{"files":[{"patch":"@@ -44,1 +44,1 @@\n-        value=\"$(grep -h ${{ inputs.var }}= make\/conf\/github-actions.conf | cut -d '=' -f 2-)\"\n+        value=\"$(grep -h '^${{ inputs.var }}'= make\/conf\/github-actions.conf | cut -d '=' -f 2-)\"\n","filename":".github\/actions\/config\/action.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+        static_libs_bundle=\"$(ls build\/*\/bundles\/jdk-*_bin-static-libs${{ inputs.debug-suffix }}.tar.gz 2> \/dev\/null || true)\"\n@@ -63,0 +64,3 @@\n+        if [[ \"$static_libs_bundle\" != \"\" ]]; then\n+          mv \"$static_libs_bundle\" \"bundles\/static-libs-${{ inputs.platform }}${{ inputs.debug-suffix }}.tar.gz\"\n+        fi\n@@ -64,1 +68,1 @@\n-        if [[ \"$jdk_bundle_zip$jdk_bundle_tar_gz$symbols_bundle$tests_bundle\" != \"\" ]]; then\n+        if [[ \"$jdk_bundle_zip$jdk_bundle_tar_gz$symbols_bundle$tests_bundle$static_libs_bundle\" != \"\" ]]; then\n","filename":".github\/actions\/upload-bundles\/action.yml","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+name: 'Build (alpine-linux)'\n+\n+on:\n+  workflow_call:\n+    inputs:\n+      platform:\n+        required: true\n+        type: string\n+      extra-conf-options:\n+        required: false\n+        type: string\n+      make-target:\n+        required: false\n+        type: string\n+        default: 'product-bundles test-bundles'\n+      debug-levels:\n+        required: false\n+        type: string\n+        default: '[ \"debug\", \"release\" ]'\n+      apk-extra-packages:\n+        required: false\n+        type: string\n+      configure-arguments:\n+        required: false\n+        type: string\n+      make-arguments:\n+        required: false\n+        type: string\n+\n+jobs:\n+  build-linux:\n+    name: build\n+    runs-on: ubuntu-22.04\n+    container:\n+      image: alpine:3.20\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        debug-level: ${{ fromJSON(inputs.debug-levels) }}\n+        include:\n+          - debug-level: debug\n+            flags: --with-debug-level=fastdebug\n+            suffix: -debug+\n+\n+    steps:\n+      - name: 'Checkout the JDK source'\n+        uses: actions\/checkout@v4\n+\n+      - name: 'Install toolchain and dependencies'\n+        run: |\n+          apk update\n+          apk add alpine-sdk alsa-lib-dev autoconf bash cups-dev cups-libs fontconfig-dev freetype-dev grep libx11-dev libxext-dev libxrandr-dev libxrender-dev libxt-dev libxtst-dev linux-headers wget zip ${{ inputs.apk-extra-packages }}\n+\n+      - name: 'Get the BootJDK'\n+        id: bootjdk\n+        uses: .\/.github\/actions\/get-bootjdk\n+        with:\n+          platform: alpine-linux-x64\n+\n+      - name: 'Configure'\n+        run: >\n+          bash configure\n+          --with-conf-name=${{ inputs.platform }}\n+          ${{ matrix.flags }}\n+          --with-version-opt=${GITHUB_ACTOR}-${GITHUB_SHA}\n+          --with-boot-jdk=${{ steps.bootjdk.outputs.path }}\n+          --with-zlib=system\n+          --with-jmod-compress=zip-1\n+          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n+          echo \"Dumping config.log:\" &&\n+          cat config.log &&\n+          exit 1)\n+\n+      - name: 'Build'\n+        id: build\n+        uses: .\/.github\/actions\/do-build\n+        with:\n+          make-target: '${{ inputs.make-target }} ${{ inputs.make-arguments }}'\n+          platform: ${{ inputs.platform }}\n+          debug-suffix: '${{ matrix.suffix }}'\n+\n+      - name: 'Upload bundles'\n+        uses: .\/.github\/actions\/upload-bundles\n+        with:\n+          platform: ${{ inputs.platform }}\n+          debug-suffix: '${{ matrix.suffix }}'\n","filename":".github\/workflows\/build-alpine-linux.yml","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -87,1 +87,1 @@\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n+            debian-repository: https:\/\/snapshot.debian.org\/archive\/debian\/20240228T034848Z\/\n","filename":".github\/workflows\/build-cross-compile.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,0 +136,4 @@\n+        env:\n+          # Only build static-libs-bundles for release builds.\n+          # For debug builds, building static-libs often exceeds disk space.\n+          STATIC_LIBS: ${{ matrix.debug-level == 'release' && 'static-libs-bundles' }}\n@@ -137,1 +141,1 @@\n-          make-target: '${{ inputs.make-target }} ${{ inputs.make-arguments }}'\n+          make-target: '${{ inputs.make-target }} ${STATIC_LIBS} ${{ inputs.make-arguments }}'\n","filename":".github\/workflows\/build-linux.yml","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        default: 'linux-x64, linux-x86, linux-x64-variants, linux-cross-compile, macos-x64, macos-aarch64, windows-x64, windows-aarch64, docs'\n+        default: 'linux-x64, linux-x86-hs, linux-x64-variants, linux-cross-compile, alpine-linux-x64, macos-x64, macos-aarch64, windows-x64, windows-aarch64, docs'\n@@ -60,0 +60,3 @@\n+    env:\n+      # List of platforms to exclude by default\n+      EXCLUDED_PLATFORMS: 'alpine-linux-x64'\n@@ -62,1 +65,1 @@\n-      linux-x86: ${{ steps.include.outputs.linux-x86 }}\n+      linux-x86-hs: ${{ steps.include.outputs.linux-x86-hs }}\n@@ -65,0 +68,1 @@\n+      alpine-linux-x64: ${{ steps.include.outputs.alpine-linux-x64 }}\n@@ -81,0 +85,4 @@\n+\n+          # Convert EXCLUDED_PLATFORMS from a comma-separated string to an array\n+          IFS=',' read -r -a excluded_array <<< \"$EXCLUDED_PLATFORMS\"\n+\n@@ -97,1 +105,7 @@\n-              # For an empty input, assume all platforms should run\n+              # For an empty input, assume all platforms should run, except those in the EXCLUDED_PLATFORMS list\n+              for excluded in \"${excluded_array[@]}\"; do\n+                if [[ \"$1\" == \"$excluded\" ]]; then\n+                  echo 'false'\n+                  return\n+                fi\n+              done\n@@ -108,0 +122,8 @@\n+\n+              # If not explicitly included, check against the EXCLUDED_PLATFORMS list\n+              for excluded in \"${excluded_array[@]}\"; do\n+                if [[ \"$1\" == \"$excluded\" ]]; then\n+                  echo 'false'\n+                  return\n+                fi\n+              done\n@@ -114,1 +136,1 @@\n-          echo \"linux-x86=$(check_platform linux-x86 linux x86)\" >> $GITHUB_OUTPUT\n+          echo \"linux-x86-hs=$(check_platform linux-x86-hs linux x86)\" >> $GITHUB_OUTPUT\n@@ -117,0 +139,1 @@\n+          echo \"alpine-linux-x64=$(check_platform alpine-linux-x64 alpine-linux x64)\" >> $GITHUB_OUTPUT\n@@ -138,2 +161,2 @@\n-  build-linux-x86:\n-    name: linux-x86\n+  build-linux-x86-hs:\n+    name: linux-x86-hs\n@@ -144,0 +167,1 @@\n+      make-target: 'hotspot'\n@@ -153,1 +177,1 @@\n-    if: needs.select.outputs.linux-x86 == 'true'\n+    if: needs.select.outputs.linux-x86-hs == 'true'\n@@ -223,0 +247,10 @@\n+  build-alpine-linux-x64:\n+    name: alpine-linux-x64\n+    needs: select\n+    uses: .\/.github\/workflows\/build-alpine-linux.yml\n+    with:\n+      platform: alpine-linux-x64\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n+    if: needs.select.outputs.alpine-linux-x64 == 'true'\n+\n@@ -303,10 +337,0 @@\n-  test-linux-x86:\n-    name: linux-x86\n-    needs:\n-      - build-linux-x86\n-    uses: .\/.github\/workflows\/test.yml\n-    with:\n-      platform: linux-x86\n-      bootjdk-platform: linux-x64\n-      runs-on: ubuntu-22.04\n-\n@@ -350,1 +374,1 @@\n-      - build-linux-x86\n+      - build-linux-x86-hs\n@@ -356,0 +380,1 @@\n+      - build-alpine-linux-x64\n@@ -361,1 +386,0 @@\n-      - test-linux-x86\n","filename":".github\/workflows\/main.yml","additions":43,"deletions":19,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-    ################################################################################\n+    ############################################################################\n@@ -316,1 +316,1 @@\n-    ################################################################################\n+    ############################################################################\n","filename":"make\/Bundles.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-     $(BUILDTOOLS_OUTPUTDIR)\/gensrc\/java.compiler.interim\/javax\/tools\/ToolProvider.java\n+    $(BUILDTOOLS_OUTPUTDIR)\/gensrc\/java.compiler.interim\/javax\/tools\/ToolProvider.java\n","filename":"make\/CompileInterimLangtools.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,6 +78,6 @@\n-       $(patsubst $(TOPDIR)\/src\/%, $(JDK_OUTPUTDIR)\/modules\/%, \\\n-         $(subst \/share\/classes,, \\\n-            $(subst _zh_TW,_zh_HK, $(filter %_zh_TW.properties, $1)) \\\n-         ) \\\n-       ), \\\n-       .properties \\\n+        $(patsubst $(TOPDIR)\/src\/%, $(JDK_OUTPUTDIR)\/modules\/%, \\\n+            $(subst \/share\/classes,, \\\n+                $(subst _zh_TW,_zh_HK, $(filter %_zh_TW.properties, $1)) \\\n+            ) \\\n+        ), \\\n+        .properties \\\n","filename":"make\/CompileJavaModules.gmk","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,2 +55,1 @@\n-        build\/tools\/depend \\\n-        , \\\n+        build\/tools\/depend, \\\n@@ -69,1 +68,1 @@\n-$(eval $(call SetupCopyFiles,COPY_NIMBUS_TEMPLATES, \\\n+$(eval $(call SetupCopyFiles, COPY_NIMBUS_TEMPLATES, \\\n@@ -72,1 +71,2 @@\n-    FILES := $(wildcard $(TOPDIR)\/src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/*.template)))\n+    FILES := $(wildcard $(TOPDIR)\/src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/*.template), \\\n+))\n@@ -76,1 +76,1 @@\n-$(eval $(call SetupCopyFiles,COPY_CLDRCONVERTER_PROPERTIES, \\\n+$(eval $(call SetupCopyFiles, COPY_CLDRCONVERTER_PROPERTIES, \\\n@@ -79,1 +79,2 @@\n-    FILES := $(wildcard $(TOPDIR)\/make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/*.properties)))\n+    FILES := $(wildcard $(TOPDIR)\/make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/*.properties), \\\n+))\n","filename":"make\/CompileToolsJdk.gmk","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-##########################################################################################\n+################################################################################\n@@ -44,1 +44,1 @@\n-$(eval $(call SetupCopyFiles,COPY_INTERIM_TZDB, \\\n+$(eval $(call SetupCopyFiles, COPY_INTERIM_TZDB, \\\n@@ -48,1 +48,2 @@\n-    MACRO := tzdb_copyfiles))\n+    MACRO := tzdb_copyfiles, \\\n+))\n@@ -50,1 +51,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/CopyInterimTZDB.gmk","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,0 +232,12 @@\n+\n+  JMOD_TARGET_OS := $(OPENJDK_BUILD_OS)\n+  ifeq ($(JMOD_TARGET_OS), macosx)\n+    JMOD_TARGET_OS := macos\n+  endif\n+\n+  JMOD_TARGET_CPU := $(OPENJDK_BUILD_CPU)\n+  ifeq ($(JMOD_TARGET_CPU), x86_64)\n+    JMOD_TARGET_CPU := amd64\n+  endif\n+\n+  JMOD_TARGET_PLATFORM := $(JMOD_TARGET_OS)-$(JMOD_TARGET_CPU)\n@@ -234,0 +246,1 @@\n+  JMOD_TARGET_PLATFORM := $(OPENJDK_MODULE_TARGET_PLATFORM)\n@@ -245,1 +258,1 @@\n-        --target-platform '$(OPENJDK_MODULE_TARGET_PLATFORM)' \\\n+        --target-platform '$(JMOD_TARGET_PLATFORM)' \\\n","filename":"make\/CreateJmods.gmk","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-  ifneq ($$($1_GROUPS),)\n+  ifneq ($$($1_GROUPS), )\n","filename":"make\/Docs.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-_:=\n+_ :=\n@@ -111,1 +111,1 @@\n-\t$(if $(all_confs), $(info Available configurations in $(build_dir):) $(foreach var,$(all_confs),$(info * $(var))),\\\n+\t$(if $(all_confs), $(info Available configurations in $(build_dir):) $(foreach var,$(all_confs),$(info * $(var))), \\\n","filename":"make\/Global.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -137,2 +137,2 @@\n-  $1_$2_DUMP_EXTRA_ARG := $(if $(filter _nocoops, $2),-XX:-UseCompressedOops,)\n-  $1_$2_DUMP_TYPE      := $(if $(filter _nocoops, $2),-NOCOOPS,)\n+  $1_$2_DUMP_EXTRA_ARG := $(if $(filter _nocoops, $2), -XX:-UseCompressedOops, )\n+  $1_$2_DUMP_TYPE      := $(if $(filter _nocoops, $2), -NOCOOPS, )\n@@ -141,1 +141,1 @@\n-  $1_$2_CDS_DUMP_FLAGS := $(CDS_DUMP_FLAGS) $(if $(filter g1gc, $(JVM_FEATURES_$1)),-XX:+UseG1GC)\n+  $1_$2_CDS_DUMP_FLAGS := $(CDS_DUMP_FLAGS) $(if $(filter g1gc, $(JVM_FEATURES_$1)), -XX:+UseG1GC)\n@@ -238,1 +238,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_GCOV_GCNO, \\\n+  $(eval $(call SetupCopyFiles, COPY_GCOV_GCNO, \\\n","filename":"make\/Images.gmk","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-ifeq ($(HAS_SPEC),)\n+ifeq ($(HAS_SPEC), )\n@@ -171,1 +171,1 @@\n-        ifneq ($(findstring $(LOG_LEVEL),info debug trace),)\n+        ifneq ($(findstring $(LOG_LEVEL), info debug trace), )\n","filename":"make\/Init.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-ifeq ($(HAS_SPEC),)\n+ifeq ($(HAS_SPEC), )\n@@ -77,1 +77,1 @@\n-    build_dir=$(CUSTOM_ROOT)\/build\n+    build_dir = $(CUSTOM_ROOT)\/build\n@@ -79,1 +79,1 @@\n-    build_dir=$(topdir)\/build\n+    build_dir = $(topdir)\/build\n@@ -81,1 +81,1 @@\n-  all_spec_files=$(wildcard $(build_dir)\/*\/spec.gmk)\n+  all_spec_files = $(wildcard $(build_dir)\/*\/spec.gmk)\n@@ -83,1 +83,1 @@\n-  all_confs=$(patsubst %\/spec.gmk, %, $(patsubst $(build_dir)\/%, %, $(all_spec_files)))\n+  all_confs = $(patsubst %\/spec.gmk, %, $(patsubst $(build_dir)\/%, %, $(all_spec_files)))\n@@ -131,1 +131,1 @@\n-    else ifneq ($$(filter-out auto fail ignore, $$(CONF_CHECK)),)\n+    else ifneq ($$(filter-out auto fail ignore, $$(CONF_CHECK)), )\n@@ -150,1 +150,1 @@\n-      ifeq ($$(wildcard $$(SPEC)),)\n+      ifeq ($$(wildcard $$(SPEC)), )\n@@ -154,1 +154,1 @@\n-      ifeq ($$(filter \/%, $$(SPEC)),)\n+      ifeq ($$(filter \/%, $$(SPEC)), )\n@@ -165,1 +165,1 @@\n-      ifeq ($$(all_spec_files),)\n+      ifeq ($$(all_spec_files), )\n@@ -183,1 +183,1 @@\n-        ifeq ($$(matching_conf),)\n+        ifeq ($$(matching_conf), )\n@@ -200,1 +200,1 @@\n-        ifeq ($$(CONF),)\n+        ifeq ($$(CONF), )\n@@ -205,1 +205,1 @@\n-          ifeq ($$(patsubst !%,,$$(CONF)),)\n+          ifeq ($$(patsubst !%,,$$(CONF)), )\n@@ -208,1 +208,1 @@\n-               $$(if $$(findstring $$(subst !,,$$(CONF)), $$(var)), ,$$(var))))\n+                $$(if $$(findstring $$(subst !,,$$(CONF)), $$(var)), ,$$(var))))\n@@ -218,1 +218,1 @@\n-            ifeq ($$(MAKE_RESTARTS),)\n+            ifeq ($$(MAKE_RESTARTS), )\n@@ -223,1 +223,1 @@\n-        ifeq ($$(matching_confs),)\n+        ifeq ($$(matching_confs), )\n@@ -231,1 +231,1 @@\n-          ifeq ($$(MAKE_RESTARTS),)\n+          ifeq ($$(MAKE_RESTARTS), )\n@@ -233,1 +233,1 @@\n-              ifneq ($$(findstring $$(LOG_LEVEL), info debug trace),)\n+              ifneq ($$(findstring $$(LOG_LEVEL), info debug trace), )\n@@ -275,1 +275,1 @@\n-    ifeq ($$(MAKE_RESTARTS),)\n+    ifeq ($$(MAKE_RESTARTS), )\n@@ -319,1 +319,1 @@\n-    topdir=$(CUSTOM_ROOT)\n+    topdir = $(CUSTOM_ROOT)\n@@ -321,1 +321,1 @@\n-    topdir=$(TOPDIR)\n+    topdir = $(TOPDIR)\n@@ -352,1 +352,1 @@\n-            $$(eval COMPARE_BUILD_PATCH=$$(strip $$(patsubst PATCH=%, %, $$(part)))) \\\n+            $$(eval COMPARE_BUILD_PATCH = $$(strip $$(patsubst PATCH=%, %, $$(part)))) \\\n@@ -355,1 +355,1 @@\n-            $$(eval COMPARE_BUILD_CONF=$$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_CONF = $$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(part))))) \\\n@@ -358,1 +358,1 @@\n-            $$(eval COMPARE_BUILD_MAKE=$$(strip $$(subst +, , $$(patsubst MAKE=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_MAKE = $$(strip $$(subst +, , $$(patsubst MAKE=%, %, $$(part))))) \\\n@@ -361,1 +361,1 @@\n-            $$(eval COMPARE_BUILD_COMP_OPTS=$$(strip $$(subst +, , $$(patsubst COMP_OPTS=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_COMP_OPTS = $$(strip $$(subst +, , $$(patsubst COMP_OPTS=%, %, $$(part))))) \\\n@@ -364,1 +364,1 @@\n-            $$(eval COMPARE_BUILD_COMP_DIR=$$(strip $$(subst +, , $$(patsubst COMP_DIR=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_COMP_DIR = $$(strip $$(subst +, , $$(patsubst COMP_DIR=%, %, $$(part))))) \\\n@@ -367,1 +367,1 @@\n-            $$(eval COMPARE_BUILD_FAIL=$$(strip $$(subst +, , $$(patsubst FAIL=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_FAIL = $$(strip $$(subst +, , $$(patsubst FAIL=%, %, $$(part))))) \\\n@@ -370,1 +370,1 @@\n-            $$(eval COMPARE_BUILD_NODRYRUN=$$(strip $$(subst +, , $$(patsubst NODRYRUN=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_NODRYRUN = $$(strip $$(subst +, , $$(patsubst NODRYRUN=%, %, $$(part))))) \\\n@@ -376,1 +376,1 @@\n-          COMPARE_BUILD_PATCH=$$(strip $$(patsubst PATCH=%, %, $$(COMPARE_BUILD)))\n+          COMPARE_BUILD_PATCH = $$(strip $$(patsubst PATCH=%, %, $$(COMPARE_BUILD)))\n@@ -378,1 +378,1 @@\n-          COMPARE_BUILD_CONF=$$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(COMPARE_BUILD))))\n+          COMPARE_BUILD_CONF = $$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(COMPARE_BUILD))))\n@@ -381,1 +381,1 @@\n-          COMPARE_BUILD_CONF=$$(strip $$(subst +, , $$(COMPARE_BUILD)))\n+          COMPARE_BUILD_CONF = $$(strip $$(subst +, , $$(COMPARE_BUILD)))\n@@ -384,1 +384,1 @@\n-          COMPARE_BUILD_PATCH=$$(strip $$(COMPARE_BUILD))\n+          COMPARE_BUILD_PATCH = $$(strip $$(COMPARE_BUILD))\n@@ -534,1 +534,1 @@\n-\t  sleep 5\\\n+\t  sleep 5 \\\n@@ -547,1 +547,1 @@\n-  BUILDTIMESDIR=$(OUTPUTDIR)\/make-support\/build-times\n+  BUILDTIMESDIR = $(OUTPUTDIR)\/make-support\/build-times\n@@ -608,1 +608,1 @@\n-  ifneq ($$(findstring $1, $$(LOG)),)\n+  ifneq ($$(findstring $1, $$(LOG)), )\n@@ -623,1 +623,1 @@\n-  ifneq ($$(findstring $1=, $$(LOG)),)\n+  ifneq ($$(findstring $1=, $$(LOG)), )\n@@ -676,1 +676,1 @@\n-  ifeq ($$(LOG_LEVEL),)\n+  ifeq ($$(LOG_LEVEL), )\n","filename":"make\/InitSupport.gmk","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+\n+include Execute.gmk\n@@ -34,2 +36,1 @@\n-# Use this file inside the image as target for make rule\n-JIMAGE_TARGET_FILE := bin\/java$(EXECUTABLE_SUFFIX)\n+INTERIM_JLINK_SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/interim-image-jlink\n@@ -45,11 +46,12 @@\n-$(INTERIM_IMAGE_DIR)\/$(JIMAGE_TARGET_FILE): $(JMODS) \\\n-    $(call DependOnVariable, INTERIM_MODULES_LIST)\n-\t$(call LogWarn, Creating interim jimage)\n-\t$(RM) -r $(INTERIM_IMAGE_DIR)\n-\t$(JLINK_TOOL) \\\n-\t    --output $(INTERIM_IMAGE_DIR) \\\n-\t    --disable-plugin generate-jli-classes \\\n-\t    --add-modules $(INTERIM_MODULES_LIST)\n-\t$(TOUCH) $@\n-\n-TARGETS += $(INTERIM_IMAGE_DIR)\/$(JIMAGE_TARGET_FILE)\n+$(eval $(call SetupExecute, jlink_interim_image, \\\n+    WARN := Creating interim jimage, \\\n+    DEPS :=  $(JMODS) $(call DependOnVariable, INTERIM_MODULES_LIST), \\\n+    OUTPUT_DIR := $(INTERIM_IMAGE_DIR), \\\n+    SUPPORT_DIR := $(INTERIM_JLINK_SUPPORT_DIR), \\\n+    PRE_COMMAND := $(RM) -r $(INTERIM_IMAGE_DIR), \\\n+    COMMAND := $(JLINK_TOOL) --output $(INTERIM_IMAGE_DIR) \\\n+        --disable-plugin generate-jli-classes \\\n+        --add-modules $(INTERIM_MODULES_LIST), \\\n+))\n+\n+TARGETS += $(jlink_interim_image)\n","filename":"make\/InterimImage.gmk","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n-    FILES := META-INF\/services\/java.nio.file.spi.FileSystemProvider))\n+    FILES := META-INF\/services\/java.nio.file.spi.FileSystemProvider, \\\n+))\n","filename":"make\/JrtfsJar.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-ifeq ($(wildcard $(SPEC)),)\n+ifeq ($(wildcard $(SPEC)), )\n@@ -281,0 +281,12 @@\n+$(eval $(call SetupTarget, hotspot-xcode-project, \\\n+    MAKEFILE := ide\/xcode\/hotspot\/CreateXcodeProject, \\\n+    TARGET := build, \\\n+    DEPS := hotspot compile-commands-hotspot jdk-image, \\\n+))\n+\n+$(eval $(call SetupTarget, open-hotspot-xcode-project, \\\n+    MAKEFILE := ide\/xcode\/hotspot\/CreateXcodeProject, \\\n+    TARGET := open, \\\n+    DEPS := hotspot-xcode-project, \\\n+))\n+\n@@ -1405,1 +1417,1 @@\n-\t$(if $(filter $(CONF_NAME),$(notdir $(OUTPUTDIR))), \\\n+\t$(if $(filter $(CONF_NAME), $(notdir $(OUTPUTDIR))), \\\n","filename":"make\/Main.gmk","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    ifeq ($(NO_RECIPES),)\n+    ifeq ($(NO_RECIPES), )\n@@ -200,2 +200,2 @@\n-  $(foreach i,2 3 4 5 6 7 8, $(if $(strip $($i)),$(strip $1)_$(strip $($i)))$(NEWLINE))\n-  $(if $(9),$(error Internal makefile error: Too many arguments to \\\n+  $(foreach i, 2 3 4 5 6 7 8, $(if $(strip $($i)),$(strip $1)_$(strip $($i)))$(NEWLINE))\n+  $(if $(9), $(error Internal makefile error: Too many arguments to \\\n","filename":"make\/MainSupport.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -107,1 +107,2 @@\n-      -timeoutHandlerTimeout:$(JTREG_FAILURE_HANDLER_TIMEOUT)\n+      -timeoutHandlerTimeout:$(JTREG_FAILURE_HANDLER_TIMEOUT) \\\n+      #\n@@ -503,1 +504,1 @@\n-    $1_GTEST_REPEAT :=--gtest_repeat=$$(GTEST_REPEAT)\n+    $1_GTEST_REPEAT := --gtest_repeat=$$(GTEST_REPEAT)\n","filename":"make\/RunTests.gmk","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-ifeq ($(filter \/%, $(lastword $(MAKEFILE_LIST))),)\n+ifeq ($(filter \/%, $(lastword $(MAKEFILE_LIST))), )\n@@ -70,1 +70,1 @@\n-      $1:=$2\n+      $1 := $2\n@@ -166,1 +166,1 @@\n-  OPENJDK_TARGET_OS_TYPE:=unix\n+  OPENJDK_TARGET_OS_TYPE := unix\n","filename":"make\/RunTestsPrebuilt.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,3 +73,3 @@\n-X:=\n-SPACE:=$(X) $(X)\n-COMMA:=,\n+X :=\n+SPACE := $(X) $(X)\n+COMMA := ,\n","filename":"make\/RunTestsPrebuiltSpec.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    $(if $(wildcard $(TOPDIR)\/$(repo)\/$(SCM_DIR)),, \\\n+    $(if $(wildcard $(TOPDIR)\/$(repo)\/$(SCM_DIR)), , \\\n@@ -75,1 +75,1 @@\n-  ################################################################################\n+  ##############################################################################\n","filename":"make\/SourceRevision.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  IMAGE_DEST_DIR=$(STATIC_LIBS_IMAGE_DIR)\/lib\n+  IMAGE_DEST_DIR = $(STATIC_LIBS_IMAGE_DIR)\/lib\n@@ -46,1 +46,1 @@\n-  IMAGE_DEST_DIR=$(STATIC_LIBS_GRAAL_IMAGE_DIR)\/lib\n+  IMAGE_DEST_DIR = $(STATIC_LIBS_GRAAL_IMAGE_DIR)\/lib\n","filename":"make\/StaticLibsImage.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-############################################################################\n+################################################################################\n","filename":"make\/TestImage.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/ToolsHotspot.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-##########################################################################################\n+################################################################################\n@@ -138,1 +138,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/ToolsJdk.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-##########################################################################################\n+################################################################################\n@@ -36,1 +36,1 @@\n-$(eval $(call SetupZipArchive,BUILD_SEC_BIN_ZIP, \\\n+$(eval $(call SetupZipArchive, BUILD_SEC_BIN_ZIP, \\\n@@ -63,1 +63,2 @@\n-    ZIP := $(IMAGES_OUTPUTDIR)\/sec-bin.zip))\n+    ZIP := $(IMAGES_OUTPUTDIR)\/sec-bin.zip, \\\n+))\n@@ -67,1 +68,1 @@\n-##########################################################################################\n+################################################################################\n@@ -73,1 +74,1 @@\n-  $(eval $(call SetupZipArchive,BUILD_SEC_WINDOWS_BIN_ZIP, \\\n+  $(eval $(call SetupZipArchive, BUILD_SEC_WINDOWS_BIN_ZIP, \\\n@@ -76,1 +77,2 @@\n-      ZIP := $(IMAGES_OUTPUTDIR)\/sec-windows-bin.zip))\n+      ZIP := $(IMAGES_OUTPUTDIR)\/sec-windows-bin.zip, \\\n+  ))\n@@ -87,1 +89,1 @@\n-  $(eval $(call SetupZipArchive,BUILD_JGSS_BIN_ZIP, \\\n+  $(eval $(call SetupZipArchive, BUILD_JGSS_BIN_ZIP, \\\n@@ -93,1 +95,2 @@\n-      ZIP := $(IMAGES_OUTPUTDIR)\/$(JGSS_ZIP_NAME)))\n+      ZIP := $(IMAGES_OUTPUTDIR)\/$(JGSS_ZIP_NAME), \\\n+  ))\n@@ -98,1 +101,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/ZipSecurity.gmk","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-SPEC:=@OUTPUTDIR@\/spec.gmk\n+SPEC := @OUTPUTDIR@\/spec.gmk\n","filename":"make\/autoconf\/Makefile.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-###############################################################################\n+################################################################################\n@@ -49,1 +49,1 @@\n-###############################################################################\n+################################################################################\n@@ -61,1 +61,1 @@\n-###############################################################################\n+################################################################################\n@@ -105,1 +105,1 @@\n-###############################################################################\n+################################################################################\n@@ -144,1 +144,1 @@\n-###############################################################################\n+################################################################################\n@@ -154,1 +154,1 @@\n-###############################################################################\n+################################################################################\n@@ -164,1 +164,1 @@\n-###############################################################################\n+################################################################################\n@@ -249,1 +249,1 @@\n-###############################################################################\n+################################################################################\n@@ -383,1 +383,1 @@\n-###############################################################################\n+################################################################################\n@@ -480,1 +480,1 @@\n-###############################################################################\n+################################################################################\n@@ -517,1 +517,1 @@\n-###############################################################################\n+################################################################################\n@@ -532,1 +532,1 @@\n-###############################################################################\n+################################################################################\n@@ -575,1 +575,1 @@\n-###############################################################################\n+################################################################################\n@@ -594,1 +594,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/basic.m4","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -31,1 +31,1 @@\n-###############################################################################\n+################################################################################\n@@ -62,1 +62,1 @@\n-###############################################################################\n+################################################################################\n@@ -119,1 +119,1 @@\n-###############################################################################\n+################################################################################\n@@ -132,1 +132,1 @@\n-   else\n+  else\n@@ -179,1 +179,1 @@\n-###############################################################################\n+################################################################################\n@@ -204,1 +204,1 @@\n-###############################################################################\n+################################################################################\n@@ -252,1 +252,1 @@\n-###############################################################################\n+################################################################################\n@@ -281,1 +281,1 @@\n-###############################################################################\n+################################################################################\n@@ -319,1 +319,1 @@\n-###############################################################################\n+################################################################################\n@@ -343,1 +343,1 @@\n-###############################################################################\n+################################################################################\n@@ -415,1 +415,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/basic_tools.m4","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-########################################################################\n+################################################################################\n@@ -52,1 +52,1 @@\n-########################################################################\n+################################################################################\n@@ -325,1 +325,1 @@\n-###############################################################################\n+################################################################################\n@@ -605,5 +605,6 @@\n-       if test \"x$with_build_jdk\" != x; then\n-         BUILD_JDK=$with_build_jdk\n-         BUILD_JDK_FOUND=maybe\n-         AC_MSG_NOTICE([Found potential Build JDK using configure arguments])\n-       fi])\n+      if test \"x$with_build_jdk\" != x; then\n+        BUILD_JDK=$with_build_jdk\n+        BUILD_JDK_FOUND=maybe\n+        AC_MSG_NOTICE([Found potential Build JDK using configure arguments])\n+      fi\n+    ])\n","filename":"make\/autoconf\/boot-jdk.m4","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-OLD_OUTPUTDIR:=@OUTPUTDIR@\n-OUTPUTDIR:=$(OLD_OUTPUTDIR)\/bootcycle-build\n+OLD_OUTPUTDIR := @OUTPUTDIR@\n+OUTPUTDIR := $(OLD_OUTPUTDIR)\/bootcycle-build\n@@ -40,1 +40,1 @@\n-JAVAC_SERVER_DIR:=$(patsubst $(OLD_OUTPUTDIR)%,$(OUTPUTDIR)%,$(JAVAC_SERVER_DIR))\n+JAVAC_SERVER_DIR := $(patsubst $(OLD_OUTPUTDIR)%,$(OUTPUTDIR)%,$(JAVAC_SERVER_DIR))\n@@ -51,1 +51,0 @@\n-\n","filename":"make\/autoconf\/bootcycle-spec.gmk.template","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/autoconf\/compare.sh.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -30,1 +30,1 @@\n-###############################################################################\n+################################################################################\n@@ -66,1 +66,1 @@\n-###############################################################################\n+################################################################################\n@@ -73,1 +73,1 @@\n-###############################################################################\n+################################################################################\n@@ -131,1 +131,1 @@\n-###############################################################################\n+################################################################################\n@@ -135,1 +135,1 @@\n-###############################################################################\n+################################################################################\n@@ -142,1 +142,1 @@\n-###############################################################################\n+################################################################################\n@@ -146,1 +146,1 @@\n-###############################################################################\n+################################################################################\n@@ -152,1 +152,1 @@\n-###############################################################################\n+################################################################################\n@@ -156,1 +156,1 @@\n-###############################################################################\n+################################################################################\n@@ -161,1 +161,1 @@\n-###############################################################################\n+################################################################################\n@@ -165,1 +165,1 @@\n-###############################################################################\n+################################################################################\n@@ -170,1 +170,1 @@\n-###############################################################################\n+################################################################################\n@@ -175,1 +175,1 @@\n-###############################################################################\n+################################################################################\n@@ -230,1 +230,1 @@\n-###############################################################################\n+################################################################################\n@@ -234,1 +234,1 @@\n-###############################################################################\n+################################################################################\n@@ -239,1 +239,1 @@\n-###############################################################################\n+################################################################################\n@@ -243,1 +243,1 @@\n-###############################################################################\n+################################################################################\n@@ -250,1 +250,1 @@\n-###############################################################################\n+################################################################################\n@@ -254,1 +254,1 @@\n-###############################################################################\n+################################################################################\n@@ -266,1 +266,1 @@\n-###############################################################################\n+################################################################################\n@@ -271,1 +271,1 @@\n-###############################################################################\n+################################################################################\n@@ -291,1 +291,1 @@\n-###############################################################################\n+################################################################################\n@@ -295,1 +295,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/configure.ac","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -238,3 +238,3 @@\n-      WARNINGS_ENABLE_ADDITIONAL=\"-Wpointer-arith -Wsign-compare \\\n-          -Wunused-function -Wundef -Wunused-value -Wreturn-type \\\n-          -Wtrampolines\"\n+      WARNINGS_ENABLE_ADDITIONAL=\"-Wpointer-arith -Wreturn-type -Wsign-compare \\\n+          -Wtrampolines -Wundef -Wunused-const-variable=1 -Wunused-function \\\n+          -Wunused-result -Wunused-value\"\n@@ -245,1 +245,3 @@\n-      DISABLED_WARNINGS=\"unused-parameter unused\"\n+      # These warnings will never be turned on, since they generate too many\n+      # false positives.\n+      DISABLED_WARNINGS=\"unused-parameter\"\n@@ -262,1 +264,3 @@\n-      DISABLED_WARNINGS=\"unknown-warning-option unused-parameter unused\"\n+      # These warnings will never be turned on, since they generate too many\n+      # false positives.\n+      DISABLED_WARNINGS=\"unknown-warning-option unused-parameter\"\n@@ -479,1 +483,1 @@\n-  ###############################################################################\n+  ##############################################################################\n@@ -513,1 +517,1 @@\n-  ###############################################################################\n+  ##############################################################################\n","filename":"make\/autoconf\/flags-cflags.m4","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -171,3 +171,3 @@\n-       test \"x${OPENJDK_$1_CPU}\" = xmipsel ||\n-       test \"x${OPENJDK_$1_CPU}\" = xmips64 ||\n-       test \"x${OPENJDK_$1_CPU}\" = xmips64el; then\n+        test \"x${OPENJDK_$1_CPU}\" = xmipsel ||\n+        test \"x${OPENJDK_$1_CPU}\" = xmips64 ||\n+        test \"x${OPENJDK_$1_CPU}\" = xmips64el; then\n","filename":"make\/autoconf\/flags-ldflags.m4","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-###############################################################################\n+################################################################################\n@@ -41,1 +41,1 @@\n-###############################################################################\n+################################################################################\n@@ -105,1 +105,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/hotspot.m4","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -84,1 +84,1 @@\n-###############################################################################\n+################################################################################\n@@ -238,2 +238,2 @@\n-         test \"x$OPENJDK_TARGET_OS\" != \"xbsd\" &&\n-         test \"x$OPENJDK_TARGET_OS\" != \"xaix\"; then\n+        test \"x$OPENJDK_TARGET_OS\" != \"xbsd\" &&\n+        test \"x$OPENJDK_TARGET_OS\" != \"xaix\"; then\n@@ -249,1 +249,1 @@\n-###############################################################################\n+################################################################################\n@@ -413,1 +413,1 @@\n-###############################################################################\n+################################################################################\n@@ -424,2 +424,2 @@\n-           test \"x$TOOLCHAIN_TYPE\" = \"xclang\" ||\n-           test \"x$TOOLCHAIN_TYPE\" = \"xmicrosoft\"; then\n+            test \"x$TOOLCHAIN_TYPE\" = \"xclang\" ||\n+            test \"x$TOOLCHAIN_TYPE\" = \"xmicrosoft\"; then\n@@ -434,1 +434,1 @@\n-           test \"x$TOOLCHAIN_TYPE\" = \"xclang\"; then\n+            test \"x$TOOLCHAIN_TYPE\" = \"xclang\"; then\n@@ -470,1 +470,1 @@\n-###############################################################################\n+################################################################################\n@@ -503,1 +503,1 @@\n-###############################################################################\n+################################################################################\n@@ -710,3 +710,2 @@\n-       [Set to disable to prevent any absolute paths from the build to end up in\n-        any of the build output. @<:@disabled in release builds, otherwise enabled@:>@])\n-      ])\n+      [Set to disable to prevent any absolute paths from the build to end up in\n+      any of the build output. @<:@disabled in release builds, otherwise enabled@:>@])])\n","filename":"make\/autoconf\/jdk-options.m4","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -96,1 +96,1 @@\n-       properties of MS Windows binaries.],\n+        properties of MS Windows binaries.],\n@@ -108,1 +108,1 @@\n-       and 'java.vm.vendor' system properties.],\n+        and 'java.vm.vendor' system properties.],\n","filename":"make\/autoconf\/jdk-version.m4","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -39,1 +39,1 @@\n-###############################################################################\n+################################################################################\n@@ -81,1 +81,1 @@\n-###############################################################################\n+################################################################################\n@@ -202,1 +202,1 @@\n-###############################################################################\n+################################################################################\n@@ -228,1 +228,1 @@\n-###############################################################################\n+################################################################################\n@@ -244,1 +244,1 @@\n-###############################################################################\n+################################################################################\n@@ -273,1 +273,1 @@\n-###############################################################################\n+################################################################################\n@@ -293,1 +293,1 @@\n-###############################################################################\n+################################################################################\n@@ -312,1 +312,1 @@\n-###############################################################################\n+################################################################################\n@@ -368,1 +368,1 @@\n-###############################################################################\n+################################################################################\n@@ -386,1 +386,1 @@\n-###############################################################################\n+################################################################################\n@@ -434,1 +434,1 @@\n-###############################################################################\n+################################################################################\n@@ -482,1 +482,1 @@\n-###############################################################################\n+################################################################################\n@@ -492,1 +492,1 @@\n-###############################################################################\n+################################################################################\n@@ -530,1 +530,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/jvm-features.m4","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-     [use libpng from build system or OpenJDK source (system, bundled) @<:@bundled@:>@])])\n+      [use libpng from build system or OpenJDK source (system, bundled) @<:@bundled@:>@])])\n","filename":"make\/autoconf\/lib-bundled.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,5 +76,5 @@\n-       The selected option applies to both build time and run time.\n-       The default behaviour can be platform dependent.\n-       If using 'system' and either the include files or libraries cannot be\n-       located automatically, then additionally specify both using\n-       --with-freetype-include and --with-freetype-lib.])])\n+      The selected option applies to both build time and run time.\n+      The default behaviour can be platform dependent.\n+      If using 'system' and either the include files or libraries cannot be\n+      located automatically, then additionally specify both using\n+      --with-freetype-include and --with-freetype-lib.])])\n@@ -98,2 +98,4 @@\n-  if (test \"x$with_freetype_include\" = \"x\" && test \"x$with_freetype_lib\" != \"x\") || \\\n-     (test \"x$with_freetype_include\" != \"x\" && test \"x$with_freetype_lib\" = \"x\"); then\n+  if (test \"x$with_freetype_include\" = \"x\" && \\\n+      test \"x$with_freetype_lib\" != \"x\") || \\\n+      (test \"x$with_freetype_include\" != \"x\" && \\\n+      test \"x$with_freetype_lib\" = \"x\"); then\n@@ -129,2 +131,2 @@\n-     (test \"x$OPENJDK_TARGET_OS\" = \"xwindows\" || \\\n-     test \"x$OPENJDK_TARGET_OS\" = \"xmacosx\"); then\n+      (test \"x$OPENJDK_TARGET_OS\" = \"xwindows\" || \\\n+      test \"x$OPENJDK_TARGET_OS\" = \"xmacosx\"); then\n","filename":"make\/autoconf\/lib-freetype.m4","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -166,2 +166,2 @@\n-     test -e $BINUTILS_INSTALL_DIR\/lib\/libopcodes.a && \\\n-     test -e $BINUTILS_INSTALL_DIR\/lib\/libiberty.a; then\n+      test -e $BINUTILS_INSTALL_DIR\/lib\/libopcodes.a && \\\n+      test -e $BINUTILS_INSTALL_DIR\/lib\/libiberty.a; then\n@@ -270,2 +270,4 @@\n-       test -e $BINUTILS_INSTALL_DIR\/lib\/libopcodes.a && \\\n-       (test -e $BINUTILS_INSTALL_DIR\/lib\/libiberty.a || test -e $BINUTILS_INSTALL_DIR\/lib64\/libiberty.a || test -e $BINUTILS_INSTALL_DIR\/lib32\/libiberty.a); then\n+        test -e $BINUTILS_INSTALL_DIR\/lib\/libopcodes.a && \\\n+        (test -e $BINUTILS_INSTALL_DIR\/lib\/libiberty.a || \\\n+        test -e $BINUTILS_INSTALL_DIR\/lib64\/libiberty.a || \\\n+        test -e $BINUTILS_INSTALL_DIR\/lib32\/libiberty.a); then\n","filename":"make\/autoconf\/lib-hsdis.m4","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-###############################################################################\n+################################################################################\n@@ -77,1 +77,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/lib-tests.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,6 +102,6 @@\n-         test \"x$OPENJDK_$1_CPU\" = xm68k ||\n-         test \"x$OPENJDK_$1_CPU\" = xmips ||\n-         test \"x$OPENJDK_$1_CPU\" = xmipsel ||\n-         test \"x$OPENJDK_$1_CPU\" = xppc ||\n-         test \"x$OPENJDK_$1_CPU\" = xsh ||\n-         test \"x$OPENJDK_$1_CPU\" = xriscv32); then\n+        test \"x$OPENJDK_$1_CPU\" = xm68k ||\n+        test \"x$OPENJDK_$1_CPU\" = xmips ||\n+        test \"x$OPENJDK_$1_CPU\" = xmipsel ||\n+        test \"x$OPENJDK_$1_CPU\" = xppc ||\n+        test \"x$OPENJDK_$1_CPU\" = xsh ||\n+        test \"x$OPENJDK_$1_CPU\" = xriscv32); then\n","filename":"make\/autoconf\/libraries.m4","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-       [build 32-bit or 64-bit binaries (for platforms that support it), e.g. --with-target-bits=32 @<:@guessed@:>@])])\n+      [build 32-bit or 64-bit binaries (for platforms that support it), e.g. --with-target-bits=32 @<:@guessed@:>@])])\n@@ -668,1 +668,1 @@\n-       [Suppress the error when configuring for a deprecated port @<:@no@:>@])])\n+      [Suppress the error when configuring for a deprecated port @<:@no@:>@])])\n@@ -681,1 +681,1 @@\n-  ###############################################################################\n+  ##############################################################################\n@@ -696,1 +696,1 @@\n-  ###############################################################################\n+  ##############################################################################\n@@ -742,1 +742,1 @@\n-  ###############################################################################\n+  ##############################################################################\n","filename":"make\/autoconf\/platform.m4","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-ifneq ($(COMPANY_NAME),)\n+ifneq ($(COMPANY_NAME), )\n@@ -291,1 +291,1 @@\n-ifneq ($(VENDOR_URL),)\n+ifneq ($(VENDOR_URL), )\n@@ -294,1 +294,1 @@\n-ifneq ($(VENDOR_URL_BUG),)\n+ifneq ($(VENDOR_URL_BUG), )\n@@ -297,1 +297,1 @@\n-ifneq ($(VENDOR_URL_VM_BUG),)\n+ifneq ($(VENDOR_URL_VM_BUG), )\n@@ -807,2 +807,0 @@\n-####################################################\n-#\n@@ -810,2 +808,0 @@\n-#\n-\n@@ -824,2 +820,0 @@\n-####################################################\n-#\n@@ -827,2 +821,0 @@\n-#\n-\n","filename":"make\/autoconf\/spec.gmk.template","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-########################################################################\n+################################################################################\n@@ -33,1 +33,1 @@\n-########################################################################\n+################################################################################\n","filename":"make\/autoconf\/toolchain.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-       pass to vcvarsall.bat (Windows only)])])\n+      pass to vcvarsall.bat (Windows only)])])\n","filename":"make\/autoconf\/toolchain_microsoft.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-###############################################################################\n+################################################################################\n@@ -103,1 +103,1 @@\n-###############################################################################\n+################################################################################\n@@ -124,1 +124,1 @@\n-###############################################################################\n+################################################################################\n@@ -140,1 +140,1 @@\n-###############################################################################\n+################################################################################\n@@ -156,1 +156,1 @@\n-###############################################################################\n+################################################################################\n@@ -168,1 +168,1 @@\n-###############################################################################\n+################################################################################\n@@ -180,1 +180,1 @@\n-###############################################################################\n+################################################################################\n@@ -207,1 +207,1 @@\n-###############################################################################\n+################################################################################\n@@ -234,1 +234,1 @@\n-###############################################################################\n+################################################################################\n@@ -262,1 +262,1 @@\n-###############################################################################\n+################################################################################\n@@ -276,1 +276,1 @@\n-###############################################################################\n+################################################################################\n@@ -297,1 +297,1 @@\n-###############################################################################\n+################################################################################\n@@ -307,1 +307,1 @@\n-###############################################################################\n+################################################################################\n@@ -317,1 +317,1 @@\n-###############################################################################\n+################################################################################\n@@ -332,1 +332,1 @@\n-###############################################################################\n+################################################################################\n@@ -474,1 +474,1 @@\n-###############################################################################\n+################################################################################\n@@ -578,1 +578,1 @@\n-###############################################################################\n+################################################################################\n@@ -813,1 +813,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/util.m4","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -39,1 +39,1 @@\n-###############################################################################\n+################################################################################\n@@ -52,1 +52,1 @@\n-###############################################################################\n+################################################################################\n@@ -121,1 +121,1 @@\n-##############################################################################\n+################################################################################\n@@ -139,1 +139,1 @@\n-###############################################################################\n+################################################################################\n@@ -173,1 +173,1 @@\n-###############################################################################\n+################################################################################\n@@ -292,1 +292,1 @@\n-###############################################################################\n+################################################################################\n@@ -372,1 +372,1 @@\n-###############################################################################\n+################################################################################\n@@ -439,1 +439,1 @@\n-###############################################################################\n+################################################################################\n@@ -455,1 +455,1 @@\n-###############################################################################\n+################################################################################\n@@ -465,1 +465,1 @@\n-###############################################################################\n+################################################################################\n@@ -476,1 +476,1 @@\n-###############################################################################\n+################################################################################\n@@ -488,1 +488,1 @@\n-###############################################################################\n+################################################################################\n@@ -500,1 +500,1 @@\n-###############################################################################\n+################################################################################\n@@ -513,1 +513,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/util_paths.m4","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n","filename":"make\/common\/CopyFiles.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n","filename":"make\/common\/Execute.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -139,0 +139,1 @@\n+          $(CHMOD) u+w '$(call DecodeSpace, $@)'; \\\n@@ -191,0 +192,5 @@\n+define copy-and-chmod-executable\n+\t$(install-file)\n+\t$(CHMOD) a+rx $@\n+endef\n+\n@@ -284,1 +290,1 @@\n-    $(eval CacheFindFiles_NEW_DIRS := $$(filter-out $$(addsuffix \/%,\\\n+    $(eval CacheFindFiles_NEW_DIRS := $$(filter-out $$(addsuffix \/%, \\\n","filename":"make\/common\/FileUtils.gmk","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-   ) \\\n+  ) \\\n","filename":"make\/common\/FindTests.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -35,1 +35,1 @@\n-FALSE_FIND_PATTERN:=-name FILE_NAME_THAT_DOESNT_EXIST\n+FALSE_FIND_PATTERN := -name FILE_NAME_THAT_DOESNT_EXIST\n@@ -43,1 +43,1 @@\n-#   DEPENDENCIES:=List of dependencies for the jar target. If left empty,\n+#   DEPENDENCIES List of dependencies for the jar target. If left empty,\n@@ -47,12 +47,12 @@\n-#   SRCS:=List of directories in where to find files to add to archive\n-#   BIN:=Directory where to store build control files\n-#   SUFFIXES:=File suffixes to include in jar\n-#   INCLUDES:=List of directories\/packages in SRCS that should be included\n-#   EXCLUDES:=List of directories\/packages in SRCS that should be excluded\n-#   EXCLUDE_FILES:=List of files in SRCS that should be excluded\n-#   EXTRA_FILES:=List of files in SRCS that should be included regardless of suffix match.\n-#   JAR:=Jar file to create\n-#   MANIFEST:=Optional manifest file template.\n-#   JARMAIN:=Optional main class to add to manifest\n-#   JARINDEX:=true means generate the index in the jar file.\n-#   SKIP_METAINF:=Set to prevent contents of an META-INF directory to be automatically\n+#   SRCS List of directories in where to find files to add to archive\n+#   BIN Directory where to store build control files\n+#   SUFFIXES File suffixes to include in jar\n+#   INCLUDES List of directories\/packages in SRCS that should be included\n+#   EXCLUDES List of directories\/packages in SRCS that should be excluded\n+#   EXCLUDE_FILES List of files in SRCS that should be excluded\n+#   EXTRA_FILES List of files in SRCS that should be included regardless of suffix match.\n+#   JAR Jar file to create\n+#   MANIFEST Optional manifest file template.\n+#   JARMAIN Optional main class to add to manifest\n+#   JARINDEX true means generate the index in the jar file.\n+#   SKIP_METAINF Set to prevent contents of an META-INF directory to be automatically\n@@ -60,1 +60,1 @@\n-#   EXTRA_MANIFEST_ATTR:=Extra attribute to add to manifest.\n+#   EXTRA_MANIFEST_ATTR Extra attribute to add to manifest.\n@@ -62,1 +62,1 @@\n-#   JAR_CMD:=Optionally override the jar command to use when creating the archive.\n+#   JAR_CMD Optionally override the jar command to use when creating the archive.\n@@ -66,2 +66,2 @@\n-  $1_JARMAIN:=$(strip $$($1_JARMAIN))\n-  $1_JARNAME:=$$(notdir $$($1_JAR))\n+  $1_JARMAIN := $(strip $$($1_JARMAIN))\n+  $1_JARNAME := $$(notdir $$($1_JAR))\n@@ -70,3 +70,3 @@\n-  $1_MANIFEST_FILE:=$$($1_BIN)\/_the.$$($1_JARNAME)_manifest\n-  $1_DELETESS_FILE:=$$($1_BIN)\/_the.$$($1_JARNAME)_deletess\n-  $1_DELETES_FILE:=$$($1_BIN)\/_the.$$($1_JARNAME)_deletes\n+  $1_MANIFEST_FILE := $$($1_BIN)\/_the.$$($1_JARNAME)_manifest\n+  $1_DELETESS_FILE := $$($1_BIN)\/_the.$$($1_JARNAME)_deletess\n+  $1_DELETES_FILE := $$($1_BIN)\/_the.$$($1_JARNAME)_deletes\n@@ -75,1 +75,1 @@\n-  ifeq (,$$($1_SUFFIXES))\n+  ifeq ($$($1_SUFFIXES), )\n@@ -77,1 +77,1 @@\n-    $1_SUFFIXES:=.class\n+    $1_SUFFIXES := .class\n@@ -80,1 +80,1 @@\n-  $1_FIND_PATTERNS:=$(FALSE_FIND_PATTERN) $$(patsubst %,$(SPACE)-o$(SPACE)-name$(SPACE)$(DQUOTE)*%$(DQUOTE),$$($1_SUFFIXES))\n+  $1_FIND_PATTERNS := $(FALSE_FIND_PATTERN) $$(patsubst %,$(SPACE)-o$(SPACE)-name$(SPACE)$(DQUOTE)*%$(DQUOTE),$$($1_SUFFIXES))\n@@ -84,2 +84,2 @@\n-  ifneq (,$$($1_INCLUDES))\n-    $1_GREP_INCLUDE_PATTERNS:=$$(call EscapeDollar, \\\n+  ifneq ($$($1_INCLUDES), )\n+    $1_GREP_INCLUDE_PATTERNS := $$(call EscapeDollar, \\\n@@ -88,2 +88,2 @@\n-    ifeq ($$(word 20,$$($1_GREP_INCLUDE_PATTERNS)),)\n-      $1_GREP_INCLUDES:=| ( $(GREP) $$(patsubst %,$(SPACE)-e$(SPACE)$(DQUOTE)%$(DQUOTE),$$($1_GREP_INCLUDE_PATTERNS)) \\\n+    ifeq ($$(word 20, $$($1_GREP_INCLUDE_PATTERNS)), )\n+      $1_GREP_INCLUDES := | ( $(GREP) $$(patsubst %,$(SPACE)-e$(SPACE)$(DQUOTE)%$(DQUOTE),$$($1_GREP_INCLUDE_PATTERNS)) \\\n@@ -93,1 +93,1 @@\n-          $$(eval $$(call ListPathsSafely,$1_GREP_INCLUDE_PATTERNS, \\\n+          $$(eval $$(call ListPathsSafely, $1_GREP_INCLUDE_PATTERNS, \\\n@@ -95,1 +95,1 @@\n-      $1_GREP_INCLUDES:=| ( $(GREP) -f $$($1_BIN)\/_the.$$($1_JARNAME)_include \\\n+      $1_GREP_INCLUDES := | ( $(GREP) -f $$($1_BIN)\/_the.$$($1_JARNAME)_include \\\n@@ -99,3 +99,3 @@\n-  ifneq (,$$($1_EXCLUDES)$$($1_EXCLUDE_FILES))\n-    $1_GREP_EXCLUDE_PATTERNS:=$$(call EscapeDollar, \\\n-        $$(foreach src,$$($1_SRCS),$$(addprefix $$(src)\/, \\\n+  ifneq ($$($1_EXCLUDES)$$($1_EXCLUDE_FILES), )\n+    $1_GREP_EXCLUDE_PATTERNS := $$(call EscapeDollar, \\\n+        $$(foreach src, $$($1_SRCS), $$(addprefix $$(src)\/, \\\n@@ -104,2 +104,2 @@\n-    ifeq ($$(word 20,$$($1_GREP_EXCLUDE_PATTERNS)),)\n-      $1_GREP_EXCLUDES:=| ( $(GREP) -v $$(patsubst %,$(SPACE)-e$(SPACE)$(DQUOTE)%$(DQUOTE),$$($1_GREP_EXCLUDE_PATTERNS)) \\\n+    ifeq ($$(word 20, $$($1_GREP_EXCLUDE_PATTERNS)), )\n+      $1_GREP_EXCLUDES := | ( $(GREP) -v $$(patsubst %,$(SPACE)-e$(SPACE)$(DQUOTE)%$(DQUOTE),$$($1_GREP_EXCLUDE_PATTERNS)) \\\n@@ -109,1 +109,1 @@\n-          $$(eval $$(call ListPathsSafely,$1_GREP_EXCLUDE_PATTERNS, \\\n+          $$(eval $$(call ListPathsSafely, $1_GREP_EXCLUDE_PATTERNS, \\\n@@ -111,1 +111,1 @@\n-      $1_GREP_EXCLUDES:=| ( $(GREP) -v -f $$($1_BIN)\/_the.$$($1_JARNAME)_exclude \\\n+      $1_GREP_EXCLUDES := | ( $(GREP) -v -f $$($1_BIN)\/_the.$$($1_JARNAME)_exclude \\\n@@ -117,1 +117,1 @@\n-  ifneq (,$$($1_JARINDEX))\n+  ifneq ($$($1_JARINDEX), )\n@@ -130,4 +130,4 @@\n-    $1_DEPENDENCIES:=$$(filter $$(addprefix %,$$($1_SUFFIXES)), \\\n-        $$(call FindFiles,$$($1_SRCS)))\n-    ifneq (,$$($1_GREP_INCLUDE_PATTERNS))\n-      $1_DEPENDENCIES:=$$(filter $$(addsuffix %,$$($1_GREP_INCLUDE_PATTERNS)),$$($1_DEPENDENCIES))\n+    $1_DEPENDENCIES := $$(filter $$(addprefix %, $$($1_SUFFIXES)), \\\n+        $$(call FindFiles, $$($1_SRCS)))\n+    ifneq ($$($1_GREP_INCLUDE_PATTERNS), )\n+      $1_DEPENDENCIES := $$(filter $$(addsuffix %, $$($1_GREP_INCLUDE_PATTERNS)), $$($1_DEPENDENCIES))\n@@ -135,2 +135,2 @@\n-    ifneq (,$$($1_GREP_EXCLUDE_PATTERNS))\n-      $1_DEPENDENCIES:=$$(filter-out $$(addsuffix %,$$($1_GREP_EXCLUDE_PATTERNS)),$$($1_DEPENDENCIES))\n+    ifneq ($$($1_GREP_EXCLUDE_PATTERNS), )\n+      $1_DEPENDENCIES := $$(filter-out $$(addsuffix %, $$($1_GREP_EXCLUDE_PATTERNS)), $$($1_DEPENDENCIES))\n@@ -139,1 +139,1 @@\n-    $1_DEPENDENCIES+=$$(wildcard $$(foreach src, $$($1_SRCS), \\\n+    $1_DEPENDENCIES += $$(wildcard $$(foreach src, $$($1_SRCS), \\\n@@ -141,2 +141,2 @@\n-    ifeq (,$$($1_SKIP_METAINF))\n-      $1_DEPENDENCIES+=$$(call FindFiles,$$(wildcard $$(addsuffix \/META-INF,$$($1_SRCS))))\n+    ifeq ($$($1_SKIP_METAINF), )\n+      $1_DEPENDENCIES += $$(call FindFiles, $$(wildcard $$(addsuffix \/META-INF, $$($1_SRCS))))\n@@ -159,2 +159,2 @@\n-  $1_CAPTURE_EXTRA_FILES=\\\n-      $$(eval $1_EXTRA_FILES_RESOLVED:=$$(call DoubleDollar, \\\n+  $1_CAPTURE_EXTRA_FILES = \\\n+      $$(eval $1_EXTRA_FILES_RESOLVED := $$(call DoubleDollar, \\\n@@ -164,1 +164,1 @@\n-        $$(eval $$(call ListPathsSafely,$1_EXTRA_FILES_RESOLVED, \\\n+        $$(eval $$(call ListPathsSafely, $1_EXTRA_FILES_RESOLVED, \\\n@@ -166,1 +166,1 @@\n-        $(SED) $$(foreach src,$$($1_SRCS), -e 's|$$(src)\/|-C $$(src) |g') \\\n+        $(SED) $$(foreach src, $$($1_SRCS), -e 's|$$(src)\/|-C $$(src) |g') \\\n@@ -173,1 +173,1 @@\n-  $1_CAPTURE_CONTENTS=\\\n+  $1_CAPTURE_CONTENTS = \\\n@@ -175,1 +175,1 @@\n-      $$(foreach src,$$($1_SRCS), \\\n+      $$(foreach src, $$($1_SRCS), \\\n@@ -183,2 +183,2 @@\n-  ifeq (,$$($1_SKIP_METAINF))\n-    $1_CAPTURE_METAINF =$$(foreach src,$$($1_SRCS), \\\n+  ifeq ($$($1_SKIP_METAINF), )\n+    $1_CAPTURE_METAINF = $$(foreach src, $$($1_SRCS), \\\n@@ -191,1 +191,1 @@\n-  $1_CAPTURE_DELETES=$$(foreach src,$$($1_SRCS),($(FIND) $$(src) -name _the.package.deleted -newer $$@ \\\n+  $1_CAPTURE_DELETES = $$(foreach src, $$($1_SRCS), ($(FIND) $$(src) -name _the.package.deleted -newer $$@ \\\n@@ -195,1 +195,1 @@\n-  $1_UPDATE_CONTENTS=\\\n+  $1_UPDATE_CONTENTS = \\\n@@ -203,1 +203,1 @@\n-  $1_SCAPTURE_CONTENTS=\\\n+  $1_SCAPTURE_CONTENTS = \\\n@@ -205,1 +205,1 @@\n-      $$(foreach src,$$($1_SRCS), \\\n+      $$(foreach src, $$($1_SRCS), \\\n@@ -212,2 +212,2 @@\n-  ifeq (,$$($1_SKIP_METAINF))\n-    $1_SCAPTURE_METAINF=$$(foreach src,$$($1_SRCS), \\\n+  ifeq ($$($1_SKIP_METAINF), )\n+    $1_SCAPTURE_METAINF = $$(foreach src, $$($1_SRCS), \\\n@@ -218,1 +218,1 @@\n-  $1_SUPDATE_CONTENTS=\\\n+  $1_SUPDATE_CONTENTS = \\\n@@ -223,1 +223,1 @@\n-  $1_NAME:=$$(subst $$(OUTPUTDIR)\/,,$$($1_JAR))\n+  $1_NAME := $$(subst $$(OUTPUTDIR)\/,,$$($1_JAR))\n@@ -231,1 +231,1 @@\n-  ifneq (,$$($1_CHECK_COMPRESS_JAR))\n+  ifneq ($$($1_CHECK_COMPRESS_JAR), )\n","filename":"make\/common\/JarArchive.gmk","additions":65,"deletions":65,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -60,1 +60,1 @@\n-  $2_TARGET:=$2\n+  $2_TARGET := $2\n@@ -62,1 +62,1 @@\n-  $$(foreach i,$$($1_SRC),$$(eval $$(call remove_string,$$i,$2_TARGET)))\n+  $$(foreach i, $$($1_SRC), $$(eval $$(call remove_string,$$i,$2_TARGET)))\n@@ -101,1 +101,1 @@\n-  $2_TARGET:=$2\n+  $2_TARGET := $2\n@@ -103,1 +103,1 @@\n-  $$(foreach i,$$($1_SRC),$$(eval $$(call remove_string,$$i,$2_TARGET)))\n+  $$(foreach i, $$($1_SRC), $$(eval $$(call remove_string,$$i,$2_TARGET)))\n@@ -141,3 +141,3 @@\n-#   SMALL_JAVA:=set to false to run javac as a \"big\" java app\n-#   COMPILER:=bootjdk or interim, the latter is default\n-#   TARGET_RELEASE:=javac flags to set the targeted jdk release (-source\/-target or --release)\n+#   SMALL_JAVA set to false to run javac as a \"big\" java app\n+#   COMPILER bootjdk or interim, the latter is default\n+#   TARGET_RELEASE javac flags to set the targeted jdk release (-source\/-target or --release)\n@@ -145,4 +145,4 @@\n-#   JAVAC_FLAGS:=javac flags to append to the default ones.\n-#   JAVA_FLAGS:=flags to be appended to the java launching the compiler\n-#   DISABLED_WARNINGS:=list of Xlint warnings that should be disabled\n-#   SRC:=one or more directories to search for sources. The order of the source roots\n+#   JAVAC_FLAGS javac flags to append to the default ones.\n+#   JAVA_FLAGS flags to be appended to the java launching the compiler\n+#   DISABLED_WARNINGS list of Xlint warnings that should be disabled\n+#   SRC one or more directories to search for sources. The order of the source roots\n@@ -150,12 +150,12 @@\n-#   BIN:=store classes here\n-#   MODULE:=Name of module being compiled. If set, classes are put in BIN\/MODULE.\n-#   CLASSPATH:=a list of additional entries to set as classpath to javac\n-#   INCLUDES:=myapp.foo means will only compile java files in myapp.foo or any of its sub-packages.\n-#   EXCLUDES:=myapp.foo means will do not compile java files in myapp.foo or any of its sub-packages.\n-#   COPY:=.prp means copy all prp files to the corresponding package in BIN.\n-#   COPY_FILES:=myapp\/foo\/setting.txt means copy this file over to the package myapp\/foo\n-#   CLEAN:=.properties means copy and clean all properties file to the corresponding package in BIN.\n-#   CLEAN_FILES:=myapp\/foo\/setting.txt means clean this file over to the package myapp\/foo\n-#   SRCZIP:=Create a src.zip based on the found sources and copied files.\n-#   INCLUDE_FILES:=\"com\/sun\/SolarisFoobar.java\" means only compile this file!\n-#   EXCLUDE_FILES:=\"com\/sun\/SolarisFoobar.java\" means do not compile this particular file!\n+#   BIN store classes here\n+#   MODULE Name of module being compiled. If set, classes are put in BIN\/MODULE.\n+#   CLASSPATH a list of additional entries to set as classpath to javac\n+#   INCLUDES myapp.foo means will only compile java files in myapp.foo or any of its sub-packages.\n+#   EXCLUDES myapp.foo means will do not compile java files in myapp.foo or any of its sub-packages.\n+#   COPY .prp means copy all prp files to the corresponding package in BIN.\n+#   COPY_FILES myapp\/foo\/setting.txt means copy this file over to the package myapp\/foo\n+#   CLEAN .properties means copy and clean all properties file to the corresponding package in BIN.\n+#   CLEAN_FILES myapp\/foo\/setting.txt means clean this file over to the package myapp\/foo\n+#   SRCZIP Create a src.zip based on the found sources and copied files.\n+#   INCLUDE_FILES \"com\/sun\/SolarisFoobar.java\" means only compile this file!\n+#   EXCLUDE_FILES \"com\/sun\/SolarisFoobar.java\" means do not compile this particular file!\n@@ -163,1 +163,1 @@\n-#   EXTRA_FILES:=List of extra source files to include in compilation. Can be used to\n+#   EXTRA_FILES List of extra source files to include in compilation. Can be used to\n@@ -165,4 +165,4 @@\n-#   HEADERS:=path to directory where all generated c-headers are written.\n-#   DEPENDS:=Extra dependency\n-#   KEEP_DUPS:=Do not remove duplicate file names from different source roots.\n-#   FAIL_NO_SRC:=Set to false to not fail the build if no source files are found,\n+#   HEADERS path to directory where all generated c-headers are written.\n+#   DEPENDS Extra dependency\n+#   KEEP_DUPS Do not remove duplicate file names from different source roots.\n+#   FAIL_NO_SRC Set to false to not fail the build if no source files are found,\n@@ -170,1 +170,1 @@\n-#   CREATE_API_DIGEST:=Set to true to use a javac plugin to generate a public API\n+#   CREATE_API_DIGEST Set to true to use a javac plugin to generate a public API\n@@ -173,1 +173,1 @@\n-#   KEEP_ALL_TRANSLATIONS:=Set to true to skip translation filtering\n+#   KEEP_ALL_TRANSLATIONS Set to true to skip translation filtering\n@@ -178,1 +178,1 @@\n-  ifeq ($$($1_BIN),)\n+  ifeq ($$($1_BIN), )\n@@ -258,1 +258,1 @@\n-       $1_JAVAC_CMD := $$(JAVA_SMALL) $$($1_JAVA_FLAGS) $$($1_JAVAC)\n+        $1_JAVAC_CMD := $$(JAVA_SMALL) $$($1_JAVA_FLAGS) $$($1_JAVAC)\n@@ -260,1 +260,1 @@\n-       $1_JAVAC_CMD := $$(JAVA) $$($1_JAVA_FLAGS) $$($1_JAVAC)\n+        $1_JAVAC_CMD := $$(JAVA) $$($1_JAVA_FLAGS) $$($1_JAVAC)\n@@ -285,2 +285,20 @@\n-  ifneq ($$($1_CLASSPATH), )\n-    $1_FLAGS += -cp $$(call PathList, $$($1_CLASSPATH))\n+  $1_AUGMENTED_CLASSPATH := $$($1_CLASSPATH)\n+  $1_API_TARGET := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_pubapi\n+  $1_API_INTERNAL := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_internalapi\n+\n+  ifeq ($$($1_CREATE_API_DIGEST), true)\n+    $1_API_DIGEST_FLAGS := \\\n+        -Xplugin:\"depend $$($1_API_TARGET)\" \\\n+        \"-XDinternalAPIPath=$$($1_API_INTERNAL)\" \\\n+        \"-XDLOG_LEVEL=$(LOG_LEVEL)\" \\\n+        #\n+\n+    $1_EXTRA_DEPS := $$(BUILDTOOLS_OUTPUTDIR)\/depend\/_the.COMPILE_DEPEND_batch\n+    # including the compilation output on the classpath, so that incremental\n+    # compilations in unnamed module can refer to other classes from the same\n+    # source root, which are not being recompiled in this compilation:\n+    $1_AUGMENTED_CLASSPATH += $$(BUILDTOOLS_OUTPUTDIR)\/depend $$($1_BIN)\n+  endif\n+\n+  ifneq ($$($1_AUGMENTED_CLASSPATH), )\n+    $1_FLAGS += -cp $$(call PathList, $$($1_AUGMENTED_CLASSPATH))\n@@ -298,1 +316,1 @@\n-  $$(call MakeDir,$$($1_BIN))\n+  $$(call MakeDir, $$($1_BIN))\n@@ -354,1 +372,1 @@\n-    $1_ALL_COPIES := $$(filter $$(addsuffix \/META-INF%,$$($1_SRC)),$$($1_ALL_SRCS))\n+    $1_ALL_COPIES := $$(filter $$(addsuffix \/META-INF%, $$($1_SRC)), $$($1_ALL_SRCS))\n@@ -356,1 +374,1 @@\n-    ifneq (,$$($1_COPY)$$($1_COPY_FILES))\n+    ifneq ($$($1_COPY)$$($1_COPY_FILES), )\n@@ -358,1 +376,1 @@\n-      $1_ALL_COPIES += $$(filter $$(addprefix %,$$($1_COPY)),$$($1_ALL_SRCS))\n+      $1_ALL_COPIES += $$(filter $$(addprefix %, $$($1_COPY)), $$($1_ALL_SRCS))\n@@ -363,2 +381,2 @@\n-    ifneq (,$$($1_INCLUDE_PATTERN))\n-      $1_ALL_COPIES := $$(filter $$($1_INCLUDE_PATTERN),$$($1_ALL_COPIES))\n+    ifneq ($$($1_INCLUDE_PATTERN), )\n+      $1_ALL_COPIES := $$(filter $$($1_INCLUDE_PATTERN), $$($1_ALL_COPIES))\n@@ -366,2 +384,2 @@\n-    ifneq (,$$($1_EXCLUDE_PATTERN))\n-      $1_ALL_COPIES := $$(filter-out $$($1_EXCLUDE_PATTERN),$$($1_ALL_COPIES))\n+    ifneq ($$($1_EXCLUDE_PATTERN), )\n+      $1_ALL_COPIES := $$(filter-out $$($1_EXCLUDE_PATTERN), $$($1_ALL_COPIES))\n@@ -373,1 +391,1 @@\n-    ifneq (,$$($1_ALL_COPIES))\n+    ifneq ($$($1_ALL_COPIES), )\n@@ -375,2 +393,2 @@\n-      $1_ALL_COPY_TARGETS:=\n-          $$(foreach i,$$($1_ALL_COPIES),$$(eval $$(call add_file_to_copy,$1,$$i)))\n+      $1_ALL_COPY_TARGETS :=\n+          $$(foreach i, $$($1_ALL_COPIES), $$(eval $$(call add_file_to_copy,$1,$$i)))\n@@ -381,1 +399,1 @@\n-    ifneq (,$$($1_CLEAN)$$($1_CLEAN_FILES))\n+    ifneq ($$($1_CLEAN)$$($1_CLEAN_FILES), )\n@@ -383,1 +401,1 @@\n-      $1_ALL_CLEANS := $$(filter $$(addprefix %,$$($1_CLEAN)),$$($1_ALL_SRCS))\n+      $1_ALL_CLEANS := $$(filter $$(addprefix %, $$($1_CLEAN)), $$($1_ALL_SRCS))\n@@ -387,2 +405,2 @@\n-      ifneq (,$$($1_INCLUDE_PATTERN))\n-        $1_ALL_CLEANS := $$(filter $$($1_INCLUDE_PATTERN),$$($1_ALL_CLEANS))\n+      ifneq ($$($1_INCLUDE_PATTERN), )\n+        $1_ALL_CLEANS := $$(filter $$($1_INCLUDE_PATTERN), $$($1_ALL_CLEANS))\n@@ -390,2 +408,2 @@\n-      ifneq (,$$($1_EXCLUDE_PATTERN))\n-        $1_ALL_CLEANS := $$(filter-out $$($1_EXCLUDE_PATTERN),$$($1_ALL_CLEANS))\n+      ifneq ($$($1_EXCLUDE_PATTERN), )\n+        $1_ALL_CLEANS := $$(filter-out $$($1_EXCLUDE_PATTERN), $$($1_ALL_CLEANS))\n@@ -397,1 +415,1 @@\n-      ifneq (,$$($1_ALL_CLEANS))\n+      ifneq ($$($1_ALL_CLEANS), )\n@@ -399,2 +417,2 @@\n-        $1_ALL_COPY_CLEAN_TARGETS:=\n-            $$(foreach i,$$($1_ALL_CLEANS),$$(eval $$(call add_file_to_clean,$1,$$i)))\n+        $1_ALL_COPY_CLEAN_TARGETS :=\n+            $$(foreach i, $$($1_ALL_CLEANS), $$(eval $$(call add_file_to_clean,$1,$$i)))\n@@ -407,1 +425,1 @@\n-    $1_REWRITE_INTO_CLASSES:=$$(foreach i,$$($1_SRC),-e 's|$$i\/||g') -e 's|\/|.|g' -e 's|.java$$$$||g'\n+    $1_REWRITE_INTO_CLASSES := $$(foreach i, $$($1_SRC), -e 's|$$i\/||g') -e 's|\/|.|g' -e 's|.java$$$$||g'\n@@ -414,3 +432,0 @@\n-    $1_API_TARGET := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_pubapi\n-    $1_API_INTERNAL := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_internalapi\n-\n@@ -419,1 +434,1 @@\n-    ifneq (,$$($1_HEADERS))\n+    ifneq ($$($1_HEADERS), )\n@@ -445,11 +460,0 @@\n-    ifeq ($$($1_CREATE_API_DIGEST), true)\n-      $1_API_DIGEST_FLAGS := \\\n-          -classpath $$(BUILDTOOLS_OUTPUTDIR)\/depend \\\n-          -Xplugin:\"depend $$($1_API_TARGET)\" \\\n-          \"-XDinternalAPIPath=$$($1_API_INTERNAL)\" \\\n-          \"-XDLOG_LEVEL=$(LOG_LEVEL)\" \\\n-          #\n-\n-      $1_EXTRA_DEPS := $$(BUILDTOOLS_OUTPUTDIR)\/depend\/_the.COMPILE_DEPEND_batch\n-    endif\n-\n@@ -502,1 +506,1 @@\n-    ifneq (,$$($1_JAR))\n+    ifneq ($$($1_JAR), )\n@@ -506,2 +510,2 @@\n-      ifeq (,$$($1_SUFFIXES))\n-        $1_SUFFIXES:=.class $$($1_CLEAN) $$($1_COPY)\n+      ifeq ($$($1_SUFFIXES), )\n+        $1_SUFFIXES := .class $$($1_CLEAN) $$($1_COPY)\n@@ -511,12 +515,12 @@\n-          DEPENDENCIES:=$$($1), \\\n-          SRCS:=$$($1_BIN)$$($1_MODULE_SUBDIR), \\\n-          SUFFIXES:=$$($1_SUFFIXES), \\\n-          EXCLUDE:=$$($1_EXCLUDES), \\\n-          INCLUDES:=$$($1_INCLUDES), \\\n-          EXTRA_FILES:=$$($1_ALL_COPY_TARGETS) $$($1_ALL_COPY_CLEAN_TARGETS), \\\n-          JAR:=$$($1_JAR), \\\n-          JARMAIN:=$$($1_JARMAIN), \\\n-          MANIFEST:=$$($1_MANIFEST), \\\n-          EXTRA_MANIFEST_ATTR:=$$($1_EXTRA_MANIFEST_ATTR), \\\n-          JARINDEX:=$$($1_JARINDEX), \\\n-          HEADERS:=$$($1_HEADERS), \\\n+          DEPENDENCIES := $$($1), \\\n+          SRCS := $$($1_BIN)$$($1_MODULE_SUBDIR), \\\n+          SUFFIXES := $$($1_SUFFIXES), \\\n+          EXCLUDE := $$($1_EXCLUDES), \\\n+          INCLUDES := $$($1_INCLUDES), \\\n+          EXTRA_FILES := $$($1_ALL_COPY_TARGETS) $$($1_ALL_COPY_CLEAN_TARGETS), \\\n+          JAR := $$($1_JAR), \\\n+          JARMAIN := $$($1_JARMAIN), \\\n+          MANIFEST := $$($1_MANIFEST), \\\n+          EXTRA_MANIFEST_ATTR := $$($1_EXTRA_MANIFEST_ATTR), \\\n+          JARINDEX := $$($1_JARINDEX), \\\n+          HEADERS := $$($1_HEADERS), \\\n@@ -530,1 +534,1 @@\n-    ifneq (,$$($1_SRCZIP))\n+    ifneq ($$($1_SRCZIP), )\n@@ -532,5 +536,5 @@\n-          SRC:=$$($1_SRC), \\\n-          ZIP:=$$($1_SRCZIP), \\\n-          INCLUDES:=$$($1_INCLUDES), \\\n-          EXCLUDES:=$$($1_EXCLUDES), \\\n-          EXCLUDE_FILES:=$$($1_EXCLUDE_FILES)))\n+          SRC := $$($1_SRC), \\\n+          ZIP := $$($1_SRCZIP), \\\n+          INCLUDES := $$($1_INCLUDES), \\\n+          EXCLUDES := $$($1_EXCLUDES), \\\n+          EXCLUDE_FILES := $$($1_EXCLUDE_FILES)))\n","filename":"make\/common\/JavaCompilation.gmk","additions":97,"deletions":93,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-  ifeq ($$(filter lib%, $$($1_$2_NAME)),)\n+  ifeq ($$(filter lib%, $$($1_$2_NAME)), )\n@@ -190,1 +190,1 @@\n-  ifeq ($$($1_$2_MODULE),)\n+  ifeq ($$($1_$2_MODULE), )\n@@ -199,1 +199,1 @@\n-     $1_$2_STATIC_LIBRARY := true\n+    $1_$2_STATIC_LIBRARY := true\n@@ -202,1 +202,1 @@\n-     $1_$2_STATIC_LIBRARY := true\n+    $1_$2_STATIC_LIBRARY := true\n","filename":"make\/common\/JdkNativeCompilation.gmk","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-################################################################\n+################################################################################\n@@ -31,1 +31,1 @@\n-################################################################\n+################################################################################\n@@ -36,1 +36,1 @@\n-ifeq ($(wildcard $(SPEC)),)\n+ifeq ($(wildcard $(SPEC)), )\n@@ -52,8 +52,8 @@\n-X:=\n-SPACE:=$(X) $(X)\n-COMMA:=,\n-DOLLAR:=$$\n-HASH:=\\#\n-LEFT_PAREN:=(\n-RIGHT_PAREN:=)\n-SQUOTE:='\n+X :=\n+SPACE := $(X) $(X)\n+COMMA := ,\n+DOLLAR := $$\n+HASH := \\#\n+LEFT_PAREN := (\n+RIGHT_PAREN := )\n+SQUOTE := '\n@@ -61,1 +61,1 @@\n-DQUOTE:=\"\n+DQUOTE := \"\n@@ -102,1 +102,1 @@\n-  ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)\n+  ifneq ($$(findstring $$(LOG_LEVEL), debug trace), )\n@@ -120,1 +120,1 @@\n-  ifneq ($$(findstring $$(LOG_LEVEL), info debug trace),)\n+  ifneq ($$(findstring $$(LOG_LEVEL), info debug trace), )\n@@ -127,1 +127,1 @@\n-  ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)\n+  ifneq ($$(findstring $$(LOG_LEVEL), debug trace), )\n@@ -134,1 +134,1 @@\n-  ifneq ($$(findstring $$(LOG_LEVEL), trace),)\n+  ifneq ($$(findstring $$(LOG_LEVEL), trace), )\n@@ -167,1 +167,1 @@\n-  $(if $($(MAX_PARAMS)),$(error Internal makefile error: \\\n+  $(if $($(MAX_PARAMS)), $(error Internal makefile error: \\\n@@ -170,1 +170,1 @@\n-  $(foreach i,$(PARAM_SEQUENCE), $(if $(strip $($i)),\\\n+  $(foreach i, $(PARAM_SEQUENCE), $(if $(strip $($i)), \\\n@@ -174,1 +174,1 @@\n-    $(info $0 $(strip $1) $(foreach i,$(PARAM_SEQUENCE), \\\n+    $(info $0 $(strip $1) $(foreach i, $(PARAM_SEQUENCE), \\\n@@ -249,2 +249,2 @@\n-    $(call WriteFile, $1_old:=$(call DoubleDollar,$(call EscapeHash,$($1))), \\\n-         $($1_filename)) \\\n+    $(call WriteFile, $1_old := $(call DoubleDollar,$(call EscapeHash,$($1))), \\\n+        $($1_filename)) \\\n@@ -263,1 +263,1 @@\n-          $(if $(call equals, $(strip $($1)), $(strip $($1_old))),,\\\n+          $(if $(call equals, $(strip $($1)), $(strip $($1_old))),, \\\n","filename":"make\/common\/MakeBase.gmk","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -70,1 +70,1 @@\n-  decompress_paths=$(SED) -f $(TOPDIR)\/make\/common\/support\/ListPathsSafely-uncompress.sed \\\n+  decompress_paths = $(SED) -f $(TOPDIR)\/make\/common\/support\/ListPathsSafely-uncompress.sed \\\n@@ -76,1 +76,1 @@\n-      $(if $(word $3,$($(strip $1))), \\\n+      $(if $(word $3, $($(strip $1))), \\\n@@ -78,1 +78,1 @@\n-              $(call compress_paths, $(wordlist $3,$4,$($(strip $1))))))\\n\" \\\n+              $(call compress_paths, $(wordlist $3, $4, $($(strip $1))))))\\n\" \\\n@@ -85,1 +85,1 @@\n-    ifneq (,$$(word 30001,$$($$(strip $1))))\n+    ifneq ($$(word 30001, $$($$(strip $1))), )\n","filename":"make\/common\/MakeIO.gmk","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -180,2 +180,2 @@\n-\t    ( $(PRINTF) \"DEPS_$(call GetModuleNameFromModuleInfo, $m) :=\" && \\\n-\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) '\\\n+\t    ( $(PRINTF) \"DEPS_$(call GetModuleNameFromModuleInfo, $m) := \" && \\\n+\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) ' \\\n@@ -194,2 +194,2 @@\n-\t      $(PRINTF) \"TRANSITIVE_MODULES_$(call GetModuleNameFromModuleInfo, $m) :=\" && \\\n-\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) '\\\n+\t      $(PRINTF) \"TRANSITIVE_MODULES_$(call GetModuleNameFromModuleInfo, $m) := \" && \\\n+\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) ' \\\n@@ -224,1 +224,1 @@\n-                 $(call FindDepsForModule, $n))))\n+                $(call FindDepsForModule, $n))))\n@@ -243,1 +243,1 @@\n-                 $(call FindIndirectExportsForModule, $n))))\n+                $(call FindIndirectExportsForModule, $n))))\n","filename":"make\/common\/Modules.gmk","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-      $$(eval $$(call CreateCompiledNativeFile,$1_$$(notdir $$(file)),\\\n+      $$(eval $$(call CreateCompiledNativeFile,$1_$$(notdir $$(file)), \\\n@@ -225,1 +225,1 @@\n-    $1 := $$($1_ALL_OBJS_JSON)\n+    $1 := $$($1_ALL_OBJS_JSON) $$($1_LDFLAGS_FILE)\n@@ -295,0 +295,1 @@\n+  $1_UNIQUE_NAME = $$($1_TYPE)_$$(subst \/,_,$$(patsubst $$(OUTPUTDIR)\/%\/,%,$$(dir $$($1_OBJECT_DIR))))_$$($1_NOSUFFIX)\n","filename":"make\/common\/NativeCompilation.gmk","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -95,1 +95,1 @@\n-        ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)\n+        ifneq ($$(findstring $$(LOG_LEVEL), debug trace), )\n","filename":"make\/common\/ProcessMarkdown.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -98,1 +98,1 @@\n-  $$(foreach file, $$($1_FILTERED_FILE_LIST),\\\n+  $$(foreach file, $$($1_FILTERED_FILE_LIST), \\\n@@ -115,3 +115,6 @@\n-        DISABLED_WARNINGS_gcc := format undef unused-function unused-value, \\\n-        DISABLED_WARNINGS_clang := undef format-nonliteral \\\n-            missing-field-initializers sometimes-uninitialized, \\\n+        DISABLED_WARNINGS_gcc := format undef unused-but-set-variable \\\n+            unused-const-variable unused-function unused-value \\\n+            unused-variable, \\\n+        DISABLED_WARNINGS_clang := format-nonliteral \\\n+            missing-field-initializers sometimes-uninitialized undef \\\n+            unused-but-set-variable unused-function unused-variable, \\\n@@ -122,1 +125,1 @@\n-        OPTIMIZATION := $$(if $$($1_OPTIMIZATION_$$(name)),$$($1_OPTIMIZATION_$$(name)),LOW), \\\n+        OPTIMIZATION := $$(if $$($1_OPTIMIZATION_$$(name)), $$($1_OPTIMIZATION_$$(name)), LOW), \\\n@@ -124,1 +127,1 @@\n-        STRIP_SYMBOLS := $$(if $$($1_STRIP_SYMBOLS_$$(name)),$$($1_STRIP_SYMBOLS_$$(name)),false), \\\n+        STRIP_SYMBOLS := $$(if $$($1_STRIP_SYMBOLS_$$(name)), $$($1_STRIP_SYMBOLS_$$(name)), false), \\\n","filename":"make\/common\/TestFilesCompilation.gmk","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -83,2 +83,2 @@\n-  ifneq ($$($1_SOURCE_FILES),)\n-    ifneq ($$($1_SOURCE_DIRS),)\n+  ifneq ($$($1_SOURCE_FILES), )\n+    ifneq ($$($1_SOURCE_DIRS), )\n@@ -87,1 +87,1 @@\n-    ifneq ($$($1_EXCLUDE_FILES)$$($1_INCLUDE_FILES),)\n+    ifneq ($$($1_EXCLUDE_FILES)$$($1_INCLUDE_FILES), )\n@@ -91,1 +91,1 @@\n-    ifeq ($$($1_SOURCE_DIRS),)\n+    ifeq ($$($1_SOURCE_DIRS), )\n@@ -97,1 +97,1 @@\n-    ifneq ($$($1_SOURCE_BASE_DIR),)\n+    ifneq ($$($1_SOURCE_BASE_DIR), )\n@@ -104,5 +104,5 @@\n-    $1_EXCLUDE_FILES:=$$(foreach i,$$($1_SOURCE_DIRS),$$(addprefix $$i\/,$$($1_EXCLUDE_FILES)))\n-    $1_INCLUDE_FILES:=$$(foreach i,$$($1_SOURCE_DIRS),$$(addprefix $$i\/,$$($1_INCLUDE_FILES)))\n-    $1_SOURCE_FILES := $$(filter-out $$($1_EXCLUDE_FILES),$$($1_SOURCE_FILES))\n-    ifneq (,$$(strip $$($1_INCLUDE_FILES)))\n-      $1_SOURCE_FILES := $$(filter $$($1_INCLUDE_FILES),$$($1_SOURCE_FILES))\n+    $1_EXCLUDE_FILES := $$(foreach i, $$($1_SOURCE_DIRS), $$(addprefix $$i\/, $$($1_EXCLUDE_FILES)))\n+    $1_INCLUDE_FILES := $$(foreach i, $$($1_SOURCE_DIRS), $$(addprefix $$i\/, $$($1_INCLUDE_FILES)))\n+    $1_SOURCE_FILES := $$(filter-out $$($1_EXCLUDE_FILES), $$($1_SOURCE_FILES))\n+    ifneq ($$(strip $$($1_INCLUDE_FILES)), )\n+      $1_SOURCE_FILES := $$(filter $$($1_INCLUDE_FILES), $$($1_SOURCE_FILES))\n@@ -110,1 +110,1 @@\n-    ifeq (,$$($1_SOURCE_FILES))\n+    ifeq ($$($1_SOURCE_FILES), )\n@@ -115,1 +115,1 @@\n-  ifneq ($$($1_REPLACEMENTS),)\n+  ifneq ($$($1_REPLACEMENTS), )\n@@ -117,1 +117,1 @@\n-    ifneq ($$(findstring \/,$$($1_REPLACEMENTS)),)\n+    ifneq ($$(findstring \/, $$($1_REPLACEMENTS)), )\n@@ -119,1 +119,1 @@\n-      ifneq ($$(findstring @,$$($1_REPLACEMENTS)),)\n+      ifneq ($$(findstring @, $$($1_REPLACEMENTS)), )\n@@ -121,1 +121,1 @@\n-        ifneq ($$(findstring |,$$($1_REPLACEMENTS)),)\n+        ifneq ($$(findstring |, $$($1_REPLACEMENTS)), )\n@@ -123,1 +123,1 @@\n-          ifneq ($$(findstring !,$$($1_REPLACEMENTS)),)\n+          ifneq ($$(findstring !, $$($1_REPLACEMENTS)), )\n@@ -164,1 +164,1 @@\n-  ifneq ($$($1_INCLUDES),)\n+  ifneq ($$($1_INCLUDES), )\n@@ -193,1 +193,1 @@\n-  ifneq ($$($1_OUTPUT_FILE),)\n+  ifneq ($$($1_OUTPUT_FILE), )\n@@ -202,1 +202,1 @@\n-    ifeq ($$($1_OUTPUT_DIR),)\n+    ifeq ($$($1_OUTPUT_DIR), )\n@@ -207,1 +207,1 @@\n-    ifeq ($$($1_SOURCE_BASE_DIR),)\n+    ifeq ($$($1_SOURCE_BASE_DIR), )\n","filename":"make\/common\/TextFileProcessing.gmk","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -39,1 +39,1 @@\n-      $(and $(findstring $(strip $1),$(strip $2)),\\\n+      $(and $(findstring $(strip $1),$(strip $2)), \\\n@@ -67,1 +67,1 @@\n-        $(eval SEQUENCE_COUNT :=) \\\n+        $(eval SEQUENCE_COUNT := ) \\\n@@ -228,1 +228,1 @@\n-        $(foreach v,$(strip $2),\\\n+        $(foreach v,$(strip $2), \\\n@@ -245,1 +245,1 @@\n-    $(strip $(if $1,$(patsubst $(firstword $1)%,%,\\\n+    $(strip $(if $1,$(patsubst $(firstword $1)%,%, \\\n@@ -273,1 +273,1 @@\n-         +\"$(ISO_8601_FORMAT_STRING)\" 2> \/dev\/null)\n+        +\"$(ISO_8601_FORMAT_STRING)\" 2> \/dev\/null)\n@@ -277,1 +277,1 @@\n-         +\"$(ISO_8601_FORMAT_STRING)\" 2> \/dev\/null)\n+        +\"$(ISO_8601_FORMAT_STRING)\" 2> \/dev\/null)\n","filename":"make\/common\/Utils.gmk","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -68,3 +68,3 @@\n-  ifneq ($$($1_INCLUDES)$$($1_INCLUDE_FILES),)\n-    $1_FIND_LIST := $$(wildcard $$(foreach s,$$($1_SRC_SLASH), \\\n-        $$(addprefix $$s,$$($1_INCLUDES) $$($1_INCLUDE_FILES))))\n+  ifneq ($$($1_INCLUDES)$$($1_INCLUDE_FILES), )\n+    $1_FIND_LIST := $$(wildcard $$(foreach s, $$($1_SRC_SLASH), \\\n+        $$(addprefix $$s, $$($1_INCLUDES) $$($1_INCLUDE_FILES))))\n@@ -79,1 +79,1 @@\n-    $1_ALL_SRCS := $$(call not-containing,_the.,$$(call ShellFindFiles,$$($1_FIND_LIST), , -L))\n+    $1_ALL_SRCS := $$(call not-containing, _the., $$(call ShellFindFiles, $$($1_FIND_LIST), , -L))\n@@ -81,1 +81,1 @@\n-    $1_ALL_SRCS := $$(call not-containing,_the.,$$(call FindFiles,$$($1_FIND_LIST)))\n+    $1_ALL_SRCS := $$(call not-containing, _the., $$(call FindFiles, $$($1_FIND_LIST)))\n@@ -85,1 +85,1 @@\n-  ifneq ($$($1_SUFFIXES),)\n+  ifneq ($$($1_SUFFIXES), )\n@@ -89,4 +89,4 @@\n-  ifneq ($$($1_INCLUDES),)\n-    ifneq ($$($1_SUFFIXES),)\n-      $1_ZIP_INCLUDES := $$(foreach s,$$($1_SUFFIXES), \\\n-          $$(addprefix -i$(SPACE)$(DQUOTE),$$(addsuffix \/*$$s$(DQUOTE),$$($1_INCLUDES))))\n+  ifneq ($$($1_INCLUDES), )\n+    ifneq ($$($1_SUFFIXES), )\n+      $1_ZIP_INCLUDES := $$(foreach s, $$($1_SUFFIXES), \\\n+          $$(addprefix -i$(SPACE)$(DQUOTE), $$(addsuffix \/*$$s$(DQUOTE), $$($1_INCLUDES))))\n@@ -94,1 +94,1 @@\n-      $1_ZIP_INCLUDES := $$(addprefix -i$(SPACE)$(DQUOTE),$$(addsuffix \/*$(DQUOTE),$$($1_INCLUDES)))\n+      $1_ZIP_INCLUDES := $$(addprefix -i$(SPACE)$(DQUOTE), $$(addsuffix \/*$(DQUOTE), $$($1_INCLUDES)))\n@@ -97,3 +97,3 @@\n-    ifneq ($$($1_SUFFIXES),)\n-      $1_ZIP_INCLUDES := $$(foreach s,$$($1_SUFFIXES), \\\n-          $$(addprefix -i$(SPACE)$(DQUOTE),*$$s$(DQUOTE)))\n+    ifneq ($$($1_SUFFIXES), )\n+      $1_ZIP_INCLUDES := $$(foreach s, $$($1_SUFFIXES), \\\n+          $$(addprefix -i$(SPACE)$(DQUOTE), *$$s$(DQUOTE)))\n@@ -102,2 +102,2 @@\n-  ifneq ($$($1_INCLUDE_FILES),)\n-    $1_ZIP_INCLUDES += $$(addprefix -i$(SPACE),$$($1_INCLUDE_FILES))\n+  ifneq ($$($1_INCLUDE_FILES), )\n+    $1_ZIP_INCLUDES += $$(addprefix -i$(SPACE), $$($1_INCLUDE_FILES))\n@@ -105,4 +105,4 @@\n-  ifneq ($$($1_EXCLUDES),)\n-    $1_ZIP_EXCLUDES := $$(addprefix -x$(SPACE)$(DQUOTE),$$(addsuffix \/*$(DQUOTE),$$($1_EXCLUDES)))\n-    $1_SRC_EXCLUDES := $$(foreach s,$$($1_SRC_SLASH),$$(addprefix $$s,$$(addsuffix \/%,$$($1_EXCLUDES))))\n-    $1_ALL_SRCS := $$(filter-out $$($1_SRC_EXCLUDES),$$($1_ALL_SRCS))\n+  ifneq ($$($1_EXCLUDES), )\n+    $1_ZIP_EXCLUDES := $$(addprefix -x$(SPACE)$(DQUOTE), $$(addsuffix \/*$(DQUOTE), $$($1_EXCLUDES)))\n+    $1_SRC_EXCLUDES := $$(foreach s, $$($1_SRC_SLASH), $$(addprefix $$s, $$(addsuffix \/%, $$($1_EXCLUDES))))\n+    $1_ALL_SRCS := $$(filter-out $$($1_SRC_EXCLUDES), $$($1_ALL_SRCS))\n@@ -110,1 +110,1 @@\n-  ifneq ($$($1_EXCLUDE_FILES),)\n+  ifneq ($$($1_EXCLUDE_FILES), )\n@@ -137,1 +137,1 @@\n-  $1_NAME:=$$(subst $$(OUTPUTDIR)\/,,$$($1_ZIP))\n+  $1_NAME := $$(subst $$(OUTPUTDIR)\/,,$$($1_ZIP))\n@@ -170,1 +170,1 @@\n-\t$$(foreach s,$$($1_SRC_SLASH), $$(call ExecuteWithLog, \\\n+\t$$(foreach s, $$($1_SRC_SLASH), $$(call ExecuteWithLog, \\\n","filename":"make\/common\/ZipArchive.gmk","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -138,1 +138,2 @@\n-      DISABLED_WARNINGS_gcc := unused-function, \\\n+      DISABLED_WARNINGS_gcc := unused-function unused-variable, \\\n+      DISABLED_WARNINGS_clang := unused-function, \\\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  $(call WriteFile,{ \\\n+  $(call WriteFile, { \\\n@@ -47,1 +47,1 @@\n-      \"command\": \"$(strip $(subst $(DQUOTE),\\$(DQUOTE),$(subst \\,\\\\,\\\n+      \"command\": \"$(strip $(subst $(DQUOTE),\\$(DQUOTE),$(subst \\,\\\\, \\\n@@ -347,1 +347,1 @@\n-\t\t$(ECHO) >> $$($1_RES_DEPS_FILE) ;\\\n+\t\t$(ECHO) >> $$($1_RES_DEPS_FILE) ; \\\n","filename":"make\/common\/native\/CompileFile.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-       endif # !STATIC_LIBRARY\n+      endif # !STATIC_LIBRARY\n","filename":"make\/common\/native\/DebugSymbols.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,0 +201,12 @@\n+\n+  # This is for IDE integration purposes only, and is not normally generated\n+  $1_LDFLAGS_FILE := $$(MAKESUPPORT_OUTPUTDIR)\/compile-commands\/$$($1_UNIQUE_NAME)-ldflags.txt\n+\n+  $1_ALL_LD_ARGS := $$($1_LDFLAGS) $$($1_EXTRA_LDFLAGS) $$($1_SYSROOT_LDFLAGS) \\\n+      $$($1_LIBS) $$($1_EXTRA_LIBS)\n+\n+  $$($1_LDFLAGS_FILE): $$($1_VARDEPS_FILE)\n+\t$$(call LogInfo, Creating compile commands linker flags output for $$($1_BASENAME))\n+\t$$(call MakeDir, $$(dir $$@))\n+\t$$(ECHO) $$($1_ALL_LD_ARGS) > $$@\n+\n","filename":"make\/common\/native\/Link.gmk","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+ALPINE_LINUX_X64_BOOT_JDK_EXT=tar.gz\n+ALPINE_LINUX_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin22-binaries\/releases\/download\/jdk-22.0.2%2B9\/OpenJDK22U-jdk_x64_alpine-linux_hotspot_22.0.2_9.tar.gz\n+ALPINE_LINUX_X64_BOOT_JDK_SHA256=49f73414824b1a7c268a611225fa4d7ce5e25600201e0f1cd59f94d1040b5264\n+\n","filename":"make\/conf\/github-actions.conf","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-    java.datatransfer \\\n@@ -100,1 +99,0 @@\n-    java.logging \\\n@@ -102,3 +100,0 @@\n-    java.management.rmi \\\n-    java.naming \\\n-    java.net.http \\\n@@ -107,2 +102,0 @@\n-    java.scripting \\\n-    java.se \\\n@@ -110,1 +103,0 @@\n-    java.security.sasl \\\n@@ -112,5 +104,0 @@\n-    java.sql \\\n-    java.sql.rowset \\\n-    java.transaction.xa \\\n-    java.xml \\\n-    java.xml.crypto \\\n@@ -118,1 +105,1 @@\n-    jdk.charsets \\\n+    jdk.attach \\\n@@ -120,3 +107,2 @@\n-    jdk.dynalink \\\n-    jdk.httpserver \\\n-    jdk.incubator.vector \\\n+    jdk.crypto.mscapi \\\n+    jdk.hotspot.agent \\\n@@ -125,0 +111,1 @@\n+    jdk.jdi \\\n@@ -126,2 +113,1 @@\n-    jdk.jsobject \\\n-    jdk.localedata \\\n+    jdk.jpackage \\\n@@ -130,3 +116,0 @@\n-    jdk.management.jfr \\\n-    jdk.naming.dns \\\n-    jdk.naming.rmi \\\n@@ -134,1 +117,0 @@\n-    jdk.nio.mapmode \\\n@@ -137,4 +119,0 @@\n-    jdk.security.jgss \\\n-    jdk.unsupported \\\n-    jdk.xml.dom \\\n-    jdk.zipfs \\\n","filename":"make\/conf\/module-loader-map.conf","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-ifeq (,$(SKIP_ME))\n+ifeq ($(SKIP_ME), )\n","filename":"make\/devkit\/Makefile","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-##########################################################################################\n+################################################################################\n@@ -95,1 +95,1 @@\n-##########################################################################################\n+################################################################################\n@@ -226,1 +226,1 @@\n-##########################################################################################\n+################################################################################\n@@ -261,1 +261,1 @@\n-##########################################################################################\n+################################################################################\n@@ -288,1 +288,1 @@\n-##########################################################################################\n+################################################################################\n@@ -327,1 +327,1 @@\n-##########################################################################################\n+################################################################################\n@@ -347,1 +347,1 @@\n-##########################################################################################\n+################################################################################\n@@ -360,1 +360,1 @@\n-##########################################################################################\n+################################################################################\n@@ -365,1 +365,1 @@\n-##########################################################################################\n+################################################################################\n@@ -393,1 +393,1 @@\n-##########################################################################################\n+################################################################################\n@@ -427,1 +427,1 @@\n-##########################################################################################\n+################################################################################\n@@ -594,1 +594,1 @@\n-##########################################################################################\n+################################################################################\n@@ -609,1 +609,1 @@\n-##########################################################################################\n+################################################################################\n@@ -624,1 +624,1 @@\n-  ##########################################################################################\n+  ##############################################################################\n@@ -644,1 +644,1 @@\n-##########################################################################################\n+################################################################################\n@@ -659,1 +659,1 @@\n-##########################################################################################\n+################################################################################\n@@ -673,1 +673,1 @@\n-##########################################################################################\n+################################################################################\n@@ -689,1 +689,1 @@\n-##########################################################################################\n+################################################################################\n@@ -709,1 +709,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/devkit\/Tools.gmk","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-      FILES := $(filter %.lib, $(LIB_TARGETS))))\n+      FILES := $(filter %.lib, $(LIB_TARGETS)), \\\n+  ))\n","filename":"make\/hotspot\/CopyToExplodedJdk.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -207,5 +207,5 @@\n-         if (CUR_FN != FILENAME) { CUR_FN=FILENAME; NR_BASE=NR-1; need_lineno=1 } \\\n-         if (need_lineno && $$0 !~ \/\\\/\\\/\/) \\\n-           { print \"\\n\\n\\#line \" (NR-NR_BASE) \" \\\"\" FILENAME \"\\\"\"; need_lineno=0 }; \\\n-         print \\\n-       }'\n+        if (CUR_FN != FILENAME) { CUR_FN=FILENAME; NR_BASE=NR-1; need_lineno=1 } \\\n+        if (need_lineno && $$0 !~ \/\\\/\\\/\/) \\\n+          { print \"\\n\\n\\#line \" (NR-NR_BASE) \" \\\"\" FILENAME \"\\\"\"; need_lineno=0 }; \\\n+        print \\\n+      }'\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -60,3 +60,3 @@\n-    DISABLED_WARNINGS_gcc := undef unused-result format-nonliteral \\\n-        maybe-uninitialized zero-as-null-pointer-constant, \\\n-    DISABLED_WARNINGS_clang := undef unused-result format-nonliteral, \\\n+    DISABLED_WARNINGS_gcc := format-nonliteral maybe-uninitialized undef \\\n+        unused-result zero-as-null-pointer-constant, \\\n+    DISABLED_WARNINGS_clang := format-nonliteral undef unused-result, \\\n@@ -98,1 +98,1 @@\n-        $(addprefix -I,$(GTEST_TEST_SRC)), \\\n+        $(addprefix -I, $(GTEST_TEST_SRC)), \\\n@@ -103,0 +103,1 @@\n+    DISABLED_WARNINGS_gcc_test_metaspace_misc.cpp := unused-const-variable, \\\n","filename":"make\/hotspot\/lib\/CompileGtest.gmk","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -95,1 +95,2 @@\n-    shift-negative-value unknown-pragmas\n+    shift-negative-value unknown-pragmas unused-but-set-variable \\\n+    unused-local-typedefs unused-variable\n@@ -97,2 +98,3 @@\n-DISABLED_WARNINGS_clang := sometimes-uninitialized \\\n-    missing-braces delete-non-abstract-non-virtual-dtor unknown-pragmas\n+DISABLED_WARNINGS_clang := delete-non-abstract-non-virtual-dtor missing-braces \\\n+    sometimes-uninitialized unknown-pragmas unused-but-set-variable \\\n+    unused-function unused-local-typedef unused-private-field unused-variable\n@@ -180,0 +182,2 @@\n+    DISABLED_WARNINGS_gcc_bytecodeInterpreter.cpp := unused-label, \\\n+    DISABLED_WARNINGS_gcc_c1_Runtime1_aarch64.cpp := unused-const-variable, \\\n@@ -182,0 +186,1 @@\n+    DISABLED_WARNINGS_gcc_g1FreeIdSet.cpp := unused-const-variable, \\\n@@ -184,0 +189,4 @@\n+    DISABLED_WARNINGS_gcc_javaClasses.cpp := unused-const-variable, \\\n+    DISABLED_WARNINGS_gcc_jfrChunkWriter.cpp := unused-const-variable, \\\n+    DISABLED_WARNINGS_gcc_jfrMemorySizer.cpp := unused-const-variable, \\\n+    DISABLED_WARNINGS_gcc_jfrTraceIdKlassQueue.cpp := unused-const-variable, \\\n@@ -185,0 +194,1 @@\n+    DISABLED_WARNINGS_gcc_jvmFlag.cpp := unused-const-variable, \\\n@@ -186,0 +196,1 @@\n+    DISABLED_WARNINGS_gcc_macroAssembler_ppc_sha.cpp := unused-const-variable, \\\n@@ -188,0 +199,1 @@\n+    DISABLED_WARNINGS_gcc_stubGenerator_s390.cpp := unused-const-variable, \\\n@@ -189,0 +201,2 @@\n+    DISABLED_WARNINGS_gcc_templateInterpreterGenerator_x86.cpp := unused-const-variable, \\\n+    DISABLED_WARNINGS_gcc_xGlobals_ppc.cpp := unused-const-variable, \\\n@@ -271,1 +285,1 @@\n-          FILES :=$(BUILD_LIBJVM_IMPORT_LIBRARY), \\\n+          FILES := $(BUILD_LIBJVM_IMPORT_LIBRARY), \\\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -50,3 +50,4 @@\n-  JVM_EXCLUDE_FILES += templateInterpreter.cpp templateInterpreterGenerator.cpp \\\n-                       bcEscapeAnalyzer.cpp ciTypeFlow.cpp\n-  JVM_CFLAGS_FEATURES += -DZERO -DZERO_LIBARCH='\"$(OPENJDK_TARGET_CPU_LEGACY_LIB)\"' $(LIBFFI_CFLAGS)\n+  JVM_EXCLUDE_FILES += templateInterpreter.cpp \\\n+      templateInterpreterGenerator.cpp bcEscapeAnalyzer.cpp ciTypeFlow.cpp\n+  JVM_CFLAGS_FEATURES += -DZERO \\\n+      -DZERO_LIBARCH='\"$(OPENJDK_TARGET_CPU_LEGACY_LIB)\"' $(LIBFFI_CFLAGS)\n@@ -72,1 +73,2 @@\n-    # Override the default -g with a more liberal strip policy for the minimal JVM\n+    # Override the default -g with a more liberal strip policy for the\n+    # minimal JVM\n@@ -83,5 +85,8 @@\n-  JVM_EXCLUDE_FILES += jvmtiGetLoadedClasses.cpp jvmtiThreadState.cpp jvmtiExtensions.cpp \\\n-      jvmtiImpl.cpp jvmtiManageCapabilities.cpp jvmtiRawMonitor.cpp jvmtiUtil.cpp jvmtiTrace.cpp \\\n-      jvmtiCodeBlobEvents.cpp jvmtiEnv.cpp jvmtiRedefineClasses.cpp jvmtiEnvBase.cpp jvmtiEnvThreadState.cpp \\\n-      jvmtiTagMap.cpp jvmtiEventController.cpp evmCompat.cpp jvmtiEnter.xsl jvmtiExport.cpp \\\n-      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp jvmtiAgent.cpp jvmtiAgentList.cpp jfrJvmtiAgent.cpp\n+  JVM_EXCLUDE_FILES += jvmtiGetLoadedClasses.cpp jvmtiThreadState.cpp \\\n+      jvmtiExtensions.cpp jvmtiImpl.cpp jvmtiManageCapabilities.cpp \\\n+      jvmtiRawMonitor.cpp jvmtiUtil.cpp jvmtiTrace.cpp jvmtiCodeBlobEvents.cpp \\\n+      jvmtiEnv.cpp jvmtiRedefineClasses.cpp jvmtiEnvBase.cpp \\\n+      jvmtiEnvThreadState.cpp jvmtiTagMap.cpp jvmtiEventController.cpp \\\n+      evmCompat.cpp jvmtiEnter.xsl jvmtiExport.cpp \\\n+      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp jvmtiAgent.cpp \\\n+      jvmtiAgentList.cpp jfrJvmtiAgent.cpp\n@@ -169,2 +174,4 @@\n-    JVM_CFLAGS_FEATURES += -flto=auto -fuse-linker-plugin -fno-strict-aliasing -fno-fat-lto-objects\n-    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto=auto -fuse-linker-plugin -fno-strict-aliasing\n+    JVM_CFLAGS_FEATURES += -flto=auto -fuse-linker-plugin -fno-strict-aliasing \\\n+        -fno-fat-lto-objects\n+    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto=auto \\\n+        -fuse-linker-plugin -fno-strict-aliasing\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-  ifneq ($(DEBUG_LEVEL),slowdebug)\n+  ifneq ($(DEBUG_LEVEL), slowdebug)\n","filename":"make\/hotspot\/lib\/JvmOverrideFiles.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    $(if $(strip $1),$(wildcard $(SUPPORT_OUTPUTDIR)\/headers\/$(strip $1)))\n+    $(if $(strip $1), $(wildcard $(SUPPORT_OUTPUTDIR)\/headers\/$(strip $1)))\n@@ -115,1 +115,1 @@\n-    $1_CLASSPATH += $$(foreach src,$(JAVA_DIRS), \\\n+    $1_CLASSPATH += $$(foreach src, $(JAVA_DIRS), \\\n@@ -160,1 +160,1 @@\n-      $1_NATIVE_SRCS += $$(foreach src,$(NATIVE_DIRS), \\\n+      $1_NATIVE_SRCS += $$(foreach src, $(NATIVE_DIRS), \\\n@@ -191,1 +191,1 @@\n-    $1_MATCHING_MAKE_TARGETS += $$(foreach name,$$($1_PLAIN_MAKE_TARGETS), \\\n+    $1_MATCHING_MAKE_TARGETS += $$(foreach name, $$($1_PLAIN_MAKE_TARGETS), \\\n@@ -295,1 +295,1 @@\n-    $1_LINKED_RESOURCES += $$(foreach src,$(JAVA_DIRS), \\\n+    $1_LINKED_RESOURCES += $$(foreach src, $(JAVA_DIRS), \\\n@@ -320,1 +320,1 @@\n-    $1_LINKED_RESOURCES += $$(foreach src,$(NATIVE_DIRS), \\\n+    $1_LINKED_RESOURCES += $$(foreach src, $(NATIVE_DIRS), \\\n","filename":"make\/ide\/eclipse\/CreateWorkspace.gmk","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-ifeq ($(SPEC),)\n-  ifneq ($(words $(SPECS)),1)\n+ifeq ($(SPEC), )\n+  ifneq ($(words $(SPECS)), 1)\n@@ -42,1 +42,1 @@\n-  ifeq ($(MODULES),)\n+  ifeq ($(MODULES), )\n@@ -50,1 +50,1 @@\n-\t$(ECHO) \"MODULE_ROOTS=\\\"$(foreach mod, $(SEL_MODULES), $(call FindModuleSrcDirs,$(mod)))\\\"\" >> $(OUT)\n+\t$(ECHO) \"MODULE_ROOTS=\\\"$(foreach mod, $(SEL_MODULES), $(call FindModuleSrcDirs, $(mod)))\\\"\" >> $(OUT)\n","filename":"make\/ide\/idea\/jdk\/idea.gmk","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-  ################################################################################\n+  ##############################################################################\n@@ -86,1 +86,1 @@\n-  TOOLS_OUTPUTDIR := $(HOTSPOT_OUTPUTDIR)\/support\/ide_classes\n+  TOOLS_OUTPUTDIR := $(MAKESUPPORT_OUTPUTDIR)\/ide\/visualstudio\n","filename":"make\/ide\/visualstudio\/hotspot\/CreateVSProject.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-ifneq (,$(wildcard $(call GetIndexerFragment,notes)))\n+ifneq ($(wildcard $(call GetIndexerFragment,notes)), )\n@@ -69,1 +69,1 @@\n-ifneq ($(WORKSPACE_ROOT),$(TOPDIR))\n+ifneq ($(WORKSPACE_ROOT), $(TOPDIR))\n","filename":"make\/ide\/vscode\/hotspot\/CreateVSCodeProject.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+#\n+# Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# This must be the first rule\n+default: all\n+\n+include $(SPEC)\n+include MakeBase.gmk\n+include CopyFiles.gmk\n+include Execute.gmk\n+include JavaCompilation.gmk\n+\n+ifeq ($(call isTargetOs, macosx), true)\n+  ##############################################################################\n+  # Build the XcodeProjectMaker java tool.\n+\n+  PROJECT_MAKER_DIR := $(TOPDIR)\/make\/ide\/xcode\/hotspot\n+  TOOLS_OUTPUTDIR := $(MAKESUPPORT_OUTPUTDIR)\/ide\/xcode\n+  IDE_OUTPUTDIR := $(OUTPUTDIR)\/xcode\n+  PROJECT_FILE_NAME := hotspot.xcodeproj\n+\n+  COMPILE_COMMAND_FILE := $(OUTPUTDIR)\/compile_commands.json\n+  LINKER_FLAGS_FILE := $(MAKESUPPORT_OUTPUTDIR)\/compile-commands\/jvm-ldflags.txt\n+\n+  $(eval $(call SetupJavaCompilation, BUILD_PROJECT_CREATOR, \\\n+      TARGET_RELEASE := $(TARGET_RELEASE_BOOTJDK), \\\n+      SRC := $(PROJECT_MAKER_DIR)\/src\/classes, \\\n+      BIN := $(TOOLS_OUTPUTDIR), \\\n+      DISABLED_WARNINGS := rawtypes unchecked serial, \\\n+  ))\n+\n+  TARGETS += $(BUILD_PROJECT_CREATOR)\n+\n+  # Run the XcodeProjectMaker tool\n+  PROJECT_CREATOR_TOOL := $(JAVA_SMALL) -cp $(TOOLS_OUTPUTDIR) XcodeProjectMaker\n+\n+  ifneq ($(findstring $(LOG_LEVEL), debug trace), )\n+    XCODE_PROJ_DEBUG_OPTION := -d\n+  endif\n+\n+  XCODE_PROJ_VARDEPS := $(WORKSPACE_ROOT) $(IDE_OUTPUTDIR) \\\n+      $(PROJECT_MAKER_DIR)\/data $(COMPILE_COMMAND_FILE) $(LINKER_FLAGS_FILE)\n+  XCODE_PROJ_VARDEPS_FILE := $(call DependOnVariable, XCODE_PROJ_VARDEPS, \\\n+    $(TOOLS_OUTPUTDIR)\/xcodeproj.vardeps)\n+\n+  $(eval $(call SetupExecute, build_xcode_project, \\\n+      WARN := Generating Xcode project file, \\\n+      DEPS := $(BUILD_PROJECT_CREATOR) $(COMPILE_COMMAND_FILE) \\\n+          $(LINKER_FLAGS_FILE) $(XCODE_PROJ_VARDEPS_FILE), \\\n+      OUTPUT_DIR := $(TOOLS_OUTPUTDIR), \\\n+      COMMAND := $(PROJECT_CREATOR_TOOL) $(WORKSPACE_ROOT) $(IDE_OUTPUTDIR) \\\n+          $(PROJECT_MAKER_DIR)\/data $(COMPILE_COMMAND_FILE) \\\n+          $(LINKER_FLAGS_FILE) $(XCODE_PROJ_DEBUG_OPTION), \\\n+  ))\n+\n+  TARGETS += $(build_xcode_project)\n+\n+  $(eval $(call SetupCopyFiles, copy_xcode_project, \\\n+      DEST := $(IDE_OUTPUTDIR), \\\n+      FILES := $(PROJECT_MAKER_DIR)\/data\/script_before.sh $(PROJECT_MAKER_DIR)\/data\/script_after.sh , \\\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n+\n+  TARGETS += $(copy_xcode_project)\n+\n+  $(eval $(call SetupExecute, open_xcode_project, \\\n+      INFO := Opening Xcode project file, \\\n+      DEPS := $(build_xcodeproject_TARGET) FORCE, \\\n+      OUTPUT_DIR := $(TOOLS_OUTPUTDIR), \\\n+      COMMAND := open $(IDE_OUTPUTDIR)\/$(PROJECT_FILE_NAME), \\\n+  ))\n+\n+  TARGETS += $(open_xcode_project)\n+\n+  # Always call open without considering dependencies being up to date\n+  FORCE:\n+\n+  build: $(build_xcode_project) $(copy_xcode_project)\n+\n+  open: $(open_xcode_project)\n+\n+  all: $(TARGETS)\n+else\n+  build:\n+  open:\n+  all:\n+\t$(info Xcode projects are only supported on macOS)\n+endif\n+\n+.PHONY: default all build open\n","filename":"make\/ide\/xcode\/hotspot\/CreateXcodeProject.gmk","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Bucket\n+   type = \"4\"\n+   version = \"2.0\">\n+   <Breakpoints>\n+      <BreakpointProxy\n+         BreakpointExtensionID = \"Xcode.Breakpoint.SymbolicBreakpoint\">\n+         <BreakpointContent\n+            shouldBeEnabled = \"Yes\"\n+            ignoreCount = \"0\"\n+            continueAfterRunningActions = \"Yes\"\n+            symbolName = \"load_jimage_library\"\n+            moduleName = \"libjvm.dylib\">\n+            <Actions>\n+               <BreakpointActionProxy\n+                  ActionExtensionID = \"Xcode.BreakpointAction.DebuggerCommand\">\n+                  <ActionContent\n+                     consoleCommand = \"process handle -n true -p true -s false SIGSEGV SIGBUS SIGUSR2\">\n+                  <\/ActionContent>\n+               <\/BreakpointActionProxy>\n+            <\/Actions>\n+            <Locations>\n+               <Location\n+                  shouldBeEnabled = \"Yes\"\n+                  ignoreCount = \"0\"\n+                  continueAfterRunningActions = \"No\"\n+                  symbolName = \"ClassLoader::load_jimage_library()\"\n+                  moduleName = \"libjvm.dylib\"\n+                  usesParentBreakpointCondition = \"Yes\"\n+                  timestampString = \"0\"\n+                  startingColumnNumber = \"0\"\n+                  endingColumnNumber = \"0\"\n+                  startingLineNumber = \"0\"\n+                  endingLineNumber = \"0\"\n+                  offsetFromSymbolStart = \"0\">\n+               <\/Location>\n+            <\/Locations>\n+         <\/BreakpointContent>\n+      <\/BreakpointProxy>\n+   <\/Breakpoints>\n+<\/Bucket>\n","filename":"make\/ide\/xcode\/hotspot\/data\/Breakpoints_v2.xcbkptlist.template","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Scheme\n+   LastUpgradeVersion = \"0900\"\n+   version = \"1.3\">\n+   <BuildAction\n+      parallelizeBuildables = \"YES\"\n+      buildImplicitDependencies = \"YES\">\n+      <BuildActionEntries>\n+         <BuildActionEntry\n+            buildForTesting = \"YES\"\n+            buildForRunning = \"YES\"\n+            buildForProfiling = \"NO\"\n+            buildForArchiving = \"NO\"\n+            buildForAnalyzing = \"YES\">\n+            <BuildableReference\n+               BuildableIdentifier = \"primary\"\n+               BlueprintIdentifier = \"D60000000000000000000000\"\n+               BuildableName = \"libjvm.dylib\"\n+               BlueprintName = \"jvm\"\n+               ReferencedContainer = \"container:hotspot.xcodeproj\">\n+            <\/BuildableReference>\n+         <\/BuildActionEntry>\n+      <\/BuildActionEntries>\n+   <\/BuildAction>\n+   <TestAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\">\n+      <Testables>\n+      <\/Testables>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/TestAction>\n+   <LaunchAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      launchStyle = \"0\"\n+      useCustomWorkingDirectory = \"NO\"\n+      ignoresPersistentStateOnLaunch = \"NO\"\n+      debugDocumentVersioning = \"YES\"\n+      debugServiceExtension = \"internal\"\n+      allowLocationSimulation = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <CommandLineArguments>\n+         <CommandLineArgument\n+            argument = \"-version\"\n+            isEnabled = \"YES\">\n+         <\/CommandLineArgument>\n+      <\/CommandLineArguments>\n+      <EnvironmentVariables>\n+         <EnvironmentVariable\n+            key = \"DYLD_PRINT_ENV\"\n+            value = \"1\"\n+            isEnabled = \"YES\">\n+         <\/EnvironmentVariable>\n+      <\/EnvironmentVariables>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/LaunchAction>\n+   <ProfileAction\n+      buildConfiguration = \"Release\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\"\n+      savedToolIdentifier = \"\"\n+      useCustomWorkingDirectory = \"NO\"\n+      debugDocumentVersioning = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+   <\/ProfileAction>\n+   <AnalyzeAction\n+      buildConfiguration = \"Release\">\n+   <\/AnalyzeAction>\n+   <ArchiveAction\n+      buildConfiguration = \"Release\"\n+      revealArchiveInOrganizer = \"YES\">\n+   <\/ArchiveAction>\n+<\/Scheme>\n","filename":"make\/ide\/xcode\/hotspot\/data\/jvm.xcscheme.template","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,207 @@\n+\/\/ !$*UTF8*$!\n+{\n+\tarchiveVersion = 1;\n+\tclasses = {\n+\t};\n+\tobjectVersion = 48;\n+\tobjects = {\n+\n+\/* Begin PBXBuildFile section *\/\n+TEMPLATE_PBXBUILDFILE\n+\/* End PBXBuildFile section *\/\n+\n+\/* Begin PBXFileReference section *\/\n+\t\tD60000000000000000000003 \/* script_before.sh *\/ = {isa = PBXFileReference; lastKnownFileType = text.script.sh; path = script_before.sh; sourceTree = \"<group>\"; };\n+\t\tD60000000000000000000002 \/* script_after.sh *\/ = {isa = PBXFileReference; lastKnownFileType = text.script.sh; path = script_after.sh; sourceTree = \"<group>\"; };\n+\t\tD60000000000000000000006 \/* libjvm.dylib *\/ = {isa = PBXFileReference; explicitFileType = \"compiled.mach-o.dylib\"; includeInIndex = 0; path = libjvm.dylib; sourceTree = BUILT_PRODUCTS_DIR; };\n+TEMPLATE_PBXFILEREFERENCE\n+\/* End PBXFileReference section *\/\n+\n+\/* Begin PBXGroup section *\/\n+\t\tD60000000000000000000004 \/* scripts *\/ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tD60000000000000000000003 \/* script_before.sh *\/,\n+\t\t\t\tD60000000000000000000002 \/* script_after.sh *\/,\n+\t\t\t);\n+\t\t\tname = scripts;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\tD60000000000000000000005 \/* Products *\/ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tD60000000000000000000006 \/* libjvm.dylib *\/,\n+\t\t\t);\n+\t\t\tname = Products;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\tD60000000000000000000001 = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tD60000000000000000000004 \/* scripts *\/,\n+TEMPLATE_GROUP_GENSRC \/* gensrc *\/,\n+TEMPLATE_GROUP_SRC \/* src *\/,\n+TEMPLATE_GROUP_TEST \/* test *\/,\n+\t\t\t\tD60000000000000000000005 \/* Products *\/,\n+\t\t\t);\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+TEMPLATE_GROUPS\n+\/* End PBXGroup section *\/\n+\n+\/* Begin PBXNativeTarget section *\/\n+\t\tD60000000000000000000000 \/* jvm *\/ = {\n+\t\t\tisa = PBXNativeTarget;\n+\t\t\tbuildConfigurationList = D6000000000000000000000F \/* Build configuration list for PBXNativeTarget \"jvm\" *\/;\n+\t\t\tbuildPhases = (\n+\t\t\t\tD60000000000000000000007 \/* Run script_before *\/,\n+\t\t\t\tD60000000000000000000008 \/* Sources *\/,\n+\t\t\t\tD6000000000000000000000A \/* Run script_after *\/,\n+\t\t\t);\n+\t\t\tbuildRules = (\n+\t\t\t);\n+\t\t\tdependencies = (\n+\t\t\t);\n+\t\t\tname = jvm;\n+\t\t\tproductName = jvm;\n+\t\t\tproductReference = D60000000000000000000006 \/* libjvm.dylib *\/;\n+\t\t\tproductType = \"com.apple.product-type.library.dynamic\";\n+\t\t};\n+\/* End PBXNativeTarget section *\/\n+\n+\/* Begin PBXProject section *\/\n+\t\tD60000000000000000000010 \/* Project object *\/ = {\n+\t\t\tisa = PBXProject;\n+\t\t\tattributes = {\n+\t\t\t\tLastUpgradeCheck = 0900;\n+\t\t\t\tORGANIZATIONNAME = Oracle;\n+\t\t\t\tTargetAttributes = {\n+\t\t\t\t\tD60000000000000000000000 = {\n+\t\t\t\t\t\tCreatedOnToolsVersion = 9.0;\n+\t\t\t\t\t\tProvisioningStyle = Automatic;\n+\t\t\t\t\t};\n+\t\t\t\t};\n+\t\t\t};\n+\t\t\tbuildConfigurationList = D6000000000000000000000E \/* Build configuration list for PBXProject \"jvm\" *\/;\n+\t\t\tcompatibilityVersion = \"Xcode 8.0\";\n+\t\t\tdevelopmentRegion = en;\n+\t\t\thasScannedForEncodings = 0;\n+\t\t\tknownRegions = (\n+\t\t\t\ten,\n+\t\t\t);\n+\t\t\tmainGroup = D60000000000000000000001;\n+\t\t\tproductRefGroup = D60000000000000000000005 \/* Products *\/;\n+\t\t\tprojectDirPath = \"\";\n+\t\t\tprojectRoot = \"\";\n+\t\t\ttargets = (\n+\t\t\t\tD60000000000000000000000 \/* jvm *\/,\n+\t\t\t);\n+\t\t};\n+\/* End PBXProject section *\/\n+\n+\/* Begin PBXShellScriptBuildPhase section *\/\n+\t\tD60000000000000000000007 \/* Run script_before *\/ = {\n+\t\t\tisa = PBXShellScriptBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\tinputPaths = (\n+\t\t\t);\n+\t\t\tname = \"Run script_before\";\n+\t\t\toutputPaths = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t\tshellPath = \/bin\/sh;\n+\t\t\tshellScript = \"cd $PROJECT_DIR;\\ntime .\/script_before.sh;\\n\";\n+\t\t};\n+\t\tD6000000000000000000000A \/* Run script_after *\/ = {\n+\t\t\tisa = PBXShellScriptBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\tinputPaths = (\n+\t\t\t);\n+\t\t\tname = \"Run script_after\";\n+\t\t\toutputPaths = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t\tshellPath = \/bin\/sh;\n+\t\t\tshellScript = \"cd $PROJECT_DIR;\\ntime .\/script_after.sh;\\n\";\n+\t\t};\n+\/* End PBXShellScriptBuildPhase section *\/\n+\n+\/* Begin PBXSourcesBuildPhase section *\/\n+\t\tD60000000000000000000008 \/* Sources *\/ = {\n+\t\t\tisa = PBXSourcesBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+TEMPLATE_PBXSOURCESSBUILDPHASE\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t};\n+\/* End PBXSourcesBuildPhase section *\/\n+\n+\/* Begin XCBuildConfiguration section *\/\n+\t\tD6000000000000000000000B \/* Release *\/ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tALWAYS_SEARCH_USER_PATHS = YES;\n+\t\t\t\tCLANG_CXX_LANGUAGE_STANDARD = \"gnu++14\";\n+\t\t\t\tCODE_SIGN_IDENTITY = \"-\";\n+\t\t\t\tCONFIGURATION_BUILD_DIR = build\/jdk\/lib\/server;\n+\t\t\t\tCONFIGURATION_TEMP_DIR = build;\n+\t\t\t\tCOPY_PHASE_STRIP = NO;\n+\t\t\t\tDEBUG_INFORMATION_FORMAT = \"dwarf-with-dsym\";\n+\t\t\t\tMTL_ENABLE_DEBUG_INFO = NO;\n+\t\t\t\tOBJROOT = build;\n+\t\t\t\tONLY_ACTIVE_ARCH = YES;\n+\t\t\t\tSDKROOT = macosx;\n+\t\t\t};\n+\t\t\tname = Release;\n+\t\t};\n+\t\tD6000000000000000000000D \/* Release *\/ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tCONFIGURATION_BUILD_DIR = \"$(BUILD_DIR)\";\n+\t\t\t\tEXECUTABLE_PREFIX = lib;\n+\t\t\t\tFRAMEWORK_SEARCH_PATHS = (\n+TEMPLATE_FRAMEWORK_SEARCH_PATHS\n+\t\t\t\t);\n+\t\t\t\tOTHER_CFLAGS = (\n+TEMPLATE_OTHER_CFLAGS\n+\t\t\t\t);\n+\t\t\t\tOTHER_LDFLAGS = (\n+TEMPLATE_OTHER_LDFLAGS\n+\t\t\t\t);\n+\t\t\t\tPRODUCT_NAME = \"$(TARGET_NAME)\";\n+\t\t\t\tSKIP_INSTALL = YES;\n+\t\t\t\tSYMROOT = build\/jdk\/lib\/server;\n+\t\t\t\tUSER_HEADER_SEARCH_PATHS = (\n+TEMPLATE_USER_HEADER_SEARCH_PATHS\n+\t\t\t\t);\n+\t\t\t};\n+\t\t\tname = Release;\n+\t\t};\n+\/* End XCBuildConfiguration section *\/\n+\n+\/* Begin XCConfigurationList section *\/\n+\t\tD6000000000000000000000E \/* Build configuration list for PBXProject \"jvm\" *\/ = {\n+\t\t\tisa = XCConfigurationList;\n+\t\t\tbuildConfigurations = (\n+\t\t\t\tD6000000000000000000000B \/* Release *\/,\n+\t\t\t);\n+\t\t\tdefaultConfigurationIsVisible = 0;\n+\t\t\tdefaultConfigurationName = Release;\n+\t\t};\n+\t\tD6000000000000000000000F \/* Build configuration list for PBXNativeTarget \"jvm\" *\/ = {\n+\t\t\tisa = XCConfigurationList;\n+\t\t\tbuildConfigurations = (\n+\t\t\t\tD6000000000000000000000D \/* Release *\/,\n+\t\t\t);\n+\t\t\tdefaultConfigurationIsVisible = 0;\n+\t\t\tdefaultConfigurationName = Release;\n+\t\t};\n+\/* End XCConfigurationList section *\/\n+\t};\n+\trootObject = D60000000000000000000010 \/* Project object *\/;\n+}\n","filename":"make\/ide\/xcode\/hotspot\/data\/project.pbxproj.template","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Scheme\n+   LastUpgradeVersion = \"0900\"\n+   version = \"1.3\">\n+   <BuildAction\n+      parallelizeBuildables = \"YES\"\n+      buildImplicitDependencies = \"YES\">\n+      <BuildActionEntries>\n+         <BuildActionEntry\n+            buildForTesting = \"YES\"\n+            buildForRunning = \" NO\"\n+            buildForProfiling = \"NO\"\n+            buildForArchiving = \"NO\"\n+            buildForAnalyzing = \"NO\">\n+            <BuildableReference\n+               BuildableIdentifier = \"primary\"\n+               BlueprintIdentifier = \"D60000000000000000000000\"\n+               BuildableName = \"libjvm.dylib\"\n+               BlueprintName = \"jvm\"\n+               ReferencedContainer = \"container:hotspot.xcodeproj\">\n+            <\/BuildableReference>\n+         <\/BuildActionEntry>\n+      <\/BuildActionEntries>\n+   <\/BuildAction>\n+   <TestAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\">\n+      <Testables>\n+      <\/Testables>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/TestAction>\n+   <LaunchAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      launchStyle = \"0\"\n+      useCustomWorkingDirectory = \"NO\"\n+      ignoresPersistentStateOnLaunch = \"NO\"\n+      debugDocumentVersioning = \"YES\"\n+      debugServiceExtension = \"internal\"\n+      allowLocationSimulation = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <CommandLineArguments>\n+         <CommandLineArgument\n+            argument = \"-jar TEMPLATE_JDK_PATH\/build\/jdk\/demo\/jfc\/J2Ddemo\/J2Ddemo.jar\"\n+            isEnabled = \"YES\">\n+         <\/CommandLineArgument>\n+      <\/CommandLineArguments>\n+      <EnvironmentVariables>\n+         <EnvironmentVariable\n+            key = \"DYLD_PRINT_ENV\"\n+            value = \"1\"\n+            isEnabled = \"YES\">\n+         <\/EnvironmentVariable>\n+      <\/EnvironmentVariables>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/LaunchAction>\n+   <ProfileAction\n+      buildConfiguration = \"Release\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\"\n+      savedToolIdentifier = \"\"\n+      useCustomWorkingDirectory = \"NO\"\n+      debugDocumentVersioning = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+   <\/ProfileAction>\n+   <AnalyzeAction\n+      buildConfiguration = \"Release\">\n+   <\/AnalyzeAction>\n+   <ArchiveAction\n+      buildConfiguration = \"Release\"\n+      revealArchiveInOrganizer = \"YES\">\n+   <\/ArchiveAction>\n+<\/Scheme>\n","filename":"make\/ide\/xcode\/hotspot\/data\/runJ2Demo.xcscheme.template","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+echo \"running script_after.sh\"\n+\n+readonly JDK_LIB_PATH=\"build\/jdk\/lib\/server\/libjvm.dylib\";\n+\n+if [ ! -f ${JDK_LIB_PATH} ] ; then\n+{\n+    echo \">>>>>>>   Cannot find ${JDK_LIB_PATH}, the build failed!?\";\n+    exit 1;\n+}\n+fi\n","filename":"make\/ide\/xcode\/hotspot\/data\/script_after.sh","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+echo \"running script_before.sh\"\n+\n+readonly JDK_BUILD_PATH=\"..\";\n+readonly JAVAC_LOCATE_PATTERN=\"images\/jdk\/bin\/javac\";\n+readonly HOTSPOT_TOUCH_FILE=\"..\/..\/..\/src\/hotspot\/os\/posix\/jvm_posix.cpp\";\n+\n+echo \">>>>>>> Making a copy of JDK ...\";\n+\n+javac_file_array=( $(find ${JDK_BUILD_PATH} | grep ${JAVAC_LOCATE_PATTERN}) );\n+javac_file=${javac_file_array[0]};\n+if [ -z ${javac_file} ] ; then\n+{\n+  echo \">>>>>>>   ERROR: could not locate ${JAVAC_LOCATE_PATTERN} (did you remember to do \\\"make images\\\"?)\";\n+  exit 1;\n+}\n+fi\n+\n+jdk_build_path=$(dirname $(dirname ${javac_file}));\n+if [ ! -f \"build\/${JAVAC_LOCATE_PATTERN}\" ] ; then\n+{\n+  echo \">>>>>>>   Copying jdk over...\";\n+  rsync -a \"${jdk_build_path}\" \"build\/\";\n+}\n+fi\n+\n+# the following files will be supplied by the Xcode build\n+rm -rf \"build\/jdk\/lib\/server\/libjvm.dylib\";\n+rm -rf \"build\/jdk\/lib\/server\/libjvm.dylib.dSYM\";\n+\n+echo \">>>>>>> DONE\";\n+\n+echo \">>>>>>> Touching ${HOTSPOT_TOUCH_FILE} to force HotspotVM rebuilt\";\n+if [ ! -f ${HOTSPOT_TOUCH_FILE} ] ; then\n+{\n+    echo \">>>>>>>   Cannot find ${HOTSPOT_TOUCH_FILE}\";\n+    exit 1;\n+}\n+fi\n+touch ${HOTSPOT_TOUCH_FILE};\n+\n+echo \">>>>>>> DONE\";\n+\n+echo \">>>>>>> Xcode should be building the HotspotVM now...\";\n","filename":"make\/ide\/xcode\/hotspot\/data\/script_before.sh","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,291 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+public class DiskFile extends LinkedHashMap<Path, DiskFile> implements Comparable<DiskFile> {\n+    \/\/ xcode id ex: D50000000000000000000000\n+    private static long xcodeIdCount = 0xF0000001;\n+    private final Path path;\n+    private final boolean directory;\n+    private final String xcodeId;\n+    private final String xcodeId2;\n+    private Iterable<String> compilerFlags;\n+\n+    public DiskFile(String path, boolean directory) {\n+        this(stringToPath(path), directory);\n+    }\n+\n+    private DiskFile(Path path, boolean directory) {\n+        this.path = path;\n+        this.directory = directory;\n+        this.compilerFlags = null;\n+        this.xcodeId = getNextXcodeId();\n+        this.xcodeId2 = getNextXcodeId();\n+    }\n+\n+    private static Path stringToPath(String string) {\n+        if (string != null) {\n+            return new File(string).toPath();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static Path clipPath(Path path, String clip) {\n+        return clipPath(path.toString(), clip);\n+    }\n+\n+    private static Path clipPath(String path, String clip) {\n+        String subpath = path;\n+        if (path.contains(clip)) {\n+            subpath = clip;\n+        }\n+        int index = path.indexOf(subpath);\n+        return stringToPath(path.substring(index));\n+    }\n+\n+    private String getNextXcodeId() {\n+        String id = \"D5FFFFFF\" + Long.toHexString(xcodeIdCount).toUpperCase(Locale.ROOT);\n+        xcodeIdCount++;\n+\n+        return id;\n+    }\n+\n+    private String getPath() {\n+        return this.path.toString();\n+    }\n+\n+    public boolean isDirectory() {\n+        return this.directory;\n+    }\n+\n+    public void markAsCompiled(List<String> compilerFlags) {\n+        this.compilerFlags = compilerFlags;\n+    }\n+\n+    private boolean isCompiled() {\n+        return (this.compilerFlags != null);\n+    }\n+\n+    public String getXcodeId() {\n+        return this.xcodeId;\n+    }\n+\n+    public String generatePbxSourcesBuildPhase() {\n+        String string = \"\";\n+        if (isCompiled()) {\n+            String fileName = getFileName();\n+            string += String.format(\"        %s \/* %s in Sources *\/,\\n\", this.xcodeId2, fileName);\n+        } else if (isDirectory()) {\n+            for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+                DiskFile file = entry.getValue();\n+                string += file.generatePbxSourcesBuildPhase();\n+            }\n+        }\n+        return string;\n+    }\n+\n+    \/\/ D5FFFFFFFFFFFFFFF0006506 \/* vm_version.cpp in Sources *\/ = {isa = PBXBuildFile; fileRef = D5FFFFFFFFFFFFFFF0006505 \/* vm_version.cpp *\/; settings = {COMPILER_FLAGS = HEREHERE; }; };\n+    public String generatePbxBuildFile() {\n+        String string = \"\";\n+        if (isCompiled()) {\n+            String flagsString = \"\";\n+            for (String flag : this.compilerFlags) {\n+                flagsString += flag.replace(\"\\\"\", \"\\\\\\\\\\\"\") + \" \";\n+            }\n+            String fileName = getFileName();\n+            string += String.format(\"    %s \/* %s in Sources *\/ = {isa = PBXBuildFile; fileRef = %s \/* %s *\/; settings = {COMPILER_FLAGS = \\\"%s\\\"; }; };\\n\", this.xcodeId2, fileName, this.xcodeId, fileName, flagsString);\n+        } else if (isDirectory()) {\n+            for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+                DiskFile file = entry.getValue();\n+                string += file.generatePbxBuildFile();\n+            }\n+        }\n+        return string;\n+    }\n+\n+    public String generatePbxFileReference(String relativePathToRoot) {\n+        String string = \"\";\n+        if (!isDirectory()) {\n+            String fileName = getFileName();\n+            String suffix = getFileNameSuffix();\n+            string += String.format(\"    %s \/* %s *\/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = %s%s; name = %s; path = \\\"%s%s\\\"; sourceTree = \\\"<group>\\\"; };\\n\", this.xcodeId, fileName, fileName, suffix, fileName, relativePathToRoot, getPath());\n+        } else if (isDirectory()) {\n+            for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+                DiskFile file = entry.getValue();\n+                string += file.generatePbxFileReference(relativePathToRoot);\n+            }\n+        }\n+        return string;\n+    }\n+\n+    public String generatePbxGroup() {\n+        String string = String.format(\"    %s \/* %s *\/ = {\\n      isa = PBXGroup;\\n      children = (\\n\", this.xcodeId, getFileName());\n+\n+        Set<DiskFile> sortedSet = new TreeSet<>(values());\n+\n+        for (DiskFile file : sortedSet) {\n+            string += String.format(\"        %s \/* %s *\/,\\n\", file.getXcodeId(), file.getFileName());\n+        }\n+        string += String.format(\"      );\\n      name = %s;\\n      sourceTree = \\\"<group>\\\";\\n    };\\n\", getFileName());\n+\n+        for (DiskFile file : sortedSet) {\n+            if (file.isDirectory()) {\n+                string += file.generatePbxGroup();\n+            }\n+        }\n+\n+        return string;\n+    }\n+\n+    private ArrayList<DiskFile> getFiles(ArrayList<DiskFile> array) {\n+        for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+            DiskFile file = entry.getValue();\n+            if (file.isDirectory()) {\n+                array.add(file);\n+                array = file.getFiles(array);\n+            } else {\n+                array.add(file);\n+            }\n+        }\n+        return array;\n+    }\n+\n+    public ArrayList<DiskFile> getFiles() {\n+        return getFiles(new ArrayList<>());\n+    }\n+\n+    public String getFilePath() {\n+        return this.path.toString();\n+    }\n+\n+    private String getFileName() {\n+        Path fileName = this.path.getFileName();\n+        if (fileName != null) {\n+            return fileName.toString();\n+        } else {\n+            return this.path.toString();\n+        }\n+    }\n+\n+    private String getFileNameNoSuffix() {\n+        String string;\n+        Path fileName = this.path.getFileName();\n+        if (fileName != null) {\n+            string = fileName.toString();\n+            int index = string.indexOf('.');\n+            if (index >= 0) {\n+                string = string.substring(0, index);\n+            }\n+        } else {\n+            string = this.path.toString();\n+        }\n+        return string;\n+    }\n+\n+    private String getFileNameSuffix() {\n+        String fileName = getFileName();\n+        int index = fileName.indexOf('.');\n+        if (index >= 0) {\n+            return fileName.substring(index);\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    public DiskFile getChild(String fileName) {\n+        DiskFile child = null;\n+        for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+            DiskFile file = entry.getValue();\n+            if (file.getFileName().equals(fileName)) {\n+                child = entry.getValue();\n+                break;\n+            } else if (file.isDirectory()) {\n+                child = file.getChild(fileName);\n+                if (child != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        return child;\n+    }\n+\n+    private DiskFile getParent(Path path) {\n+        Path pathParent = path.getParent();\n+        DiskFile parent = get(pathParent);\n+        if (parent == null) {\n+            if (this.path.equals(pathParent)) {\n+                parent = this;\n+            } else {\n+                parent = getParent(pathParent).get(pathParent);\n+            }\n+            parent.putIfAbsent(path, new DiskFile(path, true));\n+        }\n+        return parent;\n+    }\n+\n+    public void addFile(Path path, String clip) {\n+        path = clipPath(path, clip);\n+        DiskFile parent = getParent(path);\n+        parent.put(path, new DiskFile(path, false));\n+    }\n+\n+    public void addDirectory(Path path, String clip) {\n+        path = clipPath(path, clip);\n+        DiskFile parent = getParent(path);\n+        parent.putIfAbsent(path, new DiskFile(path, true));\n+    }\n+\n+    @Override\n+    public int compareTo(DiskFile file) {\n+        \/\/ \".hpp\", then \".inline.hpp\", then \".cpp\"\n+        int equal = getFileNameNoSuffix().compareTo(file.getFileNameNoSuffix());\n+        if (equal == 0) {\n+            String suffix1 = getFileNameSuffix();\n+            String suffix2 = file.getFileNameSuffix();\n+            if (!suffix1.equals(\".inline.hpp\") && !suffix2.equals(\".inline.hpp\")) {\n+                \/\/ .hpp before .cpp\n+                equal = -(getFileNameSuffix().compareTo(file.getFileNameSuffix()));\n+            } else if (suffix1.equals(\".inline.hpp\") && suffix2.equals(\".hpp\")) {\n+                return 1;\n+            } else if (suffix1.equals(\".inline.hpp\") && suffix2.equals(\".cpp\")) {\n+                return -1;\n+            } else if (suffix1.equals(\".hpp\") && suffix2.equals(\".inline.hpp\")) {\n+                return -1;\n+            } else if (suffix1.equals(\".cpp\") && suffix2.equals(\".inline.hpp\")) {\n+                return 1;\n+            }\n+        }\n+        return equal;\n+    }\n+}\n","filename":"make\/ide\/xcode\/hotspot\/src\/classes\/DiskFile.java","additions":291,"deletions":0,"binary":false,"changes":291,"status":"added"},{"patch":"@@ -0,0 +1,754 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystemLoopException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+public final class XcodeProjectMaker {\n+    private static final String JDK_SCRIPT_TOKEN_1 = \"configure\";\n+    private static final String JDK_SCRIPT_TOKEN_2 = \".jcheck\";\n+    private static final String COMPILER_LINE_HEADER = \"-I\";\n+    private static final String COMPILER_IFRAMEWORK = \"-iframework\";\n+    private static final String COMPILER_FFRAMEWORK = \"-F\";\n+    private static final String SRC_HOTSPOT_PATH = \"\/src\/hotspot\";\n+    private static final String TEST_HOTSPOT_PATH = \"\/test\/hotspot\/gtest\";\n+    private static final String ALIAS_JAVA_OLD = \"java_old.sh\";\n+    private static final String ALIAS_JAVA_NEW = \"java_new.sh\";\n+    private static final String JDK_BIN_JAVA = \"\/jdk\/bin\/java\";\n+    private static final String FILE_TOKEN = \"\\\"file\\\": \";\n+    private static final String COMMAND_TOKEN = \"\\\"command\\\": \";\n+    private static final String QUOTE_START_TOKEN = \"'\\\\\\\"\";\n+    private static final String QUOTE_END_TOKEN = \"\\\\\\\"'\";\n+    private static final String VERSION = \"2.0.0\";\n+    private static final String EXCLUDE_PARSE_TOKEN_1 = \"gtest\";\n+    private static final String TEMPLATE_FRAMEWORK_SEARCH_PATHS = \"TEMPLATE_FRAMEWORK_SEARCH_PATHS\";\n+    private static final String TEMPLATE_OTHER_CFLAGS = \"TEMPLATE_OTHER_CFLAGS\";\n+    private static final String TEMPLATE_OTHER_LDFLAGS = \"TEMPLATE_OTHER_LDFLAGS\";\n+    private static final String TEMPLATE_USER_HEADER_SEARCH_PATHS = \"TEMPLATE_USER_HEADER_SEARCH_PATHS\";\n+    private static final String TEMPLATE_GROUP_GENSRC = \"TEMPLATE_GROUP_GENSRC\";\n+    private static final String TEMPLATE_GROUP_SRC = \"TEMPLATE_GROUP_SRC\";\n+    private static final String TEMPLATE_GROUP_TEST = \"TEMPLATE_GROUP_TEST\";\n+    private static final String TEMPLATE_GROUPS = \"TEMPLATE_GROUPS\";\n+    private static final String TEMPLATE_PBXBUILDFILE = \"TEMPLATE_PBXBUILDFILE\";\n+    private static final String TEMPLATE_PBXFILEREFERENCE = \"TEMPLATE_PBXFILEREFERENCE\";\n+    private static final String TEMPLATE_PBXSOURCESSBUILDPHASE = \"TEMPLATE_PBXSOURCESSBUILDPHASE\";\n+    private static final String TEMPLATE_JDK_PATH = \"TEMPLATE_JDK_PATH\";\n+    private static final String HOTSPOT_PBXPROJ = \"hotspot.xcodeproj\";\n+    private static final String PBXPROJ = \"project.pbxproj\";\n+    private static final String XCSAHAREDDATA = \"xcshareddata\";\n+    private static final String XCSCHEMES = \"xcschemes\";\n+    private static final String JVM_XCSCHEME = \"jvm.xcscheme\";\n+    private static final String J2D_XCSCHEME = \"runJ2Demo.xcscheme\";\n+    private static final String XCDEBUGGER = \"xcdebugger\";\n+    private static final String XCBKPTLIST = \"Breakpoints_v2.xcbkptlist\";\n+    private static final String TEMPLATE_PBXPROJ = PBXPROJ + \".template\";\n+    private static final String TEMPLATE_JVM_XCSCHEME = JVM_XCSCHEME + \".template\";\n+    private static final String TEMPLATE_J2D_XCSCHEME = J2D_XCSCHEME + \".template\";\n+    private static final String TEMPLATE_XCBKPTLIST = XCBKPTLIST + \".template\";\n+    private static final String[] EXCLUDE_FILES_PREFIX = {\".\"};\n+    private static final String[] EXCLUDE_FILES_POSTFIX = {\".log\", \".cmdline\"};\n+    private static final String[] COMPILER_FLAGS_INCLUDE = {\"-m\", \"-f\", \"-D\", \"-W\"};\n+    private static final String[] COMPILER_FLAGS_IS = {\"-g\", \"-Os\", \"-0\"};\n+    private static final String[] COMPILER_FLAGS_EXCLUDE = {\"-DTHIS_FILE\", \"-DGTEST_OS_MAC\", \"-mmacosx-version-min\", \"-Werror\"}; \/\/ \"-Werror\" causes Xcode to stop compiling\n+    private static final int EXIT4 = -4;\n+    private static final int EXIT5 = -5;\n+    private static final int EXIT6 = -6;\n+    private static final int EXIT7 = -7;\n+\n+    private final HashMap<String, ArrayList<String>> compiledFiles = new HashMap<>();\n+    private final TreeSet<String> compilerFlags = new TreeSet<>();\n+    private List<String> linkerFlags = List.of();\n+    private final TreeSet<String> headerPaths = new TreeSet<>();\n+    private final boolean debugLog;\n+    private String projectMakerDataPath = null;\n+    private String generatedHotspotPath = null;\n+    private String iframework = null;\n+    private String fframework = null;\n+    private DiskFile rootGensrc = new DiskFile(\"\/\", true);\n+    private DiskFile rootSrc = new DiskFile(\"\/\", true);\n+    private DiskFile rootTest = new DiskFile(\"\/\", true);\n+\n+    public XcodeProjectMaker(boolean debugLog) {\n+        this.debugLog = debugLog;\n+    }\n+\n+    public static void main(String[] args) {\n+        String workspaceRoot = args[0];\n+        String outputDir = args[1];\n+        String pathToProjectMakerData = args[2];\n+        String pathToCompileCommands = args[3];\n+        String pathToLinkerOptionsFile = args[4];\n+        String linkerOptionsString = readFile(pathToLinkerOptionsFile);\n+        boolean debugLog = args.length > 5 && args[5].equals(\"-d\");\n+\n+        File xcodeFolder = new File(outputDir);\n+        xcodeFolder.mkdirs();\n+        String workspaceRootPathFromOutputDir = findRelativePathToWorkspaceRoot(outputDir);\n+\n+        if (debugLog) {\n+            System.out.println();\n+            System.out.println(\"Version \" + VERSION);\n+            System.out.println();\n+            System.out.println(\"       Path to workspace root is \\\"\" + workspaceRoot + \"\\\"\");\n+            System.out.println(\"Path to compile commands file is \\\"\" + pathToCompileCommands + \"\\\"\");\n+            System.out.println(\" Xcode project will be placed in \\\"\" + outputDir + \"\\\"\");\n+            System.out.println();\n+        }\n+\n+        XcodeProjectMaker maker = new XcodeProjectMaker(debugLog);\n+        maker.parseHotspotCompileCommands(pathToCompileCommands);\n+        maker.linkerFlags = List.of(linkerOptionsString.split(\" \"));\n+        maker.projectMakerDataPath = pathToProjectMakerData;\n+\n+        maker.printLogDetails();\n+\n+        maker.prepareFiles(workspaceRoot);\n+        maker.makeXcodeProj(outputDir, workspaceRootPathFromOutputDir);\n+\n+        String pathToBuild = getFileParent(outputDir);\n+        maker.makeAliases(outputDir, pathToBuild);\n+\n+        System.out.println();\n+        System.out.println(\"The Xcode project for hotspot was succesfully created\");\n+        System.out.println(\"It can be found in '\" + outputDir + \"\/\" + HOTSPOT_PBXPROJ + \"'\");\n+        System.out.println();\n+    }\n+\n+    \/\/ find a path to what looks like jdk\n+    private static String findRelativePathToWorkspaceRoot(String root) {\n+        String pathToWorkspaceRoot = null;\n+        String path = root;\n+        boolean found1 = false;\n+        boolean found2 = false;\n+\n+        while (!found1 && !found2) {\n+            File folder = new File(path);\n+            File[] files = folder.listFiles();\n+            for (File file : files) {\n+                String fileName = file.toPath().getFileName().toString();\n+                if (fileName.equals(JDK_SCRIPT_TOKEN_1)) {\n+                    found1 = true;\n+                }\n+                if (fileName.equals(JDK_SCRIPT_TOKEN_2)) {\n+                    found2 = true;\n+                }\n+                if (found1 && found2) {\n+                    break;\n+                }\n+            }\n+\n+            if (!found1 && !found2) {\n+                path = Paths.get(path).getParent().toString();\n+                if (pathToWorkspaceRoot == null) {\n+                    pathToWorkspaceRoot = \"..\";\n+                } else {\n+                    pathToWorkspaceRoot += \"\/..\";\n+                }\n+            }\n+        }\n+        return pathToWorkspaceRoot;\n+    }\n+\n+    private static String readFile(File file) {\n+        return readFile(file.toPath());\n+    }\n+\n+    private static String readFile(String path) {\n+        return readFile(Paths.get(path));\n+    }\n+\n+    private static String readFile(Path path) {\n+        try {\n+            return Files.readString(path);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+\n+    private static void writeFile(File file, String string) {\n+        writeFile(file.toPath(), string);\n+    }\n+\n+    private static void writeFile(Path path, String string) {\n+        try {\n+            Files.writeString(path, string);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            System.exit(EXIT4);\n+        }\n+    }\n+\n+    private static boolean excludeFile(Path path) {\n+        return excludeFile(path.toString());\n+    }\n+\n+    private static boolean excludeFile(String string) {\n+        return excludeFile(string, null);\n+    }\n+\n+    private static boolean excludeFile(String string, String exclude) {\n+        if (exclude != null) {\n+            if (contains(string, exclude)) {\n+                return true;\n+            }\n+        }\n+        for (String excludeFilesPrefix : EXCLUDE_FILES_PREFIX) {\n+            if (string.startsWith(excludeFilesPrefix)) {\n+                return true;\n+            }\n+        }\n+        for (String excludeFilesPostfix : EXCLUDE_FILES_POSTFIX) {\n+            if (string.endsWith(excludeFilesPostfix)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean isExcludeCompilerFlag(String string) {\n+        boolean flag = false;\n+        for (String exclude : COMPILER_FLAGS_EXCLUDE) {\n+            if (string.contains(exclude)) {\n+                flag = true;\n+                break;\n+            }\n+        }\n+        return flag;\n+    }\n+\n+    private static boolean isCompilerFlag(String string) {\n+        boolean flag = false;\n+        for (String include : COMPILER_FLAGS_INCLUDE) {\n+            if (string.startsWith(include)) {\n+                flag = true;\n+                break;\n+            }\n+        }\n+        for (String is : COMPILER_FLAGS_IS) {\n+            if (string.equals(is)) {\n+                flag = true;\n+                break;\n+            }\n+        }\n+        if (isExcludeCompilerFlag(string)) {\n+            flag = false;\n+        }\n+        return flag;\n+    }\n+\n+    private static String strip(String string) {\n+        return string.substring(2, string.length() - 1);\n+    }\n+\n+    private static String strip(String string, String token) {\n+        int start = string.indexOf(token);\n+        int end = start + token.length();\n+        return strip(string.substring(end));\n+    }\n+\n+    private static boolean contains(String string, String token) {\n+        return ((string.length() >= token.length()) && (string.contains(token)));\n+    }\n+\n+    private static String getFileParent(String path) {\n+        return Paths.get(path).getParent().toString();\n+    }\n+\n+    private static String extractPath(String string, String from, String to) {\n+        String result = null;\n+        String[] tokens = string.split(\"\/\");\n+        int i = 0;\n+        for (; i < tokens.length; i++) {\n+            if (tokens[i].equals(from)) {\n+                result = \"\";\n+                break;\n+            }\n+        }\n+        for (; i < tokens.length; i++) {\n+            result += \"\/\" + tokens[i];\n+            if (tokens[i].equals(to)) {\n+                break;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private void extractCommonCompilerFlags() {\n+        \/\/ heuristic, find average count of number of flags used by each compiled file\n+        int countFiles = 0;\n+        int countFlags = 0;\n+\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            countFiles++;\n+            List<String> flags = entry.getValue();\n+            countFlags += flags.size();\n+        }\n+\n+        \/\/ when finding common flags, only consider files with this many flags\n+        int flagCutoff = (countFlags \/ countFiles) \/ 2;\n+\n+        \/\/ collect all flags\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            List<String> flags = entry.getValue();\n+            if (flags.size() > flagCutoff) {\n+                this.compilerFlags.addAll(flags);\n+            }\n+        }\n+\n+        \/\/ find flags to remove\n+        Set<String> removeFlags = new TreeSet<>();\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            List<String> flags = entry.getValue();\n+            if (flags.size() > flagCutoff) {\n+                for (String common : this.compilerFlags) {\n+                    if (!flags.contains(common)) {\n+                        removeFlags.add(common);\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ leave only common flags\n+        for (String flag : removeFlags) {\n+            this.compilerFlags.remove(flag);\n+        }\n+\n+        \/\/ remove common flags from each compiler file, leaving only the unique ones\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            List<String> flags = entry.getValue();\n+            if (flags.size() > flagCutoff) {\n+                for (String common : this.compilerFlags) {\n+                    flags.remove(common);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void extractCompilerFlags(String line) {\n+        boolean verboseCompilerTokens = false;\n+        String file = null;\n+        ArrayList<String> flags = null;\n+\n+        String[] commands = line.split(\",\");\n+        for (String command : commands) {\n+            if (contains(command, FILE_TOKEN)) {\n+                file = strip(command, FILE_TOKEN);\n+                \/\/verbose_compiler_tokens = Contains(file, \"vm_version.cpp\");\n+            } else if (contains(command, COMMAND_TOKEN)) {\n+                String tokens = strip(command, COMMAND_TOKEN);\n+                String[] arguments = tokens.split(\" \");\n+                if (arguments.length >= 3) {\n+                    flags = new ArrayList<>();\n+                    for (int a = 2; a < arguments.length; a++) {\n+                        String argument = arguments[a];\n+                        if (isCompilerFlag(argument)) {\n+                            \/\/ catch argument like -DVMTYPE=\\\"Minimal\\\"\n+                            if (contains(argument, \"\\\\\\\\\\\\\\\"\") && argument.endsWith(\"\\\\\\\\\\\\\\\"\")) {\n+                                \/\/ TODO: more robust fix needed here\n+                                argument = argument.replace(\"\\\\\", \"\");\n+                                argument = argument.replaceFirst(\"\\\"\", \"~.~\"); \/\/ temp token ~.~\n+                                argument = argument.replace(\"\\\"\", \"\\\\\\\"'\");\n+                                argument = argument.replace(\"~.~\", \"'\\\\\\\"\");\n+                            }\n+\n+                            \/\/ argument like -DHOTSPOT_VM_DISTRO='\\\"Java HotSpot(TM)\\\"'\n+                            \/\/ gets split up, so reconstruct as single string\n+                            if (contains(argument, QUOTE_START_TOKEN) && !argument.endsWith(QUOTE_END_TOKEN)) {\n+                                String fullArgument = argument;\n+                                do {\n+                                    ++a;\n+                                    argument = arguments[a];\n+                                    fullArgument = fullArgument + \" \" + argument;\n+                                } while (!argument.endsWith(QUOTE_END_TOKEN));\n+                                argument = fullArgument;\n+                            }\n+                            flags.add(argument);\n+                            if (verboseCompilerTokens) {\n+                                System.out.println(\"    FOUND COMPILER FLAG: \" + argument);\n+                            }\n+                        } else if (argument.startsWith(COMPILER_LINE_HEADER)) {\n+                            this.headerPaths.add(argument.substring(2));\n+                        } else if (argument.equals(COMPILER_IFRAMEWORK)) {\n+                            if (iframework == null) {\n+                                ++a;\n+                                this.iframework = arguments[a]; \/\/ gets the value, so skip it for the next loop\n+                            }\n+                        } else if (argument.equals(COMPILER_FFRAMEWORK)) {\n+                            if (fframework == null) {\n+                                ++a;\n+                                this.fframework = arguments[a]; \/\/ gets the value, so skip it for the next loop\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((file != null) && (flags != null)) {\n+            this.compiledFiles.put(file, flags);\n+        } else {\n+            System.err.println(\" WARNING: extractCompilerFlags returns file:\" + file + \", flags:\" + flags);\n+        }\n+\n+        if (verboseCompilerTokens) {\n+            System.exit(0);\n+        }\n+    }\n+\n+    public void parseHotspotCompileCommands(String path) {\n+        String content = readFile(path);\n+        String[] parts = content.split(\"\\\\{\"); \/\/ }\n+\n+        int found = 0;\n+        for (String line : parts) {\n+            if (!contains(line, EXCLUDE_PARSE_TOKEN_1) && !line.startsWith(\"[\")) {\n+                extractCompilerFlags(line);\n+                found++;\n+            }\n+        }\n+        if (debugLog) {\n+            System.out.println(\"Found total of \" + found + \" files that make up the libjvm.dylib\");\n+        }\n+        extractCommonCompilerFlags();\n+\n+        \/\/ figure out \"gensrc\" folder\n+        \/\/ from: \"\/Users\/gerard\/Desktop\/jdk_test\/jdk10\/build\/macosx-x86_64-normal-server-fastdebug\/hotspot\/variant-server\/gensrc\/adfiles\/ad_x86_clone.cpp\"\n+        \/\/ to:   \"\/build\/macosx-x86_64-normal-server-fastdebug\/hotspot\/variant-server\/gensrc\"\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            String file = entry.getKey();\n+            if (file.contains(\"gensrc\")) {\n+                this.generatedHotspotPath = extractPath(file, \"build\", \"gensrc\");\n+                \/\/generatedHotspotPath = \"\/build\/macosx-x64\/hotspot\/variant-server\/gensrc\";\n+                \/\/generatedHotspotPath = \"\/build\/macosx-x86_64-normal-server-fastdebug\/hotspot\/variant-server\/gensrc\";\n+            }\n+        }\n+    }\n+\n+    \/\/ https:\/\/docs.oracle.com\/javase\/tutorial\/displayCode.html?code=https:\/\/docs.oracle.com\/javase\/tutorial\/essential\/io\/examples\/Copy.java\n+    private DiskFile getHotspotFiles(DiskFile root, String workspaceRoot, String hotspotPath) {\n+        File file = new File(workspaceRoot + \"\/\" + hotspotPath);\n+        if (!file.exists()) {\n+            return null;\n+        }\n+\n+        try {\n+            final Path rootDir = Paths.get(workspaceRoot + hotspotPath);\n+            Files.walkFileTree(rootDir, new HotspotFileVisitor(root, hotspotPath));\n+        } catch (IOException ex) {\n+            System.err.println(\"ex: \" + ex);\n+        }\n+\n+        return root;\n+    }\n+\n+    public void prepareFiles(String workspaceRoot) {\n+        this.rootGensrc = getHotspotFiles(this.rootGensrc, workspaceRoot, this.generatedHotspotPath);\n+        this.rootSrc = getHotspotFiles(this.rootSrc, workspaceRoot, SRC_HOTSPOT_PATH);\n+        this.rootTest = getHotspotFiles(this.rootTest, workspaceRoot, TEST_HOTSPOT_PATH);\n+\n+        \/\/ make a copy of files from the log\n+        Set<String> logFiles = new TreeSet<>(this.compiledFiles.keySet());\n+\n+        int totalMarkedFiles = 0;\n+        DiskFile[] roots = { this.rootGensrc, this.rootSrc };\n+        for (DiskFile root : roots) {\n+            List<DiskFile> diskFiles = root.getFiles();\n+            for (DiskFile diskFile : diskFiles) {\n+                if (!diskFile.isDirectory()) {\n+                    String logFileProcessed = null;\n+                    String diskFilePath = diskFile.getFilePath();\n+                    for (String logFilePath : logFiles) {\n+                        if (contains(logFilePath, diskFilePath)) {\n+                            totalMarkedFiles++;\n+\n+                            logFileProcessed = logFilePath;\n+\n+                            \/\/ mark the file as needing compilation\n+                            diskFile.markAsCompiled(this.compiledFiles.get(logFilePath));\n+\n+                            \/\/ break early if found\n+                            break;\n+                        }\n+                    }\n+                    if (logFileProcessed != null) {\n+                        \/\/ remove the file, so we don't have to search through it again\n+                        logFiles.remove(logFileProcessed);\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (this.compiledFiles.size() != totalMarkedFiles) {\n+            System.err.println(\"\\nError: was expecting to compile \" + this.compiledFiles.size() + \" files, but marked \" + totalMarkedFiles);\n+            for (String file : logFiles) {\n+                System.err.println(\"file: \" + file);\n+            }\n+            System.exit(EXIT5);\n+        }\n+\n+        if (!logFiles.isEmpty()) {\n+            System.err.println(\"\\nError: unprocessed files left over:\");\n+            for (String logFile : logFiles) {\n+                System.err.println(\"  \" + logFile);\n+            }\n+            System.exit(EXIT6);\n+        }\n+    }\n+\n+    public void printLogDetails() {\n+        if (!debugLog) return;\n+\n+        System.out.println(\"\\nFound \" + this.compilerFlags.size() + \" common compiler flags:\");\n+        for (String flag : this.compilerFlags) {\n+            System.out.println(\" \" + flag);\n+        }\n+\n+        System.out.println(\"\\nList of compiled files (each one uses common compiler flags plus extra ones as specified):\");\n+        int count = 1;\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            String file = entry.getKey();\n+            System.out.format(\"%4d: %s\\n\", (count), file);\n+            count++;\n+            List<String> flags = entry.getValue();\n+            for (String flag : flags) {\n+                System.out.println(\"        \" + flag);\n+            }\n+        }\n+\n+        System.out.println(\"\\nFound \" + this.linkerFlags.size() + \" linker flags:\");\n+        for (String flag : this.linkerFlags) {\n+            System.out.println(\" \" + flag);\n+        }\n+\n+        System.out.println(\"\\nFound \" + this.headerPaths.size() + \" header paths:\");\n+        for (String header : this.headerPaths) {\n+            System.out.println(\" \" + header);\n+        }\n+\n+        System.out.println(\"\\nFrameworks:\");\n+        System.out.println(\" -iframework \" + iframework);\n+        System.out.println(\" -f \" + fframework);\n+    }\n+\n+    private String makeProjectPbxproj(String workspaceRootPathFromOutputDir, String string) {\n+        String cFlags = \"\";\n+        for (String flag : this.compilerFlags) {\n+            cFlags += \"          \\\"\" + flag.replace(\"\\\"\", \"\\\\\\\\\\\"\") + \"\\\",\\n\";\n+        }\n+        cFlags = cFlags.substring(0, cFlags.length() - 2);\n+        string = string.replaceFirst(TEMPLATE_OTHER_CFLAGS, cFlags);\n+\n+        String ldFlags = \"\";\n+        for (String flag : this.linkerFlags) {\n+            ldFlags += \"          \\\"\" + flag + \"\\\",\\n\";\n+        }\n+        ldFlags = ldFlags.substring(0, ldFlags.length() - 2);\n+        string = string.replaceFirst(TEMPLATE_OTHER_LDFLAGS, ldFlags);\n+\n+        String headerPaths = \"\";\n+        for (String header : this.headerPaths) {\n+            headerPaths += \"          \\\"\" + header + \"\\\",\\n\";\n+        }\n+        headerPaths = headerPaths.substring(0, headerPaths.length() - 2);\n+        string = string.replaceFirst(TEMPLATE_USER_HEADER_SEARCH_PATHS, headerPaths);\n+\n+        String frameworkPaths = \"\";\n+        if (fframework != null) {\n+            frameworkPaths += \"          \\\"\" + fframework + \"\\\"\\n\";\n+        }\n+        string = string.replaceFirst(TEMPLATE_FRAMEWORK_SEARCH_PATHS, frameworkPaths);\n+\n+        DiskFile gensrcFile = this.rootGensrc.getChild(\"gensrc\");\n+        string = string.replaceFirst(TEMPLATE_GROUP_GENSRC, \"        \" + gensrcFile.getXcodeId());\n+\n+        DiskFile srcFile = this.rootSrc.getChild(\"src\");\n+        string = string.replaceFirst(TEMPLATE_GROUP_SRC, \"        \" + srcFile.getXcodeId());\n+\n+        DiskFile testFile = this.rootTest.getChild(\"test\");\n+        string = string.replaceFirst(TEMPLATE_GROUP_TEST, \"        \" + testFile.getXcodeId());\n+\n+        String gensrcGroups = gensrcFile.generatePbxGroup();\n+        String srcGroups = srcFile.generatePbxGroup();\n+        String testGroups = testFile.generatePbxGroup();\n+        string = string.replaceFirst(TEMPLATE_GROUPS, gensrcGroups + srcGroups + testGroups);\n+\n+        String gensrcFiles = gensrcFile.generatePbxFileReference(workspaceRootPathFromOutputDir);\n+        String srcFiles = srcFile.generatePbxFileReference(workspaceRootPathFromOutputDir);\n+        String testFiles = testFile.generatePbxFileReference(workspaceRootPathFromOutputDir);\n+        string = string.replaceFirst(TEMPLATE_PBXFILEREFERENCE, gensrcFiles + srcFiles + testFiles);\n+\n+        String gensrcCompiled = gensrcFile.generatePbxBuildFile();\n+        String compiled = srcFile.generatePbxBuildFile();\n+        string = string.replaceFirst(TEMPLATE_PBXBUILDFILE, gensrcCompiled + compiled);\n+\n+        String gensrcBuilt = gensrcFile.generatePbxSourcesBuildPhase();\n+        String built = srcFile.generatePbxSourcesBuildPhase();\n+        string = string.replaceFirst(TEMPLATE_PBXSOURCESSBUILDPHASE, gensrcBuilt + built);\n+\n+        return string;\n+    }\n+\n+    private String makeTemplateXcscheme(String outputDir, String string) {\n+        string = string.replaceAll(TEMPLATE_JDK_PATH, outputDir);\n+\n+        return string;\n+    }\n+\n+    public void makeXcodeProj(String outputDir, String workspaceRootPathFromOutputDir) {\n+    \/*\n+     jvm.xcodeproj                     <-- folder\n+       project.pbxproj                 <-- file\n+       xcshareddata                    <-- folder\n+         xcschemes                     <-- folder\n+           jvm.xcscheme                <-- file\n+         xcdebugger                    <-- folder\n+           Breakpoints_v2.xcbkptlist   <-- file\n+     *\/\n+        File xcodeDir = new File(outputDir);\n+        File jvmXcodeprojDir = new File(xcodeDir, HOTSPOT_PBXPROJ);\n+        File projectPbxprojFile = new File(jvmXcodeprojDir, PBXPROJ);\n+        File xcshareddataDir = new File(jvmXcodeprojDir, XCSAHAREDDATA);\n+        File xcschemesDir = new File(xcshareddataDir, XCSCHEMES);\n+        File jvmXcschemeFile = new File(xcschemesDir, JVM_XCSCHEME);\n+        File j2DemoXcschemeFile = new File(xcschemesDir, J2D_XCSCHEME);\n+        File xcdebuggerDir = new File(xcshareddataDir, XCDEBUGGER);\n+        File jBreakpointsV2XcbkptlistFile = new File(xcdebuggerDir, XCBKPTLIST);\n+\n+        if (xcodeDir.exists()) {\n+            xcodeDir.delete();\n+        }\n+\n+        jvmXcodeprojDir.mkdirs();\n+        xcshareddataDir.mkdirs();\n+        xcschemesDir.mkdirs();\n+        xcdebuggerDir.mkdirs();\n+\n+        File dataDir = new File(projectMakerDataPath);\n+        File templateProjectPbxprojFile = new File(dataDir, TEMPLATE_PBXPROJ);\n+        File templateJvmXcschemeFile = new File(dataDir, TEMPLATE_JVM_XCSCHEME);\n+        File templateJ2DemoXcschemeFile = new File(dataDir, TEMPLATE_J2D_XCSCHEME);\n+        File templateJBreakpointsV2XcbkptlistFile = new File(dataDir, TEMPLATE_XCBKPTLIST);\n+\n+        String projectPbxprojString = readFile(templateProjectPbxprojFile);\n+        String jvmXcschemeString = readFile(templateJvmXcschemeFile);\n+        String j2DemoXcschemeString = readFile(templateJ2DemoXcschemeFile);\n+        String jBreakpointsV2XcbkptlistString = readFile(templateJBreakpointsV2XcbkptlistFile);\n+\n+        writeFile(projectPbxprojFile, makeProjectPbxproj(workspaceRootPathFromOutputDir, projectPbxprojString));\n+        writeFile(jvmXcschemeFile, makeTemplateXcscheme(outputDir, jvmXcschemeString));\n+        writeFile(j2DemoXcschemeFile, makeTemplateXcscheme(outputDir, j2DemoXcschemeString));\n+        writeFile(jBreakpointsV2XcbkptlistFile, jBreakpointsV2XcbkptlistString);\n+    }\n+\n+    public void makeAliases(String outputDir, String pathToBuild) {\n+        File xcodeDir = new File(outputDir);\n+        File jdkOldSh = new File(xcodeDir, ALIAS_JAVA_OLD);\n+        File jdkNewSh = new File(xcodeDir, ALIAS_JAVA_NEW);\n+\n+        writeFile(jdkOldSh, \"#!\/bin\/bash\\n\" + pathToBuild + JDK_BIN_JAVA + \" $@\");\n+        writeFile(jdkNewSh, \"#!\/bin\/bash\\n\" + outputDir + \"\/build\" + JDK_BIN_JAVA + \" $@\");\n+\n+        try {\n+            Set<PosixFilePermission> permissions = new HashSet<>();\n+            permissions.add(PosixFilePermission.OWNER_READ);\n+            permissions.add(PosixFilePermission.OWNER_WRITE);\n+            permissions.add(PosixFilePermission.OWNER_EXECUTE);\n+            permissions.add(PosixFilePermission.GROUP_READ);\n+            permissions.add(PosixFilePermission.OTHERS_READ);\n+            Files.setPosixFilePermissions(jdkOldSh.toPath(), permissions);\n+            Files.setPosixFilePermissions(jdkNewSh.toPath(), permissions);\n+        } catch (IOException ex) {\n+            System.err.println(\"Warning: unable to change file permissions\");\n+            System.err.println(ex);\n+        }\n+    }\n+\n+    private static class HotspotFileVisitor implements FileVisitor<Path> {\n+        private final DiskFile root;\n+        private final String hotspotPath;\n+\n+        public HotspotFileVisitor(DiskFile root, String hotspotPath) {\n+            this.root = root;\n+            this.hotspotPath = hotspotPath;\n+        }\n+\n+        @Override\n+        public FileVisitResult preVisitDirectory(Path path, BasicFileAttributes attrs) {\n+            if (excludeFile(path)) {\n+                return FileVisitResult.SKIP_SUBTREE;\n+            } else {\n+                \/\/ consider folders based on their names\n+                Path file = path.getFileName();\n+                if (!excludeFile(file)) {\n+                    root.addDirectory(path, hotspotPath);\n+                    return FileVisitResult.CONTINUE;\n+                } else {\n+                    \/\/ skip folders with names beginning with \".\", etc\n+                    return FileVisitResult.SKIP_SUBTREE;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n+            Path file = path.getFileName();\n+            if (!excludeFile(file)) {\n+                \/\/System.err.println(path.toString());\n+                root.addFile(path, hotspotPath);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        @Override\n+        public FileVisitResult postVisitDirectory(Path path, IOException exc) {\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFileFailed(Path path, IOException exc) {\n+            if (exc instanceof FileSystemLoopException) {\n+                System.err.println(\"cycle detected: \" + path);\n+            } else {\n+                System.err.format(\"Unable to process: %s: %s\\n\", path, exc);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+    }\n+}\n","filename":"make\/ide\/xcode\/hotspot\/src\/classes\/XcodeProjectMaker.java","additions":754,"deletions":0,"binary":false,"changes":754,"status":"added"},{"patch":"@@ -1375,0 +1375,1 @@\n+            .filter(p -> p.getFileName().toString().matches(\"africa|antarctica|asia|australasia|backward|etcetera|europe|northamerica|southamerica\"))\n@@ -1397,1 +1398,2 @@\n-\n+                        var tokens = line.split(\"[ \\t]+\", -1);\n+                        var token0len = tokens.length > 0 ? tokens[0].length() : 0;\n@@ -1399,1 +1401,1 @@\n-                        if (line.startsWith(\"Zone\")) {\n+                        if (token0len > 0 && tokens[0].regionMatches(true, 0, \"Zone\", 0, token0len)) {\n@@ -1403,4 +1405,3 @@\n-                            var zl = line.split(\"[ \\t]+\", -1);\n-                            zone = zl[1];\n-                            rule = zl[3];\n-                            format = flipIfNeeded(inVanguard, zl[4]);\n+                            zone = tokens[1];\n+                            rule = tokens[3];\n+                            format = flipIfNeeded(inVanguard, tokens[4]);\n@@ -1409,2 +1410,3 @@\n-                                if (line.startsWith(\"Rule\") ||\n-                                    line.startsWith(\"Link\")) {\n+                                if (token0len > 0 &&\n+                                   (tokens[0].regionMatches(true, 0, \"Rule\", 0, token0len) ||\n+                                    tokens[0].regionMatches(true, 0, \"Link\", 0, token0len))) {\n@@ -1416,3 +1418,2 @@\n-                                    var s = line.split(\"[ \\t]+\", -1);\n-                                    rule = s[2];\n-                                    format = flipIfNeeded(inVanguard, s[3]);\n+                                    rule = tokens[2];\n+                                    format = flipIfNeeded(inVanguard, tokens[3]);\n@@ -1424,4 +1425,3 @@\n-                        if (line.startsWith(\"Rule\")) {\n-                            var rl = line.split(\"[ \\t]+\", -1);\n-                            tzdbSubstLetters.put(rl[1] + NBSP + (rl[8].equals(\"0\") ? STD : DST),\n-                                    rl[9].replace(NO_SUBST, \"\"));\n+                        if (token0len > 0 && tokens[0].regionMatches(true, 0, \"Rule\", 0, token0len)) {\n+                            tzdbSubstLetters.put(tokens[1] + NBSP + (tokens[8].equals(\"0\") ? STD : DST),\n+                                    tokens[9].replace(NO_SUBST, \"\"));\n@@ -1431,3 +1431,2 @@\n-                        if (line.startsWith(\"Link\")) {\n-                            var ll = line.split(\"[ \\t]+\", -1);\n-                            tzdbLinks.put(ll[2], ll[1]);\n+                        if (token0len > 0 && tokens[0].regionMatches(true, 0, \"Link\", 0, token0len)) {\n+                            tzdbLinks.put(tokens[2], tokens[1]);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CLDRConverter.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -109,1 +109,2 @@\n-    private static final Pattern TAG_PATTERN = Pattern.compile(\"(?s)(.+ )?(?<chapter>[1-9][0-9]*)(?<section>[0-9.]*)( .*)?$\");\n+    \/\/ Note: Matches special cases like @jvms 6.5.checkcast\n+    private static final Pattern TAG_PATTERN = Pattern.compile(\"(?s)(.+ )?(?<chapter>[1-9][0-9]*)(?<section>[0-9a-z_.]*)( .*)?$\");\n","filename":"make\/jdk\/src\/classes\/build\/tools\/taglet\/JSpec.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,1 +167,2 @@\n-                    if (line.startsWith(\"Zone\")) {        \/\/ parse Zone line\n+                    int token0len = tokens.length > 0 ? tokens[0].length() : line.length();\n+                    if (line.regionMatches(true, 0, \"Zone\", 0, token0len)) {        \/\/ parse Zone line\n@@ -185,1 +186,1 @@\n-                    } else if (line.startsWith(\"Rule\")) { \/\/ parse Rule line\n+                    } else if (line.regionMatches(true, 0, \"Rule\", 0, token0len)) { \/\/ parse Rule line\n@@ -191,1 +192,1 @@\n-                    } else if (line.startsWith(\"Link\")) { \/\/ parse link line\n+                    } else if (line.regionMatches(true, 0, \"Link\", 0, token0len)) { \/\/ parse link line\n@@ -307,1 +308,1 @@\n-                if (dayRule.startsWith(\"last\")) {\n+                if (dayRule.regionMatches(true, 0, \"last\", 0, 4)) {\n@@ -358,5 +359,6 @@\n-            switch (year.toLowerCase()) {\n-            case \"min\":  return 1900;\n-            case \"max\":  return Year.MAX_VALUE;\n-            case \"only\": return defaultYear;\n-            }\n+            int len = year.length();\n+\n+            if (year.regionMatches(true, 0, \"minimum\", 0, len)) return 1900;\n+            if (year.regionMatches(true, 0, \"maximum\", 0, len)) return Year.MAX_VALUE;\n+            if (year.regionMatches(true, 0, \"only\", 0, len)) return defaultYear;\n+\n@@ -367,14 +369,15 @@\n-            switch (mon) {\n-            case \"Jan\": return Month.JANUARY;\n-            case \"Feb\": return Month.FEBRUARY;\n-            case \"Mar\": return Month.MARCH;\n-            case \"Apr\": return Month.APRIL;\n-            case \"May\": return Month.MAY;\n-            case \"Jun\": return Month.JUNE;\n-            case \"Jul\": return Month.JULY;\n-            case \"Aug\": return Month.AUGUST;\n-            case \"Sep\": return Month.SEPTEMBER;\n-            case \"Oct\": return Month.OCTOBER;\n-            case \"Nov\": return Month.NOVEMBER;\n-            case \"Dec\": return Month.DECEMBER;\n-            }\n+            int len = mon.length();\n+\n+            if (mon.regionMatches(true, 0, \"January\", 0, len)) return Month.JANUARY;\n+            if (mon.regionMatches(true, 0, \"February\", 0, len)) return Month.FEBRUARY;\n+            if (mon.regionMatches(true, 0, \"March\", 0, len)) return Month.MARCH;\n+            if (mon.regionMatches(true, 0, \"April\", 0, len)) return Month.APRIL;\n+            if (mon.regionMatches(true, 0, \"May\", 0, len)) return Month.MAY;\n+            if (mon.regionMatches(true, 0, \"June\", 0, len)) return Month.JUNE;\n+            if (mon.regionMatches(true, 0, \"July\", 0, len)) return Month.JULY;\n+            if (mon.regionMatches(true, 0, \"August\", 0, len)) return Month.AUGUST;\n+            if (mon.regionMatches(true, 0, \"September\", 0, len)) return Month.SEPTEMBER;\n+            if (mon.regionMatches(true, 0, \"October\", 0, len)) return Month.OCTOBER;\n+            if (mon.regionMatches(true, 0, \"November\", 0, len)) return Month.NOVEMBER;\n+            if (mon.regionMatches(true, 0, \"December\", 0, len)) return Month.DECEMBER;\n+\n@@ -385,9 +388,10 @@\n-            switch (dow) {\n-            case \"Mon\": return DayOfWeek.MONDAY;\n-            case \"Tue\": return DayOfWeek.TUESDAY;\n-            case \"Wed\": return DayOfWeek.WEDNESDAY;\n-            case \"Thu\": return DayOfWeek.THURSDAY;\n-            case \"Fri\": return DayOfWeek.FRIDAY;\n-            case \"Sat\": return DayOfWeek.SATURDAY;\n-            case \"Sun\": return DayOfWeek.SUNDAY;\n-            }\n+            int len = dow.length();\n+\n+            if (dow.regionMatches(true, 0, \"Monday\", 0, len)) return DayOfWeek.MONDAY;\n+            if (dow.regionMatches(true, 0, \"Tuesday\", 0, len)) return DayOfWeek.TUESDAY;\n+            if (dow.regionMatches(true, 0, \"Wednesday\", 0, len)) return DayOfWeek.WEDNESDAY;\n+            if (dow.regionMatches(true, 0, \"Thursday\", 0, len)) return DayOfWeek.THURSDAY;\n+            if (dow.regionMatches(true, 0, \"Friday\", 0, len)) return DayOfWeek.FRIDAY;\n+            if (dow.regionMatches(true, 0, \"Saturday\", 0, len)) return DayOfWeek.SATURDAY;\n+            if (dow.regionMatches(true, 0, \"Sunday\", 0, len)) return DayOfWeek.SUNDAY;\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/tzdb\/TzdbZoneRulesProvider.java","additions":37,"deletions":33,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,5 +54,0 @@\n-  define copy-and-chmod\n-\t$(install-file)\n-\t$(CHMOD) a+rx $@\n-  endef\n-\n@@ -61,1 +56,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_MSVCR, \\\n+  $(eval $(call SetupCopyFiles, COPY_MSVCR, \\\n@@ -64,1 +59,2 @@\n-      MACRO := copy-and-chmod))\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n@@ -66,1 +62,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_VCRUNTIME_1, \\\n+  $(eval $(call SetupCopyFiles, COPY_VCRUNTIME_1, \\\n@@ -69,1 +65,2 @@\n-      MACRO := copy-and-chmod))\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n@@ -71,1 +68,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_MSVCP, \\\n+  $(eval $(call SetupCopyFiles, COPY_MSVCP, \\\n@@ -74,1 +71,2 @@\n-      MACRO := copy-and-chmod))\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n@@ -83,1 +81,1 @@\n-        MACRO := copy-and-chmod, \\\n+        MACRO := copy-and-chmod-executable, \\\n@@ -136,1 +134,1 @@\n-\t$(foreach f,$(POLICY_SRC_LIST),$(CAT) $(f) >> $@.tmp;)\n+\t$(foreach f, $(POLICY_SRC_LIST), $(CAT) $(f) >> $@.tmp;)\n@@ -161,1 +159,1 @@\n-\t$(foreach f,$(DEF_POLICY_SRC_LIST),$(CAT) $(f) >> $@.tmp;)\n+\t$(foreach f, $(DEF_POLICY_SRC_LIST), $(CAT) $(f) >> $@.tmp;)\n","filename":"make\/modules\/java.base\/Copy.gmk","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    DISABLED_WARNINGS_gcc_net_util_md.c := format-nonliteral, \\\n+    DISABLED_WARNINGS_gcc_net_util_md.c := format-nonliteral unused-variable, \\\n@@ -49,1 +49,3 @@\n-    DISABLED_WARNINGS_clang_net_util_md.c := format-nonliteral, \\\n+    DISABLED_WARNINGS_clang_net_util_md.c := format-nonliteral \\\n+        unused-variable, \\\n+    DISABLED_WARNINGS_clang_NetworkInterface.c := unused-function, \\\n@@ -59,1 +61,1 @@\n-    LIBS_aix := $(LIBDL),\\\n+    LIBS_aix := $(LIBDL), \\\n@@ -80,0 +82,2 @@\n+    DISABLED_WARNINGS_clang_Net.c := unused-function unused-variable, \\\n+    DISABLED_WARNINGS_clang_UnixNativeDispatcher.c := unused-variable, \\\n@@ -99,1 +103,2 @@\n-      DISABLED_WARNINGS_clang_KeystoreImpl.m := deprecated-declarations, \\\n+      DISABLED_WARNINGS_clang_KeystoreImpl.m := deprecated-declarations \\\n+          unused-but-set-variable unused-variable, \\\n@@ -119,0 +124,2 @@\n+      DISABLED_WARNINGS_gcc_jsig.c := unused-but-set-variable, \\\n+      DISABLED_WARNINGS_clang_jsig.c := unused-but-set-variable, \\\n@@ -172,0 +179,1 @@\n+      DISABLED_WARNINGS_gcc := implicit-function-declaration unused-variable, \\\n@@ -189,0 +197,1 @@\n+      DISABLED_WARNINGS_gcc := unused-variable, \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -282,7 +282,7 @@\n-$(eval $(call SetupGenBuffer,ByteBuffer,  $(X_BUF), type:=byte, BIN:=1))\n-$(eval $(call SetupGenBuffer,CharBuffer,  $(X_BUF), type:=char))\n-$(eval $(call SetupGenBuffer,ShortBuffer, $(X_BUF), type:=short))\n-$(eval $(call SetupGenBuffer,IntBuffer,   $(X_BUF), type:=int))\n-$(eval $(call SetupGenBuffer,LongBuffer,  $(X_BUF), type:=long))\n-$(eval $(call SetupGenBuffer,FloatBuffer, $(X_BUF), type:=float))\n-$(eval $(call SetupGenBuffer,DoubleBuffer,$(X_BUF), type:=double))\n+$(eval $(call SetupGenBuffer,ByteBuffer,  $(X_BUF), type := byte, BIN := 1))\n+$(eval $(call SetupGenBuffer,CharBuffer,  $(X_BUF), type := char))\n+$(eval $(call SetupGenBuffer,ShortBuffer, $(X_BUF), type := short))\n+$(eval $(call SetupGenBuffer,IntBuffer,   $(X_BUF), type := int))\n+$(eval $(call SetupGenBuffer,LongBuffer,  $(X_BUF), type := long))\n+$(eval $(call SetupGenBuffer,FloatBuffer, $(X_BUF), type := float))\n+$(eval $(call SetupGenBuffer,DoubleBuffer,$(X_BUF), type := double))\n@@ -294,14 +294,14 @@\n-$(eval $(call SetupGenBuffer,HeapByteBuffer,   $(HEAP_X_BUF), type:=byte))\n-$(eval $(call SetupGenBuffer,HeapByteBufferR,  $(HEAP_X_BUF), type:=byte, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapCharBuffer,   $(HEAP_X_BUF), type:=char))\n-$(eval $(call SetupGenBuffer,HeapCharBufferR,  $(HEAP_X_BUF), type:=char, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapShortBuffer,  $(HEAP_X_BUF), type:=short))\n-$(eval $(call SetupGenBuffer,HeapShortBufferR, $(HEAP_X_BUF), type:=short, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapIntBuffer,    $(HEAP_X_BUF), type:=int))\n-$(eval $(call SetupGenBuffer,HeapIntBufferR,   $(HEAP_X_BUF), type:=int, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapLongBuffer,   $(HEAP_X_BUF), type:=long))\n-$(eval $(call SetupGenBuffer,HeapLongBufferR,  $(HEAP_X_BUF), type:=long, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapFloatBuffer,  $(HEAP_X_BUF), type:=float))\n-$(eval $(call SetupGenBuffer,HeapFloatBufferR, $(HEAP_X_BUF), type:=float, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapDoubleBuffer, $(HEAP_X_BUF), type:=double))\n-$(eval $(call SetupGenBuffer,HeapDoubleBufferR,$(HEAP_X_BUF), type:=double, RW:=R))\n+$(eval $(call SetupGenBuffer,HeapByteBuffer,   $(HEAP_X_BUF), type := byte))\n+$(eval $(call SetupGenBuffer,HeapByteBufferR,  $(HEAP_X_BUF), type := byte, RW := R))\n+$(eval $(call SetupGenBuffer,HeapCharBuffer,   $(HEAP_X_BUF), type := char))\n+$(eval $(call SetupGenBuffer,HeapCharBufferR,  $(HEAP_X_BUF), type := char, RW := R))\n+$(eval $(call SetupGenBuffer,HeapShortBuffer,  $(HEAP_X_BUF), type := short))\n+$(eval $(call SetupGenBuffer,HeapShortBufferR, $(HEAP_X_BUF), type := short, RW := R))\n+$(eval $(call SetupGenBuffer,HeapIntBuffer,    $(HEAP_X_BUF), type := int))\n+$(eval $(call SetupGenBuffer,HeapIntBufferR,   $(HEAP_X_BUF), type := int, RW := R))\n+$(eval $(call SetupGenBuffer,HeapLongBuffer,   $(HEAP_X_BUF), type := long))\n+$(eval $(call SetupGenBuffer,HeapLongBufferR,  $(HEAP_X_BUF), type := long, RW := R))\n+$(eval $(call SetupGenBuffer,HeapFloatBuffer,  $(HEAP_X_BUF), type := float))\n+$(eval $(call SetupGenBuffer,HeapFloatBufferR, $(HEAP_X_BUF), type := float, RW := R))\n+$(eval $(call SetupGenBuffer,HeapDoubleBuffer, $(HEAP_X_BUF), type := double))\n+$(eval $(call SetupGenBuffer,HeapDoubleBufferR,$(HEAP_X_BUF), type := double, RW := R))\n@@ -313,2 +313,2 @@\n-$(eval $(call SetupGenBuffer,DirectByteBuffer, $(DIRECT_X_BUF), type:=byte, BIN:=1))\n-$(eval $(call SetupGenBuffer,DirectByteBufferR,$(DIRECT_X_BUF), type:=byte, BIN:=1, RW:=R))\n+$(eval $(call SetupGenBuffer,DirectByteBuffer, $(DIRECT_X_BUF), type := byte, BIN := 1))\n+$(eval $(call SetupGenBuffer,DirectByteBufferR,$(DIRECT_X_BUF), type := byte, BIN := 1, RW := R))\n@@ -318,12 +318,12 @@\n-$(eval $(call SetupGenBuffer,DirectCharBufferU,   $(DIRECT_X_BUF), type:=char, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectCharBufferRU,  $(DIRECT_X_BUF), type:=char, RW:=R, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectShortBufferU,  $(DIRECT_X_BUF), type:=short, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectShortBufferRU, $(DIRECT_X_BUF), type:=short, RW:=R, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectIntBufferU,    $(DIRECT_X_BUF), type:=int, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectIntBufferRU,   $(DIRECT_X_BUF), type:=int, RW:=R, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectLongBufferU,   $(DIRECT_X_BUF), type:=long, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectLongBufferRU,  $(DIRECT_X_BUF), type:=long, RW:=R, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferU,  $(DIRECT_X_BUF), type:=float, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferRU, $(DIRECT_X_BUF), type:=float, RW:=R, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferU, $(DIRECT_X_BUF), type:=double, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferRU,$(DIRECT_X_BUF), type:=double, RW:=R, BO:=U))\n+$(eval $(call SetupGenBuffer,DirectCharBufferU,   $(DIRECT_X_BUF), type := char, BO := U))\n+$(eval $(call SetupGenBuffer,DirectCharBufferRU,  $(DIRECT_X_BUF), type := char, RW := R, BO := U))\n+$(eval $(call SetupGenBuffer,DirectShortBufferU,  $(DIRECT_X_BUF), type := short, BO := U))\n+$(eval $(call SetupGenBuffer,DirectShortBufferRU, $(DIRECT_X_BUF), type := short, RW := R, BO := U))\n+$(eval $(call SetupGenBuffer,DirectIntBufferU,    $(DIRECT_X_BUF), type := int, BO := U))\n+$(eval $(call SetupGenBuffer,DirectIntBufferRU,   $(DIRECT_X_BUF), type := int, RW := R, BO := U))\n+$(eval $(call SetupGenBuffer,DirectLongBufferU,   $(DIRECT_X_BUF), type := long, BO := U))\n+$(eval $(call SetupGenBuffer,DirectLongBufferRU,  $(DIRECT_X_BUF), type := long, RW := R, BO := U))\n+$(eval $(call SetupGenBuffer,DirectFloatBufferU,  $(DIRECT_X_BUF), type := float, BO := U))\n+$(eval $(call SetupGenBuffer,DirectFloatBufferRU, $(DIRECT_X_BUF), type := float, RW := R, BO := U))\n+$(eval $(call SetupGenBuffer,DirectDoubleBufferU, $(DIRECT_X_BUF), type := double, BO := U))\n+$(eval $(call SetupGenBuffer,DirectDoubleBufferRU,$(DIRECT_X_BUF), type := double, RW := R, BO := U))\n@@ -333,12 +333,12 @@\n-$(eval $(call SetupGenBuffer,DirectCharBufferS,   $(DIRECT_X_BUF), type:=char, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectCharBufferRS,  $(DIRECT_X_BUF), type:=char, RW:=R, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectShortBufferS,  $(DIRECT_X_BUF), type:=short, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectShortBufferRS, $(DIRECT_X_BUF), type:=short, RW:=R, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectIntBufferS,    $(DIRECT_X_BUF), type:=int, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectIntBufferRS,   $(DIRECT_X_BUF), type:=int, RW:=R, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectLongBufferS,   $(DIRECT_X_BUF), type:=long, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectLongBufferRS,  $(DIRECT_X_BUF), type:=long, RW:=R, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferS,  $(DIRECT_X_BUF), type:=float, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferRS, $(DIRECT_X_BUF), type:=float, RW:=R, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferS, $(DIRECT_X_BUF), type:=double, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferRS,$(DIRECT_X_BUF), type:=double, RW:=R, BO:=S))\n+$(eval $(call SetupGenBuffer,DirectCharBufferS,   $(DIRECT_X_BUF), type := char, BO := S))\n+$(eval $(call SetupGenBuffer,DirectCharBufferRS,  $(DIRECT_X_BUF), type := char, RW := R, BO := S))\n+$(eval $(call SetupGenBuffer,DirectShortBufferS,  $(DIRECT_X_BUF), type := short, BO := S))\n+$(eval $(call SetupGenBuffer,DirectShortBufferRS, $(DIRECT_X_BUF), type := short, RW := R, BO := S))\n+$(eval $(call SetupGenBuffer,DirectIntBufferS,    $(DIRECT_X_BUF), type := int, BO := S))\n+$(eval $(call SetupGenBuffer,DirectIntBufferRS,   $(DIRECT_X_BUF), type := int, RW := R, BO := S))\n+$(eval $(call SetupGenBuffer,DirectLongBufferS,   $(DIRECT_X_BUF), type := long, BO := S))\n+$(eval $(call SetupGenBuffer,DirectLongBufferRS,  $(DIRECT_X_BUF), type := long, RW := R, BO := S))\n+$(eval $(call SetupGenBuffer,DirectFloatBufferS,  $(DIRECT_X_BUF), type := float, BO := S))\n+$(eval $(call SetupGenBuffer,DirectFloatBufferRS, $(DIRECT_X_BUF), type := float, RW := R, BO := S))\n+$(eval $(call SetupGenBuffer,DirectDoubleBufferS, $(DIRECT_X_BUF), type := double, BO := S))\n+$(eval $(call SetupGenBuffer,DirectDoubleBufferRS,$(DIRECT_X_BUF), type := double, RW := R, BO := S))\n@@ -350,12 +350,12 @@\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferB,   $(BYTE_X_BUF), type:=char, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferRB,  $(BYTE_X_BUF), type:=char, RW:=R, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferB,  $(BYTE_X_BUF), type:=short, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferRB, $(BYTE_X_BUF), type:=short, RW:=R, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferB,    $(BYTE_X_BUF), type:=int, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferRB,   $(BYTE_X_BUF), type:=int, RW:=R, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferB,   $(BYTE_X_BUF), type:=long, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferRB,  $(BYTE_X_BUF), type:=long, RW:=R, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferB,  $(BYTE_X_BUF), type:=float, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferRB, $(BYTE_X_BUF), type:=float, RW:=R, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferB, $(BYTE_X_BUF), type:=double, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferRB,$(BYTE_X_BUF), type:=double, RW:=R, BO:=B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferB,   $(BYTE_X_BUF), type := char, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferRB,  $(BYTE_X_BUF), type := char, RW := R, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferB,  $(BYTE_X_BUF), type := short, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferRB, $(BYTE_X_BUF), type := short, RW := R, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferB,    $(BYTE_X_BUF), type := int, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferRB,   $(BYTE_X_BUF), type := int, RW := R, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferB,   $(BYTE_X_BUF), type := long, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferRB,  $(BYTE_X_BUF), type := long, RW := R, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferB,  $(BYTE_X_BUF), type := float, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferRB, $(BYTE_X_BUF), type := float, RW := R, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferB, $(BYTE_X_BUF), type := double, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferRB,$(BYTE_X_BUF), type := double, RW := R, BO := B))\n@@ -365,12 +365,12 @@\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferL,   $(BYTE_X_BUF), type:=char, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferRL,  $(BYTE_X_BUF), type:=char, RW:=R, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferL,  $(BYTE_X_BUF), type:=short, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferRL, $(BYTE_X_BUF), type:=short, RW:=R, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferL,    $(BYTE_X_BUF), type:=int, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferRL,   $(BYTE_X_BUF), type:=int, RW:=R, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferL,   $(BYTE_X_BUF), type:=long, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferRL,  $(BYTE_X_BUF), type:=long, RW:=R, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferL,  $(BYTE_X_BUF), type:=float, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferRL, $(BYTE_X_BUF), type:=float, RW:=R, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferL, $(BYTE_X_BUF), type:=double, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferRL,$(BYTE_X_BUF), type:=double, RW:=R, BO:=L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferL,   $(BYTE_X_BUF), type := char, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferRL,  $(BYTE_X_BUF), type := char, RW := R, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferL,  $(BYTE_X_BUF), type := short, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferRL, $(BYTE_X_BUF), type := short, RW := R, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferL,    $(BYTE_X_BUF), type := int, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferRL,   $(BYTE_X_BUF), type := int, RW := R, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferL,   $(BYTE_X_BUF), type := long, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferRL,  $(BYTE_X_BUF), type := long, RW := R, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferL,  $(BYTE_X_BUF), type := float, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferRL, $(BYTE_X_BUF), type := float, RW := R, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferL, $(BYTE_X_BUF), type := double, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferRL,$(BYTE_X_BUF), type := double, RW := R, BO := L))\n","filename":"make\/modules\/java.base\/gensrc\/GensrcBuffer.gmk","additions":71,"deletions":71,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-GENSRC_EXCEPTIONS += $(foreach D,$(GENSRC_EXCEPTIONS_SRC_DIRS),$(GENSRC_EXCEPTIONS_DST)\/_the.$(D).marker)\n+GENSRC_EXCEPTIONS += $(foreach D, $(GENSRC_EXCEPTIONS_SRC_DIRS), $(GENSRC_EXCEPTIONS_DST)\/_the.$(D).marker)\n","filename":"make\/modules\/java.base\/gensrc\/GensrcExceptions.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  ifeq ($(OPENJDK_TARGET_CPU),aarch64)\n+  ifeq ($(OPENJDK_TARGET_CPU), aarch64)\n","filename":"make\/modules\/java.base\/gensrc\/GensrcMisc.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-############################################################################\n+################################################################################\n","filename":"make\/modules\/java.base\/gensrc\/GensrcModuleLoaderMap.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+    DISABLED_WARNINGS_gcc_check_code.c := unused-variable, \\\n+    DISABLED_WARNINGS_clang_check_code.c := unused-variable, \\\n@@ -61,0 +63,1 @@\n+    DISABLED_WARNINGS_clang_TimeZone_md.c := unused-variable, \\\n@@ -63,1 +66,1 @@\n-    LIBS_aix := $(LIBDL) $(LIBM),\\\n+    LIBS_aix := $(LIBDL) $(LIBM), \\\n@@ -95,0 +98,1 @@\n+    DISABLED_WARNINGS_clang_zip_util.c := unused-function, \\\n@@ -111,0 +115,6 @@\n+    DISABLED_WARNINGS_gcc_imageDecompressor.cpp := unused-variable, \\\n+    DISABLED_WARNINGS_gcc_imageFile.cpp := unused-const-variable \\\n+        unused-variable, \\\n+    DISABLED_WARNINGS_clang_imageDecompressor.cpp := unused-variable, \\\n+    DISABLED_WARNINGS_clang_imageFile.cpp := unused-private-field \\\n+        unused-variable, \\\n@@ -170,2 +180,4 @@\n-    DISABLED_WARNINGS_gcc := unused-function, \\\n-    DISABLED_WARNINGS_clang := format-nonliteral deprecated-non-prototype, \\\n+    DISABLED_WARNINGS_gcc := unused-function unused-variable, \\\n+    DISABLED_WARNINGS_clang := deprecated-non-prototype format-nonliteral \\\n+        unused-function, \\\n+    DISABLED_WARNINGS_clang_java_md_macosx.m := unused-variable, \\\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -67,2 +67,5 @@\n-      DISABLED_WARNINGS_gcc := undef, \\\n-      DISABLED_WARNINGS_clang := undef, \\\n+      DISABLED_WARNINGS_gcc := undef unused-variable, \\\n+      DISABLED_WARNINGS_clang := undef unused-variable, \\\n+      DISABLED_WARNINGS_clang_PLATFORM_API_MacOSX_MidiUtils.c := \\\n+          unused-but-set-variable, \\\n+      DISABLED_WARNINGS_clang_DirectAudioDevice.c := unused-function, \\\n","filename":"make\/modules\/java.desktop\/Lib.gmk","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+    DISABLED_WARNINGS_gcc := unused-but-set-variable unused-variable, \\\n@@ -115,0 +116,1 @@\n+    DISABLED_WARNINGS_clang := unused-but-set-variable unused-variable, \\\n@@ -128,1 +130,1 @@\n-    LIBS_aix := $(LIBDL),\\\n+    LIBS_aix := $(LIBDL), \\\n@@ -181,0 +183,2 @@\n+      DISABLED_WARNINGS_gcc := unused-variable, \\\n+      DISABLED_WARNINGS_clang := unused-variable, \\\n@@ -183,0 +187,2 @@\n+      DISABLED_WARNINGS_clang_X11Renderer.c := unused-function, \\\n+      DISABLED_WARNINGS_clang_X11SurfaceData.c := unused-function, \\\n@@ -237,1 +243,2 @@\n-      DISABLED_WARNINGS_gcc := int-to-pointer-cast, \\\n+      DISABLED_WARNINGS_gcc := int-to-pointer-cast unused-variable, \\\n+      DISABLED_WARNINGS_clang := unused-variable, \\\n@@ -247,0 +254,1 @@\n+      DISABLED_WARNINGS_gcc_X11Color.c := unused-but-set-variable, \\\n@@ -248,1 +256,2 @@\n-          pointer-to-int-cast, \\\n+          pointer-to-int-cast unused-but-set-variable, \\\n+      DISABLED_WARNINGS_gcc_X11TextRenderer_md.c := unused-but-set-variable, \\\n@@ -254,1 +263,2 @@\n-      DISABLED_WARNINGS_clang_gtk3_interface.c := parentheses, \\\n+      DISABLED_WARNINGS_clang_gtk3_interface.c := unused-function parentheses, \\\n+      DISABLED_WARNINGS_clang_GLXSurfaceData.c := unused-function, \\\n@@ -259,0 +269,1 @@\n+      DISABLED_WARNINGS_clang_XWindow.c := unused-function, \\\n@@ -263,1 +274,1 @@\n-      DISABLED_WARNINGS_clang_aix_gtk3_interface.c := parentheses \\\n+      DISABLED_WARNINGS_clang_aix_gtk3_interface.c := unused-function parentheses \\\n@@ -267,1 +278,1 @@\n-      DISABLED_WARNINGS_clang_aix_awt_InputMethod.c := sign-compare, \\\n+      DISABLED_WARNINGS_clang_aix_awt_InputMethod.c := unused-function sign-compare, \\\n@@ -311,3 +322,4 @@\n-      DISABLED_WARNINGS_clang := incomplete-implementation \\\n-          deprecated-declarations objc-method-access \\\n-          incompatible-pointer-types extra-tokens sign-compare undef, \\\n+      DISABLED_WARNINGS_clang := deprecated-declarations extra-tokens \\\n+          incompatible-pointer-types incomplete-implementation \\\n+          objc-method-access sign-compare undef unused-function \\\n+          unused-variable, \\\n","filename":"make\/modules\/java.desktop\/lib\/AwtLibraries.gmk","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+    DISABLED_WARNINGS_clang_mlib_ImageCreate.c := unused-function, \\\n@@ -87,2 +88,2 @@\n-    DISABLED_WARNINGS_gcc := format-nonliteral type-limits \\\n-        stringop-truncation, \\\n+    DISABLED_WARNINGS_gcc := format-nonliteral stringop-truncation type-limits \\\n+        unused-variable, \\\n@@ -103,1 +104,2 @@\n-      jpegdecoder.c\n+      jpegdecoder.c \\\n+      #\n@@ -121,1 +123,2 @@\n-    DISABLED_WARNINGS_gcc_imageioJPEG.c := clobbered array-bounds, \\\n+    DISABLED_WARNINGS_gcc_imageioJPEG.c := array-bounds clobbered \\\n+        unused-but-set-variable, \\\n@@ -124,0 +127,1 @@\n+    DISABLED_WARNINGS_clang_imageioJPEG.c := unused-but-set-variable, \\\n@@ -227,1 +231,2 @@\n-      DISABLED_WARNINGS_gcc_splashscreen_sys.c := type-limits unused-result, \\\n+      DISABLED_WARNINGS_gcc_splashscreen_sys.c := type-limits \\\n+          unused-but-set-variable unused-result unused-variable, \\\n@@ -231,1 +236,2 @@\n-      DISABLED_WARNINGS_clang_splashscreen_impl.c := sign-compare, \\\n+      DISABLED_WARNINGS_clang_splashscreen_impl.c := sign-compare \\\n+          unused-but-set-variable unused-function, \\\n@@ -234,1 +240,2 @@\n-      DISABLED_WARNINGS_clang_splashscreen_sys.m := deprecated-declarations, \\\n+      DISABLED_WARNINGS_clang_splashscreen_sys.m := deprecated-declarations \\\n+          unused-variable unused-but-set-variable, \\\n@@ -282,3 +289,3 @@\n-   LIBFONTMANAGER_EXTRA_SRC =\n-   LIBFONTMANAGER_LIBS += $(HARFBUZZ_LIBS)\n-   LIBFONTMANAGER_CFLAGS += $(HARFBUZZ_CFLAGS)\n+  LIBFONTMANAGER_EXTRA_SRC =\n+  LIBFONTMANAGER_LIBS += $(HARFBUZZ_LIBS)\n+  LIBFONTMANAGER_CFLAGS += $(HARFBUZZ_CFLAGS)\n@@ -286,1 +293,1 @@\n-   LIBFONTMANAGER_EXTRA_SRC = libharfbuzz\n+  LIBFONTMANAGER_EXTRA_SRC = libharfbuzz\n@@ -288,2 +295,2 @@\n-   ifeq ($(call isTargetOs, windows), false)\n-     HARFBUZZ_CFLAGS += -DGETPAGESIZE -DHAVE_MPROTECT -DHAVE_PTHREAD \\\n+  ifeq ($(call isTargetOs, windows), false)\n+    HARFBUZZ_CFLAGS += -DGETPAGESIZE -DHAVE_MPROTECT -DHAVE_PTHREAD \\\n@@ -292,9 +299,9 @@\n-   endif\n-   ifeq ($(call isTargetOs, linux macosx), true)\n-     HARFBUZZ_CFLAGS += -DHAVE_INTEL_ATOMIC_PRIMITIVES -DHB_NO_VISIBILITY\n-   endif\n-\n-   # hb-ft.cc is not presently needed, and requires freetype 2.4.2 or later.\n-   # hb-subset and hb-style APIs are not needed, excluded to cut on compilation\n-   # time.\n-   LIBFONTMANAGER_EXCLUDE_FILES += gsubgpos-context.cc hb-ft.cc hb-style.cc \\\n+  endif\n+  ifeq ($(call isTargetOs, linux macosx), true)\n+    HARFBUZZ_CFLAGS += -DHAVE_INTEL_ATOMIC_PRIMITIVES -DHB_NO_VISIBILITY\n+  endif\n+\n+  # hb-ft.cc is not presently needed, and requires freetype 2.4.2 or later.\n+  # hb-subset and hb-style APIs are not needed, excluded to cut on compilation\n+  # time.\n+  LIBFONTMANAGER_EXCLUDE_FILES += gsubgpos-context.cc hb-ft.cc hb-style.cc \\\n@@ -305,21 +312,22 @@\n-   # list of disabled warnings and the compilers for which it was specifically\n-   # added.\n-   # array-bounds         -> GCC 12 on Alpine Linux\n-   # parentheses          -> GCC 6\n-   # range-loop-analysis  -> clang on Xcode12\n-\n-   HARFBUZZ_DISABLED_WARNINGS_gcc := missing-field-initializers \\\n-       strict-aliasing unused-result array-bounds parentheses\n-   # noexcept-type required for GCC 7 builds. Not required for GCC 8+.\n-   # expansion-to-defined required for GCC 9 builds. Not required for GCC 10+.\n-   # maybe-uninitialized required for GCC 8 builds. Not required for GCC 9+.\n-   # calloc-transposed-args required for GCC 14 builds. (fixed upstream in\n-   #  Harfbuzz 032c931e1c0cfb20f18e5acb8ba005775242bd92)\n-   HARFBUZZ_DISABLED_WARNINGS_CXX_gcc := class-memaccess noexcept-type \\\n-       expansion-to-defined dangling-reference maybe-uninitialized \\\n-       calloc-transposed-args\n-   HARFBUZZ_DISABLED_WARNINGS_clang := missing-field-initializers \\\n-      range-loop-analysis\n-   HARFBUZZ_DISABLED_WARNINGS_microsoft := 4267 4244\n-\n-   LIBFONTMANAGER_CFLAGS += $(HARFBUZZ_CFLAGS)\n+  # list of disabled warnings and the compilers for which it was specifically\n+  # added.\n+  # array-bounds         -> GCC 12 on Alpine Linux\n+  # parentheses          -> GCC 6\n+  # range-loop-analysis  -> clang on Xcode12\n+\n+  HARFBUZZ_DISABLED_WARNINGS_gcc := missing-field-initializers \\\n+      strict-aliasing unused-result array-bounds parentheses \\\n+       unused-variable\n+  # noexcept-type required for GCC 7 builds. Not required for GCC 8+.\n+  # expansion-to-defined required for GCC 9 builds. Not required for GCC 10+.\n+  # maybe-uninitialized required for GCC 8 builds. Not required for GCC 9+.\n+  # calloc-transposed-args required for GCC 14 builds. (fixed upstream in\n+  #  Harfbuzz 032c931e1c0cfb20f18e5acb8ba005775242bd92)\n+  HARFBUZZ_DISABLED_WARNINGS_CXX_gcc := class-memaccess noexcept-type \\\n+      expansion-to-defined dangling-reference maybe-uninitialized \\\n+      calloc-transposed-args\n+  HARFBUZZ_DISABLED_WARNINGS_clang := missing-field-initializers \\\n+      range-loop-analysis unused-variable\n+  HARFBUZZ_DISABLED_WARNINGS_microsoft := 4267 4244\n+\n+  LIBFONTMANAGER_CFLAGS += $(HARFBUZZ_CFLAGS)\n@@ -387,1 +395,1 @@\n-    LDFLAGS_FILTER_OUT :=-Wl$(COMMA)-z$(COMMA)defs, \\\n+    LDFLAGS_FILTER_OUT := -Wl$(COMMA)-z$(COMMA)defs, \\\n","filename":"make\/modules\/java.desktop\/lib\/ClientLibraries.gmk","additions":52,"deletions":44,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+    DISABLED_WARNINGS_gcc_VMManagementImpl.c := unused-variable, \\\n+    DISABLED_WARNINGS_clang_VMManagementImpl.c := unused-variable, \\\n@@ -41,1 +43,1 @@\n-    LIBS_aix := -lperfstat,\\\n+    LIBS_aix := -lperfstat, \\\n","filename":"make\/modules\/java.management\/Lib.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n-    DISABLED_WARNINGS_gcc := undef, \\\n-    DISABLED_WARNINGS_clang := undef, \\\n+    DISABLED_WARNINGS_gcc := undef unused-but-set-variable, \\\n+    DISABLED_WARNINGS_clang := undef unused-but-set-variable, \\\n","filename":"make\/modules\/java.security.jgss\/Lib.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-   ))\n+    ))\n","filename":"make\/modules\/jdk.accessibility\/Launcher.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+    DISABLED_WARNINGS_gcc_p11_md.c := unused-variable, \\\n+    DISABLED_WARNINGS_clang_p11_md.c := unused-variable, \\\n","filename":"make\/modules\/jdk.crypto.cryptoki\/Lib.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+    DISABLED_WARNINGS_gcc_LinuxDebuggerLocal.cpp := unused-variable, \\\n@@ -63,1 +64,1 @@\n-    DISABLED_WARNINGS_clang_ps_core.c := pointer-arith, \\\n+    DISABLED_WARNINGS_gcc_symtab.c := unused-but-set-variable, \\\n@@ -66,0 +67,2 @@\n+    DISABLED_WARNINGS_clang_MacosxDebuggerLocal.m := unused-variable, \\\n+    DISABLED_WARNINGS_clang_ps_core.c := pointer-arith, \\\n","filename":"make\/modules\/jdk.hotspot.agent\/Lib.gmk","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-$(eval $(call SetupVersionProperties, JAVADOC_VERSION,\\\n+$(eval $(call SetupVersionProperties, JAVADOC_VERSION, \\\n","filename":"make\/modules\/jdk.javadoc\/Gensrc.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-$(eval $(call SetupVersionProperties, JDEPS_VERSION,\\\n+$(eval $(call SetupVersionProperties, JDEPS_VERSION, \\\n","filename":"make\/modules\/jdk.jdeps\/Gensrc.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    DISABLED_WARNINGS_gcc_eventFilter.c := unused-variable, \\\n@@ -56,0 +57,3 @@\n+    DISABLED_WARNINGS_gcc_threadControl.c := unused-but-set-variable \\\n+        unused-variable, \\\n+    DISABLED_WARNINGS_gcc_utf_util.c := unused-but-set-variable, \\\n@@ -57,0 +61,1 @@\n+    DISABLED_WARNINGS_clang_eventFilter.c := unused-variable, \\\n@@ -60,0 +65,4 @@\n+    DISABLED_WARNINGS_clang_SDE.c := unused-function, \\\n+    DISABLED_WARNINGS_clang_threadControl.c := unused-but-set-variable \\\n+        unused-variable, \\\n+    DISABLED_WARNINGS_clang_utf_util.c := unused-but-set-variable, \\\n@@ -63,2 +72,2 @@\n-        java.base:libjava \\\n-        java.base:libjvm, \\\n+        java.base:libjava, \\\n+    JDK_LIBS := java.base:libjvm, \\\n","filename":"make\/modules\/jdk.jdwp.agent\/Lib.gmk","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-$(eval $(call SetupBuildLauncher, jimage,\\\n+$(eval $(call SetupBuildLauncher, jimage, \\\n@@ -41,1 +41,1 @@\n-$(eval $(call SetupBuildLauncher, jlink,\\\n+$(eval $(call SetupBuildLauncher, jlink, \\\n@@ -51,1 +51,1 @@\n-$(eval $(call SetupBuildLauncher, jmod,\\\n+$(eval $(call SetupBuildLauncher, jmod, \\\n","filename":"make\/modules\/jdk.jlink\/Launcher.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-    DISABLED_WARNINGS_clang_LinuxPackage.c := format-nonliteral, \\\n@@ -58,0 +57,2 @@\n+    DISABLED_WARNINGS_clang_LinuxPackage.c := format-nonliteral, \\\n+    DISABLED_WARNINGS_clang_Log.cpp := unused-const-variable, \\\n@@ -92,0 +93,1 @@\n+      DISABLED_WARNINGS_gcc_Log.cpp := unused-const-variable, \\\n","filename":"make\/modules\/jdk.jpackage\/Lib.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+    DISABLED_WARNINGS_gcc_DiagnosticCommandImpl.c := unused-variable, \\\n+    DISABLED_WARNINGS_clang_DiagnosticCommandImpl.c := unused-variable, \\\n@@ -50,1 +52,1 @@\n-    LIBS_aix := -lperfstat,\\\n+    LIBS_aix := -lperfstat, \\\n","filename":"make\/modules\/jdk.management\/Lib.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+    CREATE_API_DIGEST := true, \\\n@@ -151,1 +152,1 @@\n-    EXCLUDE_FILES:= _the.BUILD_JDK_MICROBENCHMARK_batch \\\n+    EXCLUDE_FILES := _the.BUILD_JDK_MICROBENCHMARK_batch \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    DISABLED_WARNINGS := try deprecation rawtypes unchecked serial cast removal preview dangling-doc-comments, \\\n+    DISABLED_WARNINGS := try deprecation rawtypes unchecked serial cast removal preview restricted dangling-doc-comments, \\\n","filename":"make\/test\/BuildTestLib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -66,1 +67,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -69,1 +71,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/native\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/native \\\n+    #\n@@ -73,1 +76,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jdi\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jdi \\\n+    #\n@@ -77,1 +81,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -82,1 +87,2 @@\n-    -I$(TOPDIR)\/test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\n+    -I$(TOPDIR)\/test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti \\\n+    #\n@@ -86,1 +92,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/locks\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/locks \\\n+    #\n@@ -93,1 +100,2 @@\n-    -I$(VM_TESTBASE_DIR)\/vm\/mlvm\/share\n+    -I$(VM_TESTBASE_DIR)\/vm\/mlvm\/share \\\n+    #\n@@ -97,1 +105,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -102,1 +111,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -107,1 +117,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -111,1 +122,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -114,1 +126,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/stress\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/stress\/jni \\\n+    #\n@@ -120,1 +133,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/agent_common\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/agent_common \\\n+    #\n@@ -127,1 +141,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/aod\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/aod \\\n+    #\n@@ -132,1 +147,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -143,1 +159,1 @@\n-JVMTI_COMMON_INCLUDES=-I$(TOPDIR)\/test\/lib\/jdk\/test\/lib\/jvmti\n+JVMTI_COMMON_INCLUDES = -I$(TOPDIR)\/test\/lib\/jdk\/test\/lib\/jvmti\n@@ -765,1 +781,1 @@\n-BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS_libgetclmdf006 :=$(NSK_JVMTI_AGENT_INCLUDES)\n+BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS_libgetclmdf006 := $(NSK_JVMTI_AGENT_INCLUDES)\n@@ -1562,1 +1578,1 @@\n-$(eval $(call SetupCopyFiles,COPY_HOTSPOT_JTREG_NATIVE, \\\n+$(eval $(call SetupCopyFiles, COPY_HOTSPOT_JTREG_NATIVE, \\\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":35,"deletions":19,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-    -I$(TOPDIR)\/src\/java.base\/$(OPENJDK_TARGET_OS)\/native\/libjli\n+    -I$(TOPDIR)\/src\/java.base\/$(OPENJDK_TARGET_OS)\/native\/libjli \\\n+    #\n@@ -157,1 +158,1 @@\n-$(eval $(call SetupCopyFiles,COPY_JDK_JTREG_NATIVE, \\\n+$(eval $(call SetupCopyFiles, COPY_JDK_JTREG_NATIVE, \\\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/images\/About.jpg","binary":true,"status":"modified"},{"patch":"@@ -2337,1 +2337,1 @@\n-  int size = MIN2((UseSVE > 0) ? 256 : 16, (int)MaxVectorSize);\n+  int size = MIN2((UseSVE > 0) ? (int)FloatRegister::sve_vl_max : (int)FloatRegister::neon_vl, (int)MaxVectorSize);\n@@ -2376,1 +2376,1 @@\n-  if (UseSVE > 0 && 16 < len && len <= 256) {\n+  if (UseSVE > 0 && FloatRegister::neon_vl < len && len <= FloatRegister::sve_vl_max) {\n@@ -2723,1 +2723,1 @@\n-      \/* Fix up any out-of-range offsets. *\/\n+      \/\/ Fix up any out-of-range offsets.\n@@ -2764,1 +2764,5 @@\n-      (masm->*insn)(reg, T, Address(base, disp));\n+      \/\/ Fix up any out-of-range offsets.\n+      assert_different_registers(rscratch1, base);\n+      Address addr = Address(base, disp);\n+      addr = __ legitimize_address(addr, (1 << T), rscratch1);\n+      (masm->*insn)(reg, T, addr);\n@@ -2819,1 +2823,1 @@\n-  enc_class aarch64_enc_ldrsbw(iRegI dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrsbw(iRegI dst, memory mem) %{\n@@ -2827,1 +2831,1 @@\n-  enc_class aarch64_enc_ldrsb(iRegI dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrsb(iRegI dst, memory mem) %{\n@@ -2835,1 +2839,1 @@\n-  enc_class aarch64_enc_ldrb(iRegI dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrb(iRegI dst, memory mem) %{\n@@ -2843,1 +2847,1 @@\n-  enc_class aarch64_enc_ldrb(iRegL dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrb(iRegL dst, memory mem) %{\n@@ -2851,1 +2855,1 @@\n-  enc_class aarch64_enc_ldrshw(iRegI dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrshw(iRegI dst, memory mem) %{\n@@ -2859,1 +2863,1 @@\n-  enc_class aarch64_enc_ldrsh(iRegI dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrsh(iRegI dst, memory mem) %{\n@@ -2867,1 +2871,1 @@\n-  enc_class aarch64_enc_ldrh(iRegI dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrh(iRegI dst, memory mem) %{\n@@ -2875,1 +2879,1 @@\n-  enc_class aarch64_enc_ldrh(iRegL dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrh(iRegL dst, memory mem) %{\n@@ -2883,1 +2887,1 @@\n-  enc_class aarch64_enc_ldrw(iRegI dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrw(iRegI dst, memory mem) %{\n@@ -2891,1 +2895,1 @@\n-  enc_class aarch64_enc_ldrw(iRegL dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrw(iRegL dst, memory mem) %{\n@@ -2899,1 +2903,1 @@\n-  enc_class aarch64_enc_ldrsw(iRegL dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrsw(iRegL dst, memory mem) %{\n@@ -2907,1 +2911,1 @@\n-  enc_class aarch64_enc_ldr(iRegL dst, memory8 mem) %{\n+  enc_class aarch64_enc_ldr(iRegL dst, memory mem) %{\n@@ -2915,1 +2919,1 @@\n-  enc_class aarch64_enc_ldrs(vRegF dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrs(vRegF dst, memory mem) %{\n@@ -2923,1 +2927,1 @@\n-  enc_class aarch64_enc_ldrd(vRegD dst, memory8 mem) %{\n+  enc_class aarch64_enc_ldrd(vRegD dst, memory mem) %{\n@@ -2931,1 +2935,1 @@\n-  enc_class aarch64_enc_strb(iRegI src, memory1 mem) %{\n+  enc_class aarch64_enc_strb(iRegI src, memory mem) %{\n@@ -2939,1 +2943,1 @@\n-  enc_class aarch64_enc_strb0(memory1 mem) %{\n+  enc_class aarch64_enc_strb0(memory mem) %{\n@@ -2946,1 +2950,1 @@\n-  enc_class aarch64_enc_strh(iRegI src, memory2 mem) %{\n+  enc_class aarch64_enc_strh(iRegI src, memory mem) %{\n@@ -2954,1 +2958,1 @@\n-  enc_class aarch64_enc_strh0(memory2 mem) %{\n+  enc_class aarch64_enc_strh0(memory mem) %{\n@@ -2961,1 +2965,1 @@\n-  enc_class aarch64_enc_strw(iRegI src, memory4 mem) %{\n+  enc_class aarch64_enc_strw(iRegI src, memory mem) %{\n@@ -2969,1 +2973,1 @@\n-  enc_class aarch64_enc_strw0(memory4 mem) %{\n+  enc_class aarch64_enc_strw0(memory mem) %{\n@@ -2976,1 +2980,1 @@\n-  enc_class aarch64_enc_str(iRegL src, memory8 mem) %{\n+  enc_class aarch64_enc_str(iRegL src, memory mem) %{\n@@ -2991,1 +2995,1 @@\n-  enc_class aarch64_enc_str0(memory8 mem) %{\n+  enc_class aarch64_enc_str0(memory mem) %{\n@@ -2998,1 +3002,1 @@\n-  enc_class aarch64_enc_strs(vRegF src, memory4 mem) %{\n+  enc_class aarch64_enc_strs(vRegF src, memory mem) %{\n@@ -3006,1 +3010,1 @@\n-  enc_class aarch64_enc_strd(vRegD src, memory8 mem) %{\n+  enc_class aarch64_enc_strd(vRegD src, memory mem) %{\n@@ -3014,1 +3018,1 @@\n-  enc_class aarch64_enc_strb0_ordered(memory4 mem) %{\n+  enc_class aarch64_enc_strb0_ordered(memory mem) %{\n@@ -3216,1 +3220,1 @@\n-  enc_class aarch64_enc_ldaxr(iRegL dst, memory8 mem) %{\n+  enc_class aarch64_enc_ldaxr(iRegL dst, memory mem) %{\n@@ -3244,1 +3248,1 @@\n-  enc_class aarch64_enc_stlxr(iRegLNoSp src, memory8 mem) %{\n+  enc_class aarch64_enc_stlxr(iRegLNoSp src, memory mem) %{\n@@ -4172,1 +4176,1 @@\n-\/\/ Offset for scaled or unscaled immediate loads and stores\n+\/\/ Offset for immediate loads and stores\n@@ -4175,51 +4179,1 @@\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 0));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset1()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 0));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset2()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 1));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset4()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 2));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset8()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 3));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset16()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 4));\n+  predicate(n->get_int() >= -256 && n->get_int() <= 65520);\n@@ -4243,50 +4197,0 @@\n-operand immLoffset1()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 0));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset2()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 1));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset4()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 2));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset8()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 3));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset16()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 4));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -5205,15 +5109,1 @@\n-operand indOffI1(iRegP reg, immIOffset1 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffI2(iRegP reg, immIOffset2 off)\n+operand indOffI(iRegP reg, immIOffset off)\n@@ -5233,99 +5123,1 @@\n-operand indOffI4(iRegP reg, immIOffset4 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffI8(iRegP reg, immIOffset8 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffI16(iRegP reg, immIOffset16 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL1(iRegP reg, immLoffset1 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL2(iRegP reg, immLoffset2 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL4(iRegP reg, immLoffset4 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL8(iRegP reg, immLoffset8 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL16(iRegP reg, immLoffset16 off)\n+operand indOffL(iRegP reg, immLOffset off)\n@@ -5707,4 +5499,1 @@\n-opclass vmem2(indirect, indIndex, indOffI2, indOffL2);\n-opclass vmem4(indirect, indIndex, indOffI4, indOffL4);\n-opclass vmem8(indirect, indIndex, indOffI8, indOffL8);\n-opclass vmem16(indirect, indIndex, indOffI16, indOffL16);\n+opclass vmem(indirect, indIndex, indOffI, indOffL, indOffIN, indOffLN);\n@@ -5722,17 +5511,3 @@\n-opclass memory1(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI1, indOffL1,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n-\n-opclass memory2(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI2, indOffL2,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n-\n-opclass memory4(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI4, indOffL4,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n-\n-opclass memory8(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI8, indOffL8,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n-\n-\/\/ All of the memory operands. For the pipeline description.\n-opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex,\n-               indOffI1, indOffL1, indOffI2, indOffL2, indOffI4, indOffL4, indOffI8, indOffL8,\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n-\n+opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI, indOffL,\n+               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN,\n+               indOffLN, indirectX2P, indOffX2P);\n@@ -6440,1 +6215,1 @@\n-instruct loadB(iRegINoSp dst, memory1 mem)\n+instruct loadB(iRegINoSp dst, memory mem)\n@@ -6454,1 +6229,1 @@\n-instruct loadB2L(iRegLNoSp dst, memory1 mem)\n+instruct loadB2L(iRegLNoSp dst, memory mem)\n@@ -6468,1 +6243,1 @@\n-instruct loadUB(iRegINoSp dst, memory1 mem)\n+instruct loadUB(iRegINoSp dst, memory mem)\n@@ -6482,1 +6257,1 @@\n-instruct loadUB2L(iRegLNoSp dst, memory1 mem)\n+instruct loadUB2L(iRegLNoSp dst, memory mem)\n@@ -6496,1 +6271,1 @@\n-instruct loadS(iRegINoSp dst, memory2 mem)\n+instruct loadS(iRegINoSp dst, memory mem)\n@@ -6510,1 +6285,1 @@\n-instruct loadS2L(iRegLNoSp dst, memory2 mem)\n+instruct loadS2L(iRegLNoSp dst, memory mem)\n@@ -6524,1 +6299,1 @@\n-instruct loadUS(iRegINoSp dst, memory2 mem)\n+instruct loadUS(iRegINoSp dst, memory mem)\n@@ -6538,1 +6313,1 @@\n-instruct loadUS2L(iRegLNoSp dst, memory2 mem)\n+instruct loadUS2L(iRegLNoSp dst, memory mem)\n@@ -6552,1 +6327,1 @@\n-instruct loadI(iRegINoSp dst, memory4 mem)\n+instruct loadI(iRegINoSp dst, memory mem)\n@@ -6566,1 +6341,1 @@\n-instruct loadI2L(iRegLNoSp dst, memory4 mem)\n+instruct loadI2L(iRegLNoSp dst, memory mem)\n@@ -6580,1 +6355,1 @@\n-instruct loadUI2L(iRegLNoSp dst, memory4 mem, immL_32bits mask)\n+instruct loadUI2L(iRegLNoSp dst, memory mem, immL_32bits mask)\n@@ -6594,1 +6369,1 @@\n-instruct loadL(iRegLNoSp dst, memory8 mem)\n+instruct loadL(iRegLNoSp dst, memory mem)\n@@ -6608,1 +6383,1 @@\n-instruct loadRange(iRegINoSp dst, memory4 mem)\n+instruct loadRange(iRegINoSp dst, memory mem)\n@@ -6621,1 +6396,1 @@\n-instruct loadP(iRegPNoSp dst, memory8 mem)\n+instruct loadP(iRegPNoSp dst, memory mem)\n@@ -6635,1 +6410,1 @@\n-instruct loadN(iRegNNoSp dst, memory4 mem)\n+instruct loadN(iRegNNoSp dst, memory mem)\n@@ -6649,1 +6424,1 @@\n-instruct loadKlass(iRegPNoSp dst, memory8 mem)\n+instruct loadKlass(iRegPNoSp dst, memory mem)\n@@ -6663,1 +6438,1 @@\n-instruct loadNKlass(iRegNNoSp dst, memory4 mem)\n+instruct loadNKlass(iRegNNoSp dst, memory mem)\n@@ -6677,1 +6452,1 @@\n-instruct loadF(vRegF dst, memory4 mem)\n+instruct loadF(vRegF dst, memory mem)\n@@ -6691,1 +6466,1 @@\n-instruct loadD(vRegD dst, memory8 mem)\n+instruct loadD(vRegD dst, memory mem)\n@@ -6895,1 +6670,1 @@\n-instruct storeimmCM0(immI0 zero, memory1 mem)\n+instruct storeimmCM0(immI0 zero, memory mem)\n@@ -6910,1 +6685,1 @@\n-instruct storeimmCM0_ordered(immI0 zero, memory1 mem)\n+instruct storeimmCM0_ordered(immI0 zero, memory mem)\n@@ -6925,1 +6700,1 @@\n-instruct storeB(iRegIorL2I src, memory1 mem)\n+instruct storeB(iRegIorL2I src, memory mem)\n@@ -6939,1 +6714,1 @@\n-instruct storeimmB0(immI0 zero, memory1 mem)\n+instruct storeimmB0(immI0 zero, memory mem)\n@@ -6953,1 +6728,1 @@\n-instruct storeC(iRegIorL2I src, memory2 mem)\n+instruct storeC(iRegIorL2I src, memory mem)\n@@ -6966,1 +6741,1 @@\n-instruct storeimmC0(immI0 zero, memory2 mem)\n+instruct storeimmC0(immI0 zero, memory mem)\n@@ -6981,1 +6756,1 @@\n-instruct storeI(iRegIorL2I src, memory4 mem)\n+instruct storeI(iRegIorL2I src, memory mem)\n@@ -6994,1 +6769,1 @@\n-instruct storeimmI0(immI0 zero, memory4 mem)\n+instruct storeimmI0(immI0 zero, memory mem)\n@@ -7008,1 +6783,1 @@\n-instruct storeL(iRegL src, memory8 mem)\n+instruct storeL(iRegL src, memory mem)\n@@ -7022,1 +6797,1 @@\n-instruct storeimmL0(immL0 zero, memory8 mem)\n+instruct storeimmL0(immL0 zero, memory mem)\n@@ -7036,1 +6811,1 @@\n-instruct storeP(iRegP src, memory8 mem)\n+instruct storeP(iRegP src, memory mem)\n@@ -7050,1 +6825,1 @@\n-instruct storeimmP0(immP0 zero, memory8 mem)\n+instruct storeimmP0(immP0 zero, memory mem)\n@@ -7064,1 +6839,1 @@\n-instruct storeN(iRegN src, memory4 mem)\n+instruct storeN(iRegN src, memory mem)\n@@ -7077,1 +6852,1 @@\n-instruct storeImmN0(immN0 zero, memory4 mem)\n+instruct storeImmN0(immN0 zero, memory mem)\n@@ -7091,1 +6866,1 @@\n-instruct storeF(vRegF src, memory4 mem)\n+instruct storeF(vRegF src, memory mem)\n@@ -7108,1 +6883,1 @@\n-instruct storeD(vRegD src, memory8 mem)\n+instruct storeD(vRegD src, memory mem)\n@@ -7122,1 +6897,1 @@\n-instruct storeNKlass(iRegN src, memory4 mem)\n+instruct storeNKlass(iRegN src, memory mem)\n@@ -7141,1 +6916,1 @@\n-instruct prefetchalloc( memory8 mem ) %{\n+instruct prefetchalloc( memory mem ) %{\n@@ -7710,1 +7485,1 @@\n-instruct popCountI_mem(iRegINoSp dst, memory4 mem, vRegF tmp) %{\n+instruct popCountI_mem(iRegINoSp dst, memory mem, vRegF tmp) %{\n@@ -7751,1 +7526,1 @@\n-instruct popCountL_mem(iRegINoSp dst, memory8 mem, vRegD tmp) %{\n+instruct popCountL_mem(iRegINoSp dst, memory mem, vRegD tmp) %{\n@@ -16021,1 +15796,1 @@\n-    __ fast_lock_lightweight($object$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n+    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -16037,1 +15812,1 @@\n-    __ fast_unlock_lightweight($object$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n+    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -16900,1 +16675,1 @@\n-instruct compressBitsI_memcon(iRegINoSp dst, memory4 mem, immI mask,\n+instruct compressBitsI_memcon(iRegINoSp dst, memory mem, immI mask,\n@@ -16937,1 +16712,1 @@\n-instruct compressBitsL_memcon(iRegLNoSp dst, memory8 mem, immL mask,\n+instruct compressBitsL_memcon(iRegLNoSp dst, memory mem, immL mask,\n@@ -16974,1 +16749,1 @@\n-instruct expandBitsI_memcon(iRegINoSp dst, memory4 mem, immI mask,\n+instruct expandBitsI_memcon(iRegINoSp dst, memory mem, immI mask,\n@@ -17012,1 +16787,1 @@\n-instruct expandBitsL_memcon(iRegINoSp dst, memory8 mem, immL mask,\n+instruct expandBitsL_memcon(iRegINoSp dst, memory mem, immL mask,\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":88,"deletions":313,"binary":false,"changes":401,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-    if (UseSVE == 0 && length_in_bytes > 16) {\n+    if (UseSVE == 0 && length_in_bytes > FloatRegister::neon_vl) {\n@@ -348,1 +348,1 @@\n-instruct loadV2(vReg dst, vmem2 mem) %{\n+instruct loadV2(vReg dst, vmem mem) %{\n@@ -357,1 +357,1 @@\n-instruct storeV2(vReg src, vmem2 mem) %{\n+instruct storeV2(vReg src, vmem mem) %{\n@@ -366,1 +366,1 @@\n-instruct loadV4(vReg dst, vmem4 mem) %{\n+instruct loadV4(vReg dst, vmem mem) %{\n@@ -375,1 +375,1 @@\n-instruct storeV4(vReg src, vmem4 mem) %{\n+instruct storeV4(vReg src, vmem mem) %{\n@@ -384,1 +384,1 @@\n-instruct loadV8(vReg dst, vmem8 mem) %{\n+instruct loadV8(vReg dst, vmem mem) %{\n@@ -393,1 +393,1 @@\n-instruct storeV8(vReg src, vmem8 mem) %{\n+instruct storeV8(vReg src, vmem mem) %{\n@@ -402,1 +402,1 @@\n-instruct loadV16(vReg dst, vmem16 mem) %{\n+instruct loadV16(vReg dst, vmem mem) %{\n@@ -411,1 +411,1 @@\n-instruct storeV16(vReg src, vmem16 mem) %{\n+instruct storeV16(vReg src, vmem mem) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-    if (UseSVE == 0 && length_in_bytes > 16) {\n+    if (UseSVE == 0 && length_in_bytes > FloatRegister::neon_vl) {\n@@ -341,1 +341,1 @@\n-instruct $1V$2(vReg $3, vmem$2 mem) %{\n+instruct $1V$2(vReg $3, vmem mem) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  enc_class aarch64_enc_$2($1 dst, memory$5 mem) %{dnl\n+  enc_class aarch64_enc_$2($1 dst, memory mem) %{dnl\n@@ -56,1 +56,1 @@\n-  enc_class aarch64_enc_$2($1 src, memory$5 mem) %{dnl\n+  enc_class aarch64_enc_$2($1 src, memory mem) %{dnl\n@@ -61,1 +61,1 @@\n-  enc_class aarch64_enc_$2`'0(memory$4 mem) %{\n+  enc_class aarch64_enc_$2`'0(memory mem) %{\n@@ -85,1 +85,1 @@\n-  enc_class aarch64_enc_strb0_ordered(memory4 mem) %{\n+  enc_class aarch64_enc_strb0_ordered(memory mem) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/ad_encode.m4","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,2 +63,0 @@\n-  void poll_for_safepoint(relocInfo::relocType rtype, CodeEmitInfo* info = nullptr);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,2 +78,2 @@\n-    ldrw(hdr, Address(hdr, Klass::access_flags_offset()));\n-    tstw(hdr, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    ldrb(hdr, Address(hdr, Klass::misc_flags_offset()));\n+    tst(hdr, KlassFlags::_misc_is_value_based_class);\n@@ -84,1 +84,1 @@\n-    lightweight_lock(obj, hdr, temp, rscratch2, slow_case);\n+    lightweight_lock(disp_hdr, obj, hdr, temp, rscratch2, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -786,2 +786,2 @@\n-        __ ldrw(t, Address(t, Klass::access_flags_offset()));\n-        __ tbnz(t, exact_log2(JVM_ACC_HAS_FINALIZER), register_finalizer);\n+        __ ldrb(t, Address(t, Klass::misc_flags_offset()));\n+        __ tbnz(t, exact_log2(KlassFlags::_misc_has_finalizer), register_finalizer);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,2 +67,2 @@\n-    ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n-    tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    ldrb(tmp, Address(tmp, Klass::misc_flags_offset()));\n+    tst(tmp, KlassFlags::_misc_is_value_based_class);\n@@ -227,1 +227,1 @@\n-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register t1,\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register t1,\n@@ -230,1 +230,1 @@\n-  assert_different_registers(obj, t1, t2, t3);\n+  assert_different_registers(obj, box, t1, t2, t3);\n@@ -239,0 +239,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    str(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }\n+\n@@ -241,2 +246,2 @@\n-    ldrw(t1, Address(t1, Klass::access_flags_offset()));\n-    tstw(t1, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    ldrb(t1, Address(t1, Klass::misc_flags_offset()));\n+    tst(t1, KlassFlags::_misc_is_value_based_class);\n@@ -247,0 +252,1 @@\n+  const Register t3_t = t3;\n@@ -254,1 +260,0 @@\n-    const Register t3_t = t3;\n@@ -292,3 +297,38 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register t1_tagged_monitor = t1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register t1_monitor = t1;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(t1_monitor == t1_mark, \"should be the same here\");\n+    } else {\n+      Label monitor_found;\n+\n+      \/\/ Load cache address\n+      lea(t3_t, Address(rthread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        ldr(t1, Address(t3_t));\n+        cmp(obj, t1);\n+        br(Assembler::EQ, monitor_found);\n+        increment(t3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      Label loop;\n+\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      ldr(t1, Address(t3_t));\n+      cmp(obj, t1);\n+      br(Assembler::EQ, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      increment(t3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      cbnz(t1, loop);\n+      \/\/ Cache Miss, NE set from cmp above, cbnz does not set flags\n+      b(slow_path);\n+\n+      bind(monitor_found);\n+      ldr(t1_monitor, Address(t3_t, OMCache::oop_to_monitor_difference()));\n+    }\n+\n@@ -297,0 +337,5 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address owner_address(t1_monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+    const Address recursions_address(t1_monitor, ObjectMonitor::recursions_offset() - monitor_tag);\n+\n+    Label monitor_locked;\n@@ -299,1 +344,1 @@\n-    lea(t2_owner_addr, Address(t1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n+    lea(t2_owner_addr, owner_address);\n@@ -304,1 +349,1 @@\n-    br(Assembler::EQ, locked);\n+    br(Assembler::EQ, monitor_locked);\n@@ -311,1 +356,6 @@\n-    increment(Address(t1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1);\n+    increment(recursions_address, 1);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      str(t1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+    }\n@@ -334,2 +384,2 @@\n-void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register t1, Register t2,\n-                                                Register t3) {\n+void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register box, Register t1,\n+                                                Register t2, Register t3) {\n@@ -337,1 +387,1 @@\n-  assert_different_registers(obj, t1, t2, t3);\n+  assert_different_registers(obj, box, t1, t2, t3);\n@@ -340,1 +390,1 @@\n-  Label inflated, inflated_load_monitor;\n+  Label inflated, inflated_load_mark;\n@@ -352,0 +402,2 @@\n+    Label push_and_slow_path;\n+\n@@ -358,1 +410,1 @@\n-    br(Assembler::NE, inflated_load_monitor);\n+    br(Assembler::NE, inflated_load_mark);\n@@ -375,1 +427,4 @@\n-    tbnz(t1_mark, exact_log2(markWord::monitor_value), inflated);\n+    \/\/ Because we got here by popping (meaning we pushed in locked)\n+    \/\/ there will be no monitor in the box. So we need to push back the obj\n+    \/\/ so that the runtime can fix any potential anonymous owner.\n+    tbnz(t1_mark, exact_log2(markWord::monitor_value), UseObjectMonitorTable ? push_and_slow_path : inflated);\n@@ -384,0 +439,1 @@\n+    bind(push_and_slow_path);\n@@ -394,1 +450,1 @@\n-    bind(inflated_load_monitor);\n+    bind(inflated_load_mark);\n@@ -415,3 +471,4 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register t1_monitor = t1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register t1_monitor = t1;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(t1_monitor == t1_mark, \"should be the same here\");\n@@ -419,2 +476,8 @@\n-    \/\/ Untag the monitor.\n-    sub(t1_monitor, t1_mark, monitor_tag);\n+      \/\/ Untag the monitor.\n+      add(t1_monitor, t1_mark, -(int)markWord::monitor_value);\n+    } else {\n+      ldr(t1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ null check with Flags == NE, no valid pointer below alignof(ObjectMonitor*)\n+      cmp(t1_monitor, checked_cast<uint8_t>(alignof(ObjectMonitor*)));\n+      br(Assembler::LO, slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":88,"deletions":25,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-  void fast_lock_lightweight(Register object, Register t1, Register t2, Register t3);\n-  void fast_unlock_lightweight(Register object, Register t1, Register t2, Register t3);\n+  void fast_lock_lightweight(Register object, Register box, Register t1, Register t2, Register t3);\n+  void fast_unlock_lightweight(Register object, Register box, Register t1, Register t2, Register t3);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-instruct xLoadP(iRegPNoSp dst, memory8 mem, rFlagsReg cr)\n+instruct xLoadP(iRegPNoSp dst, memory mem, rFlagsReg cr)\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/x\/x_aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-instruct zLoadP(iRegPNoSp dst, memory8 mem, rFlagsReg cr)\n+instruct zLoadP(iRegPNoSp dst, memory mem, rFlagsReg cr)\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -693,2 +693,2 @@\n-      ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n-      tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n+      ldrb(tmp, Address(tmp, Klass::misc_flags_offset()));\n+      tst(tmp, KlassFlags::_misc_is_value_based_class);\n@@ -699,1 +699,1 @@\n-      lightweight_lock(obj_reg, tmp, tmp2, tmp3, slow_case);\n+      lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n@@ -755,9 +755,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-              obj_reg);\n-    } else {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-              lock_reg);\n-    }\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+            lock_reg);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -747,1 +747,1 @@\n-    lea(rscratch1, RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+    lea(rscratch1, RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n@@ -6416,0 +6416,3 @@\n+  if (!UseSVE || VM_Version::get_max_supported_sve_vector_length() == FloatRegister::sve_vl_min) {\n+    return;\n+  }\n@@ -6417,1 +6420,0 @@\n-  if (!UseSVE) return;\n@@ -6753,1 +6755,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register t1, Register t2, Register t3, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register t1, Register t2, Register t3, Label& slow) {\n@@ -6755,1 +6757,1 @@\n-  assert_different_registers(obj, t1, t2, t3, rscratch1);\n+  assert_different_registers(basic_lock, obj, t1, t2, t3, rscratch1);\n@@ -6766,0 +6768,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    str(zr, Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1642,1 +1642,1 @@\n-  void lightweight_lock(Register obj, Register t1, Register t2, Register t3, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register t1, Register t2, Register t3, Label& slow);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_AbstractMethodError_entry()));\n@@ -454,1 +454,1 @@\n-      __ far_jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));\n+      __ far_jump(RuntimeAddress(SharedRuntime::throw_IncompatibleClassChangeError_entry()));\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,1 +169,7 @@\n-    extra_save_slots_per_neon_register = slots_per_neon_register - save_slots_per_register\n+    extra_save_slots_per_neon_register = slots_per_neon_register - save_slots_per_register,\n+    neon_vl = 16,\n+    \/\/ VLmax: The maximum sve vector length is determined by the hardware\n+    \/\/ sve_vl_min <= VLmax <= sve_vl_max.\n+    sve_vl_min = 16,\n+    \/\/ Maximum supported vector length across all CPUs\n+    sve_vl_max = 256\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,0 +69,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif\n+\n@@ -1814,1 +1820,1 @@\n-      __ lightweight_lock(obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n+      __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -2178,1 +2184,2 @@\n-  CodeBuffer buffer(\"deopt_blob\", 2048+pad, 1024);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  CodeBuffer buffer(name, 2048+pad, 1024);\n@@ -2562,1 +2569,3 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+  assert(is_polling_page_id(id), \"expected a polling page stub id\");\n+\n@@ -2568,1 +2577,2 @@\n-  CodeBuffer buffer(\"handler_blob\", 2048, 1024);\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBuffer buffer(name, 2048, 1024);\n@@ -2574,2 +2584,2 @@\n-  bool cause_return = (poll_type == POLL_AT_RETURN);\n-  RegisterSaver reg_save(poll_type == POLL_AT_VECTOR_LOOP \/* save_vectors *\/);\n+  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n+  RegisterSaver reg_save(id == SharedStubId::polling_page_vectors_safepoint_handler_id \/* save_vectors *\/);\n@@ -2687,1 +2697,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n@@ -2689,0 +2699,1 @@\n+  assert(is_resolve_id(id), \"expected a resolve stub id\");\n@@ -2693,0 +2704,1 @@\n+  const char* name = SharedRuntime::stub_name(id);\n@@ -2767,0 +2779,196 @@\n+\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Since we need to preserve callee-saved values (currently\n+\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+\/\/ map and therefore have to make these stubs into RuntimeStubs\n+\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+\/\/ be preserved between the fault point and the exception handler\n+\/\/ then it must assume responsibility for that in\n+\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+  assert(is_throw_id(id), \"expected a throw stub id\");\n+\n+  const char* name = SharedRuntime::stub_name(id);\n+\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  \/\/ n.b. aarch64 asserts that frame::arg_reg_save_area_bytes == 0\n+  enum layout {\n+    rfp_off = 0,\n+    rfp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 512;\n+  int locs_size  = 64;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+\n+  __ enter(); \/\/ Save FP and LR before call\n+\n+  assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n+\n+  \/\/ lr and fp are already in place\n+  __ sub(sp, rfp, ((uint64_t)framesize-4) << LogBytesPerInt); \/\/ prolog\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n+\n+  __ mov(c_rarg0, rthread);\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ mov(rscratch1, runtime_entry);\n+  __ blr(rscratch1);\n+\n+  \/\/ Generate oop map\n+  OopMap* map = new OopMap(framesize, 0);\n+\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+  \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+  __ reinitialize_ptrue();\n+\n+  __ leave();\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));\n+  __ cbnz(rscratch1, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/\/ ASSERT\n+  __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+static void jfr_prologue(address the_pc, MacroAssembler* masm, Register thread) {\n+  __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n+  __ mov(c_rarg0, thread);\n+}\n+\n+\/\/ The handle is dereferenced through a load barrier.\n+static void jfr_epilogue(MacroAssembler* masm) {\n+  __ reset_last_Java_frame(true);\n+}\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+  jfr_epilogue(masm);\n+  __ resolve_global_jobject(r0, rscratch1, rscratch2);\n+  __ leave();\n+  __ ret(lr);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  jfr_epilogue(masm);\n+\n+  __ leave();\n+  __ ret(lr);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":215,"deletions":7,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -7048,1 +7048,1 @@\n-    __ lea(rscratch1, RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+    __ lea(rscratch1, RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -7308,92 +7308,0 @@\n-#if INCLUDE_JFR\n-\n-  static void jfr_prologue(address the_pc, MacroAssembler* _masm, Register thread) {\n-    __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n-    __ mov(c_rarg0, thread);\n-  }\n-\n-  \/\/ The handle is dereferenced through a load barrier.\n-  static void jfr_epilogue(MacroAssembler* _masm) {\n-    __ reset_last_Java_frame(true);\n-  }\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      rbp_off,\n-      rbpH_off,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-    jfr_epilogue(_masm);\n-    __ resolve_global_jobject(r0, rscratch1, rscratch2);\n-    __ leave();\n-    __ ret(lr);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      rbp_off,\n-      rbpH_off,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-    jfr_epilogue(_masm);\n-\n-    __ leave();\n-    __ ret(lr);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -7415,16 +7323,0 @@\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Since we need to preserve callee-saved values (currently\n-  \/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-  \/\/ map and therefore have to make these stubs into RuntimeStubs\n-  \/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-  \/\/ be preserved between the fault point and the exception handler\n-  \/\/ then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n@@ -7434,90 +7326,0 @@\n-  address generate_throw_exception(const char* name,\n-                                   address runtime_entry,\n-                                   Register arg1 = noreg,\n-                                   Register arg2 = noreg) {\n-    \/\/ Information about frame layout at time of blocking runtime call.\n-    \/\/ Note that we only have to preserve callee-saved registers since\n-    \/\/ the compilers are responsible for supplying a continuation point\n-    \/\/ if they expect all registers to be preserved.\n-    \/\/ n.b. aarch64 asserts that frame::arg_reg_save_area_bytes == 0\n-    enum layout {\n-      rfp_off = 0,\n-      rfp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 512;\n-    int locs_size  = 64;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-\n-    __ enter(); \/\/ Save FP and LR before call\n-\n-    assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n-\n-    \/\/ lr and fp are already in place\n-    __ sub(sp, rfp, ((uint64_t)framesize-4) << LogBytesPerInt); \/\/ prolog\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    address the_pc = __ pc();\n-    __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n-\n-    \/\/ Call runtime\n-    if (arg1 != noreg) {\n-      assert(arg2 != c_rarg1, \"clobbered\");\n-      __ mov(c_rarg1, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mov(c_rarg2, arg2);\n-    }\n-    __ mov(c_rarg0, rthread);\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ mov(rscratch1, runtime_entry);\n-    __ blr(rscratch1);\n-\n-    \/\/ Generate oop map\n-    OopMap* map = new OopMap(framesize, 0);\n-\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    __ reset_last_Java_frame(true);\n-\n-    \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n-    \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n-    __ reinitialize_ptrue();\n-\n-    __ leave();\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));\n-    __ cbnz(rscratch1, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/\/ ASSERT\n-    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-    \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name,\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub->entry_point();\n-  }\n-\n@@ -8366,10 +8168,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_StackOverflowError));\n-    StubRoutines::_throw_delayed_StackOverflowError_entry =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_delayed_StackOverflowError));\n-\n@@ -8411,10 +8203,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n-  }\n-\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -8422,1 +8204,0 @@\n-#endif \/\/ INCLUDE_JFR\n@@ -8429,17 +8210,0 @@\n-    StubRoutines::_throw_AbstractMethodError_entry =\n-      generate_throw_exception(\"AbstractMethodError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_AbstractMethodError));\n-\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry =\n-      generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_IncompatibleClassChangeError));\n-\n-    StubRoutines::_throw_NullPointerException_at_call_entry =\n-      generate_throw_exception(\"NullPointerException at call throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_NullPointerException_at_call));\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":237,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -755,2 +755,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2194,1 +2194,1 @@\n-    __ ldrw(r3, Address(r3, Klass::access_flags_offset()));\n+    __ ldrb(r3, Address(r3, Klass::misc_flags_offset()));\n@@ -2196,1 +2196,1 @@\n-    __ tbz(r3, exact_log2(JVM_ACC_HAS_FINALIZER), skip_register_finalizer);\n+    __ tbz(r3, exact_log2(KlassFlags::_misc_has_finalizer), skip_register_finalizer);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"register_aarch64.hpp\"\n@@ -47,0 +48,1 @@\n+int VM_Version::_max_supported_sve_vector_length;\n@@ -510,2 +512,3 @@\n-    } else if (MaxVectorSize < 16) {\n-      warning(\"SVE does not support vector length less than 16 bytes. Disabling SVE.\");\n+    } else if (MaxVectorSize < FloatRegister::sve_vl_min) {\n+      warning(\"SVE does not support vector length less than %d bytes. Disabling SVE.\",\n+              FloatRegister::sve_vl_min);\n@@ -513,14 +516,1 @@\n-    } else if ((MaxVectorSize % 16) == 0 && is_power_of_2(MaxVectorSize)) {\n-      int new_vl = set_and_get_current_sve_vector_length(MaxVectorSize);\n-      _initial_sve_vector_length = new_vl;\n-      \/\/ Update MaxVectorSize to the largest supported value.\n-      if (new_vl < 0) {\n-        vm_exit_during_initialization(\n-          err_msg(\"Current system does not support SVE vector length for MaxVectorSize: %d\",\n-                  (int)MaxVectorSize));\n-      } else if (new_vl != MaxVectorSize) {\n-        warning(\"Current system only supports max SVE vector length %d. Set MaxVectorSize to %d\",\n-                new_vl, new_vl);\n-      }\n-      MaxVectorSize = new_vl;\n-    } else {\n+    } else if (!((MaxVectorSize % FloatRegister::sve_vl_min) == 0 && is_power_of_2(MaxVectorSize))) {\n@@ -529,0 +519,19 @@\n+\n+    if (UseSVE > 0) {\n+      \/\/ Acquire the largest supported vector length of this machine\n+      _max_supported_sve_vector_length = set_and_get_current_sve_vector_length(FloatRegister::sve_vl_max);\n+\n+      if (MaxVectorSize != _max_supported_sve_vector_length) {\n+        int new_vl = set_and_get_current_sve_vector_length(MaxVectorSize);\n+        if (new_vl < 0) {\n+          vm_exit_during_initialization(\n+            err_msg(\"Current system does not support SVE vector length for MaxVectorSize: %d\",\n+                    (int)MaxVectorSize));\n+        } else if (new_vl != MaxVectorSize) {\n+          warning(\"Current system only supports max SVE vector length %d. Set MaxVectorSize to %d\",\n+                  new_vl, new_vl);\n+        }\n+        MaxVectorSize = new_vl;\n+      }\n+      _initial_sve_vector_length = MaxVectorSize;\n+    }\n@@ -533,1 +542,1 @@\n-    int max_vector_size = 16;\n+    int max_vector_size = FloatRegister::neon_vl;\n@@ -545,1 +554,1 @@\n-      FLAG_SET_DEFAULT(MaxVectorSize, 16);\n+      FLAG_SET_DEFAULT(MaxVectorSize, FloatRegister::neon_vl);\n@@ -549,1 +558,1 @@\n-  int inline_size = (UseSVE > 0 && MaxVectorSize >= 16) ? MaxVectorSize : 0;\n+  int inline_size = (UseSVE > 0 && MaxVectorSize >= FloatRegister::sve_vl_min) ? MaxVectorSize : 0;\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":28,"deletions":19,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  static int _max_supported_sve_vector_length;\n@@ -167,1 +168,2 @@\n-  static int get_initial_sve_vector_length()  { return _initial_sve_vector_length; };\n+  static int get_initial_sve_vector_length()        { return _initial_sve_vector_length; };\n+  static int get_max_supported_sve_vector_length()  { return _max_supported_sve_vector_length; };\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -198,2 +198,2 @@\n-    ldr_u32(tmp2, Address(tmp2, Klass::access_flags_offset()));\n-    tst(tmp2, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    ldrb(tmp2, Address(tmp2, Klass::misc_flags_offset()));\n+    tst(tmp2, KlassFlags::_misc_is_value_based_class);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -507,1 +507,1 @@\n-        \/\/ Do not call runtime if JVM_ACC_HAS_FINALIZER flag is not set\n+        \/\/ Do not call runtime if has_finalizer flag is not set\n@@ -509,1 +509,1 @@\n-        __ ldr_u32(Rtemp, Address(Rtemp, Klass::access_flags_offset()));\n+        __ ldrb(Rtemp, Address(Rtemp, Klass::misc_flags_offset()));\n@@ -511,1 +511,1 @@\n-        __ tst(Rtemp, JVM_ACC_HAS_FINALIZER);\n+        __ tst(Rtemp, KlassFlags::_misc_has_finalizer);\n","filename":"src\/hotspot\/cpu\/arm\/c1_Runtime1_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,2 +89,2 @@\n-    ldr_u32(Rscratch, Address(Rscratch, Klass::access_flags_offset()));\n-    tst(Rscratch, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    ldrb(Rscratch, Address(Rscratch, Klass::misc_flags_offset()));\n+    tst(Rscratch, KlassFlags::_misc_is_value_based_class);\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -912,2 +912,2 @@\n-      ldr_u32(R0, Address(R0, Klass::access_flags_offset()));\n-      tst(R0, JVM_ACC_IS_VALUE_BASED_CLASS);\n+      ldrb(R0, Address(R0, Klass::misc_flags_offset()));\n+      tst(R0, KlassFlags::_misc_is_value_based_class);\n@@ -988,9 +988,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Pass oop, not lock, in fast lock case. call_VM wants R1 though.\n-      push(R1);\n-      mov(R1, Robj);\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj), R1);\n-      pop(R1);\n-    } else {\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), Rlock);\n-    }\n+    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), Rlock);\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -143,1 +144,1 @@\n-  __ jump(StubRoutines::throw_AbstractMethodError_entry(), relocInfo::runtime_call_type, Rtemp);\n+  __ jump(SharedRuntime::throw_AbstractMethodError_entry(), relocInfo::runtime_call_type, Rtemp);\n@@ -464,1 +465,1 @@\n-      __ jump(StubRoutines::throw_IncompatibleClassChangeError_entry(), relocInfo::runtime_call_type, Rtemp);\n+      __ jump(SharedRuntime::throw_IncompatibleClassChangeError_entry(), relocInfo::runtime_call_type, Rtemp);\n","filename":"src\/hotspot\/cpu\/arm\/methodHandles_arm.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1363,1 +1363,2 @@\n-  CodeBuffer buffer(\"deopt_blob\", 1024, 1024);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  CodeBuffer buffer(name, 1024, 1024);\n@@ -1604,1 +1605,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n@@ -1606,0 +1607,1 @@\n+  assert(is_polling_page_id(id), \"expected a polling page stub id\");\n@@ -1608,1 +1610,2 @@\n-  CodeBuffer buffer(\"handler_blob\", 256, 256);\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBuffer buffer(name, 256, 256);\n@@ -1612,1 +1615,1 @@\n-  bool cause_return = (poll_type == POLL_AT_RETURN);\n+  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n@@ -1674,1 +1677,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n@@ -1676,0 +1679,1 @@\n+  assert(is_resolve_id(id), \"expected a resolve stub id\");\n@@ -1678,0 +1682,1 @@\n+  const char* name = SharedRuntime::stub_name(id);\n@@ -1731,0 +1736,146 @@\n+\n+\/\/------------------------------------------------------------------------------------------------------------------------\n+\/\/ Continuation point for throwing of implicit exceptions that are not handled in\n+\/\/ the current activation. Fabricates an exception oop and initiates normal\n+\/\/ exception dispatching in this frame.\n+RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+  assert(is_throw_id(id), \"expected a throw stub id\");\n+\n+  const char* name = SharedRuntime::stub_name(id);\n+\n+  int insts_size = 128;\n+  int locs_size  = 32;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps;\n+  int frame_size;\n+  int frame_complete;\n+\n+  oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  frame_size = 2;\n+  __ mov(Rexception_pc, LR);\n+  __ raw_push(FP, LR);\n+\n+  frame_complete = __ pc() - start;\n+\n+  \/\/ Any extra arguments are already supposed to be R1 and R2\n+  __ mov(R0, Rthread);\n+\n+  int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp);\n+  assert(((__ pc()) - start) == __ offset(), \"warning: start differs from code_begin\");\n+  __ call(runtime_entry);\n+  if (pc_offset == -1) {\n+    pc_offset = __ offset();\n+  }\n+\n+  \/\/ Generate oop map\n+  OopMap* map =  new OopMap(frame_size*VMRegImpl::slots_per_word, 0);\n+  oop_maps->add_gc_map(pc_offset, map);\n+  __ reset_last_Java_frame(Rtemp); \/\/ Rtemp free since scratched by far call\n+\n+  __ raw_pop(FP, LR);\n+  __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);\n+\n+  RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                                    frame_size, oop_maps, false);\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    r1_off,\n+    r2_off,\n+    return_off,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  CodeBuffer code(name, 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ raw_push(R1, R2, LR);\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(SP, FP, true, Rtemp);\n+  __ mov(c_rarg0, Rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), c_rarg0);\n+  __ reset_last_Java_frame(Rtemp);\n+\n+  \/\/ R0 is jobject handle result, unpack and process it through a barrier.\n+  __ resolve_global_jobject(R0, Rtemp, R1);\n+\n+  __ raw_pop(R1, R2, LR);\n+  __ ret();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    r1_off,\n+    r2_off,\n+    return_off,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  CodeBuffer code(name, 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ raw_push(R1, R2, LR);\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(SP, FP, true, Rtemp);\n+  __ mov(c_rarg0, Rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), c_rarg0);\n+  __ reset_last_Java_frame(Rtemp);\n+\n+  __ raw_pop(R1, R2, LR);\n+  __ ret();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":156,"deletions":5,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -2964,46 +2964,0 @@\n-  \/\/------------------------------------------------------------------------------------------------------------------------\n-  \/\/ Continuation point for throwing of implicit exceptions that are not handled in\n-  \/\/ the current activation. Fabricates an exception oop and initiates normal\n-  \/\/ exception dispatching in this frame.\n-  address generate_throw_exception(const char* name, address runtime_entry) {\n-    int insts_size = 128;\n-    int locs_size  = 32;\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps;\n-    int frame_size;\n-    int frame_complete;\n-\n-    oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-\n-    frame_size = 2;\n-    __ mov(Rexception_pc, LR);\n-    __ raw_push(FP, LR);\n-\n-    frame_complete = __ pc() - start;\n-\n-    \/\/ Any extra arguments are already supposed to be R1 and R2\n-    __ mov(R0, Rthread);\n-\n-    int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp);\n-    assert(((__ pc()) - start) == __ offset(), \"warning: start differs from code_begin\");\n-    __ call(runtime_entry);\n-    if (pc_offset == -1) {\n-      pc_offset = __ offset();\n-    }\n-\n-    \/\/ Generate oop map\n-    OopMap* map =  new OopMap(frame_size*VMRegImpl::slots_per_word, 0);\n-    oop_maps->add_gc_map(pc_offset, map);\n-    __ reset_last_Java_frame(Rtemp); \/\/ Rtemp free since scratched by far call\n-\n-    __ raw_pop(FP, LR);\n-    __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);\n-\n-    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n-                                                      frame_size, oop_maps, false);\n-    return stub->entry_point();\n-  }\n-\n@@ -3028,89 +2982,0 @@\n-#if INCLUDE_JFR\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      r1_off,\n-      r2_off,\n-      return_off,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-    __ raw_push(R1, R2, LR);\n-    address the_pc = __ pc();\n-\n-    int frame_complete = the_pc - start;\n-\n-    __ set_last_Java_frame(SP, FP, true, Rtemp);\n-    __ mov(c_rarg0, Rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), c_rarg0);\n-    __ reset_last_Java_frame(Rtemp);\n-\n-    \/\/ R0 is jobject handle result, unpack and process it through a barrier.\n-    __ resolve_global_jobject(R0, Rtemp, R1);\n-\n-    __ raw_pop(R1, R2, LR);\n-    __ ret();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(frame_complete, map);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps,\n-                                    false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      r1_off,\n-      r2_off,\n-      return_off,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    CodeBuffer code(\"jfr_return_lease\", 512, 64);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-    __ raw_push(R1, R2, LR);\n-    address the_pc = __ pc();\n-\n-    int frame_complete = the_pc - start;\n-\n-    __ set_last_Java_frame(SP, FP, true, Rtemp);\n-    __ mov(c_rarg0, Rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), c_rarg0);\n-    __ reset_last_Java_frame(Rtemp);\n-\n-    __ raw_pop(R1, R2, LR);\n-    __ ret();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(frame_complete, map);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps,\n-                                    false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -3135,2 +3000,0 @@\n-    StubRoutines::_throw_StackOverflowError_entry  = generate_throw_exception(\"StackOverflowError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));\n-\n@@ -3158,2 +3021,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n@@ -3162,9 +3023,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-  }\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -3174,6 +3026,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in non-core builds\n-    \/\/ and need to be relocatable, so they each fabricate a RuntimeStub internally.\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));\n-\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":0,"deletions":154,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -563,1 +563,1 @@\n-  __ b(StubRoutines::throw_StackOverflowError_entry(), ls);\n+  __ b(SharedRuntime::throw_StackOverflowError_entry(), ls);\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2497,2 +2497,2 @@\n-    __ ldr_u32(Rtemp, Address(Rtemp, Klass::access_flags_offset()));\n-    __ tbz(Rtemp, exact_log2(JVM_ACC_HAS_FINALIZER), skip_register_finalizer);\n+    __ ldrb(Rtemp, Address(Rtemp, Klass::misc_flags_offset()));\n+    __ tbz(Rtemp, exact_log2(KlassFlags::_misc_has_finalizer), skip_register_finalizer);\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -295,1 +295,1 @@\n-void Assembler::add(Register d, RegisterOrConstant roc, Register s1) {\n+void Assembler::add(Register d, Register s, RegisterOrConstant roc) {\n@@ -299,1 +299,3 @@\n-    addi(d, s1, (int)c);\n+    addi(d, s, (int)c);\n+  } else {\n+    add(d, s, roc.as_register());\n@@ -301,1 +303,0 @@\n-  else add(d, roc.as_register(), s1);\n@@ -304,1 +305,1 @@\n-void Assembler::subf(Register d, RegisterOrConstant roc, Register s1) {\n+void Assembler::sub(Register d, Register s, RegisterOrConstant roc) {\n@@ -308,1 +309,13 @@\n-    addi(d, s1, (int)-c);\n+    addi(d, s, (int)-c);\n+  } else {\n+    sub(d, s, roc.as_register());\n+  }\n+}\n+\n+void Assembler::xorr(Register d, Register s, RegisterOrConstant roc) {\n+  if (roc.is_constant()) {\n+    intptr_t c = roc.as_constant();\n+    assert(is_uimm(c, 16), \"too big\");\n+    xori(d, s, (int)c);\n+  } else {\n+    xorr(d, s, roc.as_register());\n@@ -310,1 +323,0 @@\n-  else subf(d, roc.as_register(), s1);\n@@ -313,1 +325,1 @@\n-void Assembler::cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1) {\n+void Assembler::cmpw(ConditionRegister d, Register s, RegisterOrConstant roc) {\n@@ -317,1 +329,13 @@\n-    cmpdi(d, s1, (int)c);\n+    cmpwi(d, s, (int)c);\n+  } else {\n+    cmpw(d, s, roc.as_register());\n+  }\n+}\n+\n+void Assembler::cmpd(ConditionRegister d, Register s, RegisterOrConstant roc) {\n+  if (roc.is_constant()) {\n+    intptr_t c = roc.as_constant();\n+    assert(is_simm(c, 16), \"too big\");\n+    cmpdi(d, s, (int)c);\n+  } else {\n+    cmpd(d, s, roc.as_register());\n@@ -319,1 +343,0 @@\n-  else cmpd(d, roc.as_register(), s1);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.cpp","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2515,3 +2515,7 @@\n-  void add( Register d, RegisterOrConstant roc, Register s1);\n-  void subf(Register d, RegisterOrConstant roc, Register s1);\n-  void cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1);\n+  void add( Register d, Register s, RegisterOrConstant roc);\n+  void add( Register d, RegisterOrConstant roc, Register s) { add(d, s, roc); }\n+  void sub( Register d, Register s, RegisterOrConstant roc);\n+  void xorr(Register d, Register s, RegisterOrConstant roc);\n+  void xorr(Register d, RegisterOrConstant roc, Register s) { xorr(d, s, roc); }\n+  void cmpw(ConditionRegister d, Register s, RegisterOrConstant roc);\n+  void cmpd(ConditionRegister d, Register s, RegisterOrConstant roc);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1862,1 +1862,1 @@\n-    __ call_c_with_frame_resize(copyfunc_addr, \/*stub does not need resized frame*\/ 0);\n+    __ call_c(copyfunc_addr, relocInfo::runtime_call_type);\n@@ -2060,1 +2060,1 @@\n-        __ call_c_with_frame_resize(copyfunc_addr, \/*stub does not need resized frame*\/ 0);\n+        __ call_c(copyfunc_addr, relocInfo::runtime_call_type);\n@@ -2184,1 +2184,1 @@\n-  __ call_c_with_frame_resize(entry, \/*stub does not need resized frame*\/ 0);\n+  __ call_c(entry, relocInfo::runtime_call_type);\n@@ -2623,1 +2623,1 @@\n-                noreg, \/*check without ldarx first*\/true);\n+                noreg, nullptr, \/*check without ldarx first*\/true);\n@@ -2865,1 +2865,1 @@\n-  __ call_c_with_frame_resize(dest, \/*no resizing*\/ 0);\n+  __ call_c(dest, relocInfo::runtime_call_type);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-    lwz(Rscratch, in_bytes(Klass::access_flags_offset()), Rscratch);\n-    testbitdi(CCR0, R0, Rscratch, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    lbz(Rscratch, in_bytes(Klass::misc_flags_offset()), Rscratch);\n+    testbitdi(CCR0, R0, Rscratch, exact_log2(KlassFlags::_misc_is_value_based_class));\n@@ -407,11 +407,0 @@\n-\n-address C1_MacroAssembler::call_c_with_frame_resize(address dest, int frame_resize) {\n-  if (frame_resize) { resize_frame(-frame_resize, R0); }\n-#if defined(ABI_ELFv2)\n-  address return_pc = call_c(dest, relocInfo::runtime_call_type);\n-#else\n-  address return_pc = call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, dest), relocInfo::runtime_call_type);\n-#endif\n-  if (frame_resize) { resize_frame(frame_resize, R0); }\n-  return return_pc;\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-  address call_c_with_frame_resize(address dest, int frame_resize);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-  address return_pc = call_c_with_frame_resize(entry_point, \/*No resize, we have a C compatible frame.*\/0);\n+  address return_pc = call_c(entry_point);\n@@ -482,2 +482,2 @@\n-        __ lwz(t, in_bytes(Klass::access_flags_offset()), t);\n-        __ testbitdi(CCR0, R0, t, exact_log2(JVM_ACC_HAS_FINALIZER));\n+        __ lbz(t, in_bytes(Klass::misc_flags_offset()), t);\n+        __ testbitdi(CCR0, R0, t, exact_log2(KlassFlags::_misc_has_finalizer));\n","filename":"src\/hotspot\/cpu\/ppc\/c1_Runtime1_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -706,1 +706,1 @@\n-                false, success_flag, true);\n+                false, success_flag, nullptr, true);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -338,1 +338,1 @@\n-      __ add(ref_base, ind_or_offs, ref_base);\n+      __ add(ref_base, ref_base, ind_or_offs);\n@@ -346,1 +346,1 @@\n-      __ subf(ref_base, ind_or_offs, ref_base);\n+      __ sub(ref_base, ref_base, ind_or_offs);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,9 +138,1 @@\n-#if defined(ABI_ELFv2)\n-    call_c(CAST_FROM_FN_PTR(address,\n-                            Interpreter::remove_activation_preserving_args_entry),\n-           relocInfo::none);\n-#else\n-    call_c(CAST_FROM_FN_PTR(FunctionDescriptor*,\n-                            Interpreter::remove_activation_preserving_args_entry),\n-           relocInfo::none);\n-#endif\n+    call_c(CAST_FROM_FN_PTR(address, Interpreter::remove_activation_preserving_args_entry));\n@@ -973,2 +965,2 @@\n-      lwz(tmp, in_bytes(Klass::access_flags_offset()), tmp);\n-      testbitdi(CCR0, R0, tmp, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+      lbz(tmp, in_bytes(Klass::misc_flags_offset()), tmp);\n+      testbitdi(CCR0, R0, tmp, exact_log2(KlassFlags::_misc_is_value_based_class));\n@@ -1046,5 +1038,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj), object);\n-    } else {\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-    }\n+    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1296,1 +1296,0 @@\n-#if defined(ABI_ELFv2)\n@@ -1298,3 +1297,0 @@\n-#else\n-  address return_pc = call_c((FunctionDescriptor*)entry_point, relocInfo::none);\n-#endif\n@@ -1321,5 +1317,1 @@\n-#if defined(ABI_ELFv2)\n-  call_c(entry_point, relocInfo::none);\n-#else\n-  call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, entry_point), relocInfo::none);\n-#endif\n+  call_c(entry_point);\n@@ -1504,1 +1496,1 @@\n-  load_const_optimized(R0, StubRoutines::throw_delayed_StackOverflowError_entry());\n+  load_const_optimized(R0, SharedRuntime::throw_delayed_StackOverflowError_entry());\n@@ -1623,1 +1615,1 @@\n-                                       Register compare_value, Register exchange_value,\n+                                       RegisterOrConstant compare_value, Register exchange_value,\n@@ -1637,1 +1629,1 @@\n-    assert_different_registers(tmp1, tmp2, dest_current_value, compare_value, exchange_value, addr_base);\n+    assert_different_registers(tmp1, tmp2, dest_current_value, compare_value.register_or_noreg(), exchange_value, addr_base);\n@@ -1698,1 +1690,1 @@\n-                                     Register compare_value, Register exchange_value,\n+                                     RegisterOrConstant compare_value, Register exchange_value,\n@@ -1700,2 +1692,2 @@\n-                                     int semantics, bool cmpxchgx_hint,\n-                                     Register int_flag_success, bool contention_hint, bool weak, int size) {\n+                                     int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                                     Label* failed_ext, bool contention_hint, bool weak, int size) {\n@@ -1703,1 +1695,2 @@\n-  Label failed;\n+  Label failed_int;\n+  Label& failed = (failed_ext != nullptr) ? *failed_ext : failed_int;\n@@ -1709,1 +1702,1 @@\n-  bool preset_result_reg = (int_flag_success != dest_current_value && int_flag_success != compare_value &&\n+  bool preset_result_reg = (int_flag_success != dest_current_value && int_flag_success != compare_value.register_or_noreg() &&\n@@ -1713,0 +1706,1 @@\n+  assert(int_flag_success == noreg || failed_ext == nullptr, \"cannot have both\");\n@@ -1738,1 +1732,1 @@\n-  if (!weak || use_result_reg) {\n+  if (!weak || use_result_reg || failed_ext) {\n@@ -1763,1 +1757,1 @@\n-  bind(failed);\n+  bind(failed_int);\n@@ -1790,4 +1784,5 @@\n-void MacroAssembler::cmpxchgd(ConditionRegister flag,\n-                              Register dest_current_value, RegisterOrConstant compare_value, Register exchange_value,\n-                              Register addr_base, int semantics, bool cmpxchgx_hint,\n-                              Register int_flag_success, Label* failed_ext, bool contention_hint, bool weak) {\n+void MacroAssembler::cmpxchgd(ConditionRegister flag, Register dest_current_value,\n+                              RegisterOrConstant compare_value, Register exchange_value,\n+                              Register addr_base,\n+                              int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                              Label* failed_ext, bool contention_hint, bool weak) {\n@@ -1813,1 +1808,1 @@\n-    cmpd(flag, compare_value, dest_current_value);\n+    cmpd(flag, dest_current_value, compare_value);\n@@ -1826,1 +1821,1 @@\n-  cmpd(flag, compare_value, dest_current_value);\n+  cmpd(flag, dest_current_value, compare_value);\n@@ -2173,1 +2168,0 @@\n-\/\/ Return true: we succeeded in generating this code\n@@ -2295,3 +2289,2 @@\n-  assert(Klass::SECONDARY_SUPERS_BITMAP_FULL == ~uintx(0), \"\");\n-  cmpdi(CCR0, r_bitmap, -1);\n-  beq(CCR0, L_huge);\n+  cmpwi(CCR0, r_array_length, (int32_t)Klass::SECONDARY_SUPERS_TABLE_SIZE - 2);\n+  bgt(CCR0, L_huge);\n@@ -2563,2 +2556,2 @@\n-    lwz(temp, in_bytes(Klass::access_flags_offset()), temp);\n-    testbitdi(flag, R0, temp, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    lbz(temp, in_bytes(Klass::misc_flags_offset()), temp);\n+    testbitdi(flag, R0, temp, exact_log2(KlassFlags::_misc_is_value_based_class));\n@@ -2754,2 +2747,2 @@\n-    lwz(tmp1, in_bytes(Klass::access_flags_offset()), tmp1);\n-    testbitdi(flag, R0, tmp1, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    lbz(tmp1, in_bytes(Klass::misc_flags_offset()), tmp1);\n+    testbitdi(flag, R0, tmp1, exact_log2(KlassFlags::_misc_is_value_based_class));\n@@ -2807,26 +2800,33 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tagged_monitor = mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-    const Register owner_addr = tmp2;\n-\n-    \/\/ Compute owner address.\n-    addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n-\n-    \/\/ CAS owner (null => current thread).\n-    cmpxchgd(\/*flag=*\/flag,\n-            \/*current_value=*\/t,\n-            \/*compare_value=*\/(intptr_t)0,\n-            \/*exchange_value=*\/R16_thread,\n-            \/*where=*\/owner_addr,\n-            MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-            MacroAssembler::cmpxchgx_hint_acquire_lock());\n-    beq(flag, locked);\n-\n-    \/\/ Check if recursive.\n-    cmpd(flag, t, R16_thread);\n-    bne(flag, slow_path);\n-\n-    \/\/ Recursive.\n-    ld(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n-    addi(tmp1, tmp1, 1);\n-    std(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register tagged_monitor = mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+      const Register owner_addr = tmp2;\n+\n+      \/\/ Compute owner address.\n+      addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n+\n+      \/\/ CAS owner (null => current thread).\n+      cmpxchgd(\/*flag=*\/flag,\n+              \/*current_value=*\/t,\n+              \/*compare_value=*\/(intptr_t)0,\n+              \/*exchange_value=*\/R16_thread,\n+              \/*where=*\/owner_addr,\n+              MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n+              MacroAssembler::cmpxchgx_hint_acquire_lock());\n+      beq(flag, locked);\n+\n+      \/\/ Check if recursive.\n+      cmpd(flag, t, R16_thread);\n+      bne(flag, slow_path);\n+\n+      \/\/ Recursive.\n+      ld(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+      addi(tmp1, tmp1, 1);\n+      std(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      crxor(flag, Assembler::equal, flag, Assembler::equal);\n+      b(slow_path);\n+    }\n@@ -2900,1 +2900,5 @@\n-    bne(CCR0, inflated);\n+    if (!UseObjectMonitorTable) {\n+      bne(CCR0, inflated);\n+    } else {\n+      bne(CCR0, push_and_slow);\n+    }\n@@ -2946,43 +2950,50 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register monitor = mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-\n-    \/\/ Untag the monitor.\n-    subi(monitor, mark, monitor_tag);\n-\n-    const Register recursions = tmp2;\n-    Label not_recursive;\n-\n-    \/\/ Check if recursive.\n-    ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-    addic_(recursions, recursions, -1);\n-    blt(CCR0, not_recursive);\n-\n-    \/\/ Recursive unlock.\n-    std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-    crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n-    b(unlocked);\n-\n-    bind(not_recursive);\n-\n-    Label release_;\n-    const Register t2 = tmp2;\n-\n-    \/\/ Check if the entry lists are empty.\n-    ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n-    ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n-    orr(t, t, t2);\n-    cmpdi(flag, t, 0);\n-    beq(flag, release_);\n-\n-    \/\/ The owner may be anonymous and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n-    b(slow_path);\n-\n-    bind(release_);\n-    \/\/ Set owner to null.\n-    release();\n-    \/\/ t contains 0\n-    std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register monitor = mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+\n+      \/\/ Untag the monitor.\n+      subi(monitor, mark, monitor_tag);\n+\n+      const Register recursions = tmp2;\n+      Label not_recursive;\n+\n+      \/\/ Check if recursive.\n+      ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+      addic_(recursions, recursions, -1);\n+      blt(CCR0, not_recursive);\n+\n+      \/\/ Recursive unlock.\n+      std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+      crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n+      b(unlocked);\n+\n+      bind(not_recursive);\n+\n+      Label release_;\n+      const Register t2 = tmp2;\n+\n+      \/\/ Check if the entry lists are empty.\n+      ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n+      ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n+      orr(t, t, t2);\n+      cmpdi(flag, t, 0);\n+      beq(flag, release_);\n+\n+      \/\/ The owner may be anonymous and we removed the last obj entry in\n+      \/\/ the lock-stack. This loses the information about the owner.\n+      \/\/ Write the thread to the owner field so the runtime knows the owner.\n+      std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+      b(slow_path);\n+\n+      bind(release_);\n+      \/\/ Set owner to null.\n+      release();\n+      \/\/ t contains 0\n+      std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      crxor(flag, Assembler::equal, flag, Assembler::equal);\n+      b(slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":114,"deletions":103,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -362,1 +362,1 @@\n-  address call_c(address function_entry, relocInfo::relocType rt);\n+  address call_c(address function_entry, relocInfo::relocType rt = relocInfo::none);\n@@ -370,0 +370,3 @@\n+  address call_c(address function_entry, relocInfo::relocType rt = relocInfo::none) {\n+    return call_c((const FunctionDescriptor*)function_entry, rt);\n+  }\n@@ -485,1 +488,1 @@\n-                         Register compare_value, Register exchange_value,\n+                         RegisterOrConstant compare_value, Register exchange_value,\n@@ -488,4 +491,5 @@\n-  void cmpxchg_generic(ConditionRegister flag,\n-                       Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                       Register tmp1, Register tmp2,\n-                       int semantics, bool cmpxchgx_hint, Register int_flag_success, bool contention_hint, bool weak, int size);\n+  void cmpxchg_generic(ConditionRegister flag, Register dest_current_value,\n+                       RegisterOrConstant compare_value, Register exchange_value,\n+                       Register addr_base, Register tmp1, Register tmp2,\n+                       int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                       Label* failed_ext, bool contention_hint, bool weak, int size);\n@@ -531,4 +535,5 @@\n-  void cmpxchgb(ConditionRegister flag,\n-                Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                Register tmp1, Register tmp2, int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, bool contention_hint = false, bool weak = false) {\n+  void cmpxchgb(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base, Register tmp1, Register tmp2,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n@@ -536,1 +541,1 @@\n-                    semantics, cmpxchgx_hint, int_flag_success, contention_hint, weak, 1);\n+                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 1);\n@@ -540,4 +545,5 @@\n-  void cmpxchgh(ConditionRegister flag,\n-                Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                Register tmp1, Register tmp2, int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, bool contention_hint = false, bool weak = false) {\n+  void cmpxchgh(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base, Register tmp1, Register tmp2,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n@@ -545,1 +551,1 @@\n-                    semantics, cmpxchgx_hint, int_flag_success, contention_hint, weak, 2);\n+                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 2);\n@@ -547,4 +553,5 @@\n-  void cmpxchgw(ConditionRegister flag,\n-                Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, bool contention_hint = false, bool weak = false) {\n+  void cmpxchgw(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n@@ -552,1 +559,1 @@\n-                    semantics, cmpxchgx_hint, int_flag_success, contention_hint, weak, 4);\n+                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 4);\n@@ -554,4 +561,5 @@\n-  void cmpxchgd(ConditionRegister flag,\n-                Register dest_current_value, RegisterOrConstant compare_value, Register exchange_value,\n-                Register addr_base, int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, Label* failed = nullptr, bool contention_hint = false, bool weak = false);\n+  void cmpxchgd(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":33,"deletions":25,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -161,2 +161,2 @@\n-  assert(StubRoutines::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n-  __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());\n+  assert(SharedRuntime::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n+  __ load_const_optimized(target, SharedRuntime::throw_AbstractMethodError_entry());\n@@ -492,1 +492,1 @@\n-      __ load_const_optimized(temp1, StubRoutines::throw_IncompatibleClassChangeError_entry());\n+      __ load_const_optimized(temp1, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n","filename":"src\/hotspot\/cpu\/ppc\/methodHandles_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7393,1 +7393,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7412,1 +7412,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7431,1 +7431,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7450,1 +7450,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7468,1 +7468,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7486,1 +7486,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7544,1 +7544,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7558,1 +7558,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7572,1 +7572,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7586,1 +7586,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7600,1 +7600,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7614,1 +7614,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7628,1 +7628,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7642,1 +7642,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7656,1 +7656,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7672,1 +7672,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7686,1 +7686,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7702,1 +7702,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7779,1 +7779,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7793,1 +7793,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7807,1 +7807,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7827,1 +7827,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7847,1 +7847,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7861,1 +7861,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7875,1 +7875,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7895,1 +7895,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7915,1 +7915,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7929,1 +7929,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7949,1 +7949,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7963,1 +7963,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -102,6 +102,1 @@\n-#if defined(ABI_ELFv2)\n-  __ call_c((address) OptoRuntime::handle_exception_C, relocInfo::none);\n-#else\n-  __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, OptoRuntime::handle_exception_C),\n-            relocInfo::none);\n-#endif\n+  __ call_c((address) OptoRuntime::handle_exception_C);\n","filename":"src\/hotspot\/cpu\/ppc\/runtime_ppc.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -2446,1 +2447,0 @@\n-#if defined(ABI_ELFv2)\n@@ -2448,4 +2448,0 @@\n-#else\n-  FunctionDescriptor* fd_native_method = (FunctionDescriptor*) native_func;\n-  __ call_c(fd_native_method, relocInfo::runtime_call_type);\n-#endif\n@@ -2863,1 +2859,2 @@\n-  CodeBuffer buffer(\"deopt_blob\", 2048, 1024);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  CodeBuffer buffer(name, 2048, 1024);\n@@ -3213,1 +3210,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n@@ -3216,0 +3213,1 @@\n+  assert(is_polling_page_id(id), \"expected a polling page stub id\");\n@@ -3222,1 +3220,2 @@\n-  CodeBuffer buffer(\"handler_blob\", 2048, 1024);\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBuffer buffer(name, 2048, 1024);\n@@ -3229,1 +3228,1 @@\n-  bool cause_return = (poll_type == POLL_AT_RETURN);\n+  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n@@ -3239,1 +3238,1 @@\n-  bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);\n+  bool save_vectors = (id == SharedStubId::polling_page_vectors_safepoint_handler_id);\n@@ -3326,1 +3325,2 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+  assert(is_resolve_id(id), \"expected a resolve stub id\");\n@@ -3331,0 +3331,1 @@\n+  const char* name = SharedRuntime::stub_name(id);\n@@ -3407,0 +3408,94 @@\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Only callee-saved registers are preserved (through the\n+\/\/ normal register window \/ RegisterMap handling).  If the compiler\n+\/\/ needs all registers to be preserved between the fault point and\n+\/\/ the exception handler then it must assume responsibility for that\n+\/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\/\/\n+\/\/ Note that we generate only this stub into a RuntimeStub, because\n+\/\/ it needs to be properly traversed and ignored during GC, so we\n+\/\/ change the meaning of the \"__\" macro within this method.\n+\/\/\n+\/\/ Note: the routine set_pc_not_at_call_for_caller in\n+\/\/ SharedRuntime.cpp requires that this code be generated into a\n+\/\/ RuntimeStub.\n+RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+  assert(is_throw_id(id), \"expected a throw stub id\");\n+\n+  const char* name = SharedRuntime::stub_name(id);\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, 1024 DEBUG_ONLY(+ 512), 0);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  int frame_size_in_bytes = frame::native_abi_reg_args_size;\n+  OopMap* map = new OopMap(frame_size_in_bytes \/ sizeof(jint), 0);\n+\n+  address start = __ pc();\n+\n+  __ save_LR(R11_scratch1);\n+\n+  \/\/ Push a frame.\n+  __ push_frame_reg_args(0, R11_scratch1);\n+\n+  address frame_complete_pc = __ pc();\n+\n+  \/\/ Note that we always have a runtime stub frame on the top of\n+  \/\/ stack by this point. Remember the offset of the instruction\n+  \/\/ whose address will be moved to R11_scratch1.\n+  address gc_map_pc = __ get_PC_trash_LR(R11_scratch1);\n+\n+  __ set_last_Java_frame(\/*sp*\/R1_SP, \/*pc*\/R11_scratch1);\n+\n+  __ mr(R3_ARG1, R16_thread);\n+  __ call_c(runtime_entry);\n+\n+  \/\/ Set an oopmap for the call site.\n+  oop_maps->add_gc_map((int)(gc_map_pc - start), map);\n+\n+  __ reset_last_Java_frame();\n+\n+#ifdef ASSERT\n+  \/\/ Make sure that this code is only executed if there is a pending\n+  \/\/ exception.\n+  {\n+    Label L;\n+    __ ld(R0,\n+          in_bytes(Thread::pending_exception_offset()),\n+          R16_thread);\n+    __ cmpdi(CCR0, R0, 0);\n+    __ bne(CCR0, L);\n+    __ stop(\"SharedRuntime::throw_exception: no pending exception\");\n+    __ bind(L);\n+  }\n+#endif\n+\n+  \/\/ Pop frame.\n+  __ pop_frame();\n+\n+  __ restore_LR(R11_scratch1);\n+\n+  __ load_const(R11_scratch1, StubRoutines::forward_exception_entry());\n+  __ mtctr(R11_scratch1);\n+  __ bctr();\n+\n+  \/\/ Create runtime stub with OopMap.\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name, &code,\n+                                  \/*frame_complete=*\/ (int)(frame_complete_pc - start),\n+                                  frame_size_in_bytes\/wordSize,\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n@@ -3650,0 +3745,78 @@\n+\n+#if INCLUDE_JFR\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  CodeBuffer code(name, 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  Register tmp1 = R10_ARG8;\n+  Register tmp2 = R9_ARG7;\n+\n+  int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n+  address start = __ pc();\n+  __ mflr(tmp1);\n+  __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n+  __ push_frame_reg_args(0, tmp1);\n+  int frame_complete = __ pc() - start;\n+  __ set_last_Java_frame(R1_SP, noreg);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), R16_thread);\n+  address calls_return_pc = __ last_calls_return_pc();\n+  __ reset_last_Java_frame();\n+  \/\/ The handle is dereferenced through a load barrier.\n+  __ resolve_global_jobject(R3_RET, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n+  __ pop_frame();\n+  __ ld(tmp1, _abi0(lr), R1_SP);\n+  __ mtlr(tmp1);\n+  __ blr();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 0);\n+  oop_maps->add_gc_map(calls_return_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  CodeBuffer code(name, 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  Register tmp1 = R10_ARG8;\n+  Register tmp2 = R9_ARG7;\n+\n+  int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n+  address start = __ pc();\n+  __ mflr(tmp1);\n+  __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n+  __ push_frame_reg_args(0, tmp1);\n+  int frame_complete = __ pc() - start;\n+  __ set_last_Java_frame(R1_SP, noreg);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), R16_thread);\n+  address calls_return_pc = __ last_calls_return_pc();\n+  __ reset_last_Java_frame();\n+  __ pop_frame();\n+  __ ld(tmp1, _abi0(lr), R1_SP);\n+  __ mtlr(tmp1);\n+  __ blr();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 0);\n+  oop_maps->add_gc_map(calls_return_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":184,"deletions":11,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -520,103 +520,0 @@\n-#define __ masm->\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Only callee-saved registers are preserved (through the\n-  \/\/ normal register window \/ RegisterMap handling).  If the compiler\n-  \/\/ needs all registers to be preserved between the fault point and\n-  \/\/ the exception handler then it must assume responsibility for that\n-  \/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-  \/\/\n-  \/\/ Note that we generate only this stub into a RuntimeStub, because\n-  \/\/ it needs to be properly traversed and ignored during GC, so we\n-  \/\/ change the meaning of the \"__\" macro within this method.\n-  \/\/\n-  \/\/ Note: the routine set_pc_not_at_call_for_caller in\n-  \/\/ SharedRuntime.cpp requires that this code be generated into a\n-  \/\/ RuntimeStub.\n-  address generate_throw_exception(const char* name, address runtime_entry, bool restore_saved_exception_pc,\n-                                   Register arg1 = noreg, Register arg2 = noreg) {\n-    CodeBuffer code(name, 1024 DEBUG_ONLY(+ 512), 0);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    int frame_size_in_bytes = frame::native_abi_reg_args_size;\n-    OopMap* map = new OopMap(frame_size_in_bytes \/ sizeof(jint), 0);\n-\n-    address start = __ pc();\n-\n-    __ save_LR(R11_scratch1);\n-\n-    \/\/ Push a frame.\n-    __ push_frame_reg_args(0, R11_scratch1);\n-\n-    address frame_complete_pc = __ pc();\n-\n-    if (restore_saved_exception_pc) {\n-      __ unimplemented(\"StubGenerator::throw_exception with restore_saved_exception_pc\");\n-    }\n-\n-    \/\/ Note that we always have a runtime stub frame on the top of\n-    \/\/ stack by this point. Remember the offset of the instruction\n-    \/\/ whose address will be moved to R11_scratch1.\n-    address gc_map_pc = __ get_PC_trash_LR(R11_scratch1);\n-\n-    __ set_last_Java_frame(\/*sp*\/R1_SP, \/*pc*\/R11_scratch1);\n-\n-    __ mr(R3_ARG1, R16_thread);\n-    if (arg1 != noreg) {\n-      __ mr(R4_ARG2, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mr(R5_ARG3, arg2);\n-    }\n-#if defined(ABI_ELFv2)\n-    __ call_c(runtime_entry, relocInfo::none);\n-#else\n-    __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, runtime_entry), relocInfo::none);\n-#endif\n-\n-    \/\/ Set an oopmap for the call site.\n-    oop_maps->add_gc_map((int)(gc_map_pc - start), map);\n-\n-    __ reset_last_Java_frame();\n-\n-#ifdef ASSERT\n-    \/\/ Make sure that this code is only executed if there is a pending\n-    \/\/ exception.\n-    {\n-      Label L;\n-      __ ld(R0,\n-                in_bytes(Thread::pending_exception_offset()),\n-                R16_thread);\n-      __ cmpdi(CCR0, R0, 0);\n-      __ bne(CCR0, L);\n-      __ stop(\"StubRoutines::throw_exception: no pending exception\");\n-      __ bind(L);\n-    }\n-#endif\n-\n-    \/\/ Pop frame.\n-    __ pop_frame();\n-\n-    __ restore_LR(R11_scratch1);\n-\n-    __ load_const(R11_scratch1, StubRoutines::forward_exception_entry());\n-    __ mtctr(R11_scratch1);\n-    __ bctr();\n-\n-    \/\/ Create runtime stub with OopMap.\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name, &code,\n-                                    \/*frame_complete=*\/ (int)(frame_complete_pc - start),\n-                                    frame_size_in_bytes\/wordSize,\n-                                    oop_maps,\n-                                    false);\n-    return stub->entry_point();\n-  }\n-#undef __\n@@ -4619,1 +4516,1 @@\n-    __ load_const_optimized(tmp1, (StubRoutines::throw_StackOverflowError_entry()), R0);\n+    __ load_const_optimized(tmp1, (SharedRuntime::throw_StackOverflowError_entry()), R0);\n@@ -4678,78 +4575,0 @@\n-#if INCLUDE_JFR\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  RuntimeStub* generate_jfr_write_checkpoint() {\n-    CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n-    MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-    Register tmp1 = R10_ARG8;\n-    Register tmp2 = R9_ARG7;\n-\n-    int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n-    address start = __ pc();\n-    __ mflr(tmp1);\n-    __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n-    __ push_frame_reg_args(0, tmp1);\n-    int frame_complete = __ pc() - start;\n-    __ set_last_Java_frame(R1_SP, noreg);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), R16_thread);\n-    address calls_return_pc = __ last_calls_return_pc();\n-    __ reset_last_Java_frame();\n-    \/\/ The handle is dereferenced through a load barrier.\n-    __ resolve_global_jobject(R3_RET, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n-    __ pop_frame();\n-    __ ld(tmp1, _abi0(lr), R1_SP);\n-    __ mtlr(tmp1);\n-    __ blr();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 0);\n-    oop_maps->add_gc_map(calls_return_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  RuntimeStub* generate_jfr_return_lease() {\n-    CodeBuffer code(\"jfr_return_lease\", 512, 64);\n-    MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-    Register tmp1 = R10_ARG8;\n-    Register tmp2 = R9_ARG7;\n-\n-    int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n-    address start = __ pc();\n-    __ mflr(tmp1);\n-    __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n-    __ push_frame_reg_args(0, tmp1);\n-    int frame_complete = __ pc() - start;\n-    __ set_last_Java_frame(R1_SP, noreg);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), R16_thread);\n-    address calls_return_pc = __ last_calls_return_pc();\n-    __ reset_last_Java_frame();\n-    __ pop_frame();\n-    __ ld(tmp1, _abi0(lr), R1_SP);\n-    __ mtlr(tmp1);\n-    __ blr();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 0);\n-    oop_maps->add_gc_map(calls_return_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -4789,8 +4608,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry   =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError), false);\n-    StubRoutines::_throw_delayed_StackOverflowError_entry =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError), false);\n-\n@@ -4815,10 +4626,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n-  }\n-\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -4826,1 +4627,0 @@\n-#endif \/\/ INCLUDE_JFR\n@@ -4831,7 +4631,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in\n-    \/\/ non-core builds\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError),  false);\n-    \/\/ Handle IncompatibleClassChangeError in itable stubs.\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError),  false);\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call), false);\n-\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":1,"deletions":208,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -786,2 +786,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"generated in wrong order\");\n-  __ load_const_optimized(Rscratch1, (StubRoutines::throw_StackOverflowError_entry()), R0);\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"generated in wrong order\");\n+  __ load_const_optimized(Rscratch1, (SharedRuntime::throw_StackOverflowError_entry()), R0);\n@@ -1467,7 +1467,1 @@\n-#if defined(ABI_ELFv2)\n-  __ call_c(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans),\n-            relocInfo::none);\n-#else\n-  __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, JavaThread::check_special_condition_for_native_trans),\n-            relocInfo::none);\n-#endif\n+  __ call_c(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans));\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2133,2 +2133,2 @@\n-    __ lwz(Rklass_flags, in_bytes(Klass::access_flags_offset()), Rklass);\n-    __ testbitdi(CCR0, R0, Rklass_flags, exact_log2(JVM_ACC_HAS_FINALIZER));\n+    __ lbz(Rklass_flags, in_bytes(Klass::misc_flags_offset()), Rklass);\n+    __ testbitdi(CCR0, R0, Rklass_flags, exact_log2(KlassFlags::_misc_has_finalizer));\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-    __ cmpd(CCR0, R19_method, 0);\n+    __ cmpdi(CCR0, R19_method, 0);\n","filename":"src\/hotspot\/cpu\/ppc\/vtableStubs_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1838,0 +1838,1 @@\n+  INSN(vlseg4e8_v, 0b0000111, 0b000, 0b00000, 0b00, 0b0, g4);\n@@ -1840,0 +1841,1 @@\n+  INSN(vsseg3e8_v, 0b0100111, 0b000, 0b00000, 0b00, 0b0, g3);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-  void poll_for_safepoint(relocInfo::relocType rtype, CodeEmitInfo* info = nullptr);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,2 +67,2 @@\n-    lwu(hdr, Address(hdr, Klass::access_flags_offset()));\n-    test_bit(temp, hdr, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    lbu(hdr, Address(hdr, Klass::misc_flags_offset()));\n+    test_bit(temp, hdr, exact_log2(KlassFlags::_misc_is_value_based_class));\n@@ -73,1 +73,1 @@\n-    lightweight_lock(obj, hdr, temp, t1, slow_case);\n+    lightweight_lock(disp_hdr, obj, hdr, temp, t1, slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -226,2 +226,0 @@\n-const int float_regs_as_doubles_size_in_slots = pd_nof_fpu_regs_frame_map * 2;\n-\n@@ -802,2 +800,2 @@\n-        __ lwu(t, Address(t, Klass::access_flags_offset()));\n-        __ test_bit(t0, t, exact_log2(JVM_ACC_HAS_FINALIZER));\n+        __ lbu(t, Address(t, Klass::misc_flags_offset()));\n+        __ test_bit(t0, t, exact_log2(KlassFlags::_misc_has_finalizer));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_Runtime1_riscv.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-    lwu(tmp, Address(tmp, Klass::access_flags_offset()));\n-    test_bit(tmp, tmp, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    lbu(tmp, Address(tmp, Klass::misc_flags_offset()));\n+    test_bit(tmp, tmp, exact_log2(KlassFlags::_misc_is_value_based_class));\n@@ -256,1 +256,2 @@\n-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register tmp1, Register tmp2, Register tmp3) {\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box,\n+                                              Register tmp1, Register tmp2, Register tmp3) {\n@@ -261,1 +262,1 @@\n-  assert_different_registers(obj, tmp1, tmp2, tmp3, flag, t0);\n+  assert_different_registers(obj, box, tmp1, tmp2, tmp3, flag, t0);\n@@ -272,0 +273,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    sd(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }\n+\n@@ -274,2 +280,2 @@\n-    lwu(tmp1, Address(tmp1, Klass::access_flags_offset()));\n-    test_bit(tmp1, tmp1, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    lbu(tmp1, Address(tmp1, Klass::misc_flags_offset()));\n+    test_bit(tmp1, tmp1, exact_log2(KlassFlags::_misc_is_value_based_class));\n@@ -280,0 +286,1 @@\n+  const Register tmp3_t = tmp3;\n@@ -287,1 +294,0 @@\n-    const Register tmp3_t = tmp3;\n@@ -326,3 +332,35 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tmp1_tagged_monitor = tmp1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register tmp1_monitor = tmp1;\n+    if (!UseObjectMonitorTable) {\n+      assert(tmp1_monitor == tmp1_mark, \"should be the same here\");\n+    } else {\n+      Label monitor_found;\n+\n+      \/\/ Load cache address\n+      la(tmp3_t, Address(xthread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        ld(tmp1, Address(tmp3_t));\n+        beq(obj, tmp1, monitor_found);\n+        add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      Label loop;\n+\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      ld(tmp1, Address(tmp3_t));\n+      beq(obj, tmp1, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      bnez(tmp1, loop);\n+      \/\/ Cache Miss. Take the slowpath.\n+      j(slow_path);\n+\n+      bind(monitor_found);\n+      ld(tmp1_monitor, Address(tmp3_t, OMCache::oop_to_monitor_difference()));\n+    }\n+\n@@ -332,0 +370,6 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address owner_address(tmp1_monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+    const Address recursions_address(tmp1_monitor, ObjectMonitor::recursions_offset() - monitor_tag);\n+\n+    Label monitor_locked;\n+\n@@ -333,1 +377,1 @@\n-    la(tmp2_owner_addr, Address(tmp1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n+    la(tmp2_owner_addr, owner_address);\n@@ -338,1 +382,1 @@\n-    beqz(tmp3_owner, locked);\n+    beqz(tmp3_owner, monitor_locked);\n@@ -344,1 +388,6 @@\n-    increment(Address(tmp1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1, tmp2, tmp3);\n+    increment(recursions_address, 1, tmp2, tmp3);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      sd(tmp1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+    }\n@@ -368,2 +417,2 @@\n-void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register tmp1, Register tmp2,\n-                                                Register tmp3) {\n+void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register box,\n+                                                Register tmp1, Register tmp2, Register tmp3) {\n@@ -374,1 +423,1 @@\n-  assert_different_registers(obj, tmp1, tmp2, tmp3, flag, t0);\n+  assert_different_registers(obj, box, tmp1, tmp2, tmp3, flag, t0);\n@@ -379,1 +428,1 @@\n-  Label inflated, inflated_load_monitor;\n+  Label inflated, inflated_load_mark;\n@@ -390,0 +439,1 @@\n+    Label push_and_slow_path;\n@@ -397,1 +447,1 @@\n-    bne(obj, tmp3_t, inflated_load_monitor);\n+    bne(obj, tmp3_t, inflated_load_mark);\n@@ -414,0 +464,3 @@\n+    \/\/ Because we got here by popping (meaning we pushed in locked)\n+    \/\/ there will be no monitor in the box. So we need to push back the obj\n+    \/\/ so that the runtime can fix any potential anonymous owner.\n@@ -415,1 +468,1 @@\n-    bnez(tmp3_t, inflated);\n+    bnez(tmp3_t, UseObjectMonitorTable ? push_and_slow_path : inflated);\n@@ -424,0 +477,1 @@\n+    bind(push_and_slow_path);\n@@ -434,1 +488,1 @@\n-    bind(inflated_load_monitor);\n+    bind(inflated_load_mark);\n@@ -456,6 +510,12 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tmp1_monitor = tmp1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-\n-    \/\/ Untag the monitor.\n-    sub(tmp1_monitor, tmp1_mark, monitor_tag);\n+    const Register tmp1_monitor = tmp1;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(tmp1_monitor == tmp1_mark, \"should be the same here\");\n+      \/\/ Untag the monitor.\n+      add(tmp1_monitor, tmp1_mark, -(int)markWord::monitor_value);\n+    } else {\n+      ld(tmp1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ No valid pointer below alignof(ObjectMonitor*). Take the slow path.\n+      mv(tmp3_t, alignof(ObjectMonitor*));\n+      bltu(tmp1_monitor, tmp3_t, slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":86,"deletions":26,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-  void fast_lock_lightweight(Register object, Register tmp1, Register tmp2, Register tmp3);\n-  void fast_unlock_lightweight(Register object, Register tmp1, Register tmp2, Register tmp3);\n+  void fast_lock_lightweight(Register object, Register box, Register tmp1, Register tmp2, Register tmp3);\n+  void fast_unlock_lightweight(Register object, Register box, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-        \/\/ If we patch code we need both a code patching and a loadload\n+        \/\/ If we patch code we need both a cmodx fence and a loadload\n@@ -276,0 +276,1 @@\n+\n@@ -277,4 +278,11 @@\n-        \/\/ Embed an artificial data dependency to order the guard load\n-        \/\/ before the epoch load.\n-        __ srli(ra, t0, 32);\n-        __ orr(t1, t1, ra);\n+        if (!UseZtso) {\n+          \/\/ Embed a synthetic data dependency between the load of the guard and\n+          \/\/ the load of the epoch. This guarantees that these loads occur in\n+          \/\/ order, while allowing other independent instructions to be reordered.\n+          \/\/ Note: This may be slower than using a membar(load|load) (fence r,r).\n+          \/\/ Because processors will not start the second load until the first comes back.\n+          \/\/ This means you cant overlap the two loads,\n+          \/\/ which is stronger than needed for ordering (stronger than TSO).\n+          __ srli(ra, t0, 32);\n+          __ orr(t1, t1, ra);\n+        }\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -753,2 +753,2 @@\n-      lwu(tmp, Address(tmp, Klass::access_flags_offset()));\n-      test_bit(tmp, tmp, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+      lbu(tmp, Address(tmp, Klass::misc_flags_offset()));\n+      test_bit(tmp, tmp, exact_log2(KlassFlags::_misc_is_value_based_class));\n@@ -759,1 +759,1 @@\n-      lightweight_lock(obj_reg, tmp, tmp2, tmp3, slow_case);\n+      lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n@@ -795,9 +795,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-              obj_reg);\n-    } else {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-              lock_reg);\n-    }\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+            lock_reg);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -77,0 +77,10 @@\n+\/\/ The C ABI specifies:\n+\/\/ \"integer scalars narrower than XLEN bits are widened according to the sign\n+\/\/ of their type up to 32 bits, then sign-extended to XLEN bits.\"\n+\/\/ Applies for both passed in register and stack.\n+\/\/\n+\/\/ Java uses 32-bit stack slots; jint, jshort, jchar, jbyte uses one slot.\n+\/\/ Native uses 64-bit stack slots for all integer scalar types.\n+\/\/\n+\/\/ lw loads the Java stack slot, sign-extends and\n+\/\/ sd store this widened integer into a 64 bit native stack slot.\n@@ -85,1 +95,1 @@\n-    __ sw(x10, Address(to(), next_stack_offset()));\n+    __ sd(x10, Address(to(), next_stack_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/interpreterRT_riscv.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -149,12 +149,0 @@\n-bool MacroAssembler::is_li64_at(address instr) {\n-  return is_lui_at(instr) && \/\/ lui\n-         is_addi_at(instr + instruction_size) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 2, 12) &&  \/\/ Slli Rd, Rs, 12\n-         is_addi_at(instr + instruction_size * 3) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 4, 12) &&  \/\/ Slli Rd, Rs, 12\n-         is_addi_at(instr + instruction_size * 5) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 6, 8) &&   \/\/ Slli Rd, Rs, 8\n-         is_addi_at(instr + instruction_size * 7) && \/\/ addi\n-         check_li64_data_dependency(instr);\n-}\n-\n@@ -912,1 +900,0 @@\n-  \/\/ use addiw to distinguish li32 to li64\n@@ -916,27 +903,0 @@\n-void MacroAssembler::li64(Register Rd, int64_t imm) {\n-  \/\/ Load upper 32 bits. upper = imm[63:32], but if imm[31] == 1 or\n-  \/\/ (imm[31:20] == 0x7ff && imm[19] == 1), upper = imm[63:32] + 1.\n-  int64_t lower = imm & 0xffffffff;\n-  lower -= ((lower << 44) >> 44);\n-  int64_t tmp_imm = ((uint64_t)(imm & 0xffffffff00000000)) + (uint64_t)lower;\n-  int32_t upper = (tmp_imm - (int32_t)lower) >> 32;\n-\n-  \/\/ Load upper 32 bits\n-  int64_t up = upper, lo = upper;\n-  lo = (lo << 52) >> 52;\n-  up -= lo;\n-  up = (int32_t)up;\n-  lui(Rd, up);\n-  addi(Rd, Rd, lo);\n-\n-  \/\/ Load the rest 32 bits.\n-  slli(Rd, Rd, 12);\n-  addi(Rd, Rd, (int32_t)lower >> 20);\n-  slli(Rd, Rd, 12);\n-  lower = ((int32_t)imm << 12) >> 20;\n-  addi(Rd, Rd, lower);\n-  slli(Rd, Rd, 8);\n-  lower = imm & 0xff;\n-  addi(Rd, Rd, lower);\n-}\n-\n@@ -1744,21 +1704,0 @@\n-static int patch_imm_in_li64(address branch, address target) {\n-  const int LI64_INSTRUCTIONS_NUM = 8;                                          \/\/ lui + addi + slli + addi + slli + addi + slli + addi\n-  int64_t lower = (intptr_t)target & 0xffffffff;\n-  lower = lower - ((lower << 44) >> 44);\n-  int64_t tmp_imm = ((uint64_t)((intptr_t)target & 0xffffffff00000000)) + (uint64_t)lower;\n-  int32_t upper =  (tmp_imm - (int32_t)lower) >> 32;\n-  int64_t tmp_upper = upper, tmp_lower = upper;\n-  tmp_lower = (tmp_lower << 52) >> 52;\n-  tmp_upper -= tmp_lower;\n-  tmp_upper >>= 12;\n-  \/\/ Load upper 32 bits. Upper = target[63:32], but if target[31] = 1 or (target[31:20] == 0x7ff && target[19] == 1),\n-  \/\/ upper = target[63:32] + 1.\n-  Assembler::patch(branch + 0,  31, 12, tmp_upper & 0xfffff);                       \/\/ Lui.\n-  Assembler::patch(branch + 4,  31, 20, tmp_lower & 0xfff);                         \/\/ Addi.\n-  \/\/ Load the rest 32 bits.\n-  Assembler::patch(branch + 12, 31, 20, ((int32_t)lower >> 20) & 0xfff);            \/\/ Addi.\n-  Assembler::patch(branch + 20, 31, 20, (((intptr_t)target << 44) >> 52) & 0xfff);  \/\/ Addi.\n-  Assembler::patch(branch + 28, 31, 20, (intptr_t)target & 0xff);                   \/\/ Addi.\n-  return LI64_INSTRUCTIONS_NUM * MacroAssembler::instruction_size;\n-}\n-\n@@ -1835,10 +1774,0 @@\n-static address get_target_of_li64(address insn_addr) {\n-  assert_cond(insn_addr != nullptr);\n-  intptr_t target_address = (((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr), 31, 12)) & 0xfffff) << 44; \/\/ Lui.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 4), 31, 20)) << 32;                 \/\/ Addi.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 12), 31, 20)) << 20;                \/\/ Addi.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 20), 31, 20)) << 8;                 \/\/ Addi.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 28), 31, 20));                      \/\/ Addi.\n-  return (address)target_address;\n-}\n-\n@@ -1867,2 +1796,0 @@\n-  } else if (MacroAssembler::is_li64_at(instruction_address)) {                 \/\/ li64\n-    return patch_imm_in_li64(instruction_address, target);\n@@ -1899,2 +1826,0 @@\n-  } else if (MacroAssembler::is_li64_at(insn_addr)) {             \/\/ li64\n-    return get_target_of_li64(insn_addr);\n@@ -3608,1 +3533,1 @@\n-         \"destination of far call not found in code cache\");\n+         \"destination of far jump not found in code cache\");\n@@ -3613,0 +3538,2 @@\n+  \/\/ We can use auipc + jr here because we know that the total size of\n+  \/\/ the code cache cannot exceed 2Gb.\n@@ -3614,2 +3541,4 @@\n-    int32_t offset;\n-    la(tmp, entry.target(), offset);\n+    int64_t distance = entry.target() - pc();\n+    int32_t offset = ((int32_t)distance << 20) >> 20;\n+    assert(is_valid_32bit_offset(distance), \"Far jump using wrong instructions.\");\n+    auipc(tmp, (int32_t)distance + 0x800);\n@@ -3630,2 +3559,5 @@\n-    assert(is_valid_32bit_offset(entry.target() - pc()), \"Far call using wrong instructions.\");\n-    call(entry.target(), tmp);\n+    int64_t distance = entry.target() - pc();\n+    int32_t offset = ((int32_t)distance << 20) >> 20;\n+    assert(is_valid_32bit_offset(distance), \"Far call using wrong instructions.\");\n+    auipc(tmp, (int32_t)distance + 0x800);\n+    jalr(tmp, offset);\n@@ -4147,1 +4079,1 @@\n-  la(t0, RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+  la(t0, RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n@@ -5597,4 +5529,10 @@\n-\/\/ On 64 bit we will store integer like items to the stack as\n-\/\/ 64 bits items (riscv64 abi) even though java would only store\n-\/\/ 32bits for a parameter. On 32bit it will simply be 32 bits\n-\/\/ So this routine will do 32->32 on 32bit and 32->64 on 64bit\n+\/\/ The C ABI specifies:\n+\/\/ \"integer scalars narrower than XLEN bits are widened according to the sign\n+\/\/ of their type up to 32 bits, then sign-extended to XLEN bits.\"\n+\/\/ Applies for both passed in register and stack.\n+\/\/\n+\/\/ Java uses 32-bit stack slots; jint, jshort, jchar, jbyte uses one slot.\n+\/\/ Native uses 64-bit stack slots for all integer scalar types.\n+\/\/\n+\/\/ lw loads the Java stack slot, sign-extends and\n+\/\/ sd store this widened integer into a 64 bit native stack slot.\n@@ -5605,1 +5543,1 @@\n-      ld(tmp, Address(fp, reg2offset_in(src.first())));\n+      lw(tmp, Address(fp, reg2offset_in(src.first())));\n@@ -5795,1 +5733,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow) {\n@@ -5797,1 +5735,1 @@\n-  assert_different_registers(obj, tmp1, tmp2, tmp3, t0);\n+  assert_different_registers(basic_lock, obj, tmp1, tmp2, tmp3, t0);\n@@ -5808,0 +5746,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    sd(zr, Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":31,"deletions":88,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -816,1 +816,0 @@\n-  void li64(Register Rd, int64_t imm);\n@@ -1605,1 +1604,1 @@\n-  void lightweight_lock(Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow);\n@@ -1709,34 +1708,0 @@\n-  \/\/ the instruction sequence of li64 is as below:\n-  \/\/     lui\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  static bool check_li64_data_dependency(address instr) {\n-    address lui = instr;\n-    address addi1 = lui + instruction_size;\n-    address slli1 = addi1 + instruction_size;\n-    address addi2 = slli1 + instruction_size;\n-    address slli2 = addi2 + instruction_size;\n-    address addi3 = slli2 + instruction_size;\n-    address slli3 = addi3 + instruction_size;\n-    address addi4 = slli3 + instruction_size;\n-    return extract_rs1(addi1) == extract_rd(lui) &&\n-           extract_rs1(addi1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(slli2) &&\n-           extract_rs1(addi3) == extract_rd(slli2) &&\n-           extract_rs1(addi3) == extract_rd(addi3) &&\n-           extract_rs1(slli3) == extract_rd(addi3) &&\n-           extract_rs1(slli3) == extract_rd(slli3) &&\n-           extract_rs1(addi4) == extract_rd(slli3) &&\n-           extract_rs1(addi4) == extract_rd(addi4);\n-  }\n-\n@@ -1787,1 +1752,0 @@\n-  static bool is_li64_at(address instr);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":37,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_AbstractMethodError_entry()));\n@@ -444,1 +444,1 @@\n-      __ far_jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));\n+      __ far_jump(RuntimeAddress(SharedRuntime::throw_IncompatibleClassChangeError_entry()));\n","filename":"src\/hotspot\/cpu\/riscv\/methodHandles_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -10556,1 +10556,1 @@\n-instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP_R10 box, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -10560,1 +10560,1 @@\n-  effect(TEMP tmp1, TEMP tmp2, USE_KILL box);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n@@ -10563,1 +10563,1 @@\n-  format %{ \"fastlock $object,$box\\t! kills $box,$tmp1,$tmp2 #@cmpFastLockLightweight\" %}\n+  format %{ \"fastlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3 #@cmpFastLockLightweight\" %}\n@@ -10566,1 +10566,1 @@\n-    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -10572,1 +10572,1 @@\n-instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP_R10 box, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -10576,1 +10576,1 @@\n-  effect(TEMP tmp1, TEMP tmp2, USE_KILL box);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n@@ -10579,1 +10579,1 @@\n-  format %{ \"fastunlock $object,$box\\t! kills $box,$tmp1,$tmp2, #@cmpFastUnlockLightweight\" %}\n+  format %{ \"fastunlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3 #@cmpFastUnlockLightweight\" %}\n@@ -10582,1 +10582,1 @@\n-    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -68,0 +69,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif\n+\n@@ -1698,1 +1705,1 @@\n-      __ lightweight_lock(obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n+      __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -2053,1 +2060,2 @@\n-  CodeBuffer buffer(\"deopt_blob\", 2048 + pad, 1024);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  CodeBuffer buffer(name, 2048 + pad, 1024);\n@@ -2431,1 +2439,3 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+  assert(is_polling_page_id(id), \"expected a polling page stub id\");\n+\n@@ -2438,1 +2448,2 @@\n-  CodeBuffer buffer(\"handler_blob\", 2048, 1024);\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBuffer buffer(name, 2048, 1024);\n@@ -2445,2 +2456,2 @@\n-  bool cause_return = (poll_type == POLL_AT_RETURN);\n-  RegisterSaver reg_saver(poll_type == POLL_AT_VECTOR_LOOP \/* save_vectors *\/);\n+  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n+  RegisterSaver reg_saver(id == SharedStubId::polling_page_vectors_safepoint_handler_id \/* save_vectors *\/);\n@@ -2552,1 +2563,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n@@ -2554,0 +2565,1 @@\n+  assert(is_resolve_id(id), \"expected a resolve stub id\");\n@@ -2558,0 +2570,1 @@\n+  const char* name = SharedRuntime::stub_name(id);\n@@ -2631,0 +2644,194 @@\n+\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Since we need to preserve callee-saved values (currently\n+\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+\/\/ map and therefore have to make these stubs into RuntimeStubs\n+\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+\/\/ be preserved between the fault point and the exception handler\n+\/\/ then it must assume responsibility for that in\n+\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+  assert(is_throw_id(id), \"expected a throw stub id\");\n+\n+  const char* name = SharedRuntime::stub_name(id);\n+\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  \/\/ n.b. riscv asserts that frame::arg_reg_save_area_bytes == 0\n+  assert_cond(runtime_entry != nullptr);\n+  enum layout {\n+    fp_off = 0,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  const int insts_size = 1024;\n+  const int locs_size  = 64;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  assert_cond(oop_maps != nullptr && masm != nullptr);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+\n+  __ enter(); \/\/ Save FP and RA before call\n+\n+  assert(is_even(framesize \/ 2), \"sp not 16-byte aligned\");\n+\n+  \/\/ ra and fp are already in place\n+  __ addi(sp, fp, 0 - ((unsigned)framesize << LogBytesPerInt)); \/\/ prolog\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, fp, the_pc, t0);\n+\n+  \/\/ Call runtime\n+  __ mv(c_rarg0, xthread);\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ rt_call(runtime_entry);\n+\n+  \/\/ Generate oop map\n+  OopMap* map = new OopMap(framesize, 0);\n+  assert_cond(map != nullptr);\n+\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave();\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n+  __ bnez(t0, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/\/ ASSERT\n+  __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  assert(stub != nullptr, \"create runtime stub fail!\");\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+static void jfr_prologue(address the_pc, MacroAssembler* masm, Register thread) {\n+  __ set_last_Java_frame(sp, fp, the_pc, t0);\n+  __ mv(c_rarg0, thread);\n+}\n+\n+static void jfr_epilogue(MacroAssembler* masm) {\n+  __ reset_last_Java_frame(true);\n+}\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    fp_off,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, xthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+\n+  jfr_epilogue(masm);\n+  __ resolve_global_jobject(x10, t0, t1);\n+  __ leave();\n+  __ ret();\n+\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    fp_off,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, xthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+\n+  jfr_epilogue(masm);\n+  __ leave();\n+  __ ret();\n+\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":214,"deletions":7,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -3777,1 +3777,1 @@\n-    __ la(t0, RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+    __ la(t0, RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -5325,0 +5325,273 @@\n+  \/**\n+   * vector registers:\n+   * input VectorRegister's:  intputV1-V4, for m2 they could be v2, v4, v6, for m1 they could be v2, v4, v6, v8\n+   * index VectorRegister's:  idxV1-V3, for m2 they could be v8, v10, v12, v14, for m1 they could be v10, v12, v14, v16\n+   * output VectorRegister's: outputV1-V4, for m2 they could be v16, v18, v20, v22, for m1 they could be v18, v20, v22\n+   *\n+   * NOTE: each field will occupy a single vector register group\n+   *\/\n+  void base64_vector_decode_round(Register src, Register dst, Register codec,\n+                    Register size, Register stepSrc, Register stepDst, Register failedIdx, Register minusOne,\n+                    VectorRegister inputV1, VectorRegister inputV2, VectorRegister inputV3, VectorRegister inputV4,\n+                    VectorRegister idxV1, VectorRegister idxV2, VectorRegister idxV3, VectorRegister idxV4,\n+                    VectorRegister outputV1, VectorRegister outputV2, VectorRegister outputV3,\n+                    Assembler::LMUL lmul) {\n+    \/\/ set vector register type\/len\n+    __ vsetvli(x0, size, Assembler::e8, lmul, Assembler::ma, Assembler::ta);\n+\n+    \/\/ segmented load src into v registers: mem(src) => vr(4)\n+    __ vlseg4e8_v(inputV1, src);\n+\n+    \/\/ src = src + register_group_len_bytes * 4\n+    __ add(src, src, stepSrc);\n+\n+    \/\/ decoding\n+    \/\/   1. indexed load: vr(4) => vr(4)\n+    __ vluxei8_v(idxV1, codec, inputV1);\n+    __ vluxei8_v(idxV2, codec, inputV2);\n+    __ vluxei8_v(idxV3, codec, inputV3);\n+    __ vluxei8_v(idxV4, codec, inputV4);\n+\n+    \/\/   2. check wrong data\n+    __ vor_vv(outputV1, idxV1, idxV2);\n+    __ vor_vv(outputV2, idxV3, idxV4);\n+    __ vor_vv(outputV1, outputV1, outputV2);\n+    __ vmseq_vi(v0, outputV1, -1);\n+    __ vfirst_m(failedIdx, v0);\n+    Label NoFailure;\n+    __ beq(failedIdx, minusOne, NoFailure);\n+    __ vsetvli(x0, failedIdx, Assembler::e8, lmul, Assembler::mu, Assembler::tu);\n+    __ slli(stepDst, failedIdx, 1);\n+    __ add(stepDst, failedIdx, stepDst);\n+    __ BIND(NoFailure);\n+\n+    \/\/   3. compute the decoded data: vr(4) => vr(3)\n+    __ vsll_vi(idxV1, idxV1, 2);\n+    __ vsrl_vi(outputV1, idxV2, 4);\n+    __ vor_vv(outputV1, outputV1, idxV1);\n+\n+    __ vsll_vi(idxV2, idxV2, 4);\n+    __ vsrl_vi(outputV2, idxV3, 2);\n+    __ vor_vv(outputV2, outputV2, idxV2);\n+\n+    __ vsll_vi(idxV3, idxV3, 6);\n+    __ vor_vv(outputV3, idxV4, idxV3);\n+\n+    \/\/ segmented store encoded data in v registers back to dst: vr(3) => mem(dst)\n+    __ vsseg3e8_v(outputV1, dst);\n+\n+    \/\/ dst = dst + register_group_len_bytes * 3\n+    __ add(dst, dst, stepDst);\n+  }\n+\n+  \/**\n+   * int j.u.Base64.Decoder.decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL, boolean isMIME)\n+   *\n+   *  Input arguments:\n+   *  c_rarg0   - src, source array\n+   *  c_rarg1   - sp, src start offset\n+   *  c_rarg2   - sl, src end offset\n+   *  c_rarg3   - dst, dest array\n+   *  c_rarg4   - dp, dst start offset\n+   *  c_rarg5   - isURL, Base64 or URL character set\n+   *  c_rarg6   - isMIME, Decoding MIME block\n+   *\/\n+  address generate_base64_decodeBlock() {\n+\n+    static const uint8_t fromBase64[256] = {\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u, 255u,  63u,\n+        52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+        15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u, 255u,\n+        255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+        41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    static const uint8_t fromBase64URL[256] = {\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u,\n+        52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+        15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,  63u,\n+        255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+        41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"decodeBlock\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    Register src    = c_rarg0;\n+    Register soff   = c_rarg1;\n+    Register send   = c_rarg2;\n+    Register dst    = c_rarg3;\n+    Register doff   = c_rarg4;\n+    Register isURL  = c_rarg5;\n+    Register isMIME = c_rarg6;\n+\n+    Register codec     = c_rarg7;\n+    Register dstBackup = x31;\n+    Register length    = x28;     \/\/ t3, total length of src data in bytes\n+\n+    Label ProcessData, Exit;\n+    Label ProcessScalar, ScalarLoop;\n+\n+    \/\/ passed in length (send - soff) is guaranteed to be > 4,\n+    \/\/ and in this intrinsic we only process data of length in multiple of 4,\n+    \/\/ it's not guaranteed to be multiple of 4 by java level, so do it explicitly\n+    __ sub(length, send, soff);\n+    __ andi(length, length, -4);\n+    \/\/ real src\/dst to process data\n+    __ add(src, src, soff);\n+    __ add(dst, dst, doff);\n+    \/\/ backup of dst, used to calculate the return value at exit\n+    __ mv(dstBackup, dst);\n+\n+    \/\/ load the codec base address\n+    __ la(codec, ExternalAddress((address) fromBase64));\n+    __ beqz(isURL, ProcessData);\n+    __ la(codec, ExternalAddress((address) fromBase64URL));\n+    __ BIND(ProcessData);\n+\n+    \/\/ vector version\n+    if (UseRVV) {\n+      \/\/ for MIME case, it has a default length limit of 76 which could be\n+      \/\/ different(smaller) from (send - soff), so in MIME case, we go through\n+      \/\/ the scalar code path directly.\n+      __ bnez(isMIME, ScalarLoop);\n+\n+      Label ProcessM1, ProcessM2;\n+\n+      Register failedIdx = soff;\n+      Register stepSrcM1 = send;\n+      Register stepSrcM2 = doff;\n+      Register stepDst   = isURL;\n+      Register size      = x29;   \/\/ t4\n+      Register minusOne  = x30;   \/\/ t5\n+\n+      __ mv(minusOne, -1);\n+      __ mv(size, MaxVectorSize * 2);\n+      __ mv(stepSrcM1, MaxVectorSize * 4);\n+      __ slli(stepSrcM2, stepSrcM1, 1);\n+      __ mv(stepDst, MaxVectorSize * 2 * 3);\n+\n+      __ blt(length, stepSrcM2, ProcessM1);\n+\n+\n+      \/\/ Assembler::m2\n+      __ BIND(ProcessM2);\n+      base64_vector_decode_round(src, dst, codec,\n+                    size, stepSrcM2, stepDst, failedIdx, minusOne,\n+                    v2, v4, v6, v8,      \/\/ inputs\n+                    v10, v12, v14, v16,  \/\/ indexes\n+                    v18, v20, v22,       \/\/ outputs\n+                    Assembler::m2);\n+      __ sub(length, length, stepSrcM2);\n+\n+      \/\/ error check\n+      __ bne(failedIdx, minusOne, Exit);\n+\n+      __ bge(length, stepSrcM2, ProcessM2);\n+\n+\n+      \/\/ Assembler::m1\n+      __ BIND(ProcessM1);\n+      __ blt(length, stepSrcM1, ProcessScalar);\n+\n+      __ srli(size, size, 1);\n+      __ srli(stepDst, stepDst, 1);\n+      base64_vector_decode_round(src, dst, codec,\n+                    size, stepSrcM1, stepDst, failedIdx, minusOne,\n+                    v1, v2, v3, v4,      \/\/ inputs\n+                    v5, v6, v7, v8,      \/\/ indexes\n+                    v9, v10, v11,        \/\/ outputs\n+                    Assembler::m1);\n+      __ sub(length, length, stepSrcM1);\n+\n+      \/\/ error check\n+      __ bne(failedIdx, minusOne, Exit);\n+\n+      __ BIND(ProcessScalar);\n+      __ beqz(length, Exit);\n+    }\n+\n+    \/\/ scalar version\n+    {\n+      Register byte0 = soff, byte1 = send, byte2 = doff, byte3 = isURL;\n+      Register combined32Bits = x29; \/\/ t5\n+\n+      \/\/ encoded:   [byte0[5:0] : byte1[5:0] : byte2[5:0]] : byte3[5:0]] =>\n+      \/\/ plain:     [byte0[5:0]+byte1[5:4] : byte1[3:0]+byte2[5:2] : byte2[1:0]+byte3[5:0]]\n+      __ BIND(ScalarLoop);\n+\n+      \/\/ load 4 bytes encoded src data\n+      __ lbu(byte0, Address(src, 0));\n+      __ lbu(byte1, Address(src, 1));\n+      __ lbu(byte2, Address(src, 2));\n+      __ lbu(byte3, Address(src, 3));\n+      __ addi(src, src, 4);\n+\n+      \/\/ get codec index and decode (ie. load from codec by index)\n+      __ add(byte0, codec, byte0);\n+      __ add(byte1, codec, byte1);\n+      __ lb(byte0, Address(byte0, 0));\n+      __ lb(byte1, Address(byte1, 0));\n+      __ add(byte2, codec, byte2);\n+      __ add(byte3, codec, byte3);\n+      __ lb(byte2, Address(byte2, 0));\n+      __ lb(byte3, Address(byte3, 0));\n+      __ slliw(byte0, byte0, 18);\n+      __ slliw(byte1, byte1, 12);\n+      __ orr(byte0, byte0, byte1);\n+      __ orr(byte0, byte0, byte3);\n+      __ slliw(byte2, byte2, 6);\n+      \/\/ For performance consideration, `combined32Bits` is constructed for 2 purposes at the same time,\n+      \/\/  1. error check below\n+      \/\/  2. decode below\n+      __ orr(combined32Bits, byte0, byte2);\n+\n+      \/\/ error check\n+      __ bltz(combined32Bits, Exit);\n+\n+      \/\/ store 3 bytes decoded data\n+      __ sraiw(byte0, combined32Bits, 16);\n+      __ sraiw(byte1, combined32Bits, 8);\n+      __ sb(byte0, Address(dst, 0));\n+      __ sb(byte1, Address(dst, 1));\n+      __ sb(combined32Bits, Address(dst, 2));\n+\n+      __ sub(length, length, 4);\n+      __ addi(dst, dst, 3);\n+      \/\/ loop back\n+      __ bnez(length, ScalarLoop);\n+    }\n+\n+    __ BIND(Exit);\n+    __ sub(c_rarg0, dst, dstBackup);\n+\n+    __ leave();\n+    __ ret();\n+\n+    return (address) start;\n+  }\n+\n@@ -5837,91 +6110,0 @@\n-#if INCLUDE_JFR\n-\n-  static void jfr_prologue(address the_pc, MacroAssembler* _masm, Register thread) {\n-    __ set_last_Java_frame(sp, fp, the_pc, t0);\n-    __ mv(c_rarg0, thread);\n-  }\n-\n-  static void jfr_epilogue(MacroAssembler* _masm) {\n-    __ reset_last_Java_frame(true);\n-  }\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      fp_off,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, xthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-\n-    jfr_epilogue(_masm);\n-    __ resolve_global_jobject(x10, t0, t1);\n-    __ leave();\n-    __ ret();\n-\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      fp_off,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, xthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-\n-    jfr_epilogue(_masm);\n-    __ leave();\n-    __ ret();\n-\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -5942,108 +6124,0 @@\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Since we need to preserve callee-saved values (currently\n-  \/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-  \/\/ map and therefore have to make these stubs into RuntimeStubs\n-  \/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-  \/\/ be preserved between the fault point and the exception handler\n-  \/\/ then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n-#undef __\n-#define __ masm->\n-\n-  address generate_throw_exception(const char* name,\n-                                   address runtime_entry,\n-                                   Register arg1 = noreg,\n-                                   Register arg2 = noreg) {\n-    \/\/ Information about frame layout at time of blocking runtime call.\n-    \/\/ Note that we only have to preserve callee-saved registers since\n-    \/\/ the compilers are responsible for supplying a continuation point\n-    \/\/ if they expect all registers to be preserved.\n-    \/\/ n.b. riscv asserts that frame::arg_reg_save_area_bytes == 0\n-    assert_cond(runtime_entry != nullptr);\n-    enum layout {\n-      fp_off = 0,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    const int insts_size = 1024;\n-    const int locs_size  = 64;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    assert_cond(oop_maps != nullptr && masm != nullptr);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-\n-    __ enter(); \/\/ Save FP and RA before call\n-\n-    assert(is_even(framesize \/ 2), \"sp not 16-byte aligned\");\n-\n-    \/\/ ra and fp are already in place\n-    __ addi(sp, fp, 0 - ((unsigned)framesize << LogBytesPerInt)); \/\/ prolog\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    address the_pc = __ pc();\n-    __ set_last_Java_frame(sp, fp, the_pc, t0);\n-\n-    \/\/ Call runtime\n-    if (arg1 != noreg) {\n-      assert(arg2 != c_rarg1, \"clobbered\");\n-      __ mv(c_rarg1, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mv(c_rarg2, arg2);\n-    }\n-    __ mv(c_rarg0, xthread);\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ rt_call(runtime_entry);\n-\n-    \/\/ Generate oop map\n-    OopMap* map = new OopMap(framesize, 0);\n-    assert_cond(map != nullptr);\n-\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    __ reset_last_Java_frame(true);\n-\n-    __ leave();\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n-    __ bnez(t0, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/\/ ASSERT\n-    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-    \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name,\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    assert(stub != nullptr, \"create runtime stub fail!\");\n-    return stub->entry_point();\n-  }\n-\n@@ -6074,10 +6148,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_StackOverflowError));\n-    StubRoutines::_throw_delayed_StackOverflowError_entry =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_delayed_StackOverflowError));\n-\n@@ -6096,10 +6160,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n-  }\n-\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -6107,1 +6161,0 @@\n-#endif \/\/ INCLUDE_JFR\n@@ -6115,17 +6168,0 @@\n-    StubRoutines::_throw_AbstractMethodError_entry =\n-      generate_throw_exception(\"AbstractMethodError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_AbstractMethodError));\n-\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry =\n-      generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_IncompatibleClassChangeError));\n-\n-    StubRoutines::_throw_NullPointerException_at_call_entry =\n-      generate_throw_exception(\"NullPointerException at call throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_NullPointerException_at_call));\n@@ -6220,0 +6256,1 @@\n+      StubRoutines::_base64_decodeBlock = generate_base64_decodeBlock();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":275,"deletions":238,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -661,2 +661,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2101,1 +2101,1 @@\n-    __ lwu(x13, Address(x13, Klass::access_flags_offset()));\n+    __ lbu(x13, Address(x13, Klass::misc_flags_offset()));\n@@ -2103,1 +2103,1 @@\n-    __ test_bit(t0, x13, exact_log2(JVM_ACC_HAS_FINALIZER));\n+    __ test_bit(t0, x13, exact_log2(KlassFlags::_misc_has_finalizer));\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    testbit(Address(tmp, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    z_tm(Address(tmp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -446,1 +446,1 @@\n-        __ testbit(Address(klass, Klass::access_flags_offset()), exact_log2(JVM_ACC_HAS_FINALIZER));\n+        __ z_tm(Address(klass, Klass::misc_flags_offset()), KlassFlags::_misc_has_finalizer);\n","filename":"src\/hotspot\/cpu\/s390\/c1_Runtime1_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1010,1 +1010,1 @@\n-    testbit(Address(tmp, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    z_tm(Address(tmp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n@@ -1075,10 +1075,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    \/\/ for lightweight locking we need to use monitorenter_obj, see interpreterRuntime.cpp\n-    call_VM(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-            object);\n-  } else {\n-    call_VM(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            monitor);\n-  }\n+  call_VM(noreg,\n+          CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+          monitor);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2754,1 +2754,1 @@\n-  load_const_optimized(Z_R1, StubRoutines::throw_delayed_StackOverflowError_entry());\n+  load_const_optimized(Z_R1, SharedRuntime::throw_delayed_StackOverflowError_entry());\n@@ -3323,2 +3323,2 @@\n-  z_cghi(r_bitmap, Klass::SECONDARY_SUPERS_BITMAP_FULL);\n-  z_bre(L_huge);\n+  z_chi(r_array_length, Klass::SECONDARY_SUPERS_BITMAP_FULL - 2);\n+  z_brh(L_huge);\n@@ -3510,3 +3510,1 @@\n-    z_l(temp, Address(temp, Klass::access_flags_offset()));\n-    assert((JVM_ACC_IS_VALUE_BASED_CLASS & 0xFFFF) == 0, \"or change following instruction\");\n-    z_nilh(temp, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n+    z_tm(Address(temp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n@@ -6157,3 +6155,1 @@\n-    z_l(tmp1, Address(tmp1, Klass::access_flags_offset()));\n-    assert((JVM_ACC_IS_VALUE_BASED_CLASS & 0xFFFF) == 0, \"or change following instruction\");\n-    z_nilh(tmp1, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n+    z_tm(Address(tmp1, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n@@ -6221,20 +6217,27 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tagged_monitor = mark;\n-    const Register zero           = tmp2;\n-\n-    \/\/ Try to CAS m->owner from null to current thread.\n-    \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n-    \/\/ Otherwise, register zero is filled with the current owner.\n-    z_lghi(zero, 0);\n-    z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), tagged_monitor);\n-    z_bre(locked);\n-\n-    \/\/ Check if recursive.\n-    z_cgr(Z_thread, zero); \/\/ zero contains the owner from z_csg instruction\n-    z_brne(slow_path);\n-\n-    \/\/ Recursive\n-    z_agsi(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n-    z_cgr(zero, zero);\n-    \/\/ z_bru(locked);\n-    \/\/ Uncomment above line in the future, for now jump address is right next to us.\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register tagged_monitor = mark;\n+      const Register zero           = tmp2;\n+\n+      \/\/ Try to CAS m->owner from null to current thread.\n+      \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n+      \/\/ Otherwise, register zero is filled with the current owner.\n+      z_lghi(zero, 0);\n+      z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), tagged_monitor);\n+      z_bre(locked);\n+\n+      \/\/ Check if recursive.\n+      z_cgr(Z_thread, zero); \/\/ zero contains the owner from z_csg instruction\n+      z_brne(slow_path);\n+\n+      \/\/ Recursive\n+      z_agsi(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n+      z_cgr(zero, zero);\n+      \/\/ z_bru(locked);\n+      \/\/ Uncomment above line in the future, for now jump address is right next to us.\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      z_ltgr(obj, obj);\n+      z_bru(slow_path);\n+    }\n@@ -6282,0 +6285,1 @@\n+    NearLabel push_and_slow_path;\n@@ -6311,1 +6315,5 @@\n-    z_brnaz(inflated);\n+    if (!UseObjectMonitorTable) {\n+      z_brnaz(inflated);\n+    } else {\n+      z_brnaz(push_and_slow_path);\n+    }\n@@ -6330,0 +6338,1 @@\n+    bind(push_and_slow_path);\n@@ -6367,2 +6376,3 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register monitor = mark;\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register monitor = mark;\n@@ -6370,2 +6380,2 @@\n-    NearLabel not_recursive;\n-    const Register recursions = tmp2;\n+      NearLabel not_recursive;\n+      const Register recursions = tmp2;\n@@ -6373,3 +6383,3 @@\n-    \/\/ Check if recursive.\n-    load_and_test_long(recursions, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-    z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+      \/\/ Check if recursive.\n+      load_and_test_long(recursions, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+      z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n@@ -6377,4 +6387,4 @@\n-    \/\/ Recursive unlock\n-    z_agsi(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n-    z_cgr(monitor, monitor); \/\/ set the CC to EQUAL\n-    z_bru(unlocked);\n+      \/\/ Recursive unlock\n+      z_agsi(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n+      z_cgr(monitor, monitor); \/\/ set the CC to EQUAL\n+      z_bru(unlocked);\n@@ -6382,1 +6392,1 @@\n-    bind(not_recursive);\n+      bind(not_recursive);\n@@ -6384,6 +6394,6 @@\n-    NearLabel not_ok;\n-    \/\/ Check if the entry lists are empty.\n-    load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-    z_brne(not_ok);\n-    load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-    z_brne(not_ok);\n+      NearLabel not_ok;\n+      \/\/ Check if the entry lists are empty.\n+      load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+      z_brne(not_ok);\n+      load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n+      z_brne(not_ok);\n@@ -6391,2 +6401,2 @@\n-    z_release();\n-    z_stg(tmp2 \/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+      z_release();\n+      z_stg(tmp2 \/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n@@ -6394,1 +6404,1 @@\n-    z_bru(unlocked); \/\/ CC = EQ here\n+      z_bru(unlocked); \/\/ CC = EQ here\n@@ -6396,1 +6406,1 @@\n-    bind(not_ok);\n+      bind(not_ok);\n@@ -6398,5 +6408,11 @@\n-    \/\/ The owner may be anonymous, and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    z_stg(Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n-    z_bru(slow_path); \/\/ CC = NE here\n+      \/\/ The owner may be anonymous, and we removed the last obj entry in\n+      \/\/ the lock-stack. This loses the information about the owner.\n+      \/\/ Write the thread to the owner field so the runtime knows the owner.\n+      z_stg(Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+      z_bru(slow_path); \/\/ CC = NE here\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      z_ltgr(obj, obj);\n+      z_bru(slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":73,"deletions":57,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -183,2 +183,2 @@\n-  assert(StubRoutines::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n-  __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());\n+  assert(SharedRuntime::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n+  __ load_const_optimized(target, SharedRuntime::throw_AbstractMethodError_entry());\n@@ -546,1 +546,1 @@\n-      __ load_const_optimized(Z_R1, StubRoutines::throw_IncompatibleClassChangeError_entry());\n+      __ load_const_optimized(Z_R1, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n","filename":"src\/hotspot\/cpu\/s390\/methodHandles_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2491,1 +2491,2 @@\n-  CodeBuffer buffer(\"deopt_blob\", 2048, 1024);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  CodeBuffer buffer(name, 2048, 1024);\n@@ -2837,1 +2838,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n@@ -2840,0 +2841,1 @@\n+  assert(is_polling_page_id(id), \"expected a polling page stub id\");\n@@ -2846,1 +2848,2 @@\n-  CodeBuffer buffer(\"handler_blob\", 2048, 1024);\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBuffer buffer(name, 2048, 1024);\n@@ -2853,1 +2856,1 @@\n-  bool cause_return = (poll_type == POLL_AT_RETURN);\n+  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n@@ -2938,1 +2941,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n@@ -2940,0 +2943,1 @@\n+  assert(is_resolve_id(id), \"expected a resolve stub id\");\n@@ -2944,0 +2948,1 @@\n+  const char* name = SharedRuntime::stub_name(id);\n@@ -3013,0 +3018,82 @@\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Only callee-saved registers are preserved (through the\n+\/\/ normal RegisterMap handling). If the compiler\n+\/\/ needs all registers to be preserved between the fault point and\n+\/\/ the exception handler then it must assume responsibility for that\n+\/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\n+\/\/ Note that we generate only this stub into a RuntimeStub, because\n+\/\/ it needs to be properly traversed and ignored during GC, so we\n+\/\/ change the meaning of the \"__\" macro within this method.\n+\n+\/\/ Note: the routine set_pc_not_at_call_for_caller in\n+\/\/ SharedRuntime.cpp requires that this code be generated into a\n+\/\/ RuntimeStub.\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+  assert(is_throw_id(id), \"expected a throw stub id\");\n+\n+  const char* name = SharedRuntime::stub_name(id);\n+\n+  int insts_size = 256;\n+  int locs_size  = 0;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer      code(name, insts_size, locs_size);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  int framesize_in_bytes;\n+  address start = __ pc();\n+\n+  __ save_return_pc();\n+  framesize_in_bytes = __ push_frame_abi160(0);\n+\n+  address frame_complete_pc = __ pc();\n+\n+  \/\/ Note that we always have a runtime stub frame on the top of stack at this point.\n+  __ get_PC(Z_R1);\n+  __ set_last_Java_frame(\/*sp*\/Z_SP, \/*pc*\/Z_R1);\n+\n+  \/\/ Do the call.\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ call_VM_leaf(runtime_entry, Z_thread);\n+\n+  __ reset_last_Java_frame();\n+\n+#ifdef ASSERT\n+  \/\/ Make sure that this code is only executed if there is a pending exception.\n+  { Label L;\n+    __ z_lg(Z_R0,\n+            in_bytes(Thread::pending_exception_offset()),\n+            Z_thread);\n+    __ z_ltgr(Z_R0, Z_R0);\n+    __ z_brne(L);\n+    __ stop(\"SharedRuntime::throw_exception: no pending exception\");\n+    __ bind(L);\n+  }\n+#endif\n+\n+  __ pop_frame();\n+  __ restore_return_pc();\n+\n+  __ load_const_optimized(Z_R1, StubRoutines::forward_exception_entry());\n+  __ z_br(Z_R1);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name, &code,\n+                                  frame_complete_pc - start,\n+                                  framesize_in_bytes\/wordSize,\n+                                  nullptr \/*oop_maps*\/, false);\n+\n+  return stub;\n+}\n+\n@@ -3266,0 +3353,15 @@\n+\n+#if INCLUDE_JFR\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  if (!Continuations::enabled()) return nullptr;\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  if (!Continuations::enabled()) return nullptr;\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":107,"deletions":5,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -575,83 +575,0 @@\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Only callee-saved registers are preserved (through the\n-  \/\/ normal RegisterMap handling). If the compiler\n-  \/\/ needs all registers to be preserved between the fault point and\n-  \/\/ the exception handler then it must assume responsibility for that\n-  \/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n-  \/\/ Note that we generate only this stub into a RuntimeStub, because\n-  \/\/ it needs to be properly traversed and ignored during GC, so we\n-  \/\/ change the meaning of the \"__\" macro within this method.\n-\n-  \/\/ Note: the routine set_pc_not_at_call_for_caller in\n-  \/\/ SharedRuntime.cpp requires that this code be generated into a\n-  \/\/ RuntimeStub.\n-#undef __\n-#define __ masm->\n-\n-  address generate_throw_exception(const char* name, address runtime_entry,\n-                                   bool restore_saved_exception_pc,\n-                                   Register arg1 = noreg, Register arg2 = noreg) {\n-    assert_different_registers(arg1, Z_R0_scratch);  \/\/ would be destroyed by push_frame()\n-    assert_different_registers(arg2, Z_R0_scratch);  \/\/ would be destroyed by push_frame()\n-\n-    int insts_size = 256;\n-    int locs_size  = 0;\n-    CodeBuffer      code(name, insts_size, locs_size);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    int framesize_in_bytes;\n-    address start = __ pc();\n-\n-    __ save_return_pc();\n-    framesize_in_bytes = __ push_frame_abi160(0);\n-\n-    address frame_complete_pc = __ pc();\n-    if (restore_saved_exception_pc) {\n-      __ unimplemented(\"StubGenerator::throw_exception\", 74);\n-    }\n-\n-    \/\/ Note that we always have a runtime stub frame on the top of stack at this point.\n-    __ get_PC(Z_R1);\n-    __ set_last_Java_frame(\/*sp*\/Z_SP, \/*pc*\/Z_R1);\n-\n-    \/\/ Do the call.\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ call_VM_leaf(runtime_entry, Z_thread, arg1, arg2);\n-\n-    __ reset_last_Java_frame();\n-\n-#ifdef ASSERT\n-    \/\/ Make sure that this code is only executed if there is a pending exception.\n-    { Label L;\n-      __ z_lg(Z_R0,\n-                in_bytes(Thread::pending_exception_offset()),\n-                Z_thread);\n-      __ z_ltgr(Z_R0, Z_R0);\n-      __ z_brne(L);\n-      __ stop(\"StubRoutines::throw_exception: no pending exception\");\n-      __ bind(L);\n-    }\n-#endif\n-\n-    __ pop_frame();\n-    __ restore_return_pc();\n-\n-    __ load_const_optimized(Z_R1, StubRoutines::forward_exception_entry());\n-    __ z_br(Z_R1);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name, &code,\n-                                    frame_complete_pc - start,\n-                                    framesize_in_bytes\/wordSize,\n-                                    nullptr \/*oop_maps*\/, false);\n-\n-    return stub->entry_point();\n-  }\n-\n@@ -3124,15 +3041,0 @@\n-  #if INCLUDE_JFR\n-  RuntimeStub* generate_jfr_write_checkpoint() {\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n-  }\n-\n-  RuntimeStub* generate_jfr_return_lease() {\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n-  }\n-\n-  #endif \/\/ INCLUDE_JFR\n-\n@@ -3167,8 +3069,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry          =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError), false);\n-    StubRoutines::_throw_delayed_StackOverflowError_entry  =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError), false);\n-\n@@ -3199,2 +3093,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n@@ -3203,9 +3095,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-  }\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -3217,5 +3100,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in non-core builds.\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError),  false);\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError),  false);\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call), false);\n-\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":0,"deletions":122,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -853,3 +853,3 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  AddressLiteral stub(StubRoutines::throw_StackOverflowError_entry());\n-  __ load_absolute_address(tmp1, StubRoutines::throw_StackOverflowError_entry());\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  AddressLiteral stub(SharedRuntime::throw_StackOverflowError_entry());\n+  __ load_absolute_address(tmp1, SharedRuntime::throw_StackOverflowError_entry());\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2324,1 +2324,1 @@\n-    __ testbit(Address(Rklass, Klass::access_flags_offset()), exact_log2(JVM_ACC_HAS_FINALIZER));\n+    __ z_tm(Address(Rklass, Klass::misc_flags_offset()), KlassFlags::_misc_has_finalizer);\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1408,6 +1408,0 @@\n-void Assembler::addw(Register dst, Register src) {\n-  emit_int8(0x66);\n-  (void)prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_arith(0x03, 0xC0, dst, src);\n-}\n-\n@@ -1635,5 +1629,0 @@\n-void Assembler::andw(Register dst, Register src) {\n-  (void)prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_arith(0x23, 0xC0, dst, src);\n-}\n-\n@@ -4233,5 +4222,0 @@\n-void Assembler::orw(Register dst, Register src) {\n-  (void)prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_arith(0x0B, 0xC0, dst, src);\n-}\n-\n@@ -6806,5 +6790,0 @@\n-void Assembler::xorw(Register dst, Register src) {\n-  (void)prefix_and_encode(dst->encoding(), src->encoding());\n-  emit_arith(0x33, 0xC0, dst, src);\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1071,1 +1071,0 @@\n-  void addw(Register dst, Register src);\n@@ -1123,1 +1122,0 @@\n-  void andw(Register dst, Register src);\n@@ -1827,2 +1825,0 @@\n-  void orw(Register dst, Register src);\n-\n@@ -2345,1 +2341,0 @@\n-  void xorw(Register dst, Register src);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,2 +61,1 @@\n-    movl(hdr, Address(hdr, Klass::access_flags_offset()));\n-    testl(hdr, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    testb(Address(hdr, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n@@ -69,0 +68,1 @@\n+    lightweight_lock(disp_hdr, obj, hdr, thread, tmp, slow_case);\n@@ -70,2 +70,4 @@\n-    const Register thread = disp_hdr;\n-    get_thread(thread);\n+    \/\/ Implicit null check.\n+    movptr(hdr, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+    jmp(slow_case);\n@@ -73,1 +75,0 @@\n-    lightweight_lock(obj, hdr, thread, tmp, slow_case);\n@@ -142,4 +143,2 @@\n-    \/\/ This relies on the implementation of lightweight_unlock being able to handle\n-    \/\/ that the reg_rax and thread Register parameters may alias each other.\n-    get_thread(disp_hdr);\n-    lightweight_unlock(obj, disp_hdr, disp_hdr, hdr, slow_case);\n+    \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+    jmp(slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1169,2 +1169,1 @@\n-        __ movl(t, Address(t, Klass::access_flags_offset()));\n-        __ testl(t, JVM_ACC_HAS_FINALIZER);\n+        __ testb(Address(t, Klass::misc_flags_offset()), KlassFlags::_misc_has_finalizer);\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+    __ bind(_slow_path);\n@@ -115,0 +116,4 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address succ_address(monitor, ObjectMonitor::succ_offset() - monitor_tag);\n+    const Address owner_address(monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+\n@@ -116,1 +121,1 @@\n-    __ cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n+    __ cmpptr(succ_address, NULL_WORD);\n@@ -120,1 +125,1 @@\n-    __ movptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n+    __ movptr(owner_address, NULL_WORD);\n@@ -127,1 +132,1 @@\n-    __ cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n+    __ cmpptr(succ_address, NULL_WORD);\n@@ -136,1 +141,1 @@\n-    __ lock(); __ cmpxchgptr(_thread, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+    __ lock(); __ cmpxchgptr(_thread, owner_address);\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -280,2 +280,1 @@\n-    movl(tmpReg, Address(tmpReg, Klass::access_flags_offset()));\n-    testl(tmpReg, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    testb(Address(tmpReg, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n@@ -593,0 +592,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    movptr(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), 0);\n+  }\n+\n@@ -595,2 +599,1 @@\n-    movl(rax_reg, Address(rax_reg, Klass::access_flags_offset()));\n-    testl(rax_reg, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    testb(Address(rax_reg, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n@@ -606,1 +609,1 @@\n-    const Register top = box;\n+    const Register top = UseObjectMonitorTable ? rax_reg : box;\n@@ -633,0 +636,4 @@\n+    if (UseObjectMonitorTable) {\n+      \/\/ Need to reload top, clobbered by CAS.\n+      movl(top, Address(thread, JavaThread::lock_stack_top_offset()));\n+    }\n@@ -643,1 +650,44 @@\n-    const Register tagged_monitor = mark;\n+    const Register monitor = t;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(mark == monitor, \"should be the same here\");\n+    } else {\n+      \/\/ Uses ObjectMonitorTable.  Look for the monitor in the om_cache.\n+      \/\/ Fetch ObjectMonitor* from the cache or take the slow-path.\n+      Label monitor_found;\n+\n+      \/\/ Load cache address\n+      lea(t, Address(thread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        cmpptr(obj, Address(t));\n+        jccb(Assembler::equal, monitor_found);\n+        increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      Label loop;\n+\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      cmpptr(obj, Address(t));\n+      jccb(Assembler::equal, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      cmpptr(Address(t), 1);\n+      jcc(Assembler::below, slow_path); \/\/ 0 check, but with ZF=0 when *t == 0\n+      increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+      jmpb(loop);\n+\n+      \/\/ Cache hit.\n+      bind(monitor_found);\n+      movptr(monitor, Address(t, OMCache::oop_to_monitor_difference()));\n+    }\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address recursions_address(monitor, ObjectMonitor::recursions_offset() - monitor_tag);\n+    const Address owner_address(monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+\n+    Label monitor_locked;\n+    \/\/ Lock the monitor.\n@@ -647,2 +697,2 @@\n-    lock(); cmpxchgptr(thread, Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-    jccb(Assembler::equal, locked);\n+    lock(); cmpxchgptr(thread, owner_address);\n+    jccb(Assembler::equal, monitor_locked);\n@@ -655,1 +705,7 @@\n-    increment(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+    increment(recursions_address);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      \/\/ Cache the monitor for unlock\n+      movptr(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), monitor);\n+    }\n@@ -697,1 +753,3 @@\n-  const Register top = reg_rax;\n+  const Register monitor = t;\n+  const Register top = UseObjectMonitorTable ? t : reg_rax;\n+  const Register box = reg_rax;\n@@ -709,0 +767,1 @@\n+  Label& slow_path = stub == nullptr ? dummy : stub->slow_path();\n@@ -715,2 +774,4 @@\n-    \/\/ Prefetch mark.\n-    movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    if (!UseObjectMonitorTable) {\n+      \/\/ Prefetch mark.\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n@@ -733,0 +794,5 @@\n+    if (UseObjectMonitorTable) {\n+      \/\/ Load mark.\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n+\n@@ -754,0 +820,3 @@\n+    if (UseObjectMonitorTable) {\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n@@ -761,13 +830,14 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register monitor = mark;\n-\n-#ifndef _LP64\n-    \/\/ Check if recursive.\n-    xorptr(reg_rax, reg_rax);\n-    orptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-    jcc(Assembler::notZero, check_successor);\n-\n-    \/\/ Check if the entry lists are empty.\n-    movptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-    orptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-    jcc(Assembler::notZero, check_successor);\n+    if (!UseObjectMonitorTable) {\n+      assert(mark == monitor, \"should be the same here\");\n+    } else {\n+      \/\/ Uses ObjectMonitorTable.  Look for the monitor in our BasicLock on the stack.\n+      movptr(monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ null check with ZF == 0, no valid pointer below alignof(ObjectMonitor*)\n+      cmpptr(monitor, alignof(ObjectMonitor*));\n+      jcc(Assembler::below, slow_path);\n+    }\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address recursions_address{monitor, ObjectMonitor::recursions_offset() - monitor_tag};\n+    const Address cxq_address{monitor, ObjectMonitor::cxq_offset() - monitor_tag};\n+    const Address EntryList_address{monitor, ObjectMonitor::EntryList_offset() - monitor_tag};\n+    const Address owner_address{monitor, ObjectMonitor::owner_offset() - monitor_tag};\n@@ -775,3 +845,0 @@\n-    \/\/ Release lock.\n-    movptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n-#else \/\/ _LP64\n@@ -781,1 +848,1 @@\n-    cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 0);\n+    cmpptr(recursions_address, 0);\n@@ -785,2 +852,2 @@\n-    movptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-    orptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+    movptr(reg_rax, cxq_address);\n+    orptr(reg_rax, EntryList_address);\n@@ -790,1 +857,1 @@\n-    movptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n+    movptr(owner_address, NULL_WORD);\n@@ -795,1 +862,1 @@\n-    decrement(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+    decrement(recursions_address);\n@@ -797,1 +864,0 @@\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":100,"deletions":34,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-static const int native_invoker_code_base_size = 512;\n-static const int native_invoker_size_per_arg = 8;\n+static const int native_invoker_code_base_size = 256;\n+static const int native_invoker_size_per_arg = 16;\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1178,2 +1178,1 @@\n-      movl(tmp_reg, Address(tmp_reg, Klass::access_flags_offset()));\n-      testl(tmp_reg, JVM_ACC_IS_VALUE_BASED_CLASS);\n+      testb(Address(tmp_reg, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n@@ -1186,0 +1185,1 @@\n+      lightweight_lock(lock_reg, obj_reg, swap_reg, thread, tmp_reg, slow_case);\n@@ -1187,2 +1187,2 @@\n-      const Register thread = lock_reg;\n-      get_thread(thread);\n+      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+      jmp(slow_case);\n@@ -1190,1 +1190,0 @@\n-      lightweight_lock(obj_reg, swap_reg, thread, tmp_reg, slow_case);\n@@ -1252,9 +1251,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-              obj_reg);\n-    } else {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-              lock_reg);\n-    }\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+            lock_reg);\n@@ -1309,4 +1302,2 @@\n-      \/\/ This relies on the implementation of lightweight_unlock being able to handle\n-      \/\/ that the reg_rax and thread Register parameters may alias each other.\n-      get_thread(swap_reg);\n-      lightweight_unlock(obj_reg, swap_reg, swap_reg, header_reg, slow_case);\n+      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+      jmp(slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":9,"deletions":18,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1306,1 +1306,1 @@\n-  jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+  jump(RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n@@ -10278,1 +10278,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register reg_rax, Register thread, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register reg_rax, Register thread, Register tmp, Label& slow) {\n@@ -10280,1 +10280,1 @@\n-  assert_different_registers(obj, reg_rax, thread, tmp);\n+  assert_different_registers(basic_lock, obj, reg_rax, thread, tmp);\n@@ -10289,0 +10289,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    movptr(Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))), 0);\n+  }\n+\n@@ -10327,3 +10332,0 @@\n-\/\/\n-\/\/ x86_32 Note: reg_rax and thread may alias each other due to limited register\n-\/\/              availiability.\n@@ -10332,2 +10334,1 @@\n-  assert_different_registers(obj, reg_rax, tmp);\n-  LP64_ONLY(assert_different_registers(obj, reg_rax, thread, tmp);)\n+  assert_different_registers(obj, reg_rax, thread, tmp);\n@@ -10373,4 +10374,0 @@\n-  if (thread == reg_rax) {\n-    \/\/ On x86_32 we may lose the thread.\n-    get_thread(thread);\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2151,1 +2151,1 @@\n-  void lightweight_lock(Register obj, Register reg_rax, Register thread, Register tmp, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register reg_rax, Register thread, Register tmp, Label& slow);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-  __ jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));\n+  __ jump(RuntimeAddress(SharedRuntime::throw_AbstractMethodError_entry()));\n@@ -513,1 +513,1 @@\n-      __ jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));\n+      __ jump(RuntimeAddress(SharedRuntime::throw_IncompatibleClassChangeError_entry()));\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,3 +65,5 @@\n-    \/\/ check if monitor\n-    __ testptr(result, markWord::monitor_value);\n-    __ jcc(Assembler::notZero, slowCase);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ check if monitor\n+      __ testptr(result, markWord::monitor_value);\n+      __ jcc(Assembler::notZero, slowCase);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -59,0 +60,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif \/\/ PRODUCT\n+\n@@ -1689,1 +1696,2 @@\n-      __ lightweight_lock(obj_reg, swap_reg, thread, lock_reg, slow_path_lock);\n+      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+      __ jmp(slow_path_lock);\n@@ -2057,1 +2065,2 @@\n-  CodeBuffer   buffer(\"deopt_blob\", 1536, 1024);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  CodeBuffer   buffer(name, 1536, 1024);\n@@ -2398,1 +2407,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n@@ -2405,0 +2414,1 @@\n+  assert(is_polling_page_id(id), \"expected a polling page stub id\");\n@@ -2412,1 +2422,2 @@\n-  CodeBuffer   buffer(\"handler_blob\", 2048, 1024);\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBuffer   buffer(name, 2048, 1024);\n@@ -2418,2 +2429,2 @@\n-  bool cause_return = (poll_type == POLL_AT_RETURN);\n-  bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);\n+  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n+  bool save_vectors = (id == SharedStubId::polling_page_vectors_safepoint_handler_id);\n@@ -2551,1 +2562,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n@@ -2553,0 +2564,1 @@\n+  assert(is_resolve_id(id), \"expected a resolve stub id\");\n@@ -2557,0 +2569,1 @@\n+  const char* name = SharedRuntime::stub_name(id);\n@@ -2633,0 +2646,209 @@\n+\n+  \/\/------------------------------------------------------------------------------------------------------------------------\n+  \/\/ Continuation point for throwing of implicit exceptions that are not handled in\n+  \/\/ the current activation. Fabricates an exception oop and initiates normal\n+  \/\/ exception dispatching in this frame.\n+  \/\/\n+  \/\/ Previously the compiler (c2) allowed for callee save registers on Java calls.\n+  \/\/ This is no longer true after adapter frames were removed but could possibly\n+  \/\/ be brought back in the future if the interpreter code was reworked and it\n+  \/\/ was deemed worthwhile. The comment below was left to describe what must\n+  \/\/ happen here if callee saves were resurrected. As it stands now this stub\n+  \/\/ could actually be a vanilla BufferBlob and have now oopMap at all.\n+  \/\/ Since it doesn't make much difference we've chosen to leave it the\n+  \/\/ way it was in the callee save days and keep the comment.\n+\n+  \/\/ If we need to preserve callee-saved values we need a callee-saved oop map and\n+  \/\/ therefore have to make these stubs into RuntimeStubs rather than BufferBlobs.\n+  \/\/ If the compiler needs all registers to be preserved between the fault\n+  \/\/ point and the exception handler then it must assume responsibility for that in\n+  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+  \/\/ continuation_for_implicit_division_by_zero_exception. All other implicit\n+  \/\/ exceptions (e.g., NullPointerException or AbstractMethodError on entry) are\n+  \/\/ either at call sites or otherwise assume that stack unwinding will be initiated,\n+  \/\/ so caller saved registers were assumed volatile in the compiler.\n+RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+  assert(is_throw_id(id), \"expected a throw stub id\");\n+\n+  const char* name = SharedRuntime::stub_name(id);\n+\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  enum layout {\n+    thread_off,    \/\/ last_java_sp\n+    arg1_off,\n+    arg2_off,\n+    rbp_off,       \/\/ callee saved register\n+    ret_pc,\n+    framesize\n+  };\n+\n+  int insts_size = 256;\n+  int locs_size  = 32;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+  Register java_thread = rbx;\n+  __ get_thread(java_thread);\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ pc and rbp, already pushed\n+  __ subptr(rsp, (framesize-2) * wordSize); \/\/ prolog\n+\n+  \/\/ Frame is now completed as far as size and linkage.\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ push java thread (becomes first argument of C function)\n+  __ movptr(Address(rsp, thread_off * wordSize), java_thread);\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  __ set_last_Java_frame(java_thread, rsp, rbp, nullptr, noreg);\n+\n+  \/\/ Call runtime\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ call(RuntimeAddress(runtime_entry));\n+  \/\/ Generate oop map\n+  OopMap* map =  new OopMap(framesize, 0);\n+  oop_maps->add_gc_map(__ pc() - start, map);\n+\n+  \/\/ restore the thread (cannot use the pushed argument since arguments\n+  \/\/ may be overwritten by C code generated by an optimizing compiler);\n+  \/\/ however can use the register value directly if it is callee saved.\n+  __ get_thread(java_thread);\n+\n+  __ reset_last_Java_frame(java_thread, true);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n+  __ jcc(Assembler::notEqual, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/* ASSERT *\/\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+\n+  RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete, framesize, oop_maps, false);\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+static void jfr_prologue(address the_pc, MacroAssembler* masm) {\n+  Register java_thread = rdi;\n+  __ get_thread(java_thread);\n+  __ set_last_Java_frame(java_thread, rsp, rbp, the_pc, noreg);\n+  __ movptr(Address(rsp, 0), java_thread);\n+}\n+\n+\/\/ The handle is dereferenced through a load barrier.\n+static void jfr_epilogue(MacroAssembler* masm) {\n+  Register java_thread = rdi;\n+  __ get_thread(java_thread);\n+  __ reset_last_Java_frame(java_thread, true);\n+}\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    FPUState_off         = 0,\n+    rbp_off              = FPUStateSizeInWords,\n+    rdi_off,\n+    rsi_off,\n+    rcx_off,\n+    rbx_off,\n+    saved_argument_off,\n+    saved_argument_off2, \/\/ 2nd half of double\n+    framesize\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+  jfr_epilogue(masm);\n+  __ resolve_global_jobject(rax, rdi, rdx);\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    FPUState_off = 0,\n+    rbp_off = FPUStateSizeInWords,\n+    rdi_off,\n+    rsi_off,\n+    rcx_off,\n+    rbx_off,\n+    saved_argument_off,\n+    saved_argument_off2, \/\/ 2nd half of double\n+    framesize\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  jfr_epilogue(masm);\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":229,"deletions":7,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -73,0 +74,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif \/\/ PRODUCT\n+\n@@ -2269,1 +2276,1 @@\n-      __ lightweight_lock(obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n+      __ lightweight_lock(lock_reg, obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n@@ -2619,1 +2626,2 @@\n-  CodeBuffer buffer(\"deopt_blob\", 2560+pad, 1024);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  CodeBuffer buffer(name, 2560+pad, 1024);\n@@ -2977,1 +2985,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n@@ -2980,0 +2988,1 @@\n+  assert(is_polling_page_id(id), \"expected a polling page stub id\");\n@@ -2986,1 +2995,2 @@\n-  CodeBuffer buffer(\"handler_blob\", 2348, 1024);\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBuffer buffer(name, 2348, 1024);\n@@ -2992,2 +3002,2 @@\n-  bool cause_return = (poll_type == POLL_AT_RETURN);\n-  bool save_wide_vectors = (poll_type == POLL_AT_VECTOR_LOOP);\n+  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n+  bool save_wide_vectors = (id == SharedStubId::polling_page_vectors_safepoint_handler_id);\n@@ -3136,1 +3146,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n@@ -3138,0 +3148,1 @@\n+  assert(is_resolve_id(id), \"expected a resolve stub id\");\n@@ -3142,0 +3153,1 @@\n+  const char* name = SharedRuntime::stub_name(id);\n@@ -3213,0 +3225,99 @@\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Since we need to preserve callee-saved values (currently\n+\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+\/\/ map and therefore have to make these stubs into RuntimeStubs\n+\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+\/\/ be preserved between the fault point and the exception handler\n+\/\/ then it must assume responsibility for that in\n+\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+  assert(is_throw_id(id), \"expected a throw stub id\");\n+\n+  const char* name = SharedRuntime::stub_name(id);\n+\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  enum layout {\n+    rbp_off = frame::arg_reg_save_area_bytes\/BytesPerInt,\n+    rbp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 512;\n+  int locs_size  = 64;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n+\n+  \/\/ return address and rbp are already in place\n+  __ subptr(rsp, (framesize-4) << LogBytesPerInt); \/\/ prolog\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n+  __ andptr(rsp, -(StackAlignmentInBytes));    \/\/ Align stack\n+\n+  \/\/ Call runtime\n+  __ movptr(c_rarg0, r15_thread);\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ call(RuntimeAddress(runtime_entry));\n+\n+  \/\/ Generate oop map\n+  OopMap* map = new OopMap(framesize, 0);\n+\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n+  __ jcc(Assembler::notEqual, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/\/ ASSERT\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+\n+  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n@@ -3478,0 +3589,93 @@\n+#if INCLUDE_JFR\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  CodeBuffer code(name, 1024, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  address start = __ pc();\n+\n+  __ enter();\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n+  __ movptr(c_rarg0, r15_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+  __ reset_last_Java_frame(true);\n+\n+  \/\/ rax is jobject handle result, unpack and process it through a barrier.\n+  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  CodeBuffer code(name, 1024, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  address start = __ pc();\n+\n+  __ enter();\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch2);\n+  __ movptr(c_rarg0, r15_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":211,"deletions":7,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -3846,14 +3846,0 @@\n- public:\n-  \/\/ Information about frame layout at time of blocking runtime call.\n-  \/\/ Note that we only have to preserve callee-saved registers since\n-  \/\/ the compilers are responsible for supplying a continuation point\n-  \/\/ if they expect all registers to be preserved.\n-  enum layout {\n-    thread_off,    \/\/ last_java_sp\n-    arg1_off,\n-    arg2_off,\n-    rbp_off,       \/\/ callee saved register\n-    ret_pc,\n-    framesize\n-  };\n-\n@@ -3862,99 +3848,0 @@\n-#undef  __\n-#define __ masm->\n-\n-  \/\/------------------------------------------------------------------------------------------------------------------------\n-  \/\/ Continuation point for throwing of implicit exceptions that are not handled in\n-  \/\/ the current activation. Fabricates an exception oop and initiates normal\n-  \/\/ exception dispatching in this frame.\n-  \/\/\n-  \/\/ Previously the compiler (c2) allowed for callee save registers on Java calls.\n-  \/\/ This is no longer true after adapter frames were removed but could possibly\n-  \/\/ be brought back in the future if the interpreter code was reworked and it\n-  \/\/ was deemed worthwhile. The comment below was left to describe what must\n-  \/\/ happen here if callee saves were resurrected. As it stands now this stub\n-  \/\/ could actually be a vanilla BufferBlob and have now oopMap at all.\n-  \/\/ Since it doesn't make much difference we've chosen to leave it the\n-  \/\/ way it was in the callee save days and keep the comment.\n-\n-  \/\/ If we need to preserve callee-saved values we need a callee-saved oop map and\n-  \/\/ therefore have to make these stubs into RuntimeStubs rather than BufferBlobs.\n-  \/\/ If the compiler needs all registers to be preserved between the fault\n-  \/\/ point and the exception handler then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other implicit\n-  \/\/ exceptions (e.g., NullPointerException or AbstractMethodError on entry) are\n-  \/\/ either at call sites or otherwise assume that stack unwinding will be initiated,\n-  \/\/ so caller saved registers were assumed volatile in the compiler.\n-  address generate_throw_exception(const char* name, address runtime_entry,\n-                                   Register arg1 = noreg, Register arg2 = noreg) {\n-\n-    int insts_size = 256;\n-    int locs_size  = 32;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-    Register java_thread = rbx;\n-    __ get_thread(java_thread);\n-\n-    __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-    \/\/ pc and rbp, already pushed\n-    __ subptr(rsp, (framesize-2) * wordSize); \/\/ prolog\n-\n-    \/\/ Frame is now completed as far as size and linkage.\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ push java thread (becomes first argument of C function)\n-    __ movptr(Address(rsp, thread_off * wordSize), java_thread);\n-    if (arg1 != noreg) {\n-      __ movptr(Address(rsp, arg1_off * wordSize), arg1);\n-    }\n-    if (arg2 != noreg) {\n-      assert(arg1 != noreg, \"missing reg arg\");\n-      __ movptr(Address(rsp, arg2_off * wordSize), arg2);\n-    }\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    __ set_last_Java_frame(java_thread, rsp, rbp, nullptr, noreg);\n-\n-    \/\/ Call runtime\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ call(RuntimeAddress(runtime_entry));\n-    \/\/ Generate oop map\n-    OopMap* map =  new OopMap(framesize, 0);\n-    oop_maps->add_gc_map(__ pc() - start, map);\n-\n-    \/\/ restore the thread (cannot use the pushed argument since arguments\n-    \/\/ may be overwritten by C code generated by an optimizing compiler);\n-    \/\/ however can use the register value directly if it is callee saved.\n-    __ get_thread(java_thread);\n-\n-    __ reset_last_Java_frame(java_thread, true);\n-\n-    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n-    __ jcc(Assembler::notEqual, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/* ASSERT *\/\n-    __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-\n-    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete, framesize, oop_maps, false);\n-    return stub->entry_point();\n-  }\n-\n-\n@@ -4000,103 +3887,0 @@\n-#if INCLUDE_JFR\n-\n-  static void jfr_prologue(address the_pc, MacroAssembler* masm) {\n-    Register java_thread = rdi;\n-    __ get_thread(java_thread);\n-    __ set_last_Java_frame(java_thread, rsp, rbp, the_pc, noreg);\n-    __ movptr(Address(rsp, 0), java_thread);\n-  }\n-\n-  \/\/ The handle is dereferenced through a load barrier.\n-  static void jfr_epilogue(MacroAssembler* masm) {\n-    Register java_thread = rdi;\n-    __ get_thread(java_thread);\n-    __ reset_last_Java_frame(java_thread, true);\n-  }\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      FPUState_off         = 0,\n-      rbp_off              = FPUStateSizeInWords,\n-      rdi_off,\n-      rsi_off,\n-      rcx_off,\n-      rbx_off,\n-      saved_argument_off,\n-      saved_argument_off2, \/\/ 2nd half of double\n-      framesize\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-    jfr_epilogue(_masm);\n-    __ resolve_global_jobject(rax, rdi, rdx);\n-    __ leave();\n-    __ ret(0);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      FPUState_off = 0,\n-      rbp_off = FPUStateSizeInWords,\n-      rdi_off,\n-      rsi_off,\n-      rcx_off,\n-      rbx_off,\n-      saved_argument_off,\n-      saved_argument_off2, \/\/ 2nd half of double\n-      framesize\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-    jfr_epilogue(_masm);\n-    __ leave();\n-    __ ret(0);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -4133,6 +3917,0 @@\n-    \/\/ Build this early so it's available for the interpreter\n-    StubRoutines::_throw_StackOverflowError_entry          = generate_throw_exception(\"StackOverflowError throw_exception\",\n-                                                                                      CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));\n-    StubRoutines::_throw_delayed_StackOverflowError_entry  = generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                                                                                      CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError));\n-\n@@ -4191,2 +3969,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n@@ -4195,9 +3971,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-  }\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -4207,6 +3974,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in non-core builds\n-    \/\/ and need to be relocatable, so they each fabricate a RuntimeStub internally.\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":0,"deletions":239,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -48,3 +48,0 @@\n-#if INCLUDE_JFR\n-#include \"jfr\/support\/jfrIntrinsics.hpp\"\n-#endif\n@@ -3705,1 +3702,1 @@\n-  __ jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  __ jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -3781,192 +3778,0 @@\n-#if INCLUDE_JFR\n-\n-\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-\/\/ It returns a jobject handle to the event writer.\n-\/\/ The handle is dereferenced and the return value is the event writer oop.\n-RuntimeStub* StubGenerator::generate_jfr_write_checkpoint() {\n-  enum layout {\n-    rbp_off,\n-    rbpH_off,\n-    return_off,\n-    return_off2,\n-    framesize \/\/ inclusive of return address\n-  };\n-\n-  CodeBuffer code(\"jfr_write_checkpoint\", 1024, 64);\n-  MacroAssembler* _masm = new MacroAssembler(&code);\n-  address start = __ pc();\n-\n-  __ enter();\n-  address the_pc = __ pc();\n-\n-  int frame_complete = the_pc - start;\n-\n-  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n-  __ movptr(c_rarg0, r15_thread);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-  __ reset_last_Java_frame(true);\n-\n-  \/\/ rax is jobject handle result, unpack and process it through a barrier.\n-  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n-\n-  __ leave();\n-  __ ret(0);\n-\n-  OopMapSet* oop_maps = new OopMapSet();\n-  OopMap* map = new OopMap(framesize, 1);\n-  oop_maps->add_gc_map(frame_complete, map);\n-\n-  RuntimeStub* stub =\n-    RuntimeStub::new_runtime_stub(code.name(),\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps,\n-                                  false);\n-  return stub;\n-}\n-\n-\/\/ For c2: call to return a leased buffer.\n-RuntimeStub* StubGenerator::generate_jfr_return_lease() {\n-  enum layout {\n-    rbp_off,\n-    rbpH_off,\n-    return_off,\n-    return_off2,\n-    framesize \/\/ inclusive of return address\n-  };\n-\n-  CodeBuffer code(\"jfr_return_lease\", 1024, 64);\n-  MacroAssembler* _masm = new MacroAssembler(&code);\n-  address start = __ pc();\n-\n-  __ enter();\n-  address the_pc = __ pc();\n-\n-  int frame_complete = the_pc - start;\n-\n-  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch2);\n-  __ movptr(c_rarg0, r15_thread);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-  __ reset_last_Java_frame(true);\n-\n-  __ leave();\n-  __ ret(0);\n-\n-  OopMapSet* oop_maps = new OopMapSet();\n-  OopMap* map = new OopMap(framesize, 1);\n-  oop_maps->add_gc_map(frame_complete, map);\n-\n-  RuntimeStub* stub =\n-    RuntimeStub::new_runtime_stub(code.name(),\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps,\n-                                  false);\n-  return stub;\n-}\n-\n-#endif \/\/ INCLUDE_JFR\n-\n-\/\/ Continuation point for throwing of implicit exceptions that are\n-\/\/ not handled in the current activation. Fabricates an exception\n-\/\/ oop and initiates normal exception dispatching in this\n-\/\/ frame. Since we need to preserve callee-saved values (currently\n-\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-\/\/ map and therefore have to make these stubs into RuntimeStubs\n-\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-\/\/ be preserved between the fault point and the exception handler\n-\/\/ then it must assume responsibility for that in\n-\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-\/\/ continuation_for_implicit_division_by_zero_exception. All other\n-\/\/ implicit exceptions (e.g., NullPointerException or\n-\/\/ AbstractMethodError on entry) are either at call sites or\n-\/\/ otherwise assume that stack unwinding will be initiated, so\n-\/\/ caller saved registers were assumed volatile in the compiler.\n-address StubGenerator::generate_throw_exception(const char* name,\n-                                                address runtime_entry,\n-                                                Register arg1,\n-                                                Register arg2) {\n-  \/\/ Information about frame layout at time of blocking runtime call.\n-  \/\/ Note that we only have to preserve callee-saved registers since\n-  \/\/ the compilers are responsible for supplying a continuation point\n-  \/\/ if they expect all registers to be preserved.\n-  enum layout {\n-    rbp_off = frame::arg_reg_save_area_bytes\/BytesPerInt,\n-    rbp_off2,\n-    return_off,\n-    return_off2,\n-    framesize \/\/ inclusive of return address\n-  };\n-\n-  int insts_size = 512;\n-  int locs_size  = 64;\n-\n-  CodeBuffer code(name, insts_size, locs_size);\n-  OopMapSet* oop_maps  = new OopMapSet();\n-  MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-  address start = __ pc();\n-\n-  \/\/ This is an inlined and slightly modified version of call_VM\n-  \/\/ which has the ability to fetch the return PC out of\n-  \/\/ thread-local storage and also sets up last_Java_sp slightly\n-  \/\/ differently than the real call_VM\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n-\n-  \/\/ return address and rbp are already in place\n-  __ subptr(rsp, (framesize-4) << LogBytesPerInt); \/\/ prolog\n-\n-  int frame_complete = __ pc() - start;\n-\n-  \/\/ Set up last_Java_sp and last_Java_fp\n-  address the_pc = __ pc();\n-  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n-  __ andptr(rsp, -(StackAlignmentInBytes));    \/\/ Align stack\n-\n-  \/\/ Call runtime\n-  if (arg1 != noreg) {\n-    assert(arg2 != c_rarg1, \"clobbered\");\n-    __ movptr(c_rarg1, arg1);\n-  }\n-  if (arg2 != noreg) {\n-    __ movptr(c_rarg2, arg2);\n-  }\n-  __ movptr(c_rarg0, r15_thread);\n-  BLOCK_COMMENT(\"call runtime_entry\");\n-  __ call(RuntimeAddress(runtime_entry));\n-\n-  \/\/ Generate oop map\n-  OopMap* map = new OopMap(framesize, 0);\n-\n-  oop_maps->add_gc_map(the_pc - start, map);\n-\n-  __ reset_last_Java_frame(true);\n-\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  \/\/ check for pending exceptions\n-#ifdef ASSERT\n-  Label L;\n-  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n-  __ jcc(Assembler::notEqual, L);\n-  __ should_not_reach_here();\n-  __ bind(L);\n-#endif \/\/ ASSERT\n-  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-\n-  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-  RuntimeStub* stub =\n-    RuntimeStub::new_runtime_stub(name,\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps, false);\n-  return stub->entry_point();\n-}\n-\n@@ -4090,11 +3895,0 @@\n-  \/\/ Build this early so it's available for the interpreter.\n-  StubRoutines::_throw_StackOverflowError_entry =\n-    generate_throw_exception(\"StackOverflowError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_StackOverflowError));\n-  StubRoutines::_throw_delayed_StackOverflowError_entry =\n-    generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_delayed_StackOverflowError));\n@@ -4134,2 +3928,0 @@\n-\n-  JFR_ONLY(generate_jfr_stubs();)\n@@ -4138,9 +3930,0 @@\n-#if INCLUDE_JFR\n-void StubGenerator::generate_jfr_stubs() {\n-  StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-  StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-  StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-  StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-}\n-#endif\n-\n@@ -4150,21 +3933,0 @@\n-  \/\/ These entry points require SharedInfo::stack0 to be set up in\n-  \/\/ non-core builds and need to be relocatable, so they each\n-  \/\/ fabricate a RuntimeStub internally.\n-  StubRoutines::_throw_AbstractMethodError_entry =\n-    generate_throw_exception(\"AbstractMethodError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_AbstractMethodError));\n-\n-  StubRoutines::_throw_IncompatibleClassChangeError_entry =\n-    generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_IncompatibleClassChangeError));\n-\n-  StubRoutines::_throw_NullPointerException_at_call_entry =\n-    generate_throw_exception(\"NullPointerException at call throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_NullPointerException_at_call));\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":239,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -589,10 +589,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs();\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  RuntimeStub* generate_jfr_write_checkpoint();\n-  \/\/ For c2: call to runtime to return a buffer lease.\n-  RuntimeStub* generate_jfr_return_lease();\n-#endif \/\/ INCLUDE_JFR\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -548,2 +548,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  __ jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  __ jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2582,2 +2582,1 @@\n-    __ movl(rdi, Address(rdi, Klass::access_flags_offset()));\n-    __ testl(rdi, JVM_ACC_HAS_FINALIZER);\n+    __ testb(Address(rdi, Klass::misc_flags_offset()), KlassFlags::_misc_has_finalizer);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6391,1 +6391,1 @@\n-instruct cmovL_imm_01(rRegL dst, immI_1 src, rFlagsReg cr, cmpOp cop)\n+instruct cmovL_imm_01(rRegL dst, immL1 src, rFlagsReg cr, cmpOp cop)\n@@ -6429,1 +6429,1 @@\n-instruct cmovL_imm_01U(rRegL dst, immI_1 src, rFlagsRegU cr, cmpOpU cop)\n+instruct cmovL_imm_01U(rRegL dst, immL1 src, rFlagsRegU cr, cmpOpU cop)\n@@ -6455,1 +6455,1 @@\n-instruct cmovL_imm_01UCF(rRegL dst, immI_1 src, rFlagsRegUCF cr, cmpOpUCF cop)\n+instruct cmovL_imm_01UCF(rRegL dst, immL1 src, rFlagsRegUCF cr, cmpOpUCF cop)\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-static RuntimeStub* generate_empty_runtime_stub(const char* name) {\n+static RuntimeStub* generate_empty_runtime_stub() {\n@@ -104,1 +104,0 @@\n-\n@@ -109,1 +108,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n@@ -113,2 +112,6 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {\n-  return generate_empty_runtime_stub(\"resolve_blob\");\n+RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n+  return generate_empty_runtime_stub();\n+}\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+  return generate_empty_runtime_stub();\n@@ -130,0 +133,12 @@\n+\n+#if INCLUDE_JFR\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  return nullptr;\n+}\n+\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  return nullptr;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -206,16 +206,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in\n-    \/\/ non-core builds and need to be relocatable, so they each\n-    \/\/ fabricate a RuntimeStub internally.\n-    StubRoutines::_throw_AbstractMethodError_entry =\n-      ShouldNotCallThisStub();\n-\n-    StubRoutines::_throw_NullPointerException_at_call_entry =\n-      ShouldNotCallThisStub();\n-\n-    StubRoutines::_throw_StackOverflowError_entry =\n-      ShouldNotCallThisStub();\n-\n-    \/\/ support for verify_oop (must happen after universe_init)\n-    StubRoutines::_verify_oop_subroutine_entry =\n-      ShouldNotCallThisStub();\n-\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -47,0 +48,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -334,13 +336,15 @@\n-    markWord disp = lockee->mark().set_unlocked();\n-    monitor->lock()->set_displaced_header(disp);\n-    bool call_vm = (LockingMode == LM_MONITOR);\n-    bool inc_monitor_count = true;\n-    if (call_vm || lockee->cas_set_mark(markWord::from_pointer(monitor), disp) != disp) {\n-      \/\/ Is it simple recursive case?\n-      if (!call_vm && thread->is_lock_owned((address) disp.clear_lock_bits().to_pointer())) {\n-        monitor->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-      } else {\n-        inc_monitor_count = false;\n-        CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));\n-        if (HAS_PENDING_EXCEPTION)\n-          goto unwind_and_return;\n+    bool success = false;\n+    if (LockingMode == LM_LEGACY) {\n+      markWord disp = lockee->mark().set_unlocked();\n+      monitor->lock()->set_displaced_header(disp);\n+      success = true;\n+      if (lockee->cas_set_mark(markWord::from_pointer(monitor), disp) != disp) {\n+        \/\/ Is it simple recursive case?\n+        if (thread->is_lock_owned((address) disp.clear_lock_bits().to_pointer())) {\n+          monitor->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+        } else {\n+          success = false;\n+        }\n+      }\n+      if (success) {\n+        THREAD->inc_held_monitor_count();\n@@ -349,2 +353,4 @@\n-    if (inc_monitor_count) {\n-      THREAD->inc_held_monitor_count();\n+    if (!success) {\n+      CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));\n+          if (HAS_PENDING_EXCEPTION)\n+            goto unwind_and_return;\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -476,3 +476,3 @@\n-#ifdef STATIC_BUILD\n-    strcat(buf, \"\/lib\");\n-#endif\n+    if (is_vm_statically_linked()) {\n+      strcat(buf, \"\/lib\");\n+    }\n@@ -1096,3 +1096,4 @@\n-#ifdef STATIC_BUILD\n-  return os::get_default_process_handle();\n-#else\n+  if (is_vm_statically_linked()) {\n+    return os::get_default_process_handle();\n+  }\n+\n@@ -1102,1 +1103,0 @@\n-#endif \/\/ STATIC_BUILD\n@@ -1106,3 +1106,4 @@\n-#ifdef STATIC_BUILD\n-  return os::get_default_process_handle();\n-#else\n+  if (is_vm_statically_linked()) {\n+    return os::get_default_process_handle();\n+  }\n+\n@@ -1272,1 +1273,0 @@\n-#endif \/\/ STATIC_BUILD\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -612,1 +612,1 @@\n-  char* s_path = subsystem_path();\n+  const char* s_path = subsystem_path();\n@@ -682,1 +682,1 @@\n-  char* s_path = subsystem_path();\n+  const char* s_path = subsystem_path();\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,0 +106,3 @@\n+  protected:\n+    char* _cgroup_path;\n+    char* _mount_point;\n@@ -107,1 +110,1 @@\n-    virtual char* subsystem_path() = 0;\n+    virtual const char* subsystem_path() = 0;\n@@ -109,0 +112,3 @@\n+    const char* cgroup_path() { return _cgroup_path; }\n+    const char* mount_point() { return _mount_point; }\n+    virtual bool needs_hierarchy_adjustment() { return false; }\n@@ -205,0 +211,1 @@\n+    virtual bool needs_hierarchy_adjustment() = 0;\n@@ -206,0 +213,4 @@\n+    virtual const char* subsystem_path() = 0;\n+    virtual void set_subsystem_path(const char* cgroup_path) = 0;\n+    virtual const char* mount_point() = 0;\n+    virtual const char* cgroup_path() = 0;\n@@ -220,0 +231,1 @@\n+    virtual bool needs_hierarchy_adjustment() = 0;\n@@ -221,0 +233,4 @@\n+    virtual const char* subsystem_path() = 0;\n+    virtual void set_subsystem_path(const char* cgroup_path) = 0;\n+    virtual const char* mount_point() = 0;\n+    virtual const char* cgroup_path() = 0;\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"os_linux.hpp\"\n@@ -49,0 +50,110 @@\n+\n+void CgroupUtil::adjust_controller(CgroupMemoryController* mem) {\n+  if (!mem->needs_hierarchy_adjustment()) {\n+    \/\/ nothing to do\n+    return;\n+  }\n+  log_trace(os, container)(\"Adjusting controller path for memory: %s\", mem->subsystem_path());\n+  assert(mem->cgroup_path() != nullptr, \"invariant\");\n+  char* orig = os::strdup(mem->cgroup_path());\n+  char* cg_path = os::strdup(orig);\n+  char* last_slash;\n+  assert(cg_path[0] == '\/', \"cgroup path must start with '\/'\");\n+  julong phys_mem = os::Linux::physical_memory();\n+  char* limit_cg_path = nullptr;\n+  jlong limit = mem->read_memory_limit_in_bytes(phys_mem);\n+  jlong lowest_limit = phys_mem;\n+  while ((last_slash = strrchr(cg_path, '\/')) != cg_path) {\n+    *last_slash = '\\0'; \/\/ strip path\n+    \/\/ update to shortened path and try again\n+    mem->set_subsystem_path(cg_path);\n+    limit = mem->read_memory_limit_in_bytes(phys_mem);\n+    if (limit >= 0 && limit < lowest_limit) {\n+      lowest_limit = limit;\n+      os::free(limit_cg_path); \/\/ handles nullptr\n+      limit_cg_path = os::strdup(cg_path);\n+    }\n+  }\n+  \/\/ need to check limit at mount point\n+  mem->set_subsystem_path(\"\/\");\n+  limit = mem->read_memory_limit_in_bytes(phys_mem);\n+  if (limit >= 0 && limit < lowest_limit) {\n+    lowest_limit = limit;\n+    os::free(limit_cg_path); \/\/ handles nullptr\n+    limit_cg_path = os::strdup(\"\/\");\n+  }\n+  assert(lowest_limit >= 0, \"limit must be positive\");\n+  if ((julong)lowest_limit != phys_mem) {\n+    \/\/ we've found a lower limit anywhere in the hierarchy,\n+    \/\/ set the path to the limit path\n+    assert(limit_cg_path != nullptr, \"limit path must be set\");\n+    mem->set_subsystem_path(limit_cg_path);\n+    log_trace(os, container)(\"Adjusted controller path for memory to: %s. \"\n+                             \"Lowest limit was: \" JLONG_FORMAT,\n+                             mem->subsystem_path(),\n+                             lowest_limit);\n+  } else {\n+    log_trace(os, container)(\"No lower limit found for memory in hierarchy %s, \"\n+                             \"adjusting to original path %s\",\n+                              mem->mount_point(), orig);\n+    mem->set_subsystem_path(orig);\n+  }\n+  os::free(cg_path);\n+  os::free(orig);\n+  os::free(limit_cg_path);\n+}\n+\n+void CgroupUtil::adjust_controller(CgroupCpuController* cpu) {\n+  if (!cpu->needs_hierarchy_adjustment()) {\n+    \/\/ nothing to do\n+    return;\n+  }\n+  log_trace(os, container)(\"Adjusting controller path for cpu: %s\", cpu->subsystem_path());\n+  assert(cpu->cgroup_path() != nullptr, \"invariant\");\n+  char* orig = os::strdup(cpu->cgroup_path());\n+  char* cg_path = os::strdup(orig);\n+  char* last_slash;\n+  assert(cg_path[0] == '\/', \"cgroup path must start with '\/'\");\n+  int host_cpus = os::Linux::active_processor_count();\n+  int cpus = CgroupUtil::processor_count(cpu, host_cpus);\n+  int lowest_limit = host_cpus;\n+  char* limit_cg_path = nullptr;\n+  while ((last_slash = strrchr(cg_path, '\/')) != cg_path) {\n+    *last_slash = '\\0'; \/\/ strip path\n+    \/\/ update to shortened path and try again\n+    cpu->set_subsystem_path(cg_path);\n+    cpus = CgroupUtil::processor_count(cpu, host_cpus);\n+    if (cpus != host_cpus && cpus < lowest_limit) {\n+      lowest_limit = cpus;\n+      os::free(limit_cg_path); \/\/ handles nullptr\n+      limit_cg_path = os::strdup(cg_path);\n+    }\n+  }\n+  \/\/ need to check limit at mount point\n+  cpu->set_subsystem_path(\"\/\");\n+  cpus = CgroupUtil::processor_count(cpu, host_cpus);\n+  if (cpus != host_cpus && cpus < lowest_limit) {\n+    lowest_limit = cpus;\n+    os::free(limit_cg_path); \/\/ handles nullptr\n+    limit_cg_path = os::strdup(cg_path);\n+  }\n+  assert(lowest_limit >= 0, \"limit must be positive\");\n+  if (lowest_limit != host_cpus) {\n+    \/\/ we've found a lower limit anywhere in the hierarchy,\n+    \/\/ set the path to the limit path\n+    assert(limit_cg_path != nullptr, \"limit path must be set\");\n+    cpu->set_subsystem_path(limit_cg_path);\n+    log_trace(os, container)(\"Adjusted controller path for cpu to: %s. \"\n+                             \"Lowest limit was: %d\",\n+                             cpu->subsystem_path(),\n+                             lowest_limit);\n+  } else {\n+    log_trace(os, container)(\"No lower limit found for cpu in hierarchy %s, \"\n+                             \"adjusting to original path %s\",\n+                              cpu->mount_point(), orig);\n+    cpu->set_subsystem_path(orig);\n+  }\n+  os::free(cg_path);\n+  os::free(orig);\n+  os::free(limit_cg_path);\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":111,"deletions":0,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -35,0 +35,6 @@\n+    \/\/ Given a memory controller, adjust its path to a point in the hierarchy\n+    \/\/ that represents the closest memory limit.\n+    static void adjust_controller(CgroupMemoryController* m);\n+    \/\/ Given a cpu controller, adjust its path to a point in the hierarchy\n+    \/\/ that represents the closest cpu limit.\n+    static void adjust_controller(CgroupCpuController* c);\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,9 @@\n-void CgroupV1Controller::set_subsystem_path(char *cgroup_path) {\n+void CgroupV1Controller::set_subsystem_path(const char* cgroup_path) {\n+  if (_cgroup_path != nullptr) {\n+    os::free(_cgroup_path);\n+  }\n+  if (_path != nullptr) {\n+    os::free(_path);\n+    _path = nullptr;\n+  }\n+  _cgroup_path = os::strdup(cgroup_path);\n@@ -55,1 +63,1 @@\n-        char *p = strstr(cgroup_path, _root);\n+        char *p = strstr((char*)cgroup_path, _root);\n@@ -69,8 +77,5 @@\n-\/* uses_mem_hierarchy\n- *\n- * Return whether or not hierarchical cgroup accounting is being\n- * done.\n- *\n- * return:\n- *    A number > 0 if true, or\n- *    OSCONTAINER_ERROR for not supported\n+\/*\n+ * The common case, containers, we have _root == _cgroup_path, and thus set the\n+ * controller path to the _mount_point. This is where the limits are exposed in\n+ * the cgroup pseudo filesystem (at the leaf) and adjustment of the path won't\n+ * be needed for that reason.\n@@ -78,12 +83,3 @@\n-jlong CgroupV1MemoryController::uses_mem_hierarchy() {\n-  julong use_hierarchy;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n-  return (jlong)use_hierarchy;\n-}\n-\n-void CgroupV1MemoryController::set_subsystem_path(char *cgroup_path) {\n-  reader()->set_subsystem_path(cgroup_path);\n-  jlong hierarchy = uses_mem_hierarchy();\n-  if (hierarchy > 0) {\n-    set_hierarchical(true);\n-  }\n+bool CgroupV1Controller::needs_hierarchy_adjustment() {\n+  assert(_cgroup_path != nullptr, \"sanity\");\n+  return strcmp(_root, _cgroup_path) != 0;\n@@ -118,14 +114,0 @@\n-    log_trace(os, container)(\"Non-Hierarchical Memory Limit is: Unlimited\");\n-    if (is_hierarchical()) {\n-      julong hier_memlimit;\n-      bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"hierarchical_memory_limit\", &hier_memlimit);\n-      if (!is_ok) {\n-        return OSCONTAINER_ERROR;\n-      }\n-      log_trace(os, container)(\"Hierarchical Memory Limit is: \" JULONG_FORMAT, hier_memlimit);\n-      if (hier_memlimit < phys_mem) {\n-        verbose_log(hier_memlimit, phys_mem);\n-        return (jlong)hier_memlimit;\n-      }\n-      log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n-    }\n@@ -153,1 +135,0 @@\n-  julong hier_memswlimit;\n@@ -157,16 +138,1 @@\n-    log_trace(os, container)(\"Non-Hierarchical Memory and Swap Limit is: Unlimited\");\n-    if (is_hierarchical()) {\n-      const char* matchline = \"hierarchical_memsw_limit\";\n-      bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\",\n-                                                           matchline,\n-                                                           &hier_memswlimit);\n-      if (!is_ok) {\n-        return OSCONTAINER_ERROR;\n-      }\n-      log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: \" JULONG_FORMAT, hier_memswlimit);\n-      if (hier_memswlimit >= host_total_memsw) {\n-        log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n-      } else {\n-        return (jlong)hier_memswlimit;\n-      }\n-    }\n+    log_trace(os, container)(\"Memory and Swap Limit is: Unlimited\");\n@@ -236,0 +202,15 @@\n+\/\/ Constructor\n+CgroupV1Subsystem::CgroupV1Subsystem(CgroupV1Controller* cpuset,\n+                      CgroupV1CpuController* cpu,\n+                      CgroupV1Controller* cpuacct,\n+                      CgroupV1Controller* pids,\n+                      CgroupV1MemoryController* memory) :\n+    _cpuset(cpuset),\n+    _cpuacct(cpuacct),\n+    _pids(pids) {\n+  CgroupUtil::adjust_controller(memory);\n+  CgroupUtil::adjust_controller(cpu);\n+  _memory = new CachingCgroupController<CgroupMemoryController>(memory);\n+  _cpu = new CachingCgroupController<CgroupCpuController>(cpu);\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":34,"deletions":53,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -38,1 +39,0 @@\n-    char* _mount_point;\n@@ -48,1 +48,0 @@\n-                                  _mount_point(os::strdup(mountpoint)),\n@@ -51,0 +50,2 @@\n+      _cgroup_path = nullptr;\n+      _mount_point = os::strdup(mountpoint);\n@@ -54,1 +55,0 @@\n-                                                      _mount_point(o._mount_point),\n@@ -57,0 +57,2 @@\n+      _cgroup_path = o._cgroup_path;\n+      _mount_point = o._mount_point;\n@@ -63,2 +65,2 @@\n-    void set_subsystem_path(char *cgroup_path);\n-    char *subsystem_path() override { return _path; }\n+    void set_subsystem_path(const char *cgroup_path);\n+    const char* subsystem_path() override { return _path; }\n@@ -66,0 +68,1 @@\n+    bool needs_hierarchy_adjustment() override;\n@@ -74,2 +77,3 @@\n-    bool is_hierarchical() { return _uses_mem_hierarchy; }\n-    void set_subsystem_path(char *cgroup_path);\n+    void set_subsystem_path(const char *cgroup_path) override {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n@@ -88,0 +92,3 @@\n+    bool needs_hierarchy_adjustment() override {\n+      return reader()->needs_hierarchy_adjustment();\n+    }\n@@ -91,0 +98,3 @@\n+    const char* subsystem_path() override { return reader()->subsystem_path(); }\n+    const char* mount_point() override { return reader()->mount_point(); }\n+    const char* cgroup_path() override { return reader()->cgroup_path(); }\n@@ -92,6 +102,0 @@\n-    \/* Some container runtimes set limits via cgroup\n-     * hierarchy. If set to true consider also memory.stat\n-     * file if everything else seems unlimited *\/\n-    bool _uses_mem_hierarchy;\n-    jlong uses_mem_hierarchy();\n-    void set_hierarchical(bool value) { _uses_mem_hierarchy = value; }\n@@ -103,2 +107,1 @@\n-      : _reader(reader),\n-        _uses_mem_hierarchy(false) {\n+      : _reader(reader) {\n@@ -118,1 +121,1 @@\n-    void set_subsystem_path(char *cgroup_path) {\n+    void set_subsystem_path(const char *cgroup_path) override {\n@@ -124,0 +127,10 @@\n+    const char* subsystem_path() override {\n+      return reader()->subsystem_path();\n+    }\n+    const char* mount_point() override {\n+      return reader()->mount_point();\n+    }\n+    bool needs_hierarchy_adjustment() override {\n+      return reader()->needs_hierarchy_adjustment();\n+    }\n+    const char* cgroup_path() override { return reader()->cgroup_path(); }\n@@ -133,0 +146,6 @@\n+    CgroupV1Subsystem(CgroupV1Controller* cpuset,\n+                      CgroupV1CpuController* cpu,\n+                      CgroupV1Controller* cpuacct,\n+                      CgroupV1Controller* pids,\n+                      CgroupV1MemoryController* memory);\n+\n@@ -158,12 +177,0 @@\n-  public:\n-    CgroupV1Subsystem(CgroupV1Controller* cpuset,\n-                      CgroupV1CpuController* cpu,\n-                      CgroupV1Controller* cpuacct,\n-                      CgroupV1Controller* pids,\n-                      CgroupV1MemoryController* memory) :\n-      _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n-      _cpuset(cpuset),\n-      _cpu(new CachingCgroupController<CgroupCpuController>(cpu)),\n-      _cpuacct(cpuacct),\n-      _pids(pids) {\n-    }\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":35,"deletions":28,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -28,0 +28,16 @@\n+\/\/ Constructor\n+CgroupV2Controller::CgroupV2Controller(char* mount_path,\n+                                       char *cgroup_path,\n+                                       bool ro) :  _read_only(ro),\n+                                                   _path(construct_path(mount_path, cgroup_path)) {\n+  _cgroup_path = os::strdup(cgroup_path);\n+  _mount_point = os::strdup(mount_path);\n+}\n+\/\/ Shallow copy constructor\n+CgroupV2Controller::CgroupV2Controller(const CgroupV2Controller& o) :\n+                                            _read_only(o._read_only),\n+                                            _path(o._path) {\n+  _cgroup_path = o._cgroup_path;\n+  _mount_point = o._mount_point;\n+}\n+\n@@ -98,0 +114,11 @@\n+\/\/ Constructor\n+CgroupV2Subsystem::CgroupV2Subsystem(CgroupV2MemoryController * memory,\n+                                     CgroupV2CpuController* cpu,\n+                                     CgroupV2Controller unified) :\n+                                     _unified(unified) {\n+  CgroupUtil::adjust_controller(memory);\n+  CgroupUtil::adjust_controller(cpu);\n+  _memory = new CachingCgroupController<CgroupMemoryController>(memory);\n+  _cpu = new CachingCgroupController<CgroupCpuController>(cpu);\n+}\n+\n@@ -267,0 +294,12 @@\n+void CgroupV2Controller::set_subsystem_path(const char* cgroup_path) {\n+  if (_path != nullptr) {\n+    os::free(_path);\n+  }\n+  _path = construct_path(_mount_point, cgroup_path);\n+}\n+\n+\/\/ For cgv2 we only need hierarchy walk if the cgroup path isn't '\/' (root)\n+bool CgroupV2Controller::needs_hierarchy_adjustment() {\n+  return strcmp(_cgroup_path, \"\/\") != 0;\n+}\n+\n@@ -275,1 +314,1 @@\n-char* CgroupV2Controller::construct_path(char* mount_path, char *cgroup_path) {\n+char* CgroupV2Controller::construct_path(char* mount_path, const char* cgroup_path) {\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -32,4 +33,0 @@\n-    \/* the mount path of the cgroup v2 hierarchy *\/\n-    char *_mount_path;\n-    \/* The cgroup path for the controller *\/\n-    char *_cgroup_path;\n@@ -40,1 +37,1 @@\n-    static char* construct_path(char* mount_path, char *cgroup_path);\n+    static char* construct_path(char* mount_path, const char *cgroup_path);\n@@ -43,7 +40,1 @@\n-    CgroupV2Controller(char* mount_path,\n-                       char *cgroup_path,\n-                       bool ro) :  _mount_path(os::strdup(mount_path)),\n-                                   _cgroup_path(os::strdup(cgroup_path)),\n-                                   _read_only(ro),\n-                                   _path(construct_path(mount_path, cgroup_path)) {\n-    }\n+    CgroupV2Controller(char* mount_path, char *cgroup_path, bool ro);\n@@ -51,6 +42,1 @@\n-    CgroupV2Controller(const CgroupV2Controller& o) :\n-                                            _mount_path(o._mount_path),\n-                                            _cgroup_path(o._cgroup_path),\n-                                            _read_only(o._read_only),\n-                                            _path(o._path) {\n-    }\n+    CgroupV2Controller(const CgroupV2Controller& o);\n@@ -61,1 +47,4 @@\n-    char *subsystem_path() override { return _path; }\n+    const char* subsystem_path() override { return _path; }\n+    bool needs_hierarchy_adjustment() override;\n+    \/\/ Allow for optional updates of the subsystem path\n+    void set_subsystem_path(const char* cgroup_path);\n@@ -78,0 +67,11 @@\n+    const char* subsystem_path() {\n+      return reader()->subsystem_path();\n+    }\n+    bool needs_hierarchy_adjustment() override {\n+      return reader()->needs_hierarchy_adjustment();\n+    }\n+    void set_subsystem_path(const char* cgroup_path) {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n+    const char* mount_point() { return reader()->mount_point(); }\n+    const char* cgroup_path() override { return reader()->cgroup_path(); }\n@@ -100,0 +100,11 @@\n+    const char* subsystem_path() {\n+      return reader()->subsystem_path();\n+    }\n+    bool needs_hierarchy_adjustment() override {\n+      return reader()->needs_hierarchy_adjustment();\n+    }\n+    void set_subsystem_path(const char* cgroup_path) {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n+    const char* mount_point() { return reader()->mount_point(); }\n+    const char* cgroup_path() override { return reader()->cgroup_path(); }\n@@ -113,1 +124,1 @@\n-    CgroupV2Subsystem(CgroupV2MemoryController* memory,\n+    CgroupV2Subsystem(CgroupV2MemoryController * memory,\n@@ -115,5 +126,1 @@\n-                      CgroupV2Controller unified) :\n-        _unified(unified),\n-        _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n-        _cpu(new CachingCgroupController<CgroupCpuController>(cpu)) {\n-    }\n+                      CgroupV2Controller unified);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":32,"deletions":25,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-  \/*  NB: The default value of UseLinuxPosixThreadCPUClocks may be   *\/ \\\n-  \/* overridden in Arguments::parse_each_vm_init_arg.                *\/ \\\n@@ -44,1 +42,1 @@\n-          \"enable fast Linux Posix clocks where available\")             \\\n+          \"(Deprecated) enable fast Linux Posix clocks where available\") \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-  friend class CgroupSubsystem;\n@@ -35,1 +34,0 @@\n-  friend class OSContainer;\n@@ -61,1 +59,0 @@\n-  static int active_processor_count();\n@@ -96,0 +93,1 @@\n+  static int active_processor_count();\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,1 +22,1 @@\n- *  \n+ *\n@@ -132,1 +132,1 @@\n-  probe CallNonvirtualVoidMethodV__entry(void*, void*, void*, uintptr_t);  \n+  probe CallNonvirtualVoidMethodV__entry(void*, void*, void*, uintptr_t);\n@@ -203,2 +203,2 @@\n-  probe CallStaticVoidMethod__return(); \n-  probe CallStaticVoidMethodV__entry(void*, void*, uintptr_t);  \n+  probe CallStaticVoidMethod__return();\n+  probe CallStaticVoidMethodV__entry(void*, void*, uintptr_t);\n@@ -206,1 +206,1 @@\n-  probe CallVoidMethodA__entry(void*, void*, uintptr_t);  \n+  probe CallVoidMethodA__entry(void*, void*, uintptr_t);\n@@ -208,3 +208,3 @@\n-  probe CallVoidMethod__entry(void*, void*, uintptr_t);  \n-  probe CallVoidMethod__return(); \n-  probe CallVoidMethodV__entry(void*, void*, uintptr_t);  \n+  probe CallVoidMethod__entry(void*, void*, uintptr_t);\n+  probe CallVoidMethod__return();\n+  probe CallVoidMethodV__entry(void*, void*, uintptr_t);\n@@ -232,1 +232,1 @@\n-  probe ExceptionDescribe__entry(void*);  \n+  probe ExceptionDescribe__entry(void*);\n@@ -355,0 +355,2 @@\n+  probe GetStringUTFLengthAsLong__entry(void*, void*);\n+  probe GetStringUTFLengthAsLong__return(uintptr_t);\n@@ -391,1 +393,1 @@\n-  probe NewObjectA__entry(void*, void*, uintptr_t);  \n+  probe NewObjectA__entry(void*, void*, uintptr_t);\n@@ -395,1 +397,1 @@\n-  probe NewObject__entry(void*, void*, uintptr_t); \n+  probe NewObject__entry(void*, void*, uintptr_t);\n@@ -397,1 +399,1 @@\n-  probe NewObjectV__entry(void*, void*, uintptr_t);  \n+  probe NewObjectV__entry(void*, void*, uintptr_t);\n@@ -411,1 +413,1 @@\n-  probe RegisterNatives__entry(void*, void*, const void*, uint32_t);  \n+  probe RegisterNatives__entry(void*, void*, const void*, uint32_t);\n@@ -493,2 +495,2 @@\n-  probe ThrowNew__entry(void*, void*, const char*);  \n-  probe ThrowNew__return(intptr_t);  \n+  probe ThrowNew__entry(void*, void*, const char*);\n+  probe ThrowNew__return(intptr_t);\n@@ -499,1 +501,1 @@\n-  probe UnregisterNatives__entry(void*, void*);  \n+  probe UnregisterNatives__entry(void*, void*);\n@@ -508,1 +510,0 @@\n-\n","filename":"src\/hotspot\/os\/posix\/dtrace\/hotspot_jni.d","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-    _snprintf(msg, sizeof(msg), \"%d\\n\", result);\n+    os::snprintf(msg, sizeof(msg), \"%d\\n\", result);\n","filename":"src\/hotspot\/os\/windows\/attachListener_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1779,3 +1779,3 @@\n-    ::_snprintf(ebuf, ebuflen - 1,\n-                \"Can't load %s-bit .dll on a %s-bit platform\",\n-                lib_arch_str, running_arch_str);\n+    os::snprintf(ebuf, ebuflen - 1,\n+                 \"Can't load %s-bit .dll on a %s-bit platform\",\n+                 lib_arch_str, running_arch_str);\n@@ -1784,3 +1784,3 @@\n-    ::_snprintf(ebuf, ebuflen - 1,\n-                \"Can't load this .dll (machine code=0x%x) on a %s-bit platform\",\n-                lib_arch, running_arch_str);\n+    os::snprintf(ebuf, ebuflen - 1,\n+                 \"Can't load this .dll (machine code=0x%x) on a %s-bit platform\",\n+                 lib_arch, running_arch_str);\n@@ -5744,0 +5744,6 @@\n+\/\/ Platform Mutex\/Monitor implementation\n+\n+PlatformMutex::PlatformMutex() {\n+  InitializeCriticalSection(&_mutex);\n+}\n+\n@@ -5748,1 +5754,7 @@\n-\/\/ Platform Monitor implementation\n+PlatformMonitor::PlatformMonitor() {\n+  InitializeConditionVariable(&_cond);\n+}\n+\n+PlatformMonitor::~PlatformMonitor() {\n+  \/\/ There is no DeleteConditionVariable API\n+}\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+  address original_sp = sp;\n@@ -58,0 +59,4 @@\n+  StackOverflow* state = JavaThread::current()->stack_overflow_state();\n+  assert(original_sp > state->shadow_zone_safe_limit(), \"original_sp=\" INTPTR_FORMAT \", \"\n+         \"shadow_zone_safe_limit=\" INTPTR_FORMAT, p2i(original_sp), p2i(state->shadow_zone_safe_limit()));\n+  state->set_shadow_zone_growth_watermark(original_sp);\n@@ -64,12 +69,0 @@\n-inline PlatformMutex::PlatformMutex() {\n-  InitializeCriticalSection(&_mutex);\n-}\n-\n-inline PlatformMonitor::PlatformMonitor() {\n-  InitializeConditionVariable(&_cond);\n-}\n-\n-inline PlatformMonitor::~PlatformMonitor() {\n-  \/\/ There is no DeleteConditionVariable API\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,1 @@\n-  _snprintf(dirname, nbytes, \"%s\\\\%s_%s\", tmpdir, perfdir, user);\n+  os::snprintf(dirname, nbytes, \"%s\\\\%s_%s\", tmpdir, perfdir, user);\n@@ -458,1 +458,1 @@\n-  _snprintf(name, nbytes, \"%s_%s_%u\", PERFDATA_NAME, user, vmid);\n+  os::snprintf(name, nbytes, \"%s_%s_%u\", PERFDATA_NAME, user, vmid);\n@@ -474,1 +474,1 @@\n-  _snprintf(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n+  os::snprintf(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n","filename":"src\/hotspot\/os\/windows\/perfMemory_windows.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+  assert(requested_size <= SIZE_MAX - length, \"overflow\");\n@@ -132,0 +133,1 @@\n+  assert(items <= SIZE_MAX \/ x, \"overflow\");\n@@ -139,0 +141,5 @@\n+static size_t pointer_delta(const void *left, const void *right) {\n+  assert(left >= right, \"pointer delta underflow\");\n+  return (uintptr_t)left - (uintptr_t)right;\n+}\n+\n@@ -142,6 +149,0 @@\n-  \/\/ Stupid fast special case\n-  if( new_size <= old_size ) {  \/\/ Shrink in-place\n-    if( c_old+old_size == _hwm) \/\/ Attempt to free the excess bytes\n-      _hwm = c_old+new_size;    \/\/ Adjust hwm\n-    return c_old;\n-  }\n@@ -149,5 +150,11 @@\n-  \/\/ See if we can resize in-place\n-  if( (c_old+old_size == _hwm) &&       \/\/ Adjusting recent thing\n-      (c_old+new_size <= _max) ) {      \/\/ Still fits where it sits\n-    _hwm = c_old+new_size;      \/\/ Adjust hwm\n-    return c_old;               \/\/ Return old pointer\n+  \/\/ Reallocating the latest allocation?\n+  if (c_old + old_size == _hwm) {\n+    assert(_chunk->bottom() <= c_old, \"invariant\");\n+\n+    \/\/ Reallocate in place if it fits. Also handles shrinking\n+    if (pointer_delta(_max, c_old) >= new_size) {\n+      _hwm = c_old + new_size;\n+      return c_old;\n+    }\n+  } else if (new_size <= old_size) { \/\/ Shrink in place\n+    return c_old;\n","filename":"src\/hotspot\/share\/adlc\/adlArena.cpp","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,1 @@\n+    assert(x <= SIZE_MAX - (8-1), \"overflow\");\n@@ -110,0 +111,1 @@\n+    assert(x <= SIZE_MAX - (4-1), \"overflow\");\n","filename":"src\/hotspot\/share\/adlc\/adlArena.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1392,0 +1392,5 @@\n+  if (next_bci() >= method()->code_size()) {\n+    \/\/ This can happen if the subroutine does not terminate with a ret,\n+    \/\/ effectively turning the jsr into a goto.\n+    BAILOUT(\"too-complicated jsr\/ret structure\");\n+  }\n@@ -1566,1 +1571,1 @@\n-       (scope()->wrote_final() ||\n+       (scope()->wrote_final() || scope()->wrote_stable() ||\n@@ -1744,4 +1749,0 @@\n-  if (field->is_final() && (code == Bytecodes::_putfield)) {\n-    scope()->set_wrote_final();\n-  }\n-\n@@ -1753,0 +1754,6 @@\n+    if (field->is_final()) {\n+      scope()->set_wrote_final();\n+    }\n+    if (field->is_stable()) {\n+      scope()->set_wrote_stable();\n+    }\n@@ -2117,1 +2124,1 @@\n-    assert(!target->can_be_statically_bound() || target == cha_monomorphic_target, \"\");\n+    assert(!target->can_be_statically_bound() || target->equals(cha_monomorphic_target), \"\");\n@@ -3737,0 +3744,3 @@\n+  if (next_bci() >= method()->code_size()) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  _wrote_stable       = false;\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+  bool          _wrote_stable;                   \/\/ has written @Stable field\n@@ -190,0 +191,2 @@\n+  void          set_wrote_stable()               { _wrote_stable = true; }\n+  bool          wrote_stable() const             { return _wrote_stable; }\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -760,2 +760,2 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT || obj == lock->obj(), \"must match\");\n-  SharedRuntime::monitor_enter_helper(obj, LockingMode == LM_LIGHTWEIGHT ? nullptr : lock->lock(), current);\n+  assert(obj == lock->obj(), \"must match\");\n+  SharedRuntime::monitor_enter_helper(obj, lock->lock(), current);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,0 +115,6 @@\n+  \/\/ The minimum region size of all collectors that are supported by CDS in\n+  \/\/ ArchiveHeapLoader::can_map() mode. Currently only G1 is supported. G1's region size\n+  \/\/ depends on -Xmx, but can never be smaller than 1 * M.\n+  \/\/ (TODO: Perhaps change to 256K to be compatible with Shenandoah)\n+  static constexpr int MIN_GC_REGION_ALIGNMENT = 1 * M;\n+\n@@ -122,6 +128,0 @@\n-  \/\/ The minimum region size of all collectors that are supported by CDS in\n-  \/\/ ArchiveHeapLoader::can_map() mode. Currently only G1 is supported. G1's region size\n-  \/\/ depends on -Xmx, but can never be smaller than 1 * M.\n-  \/\/ (TODO: Perhaps change to 256K to be compatible with Shenandoah)\n-  static constexpr int MIN_GC_REGION_ALIGNMENT = 1 * M;\n-\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -466,1 +466,1 @@\n-    if (!UTF8::is_legal_utf8((const unsigned char*)class_name, (int)len, \/*version_leq_47*\/false)) {\n+    if (!UTF8::is_legal_utf8((const unsigned char*)class_name, len, \/*version_leq_47*\/false)) {\n@@ -852,1 +852,0 @@\n-\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -271,1 +271,0 @@\n-  st->print_cr(\"- narrow_oop_base:                \" INTPTR_FORMAT, p2i(_narrow_oop_base));\n@@ -2028,1 +2027,1 @@\n-        log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC or UseParallelGC are required.\");\n+        log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC, UseParallelGC, or UseShenandoahGC are required.\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1647,24 +1647,0 @@\n-#ifndef PRODUCT\n-ResourceBitMap HeapShared::calculate_oopmap(MemRegion region) {\n-  size_t num_bits = region.byte_size() \/ (UseCompressedOops ? sizeof(narrowOop) : sizeof(oop));\n-  ResourceBitMap oopmap(num_bits);\n-\n-  HeapWord* p   = region.start();\n-  HeapWord* end = region.end();\n-  FindEmbeddedNonNullPointers finder((void*)p, &oopmap);\n-\n-  int num_objs = 0;\n-  while (p < end) {\n-    oop o = cast_to_oop(p);\n-    o->oop_iterate(&finder);\n-    p += o->size();\n-    ++ num_objs;\n-  }\n-\n-  log_info(cds, heap)(\"calculate_oopmap: objects = %6d, oop fields = %7d (nulls = %7d)\",\n-                      num_objs, finder.num_total_oops(), finder.num_null_oops());\n-  return oopmap;\n-}\n-\n-#endif \/\/ !PRODUCT\n-\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -374,3 +374,0 @@\n-#ifndef PRODUCT\n-  static ResourceBitMap calculate_oopmap(MemRegion region); \/\/ marks all the oop pointers\n-#endif\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-  _has_finalizer = access_flags.has_finalizer();\n+  _has_finalizer = ik->has_finalizer();\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,0 +229,9 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciKlass::misc_flags\n+klass_flags_t ciKlass::misc_flags() {\n+  assert(is_loaded(), \"not loaded\");\n+  GUARDED_VM_ENTRY(\n+    return get_Klass()->misc_flags();\n+  )\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,0 +124,3 @@\n+  \/\/ Fetch Klass::misc_flags.\n+  klass_flags_t          misc_flags();\n+\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -784,0 +784,16 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciMethod::equals\n+\/\/\n+\/\/ Returns true if the methods are the same, taking redefined methods\n+\/\/ into account.\n+bool ciMethod::equals(const ciMethod* m) const {\n+  if (this == m) return true;\n+  VM_ENTRY_MARK;\n+  Method* m1 = this->get_Method();\n+  Method* m2 = m->get_Method();\n+  if (m1->is_old()) m1 = m1->get_new_method();\n+  if (m2->is_old()) m2 = m2->get_new_method();\n+  return m1 == m2;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -369,0 +369,2 @@\n+  bool equals(const ciMethod* m) const;\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1355,87 +1355,0 @@\n-\/\/ Field allocation types. Used for computing field offsets.\n-\n-enum FieldAllocationType {\n-  STATIC_OOP,           \/\/ Oops\n-  STATIC_BYTE,          \/\/ Boolean, Byte, char\n-  STATIC_SHORT,         \/\/ shorts\n-  STATIC_WORD,          \/\/ ints\n-  STATIC_DOUBLE,        \/\/ aligned long or double\n-  NONSTATIC_OOP,\n-  NONSTATIC_BYTE,\n-  NONSTATIC_SHORT,\n-  NONSTATIC_WORD,\n-  NONSTATIC_DOUBLE,\n-  MAX_FIELD_ALLOCATION_TYPE,\n-  BAD_ALLOCATION_TYPE = -1\n-};\n-\n-static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {\n-  BAD_ALLOCATION_TYPE, \/\/ 0\n-  BAD_ALLOCATION_TYPE, \/\/ 1\n-  BAD_ALLOCATION_TYPE, \/\/ 2\n-  BAD_ALLOCATION_TYPE, \/\/ 3\n-  NONSTATIC_BYTE ,     \/\/ T_BOOLEAN     =  4,\n-  NONSTATIC_SHORT,     \/\/ T_CHAR        =  5,\n-  NONSTATIC_WORD,      \/\/ T_FLOAT       =  6,\n-  NONSTATIC_DOUBLE,    \/\/ T_DOUBLE      =  7,\n-  NONSTATIC_BYTE,      \/\/ T_BYTE        =  8,\n-  NONSTATIC_SHORT,     \/\/ T_SHORT       =  9,\n-  NONSTATIC_WORD,      \/\/ T_INT         = 10,\n-  NONSTATIC_DOUBLE,    \/\/ T_LONG        = 11,\n-  NONSTATIC_OOP,       \/\/ T_OBJECT      = 12,\n-  NONSTATIC_OOP,       \/\/ T_ARRAY       = 13,\n-  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 14,\n-  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 15,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 16,\n-  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 17,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 18,\n-  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 19,\n-  BAD_ALLOCATION_TYPE, \/\/ 0\n-  BAD_ALLOCATION_TYPE, \/\/ 1\n-  BAD_ALLOCATION_TYPE, \/\/ 2\n-  BAD_ALLOCATION_TYPE, \/\/ 3\n-  STATIC_BYTE ,        \/\/ T_BOOLEAN     =  4,\n-  STATIC_SHORT,        \/\/ T_CHAR        =  5,\n-  STATIC_WORD,         \/\/ T_FLOAT       =  6,\n-  STATIC_DOUBLE,       \/\/ T_DOUBLE      =  7,\n-  STATIC_BYTE,         \/\/ T_BYTE        =  8,\n-  STATIC_SHORT,        \/\/ T_SHORT       =  9,\n-  STATIC_WORD,         \/\/ T_INT         = 10,\n-  STATIC_DOUBLE,       \/\/ T_LONG        = 11,\n-  STATIC_OOP,          \/\/ T_OBJECT      = 12,\n-  STATIC_OOP,          \/\/ T_ARRAY       = 13,\n-  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 14,\n-  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 15,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 16,\n-  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 17,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 18,\n-  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 19,\n-};\n-\n-static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {\n-  assert(type >= T_BOOLEAN && type < T_VOID, \"only allowable values\");\n-  FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];\n-  assert(result != BAD_ALLOCATION_TYPE, \"bad type\");\n-  return result;\n-}\n-\n-class ClassFileParser::FieldAllocationCount : public ResourceObj {\n- public:\n-  u2 count[MAX_FIELD_ALLOCATION_TYPE];\n-\n-  FieldAllocationCount() {\n-    for (int i = 0; i < MAX_FIELD_ALLOCATION_TYPE; i++) {\n-      count[i] = 0;\n-    }\n-  }\n-\n-  void update(bool is_static, BasicType type) {\n-    FieldAllocationType atype = basic_type_to_atype(is_static, type);\n-    if (atype != BAD_ALLOCATION_TYPE) {\n-      \/\/ Make sure there is no overflow with injected fields.\n-      assert(count[atype] < 0xFFFF, \"More than 65535 fields\");\n-      count[atype]++;\n-    }\n-  }\n-};\n-\n@@ -1446,1 +1359,0 @@\n-                                   FieldAllocationCount* const fac,\n@@ -1453,1 +1365,0 @@\n-  assert(fac != nullptr, \"invariant\");\n@@ -1547,2 +1458,4 @@\n-    \/\/ Update FieldAllocationCount for this kind of field\n-    fac->update(is_static, type);\n+    \/\/ Update number of static oop fields.\n+    if (is_static && is_reference_type(type)) {\n+      _static_oop_count++;\n+    }\n@@ -1593,4 +1506,0 @@\n-\n-      \/\/ Update FieldAllocationCount for this kind of field\n-      const BasicType type = Signature::basic_type(injected[n].signature());\n-      fac->update(false, type);\n@@ -4562,1 +4471,2 @@\n-  if (!UTF8::is_legal_utf8(buffer, length, _major_version <= 47)) {\n+  \/\/ Note: 0 <= length < 64K, as it comes from a u2 entry in the CP.\n+  if (!UTF8::is_legal_utf8(buffer, static_cast<size_t>(length), _major_version <= 47)) {\n@@ -5119,2 +5029,1 @@\n-  assert(_fac != nullptr, \"invariant\");\n-  ik->set_static_oop_field_count(_fac->count[STATIC_OOP]);\n+  ik->set_static_oop_field_count(_static_oop_count);\n@@ -5176,3 +5085,1 @@\n-  if (_is_hidden) {\n-    ik->set_is_hidden();\n-  }\n+  assert(!_is_hidden || ik->is_hidden(), \"must be set already\");\n@@ -5364,0 +5271,1 @@\n+  _static_oop_count(0),\n@@ -5384,1 +5292,0 @@\n-  _fac(nullptr),\n@@ -5710,1 +5617,0 @@\n-  _fac = new FieldAllocationCount();\n@@ -5713,1 +5619,0 @@\n-               _fac,\n@@ -5871,1 +5776,0 @@\n-  assert(_fac != nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":9,"deletions":105,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -89,1 +89,0 @@\n-  class FieldAllocationCount;\n@@ -119,0 +118,1 @@\n+  unsigned int _static_oop_count;\n@@ -144,1 +144,0 @@\n-  FieldAllocationCount* _fac;\n@@ -263,1 +262,0 @@\n-                    FieldAllocationCount* const fac,\n@@ -552,0 +550,1 @@\n+  bool is_abstract() const { return _access_flags.is_abstract(); }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-\/\/ UTF8::as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, int buflen).\n+\/\/ UTF8::as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, size_t buflen).\n@@ -437,1 +437,1 @@\n-void HashtableTextDump::put_utf8(outputStream* st, const char* utf8_string, int utf8_length) {\n+void HashtableTextDump::put_utf8(outputStream* st, const char* utf8_string, size_t utf8_length) {\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-  static void put_utf8(outputStream* st, const char* utf8_string, int utf8_length);\n+  static void put_utf8(outputStream* st, const char* utf8_string, size_t utf8_length);\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -307,1 +307,2 @@\n-    char* expected = UNICODE::as_utf8(unicode, length);\n+    size_t utf8_len = static_cast<size_t>(length);\n+    char* expected = UNICODE::as_utf8(unicode, utf8_len);\n@@ -349,1 +350,1 @@\n-  if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, (int)strlen(utf8_str), false)) {\n+  if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, strlen(utf8_str), false)) {\n@@ -557,1 +558,1 @@\n-  int result_length;\n+  size_t result_length;\n@@ -569,2 +570,2 @@\n-  assert(result_length >= length + 1, \"must not be shorter\");\n-  assert(result_length == (int)strlen(result) + 1, \"must match\");\n+  assert(result_length >= (size_t)length + 1, \"must not be shorter\");\n+  assert(result_length == strlen(result) + 1, \"must match\");\n@@ -585,2 +586,3 @@\n-    const char* base = UNICODE::as_utf8(position, length);\n-    Symbol* sym = SymbolTable::new_symbol(base, length);\n+    size_t utf8_len = static_cast<size_t>(length);\n+    const char* base = UNICODE::as_utf8(position, utf8_len);\n+    Symbol* sym = SymbolTable::new_symbol(base, checked_cast<int>(utf8_len));\n@@ -601,2 +603,3 @@\n-    const char* base = UNICODE::as_utf8(position, length);\n-    return SymbolTable::probe(base, length);\n+    size_t utf8_len = static_cast<size_t>(length);\n+    const char* base = UNICODE::as_utf8(position, utf8_len);\n+    return SymbolTable::probe(base, checked_cast<int>(utf8_len));\n@@ -606,1 +609,1 @@\n-int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {\n+size_t java_lang_String::utf8_length(oop java_string, typeArrayOop value) {\n@@ -620,1 +623,1 @@\n-int java_lang_String::utf8_length(oop java_string) {\n+size_t java_lang_String::utf8_length(oop java_string) {\n@@ -625,0 +628,19 @@\n+int java_lang_String::utf8_length_as_int(oop java_string) {\n+  typeArrayOop value = java_lang_String::value(java_string);\n+  return utf8_length_as_int(java_string, value);\n+}\n+\n+int java_lang_String::utf8_length_as_int(oop java_string, typeArrayOop value) {\n+  assert(value_equals(value, java_lang_String::value(java_string)),\n+         \"value must be same as java_lang_String::value(java_string)\");\n+  int length = java_lang_String::length(java_string, value);\n+  if (length == 0) {\n+    return 0;\n+  }\n+  if (!java_lang_String::is_latin1(java_string)) {\n+    return UNICODE::utf8_length_as_int(value->char_at_addr(0), length);\n+  } else {\n+    return UNICODE::utf8_length_as_int(value->byte_at_addr(0), length);\n+  }\n+}\n+\n@@ -626,1 +648,1 @@\n-  int length;\n+  size_t length;\n@@ -630,1 +652,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, int& length) {\n+char* java_lang_String::as_utf8_string(oop java_string, size_t& length) {\n@@ -632,0 +654,2 @@\n+  \/\/ `length` is used as the incoming number of characters to\n+  \/\/ convert, and then set as the number of bytes in the UTF8 sequence.\n@@ -645,1 +669,1 @@\n-char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, int buflen, int& utf8_len) {\n+char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, size_t buflen, size_t& utf8_len) {\n@@ -666,1 +690,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {\n+char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, size_t buflen) {\n@@ -680,1 +704,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {\n+char* java_lang_String::as_utf8_string(oop java_string, char* buf, size_t buflen) {\n@@ -686,0 +710,3 @@\n+  \/\/ `length` is used as the incoming number of characters to\n+  \/\/ convert, and then set as the number of bytes in the UTF8 sequence.\n+  size_t  length = static_cast<size_t>(len);\n@@ -691,1 +718,1 @@\n-    return UNICODE::as_utf8(position, len);\n+    return UNICODE::as_utf8(position, length);\n@@ -694,1 +721,1 @@\n-    return UNICODE::as_utf8(position, len);\n+    return UNICODE::as_utf8(position, length);\n@@ -698,1 +725,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen) {\n+char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, size_t buflen) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":46,"deletions":19,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -134,2 +134,5 @@\n-  static int utf8_length(oop java_string);\n-  static int utf8_length(oop java_string, typeArrayOop string_value);\n+  static size_t utf8_length(oop java_string);\n+  static size_t utf8_length(oop java_string, typeArrayOop string_value);\n+  \/\/ Legacy variants that truncate the length if needed\n+  static int    utf8_length_as_int(oop java_string);\n+  static int    utf8_length_as_int(oop java_string, typeArrayOop string_value);\n@@ -139,3 +142,4 @@\n-  static char*  as_utf8_string(oop java_string, int& length);\n-  static char*  as_utf8_string_full(oop java_string, char* buf, int buflen, int& length);\n-  static char*  as_utf8_string(oop java_string, char* buf, int buflen);\n+  \/\/ `length` is set to the length of the utf8 sequence.\n+  static char*  as_utf8_string(oop java_string, size_t& length);\n+  static char*  as_utf8_string_full(oop java_string, char* buf, size_t buflen, size_t& length);\n+  static char*  as_utf8_string(oop java_string, char* buf, size_t buflen);\n@@ -143,2 +147,2 @@\n-  static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);\n-  static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);\n+  static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, size_t buflen);\n+  static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, size_t buflen);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -75,1 +75,3 @@\n-  char* module_name = java_lang_String::as_utf8_string(name_oop, len);\n+  size_t utf8_len;\n+  char* module_name = java_lang_String::as_utf8_string(name_oop, utf8_len);\n+  len = checked_cast<int>(utf8_len); \/\/ module names are < 64K\n@@ -87,1 +89,1 @@\n-  int len;\n+  size_t len;\n@@ -89,1 +91,1 @@\n-  return SymbolTable::new_symbol(str, len);\n+  return SymbolTable::new_symbol(str, checked_cast<int>(len));\n@@ -145,2 +147,4 @@\n-static const char* as_internal_package(oop package_string, char* buf, int buflen, int& utf8_len) {\n-  char* package_name = java_lang_String::as_utf8_string_full(package_string, buf, buflen, utf8_len);\n+static const char* as_internal_package(oop package_string, char* buf, size_t buflen, int& utf8_len) {\n+  size_t full_utf8_len;\n+  char* package_name = java_lang_String::as_utf8_string_full(package_string, buf, buflen, full_utf8_len);\n+  utf8_len = checked_cast<int>(full_utf8_len); \/\/ package names are < 64K\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -689,1 +689,1 @@\n-    int utf8_length = length;\n+    size_t utf8_length = length;\n@@ -700,1 +700,1 @@\n-    st->print(\"%d: \", utf8_length);\n+    st->print(\"%zu: \", utf8_length);\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -177,1 +177,2 @@\n-        log_trace_symboltable_helper(&value, \"Leaked permanent symbol\");\n+        \/\/ Can't access the symbol after Afree, but we just printed it above.\n+        NOT_PRODUCT(log_trace(symboltable)(\" - Leaked permanent symbol\");)\n@@ -352,0 +353,1 @@\n+  assert(len >= 0, \"negative length %d suggests integer overflow in the caller\", len);\n@@ -464,1 +466,1 @@\n-  int utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n+  size_t utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n@@ -466,1 +468,1 @@\n-  if (utf8_length < (int) sizeof(stack_buf)) {\n+  if (utf8_length < sizeof(stack_buf)) {\n@@ -469,1 +471,1 @@\n-    return new_symbol(chars, utf8_length);\n+    return new_symbol(chars, checked_cast<int>(utf8_length));\n@@ -474,1 +476,1 @@\n-    return new_symbol(chars, utf8_length);\n+    return new_symbol(chars, checked_cast<int>(utf8_length));\n@@ -480,1 +482,1 @@\n-  int utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n+  size_t utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n@@ -482,1 +484,1 @@\n-  if (utf8_length < (int) sizeof(stack_buf)) {\n+  if (utf8_length < sizeof(stack_buf)) {\n@@ -485,1 +487,1 @@\n-    return lookup_only(chars, utf8_length, hash);\n+    return lookup_only(chars, checked_cast<int>(utf8_length), hash);\n@@ -490,1 +492,1 @@\n-    return lookup_only(chars, utf8_length, hash);\n+    return lookup_only(chars, checked_cast<int>(utf8_length), hash);\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -264,1 +264,2 @@\n-  if ((int)strlen(name) > Symbol::max_length()) {\n+  size_t name_len = strlen(name);\n+  if (name_len > static_cast<size_t>(Symbol::max_length())) {\n@@ -266,5 +267,18 @@\n-    \/\/ into the constant pool.\n-    Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n-                       \"Class name exceeds maximum length of %d: %s\",\n-                       Symbol::max_length(),\n-                       name);\n+    \/\/ into the constant pool. If necessary report an abridged name\n+    \/\/ in the exception message.\n+    if (name_len > static_cast<size_t>(MaxStringPrintSize)) {\n+      Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n+                         \"Class name exceeds maximum length of %d: %.*s ... (%zu characters omitted) ... %.*s\",\n+                         Symbol::max_length(),\n+                         MaxStringPrintSize \/ 2,\n+                         name,\n+                         name_len - 2 * (MaxStringPrintSize \/ 2), \/\/ allows for odd value\n+                         MaxStringPrintSize \/ 2,\n+                         name + name_len - MaxStringPrintSize \/ 2);\n+    }\n+    else {\n+      Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n+                         \"Class name exceeds maximum length of %d: %s\",\n+                         Symbol::max_length(),\n+                         name);\n+    }\n@@ -274,1 +288,1 @@\n-  assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false),\n+  assert(UTF8::is_legal_utf8((const unsigned char*)name, name_len, false),\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -277,3 +277,10 @@\n-    \/\/ These are classes loaded from unsupported locations (such as those loaded by JVMTI native\n-    \/\/ agent during dump time).\n-    return warn_excluded(k, \"Unsupported location\");\n+    if (k->name()->starts_with(\"java\/lang\/invoke\/BoundMethodHandle$Species_\")) {\n+      \/\/ This class is dynamically generated by the JDK\n+      ResourceMark rm;\n+      log_info(cds)(\"Skipping %s because it is dynamically generated\", k->name()->as_C_string());\n+      return true; \/\/ exclude without warning\n+    } else {\n+      \/\/ These are classes loaded from unsupported locations (such as those loaded by JVMTI native\n+      \/\/ agent during dump time).\n+      return warn_excluded(k, \"Unsupported location\");\n+    }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  do_klass(IllegalCallerException_klass,                java_lang_IllegalCallerException                      ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -245,0 +245,2 @@\n+    case vmIntrinsics::_Continuation_pin:\n+    case vmIntrinsics::_Continuation_unpin:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -603,0 +603,2 @@\n+  do_intrinsic(_Continuation_pin,          jdk_internal_vm_Continuation, pin_name, void_method_signature, F_SN)         \\\n+  do_intrinsic(_Continuation_unpin,        jdk_internal_vm_Continuation, unpin_name, void_method_signature, F_SN)       \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,0 +206,1 @@\n+  template(java_lang_IllegalCallerException,          \"java\/lang\/IllegalCallerException\")         \\\n@@ -409,0 +410,2 @@\n+  template(pin_name,                                  \"pin\")                                      \\\n+  template(unpin_name,                                \"unpin\")                                    \\\n@@ -589,1 +592,1 @@\n-  template(classloader_string_long_signature,         \"(Ljava\/lang\/ClassLoader;Ljava\/lang\/String;)J\")             \\\n+  template(classloader_class_string_string_long_signature,         \"(Ljava\/lang\/ClassLoader;Ljava\/lang\/Class;Ljava\/lang\/String;Ljava\/lang\/String;)J\")             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -598,0 +598,1 @@\n+  friend class VMStructs;\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-  const size_t min_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3); \/\/ Make sure we have enough space for VM internal code\n+  const size_t min_cache_size = CompilerConfig::min_code_cache_size(); \/\/ Make sure we have enough space for VM internal code\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -896,1 +896,1 @@\n-  _type       = (DepType)(end_marker-1);  \/\/ defeat \"already at end\" assert\n+  _type       = undefined_dependency;  \/\/ defeat \"already at end\" assert\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,0 +106,3 @@\n+    \/\/ _type is initially set to -1, to prevent \"already at end\" assert\n+    undefined_dependency = -1,\n+\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-      int max_count = (ReservedCodeCacheSize - (CodeCacheMinimumUseSpace DEBUG_ONLY(* 3))) \/ (int)buffer_size;\n+      int max_count = (ReservedCodeCacheSize - (int)CompilerConfig::min_code_cache_size()) \/ (int)buffer_size;\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -478,2 +478,1 @@\n-  \/\/ Template Interpreter code is approximately 3X larger in debug builds.\n-  uint min_code_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3);\n+  size_t min_code_cache_size = CompilerConfig::min_code_cache_size();\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -151,0 +151,2 @@\n+  inline static size_t min_code_cache_size();\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,6 @@\n+#ifdef COMPILER1\n+#include \"c1\/c1_Compiler.hpp\"\n+#endif\n+#ifdef COMPILER2\n+#include \"opto\/c2compiler.hpp\"\n+#endif\n@@ -135,0 +141,9 @@\n+inline size_t CompilerConfig::min_code_cache_size() {\n+  size_t min_code_cache_size = CodeCacheMinimumUseSpace;\n+  \/\/ Template Interpreter code is approximately 3X larger in debug builds.\n+  DEBUG_ONLY(min_code_cache_size *= 3);\n+  COMPILER1_PRESENT(min_code_cache_size += Compiler::code_buffer_size());\n+  COMPILER2_PRESENT(min_code_cache_size += C2Compiler::initial_code_buffer_size());\n+  return min_code_cache_size;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.inline.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -788,7 +789,7 @@\n-#ifdef STATIC_BUILD\n-  char* p = strrchr(buf, '\/');\n-  *p = '\\0';\n-  strcat(p, \"\/lib\/\");\n-  lib_offset = jvm_offset = (int)strlen(buf);\n-#else\n-  {\n+\n+  if (is_vm_statically_linked()) {\n+    char* p = strrchr(buf, '\/');\n+    *p = '\\0';\n+    strcat(p, \"\/lib\/\");\n+    lib_offset = jvm_offset = (int)strlen(buf);\n+  } else {\n@@ -808,1 +809,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,0 +225,3 @@\n+          if (bci + Bytecodes::length_for(code) >= method_len) {\n+            break;\n+          }\n@@ -235,0 +238,3 @@\n+          if (bci + Bytecodes::length_for(code) >= method_len) {\n+            break;\n+          }\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -247,0 +247,4 @@\n+  \/\/ The claim size for group cardsets should be smaller to facilitate\n+  \/\/ better work distribution. The group cardsets should be larger than\n+  \/\/ the per region cardsets.\n+  const static uint GroupBucketClaimSize = 4;\n@@ -350,1 +354,9 @@\n-    _table_scanner.set(&_table, BucketClaimSize);\n+    reset_table_scanner(BucketClaimSize);\n+  }\n+\n+  void reset_table_scanner_for_groups() {\n+    reset_table_scanner(GroupBucketClaimSize);\n+  }\n+\n+  void reset_table_scanner(uint claim_size) {\n+    _table_scanner.set(&_table, claim_size);\n@@ -1045,0 +1057,4 @@\n+\n+void G1CardSet::reset_table_scanner_for_groups() {\n+  _table->reset_table_scanner_for_groups();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -383,0 +383,2 @@\n+  void reset_table_scanner_for_groups();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1162,0 +1162,2 @@\n+  _young_regions_cardset_mm(card_set_config(), card_set_freelist_pool()),\n+  _young_regions_cardset(card_set_config(), &_young_regions_cardset_mm),\n@@ -2696,0 +2698,1 @@\n+  hr->install_group_cardset(young_regions_cardset());\n@@ -2905,0 +2908,2 @@\n+      \/\/ Install the group cardset.\n+      new_alloc_region->install_group_cardset(young_regions_cardset());\n@@ -3046,0 +3051,4 @@\n+\n+void G1CollectedHeap::prepare_group_cardsets_for_scan () {\n+  _young_regions_cardset.reset_table_scanner_for_groups();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -782,0 +782,4 @@\n+  \/\/ Group cardsets\n+  G1CardSetMemoryManager _young_regions_cardset_mm;\n+  G1CardSet _young_regions_cardset;\n+\n@@ -783,0 +787,8 @@\n+  G1CardSetConfiguration* card_set_config() { return &_card_set_config; }\n+\n+  G1CardSet* young_regions_cardset() { return &_young_regions_cardset; };\n+\n+  G1CardSetMemoryManager* young_regions_card_set_mm() { return &_young_regions_cardset_mm; }\n+\n+  void prepare_group_cardsets_for_scan();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards);\n+  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards, _g1h->young_regions_cardset()->occupied());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2983,0 +2983,1 @@\n+  _young_cardset_bytes_per_region(0),\n@@ -2993,0 +2994,7 @@\n+  uint num_young_regions = g1h->young_regions_count();\n+  size_t young_cardset_bytes = g1h->young_regions_cardset()->mem_size();\n+\n+  if (num_young_regions > 0) {\n+    _young_cardset_bytes_per_region = young_cardset_bytes \/ num_young_regions;\n+  }\n+\n@@ -3044,0 +3052,4 @@\n+  if (r->is_young()) {\n+    remset_bytes = _young_cardset_bytes_per_region;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -961,0 +961,2 @@\n+  size_t _young_cardset_bytes_per_region;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-  size_t _sampled_card_rs_length;\n@@ -262,1 +261,1 @@\n-    _sampled_card_rs_length(0), _sampled_code_root_rs_length(0) {}\n+    _sampled_code_root_rs_length(0) {}\n@@ -266,1 +265,0 @@\n-    _sampled_card_rs_length += rem_set->occupied();\n@@ -271,1 +269,0 @@\n-  size_t sampled_card_rs_length() const { return _sampled_card_rs_length; }\n@@ -289,0 +286,2 @@\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    G1CollectionSet* cset = g1h->collection_set();\n@@ -290,1 +289,0 @@\n-    G1CollectionSet* cset = G1CollectedHeap::heap()->collection_set();\n@@ -292,1 +290,5 @@\n-    _policy->revise_young_list_target_length(cl.sampled_card_rs_length(), cl.sampled_code_root_rs_length());\n+\n+    size_t card_rs_length = g1h->young_regions_cardset()->occupied();\n+\n+    size_t sampled_code_root_rs_length = cl.sampled_code_root_rs_length();\n+    _policy->revise_young_list_target_length(card_rs_length, sampled_code_root_rs_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -250,0 +250,2 @@\n+  _heap->young_regions_cardset()->clear();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+  hr->uninstall_group_cardset();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+  uninstall_group_cardset();\n@@ -218,0 +219,3 @@\n+  if (is_young()) {\n+    uninstall_group_cardset();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+class G1CardSet;\n@@ -511,0 +512,3 @@\n+  void install_group_cardset(G1CardSet* group_cardset);\n+  void uninstall_group_cardset();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -514,0 +514,8 @@\n+inline void G1HeapRegion::install_group_cardset(G1CardSet* group_cardset) {\n+  _rem_set->install_group_cardset(group_cardset);\n+}\n+\n+inline void G1HeapRegion::uninstall_group_cardset() {\n+  _rem_set->uninstall_group_cardset();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,0 +58,7 @@\n+void G1HeapRegionRemSet::uninstall_group_cardset() {\n+  if (_saved_card_set != nullptr) {\n+    _card_set = _saved_card_set;\n+    _saved_card_set = nullptr;\n+  }\n+}\n+\n@@ -62,1 +69,2 @@\n-  _card_set(config, &_card_set_mm),\n+  _card_set(new G1CardSet(config, &_card_set_mm)),\n+  _saved_card_set(nullptr),\n@@ -71,0 +79,1 @@\n+  assert(_saved_card_set == nullptr, \"pre-condition\");\n@@ -75,1 +84,1 @@\n-  _card_set.clear();\n+  _card_set->clear();\n@@ -86,1 +95,1 @@\n-  _card_set.reset_table_scanner();\n+  _card_set->reset_table_scanner();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,1 +50,2 @@\n-  G1CardSet _card_set;\n+  G1CardSet* _card_set;\n+  G1CardSet* _saved_card_set;\n@@ -61,0 +62,1 @@\n+  ~G1HeapRegionRemSet() { delete _card_set; }\n@@ -63,1 +65,15 @@\n-    return _card_set.is_empty();\n+    return _card_set->is_empty();\n+  }\n+\n+  void install_group_cardset(G1CardSet* group_cardset) {\n+    assert(group_cardset != nullptr, \"pre-condition\");\n+    assert(_saved_card_set == nullptr, \"pre-condition\");\n+\n+    _saved_card_set = _card_set;\n+    _card_set = group_cardset;\n+  }\n+\n+  void uninstall_group_cardset();\n+\n+  bool has_group_cardset() {\n+    return _saved_card_set != nullptr;\n@@ -71,1 +87,1 @@\n-    return (code_roots_list_length() == 0) && _card_set.occupancy_less_or_equal_to(occ);\n+    return (code_roots_list_length() == 0) && _card_set->occupancy_less_or_equal_to(occ);\n@@ -80,0 +96,3 @@\n+  template <class CardOrRangeVisitor>\n+  inline static void iterate_for_merge(G1CardSet* card_set, CardOrRangeVisitor& cl);\n+\n@@ -81,1 +100,1 @@\n-    return _card_set.occupied();\n+    return _card_set->occupied();\n@@ -84,0 +103,2 @@\n+  G1CardSet* card_set() { return _card_set; }\n+\n@@ -128,1 +149,1 @@\n-    return _card_set.mem_size()\n+    return _card_set->mem_size()\n@@ -134,1 +155,1 @@\n-    return _card_set.unused_mem_size();\n+    return _card_set->unused_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.hpp","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -111,5 +111,1 @@\n-  G1HeapRegionRemSetMergeCardClosure<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(&_card_set,\n-                                                                                       cl,\n-                                                                                       _card_set.config()->log2_card_regions_per_heap_region(),\n-                                                                                       _card_set.config()->log2_cards_per_card_region());\n-  _card_set.iterate_containers(&cl2, true \/* at_safepoint *\/);\n+  iterate_for_merge(_card_set, cl);\n@@ -118,0 +114,8 @@\n+template <class CardOrRangeVisitor>\n+void G1HeapRegionRemSet::iterate_for_merge(G1CardSet* card_set, CardOrRangeVisitor& cl) {\n+  G1HeapRegionRemSetMergeCardClosure<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(card_set,\n+                                                                                       cl,\n+                                                                                       card_set->config()->log2_card_regions_per_heap_region(),\n+                                                                                       card_set->config()->log2_cards_per_card_region());\n+  card_set->iterate_containers(&cl2, true \/* at_safepoint *\/);\n+}\n@@ -133,1 +137,1 @@\n-   return;\n+    return;\n@@ -136,1 +140,1 @@\n-  _card_set.add_card(to_card(from));\n+  _card_set->add_card(to_card(from));\n@@ -140,1 +144,1 @@\n-  return _card_set.contains_card(to_card(from));\n+  return _card_set->contains_card(to_card(from));\n@@ -144,1 +148,1 @@\n-  _card_set.print_info(st, to_card(from));\n+  _card_set->print_info(st, to_card(from));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.inline.hpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1092,0 +1092,5 @@\n+  return predict_base_time_ms(pending_cards, card_rs_length);\n+}\n+\n+double G1Policy::predict_base_time_ms(size_t pending_cards, size_t card_rs_length) const {\n+  bool for_young_only_phase = collector_state()->in_young_only_phase();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,0 +141,2 @@\n+  double predict_base_time_ms(size_t pending_cards, size_t card_rs_length) const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1382,0 +1382,4 @@\n+        if (_initial_evacuation) {\n+          G1HeapRegionRemSet::iterate_for_merge(g1h->young_regions_cardset(), merge);\n+        }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+    size_t occupied_cards = hrrs->occupied();\n@@ -225,0 +226,8 @@\n+\n+    if (r->is_young()) {\n+      uint num_young  =  G1CollectedHeap::heap()->young_regions_count();\n+      occupied_cards \/= num_young;\n+      rs_unused_mem_sz \/= num_young;\n+      rs_mem_sz \/= num_young;\n+    }\n+\n@@ -229,1 +238,1 @@\n-    size_t occupied_cards = hrrs->occupied();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -298,4 +298,3 @@\n-      \/\/ Sample card set sizes for young gen and humongous before GC: this makes\n-      \/\/ the policy to give back memory to the OS keep the most recent amount of\n-      \/\/ memory for these regions.\n-      if (hr->is_young() || hr->is_starts_humongous()) {\n+      \/\/ Sample card set sizes for humongous before GC: this makes the policy to give\n+      \/\/ back memory to the OS keep the most recent amount of memory for these regions.\n+      if (hr->is_starts_humongous()) {\n@@ -510,0 +509,3 @@\n+\n+    _g1h->prepare_group_cardsets_for_scan();\n+\n@@ -517,1 +519,4 @@\n-    _g1h->set_young_gen_card_set_stats(g1_prep_task.all_card_set_stats());\n+    G1MonotonicArenaMemoryStats sampled_card_set_stats = g1_prep_task.all_card_set_stats();\n+    sampled_card_set_stats.add(_g1h->young_regions_card_set_mm()->memory_stats());\n+    _g1h->set_young_gen_card_set_stats(sampled_card_set_stats);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -676,0 +676,4 @@\n+\n+    \/\/ Add the cards from the group cardsets.\n+    _card_rs_length += g1h->young_regions_cardset()->occupied();\n+\n@@ -825,1 +829,0 @@\n-    stats()->account_card_rs_length(r);\n@@ -828,0 +831,2 @@\n+      \/\/ We only use card_rs_length statistics to estimate young regions length.\n+      stats()->account_card_rs_length(r);\n@@ -914,0 +919,2 @@\n+\n+    _g1h->young_regions_cardset()->clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n@@ -45,0 +47,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -51,0 +54,1 @@\n+PartialArrayStateAllocator*    PSPromotionManager::_partial_array_state_allocator = nullptr;\n@@ -65,0 +69,4 @@\n+  assert(_partial_array_state_allocator == nullptr, \"Attempt to initialize twice\");\n+  _partial_array_state_allocator\n+    = new PartialArrayStateAllocator(ParallelGCThreads);\n+\n@@ -70,0 +78,1 @@\n+    _manager_array[i]._partial_array_state_allocator_index = i;\n@@ -127,0 +136,4 @@\n+  \/\/ All PartialArrayStates have been returned to the allocator, since the\n+  \/\/ claimed_stack_depths are all empty.  Leave them there for use by future\n+  \/\/ collections.\n+\n@@ -175,1 +188,4 @@\n-PSPromotionManager::PSPromotionManager() {\n+\/\/ Most members are initialized either by initialize() or reset().\n+PSPromotionManager::PSPromotionManager()\n+  : _partial_array_stepper(ParallelGCThreads, ParGCArrayScanChunk)\n+{\n@@ -185,1 +201,3 @@\n-  _array_chunk_size = ParGCArrayScanChunk;\n+  \/\/ Initialize to a bad value; fixed by initialize().\n+  _partial_array_state_allocator_index = UINT_MAX;\n+\n@@ -187,1 +205,1 @@\n-  _min_array_size_for_chunking = 3 * _array_chunk_size \/ 2;\n+  _min_array_size_for_chunking = (3 * ParGCArrayScanChunk \/ 2);\n@@ -280,7 +298,1 @@\n-void PSPromotionManager::process_array_chunk(PartialArrayScanTask task) {\n-  assert(PSChunkLargeArrays, \"invariant\");\n-\n-  oop old = task.to_source_array();\n-  assert(old->is_objArray(), \"invariant\");\n-  assert(old->is_forwarded(), \"invariant\");\n-\n+void PSPromotionManager::process_array_chunk(PartialArrayState* state) {\n@@ -289,11 +301,15 @@\n-  oop const obj = old->forwardee();\n-\n-  int start;\n-  int const end = arrayOop(old)->length();\n-  if (end > (int) _min_array_size_for_chunking) {\n-    \/\/ we'll chunk more\n-    start = end - _array_chunk_size;\n-    assert(start > 0, \"invariant\");\n-    arrayOop(old)->set_length(start);\n-    push_depth(ScannerTask(PartialArrayScanTask(old)));\n-    TASKQUEUE_STATS_ONLY(++_array_chunk_pushes);\n+  \/\/ Claim a chunk.  Push additional tasks before processing the claimed\n+  \/\/ chunk to allow other workers to steal while we're processing.\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n+  if (step._ncreate > 0) {\n+    state->add_references(step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      push_depth(ScannerTask(state));\n+    }\n+    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n+  }\n+  int start = checked_cast<int>(step._index);\n+  int end = checked_cast<int>(step._index + _partial_array_stepper.chunk_size());\n+  assert(start < end, \"invariant\");\n+  if (UseCompressedOops) {\n+    process_array_chunk_work<narrowOop>(state->destination(), start, end);\n@@ -301,4 +317,1 @@\n-    \/\/ this is the final chunk for this array\n-    start = 0;\n-    int const actual_length = arrayOop(obj)->length();\n-    arrayOop(old)->set_length(actual_length);\n+    process_array_chunk_work<oop>(state->destination(), start, end);\n@@ -306,0 +319,3 @@\n+  \/\/ Release reference to state, now that we're done with it.\n+  _partial_array_state_allocator->release(_partial_array_state_allocator_index, state);\n+}\n@@ -307,0 +323,22 @@\n+void PSPromotionManager::push_objArray(oop old_obj, oop new_obj) {\n+  assert(old_obj->is_objArray(), \"precondition\");\n+  assert(old_obj->is_forwarded(), \"precondition\");\n+  assert(old_obj->forwardee() == new_obj, \"precondition\");\n+  assert(new_obj->is_objArray(), \"precondition\");\n+\n+  size_t array_length = objArrayOop(new_obj)->length();\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n+\n+  if (step._ncreate > 0) {\n+    TASKQUEUE_STATS_ONLY(++_arrays_chunked);\n+    PartialArrayState* state =\n+      _partial_array_state_allocator->allocate(_partial_array_state_allocator_index,\n+                                               old_obj, new_obj,\n+                                               step._index,\n+                                               array_length,\n+                                               step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      push_depth(ScannerTask(state));\n+    }\n+    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n+  }\n@@ -308,1 +346,1 @@\n-    process_array_chunk_work<narrowOop>(obj, start, end);\n+    process_array_chunk_work<narrowOop>(new_obj, 0, checked_cast<int>(step._index));\n@@ -310,1 +348,1 @@\n-    process_array_chunk_work<oop>(obj, start, end);\n+    process_array_chunk_work<oop>(new_obj, 0, checked_cast<int>(step._index));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":66,"deletions":28,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n@@ -52,0 +53,2 @@\n+class PartialArrayState;\n+class PartialArrayStateAllocator;\n@@ -88,1 +91,3 @@\n-  uint                                _array_chunk_size;\n+  static PartialArrayStateAllocator*  _partial_array_state_allocator;\n+  PartialArrayTaskStepper             _partial_array_stepper;\n+  uint                                _partial_array_state_allocator_index;\n@@ -104,1 +109,2 @@\n-  void process_array_chunk(PartialArrayScanTask task);\n+  void process_array_chunk(PartialArrayState* state);\n+  void push_objArray(oop old_obj, oop new_obj);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -279,3 +279,1 @@\n-      \/\/ we'll chunk it\n-      push_depth(ScannerTask(PartialArrayScanTask(o)));\n-      TASKQUEUE_STATS_ONLY(++_arrays_chunked; ++_array_chunk_pushes);\n+      push_objArray(o, new_obj);\n@@ -325,1 +323,1 @@\n-  if (task.is_partial_array_task()) {\n+  if (task.is_partial_array_state()) {\n@@ -327,1 +325,1 @@\n-    process_array_chunk(task.to_partial_array_task());\n+    process_array_chunk(task.to_partial_array_state());\n@@ -344,1 +342,1 @@\n-  if (task.is_partial_array_task()) {\n+  if (task.is_partial_array_state()) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -849,1 +849,9 @@\n-  Generation::print_on(st);\n+  st->print(\" %-10s\", name());\n+\n+  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n+            capacity()\/K, used()\/K);\n+  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+               p2i(_virtual_space.low_boundary()),\n+               p2i(_virtual_space.high()),\n+               p2i(_virtual_space.high_boundary()));\n+\n@@ -858,5 +866,0 @@\n-\n-const char* DefNewGeneration::name() const {\n-  return \"def new generation\";\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -237,2 +237,1 @@\n-  virtual const char* name() const;\n-  virtual const char* short_name() const { return \"DefNew\"; }\n+  const char* name() const { return \"DefNew\"; }\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,12 +61,0 @@\n-\n-void Generation::print() const { print_on(tty); }\n-\n-void Generation::print_on(outputStream* st)  const {\n-  st->print(\" %-20s\", name());\n-  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n-             capacity()\/K, used()\/K);\n-  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-              p2i(_virtual_space.low_boundary()),\n-              p2i(_virtual_space.high()),\n-              p2i(_virtual_space.high_boundary()));\n-}\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -106,7 +106,0 @@\n-  \/\/ Printing\n-  virtual const char* name() const = 0;\n-  virtual const char* short_name() const = 0;\n-\n-  virtual void print() const;\n-  virtual void print_on(outputStream* st) const;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -885,6 +885,6 @@\n-  if (_young_gen != nullptr) {\n-    _young_gen->print_on(st);\n-  }\n-  if (_old_gen != nullptr) {\n-    _old_gen->print_on(st);\n-  }\n+  assert(_young_gen != nullptr, \"precondition\");\n+  assert(_old_gen   != nullptr, \"precondition\");\n+\n+  _young_gen->print_on(st);\n+  _old_gen->print_on(st);\n+\n@@ -911,1 +911,1 @@\n-                     HEAP_CHANGE_FORMAT_ARGS(def_new_gen->short_name(),\n+                     HEAP_CHANGE_FORMAT_ARGS(def_new_gen->name(),\n@@ -927,1 +927,1 @@\n-                     HEAP_CHANGE_FORMAT_ARGS(old_gen()->short_name(),\n+                     HEAP_CHANGE_FORMAT_ARGS(old_gen()->name(),\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -443,1 +443,9 @@\n-  Generation::print_on(st);\n+  st->print(\" %-10s\", name());\n+\n+  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n+            capacity()\/K, used()\/K);\n+  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+               p2i(_virtual_space.low_boundary()),\n+               p2i(_virtual_space.high()),\n+               p2i(_virtual_space.high_boundary()));\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -124,2 +124,1 @@\n-  const char* name() const { return \"tenured generation\"; }\n-  const char* short_name() const { return \"Tenured\"; }\n+  const char* name() const { return \"Tenured\"; }\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -41,0 +42,21 @@\n+\/\/ GCLockerTimingDebugLogger tracks specific timing information for GC lock waits.\n+class GCLockerTimingDebugLogger : public StackObj {\n+  const char* _log_message;\n+  Ticks _start;\n+\n+public:\n+  GCLockerTimingDebugLogger(const char* log_message) : _log_message(log_message) {\n+    assert(_log_message != nullptr, \"GC locker debug message must be set.\");\n+    _start = Ticks::now();\n+  }\n+\n+  ~GCLockerTimingDebugLogger() {\n+    Log(gc, jni) log;\n+    if (log.is_debug()) {\n+      ResourceMark rm; \/\/ JavaThread::name() allocates to convert to UTF8\n+      const Tickspan elapsed_time = Ticks::now() - _start;\n+      log.debug(\"%s Resumed after \" UINT64_FORMAT \"ms. Thread \\\"%s\\\".\", _log_message, elapsed_time.milliseconds(), Thread::current()->name());\n+    }\n+  }\n+};\n+\n@@ -113,5 +135,5 @@\n-  }\n-\n-  \/\/ Wait for _needs_gc  to be cleared\n-  while (needs_gc()) {\n-    ml.wait();\n+    GCLockerTimingDebugLogger logger(\"Thread stalled by JNI critical section.\");\n+    \/\/ Wait for _needs_gc to be cleared\n+    while (needs_gc()) {\n+      ml.wait();\n+    }\n@@ -130,10 +152,14 @@\n-  while (needs_gc()) {\n-    \/\/ There's at least one thread that has not left the critical region (CR)\n-    \/\/ completely. When that last thread (no new threads can enter CR due to the\n-    \/\/ blocking) exits CR, it calls `jni_unlock`, which sets `_needs_gc`\n-    \/\/ to false and wakes up all blocked threads.\n-    \/\/ We would like to assert #threads in CR to be > 0, `_jni_lock_count > 0`\n-    \/\/ in the code, but it's too strong; it's possible that the last thread\n-    \/\/ has called `jni_unlock`, but not yet finished the call, e.g. initiating\n-    \/\/ a GCCause::_gc_locker GC.\n-    ml.wait();\n+  if (needs_gc()) {\n+    log_debug_jni(\"Blocking thread as there is a pending GC request\");\n+    GCLockerTimingDebugLogger logger(\"Thread blocked to enter critical region.\");\n+    while (needs_gc()) {\n+      \/\/ There's at least one thread that has not left the critical region (CR)\n+      \/\/ completely. When that last thread (no new threads can enter CR due to the\n+      \/\/ blocking) exits CR, it calls `jni_unlock`, which sets `_needs_gc`\n+      \/\/ to false and wakes up all blocked threads.\n+      \/\/ We would like to assert #threads in CR to be > 0, `_jni_lock_count > 0`\n+      \/\/ in the code, but it's too strong; it's possible that the last thread\n+      \/\/ has called `jni_unlock`, but not yet finished the call, e.g. initiating\n+      \/\/ a GCCause::_gc_locker GC.\n+      ml.wait();\n+    }\n@@ -151,0 +177,1 @@\n+  log_debug_jni(\"Thread exiting critical region.\");\n@@ -164,1 +191,1 @@\n-      log_debug_jni(\"Performing GC after exiting critical section.\");\n+      log_debug_jni(\"Last thread exiting. Performing GC after exiting critical section.\");\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":43,"deletions":16,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -112,1 +113,1 @@\n-class PartialArrayStateAllocator {\n+class PartialArrayStateAllocator : public CHeapObj<mtGC> {\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -576,14 +576,0 @@\n-\/\/ Wrapper over an oop that is a partially scanned array.\n-\/\/ Can be converted to a ScannerTask for placement in associated task queues.\n-\/\/ Refers to the partially copied source array oop.\n-\/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n-class PartialArrayScanTask {\n-  oop _src;\n-\n-public:\n-  explicit PartialArrayScanTask(oop src_array) : _src(src_array) {}\n-  \/\/ Trivially copyable.\n-\n-  oop to_source_array() const { return _src; }\n-};\n-\n@@ -630,4 +616,0 @@\n-  \/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n-  explicit ScannerTask(PartialArrayScanTask t) :\n-    _p(encode(t.to_source_array(), PartialArrayTag)) {}\n-\n@@ -649,5 +631,0 @@\n-  \/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n-  bool is_partial_array_task() const {\n-    return (raw_value() & PartialArrayTag) != 0;\n-  }\n-\n@@ -666,5 +643,0 @@\n-  \/\/ Temporarily retained to support ParallelGC until it adopts PartialArrayState.\n-  PartialArrayScanTask to_partial_array_task() const {\n-    return PartialArrayScanTask(cast_to_oop(decode(PartialArrayTag)));\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  if (!heap->is_in(loc)) return;\n+  if (!heap->is_in_reserved(loc)) return;\n@@ -83,1 +83,1 @@\n-  if (heap->is_in(loc)) {\n+  if (heap->is_in_reserved(loc)) {\n@@ -102,1 +102,1 @@\n-  if (heap->is_in(loc)) {\n+  if (heap->is_in_reserved(loc)) {\n@@ -119,1 +119,1 @@\n-  bool loc_in_heap = (loc != nullptr && heap->is_in(loc));\n+  bool loc_in_heap = (loc != nullptr && heap->is_in_reserved(loc));\n@@ -172,1 +172,1 @@\n-void ShenandoahAsserts::assert_in_heap(void* interior_loc, oop obj, const char *file, int line) {\n+void ShenandoahAsserts::assert_in_heap_bounds(void* interior_loc, oop obj, const char *file, int line) {\n@@ -175,3 +175,3 @@\n-  if (!heap->is_in(obj)) {\n-    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap failed\",\n-                  \"oop must point to a heap address\",\n+  if (!heap->is_in_reserved(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_bounds failed\",\n+                  \"oop must be in heap bounds\",\n@@ -182,1 +182,1 @@\n-void ShenandoahAsserts::assert_in_heap_or_null(void* interior_loc, oop obj, const char *file, int line) {\n+void ShenandoahAsserts::assert_in_heap_bounds_or_null(void* interior_loc, oop obj, const char *file, int line) {\n@@ -185,3 +185,3 @@\n-  if (obj != nullptr && !heap->is_in(obj)) {\n-    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_or_null failed\",\n-                  \"oop must point to a heap address\",\n+  if (obj != nullptr && !heap->is_in_reserved(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_bounds_or_null failed\",\n+                  \"oop must be in heap bounds\",\n@@ -197,1 +197,1 @@\n-  if (!heap->is_in(obj)) {\n+  if (!heap->is_in_reserved(obj)) {\n@@ -199,1 +199,1 @@\n-                  \"oop must point to a heap address\",\n+                  \"oop must be in heap bounds\",\n@@ -216,0 +216,6 @@\n+  if (!heap->is_in(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                  \"Object should be in active region area\",\n+                  file, line);\n+  }\n+\n@@ -229,1 +235,1 @@\n-    if (!heap->is_in(fwd)) {\n+    if (!heap->is_in_reserved(fwd)) {\n@@ -231,1 +237,1 @@\n-                    \"Forwardee must point to a heap address\",\n+                    \"Forwardee must be in heap bounds\",\n@@ -242,0 +248,6 @@\n+    if (!heap->is_in(fwd)) {\n+      print_failure(_safe_oop, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                    \"Forwardee should be in active region area\",\n+                    file, line);\n+    }\n+\n@@ -244,1 +256,1 @@\n-                    \"Non-trivial forwardee should in another region\",\n+                    \"Non-trivial forwardee should be in another region\",\n@@ -260,1 +272,1 @@\n-  if (java_lang_Class::is_instance(obj)) {\n+  if (Universe::is_fully_initialized() && (obj_klass == vmClasses::Class_klass())) {\n@@ -289,1 +301,3 @@\n-  if (alloc_size > ShenandoahHeapRegion::humongous_threshold_words()) {\n+  HeapWord* obj_end = cast_from_oop<HeapWord*>(obj) + alloc_size;\n+\n+  if (ShenandoahHeapRegion::requires_humongous(alloc_size)) {\n@@ -291,2 +305,2 @@\n-    size_t num_regions = ShenandoahHeapRegion::required_regions(alloc_size * HeapWordSize);\n-    for (size_t i = idx; i < idx + num_regions; i++) {\n+    size_t end_idx = heap->heap_region_index_containing(obj_end - 1);\n+    for (size_t i = idx; i < end_idx; i++) {\n@@ -305,0 +319,6 @@\n+  } else {\n+    if (obj_end > r->top()) {\n+      print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_correct_region failed\",\n+                    \"Object end should be within the active area of the region\",\n+                    file, line);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":41,"deletions":21,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-  static void assert_in_heap(void* interior_loc, oop obj, const char* file, int line);\n-  static void assert_in_heap_or_null(void* interior_loc, oop obj, const char* file, int line);\n+  static void assert_in_heap_bounds(void* interior_loc, oop obj, const char* file, int line);\n+  static void assert_in_heap_bounds_or_null(void* interior_loc, oop obj, const char* file, int line);\n@@ -81,4 +81,4 @@\n-#define shenandoah_assert_in_heap(interior_loc, obj) \\\n-                    ShenandoahAsserts::assert_in_heap(interior_loc, obj, __FILE__, __LINE__)\n-#define shenandoah_assert_in_heap_or_null(interior_loc, obj) \\\n-                    ShenandoahAsserts::assert_in_heap_or_null(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_in_heap_bounds(interior_loc, obj) \\\n+                    ShenandoahAsserts::assert_in_heap_bounds(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_in_heap_bounds_or_null(interior_loc, obj) \\\n+                    ShenandoahAsserts::assert_in_heap_bounds_or_null(interior_loc, obj, __FILE__, __LINE__)\n@@ -186,2 +186,2 @@\n-#define shenandoah_assert_in_heap(interior_loc, obj)\n-#define shenandoah_assert_in_heap_or_null(interior_loc, obj)\n+#define shenandoah_assert_in_heap_bounds(interior_loc, obj)\n+#define shenandoah_assert_in_heap_bounds_or_null(interior_loc, obj)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  shenandoah_assert_in_heap_or_null(nullptr, p);\n+  shenandoah_assert_in_heap_bounds_or_null(nullptr, p);\n@@ -50,1 +50,1 @@\n-  assert(p == nullptr || _heap->is_in(p), \"Must be in the heap\");\n+  assert(p == nullptr || _heap->is_in_reserved(p), \"Must be in the heap\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -709,6 +709,0 @@\n-      \/\/ Verify before arming for concurrent processing.\n-      \/\/ Otherwise, verification can trigger stack processing.\n-      if (ShenandoahVerify) {\n-        heap->verifier()->verify_during_evacuation();\n-      }\n-\n@@ -839,4 +833,1 @@\n-        \/\/ Here we are asserting that an unmarked from-space object is 'correct'. There seems to be a legitimate\n-        \/\/ use-case for accessing from-space objects during concurrent class unloading. In all modes of Shenandoah,\n-        \/\/ concurrent class unloading only happens during a global collection.\n-        shenandoah_assert_correct(p, obj);\n+        \/\/ Note: The obj is dead here. Do not touch it, just clear.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  bool is_humongous = req.size() > ShenandoahHeapRegion::humongous_threshold_words();\n+  bool is_humongous = ShenandoahHeapRegion::requires_humongous(req.size());\n@@ -83,1 +83,1 @@\n-  bool is_humongous = (words > ShenandoahHeapRegion::region_size_words());\n+  bool is_humongous = ShenandoahHeapRegion::requires_humongous(words);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -361,5 +361,0 @@\n-\n-    if(ShenandoahVerify) {\n-      heap->verifier()->verify_during_evacuation();\n-    }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  shenandoah_assert_in_heap(nullptr, obj);\n+  shenandoah_assert_in_heap_bounds(nullptr, obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1992,1 +1992,1 @@\n-  if (req.size() > ShenandoahHeapRegion::humongous_threshold_words()) {\n+  if (ShenandoahHeapRegion::requires_humongous(req.size())) {\n@@ -2002,2 +2002,1 @@\n-        assert(false, \"Trying to allocate TLAB larger than the humongous threshold: \" SIZE_FORMAT \" > \" SIZE_FORMAT,\n-               req.size(), ShenandoahHeapRegion::humongous_threshold_words());\n+        assert(false, \"Trying to allocate TLAB in humongous region: \" SIZE_FORMAT, req.size());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-  \/\/ Precondition: req.size() <= ShenandoahHeapRegion::humongous_threshold_words().\n+  \/\/ Precondition: !ShenandoahHeapRegion::requires_humongous(req.size())\n@@ -320,1 +320,1 @@\n-  \/\/ Precondition: req.size() > ShenandoahHeapRegion::humongous_threshold_words().\n+  \/\/ Precondition: ShenandoahHeapRegion::requires_humongous(req.size())\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+#include \"cds\/archiveHeapWriter.hpp\"\n@@ -708,1 +709,1 @@\n-    if (wasted_bytes > 0 && req.actual_size() > ShenandoahHeapRegion::humongous_threshold_words()) {\n+    if (wasted_bytes > 0 && ShenandoahHeapRegion::requires_humongous(req.actual_size())) {\n@@ -782,0 +783,15 @@\n+bool ShenandoahHeap::is_in(const void* p) const {\n+  if (is_in_reserved(p)) {\n+    if (is_full_gc_move_in_progress()) {\n+      \/\/ Full GC move is running, we do not have a consistent region\n+      \/\/ information yet. But we know the pointer is in heap.\n+      return true;\n+    }\n+    \/\/ Now check if we point to a live section in active region.\n+    ShenandoahHeapRegion* r = heap_region_containing(p);\n+    return (r->is_active() && p < r->top());\n+  } else {\n+    return false;\n+  }\n+}\n+\n@@ -2669,0 +2685,77 @@\n+HeapWord* ShenandoahHeap::allocate_loaded_archive_space(size_t size) {\n+#if INCLUDE_CDS_JAVA_HEAP\n+  \/\/ CDS wants a continuous memory range to load a bunch of objects.\n+  \/\/ This effectively bypasses normal allocation paths, and requires\n+  \/\/ a bit of massaging to unbreak GC invariants.\n+\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);\n+\n+  \/\/ Easy case: a single regular region, no further adjustments needed.\n+  if (!ShenandoahHeapRegion::requires_humongous(size)) {\n+    return allocate_memory(req);\n+  }\n+\n+  \/\/ Hard case: the requested size would cause a humongous allocation.\n+  \/\/ We need to make sure it looks like regular allocation to the rest of GC.\n+\n+  \/\/ CDS code would guarantee no objects straddle multiple regions, as long as\n+  \/\/ regions are as large as MIN_GC_REGION_ALIGNMENT. It is impractical at this\n+  \/\/ point to deal with case when Shenandoah runs with smaller regions.\n+  \/\/ TODO: This check can be dropped once MIN_GC_REGION_ALIGNMENT agrees more with Shenandoah.\n+  if (ShenandoahHeapRegion::region_size_bytes() < ArchiveHeapWriter::MIN_GC_REGION_ALIGNMENT) {\n+    return nullptr;\n+  }\n+\n+  HeapWord* mem = allocate_memory(req);\n+  size_t start_idx = heap_region_index_containing(mem);\n+  size_t num_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);\n+\n+  \/\/ Flip humongous -> regular.\n+  {\n+    ShenandoahHeapLocker locker(lock(), false);\n+    for (size_t c = start_idx; c < start_idx + num_regions; c++) {\n+      get_region(c)->make_regular_bypass();\n+    }\n+  }\n+\n+  return mem;\n+#else\n+  assert(false, \"Archive heap loader should not be available, should not be here\");\n+  return nullptr;\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+}\n+\n+void ShenandoahHeap::complete_loaded_archive_space(MemRegion archive_space) {\n+  \/\/ Nothing to do here, except checking that heap looks fine.\n+#ifdef ASSERT\n+  HeapWord* start = archive_space.start();\n+  HeapWord* end = archive_space.end();\n+\n+  \/\/ No unclaimed space between the objects.\n+  \/\/ Objects are properly allocated in correct regions.\n+  HeapWord* cur = start;\n+  while (cur < end) {\n+    oop oop = cast_to_oop(cur);\n+    shenandoah_assert_in_correct_region(nullptr, oop);\n+    cur += oop->size();\n+  }\n+\n+  \/\/ No unclaimed tail at the end of archive space.\n+  assert(cur == end,\n+         \"Archive space should be fully used: \" PTR_FORMAT \" \" PTR_FORMAT,\n+         p2i(cur), p2i(end));\n+\n+  \/\/ Region bounds are good.\n+  ShenandoahHeapRegion* begin_reg = heap_region_containing(start);\n+  ShenandoahHeapRegion* end_reg = heap_region_containing(end);\n+  assert(begin_reg->is_regular(), \"Must be\");\n+  assert(end_reg->is_regular(), \"Must be\");\n+  assert(begin_reg->bottom() == start,\n+         \"Must agree: archive-space-start: \" PTR_FORMAT \", begin-region-bottom: \" PTR_FORMAT,\n+         p2i(start), p2i(begin_reg->bottom()));\n+  assert(end_reg->top() == end,\n+         \"Must agree: archive-space-end: \" PTR_FORMAT \", end-region-top: \" PTR_FORMAT,\n+         p2i(end), p2i(end_reg->top()));\n+#endif\n+}\n+\n@@ -2690,0 +2783,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":95,"deletions":1,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -601,1 +601,3 @@\n-  inline bool is_in(const void* p) const override;\n+  \/\/ Check the pointer is in active part of Java heap.\n+  \/\/ Use is_in_reserved to check if object is within heap bounds.\n+  bool is_in(const void* p) const override;\n@@ -657,0 +659,6 @@\n+\/\/ ---------- CDS archive support\n+\n+  bool can_load_archived_objects() const override { return UseCompressedOops && !ShenandoahCardBarrier; }\n+  HeapWord* allocate_loaded_archive_space(size_t size) override;\n+  void complete_loaded_archive_space(MemRegion archive_space) override;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -348,6 +348,0 @@\n-bool ShenandoahHeap::is_in(const void* p) const {\n-  HeapWord* heap_base = (HeapWord*) base();\n-  HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();\n-  return p >= heap_base && p < last_region_end;\n-}\n-\n@@ -357,1 +351,1 @@\n-    assert(is_in(obj), \"Otherwise shouldn't return true below\");\n+    assert(is_in_reserved(obj), \"Otherwise shouldn't return true below\");\n@@ -369,1 +363,1 @@\n-  assert(is_in(obj), \"only check if is in active generation for objects (\" PTR_FORMAT \") in heap\", p2i(obj));\n+  assert(is_in_reserved(obj), \"only check if is in active generation for objects (\" PTR_FORMAT \") in heap\", p2i(obj));\n@@ -395,1 +389,1 @@\n-  return is_in(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::YOUNG_GENERATION);\n+  return is_in_reserved(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::YOUNG_GENERATION);\n@@ -399,1 +393,1 @@\n-  return is_in(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::OLD_GENERATION);\n+  return is_in_reserved(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::OLD_GENERATION);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-\n@@ -63,2 +62,0 @@\n-size_t ShenandoahHeapRegion::HumongousThresholdBytes = 0;\n-size_t ShenandoahHeapRegion::HumongousThresholdWords = 0;\n@@ -147,2 +144,4 @@\n-  assert (ShenandoahHeap::heap()->is_full_gc_in_progress() || ShenandoahHeap::heap()->is_degenerated_gc_in_progress(),\n-          \"only for full or degen GC\");\n+  assert (!Universe::is_fully_initialized() ||\n+          ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+          ShenandoahHeap::heap()->is_degenerated_gc_in_progress(),\n+          \"Only for STW GC or when Universe is initializing (CDS)\");\n@@ -157,0 +156,8 @@\n+      if (_state == _humongous_start || _state == _humongous_cont) {\n+        \/\/ CDS allocates chunks of the heap to fill with regular objects. The allocator\n+        \/\/ will dutifully track any waste in the unused portion of the last region. Once\n+        \/\/ CDS has finished initializing the objects, it will convert these regions to\n+        \/\/ regular regions. The 'waste' in the last region is no longer wasted at this point,\n+        \/\/ so we must stop treating it as such.\n+        decrement_humongous_waste();\n+      }\n@@ -575,0 +582,1 @@\n+  heap->marking_context()->clear_bitmap(this);\n@@ -754,9 +762,0 @@\n-  guarantee(HumongousThresholdWords == 0, \"we should only set it once\");\n-  HumongousThresholdWords = RegionSizeWords * ShenandoahHumongousThreshold \/ 100;\n-  HumongousThresholdWords = align_down(HumongousThresholdWords, MinObjAlignment);\n-  assert (HumongousThresholdWords <= RegionSizeWords, \"sanity\");\n-\n-  guarantee(HumongousThresholdBytes == 0, \"we should only set it once\");\n-  HumongousThresholdBytes = HumongousThresholdWords * HeapWordSize;\n-  assert (HumongousThresholdBytes <= RegionSizeBytes, \"sanity\");\n-\n@@ -764,2 +763,1 @@\n-  MaxTLABSizeWords = MIN2(RegionSizeWords, HumongousThresholdWords);\n-  MaxTLABSizeWords = align_down(MaxTLABSizeWords, MinObjAlignment);\n+  MaxTLABSizeWords = align_down(RegionSizeWords, MinObjAlignment);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -231,2 +231,0 @@\n-  static size_t HumongousThresholdBytes;\n-  static size_t HumongousThresholdWords;\n@@ -282,0 +280,4 @@\n+  inline static bool requires_humongous(size_t words) {\n+    return words > ShenandoahHeapRegion::RegionSizeWords;\n+  }\n+\n@@ -334,8 +336,0 @@\n-  inline static size_t humongous_threshold_bytes() {\n-    return ShenandoahHeapRegion::HumongousThresholdBytes;\n-  }\n-\n-  inline static size_t humongous_threshold_words() {\n-    return ShenandoahHeapRegion::HumongousThresholdWords;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  log_info(gc, init)(\"Humongous Object Threshold: \" EXACTFMT, EXACTFMTARGS(ShenandoahHeapRegion::humongous_threshold_bytes()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahInitLogger.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  assert(ShenandoahHeap::heap()->is_in(addr),\n+  assert(ShenandoahHeap::heap()->is_in_reserved(addr),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n-  inline bool is_marked(oop) const;\n+  inline bool is_marked(oop obj) const;\n+  inline bool is_marked(HeapWord* raw_obj) const;\n@@ -66,0 +67,1 @@\n+  inline bool is_marked_strong(HeapWord* raw_obj) const;\n@@ -72,1 +74,1 @@\n-  inline bool allocated_after_mark_start(oop obj) const;\n+  inline bool allocated_after_mark_start(const oop obj) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,5 @@\n-  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked(cast_from_oop<HeapWord *>(obj));\n+  return is_marked(cast_from_oop<HeapWord*>(obj));\n+}\n+\n+inline bool ShenandoahMarkingContext::is_marked(HeapWord* raw_obj) const {\n+  return allocated_after_mark_start(raw_obj) || _mark_bit_map.is_marked(raw_obj);\n@@ -46,1 +50,5 @@\n-  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked_strong(cast_from_oop<HeapWord*>(obj));\n+  return is_marked_strong(cast_from_oop<HeapWord*>(obj));\n+}\n+\n+inline bool ShenandoahMarkingContext::is_marked_strong(HeapWord* raw_obj) const {\n+  return allocated_after_mark_start(raw_obj) || _mark_bit_map.is_marked_strong(raw_obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -112,0 +112,11 @@\n+inline oop reference_coop_decode_raw(narrowOop v) {\n+  return CompressedOops::is_null(v) ? nullptr : CompressedOops::decode_raw(v);\n+}\n+\n+inline oop reference_coop_decode_raw(oop v) {\n+  return v;\n+}\n+\n+\/\/ Raw referent, it can be dead. You cannot treat it as oop without additional safety\n+\/\/ checks, this is why it is HeapWord*. The decoding uses a special-case inlined\n+\/\/ CompressedOops::decode method that bypasses normal oop-ness checks.\n@@ -113,3 +124,3 @@\n-static oop reference_referent(oop reference) {\n-  T heap_oop = Atomic::load(reference_referent_addr<T>(reference));\n-  return CompressedOops::decode(heap_oop);\n+static HeapWord* reference_referent_raw(oop reference) {\n+  T raw_oop = Atomic::load(reference_referent_addr<T>(reference));\n+  return cast_from_oop<HeapWord*>(reference_coop_decode_raw(raw_oop));\n@@ -313,2 +324,2 @@\n-  const oop referent = reference_referent<T>(reference);\n-  if (referent == nullptr) {\n+  HeapWord* raw_referent = reference_referent_raw<T>(reference);\n+  if (raw_referent == nullptr) {\n@@ -324,1 +335,1 @@\n-    return ShenandoahHeap::heap()->complete_marking_context()->is_marked(referent);\n+    return ShenandoahHeap::heap()->complete_marking_context()->is_marked(raw_referent);\n@@ -326,1 +337,1 @@\n-    return ShenandoahHeap::heap()->complete_marking_context()->is_marked_strong(referent);\n+    return ShenandoahHeap::heap()->complete_marking_context()->is_marked_strong(raw_referent);\n@@ -338,1 +349,1 @@\n-    assert(ShenandoahHeap::heap()->marking_context()->is_marked(reference_referent<T>(reference)), \"only make inactive final refs with alive referents\");\n+    assert(ShenandoahHeap::heap()->marking_context()->is_marked(reference_referent_raw<T>(reference)), \"only make inactive final refs with alive referents\");\n@@ -425,0 +436,7 @@\n+  HeapWord* raw_referent = reference_referent_raw<T>(reference);\n+\n+#ifdef ASSERT\n+  assert(raw_referent == nullptr || ShenandoahHeap::heap()->marking_context()->is_marked(raw_referent),\n+         \"only drop references with alive referents\");\n+#endif\n+\n@@ -426,2 +444,0 @@\n-  oop referent = reference_referent<T>(reference);\n-  assert(referent == nullptr || heap->marking_context()->is_marked(referent), \"only drop references with alive referents\");\n@@ -436,1 +452,1 @@\n-  if (heap->mode()->is_generational() && heap->is_in_old(reference) && heap->is_in_young(referent)) {\n+  if (heap->mode()->is_generational() && heap->is_in_old(reference) && heap->is_in_young(raw_referent)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":27,"deletions":11,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -59,7 +59,0 @@\n-class ShenandoahIgnoreReferenceDiscoverer : public ReferenceDiscoverer {\n-public:\n-  virtual bool discover_reference(oop obj, ReferenceType type) {\n-    return true;\n-  }\n-};\n-\n@@ -76,0 +69,1 @@\n+  ReferenceIterationMode _ref_mode;\n@@ -93,1 +87,7 @@\n-      set_ref_discoverer_internal(new ShenandoahIgnoreReferenceDiscoverer());\n+      \/\/ Unknown status for Reference.referent field. Do not touch it, it might be dead.\n+      \/\/ Normally, barriers would prevent us from seeing the dead referents, but verifier\n+      \/\/ runs with barriers disabled.\n+      _ref_mode = DO_FIELDS_EXCEPT_REFERENT;\n+    } else {\n+      \/\/ Otherwise do all fields.\n+      _ref_mode = DO_FIELDS;\n@@ -103,0 +103,4 @@\n+  ReferenceIterationMode reference_iteration_mode() override {\n+    return _ref_mode;\n+  }\n+\n@@ -144,2 +148,2 @@\n-    check(ShenandoahAsserts::_safe_unknown, obj, _heap->is_in(obj),\n-              \"oop must be in heap\");\n+    check(ShenandoahAsserts::_safe_unknown, obj, _heap->is_in_reserved(obj),\n+              \"oop must be in heap bounds\");\n@@ -204,2 +208,2 @@\n-      check(ShenandoahAsserts::_safe_oop, obj, _heap->is_in(fwd),\n-             \"Forwardee must be in heap\");\n+      check(ShenandoahAsserts::_safe_oop, obj, _heap->is_in_reserved(fwd),\n+             \"Forwardee must be in heap bounds\");\n@@ -222,0 +226,3 @@\n+      check(ShenandoahAsserts::_safe_oop, obj, fwd_reg->is_active(),\n+            \"Forwardee should be in active region\");\n+\n@@ -242,1 +249,1 @@\n-    if (java_lang_Class::is_instance(obj)) {\n+    if (obj_klass == vmClasses::Class_klass()) {\n@@ -811,8 +818,0 @@\n-      case _verify_gcstate_evacuation:\n-        enabled = true;\n-        expected = ShenandoahHeap::EVACUATION;\n-        if (!_heap->is_stw_gc_in_progress()) {\n-          \/\/ Only concurrent GC sets this.\n-          expected |= ShenandoahHeap::WEAK_ROOTS;\n-        }\n-        break;\n@@ -1103,28 +1102,0 @@\n-void ShenandoahVerifier::verify_during_evacuation() {\n-  verify_at_safepoint(\n-          \"During Evacuation\",\n-          _verify_remembered_disable, \/\/ do not verify remembered set\n-          _verify_forwarded_allow,    \/\/ some forwarded references are allowed\n-          _verify_marked_disable,     \/\/ walk only roots\n-          _verify_cset_disable,       \/\/ some cset references are not forwarded yet\n-          _verify_liveness_disable,   \/\/ liveness data might be already stale after pre-evacs\n-          _verify_regions_disable,    \/\/ trash regions not yet recycled\n-          _verify_size_disable,       \/\/ we don't know how much of promote-in-place work has been completed\n-          _verify_gcstate_evacuation  \/\/ evacuation is in progress\n-  );\n-}\n-\n-void ShenandoahVerifier::verify_after_evacuation() {\n-  verify_at_safepoint(\n-          \"After Evacuation\",\n-          _verify_remembered_disable,  \/\/ do not verify remembered set\n-          _verify_forwarded_allow,     \/\/ objects are still forwarded\n-          _verify_marked_complete,     \/\/ bitmaps might be stale, but alloc-after-mark should be well\n-          _verify_cset_forwarded,      \/\/ all cset refs are fully forwarded\n-          _verify_liveness_disable,    \/\/ no reliable liveness data anymore\n-          _verify_regions_notrash,     \/\/ trash regions have been recycled already\n-          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n-          _verify_gcstate_forwarded    \/\/ evacuation produced some forwarded objects\n-  );\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":20,"deletions":49,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -174,3 +174,0 @@\n-    \/\/ Evacuation is in progress, some objects are forwarded\n-    _verify_gcstate_evacuation,\n-\n@@ -219,2 +216,0 @@\n-  void verify_during_evacuation();\n-  void verify_after_evacuation();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -133,7 +133,0 @@\n-  product(intx, ShenandoahHumongousThreshold, 100, EXPERIMENTAL,            \\\n-          \"Humongous objects are allocated in separate regions. \"           \\\n-          \"This setting defines how large the object should be to be \"      \\\n-          \"deemed humongous. Value is in  percents of heap region size. \"   \\\n-          \"This also caps the maximum TLAB size.\")                          \\\n-          range(1, 100)                                                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -233,2 +233,2 @@\n-static bool should_clear_soft_references(GCCause::Cause cause) {\n-  \/\/ Clear soft references if implied by the GC cause\n+static bool should_clear_all_soft_references(GCCause::Cause cause) {\n+  \/\/ Clear all soft references if implied by the GC cause\n@@ -262,1 +262,1 @@\n-  \/\/ Clear soft references if threads are stalled waiting for an old collection\n+  \/\/ Clear all soft references if threads are stalled waiting for an old collection\n@@ -267,1 +267,1 @@\n-  \/\/ Don't clear\n+  \/\/ Don't clear all soft references\n@@ -305,5 +305,9 @@\n-  \/\/ It is important that when soft references are cleared, we also pre-clean the young\n-  \/\/ generation, as we might otherwise throw premature OOM. Therefore, all causes that\n-  \/\/ trigger soft ref cleaning must also trigger pre-cleaning of young gen. If allocations\n-  \/\/ stalled when checking for soft ref cleaning, then since we hold the driver locker all\n-  \/\/ the way until we check for young gen pre-cleaning, we can be certain that we should\n+  \/\/ We clear all soft references as a last-ditch effort to collect memory\n+  \/\/ before throwing an OOM. Therefore it is important that when the GC policy\n+  \/\/ is to clear all soft references, that we also pre-clean the young\n+  \/\/ generation, as we might otherwise throw premature OOM.\n+  \/\/\n+  \/\/ Therefore, all causes that trigger all soft ref clearing must also trigger\n+  \/\/ pre-cleaning of young gen. If allocations stalled when checking for all\n+  \/\/ soft ref clearing, then since we hold the driver locker all the way until\n+  \/\/ we check for young gen pre-cleaning, we can be certain that we should\n@@ -311,1 +315,1 @@\n-  assert(!should_clear_soft_references(cause), \"Clearing soft references without pre-cleaning young gen\");\n+  assert(!should_clear_all_soft_references(cause), \"Clearing all soft references without pre-cleaning young gen\");\n@@ -398,0 +402,4 @@\n+\n+    \/\/ Set up soft reference policy\n+    const bool clear_all = should_clear_all_soft_references(request.cause());\n+    ZGeneration::old()->set_soft_reference_policy(clear_all);\n@@ -447,2 +455,3 @@\n-static void handle_alloc_stalling_for_old(bool cleared_soft_refs) {\n-  ZHeap::heap()->handle_alloc_stalling_for_old(cleared_soft_refs);\n+static void handle_alloc_stalling_for_old() {\n+  const bool cleared_all = ZGeneration::old()->uses_clear_all_soft_reference_policy();\n+  ZHeap::heap()->handle_alloc_stalling_for_old(cleared_all);\n@@ -451,2 +460,2 @@\n-void ZDriverMajor::handle_alloc_stalls(bool cleared_soft_refs) const {\n-  handle_alloc_stalling_for_old(cleared_soft_refs);\n+void ZDriverMajor::handle_alloc_stalls() const {\n+  handle_alloc_stalling_for_old();\n@@ -467,4 +476,0 @@\n-    \/\/ Set up soft reference policy\n-    const bool clear_soft_refs = should_clear_soft_references(request.cause());\n-    ZGeneration::old()->set_soft_reference_policy(clear_soft_refs);\n-\n@@ -480,1 +485,1 @@\n-    handle_alloc_stalls(clear_soft_refs);\n+    handle_alloc_stalls();\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":24,"deletions":19,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-  void handle_alloc_stalls(bool cleared_soft_refs) const;\n+  void handle_alloc_stalls() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    _page->finalize_reset_for_in_place_relocation();\n+    _page->reset_livemap();\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1289,0 +1289,4 @@\n+bool ZGenerationOld::uses_clear_all_soft_reference_policy() const {\n+  return _reference_processor.uses_clear_all_soft_reference_policy();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -312,0 +312,1 @@\n+  bool uses_clear_all_soft_reference_policy() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-inline void ZHeap::handle_alloc_stalling_for_old(bool cleared_soft_refs) {\n-  _page_allocator.handle_alloc_stalling_for_old(cleared_soft_refs);\n+inline void ZHeap::handle_alloc_stalling_for_old(bool cleared_all_soft_refs) {\n+  _page_allocator.handle_alloc_stalling_for_old(cleared_all_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zLock.inline.hpp\"\n@@ -48,0 +49,1 @@\n+    _shared_small_page(nullptr),\n@@ -49,1 +51,1 @@\n-    _shared_small_page(nullptr) {}\n+    _medium_page_alloc_lock() {}\n@@ -129,0 +131,36 @@\n+zaddress ZObjectAllocator::alloc_object_in_medium_page(size_t size,\n+                                                       ZAllocationFlags flags) {\n+  zaddress addr = zaddress::null;\n+  ZPage** shared_medium_page = _shared_medium_page.addr();\n+  ZPage* page = Atomic::load_acquire(shared_medium_page);\n+\n+  if (page != nullptr) {\n+    addr = page->alloc_object_atomic(size);\n+  }\n+\n+  if (is_null(addr)) {\n+    \/\/ When a new medium page is required, we synchronize the allocation\n+    \/\/ of the new page using a lock. This is to avoid having multiple\n+    \/\/ threads requesting a medium page from the page cache when we know\n+    \/\/ only one of the will succeed in installing the page at this layer.\n+    ZLocker<ZLock> locker(&_medium_page_alloc_lock);\n+\n+    \/\/ When holding the lock we can't allow the page allocator to stall,\n+    \/\/ which in the common case it won't. The page allocation is thus done\n+    \/\/ in a non-blocking fashion and only if this fails we below (while not\n+    \/\/ holding the lock) do the blocking page allocation.\n+    ZAllocationFlags non_blocking_flags = flags;\n+    non_blocking_flags.set_non_blocking();\n+\n+    addr = alloc_object_in_shared_page(shared_medium_page, ZPageType::medium, ZPageSizeMedium, size, non_blocking_flags);\n+  }\n+\n+  if (is_null(addr) && !flags.non_blocking()) {\n+    \/\/ The above allocation attempts failed and this allocation should stall\n+    \/\/ until memory is available. Redo the allocation with blocking enabled.\n+    addr = alloc_object_in_shared_page(shared_medium_page, ZPageType::medium, ZPageSizeMedium, size, flags);\n+  }\n+\n+  return addr;\n+}\n+\n@@ -144,1 +182,1 @@\n-  return alloc_object_in_shared_page(_shared_medium_page.addr(), ZPageType::medium, ZPageSizeMedium, size, flags);\n+  return alloc_object_in_medium_page(size, flags);\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.cpp","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zLock.hpp\"\n@@ -42,1 +43,0 @@\n-  ZContended<ZPage*> _shared_medium_page;\n@@ -44,0 +44,2 @@\n+  ZContended<ZPage*> _shared_medium_page;\n+  ZLock              _medium_page_alloc_lock;\n@@ -59,0 +61,3 @@\n+  zaddress alloc_object_in_medium_page(size_t size,\n+                                       ZAllocationFlags flags);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -60,5 +60,2 @@\n-  \/\/ Only copy type and memory layouts. Let the rest be lazily reconstructed when needed.\n-  return new ZPage(_type, _virtual, _physical);\n-}\n-\n-ZPage* ZPage::clone_limited_promote_flipped() const {\n+  \/\/ Only copy type and memory layouts, and also update _top. Let the rest be\n+  \/\/ lazily reconstructed when needed.\n@@ -66,2 +63,0 @@\n-\n-  \/\/ The page is still filled with the same objects, need to retain the top pointer.\n@@ -86,3 +81,4 @@\n-void ZPage::remset_clear() {\n-  _remembered_set.clear_all();\n-}\n+void ZPage::remset_initialize() {\n+  \/\/ Remsets should only be initialized once and only for old pages.\n+  assert(!_remembered_set.is_initialized(), \"Should not be initialized\");\n+  assert(is_old(), \"Only old pages need a remset\");\n@@ -90,25 +86,2 @@\n-void ZPage::verify_remset_after_reset(ZPageAge prev_age, ZPageResetType type) {\n-  \/\/ Young-to-old reset\n-  if (prev_age != ZPageAge::old) {\n-    verify_remset_cleared_previous();\n-    verify_remset_cleared_current();\n-    return;\n-  }\n-\n-  \/\/ Old-to-old reset\n-  switch (type) {\n-  case ZPageResetType::Splitting:\n-    \/\/ Page is on the way to be destroyed or reused, delay\n-    \/\/ clearing until the page is reset for Allocation.\n-    break;\n-\n-  case ZPageResetType::InPlaceRelocation:\n-    \/\/ Relocation failed and page is being compacted in-place.\n-    \/\/ The remset bits are flipped each young mark start, so\n-    \/\/ the verification code below needs to use the right remset.\n-    if (ZGeneration::old()->active_remset_is_current()) {\n-      verify_remset_cleared_previous();\n-    } else {\n-      verify_remset_cleared_current();\n-    }\n-    break;\n+  _remembered_set.initialize(size());\n+}\n@@ -116,3 +89,2 @@\n-  case ZPageResetType::FlipAging:\n-    fatal(\"Should not have called this for old-to-old flipping\");\n-    break;\n+void ZPage::remset_initialize_or_verify_cleared() {\n+  assert(is_old(), \"Only old pages need a remset\");\n@@ -120,2 +92,1 @@\n-  case ZPageResetType::Allocation:\n-    verify_remset_cleared_previous();\n+  if (_remembered_set.is_initialized()) {\n@@ -123,8 +94,3 @@\n-    break;\n-  };\n-}\n-\n-void ZPage::reset_remembered_set() {\n-  if (is_young()) {\n-    \/\/ Remset not needed\n-    return;\n+    verify_remset_cleared_previous();\n+  } else {\n+    remset_initialize();\n@@ -132,0 +98,1 @@\n+}\n@@ -133,6 +100,2 @@\n-  \/\/ Clearing of remsets is done when freeing a page, so this code only\n-  \/\/ needs to ensure the remset is initialized the first time a page\n-  \/\/ becomes old.\n-  if (!_remembered_set.is_initialized()) {\n-    _remembered_set.initialize(size());\n-  }\n+void ZPage::remset_clear() {\n+  _remembered_set.clear_all();\n@@ -141,2 +104,1 @@\n-void ZPage::reset(ZPageAge age, ZPageResetType type) {\n-  const ZPageAge prev_age = _age;\n+void ZPage::reset(ZPageAge age) {\n@@ -151,14 +113,0 @@\n-\n-  \/\/ Flip aged pages are still filled with the same objects, need to retain the top pointer.\n-  if (type != ZPageResetType::FlipAging) {\n-    _top = to_zoffset_end(start());\n-  }\n-\n-  reset_remembered_set();\n-  verify_remset_after_reset(prev_age, type);\n-\n-  if (type != ZPageResetType::InPlaceRelocation || (prev_age != ZPageAge::old && age == ZPageAge::old)) {\n-    \/\/ Promoted in-place relocations reset the live map,\n-    \/\/ because they clone the page.\n-    _livemap.reset();\n-  }\n@@ -167,2 +115,1 @@\n-void ZPage::finalize_reset_for_in_place_relocation() {\n-  \/\/ Now we're done iterating over the livemaps\n+void ZPage::reset_livemap() {\n@@ -172,0 +119,4 @@\n+void ZPage::reset_top_for_allocation() {\n+  _top = to_zoffset_end(start());\n+}\n+\n@@ -191,0 +142,1 @@\n+  assert(vmem.end() == _virtual.start(), \"Should be consecutive\");\n@@ -193,3 +145,0 @@\n-  reset(_age, ZPageResetType::Splitting);\n-\n-  assert(vmem.end() == _virtual.start(), \"Should be consecutive\");\n@@ -271,1 +220,1 @@\n- _remembered_set.clear_current();\n+  _remembered_set.clear_current();\n@@ -275,1 +224,1 @@\n- _remembered_set.clear_previous();\n+  _remembered_set.clear_previous();\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.cpp","additions":26,"deletions":77,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -39,12 +39,0 @@\n-enum class ZPageResetType {\n-  \/\/ Normal allocation path\n-  Allocation,\n-  \/\/ Relocation failed and started to relocate in-place\n-  InPlaceRelocation,\n-  \/\/ Page was not selected for relocation, all objects\n-  \/\/ stayed, but the page aged.\n-  FlipAging,\n-  \/\/ The page was split and needs to be reset\n-  Splitting,\n-};\n-\n@@ -85,1 +73,0 @@\n-  void reset_remembered_set();\n@@ -89,2 +76,0 @@\n-  void verify_remset_after_reset(ZPageAge prev_age, ZPageResetType type);\n-\n@@ -95,1 +80,0 @@\n-  ZPage* clone_limited_promote_flipped() const;\n@@ -131,4 +115,3 @@\n-  void reset(ZPageAge age, ZPageResetType type);\n-\n-  void finalize_reset_for_in_place_relocation();\n-\n+  void reset(ZPageAge age);\n+  void reset_livemap();\n+  void reset_top_for_allocation();\n@@ -175,0 +158,2 @@\n+  void remset_initialize();\n+  void remset_initialize_or_verify_cleared();\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.hpp","additions":5,"deletions":20,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -732,1 +732,6 @@\n-  page->reset(age, ZPageResetType::Allocation);\n+  page->reset(age);\n+  page->reset_top_for_allocation();\n+  page->reset_livemap();\n+  if (age == ZPageAge::old) {\n+    page->remset_initialize_or_verify_cleared();\n+  }\n@@ -988,1 +993,1 @@\n-void ZPageAllocator::handle_alloc_stalling_for_old(bool cleared_soft_refs) {\n+void ZPageAllocator::handle_alloc_stalling_for_old(bool cleared_all_soft_refs) {\n@@ -990,1 +995,1 @@\n-  if (cleared_soft_refs) {\n+  if (cleared_all_soft_refs) {\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-    _clear_all_soft_refs(false),\n+    _uses_clear_all_soft_reference_policy(false),\n@@ -124,1 +124,1 @@\n-void ZReferenceProcessor::set_soft_reference_policy(bool clear) {\n+void ZReferenceProcessor::set_soft_reference_policy(bool clear_all_soft_references) {\n@@ -128,1 +128,1 @@\n-  _clear_all_soft_refs = clear;\n+  _uses_clear_all_soft_reference_policy = clear_all_soft_references;\n@@ -130,1 +130,1 @@\n-  if (clear) {\n+  if (clear_all_soft_references) {\n@@ -139,0 +139,4 @@\n+bool ZReferenceProcessor::uses_clear_all_soft_reference_policy() const {\n+  return _uses_clear_all_soft_reference_policy;\n+}\n+\n@@ -443,1 +447,1 @@\n-  if (_clear_all_soft_refs) {\n+  if (_uses_clear_all_soft_reference_policy) {\n","filename":"src\/hotspot\/share\/gc\/z\/zReferenceProcessor.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  bool                 _clear_all_soft_refs;\n+  bool                 _uses_clear_all_soft_reference_policy;\n@@ -72,1 +72,3 @@\n-  void set_soft_reference_policy(bool clear);\n+  void set_soft_reference_policy(bool clear_all_soft_references);\n+  bool uses_clear_all_soft_reference_policy() const;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zReferenceProcessor.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -846,1 +846,17 @@\n-    to_page->reset(to_age, ZPageResetType::InPlaceRelocation);\n+\n+    \/\/ Reset page for in-place relocation\n+    to_page->reset(to_age);\n+    to_page->reset_top_for_allocation();\n+    if (promotion) {\n+      to_page->remset_initialize();\n+    }\n+\n+    \/\/ Verify that the inactive remset is clear when resetting the page for\n+    \/\/ in-place relocation.\n+    if (from_page->age() == ZPageAge::old) {\n+      if (ZGeneration::old()->active_remset_is_current()) {\n+        to_page->verify_remset_cleared_previous();\n+      } else {\n+        to_page->verify_remset_cleared_current();\n+      }\n+    }\n@@ -1273,2 +1289,8 @@\n-      ZPage* const new_page = promotion ? prev_page->clone_limited_promote_flipped() : prev_page;\n-      new_page->reset(to_age, ZPageResetType::FlipAging);\n+      ZPage* const new_page = promotion ? prev_page->clone_limited() : prev_page;\n+\n+      \/\/ Reset page for flip aging\n+      new_page->reset(to_age);\n+      new_page->reset_livemap();\n+      if (promotion) {\n+        new_page->remset_initialize();\n+      }\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-bool ZRemembered::scan_page(ZPage* page) const {\n+bool ZRemembered::scan_page_and_clear_remset(ZPage* page) const {\n@@ -154,0 +154,14 @@\n+  if (ZVerifyRemembered) {\n+    \/\/ Make sure self healing of pointers is ordered before clearing of\n+    \/\/ the previous bits so that ZVerify::after_scan can detect missing\n+    \/\/ remset entries accurately.\n+    OrderAccess::storestore();\n+  }\n+\n+  \/\/ If we have consumed the remset entries above we also clear them.\n+  \/\/ The exception is if the page is completely empty\/garbage, where we don't\n+  \/\/ want to race with an old collection modifying the remset as well.\n+  if (!can_trust_live_bits || page->is_marked()) {\n+    page->clear_remset_previous();\n+  }\n+\n@@ -503,10 +517,1 @@\n-          bool found_roots = _remembered->scan_page(page);\n-\n-          \/\/ ... and as a side-effect clear the previous entries\n-          if (ZVerifyRemembered) {\n-            \/\/ Make sure self healing of pointers is ordered before clearing of\n-            \/\/ the previous bits so that ZVerify::after_scan can detect missing\n-            \/\/ remset entries accurately.\n-            OrderAccess::storestore();\n-          }\n-          page->clear_remset_previous();\n+          bool found_roots = _remembered->scan_page_and_clear_remset(page);\n","filename":"src\/hotspot\/share\/gc\/z\/zRemembered.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  bool scan_page(ZPage* page) const;\n+  bool scan_page_and_clear_remset(ZPage* page) const;\n","filename":"src\/hotspot\/share\/gc\/z\/zRemembered.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,2 +81,2 @@\n-  clear_current();\n-  clear_previous();\n+  _bitmap[0].clear_large();\n+  _bitmap[1].clear_large();\n","filename":"src\/hotspot\/share\/gc\/z\/zRememberedSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -183,0 +183,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsStaticallyLinked(void);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -646,1 +646,1 @@\n-      constantTag tag = cp->tag_at(cp_index);\n+      constantTag tag = cp->constant_tag_at(cp_index);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -728,1 +728,0 @@\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Should call monitorenter_obj() when using the new lightweight locking\");\n@@ -743,17 +742,0 @@\n-\/\/ NOTE: We provide a separate implementation for the new lightweight locking to workaround a limitation\n-\/\/ of registers in x86_32. This entry point accepts an oop instead of a BasicObjectLock*.\n-\/\/ The problem is that we would need to preserve the register that holds the BasicObjectLock,\n-\/\/ but we are using that register to hold the thread. We don't have enough registers to\n-\/\/ also keep the BasicObjectLock, but we don't really need it anyway, we only need\n-\/\/ the object. See also InterpreterMacroAssembler::lock_object().\n-\/\/ As soon as legacy stack-locking goes away we could remove the other monitorenter() entry\n-\/\/ point, and only use oop-accepting entries (same for monitorexit() below).\n-JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter_obj(JavaThread* current, oopDesc* obj))\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"Should call monitorenter() when not using the new lightweight locking\");\n-  Handle h_obj(current, cast_to_oop(obj));\n-  assert(Universe::heap()->is_in_or_null(h_obj()),\n-         \"must be null or an object\");\n-  ObjectSynchronizer::enter(h_obj, nullptr, current);\n-  return;\n-JRT_END\n-\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -57,0 +58,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -64,0 +66,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -627,12 +630,16 @@\n-        \/\/ Traditional lightweight locking.\n-        markWord displaced = rcvr->mark().set_unlocked();\n-        mon->lock()->set_displaced_header(displaced);\n-        bool call_vm = (LockingMode == LM_MONITOR);\n-        bool inc_monitor_count = true;\n-        if (call_vm || rcvr->cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {\n-          \/\/ Is it simple recursive case?\n-          if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-            mon->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-          } else {\n-            inc_monitor_count = false;\n-            CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);\n+        bool success = false;\n+        if (LockingMode == LM_LEGACY) {\n+           \/\/ Traditional fast locking.\n+          markWord displaced = rcvr->mark().set_unlocked();\n+          mon->lock()->set_displaced_header(displaced);\n+          success = true;\n+          if (rcvr->cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {\n+            \/\/ Is it simple recursive case?\n+            if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+              mon->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+            } else {\n+              success = false;\n+            }\n+          }\n+          if (success) {\n+            THREAD->inc_held_monitor_count();\n@@ -641,2 +648,2 @@\n-        if (inc_monitor_count) {\n-          THREAD->inc_held_monitor_count();\n+        if (!success) {\n+            CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);\n@@ -644,0 +651,1 @@\n+\n@@ -726,12 +734,16 @@\n-      \/\/ traditional lightweight locking\n-      markWord displaced = lockee->mark().set_unlocked();\n-      entry->lock()->set_displaced_header(displaced);\n-      bool call_vm = (LockingMode == LM_MONITOR);\n-      bool inc_monitor_count = true;\n-      if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n-        \/\/ Is it simple recursive case?\n-        if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-          entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-        } else {\n-          inc_monitor_count = false;\n-          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n+      bool success = false;\n+      if (LockingMode == LM_LEGACY) {\n+        \/\/ Traditional fast locking.\n+        markWord displaced = lockee->mark().set_unlocked();\n+        entry->lock()->set_displaced_header(displaced);\n+        success = true;\n+        if (lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n+          \/\/ Is it simple recursive case?\n+          if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+            entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+          } else {\n+            success = false;\n+          }\n+        }\n+        if (success) {\n+          THREAD->inc_held_monitor_count();\n@@ -740,2 +752,2 @@\n-      if (inc_monitor_count) {\n-        THREAD->inc_held_monitor_count();\n+      if (!success) {\n+        CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n@@ -743,0 +755,1 @@\n+\n@@ -1656,12 +1669,16 @@\n-          \/\/ traditional lightweight locking\n-          markWord displaced = lockee->mark().set_unlocked();\n-          entry->lock()->set_displaced_header(displaced);\n-          bool call_vm = (LockingMode == LM_MONITOR);\n-          bool inc_monitor_count = true;\n-          if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n-            \/\/ Is it simple recursive case?\n-            if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-              entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-            } else {\n-              inc_monitor_count = false;\n-              CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n+          bool success = false;\n+          if (LockingMode == LM_LEGACY) {\n+            \/\/ Traditional fast locking.\n+            markWord displaced = lockee->mark().set_unlocked();\n+            entry->lock()->set_displaced_header(displaced);\n+            success = true;\n+            if (lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n+              \/\/ Is it simple recursive case?\n+              if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+                entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+              } else {\n+                success = false;\n+              }\n+            }\n+            if (success) {\n+              THREAD->inc_held_monitor_count();\n@@ -1670,2 +1687,2 @@\n-          if (inc_monitor_count) {\n-            THREAD->inc_held_monitor_count();\n+          if (!success) {\n+            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n@@ -1673,0 +1690,1 @@\n+\n@@ -1690,2 +1708,0 @@\n-            markWord header = lock->displaced_header();\n-            most_recent->set_obj(nullptr);\n@@ -1693,10 +1709,16 @@\n-            \/\/ If it isn't recursive we either must swap old header or call the runtime\n-            bool dec_monitor_count = true;\n-            bool call_vm = (LockingMode == LM_MONITOR);\n-            if (header.to_pointer() != nullptr || call_vm) {\n-              markWord old_header = markWord::encode(lock);\n-              if (call_vm || lockee->cas_set_mark(header, old_header) != old_header) {\n-                \/\/ restore object for the slow case\n-                most_recent->set_obj(lockee);\n-                dec_monitor_count = false;\n-                InterpreterRuntime::monitorexit(most_recent);\n+            bool success = false;\n+            if (LockingMode == LM_LEGACY) {\n+              \/\/ If it isn't recursive we either must swap old header or call the runtime\n+              most_recent->set_obj(nullptr);\n+              success = true;\n+              markWord header = lock->displaced_header();\n+              if (header.to_pointer() != nullptr) {\n+                markWord old_header = markWord::encode(lock);\n+                if (lockee->cas_set_mark(header, old_header) != old_header) {\n+                  \/\/ restore object for the slow case\n+                  most_recent->set_obj(lockee);\n+                  success = false;\n+                }\n+              }\n+              if (success) {\n+                THREAD->dec_held_monitor_count();\n@@ -1705,2 +1727,2 @@\n-            if (dec_monitor_count) {\n-              THREAD->dec_held_monitor_count();\n+            if (!success) {\n+              InterpreterRuntime::monitorexit(most_recent);\n@@ -3128,12 +3150,18 @@\n-          markWord header = lock->displaced_header();\n-          end->set_obj(nullptr);\n-\n-          \/\/ If it isn't recursive we either must swap old header or call the runtime\n-          bool dec_monitor_count = true;\n-          if (header.to_pointer() != nullptr) {\n-            markWord old_header = markWord::encode(lock);\n-            if (lockee->cas_set_mark(header, old_header) != old_header) {\n-              \/\/ restore object for the slow case\n-              end->set_obj(lockee);\n-              dec_monitor_count = false;\n-              InterpreterRuntime::monitorexit(end);\n+\n+          bool success = false;\n+          if (LockingMode == LM_LEGACY) {\n+            markWord header = lock->displaced_header();\n+            end->set_obj(nullptr);\n+\n+            \/\/ If it isn't recursive we either must swap old header or call the runtime\n+            success = true;\n+            if (header.to_pointer() != nullptr) {\n+              markWord old_header = markWord::encode(lock);\n+              if (lockee->cas_set_mark(header, old_header) != old_header) {\n+                \/\/ restore object for the slow case\n+                end->set_obj(lockee);\n+                success = false;\n+              }\n+            }\n+            if (success) {\n+              THREAD->dec_held_monitor_count();\n@@ -3142,2 +3170,2 @@\n-          if (dec_monitor_count) {\n-            THREAD->dec_held_monitor_count();\n+          if (!success) {\n+            InterpreterRuntime::monitorexit(end);\n@@ -3191,1 +3219,1 @@\n-          } else if (LockingMode == LM_MONITOR) {\n+          } else if (LockingMode != LM_LEGACY) {\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":99,"deletions":71,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,1 +295,1 @@\n-    const size_t length = static_cast<size_t>(java_lang_String::utf8_length(string, value)) + 1;\n+    const size_t length = java_lang_String::utf8_length(string, value) + 1;\n@@ -298,1 +298,1 @@\n-    java_lang_String::as_utf8_string(string, value, str, static_cast<int>(length));\n+    java_lang_String::as_utf8_string(string, value, str, length);\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -505,1 +505,1 @@\n-static char* allocate_string(bool c_heap, int length, Thread* thread) {\n+static char* allocate_string(bool c_heap, size_t length, Thread* thread) {\n@@ -514,1 +514,1 @@\n-    const int length = java_lang_String::utf8_length(string, value);\n+    const size_t length = java_lang_String::utf8_length(string, value);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-jboolean JNICALL jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size);\n+void JNICALL jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,0 +194,4 @@\n+  if (!initialize(THREAD)) {\n+    log_error(jfr, system)(\"JfrUpcall could not be initialized.\");\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,4 @@\n-  return name != nullptr ? java_lang_String::as_utf8_string(name, length) : nullptr;\n+  size_t utf8_len;\n+  const char* ret = name != nullptr ? java_lang_String::as_utf8_string(name, utf8_len) : nullptr;\n+  length = checked_cast<int>(utf8_len); \/\/ Thread names should be short\n+  return ret;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadState.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-#include \"memory\/metaspace.hpp\"\n@@ -78,2 +77,3 @@\n-static bool can_compress_element(traceid id) {\n-  return Metaspace::using_class_space() && id < uncompressed_threshold;\n+static bool can_compress_element(const Klass* klass) {\n+  return CompressedKlassPointers::is_in_encoding_range(klass) &&\n+         JfrTraceId::load_raw(klass) < uncompressed_threshold;\n@@ -84,1 +84,1 @@\n-  return element_size(can_compress_element(JfrTraceId::load_raw(klass)));\n+  return element_size(can_compress_element(klass));\n@@ -140,1 +140,2 @@\n-  assert(can_compress_element(id), \"invariant\");\n+  assert(can_compress_element(klass), \"invariant\");\n+  assert(id == JfrTraceId::load_raw(klass), \"invariant\");\n@@ -156,1 +157,1 @@\n-  if (can_compress_element(id)) {\n+  if (can_compress_element(klass)) {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdKlassQueue.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -396,2 +396,1 @@\n-template <typename Instance, void(Instance::*func)()>\n-class JfrVMOperation : public VM_Operation {\n+class JfrSafepointClearVMOperation : public VM_Operation {\n@@ -399,1 +398,10 @@\n-  Instance& _instance;\n+  JfrRecorderService& _instance;\n+ public:\n+  JfrSafepointClearVMOperation(JfrRecorderService& instance) : _instance(instance) {}\n+  void doit() { _instance.safepoint_clear(); }\n+  VMOp_Type type() const { return VMOp_JFRSafepointClear; }\n+};\n+\n+class JfrSafepointWriteVMOperation : public VM_Operation {\n+ private:\n+  JfrRecorderService& _instance;\n@@ -401,3 +409,3 @@\n-  JfrVMOperation(Instance& instance) : _instance(instance) {}\n-  void doit() { (_instance.*func)(); }\n-  VMOp_Type type() const { return VMOp_JFRCheckpoint; }\n+  JfrSafepointWriteVMOperation(JfrRecorderService& instance) : _instance(instance) {}\n+  void doit() { _instance.safepoint_write(); }\n+  VMOp_Type type() const { return VMOp_JFRSafepointWrite; }\n@@ -473,1 +481,1 @@\n-  JfrVMOperation<JfrRecorderService, &JfrRecorderService::safepoint_clear> safepoint_task(*this);\n+  JfrSafepointClearVMOperation op(*this);\n@@ -475,1 +483,1 @@\n-  VMThread::execute(&safepoint_task);\n+  VMThread::execute(&op);\n@@ -580,1 +588,1 @@\n-  JfrVMOperation<JfrRecorderService, &JfrRecorderService::safepoint_write> safepoint_task(*this);\n+  JfrSafepointWriteVMOperation op(*this);\n@@ -583,1 +591,1 @@\n-  VMThread::execute(&safepoint_task);\n+  VMThread::execute(&op);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+  friend class JfrSafepointClearVMOperation;\n+  friend class JfrSafepointWriteVMOperation;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -29,2 +29,1 @@\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/klass.hpp\"\n@@ -203,1 +202,1 @@\n-  return mark((uintptr_t)sym->identity_hash(), sym, leakp);\n+  return mark(sym->identity_hash(), sym, leakp);\n@@ -239,35 +238,8 @@\n-* hidden classes symbol is the external name +\n-* the address of its InstanceKlass slash appended:\n-*   java.lang.invoke.LambdaForm$BMH\/22626602\n-*\n-* caller needs ResourceMark\n-*\/\n-\n-uintptr_t JfrSymbolTable::hidden_klass_name_hash(const InstanceKlass* ik) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != nullptr, \"invariant\");\n-  return (uintptr_t)mirror->identity_hash();\n-}\n-\n-static const char* create_hidden_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  assert(hash != 0, \"invariant\");\n-  char* hidden_symbol = nullptr;\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != nullptr, \"invariant\");\n-  char hash_buf[40];\n-  os::snprintf_checked(hash_buf, sizeof(hash_buf), \"\/\" UINTX_FORMAT, hash);\n-  const size_t hash_len = strlen(hash_buf);\n-  const size_t result_len = ik->name()->utf8_length();\n-  hidden_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);\n-  ik->name()->as_klass_external_name(hidden_symbol, (int)result_len + 1);\n-  assert(strlen(hidden_symbol) == result_len, \"invariant\");\n-  strcpy(hidden_symbol + result_len, hash_buf);\n-  assert(strlen(hidden_symbol) == result_len + hash_len, \"invariant\");\n-  return hidden_symbol;\n-}\n-\n-bool JfrSymbolTable::is_hidden_klass(const Klass* k) {\n+ * The hidden class symbol is the external name with the\n+ * address of its Klass slash appended.\n+ *\n+ * \"java.lang.invoke.LambdaForm$DMH\/0x0000000037144c00\"\n+ *\n+ * Caller needs ResourceMark.\n+ *\/\n+traceid JfrSymbolTable::mark_hidden_klass_name(const Klass* k, bool leakp) {\n@@ -275,9 +247,3 @@\n-  return k->is_instance_klass() && ((const InstanceKlass*)k)->is_hidden();\n-}\n-\n-traceid JfrSymbolTable::mark_hidden_klass_name(const InstanceKlass* ik, bool leakp) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const uintptr_t hash = hidden_klass_name_hash(ik);\n-  const char* const hidden_symbol = create_hidden_klass_symbol(ik, hash);\n-  return mark(hash, hidden_symbol, leakp);\n+  assert(k->is_hidden(), \"invariant\");\n+  const uintptr_t hash = k->name()->identity_hash();\n+  return mark(hash, k->external_name(), leakp);\n@@ -289,3 +255,2 @@\n-  if (is_hidden_klass(k)) {\n-    assert(k->is_instance_klass(), \"invariant\");\n-    symbol_id = mark_hidden_klass_name((const InstanceKlass*)k, leakp);\n+  if (k->is_hidden()) {\n+    symbol_id = mark_hidden_klass_name(k, leakp);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.cpp","additions":17,"deletions":52,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,1 @@\n+  traceid mark_hidden_klass_name(const Klass* k, bool leakp);\n@@ -109,4 +110,0 @@\n-  traceid mark_hidden_klass_name(const InstanceKlass* k, bool leakp);\n-  bool is_hidden_klass(const Klass* k);\n-  uintptr_t hidden_klass_name_hash(const InstanceKlass* ik);\n-\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -52,0 +53,1 @@\n+static int pin_offset = invalid_offset;\n@@ -101,0 +103,7 @@\n+\n+  const char pin_name[] = \"pinVirtualThread\";\n+  Symbol* const pin_sym = SymbolTable::new_symbol(valid_name);\n+  assert(pin_sym != nullptr, \"invariant\");\n+  assert(invalid_offset == pin_offset, \"invariant\");\n+  JfrJavaSupport::compute_field_offset(pin_offset, klass, pin_sym, vmSymbols::bool_signature());\n+  assert(pin_offset != invalid_offset, \"invariant\");\n@@ -222,0 +231,5 @@\n+static inline bool pin_virtual(const JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  return JfrThreadLocal::is_vthread(jt) && VMContinuations;\n+}\n+\n@@ -228,1 +242,1 @@\n-  static const char signature[] = \"(JJJZZ)V\";\n+  static const char signature[] = \"(JJJZZZ)V\";\n@@ -237,0 +251,1 @@\n+  args.push_int(pin_virtual(THREAD) ? (jint)JNI_TRUE : (jint)JNI_FALSE);\n@@ -252,0 +267,1 @@\n+      writer->long_field_put(thread_id_offset, current_tid);\n@@ -254,1 +270,3 @@\n-      writer->long_field_put(thread_id_offset, current_tid);\n+      if (!excluded) {\n+        writer->bool_field_put(pin_offset, pin_virtual(jt));\n+      }\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -713,2 +713,4 @@\n-    if (!THREAD->has_last_Java_frame()) {\n-        JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"Cannot call getJObjectValue without Java frame anchor\"));\n+    \/\/ Ensure that current JNI handle scope is not the top-most JNIHandleBlock as handles\n+    \/\/ in that scope are only released when the thread exits.\n+    if (!THREAD->has_last_Java_frame() && THREAD->active_handles()->pop_frame_link() == nullptr) {\n+        JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"Cannot call getJObjectValue without Java frame anchor or a pushed JNI handle block\"));\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+    static address SharedRuntime_throw_delayed_StackOverflowError_entry;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+address CompilerToVM::Data::SharedRuntime_throw_delayed_StackOverflowError_entry;\n@@ -161,0 +162,1 @@\n+  SharedRuntime_throw_delayed_StackOverflowError_entry = SharedRuntime::throw_delayed_StackOverflowError_entry();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -71,0 +72,2 @@\n+  static_field(CompilerToVM::Data,             SharedRuntime_throw_delayed_StackOverflowError_entry,                                 \\\n+                                                                                       address)                                      \\\n@@ -154,1 +157,1 @@\n-  volatile_nonstatic_field(BasicLock,          _displaced_header,                      markWord)                                     \\\n+  volatile_nonstatic_field(BasicLock,          _metadata,                              uintptr_t)                                    \\\n@@ -244,0 +247,2 @@\n+  nonstatic_field(JavaThread,                  _om_cache,                                     OMCache)                               \\\n+  nonstatic_field(JavaThread,                  _cont_entry,                                   ContinuationEntry*)                    \\\n@@ -248,0 +253,1 @@\n+  nonstatic_field(ContinuationEntry,           _pin_count,                                    uint32_t)                              \\\n@@ -271,0 +277,1 @@\n+  nonstatic_field(Klass,                       _misc_flags._flags,                            u1)                                    \\\n@@ -330,2 +337,0 @@\n-  static_field(StubRoutines,                _throw_delayed_StackOverflowError_entry,          address)                               \\\n-                                                                                                                                     \\\n@@ -481,4 +486,0 @@\n-  declare_constant(JVM_ACC_HAS_FINALIZER)                                 \\\n-  declare_constant(JVM_ACC_IS_CLONEABLE_FAST)                             \\\n-  declare_constant(JVM_ACC_IS_HIDDEN_CLASS)                               \\\n-  declare_constant(JVM_ACC_IS_VALUE_BASED_CLASS)                          \\\n@@ -534,0 +535,2 @@\n+  declare_constant_with_value(\"OMCache::oop_to_oop_difference\", OMCache::oop_to_oop_difference()) \\\n+  declare_constant_with_value(\"OMCache::oop_to_monitor_difference\", OMCache::oop_to_monitor_difference()) \\\n@@ -730,0 +733,4 @@\n+  declare_constant(KlassFlags::_misc_is_hidden_class)                     \\\n+  declare_constant(KlassFlags::_misc_is_value_based_class)                \\\n+  declare_constant(KlassFlags::_misc_has_finalizer)                       \\\n+  declare_constant(KlassFlags::_misc_is_cloneable_fast)                   \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+  LOG_TAG(monitortable) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,2 @@\n-  return Metaspace::allocate(loader_data, word_size, type, THREAD);\n+  assert(type != ClassType, \"class has its own operator new\");\n+  return Metaspace::allocate(loader_data, word_size, type, \/*use_class_space*\/ false, THREAD);\n@@ -85,1 +86,2 @@\n-  return Metaspace::allocate(loader_data, word_size, type);\n+  assert(type != ClassType, \"class has its own operator new\");\n+  return Metaspace::allocate(loader_data, word_size, type, \/*use_class_space*\/ false);\n","filename":"src\/hotspot\/share\/memory\/allocation.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -314,2 +314,0 @@\n-\n-\n@@ -327,6 +325,0 @@\n-  \/\/ Stupid fast special case\n-  if( new_size <= old_size ) {  \/\/ Shrink in-place\n-    if( c_old+old_size == _hwm) \/\/ Attempt to free the excess bytes\n-      _hwm = c_old+new_size;    \/\/ Adjust hwm\n-    return c_old;\n-  }\n@@ -334,1 +326,1 @@\n-  \/\/ make sure that new_size is legal\n+  \/\/ Make sure that new_size is legal\n@@ -337,5 +329,11 @@\n-  \/\/ See if we can resize in-place\n-  if( (c_old+old_size == _hwm) &&       \/\/ Adjusting recent thing\n-      (c_old+corrected_new_size <= _max) ) {      \/\/ Still fits where it sits\n-    _hwm = c_old+corrected_new_size;      \/\/ Adjust hwm\n-    return c_old;               \/\/ Return old pointer\n+  \/\/ Reallocating the latest allocation?\n+  if (c_old + old_size == _hwm) {\n+    assert(_chunk->bottom() <= c_old, \"invariant\");\n+\n+    \/\/ Reallocate in place if it fits. Also handles shrinking\n+    if (pointer_delta(_max, c_old, 1) >= corrected_new_size) {\n+      _hwm = c_old + corrected_new_size;\n+      return c_old;\n+    }\n+  } else if (new_size <= old_size) { \/\/ Shrink in place\n+    return c_old;\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size, bool is_class) {\n+void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size) {\n@@ -135,1 +135,2 @@\n-  if (Metaspace::using_class_space() && is_class) {\n+  const bool is_class = Metaspace::using_class_space() && Metaspace::is_in_class_space(ptr);\n+  if (is_class) {\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-  void deallocate(MetaWord* ptr, size_t word_size, bool is_class);\n+  void deallocate(MetaWord* ptr, size_t word_size);\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-      loader_data->metaspace_non_null()->deallocate((MetaWord*)data, size, false);\n+      loader_data->metaspace_non_null()->deallocate((MetaWord*)data, size);\n@@ -71,1 +71,0 @@\n-      bool is_klass = md->is_klass();\n@@ -79,1 +78,1 @@\n-      loader_data->metaspace_non_null()->deallocate((MetaWord*)md, size, is_klass);\n+      loader_data->metaspace_non_null()->deallocate((MetaWord*)md, size);\n","filename":"src\/hotspot\/share\/memory\/metadataFactory.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -541,0 +541,2 @@\n+const void* Metaspace::_class_space_start = nullptr;\n+const void* Metaspace::_class_space_end = nullptr;\n@@ -573,0 +575,2 @@\n+  _class_space_start = rs.base();\n+  _class_space_end = rs.end();\n@@ -829,1 +833,1 @@\n-                              MetaspaceObj::Type type) {\n+                              MetaspaceObj::Type type, bool use_class_space) {\n@@ -839,1 +843,1 @@\n-  MetadataType mdtype = (type == MetaspaceObj::ClassType) ? ClassType : NonClassType;\n+  MetadataType mdtype = use_class_space ? ClassType : NonClassType;\n@@ -855,1 +859,1 @@\n-                              MetaspaceObj::Type type, TRAPS) {\n+                              MetaspaceObj::Type type, bool use_class_space, TRAPS) {\n@@ -863,1 +867,1 @@\n-  MetaWord* result = allocate(loader_data, word_size, type);\n+  MetaWord* result = allocate(loader_data, word_size, type, use_class_space);\n@@ -866,1 +870,1 @@\n-    MetadataType mdtype = (type == MetaspaceObj::ClassType) ? ClassType : NonClassType;\n+    MetadataType mdtype = use_class_space ? ClassType : NonClassType;\n@@ -896,9 +900,11 @@\n-  Log(gc, metaspace, freelist, oom) log;\n-  if (log.is_info()) {\n-    log.info(\"Metaspace (%s) allocation failed for size \" SIZE_FORMAT,\n-             is_class_space_allocation(mdtype) ? \"class\" : \"data\", word_size);\n-    ResourceMark rm;\n-    if (log.is_debug()) {\n-      if (loader_data->metaspace_or_null() != nullptr) {\n-        LogStream ls(log.debug());\n-        loader_data->print_value_on(&ls);\n+  {\n+    LogMessage(gc, metaspace, freelist, oom) log;\n+    if (log.is_info()) {\n+      log.info(\"Metaspace (%s) allocation failed for size \" SIZE_FORMAT,\n+               is_class_space_allocation(mdtype) ? \"class\" : \"data\", word_size);\n+      ResourceMark rm;\n+      if (log.is_debug()) {\n+        if (loader_data->metaspace_or_null() != nullptr) {\n+          NonInterleavingLogStream ls(LogLevelType::Debug, log);\n+          loader_data->print_value_on(&ls);\n+        }\n@@ -906,0 +912,3 @@\n+      NonInterleavingLogStream ls(LogLevelType::Info, log);\n+      \/\/ In case of an OOM, log out a short but still useful report.\n+      MetaspaceUtils::print_basic_report(&ls, 0);\n@@ -907,3 +916,0 @@\n-    LogStream ls(log.info());\n-    \/\/ In case of an OOM, log out a short but still useful report.\n-    MetaspaceUtils::print_basic_report(&ls, 0);\n@@ -980,6 +986,0 @@\n-bool Metaspace::contains(const void* ptr) {\n-  if (MetaspaceShared::is_in_shared_metaspace(ptr)) {\n-    return true;\n-  }\n-  return contains_non_shared(ptr);\n-}\n@@ -987,4 +987,5 @@\n-bool Metaspace::contains_non_shared(const void* ptr) {\n-  if (using_class_space() && VirtualSpaceList::vslist_class()->contains((MetaWord*)ptr)) {\n-     return true;\n-  }\n+\/\/ Returns true if pointer points into one of the metaspace regions, or\n+\/\/ into the class space.\n+bool Metaspace::is_in_shared_metaspace(const void* ptr) {\n+  return MetaspaceShared::is_in_shared_metaspace(ptr);\n+}\n@@ -992,0 +993,2 @@\n+\/\/ Returns true if pointer points into one of the non-class-space metaspace regions.\n+bool Metaspace::is_in_nonclass_metaspace(const void* ptr) {\n@@ -994,0 +997,1 @@\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":31,"deletions":27,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,4 @@\n+  \/\/ For quick pointer testing: extent of class space; nullptr if no class space.\n+  static const void* _class_space_start;\n+  static const void* _class_space_end;\n+\n@@ -109,1 +113,1 @@\n-                            MetaspaceObj::Type type, TRAPS);\n+                            MetaspaceObj::Type type, bool use_class_space, TRAPS);\n@@ -114,1 +118,15 @@\n-                            MetaspaceObj::Type type);\n+                            MetaspaceObj::Type type, bool use_class_space);\n+\n+  \/\/ Returns true if the pointer points into class space, non-class metaspace, or the\n+  \/\/ metadata portion of the CDS archive.\n+  static bool contains(const void* ptr) {\n+    return is_in_shared_metaspace(ptr) || \/\/ in cds\n+           is_in_class_space(ptr) ||      \/\/ in class space\n+           is_in_nonclass_metaspace(ptr); \/\/ in one of the non-class regions?\n+  }\n+\n+  \/\/ Returns true if the pointer points into class space or into non-class metaspace\n+  static bool contains_non_shared(const void* ptr) {\n+    return is_in_class_space(ptr) ||      \/\/ in class space\n+           is_in_nonclass_metaspace(ptr); \/\/ in one of the non-class regions?\n+  }\n@@ -116,2 +134,12 @@\n-  static bool contains(const void* ptr);\n-  static bool contains_non_shared(const void* ptr);\n+  \/\/ Returns true if pointer points into the CDS klass region.\n+  static bool is_in_shared_metaspace(const void* ptr);\n+\n+  \/\/ Returns true if pointer points into one of the non-class-space metaspace regions.\n+  static bool is_in_nonclass_metaspace(const void* ptr);\n+\n+  \/\/ Returns true if pointer points into class space, false if it doesn't or if\n+  \/\/ there is no class space. Class space is a contiguous region, which is why\n+  \/\/ two address comparisons are enough.\n+  static inline bool is_in_class_space(const void* ptr) {\n+    return ptr < _class_space_end && ptr >= _class_space_start;\n+  }\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include <limits>\n@@ -44,8 +45,1 @@\n-  struct StackIndex {\n-    friend NativeCallStackStorage;\n-    int32_t _stack_index;\n-  public:\n-    static constexpr const int32_t invalid = -1;\n-    static bool equals(const StackIndex& a, const StackIndex& b) {\n-      return a._stack_index == b._stack_index;\n-    }\n+  using StackIndex = int;\n@@ -53,4 +47,11 @@\n-    bool is_invalid() {\n-      return _stack_index == invalid;\n-    }\n-  };\n+private:\n+  constexpr static const StackIndex invalid = std::numeric_limits<StackIndex>::max() - 1;\n+\n+public:\n+  static bool equals(const StackIndex a, const StackIndex b) {\n+    return a == b;\n+  }\n+\n+  static bool is_invalid(StackIndex a) {\n+    return a == invalid;\n+  }\n@@ -86,1 +87,1 @@\n-      return StackIndex{StackIndex::invalid};\n+      return invalid;\n@@ -92,1 +93,1 @@\n-    if (si._stack_index == -1) {\n+    if (is_invalid(si)) {\n@@ -95,1 +96,1 @@\n-    return _stacks.at(si._stack_index);\n+    return _stacks.at(si);\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-             NativeCallStackStorage::StackIndex::equals(a.stack_idx, b.stack_idx);\n+             NativeCallStackStorage::equals(a.stack_idx, b.stack_idx);\n@@ -115,1 +115,1 @@\n-    const NativeCallStackStorage::StackIndex stack() const {\n+    NativeCallStackStorage::StackIndex stack() const {\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,0 @@\n-  bool is_klass() const { return false; }\n","filename":"src\/hotspot\/share\/oops\/annotations.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-                                     MetaspaceObj::array_type(sizeof(T)), THREAD);\n+                                     MetaspaceObj::array_type(sizeof(T)), false, THREAD);\n","filename":"src\/hotspot\/share\/oops\/array.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,4 @@\n+void* ArrayKlass::operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw() {\n+  return Metaspace::allocate(loader_data, word_size, MetaspaceObj::ClassType, true, THREAD);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,2 @@\n+  void* operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw();\n+\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,0 +110,12 @@\n+\n+  \/\/ Returns whether the pointer is in the memory region used for encoding compressed\n+  \/\/ class pointers.  This includes CDS.\n+\n+  \/\/ encoding                                                               encoding\n+  \/\/ base                                                                   end (base+range)\n+  \/\/ |-----------------------------------------------------------------------|\n+  \/\/ |----CDS---| |--------------------class space---------------------------|\n+\n+  static inline bool is_in_encoding_range(const void* p) {\n+    return p >= _base && p < (_base + _range);\n+  }\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -473,1 +473,0 @@\n-  bool is_klass() const { return false; }\n","filename":"src\/hotspot\/share\/oops\/constMethod.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -234,1 +234,0 @@\n-  bool is_klass() const { return false; }\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -439,3 +439,0 @@\n-        assert(!fellThrough, \"should not happen\");\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n-        break;\n@@ -444,1 +441,4 @@\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n+        \/\/ If this is the last bytecode, there is no successor to mark\n+        if (bci + Bytecodes::length_for(bytecode) < method()->code_size()) {\n+          bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n+        }\n@@ -505,1 +505,4 @@\n-            reachable_basicblock(this, bci + Bytecodes::length_for(bytecode), &change);\n+            \/\/ If this is the last bytecode, there is no successor to mark\n+            if (bci + Bytecodes::length_for(bytecode) < method()->code_size()) {\n+              reachable_basicblock(this, bci + Bytecodes::length_for(bytecode), &change);\n+            }\n@@ -589,3 +592,0 @@\n-\n-\n-\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -440,0 +440,5 @@\n+void* InstanceKlass::operator new(size_t size, ClassLoaderData* loader_data, size_t word_size,\n+                                  bool use_class_space, TRAPS) throw() {\n+  return Metaspace::allocate(loader_data, word_size, ClassType, use_class_space, THREAD);\n+}\n+\n@@ -452,0 +457,1 @@\n+  const bool use_class_space = !parser.is_interface() && !parser.is_abstract();\n@@ -456,1 +462,1 @@\n-    ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);\n+    ik = new (loader_data, size, use_class_space, THREAD) InstanceRefKlass(parser);\n@@ -459,1 +465,1 @@\n-    ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);\n+    ik = new (loader_data, size, use_class_space, THREAD) InstanceMirrorKlass(parser);\n@@ -462,1 +468,1 @@\n-    ik = new (loader_data, size, THREAD) InstanceStackChunkKlass(parser);\n+    ik = new (loader_data, size, use_class_space, THREAD) InstanceStackChunkKlass(parser);\n@@ -465,1 +471,1 @@\n-    ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);\n+    ik = new (loader_data, size, use_class_space, THREAD) InstanceClassLoaderKlass(parser);\n@@ -468,1 +474,1 @@\n-    ik = new (loader_data, size, THREAD) InstanceKlass(parser);\n+    ik = new (loader_data, size, use_class_space, THREAD) InstanceKlass(parser);\n@@ -2662,2 +2668,2 @@\n-  \/\/ Initialize @ValueBased class annotation\n-  if (DiagnoseSyncOnValueBasedClasses && has_value_based_class_annotation()) {\n+  \/\/ Initialize @ValueBased class annotation if not already set in the archived klass.\n+  if (DiagnoseSyncOnValueBasedClasses && has_value_based_class_annotation() && !is_value_based()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -147,0 +148,2 @@\n+  void* operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, bool use_class_space, TRAPS) throw();\n+\n@@ -228,4 +231,0 @@\n-  \/\/ _is_marked_dependent can be set concurrently, thus cannot be part of the\n-  \/\/ _misc_flags.\n-  bool            _is_marked_dependent;     \/\/ used for marking during flushing and deoptimization\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-    f.print_value_on(_st, nullptr);\n+    f.print_value_on(_st);\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  return _access_flags.is_cloneable_fast() ||\n+  return _misc_flags.is_cloneable_fast() ||\n@@ -79,1 +79,1 @@\n-    _access_flags.set_is_cloneable_fast();\n+    _misc_flags.set_is_cloneable_fast(true);\n@@ -250,4 +250,0 @@\n-void* Klass::operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw() {\n-  return Metaspace::allocate(loader_data, word_size, MetaspaceObj::ClassType, THREAD);\n-}\n-\n@@ -978,0 +974,1 @@\n+  st->print(BULLET\"flags: \"); _misc_flags.print_on(st); st->cr();\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/klassFlags.hpp\"\n@@ -168,0 +169,2 @@\n+                                \/\/ Some flags created by the JVM, not in the class file itself,\n+                                \/\/ are in _misc_flags below.\n@@ -197,0 +200,2 @@\n+  KlassFlags  _misc_flags;\n+\n@@ -204,2 +209,0 @@\n-  void* operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw();\n-\n@@ -431,0 +434,1 @@\n+  static ByteSize misc_flags_offset()            { return byte_offset_of(Klass, _misc_flags._flags); }\n@@ -695,6 +699,8 @@\n-  bool has_finalizer() const            { return _access_flags.has_finalizer(); }\n-  void set_has_finalizer()              { _access_flags.set_has_finalizer(); }\n-  bool is_hidden() const                { return access_flags().is_hidden_class(); }\n-  void set_is_hidden()                  { _access_flags.set_is_hidden_class(); }\n-  bool is_value_based()                 { return _access_flags.is_value_based_class(); }\n-  void set_is_value_based()             { _access_flags.set_is_value_based_class(); }\n+  bool has_finalizer() const            { return _misc_flags.has_finalizer(); }\n+  void set_has_finalizer()              { _misc_flags.set_has_finalizer(true); }\n+  bool is_hidden() const                { return _misc_flags.is_hidden_class(); }\n+  void set_is_hidden()                  { _misc_flags.set_is_hidden_class(true); }\n+  bool is_value_based() const           { return _misc_flags.is_value_based_class(); }\n+  void set_is_value_based()             { _misc_flags.set_is_value_based_class(true); }\n+\n+  klass_flags_t misc_flags() const      { return _misc_flags.value(); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,1 @@\n-  return access_flags().is_hidden_class() &&\n-         class_loader_data()->has_class_mirror_holder();\n+  return is_hidden() && class_loader_data()->has_class_mirror_holder();\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/klassFlags.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+void KlassFlags::print_on(outputStream* st) const {\n+#define KLASS_FLAGS_PRINT(name, ignore)          \\\n+  if (name()) st->print(#name \" \");\n+  KLASS_FLAGS_DO(KLASS_FLAGS_PRINT)\n+#undef KLASS_FLAGS_PRINT\n+}\n","filename":"src\/hotspot\/share\/oops\/klassFlags.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_KLASSFLAGS_HPP\n+#define SHARE_OOPS_KLASSFLAGS_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+\n+\/\/ The Klass class contains only parse-time flags and are used by generated code, even though\n+\/\/ most apply to InstanceKlass, access is more straightforward through Klass pointers.\n+\/\/ These flags are JVM internal and not part of the AccessFlags classfile specification.\n+\n+using klass_flags_t = u1;\n+\n+class KlassFlags {\n+  friend class VMStructs;\n+  friend class JVMCIVMStructs;\n+\n+ public:\n+#define KLASS_FLAGS_DO(flag)  \\\n+    flag(is_hidden_class              , 1 << 0) \\\n+    flag(is_value_based_class         , 1 << 1) \\\n+    flag(has_finalizer                , 1 << 2) \\\n+    flag(is_cloneable_fast            , 1 << 3) \\\n+    \/* end of list *\/\n+\n+#define KLASS_FLAGS_ENUM_NAME(name, value)    _misc_##name = value,\n+  enum {\n+    KLASS_FLAGS_DO(KLASS_FLAGS_ENUM_NAME)\n+  };\n+#undef KLASS_FLAGS_ENUM_NAME\n+\n+  \/\/ These flags are write-once before the class is published and then read-only\n+  \/\/ so don't require atomic updates.\n+  klass_flags_t _flags;\n+\n+ public:\n+  KlassFlags() : _flags(0) {}\n+\n+  klass_flags_t value() const { return _flags; }\n+\n+  \/\/ Create getters and setters for the flag values.\n+#define KLASS_FLAGS_GET_SET(name, ignore)          \\\n+  bool name() const { return (_flags & _misc_##name) != 0; } \\\n+  void set_##name(bool b) {         \\\n+    assert(!name(), \"set once\");    \\\n+    if (b) _flags |= _misc_##name; \\\n+  }\n+  KLASS_FLAGS_DO(KLASS_FLAGS_GET_SET)\n+#undef KLASS_FLAGS_GET_SET\n+\n+  void print_on(outputStream* st) const;\n+};\n+\n+#endif \/\/ SHARE_OOPS_KLASSFLAGS_HPP\n","filename":"src\/hotspot\/share\/oops\/klassFlags.hpp","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -70,1 +71,1 @@\n-    if (print_monitor_info) {\n+    if (print_monitor_info && !UseObjectMonitorTable) {\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-\/\/    [ptr             | 10]  monitor            inflated lock (header is swapped out)\n+\/\/    [ptr             | 10]  monitor            inflated lock (header is swapped out, UseObjectMonitorTable == false)\n+\/\/    [header          | 10]  monitor            inflated lock (UseObjectMonitorTable == true)\n@@ -200,0 +201,1 @@\n+    assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use markWord for monitors\");\n@@ -205,2 +207,5 @@\n-    return LockingMode == LM_LIGHTWEIGHT  ? lockbits == monitor_value   \/\/ monitor?\n-                                          : (lockbits & unlocked_value) == 0; \/\/ monitor | stack-locked?\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      return !UseObjectMonitorTable && lockbits == monitor_value;\n+    }\n+    \/\/ monitor (0b10) | stack-locked (0b00)?\n+    return (lockbits & unlocked_value) == 0;\n@@ -226,0 +231,1 @@\n+    assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use markWord for monitors\");\n@@ -230,0 +236,4 @@\n+  markWord set_has_monitor() const {\n+    return markWord((value() & ~lock_mask_in_place) | monitor_value);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -86,2 +86,0 @@\n-    bool is_klass() const { return false; }\n-\n","filename":"src\/hotspot\/share\/oops\/recordComponent.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  int quoted_length = UTF8::quoted_ascii_length(ptr, utf8_length());\n+  size_t quoted_length = UTF8::quoted_ascii_length(ptr, utf8_length());\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -318,1 +318,3 @@\n-      double min_freq = MAX2(MinInlineFrequencyRatio, 1.0 \/ CompilationPolicy::min_invocations());\n+      \/\/ avoid division by 0, set divisor to at least 1\n+      int cp_min_inv = MAX2(1, CompilationPolicy::min_invocations());\n+      double min_freq = MAX2(MinInlineFrequencyRatio, 1.0 \/ cp_min_inv);\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  Label _slow_path;\n@@ -114,0 +115,1 @@\n+  Label& slow_path() { return _slow_path; }\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -734,0 +734,2 @@\n+  case vmIntrinsics::_Continuation_pin:\n+  case vmIntrinsics::_Continuation_unpin:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -757,1 +757,1 @@\n-      init_start(s);\n+      verify_start(s);\n@@ -764,1 +764,1 @@\n-      init_start(s);\n+      verify_start(s);\n@@ -1108,6 +1108,4 @@\n-\/\/---------------------------init_start----------------------------------------\n-\/\/ Install the StartNode on this compile object.\n-void Compile::init_start(StartNode* s) {\n-  if (failing())\n-    return; \/\/ already failing\n-  assert(s == start(), \"\");\n+#ifdef ASSERT\n+\/\/ Verify that the current StartNode is valid.\n+void Compile::verify_start(StartNode* s) const {\n+  assert(failing() || s == start(), \"should be StartNode\");\n@@ -1115,0 +1113,1 @@\n+#endif\n@@ -1704,0 +1703,2 @@\n+      if (flat->offset() == in_bytes(Klass::misc_flags_offset()))\n+        alias_type(idx)->set_rewritable(false);\n@@ -5199,1 +5200,14 @@\n-    ss.print(\": %d %s \", n->_idx, NodeClassNames[n->Opcode()]);\n+    ss.print(\": %d %s\", n->_idx, NodeClassNames[n->Opcode()]);\n+    if (n->is_Call()) {\n+      CallNode* call = n->as_Call();\n+      if (call->_name != nullptr) {\n+        \/\/ E.g. uncommon traps etc.\n+        ss.print(\" - %s\", call->_name);\n+      } else if (call->is_CallJava()) {\n+        CallJavaNode* call_java = call->as_CallJava();\n+        if (call_java->method() != nullptr) {\n+          ss.print(\" -\");\n+          call_java->method()->print_short_name(&ss);\n+        }\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -867,1 +867,1 @@\n-  void         init_start(StartNode* s);\n+  void         verify_start(StartNode* s) const NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-  C->init_start(start);\n+  C->verify_start(start);\n","filename":"src\/hotspot\/share\/opto\/generateOptoStub.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -485,0 +485,3 @@\n+  case vmIntrinsics::_Continuation_pin:          return inline_native_Continuation_pinning(false);\n+  case vmIntrinsics::_Continuation_unpin:        return inline_native_Continuation_pinning(true);\n+\n@@ -3170,1 +3173,1 @@\n-                                              StubRoutines::jfr_return_lease(),\n+                                              SharedRuntime::jfr_return_lease(),\n@@ -3233,0 +3236,1 @@\n+ * bool pinVirtualThread;\n@@ -3237,0 +3241,1 @@\n+ *   pinVirtualThread = VMContinuations;\n@@ -3248,0 +3253,1 @@\n+ *   pinVirtualThread = false;\n@@ -3253,1 +3259,1 @@\n- *   setField(event_writer, \"threadID\", tid);\n+ *   setField(event_writer, \"pinVirtualThread\", pinVirtualThread);\n@@ -3255,0 +3261,1 @@\n+ *   setField(event_writer, \"threadID\", tid);\n@@ -3325,0 +3332,4 @@\n+  \/\/ Continuation support determines if a virtual thread should be pinned.\n+  Node* global_addr = makecon(TypeRawPtr::make((address)&VMContinuations));\n+  Node* continuation_support = make_load(control(), global_addr, TypeInt::BOOL, T_BOOLEAN, MemNode::unordered);\n+\n@@ -3369,1 +3380,1 @@\n-                                                  StubRoutines::jfr_write_checkpoint(),\n+                                                  SharedRuntime::jfr_write_checkpoint(),\n@@ -3415,0 +3426,2 @@\n+  PhiNode* pinVirtualThread = new PhiNode(vthread_compare_rgn, TypeInt::BOOL);\n+  record_for_igvn(pinVirtualThread);\n@@ -3427,0 +3440,2 @@\n+  pinVirtualThread->init_req(_true_path, _gvn.transform(continuation_support));\n+  pinVirtualThread->init_req(_false_path, _gvn.intcon(0));\n@@ -3450,0 +3465,3 @@\n+  \/\/ Get the field offset to, conditionally, store an updated pinVirtualThread value later.\n+  Node* const event_writer_pin_field = field_address_from_object(event_writer, \"pinVirtualThread\", \"Z\", false);\n+  const TypePtr* event_writer_pin_field_type = _gvn.type(event_writer_pin_field)->isa_ptr();\n@@ -3470,0 +3488,3 @@\n+  \/\/ Store the pin state to the event writer.\n+  store_to_memory(tid_is_not_equal, event_writer_pin_field, _gvn.transform(pinVirtualThread), T_BOOLEAN, event_writer_pin_field_type, MemNode::unordered);\n+\n@@ -3718,0 +3739,87 @@\n+\/\/------------------------inline_native_Continuation_pin and unpin-----------\n+\n+\/\/ Shared implementation routine for both pin and unpin.\n+bool LibraryCallKit::inline_native_Continuation_pinning(bool unpin) {\n+  enum { _true_path = 1, _false_path = 2, PATH_LIMIT };\n+\n+  \/\/ Save input memory.\n+  Node* input_memory_state = reset_memory();\n+  set_all_memory(input_memory_state);\n+\n+  \/\/ TLS\n+  Node* tls_ptr = _gvn.transform(new ThreadLocalNode());\n+  Node* last_continuation_offset = basic_plus_adr(top(), tls_ptr, in_bytes(JavaThread::cont_entry_offset()));\n+  Node* last_continuation = make_load(control(), last_continuation_offset, last_continuation_offset->get_ptr_type(), T_ADDRESS, MemNode::unordered);\n+\n+  \/\/ Null check the last continuation object.\n+  Node* continuation_cmp_null = _gvn.transform(new CmpPNode(last_continuation, null()));\n+  Node* test_continuation_not_equal_null = _gvn.transform(new BoolNode(continuation_cmp_null, BoolTest::ne));\n+  IfNode* iff_continuation_not_equal_null = create_and_map_if(control(), test_continuation_not_equal_null, PROB_MAX, COUNT_UNKNOWN);\n+\n+  \/\/ False path, last continuation is null.\n+  Node* continuation_is_null = _gvn.transform(new IfFalseNode(iff_continuation_not_equal_null));\n+\n+  \/\/ True path, last continuation is not null.\n+  Node* continuation_is_not_null = _gvn.transform(new IfTrueNode(iff_continuation_not_equal_null));\n+\n+  set_control(continuation_is_not_null);\n+\n+  \/\/ Load the pin count from the last continuation.\n+  Node* pin_count_offset = basic_plus_adr(top(), last_continuation, in_bytes(ContinuationEntry::pin_count_offset()));\n+  Node* pin_count = make_load(control(), pin_count_offset, TypeInt::INT, T_INT, MemNode::unordered);\n+\n+  \/\/ The loaded pin count is compared against a context specific rhs for over\/underflow detection.\n+  Node* pin_count_rhs;\n+  if (unpin) {\n+    pin_count_rhs = _gvn.intcon(0);\n+  } else {\n+    pin_count_rhs = _gvn.intcon(UINT32_MAX);\n+  }\n+  Node* pin_count_cmp = _gvn.transform(new CmpUNode(_gvn.transform(pin_count), pin_count_rhs));\n+  Node* test_pin_count_over_underflow = _gvn.transform(new BoolNode(pin_count_cmp, BoolTest::eq));\n+  IfNode* iff_pin_count_over_underflow = create_and_map_if(control(), test_pin_count_over_underflow, PROB_MIN, COUNT_UNKNOWN);\n+\n+  \/\/ False branch, no pin count over\/underflow. Increment or decrement pin count and store back.\n+  Node* valid_pin_count = _gvn.transform(new IfFalseNode(iff_pin_count_over_underflow));\n+  set_control(valid_pin_count);\n+\n+  Node* next_pin_count;\n+  if (unpin) {\n+    next_pin_count = _gvn.transform(new SubINode(pin_count, _gvn.intcon(1)));\n+  } else {\n+    next_pin_count = _gvn.transform(new AddINode(pin_count, _gvn.intcon(1)));\n+  }\n+\n+  Node* updated_pin_count_memory = store_to_memory(control(), pin_count_offset, next_pin_count, T_INT, Compile::AliasIdxRaw, MemNode::unordered);\n+\n+  \/\/ True branch, pin count over\/underflow.\n+  Node* pin_count_over_underflow = _gvn.transform(new IfTrueNode(iff_pin_count_over_underflow));\n+  {\n+    \/\/ Trap (but not deoptimize (Action_none)) and continue in the interpreter\n+    \/\/ which will throw IllegalStateException for pin count over\/underflow.\n+    PreserveJVMState pjvms(this);\n+    set_control(pin_count_over_underflow);\n+    set_all_memory(input_memory_state);\n+    uncommon_trap_exact(Deoptimization::Reason_intrinsic,\n+                        Deoptimization::Action_none);\n+    assert(stopped(), \"invariant\");\n+  }\n+\n+  \/\/ Result of top level CFG and Memory.\n+  RegionNode* result_rgn = new RegionNode(PATH_LIMIT);\n+  record_for_igvn(result_rgn);\n+  PhiNode* result_mem = new PhiNode(result_rgn, Type::MEMORY, TypePtr::BOTTOM);\n+  record_for_igvn(result_mem);\n+\n+  result_rgn->init_req(_true_path, _gvn.transform(valid_pin_count));\n+  result_rgn->init_req(_false_path, _gvn.transform(continuation_is_null));\n+  result_mem->init_req(_true_path, _gvn.transform(updated_pin_count_memory));\n+  result_mem->init_req(_false_path, _gvn.transform(input_memory_state));\n+\n+  \/\/ Set output state.\n+  set_control(_gvn.transform(result_rgn));\n+  set_all_memory(_gvn.transform(result_mem));\n+\n+  return true;\n+}\n+\n@@ -3755,1 +3863,1 @@\n-\/\/ Use this for JVM_ACC_INTERFACE, JVM_ACC_IS_CLONEABLE_FAST, JVM_ACC_HAS_FINALIZER.\n+\/\/ Use this for JVM_ACC_INTERFACE.\n@@ -3757,1 +3865,2 @@\n-Node* LibraryCallKit::generate_access_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region) {\n+Node* LibraryCallKit::generate_klass_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region,\n+                                                 ByteSize offset, const Type* type, BasicType bt) {\n@@ -3760,2 +3869,2 @@\n-  Node* modp = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));\n-  Node* mods = make_load(nullptr, modp, TypeInt::INT, T_INT, MemNode::unordered);\n+  Node* modp = basic_plus_adr(kls, in_bytes(offset));\n+  Node* mods = make_load(nullptr, modp, type, bt, MemNode::unordered);\n@@ -3770,1 +3879,2 @@\n-  return generate_access_flags_guard(kls, JVM_ACC_INTERFACE, 0, region);\n+  return generate_klass_flags_guard(kls, JVM_ACC_INTERFACE, 0, region,\n+                                    Klass::access_flags_offset(), TypeInt::INT, T_INT);\n@@ -3772,0 +3882,7 @@\n+\n+\/\/ Use this for testing if Klass is_hidden, has_finalizer, and is_cloneable_fast.\n+Node* LibraryCallKit::generate_misc_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region) {\n+  return generate_klass_flags_guard(kls, modifier_mask, modifier_bits, region,\n+                                    Klass::misc_flags_offset(), TypeInt::UBYTE, T_BOOLEAN);\n+}\n+\n@@ -3773,1 +3890,1 @@\n-  return generate_access_flags_guard(kls, JVM_ACC_IS_HIDDEN_CLASS, 0, region);\n+  return generate_misc_flags_guard(kls, KlassFlags::_misc_is_hidden_class, 0, region);\n@@ -4607,7 +4724,8 @@\n-  \/\/ Test the header to see if it is safe to read w.r.t. locking.\n-  Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n-  Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n-    Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n-    Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n+  if (!UseObjectMonitorTable) {\n+    \/\/ Test the header to see if it is safe to read w.r.t. locking.\n+    Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n+    Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n+      Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n+      Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n@@ -4615,5 +4733,5 @@\n-    generate_slow_guard(test_monitor, slow_region);\n-  } else {\n-    Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n-    Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n-    Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n+      generate_slow_guard(test_monitor, slow_region);\n+    } else {\n+      Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n+      Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n+      Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n@@ -4621,1 +4739,2 @@\n-    generate_slow_guard(test_not_unlocked, slow_region);\n+      generate_slow_guard(test_not_unlocked, slow_region);\n+    }\n@@ -5213,6 +5332,6 @@\n-      generate_access_flags_guard(obj_klass,\n-                                  \/\/ Test both conditions:\n-                                  JVM_ACC_IS_CLONEABLE_FAST | JVM_ACC_HAS_FINALIZER,\n-                                  \/\/ Must be cloneable but not finalizer:\n-                                  JVM_ACC_IS_CLONEABLE_FAST,\n-                                  slow_region);\n+      generate_misc_flags_guard(obj_klass,\n+                                \/\/ Test both conditions:\n+                                KlassFlags::_misc_is_cloneable_fast | KlassFlags::_misc_has_finalizer,\n+                                \/\/ Must be cloneable but not finalizer:\n+                                KlassFlags::_misc_is_cloneable_fast,\n+                                slow_region);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":147,"deletions":28,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -159,3 +159,5 @@\n-  Node* generate_access_flags_guard(Node* kls,\n-                                    int modifier_mask, int modifier_bits,\n-                                    RegionNode* region);\n+  Node* generate_klass_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region,\n+                                   ByteSize offset, const Type* type, BasicType bt);\n+  Node* generate_misc_flags_guard(Node* kls,\n+                                  int modifier_mask, int modifier_bits,\n+                                  RegionNode* region);\n@@ -244,0 +246,1 @@\n+  bool inline_native_Continuation_pinning(bool unpin);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1312,13 +1312,0 @@\n-Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {\n-  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n-  register_new_node(castii, ctrl);\n-  for (DUIterator_Fast imax, i = incr->fast_outs(imax); i < imax; i++) {\n-    Node* n = incr->fast_out(i);\n-    if (n->is_Phi() && n->in(0) == loop) {\n-      int nrep = n->replace_edge(incr, castii, &_igvn);\n-      return castii;\n-    }\n-  }\n-  return nullptr;\n-}\n-\n@@ -1683,3 +1670,0 @@\n-  \/\/ CastII for the main loop:\n-  Node* castii = cast_incr_before_loop(pre_incr, min_taken, main_head);\n-  assert(castii != nullptr, \"no castII inserted\");\n@@ -1687,1 +1671,1 @@\n-  copy_assertion_predicates_to_main_loop(pre_head, castii, stride, outer_loop, outer_main_head, dd_main_head,\n+  copy_assertion_predicates_to_main_loop(pre_head, pre_incr, stride, outer_loop, outer_main_head, dd_main_head,\n@@ -1690,1 +1674,1 @@\n-  copy_assertion_predicates_to_post_loop(outer_main_head, post_head, post_incr, stride);\n+  copy_assertion_predicates_to_post_loop(outer_main_head, post_head, stride);\n@@ -1702,2 +1686,2 @@\n-  register_new_node(pre_limit, pre_head->in(0));\n-  register_new_node(pre_opaq , pre_head->in(0));\n+  register_new_node(pre_limit, pre_head->in(LoopNode::EntryControl));\n+  register_new_node(pre_opaq , pre_head->in(LoopNode::EntryControl));\n@@ -1815,1 +1799,1 @@\n-  copy_assertion_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n+  copy_assertion_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, main_head->stride());\n@@ -1918,4 +1902,0 @@\n-  \/\/ CastII for the new post loop:\n-  incr = cast_incr_before_loop(zer_opaq->in(1), zer_taken, post_head);\n-  assert(incr != nullptr, \"no castII inserted\");\n-\n@@ -1937,6 +1917,0 @@\n-  if (init->is_CastII()) {\n-    \/\/ skip over the cast added by PhaseIdealLoop::cast_incr_before_loop() when pre\/post\/main loops are created because\n-    \/\/ it can get in the way of type propagation\n-    assert(init->as_CastII()->carry_dependency() && loop_head->skip_assertion_predicates_with_halt() == init->in(0), \"casted iv phi from pre loop expected\");\n-    init = init->in(1);\n-  }\n@@ -1991,1 +1965,3 @@\n-                                                            Node* init, Node* stride) {\n+                                                            Node* stride) {\n+  Node* opaq = post_loop_head->is_canonical_loop_entry();\n+  Node* init = opaq->in(1);\n@@ -2817,0 +2793,1 @@\n+  Node* main_limit_ctrl = get_ctrl(main_limit);\n@@ -2849,0 +2826,1 @@\n+  Node* pre_limit_ctrl = get_ctrl(pre_limit);\n@@ -2851,1 +2829,6 @@\n-  Node *pre_ctrl = pre_end->loopnode()->in(LoopNode::EntryControl);\n+  Node* pre_ctrl = pre_end->loopnode()->in(LoopNode::EntryControl);\n+  \/\/ Range check elimination optimizes out conditions whose parameters are loop invariant in the main loop. They usually\n+  \/\/ have control above the pre loop, but there's no guarantee that they do. There's no guarantee either that the pre\n+  \/\/ loop limit has control that's out of loop (a previous round of range check elimination could have set a limit that's\n+  \/\/ not loop invariant).\n+  Node* new_limit_ctrl = dominated_node(pre_ctrl, pre_limit_ctrl);\n@@ -2911,2 +2894,2 @@\n-      Node *limit_c = get_ctrl(limit);\n-      if (loop->is_member(get_loop(limit_c))) {\n+      Node* limit_ctrl = get_ctrl(limit);\n+      if (loop->is_member(get_loop(limit_ctrl))) {\n@@ -2917,2 +2900,2 @@\n-        limit_c = get_ctrl(limit);\n-        if (loop->is_member(get_loop(limit_c))) {\n+        limit_ctrl = get_ctrl(limit);\n+        if (loop->is_member(get_loop(limit_ctrl))) {\n@@ -2927,1 +2910,1 @@\n-      if (is_dominator(ctrl, limit_c)) {\n+      if (is_dominator(ctrl, limit_ctrl)) {\n@@ -2931,1 +2914,1 @@\n-      assert(is_dominator(compute_early_ctrl(limit, limit_c), pre_end), \"node pinned on loop exit test?\");\n+      assert(is_dominator(compute_early_ctrl(limit, limit_ctrl), pre_end), \"node pinned on loop exit test?\");\n@@ -2940,2 +2923,2 @@\n-      Node *offset_c = get_ctrl(offset);\n-      if (loop->is_member(get_loop(offset_c))) {\n+      Node* offset_ctrl = get_ctrl(offset);\n+      if (loop->is_member(get_loop(offset_ctrl))) {\n@@ -2948,1 +2931,1 @@\n-      if (is_dominator(ctrl, offset_c)) {\n+      if (is_dominator(ctrl, offset_ctrl)) {\n@@ -2952,1 +2935,8 @@\n-      assert(is_dominator(compute_early_ctrl(offset, offset_c), pre_end), \"node pinned on loop exit test?\");\n+      \/\/ offset and limit can have control set below the pre loop when they are not loop invariant in the pre loop.\n+      \/\/ Update their control (and the control of inputs as needed) to be above pre_end\n+      offset_ctrl = ensure_node_and_inputs_are_above_pre_end(pre_end, offset);\n+      limit_ctrl = ensure_node_and_inputs_are_above_pre_end(pre_end, limit);\n+\n+      \/\/ offset and limit could have control below new_limit_ctrl if they are not loop invariant in the pre loop.\n+      new_limit_ctrl = dominated_node(new_limit_ctrl, offset_ctrl, limit_ctrl);\n+\n@@ -2972,1 +2962,1 @@\n-      register_new_node(offset, pre_ctrl);\n+      register_new_node(offset, new_limit_ctrl);\n@@ -2975,1 +2965,1 @@\n-      register_new_node(limit, pre_ctrl);\n+      register_new_node(limit, new_limit_ctrl);\n@@ -2981,1 +2971,1 @@\n-          add_constraint(stride_con, lscale_con, offset, zero, limit, pre_ctrl, &pre_limit, &main_limit);\n+          add_constraint(stride_con, lscale_con, offset, zero, limit, new_limit_ctrl, &pre_limit, &main_limit);\n@@ -3040,1 +3030,1 @@\n-          register_new_node(offset, pre_ctrl);\n+          register_new_node(offset, new_limit_ctrl);\n@@ -3042,1 +3032,1 @@\n-          register_new_node(limit, pre_ctrl);\n+          register_new_node(limit, new_limit_ctrl);\n@@ -3048,1 +3038,1 @@\n-            register_new_node(limit, pre_ctrl);\n+            register_new_node(limit, new_limit_ctrl);\n@@ -3055,1 +3045,1 @@\n-          add_constraint(stride_con, lscale_con, offset, mini, limit, pre_ctrl, &pre_limit, &main_limit);\n+          add_constraint(stride_con, lscale_con, offset, mini, limit, new_limit_ctrl, &pre_limit, &main_limit);\n@@ -3099,1 +3089,1 @@\n-    register_new_node(pre_limit, pre_ctrl);\n+    register_new_node(pre_limit, new_limit_ctrl);\n@@ -3101,0 +3091,6 @@\n+  \/\/ new pre_limit can push Bool\/Cmp\/Opaque nodes down (when one of the eliminated condition has parameters that are not\n+  \/\/ loop invariant in the pre loop.\n+  set_ctrl(pre_opaq, new_limit_ctrl);\n+  set_ctrl(pre_end->cmp_node(), new_limit_ctrl);\n+  set_ctrl(pre_end->in(1), new_limit_ctrl);\n+\n@@ -3120,1 +3116,1 @@\n-  assert(main_limit == cl->limit() || get_ctrl(main_limit) == pre_ctrl, \"wrong control for added limit\");\n+  assert(main_limit == cl->limit() || get_ctrl(main_limit) == new_limit_ctrl, \"wrong control for added limit\");\n@@ -3128,1 +3124,1 @@\n-  register_new_node(main_limit, pre_ctrl);\n+  register_new_node(main_limit, new_limit_ctrl);\n@@ -3139,0 +3135,31 @@\n+  \/\/ new main_limit can push Bool\/Cmp nodes down (when one of the eliminated condition has parameters that are not loop\n+  \/\/ invariant in the pre loop.\n+  set_ctrl(opqzm, new_limit_ctrl);\n+  set_ctrl(iffm->in(1)->in(1), new_limit_ctrl);\n+  set_ctrl(iffm->in(1), new_limit_ctrl);\n+}\n+\n+\/\/ Adjust control for node and its inputs (and inputs of its inputs) to be above the pre end\n+Node* PhaseIdealLoop::ensure_node_and_inputs_are_above_pre_end(CountedLoopEndNode* pre_end, Node* node) {\n+  Node* control = get_ctrl(node);\n+  assert(is_dominator(compute_early_ctrl(node, control), pre_end), \"node pinned on loop exit test?\");\n+\n+  if (is_dominator(control, pre_end)) {\n+    return control;\n+  }\n+  control = pre_end->in(0);\n+  ResourceMark rm;\n+  Unique_Node_List wq;\n+  wq.push(node);\n+  for (uint i = 0; i < wq.size(); i++) {\n+    Node* n = wq.at(i);\n+    assert(is_dominator(compute_early_ctrl(n, get_ctrl(n)), pre_end), \"node pinned on loop exit test?\");\n+    set_ctrl(n, control);\n+    for (uint j = 0; j < n->req(); j++) {\n+      Node* in = n->in(j);\n+      if (in != nullptr && has_ctrl(in) && !is_dominator(get_ctrl(in), pre_end)) {\n+        wq.push(in);\n+      }\n+    }\n+  }\n+  return control;\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":80,"deletions":53,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -4514,17 +4514,0 @@\n-#ifdef ASSERT\n-\/\/ Goes over all children of the root of the loop tree. Check if any of them have a path\n-\/\/ down to Root, that does not go via a NeverBranch exit.\n-bool PhaseIdealLoop::only_has_infinite_loops() {\n-  ResourceMark rm;\n-  Unique_Node_List worklist;\n-  \/\/ start traversal at all loop heads of first-level loops\n-  for (IdealLoopTree* l = _ltree_root->_child; l != nullptr; l = l->_next) {\n-    Node* head = l->_head;\n-    assert(head->is_Region(), \"\");\n-    worklist.push(head);\n-  }\n-  return RegionNode::are_all_nodes_in_infinite_subgraph(worklist);\n-}\n-#endif\n-\n-\n@@ -4589,5 +4572,1 @@\n-  \/\/ Verify that the has_loops() flag set at parse time is consistent\n-  \/\/ with the just built loop tree. With infinite loops, it could be\n-  \/\/ that one pass of loop opts only finds infinite loops, clears the\n-  \/\/ has_loops() flag but adds NeverBranch nodes so the next loop opts\n-  \/\/ verification pass finds a non empty loop tree. When the back edge\n+  \/\/ Verify that the has_loops() flag set at parse time is consistent with the just built loop tree. When the back edge\n@@ -4595,1 +4574,1 @@\n-  assert(_ltree_root->_child == nullptr || C->has_loops() || only_has_infinite_loops() || C->has_exception_backedge(), \"parsing found no loops but there are some\");\n+  assert(_ltree_root->_child == nullptr || C->has_loops() || C->has_exception_backedge(), \"parsing found no loops but there are some\");\n@@ -5428,1 +5407,1 @@\n-        pre_order = build_loop_tree_impl( n, pre_order );\n+        pre_order = build_loop_tree_impl(n, pre_order);\n@@ -5446,1 +5425,1 @@\n-int PhaseIdealLoop::build_loop_tree_impl( Node *n, int pre_order ) {\n+int PhaseIdealLoop::build_loop_tree_impl(Node* n, int pre_order) {\n@@ -5457,2 +5436,2 @@\n-    if( n == m ) continue;      \/\/ Ignore control self-cycles\n-    if( !m->is_CFG() ) continue;\/\/ Ignore non-CFG edges\n+    if (n == m) continue;      \/\/ Ignore control self-cycles\n+    if (!m->is_CFG()) continue;\/\/ Ignore non-CFG edges\n@@ -5461,1 +5440,1 @@\n-    if( !is_postvisited(m) ) {  \/\/ Child visited but not post-visited?\n+    if (!is_postvisited(m)) {  \/\/ Child visited but not post-visited?\n@@ -5463,1 +5442,1 @@\n-      assert( get_preorder(m) < pre_order, \"should be backedge\" );\n+      assert(get_preorder(m) < pre_order, \"should be backedge\");\n@@ -5466,1 +5445,1 @@\n-      if( m == C->root()) {     \/\/ Found the root?\n+      if (m == C->root()) {     \/\/ Found the root?\n@@ -5472,1 +5451,1 @@\n-      if( !has_loop(m) )        \/\/ If 'm' does not already have a loop set\n+      if (!has_loop(m)) {        \/\/ If 'm' does not already have a loop set\n@@ -5474,1 +5453,1 @@\n-\n+      }\n@@ -5483,1 +5462,1 @@\n-      while( l && l->_head == m ) \/\/ Successor heads loop?\n+      while (l && l->_head == m) { \/\/ Successor heads loop?\n@@ -5485,0 +5464,1 @@\n+      }\n@@ -5487,1 +5467,1 @@\n-      if( !l ) {\n+      if (!l) {\n@@ -5493,7 +5473,0 @@\n-        \/\/ Here I set the loop to be the root loop.  I could have, after\n-        \/\/ inserting a bogus loop exit, restarted the recursion and found my\n-        \/\/ new loop exit.  This would make the infinite loop a first-class\n-        \/\/ loop and it would then get properly optimized.  What's the use of\n-        \/\/ optimizing an infinite loop?\n-        l = _ltree_root;        \/\/ Oops, found infinite loop\n-\n@@ -5523,1 +5496,1 @@\n-          set_loop(if_f, l);\n+          set_loop(if_f, _ltree_root);\n@@ -5532,1 +5505,1 @@\n-          set_loop(halt, l);\n+          set_loop(halt, _ltree_root);\n@@ -5536,0 +5509,17 @@\n+        \/\/ move to outer most loop with same header\n+        l = m_loop;\n+        while (true) {\n+          IdealLoopTree* next = l->_parent;\n+          if (next == nullptr || next->_head != m) {\n+            break;\n+          }\n+          l = next;\n+        }\n+        \/\/ properly insert infinite loop in loop tree\n+        sort(_ltree_root, l);\n+        \/\/ fix child link from parent\n+        IdealLoopTree* p = l->_parent;\n+        l->_next = p->_child;\n+        p->_child = l;\n+        \/\/ code below needs enclosing loop\n+        l = l->_parent;\n@@ -5589,1 +5579,1 @@\n-    while( p && l->_head == n ) {\n+    while (p && l->_head == n) {\n@@ -5603,1 +5593,1 @@\n-    if( innermost ) {\n+    if (innermost) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -941,2 +941,0 @@\n-  Node* cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop);\n-\n@@ -963,1 +961,1 @@\n-  void copy_assertion_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head, Node* init,\n+  void copy_assertion_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head,\n@@ -971,4 +969,0 @@\n-#ifdef ASSERT\n-  bool only_has_infinite_loops();\n-#endif\n-\n@@ -1081,1 +1075,1 @@\n-  int build_loop_tree_impl( Node *n, int pre_order );\n+  int build_loop_tree_impl(Node* n, int pre_order);\n@@ -1189,0 +1183,10 @@\n+  Node* dominated_node(Node* c1, Node* c2) {\n+    assert(is_dominator(c1, c2) || is_dominator(c2, c1), \"nodes must be related\");\n+    return is_dominator(c1, c2) ? c2 : c1;\n+  }\n+\n+  \/\/ Return control node that's dominated by the 2 others\n+  Node* dominated_node(Node* c1, Node* c2, Node* c3) {\n+    return dominated_node(c1, dominated_node(c2, c3));\n+  }\n+\n@@ -1537,0 +1541,2 @@\n+  bool split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk);\n+\n@@ -1581,1 +1587,1 @@\n-  static bool is_divisor_counted_loop_phi(const Node* divisor, const Node* loop);\n+  static bool is_divisor_loop_phi(const Node* divisor, const Node* loop);\n@@ -1787,0 +1793,2 @@\n+\n+  Node* ensure_node_and_inputs_are_above_pre_end(CountedLoopEndNode* pre_end, Node* node);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-  return is_divisor_counted_loop_phi(divisor, region) &&\n+  return is_divisor_loop_phi(divisor, region) &&\n@@ -302,2 +302,2 @@\n-bool PhaseIdealLoop::is_divisor_counted_loop_phi(const Node* divisor, const Node* loop) {\n-  return loop->is_BaseCountedLoop() && divisor->is_Phi() && divisor->in(0) == loop;\n+bool PhaseIdealLoop::is_divisor_loop_phi(const Node* divisor, const Node* loop) {\n+  return loop->is_Loop() && divisor->is_Phi() && divisor->in(0) == loop;\n@@ -1072,1 +1072,1 @@\n-            assert(get_loop(lca)->_nest < n_loop->_nest || lca->in(0)->is_NeverBranch(), \"must not be moved into inner loop\");\n+            assert(get_loop(lca)->_nest < n_loop->_nest || get_loop(lca)->_head->as_Loop()->is_in_infinite_subgraph(), \"must not be moved into inner loop\");\n@@ -1092,0 +1092,19 @@\n+\/\/ Split some nodes that take a counted loop phi as input at a counted\n+\/\/ loop can cause vectorization of some expressions to fail\n+bool PhaseIdealLoop::split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk) {\n+  if (!n_blk->is_CountedLoop()) {\n+    return false;\n+  }\n+\n+  int opcode = n->Opcode();\n+\n+  if (opcode != Op_AndI &&\n+      opcode != Op_MulI &&\n+      opcode != Op_RotateRight &&\n+      opcode != Op_RShiftI) {\n+    return false;\n+  }\n+\n+  return n->in(1) == n_blk->as_BaseCountedLoop()->phi();\n+}\n+\n@@ -1178,0 +1197,4 @@\n+  if (split_thru_phi_could_prevent_vectorization(n, n_blk)) {\n+    return n;\n+  }\n+\n@@ -1275,3 +1298,1 @@\n-    if (loop->is_member(get_loop(dom)) ||\n-        \/\/ NeverBranch nodes are not assigned to the loop when constructed\n-        (dom->is_NeverBranch() && loop->is_member(get_loop(dom->in(0))))) {\n+    if (loop->is_member(get_loop(dom))) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -430,3 +431,9 @@\n-bool MemNode::all_controls_dominate(Node* dom, Node* sub) {\n-  if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top())\n-    return false; \/\/ Conservative answer for dead code\n+\/\/ Returns 'DomResult::Dominate' if all control inputs of 'dom'\n+\/\/ dominate 'sub', 'DomResult::NotDominate' if not,\n+\/\/ and 'DomResult::EncounteredDeadCode' if we can't decide due to\n+\/\/ dead code, but at the end of IGVN, we know the definite result\n+\/\/ once the dead code is cleaned up.\n+Node::DomResult MemNode::maybe_all_controls_dominate(Node* dom, Node* sub) {\n+  if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top()) {\n+    return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+  }\n@@ -436,2 +443,3 @@\n-  if (dom == nullptr || dom->is_top())\n-    return false; \/\/ Conservative answer for dead code\n+  if (dom == nullptr || dom->is_top()) {\n+    return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+  }\n@@ -442,1 +450,1 @@\n-    return false;\n+    return DomResult::NotDominate;\n@@ -445,2 +453,3 @@\n-  if (dom->is_Con() || dom->is_Start() || dom->is_Root() || dom == sub)\n-    return true;\n+  if (dom->is_Con() || dom->is_Start() || dom->is_Root() || dom == sub) {\n+    return DomResult::Dominate;\n+  }\n@@ -460,2 +469,3 @@\n-  if (sub == nullptr || sub->is_top())\n-    return false; \/\/ Conservative answer for dead code\n+  if (sub == nullptr || sub->is_top()) {\n+    return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+  }\n@@ -465,2 +475,3 @@\n-  if (sub == dom)\n-    return true;\n+  if (sub == dom) {\n+    return DomResult::Dominate;\n+  }\n@@ -468,2 +479,3 @@\n-  if (sub->is_Start() || sub->is_Root())\n-    return false;\n+  if (sub->is_Start() || sub->is_Root()) {\n+    return DomResult::NotDominate;\n+  }\n@@ -483,2 +495,3 @@\n-      if (n == orig_sub)\n-        return false; \/\/ One of dom's inputs dominated by sub.\n+      if (n == orig_sub) {\n+        return DomResult::NotDominate; \/\/ One of dom's inputs dominated by sub.\n+      }\n@@ -488,2 +501,3 @@\n-        if (n == nullptr || n->is_top())\n-          return false; \/\/ Conservative answer for dead code\n+        if (n == nullptr || n->is_top()) {\n+          return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+        }\n@@ -495,1 +509,2 @@\n-        if (n->dominates(sub, nlist))\n+        DomResult dom_result = n->dominates(sub, nlist);\n+        if (dom_result == DomResult::Dominate) {\n@@ -497,2 +512,3 @@\n-        else\n-          return false;\n+        } else {\n+          return dom_result;\n+        }\n@@ -503,2 +519,3 @@\n-          if (m->is_top())\n-            return false; \/\/ Conservative answer for dead code\n+          if (m->is_top()) {\n+            return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+          }\n@@ -511,1 +528,1 @@\n-          if (m == nullptr || m->is_top())\n+          if (m == nullptr || m->is_top()) {\n@@ -513,0 +530,1 @@\n+          }\n@@ -517,1 +535,1 @@\n-    return only_dominating_controls;\n+    return only_dominating_controls ? DomResult::Dominate : DomResult::NotDominate;\n@@ -729,1 +747,1 @@\n-      if (st_alloc == nullptr)\n+      if (st_alloc == nullptr) {\n@@ -731,0 +749,1 @@\n+      }\n@@ -733,1 +752,1 @@\n-      if (alloc == st_alloc)\n+      if (alloc == st_alloc) {\n@@ -735,1 +754,1 @@\n-      else if (alloc != nullptr)\n+      } else if (alloc != nullptr) {\n@@ -737,1 +756,1 @@\n-      else if (all_controls_dominate(this, st_alloc))\n+      } else if (all_controls_dominate(this, st_alloc)) {\n@@ -739,0 +758,1 @@\n+      }\n@@ -1569,1 +1589,1 @@\n-    if (!MemNode::all_controls_dominate(mem, base->in(0)))\n+    if (!MemNode::all_controls_dominate(mem, base->in(0))) {\n@@ -1571,0 +1591,1 @@\n+    }\n@@ -1661,0 +1682,1 @@\n+  DomResult dom_result = DomResult::Dominate;\n@@ -1665,2 +1687,2 @@\n-    if (!MemNode::all_controls_dominate(address, region))\n-      return nullptr;\n+    \/\/ We will check `dom_result` later.\n+    dom_result = MemNode::maybe_all_controls_dominate(address, region);\n@@ -1671,2 +1693,2 @@\n-    if (!MemNode::all_controls_dominate(mem, region))\n-      return nullptr;\n+    \/\/ We will check `dom_result` later.\n+    dom_result = MemNode::maybe_all_controls_dominate(mem, region);\n@@ -1675,1 +1697,2 @@\n-    if (MemNode::all_controls_dominate(mem, base->in(0))) {\n+    dom_result = MemNode::maybe_all_controls_dominate(mem, base->in(0));\n+    if (dom_result == DomResult::Dominate) {\n@@ -1677,2 +1700,0 @@\n-    } else if (MemNode::all_controls_dominate(address, mem->in(0))) {\n-      region = mem->in(0);\n@@ -1680,1 +1701,5 @@\n-      return nullptr; \/\/ complex graph\n+      dom_result = MemNode::maybe_all_controls_dominate(address, mem->in(0));\n+      if (dom_result == DomResult::Dominate) {\n+        region = mem->in(0);\n+      }\n+      \/\/ Otherwise we encountered a complex graph.\n@@ -1687,0 +1712,11 @@\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+  if (dom_result != DomResult::Dominate) {\n+    if (dom_result == DomResult::EncounteredDeadCode) {\n+      \/\/ There is some dead code which eventually will be removed in IGVN.\n+      \/\/ Once this is the case, we get an unambiguous dominance result.\n+      \/\/ Push the node to the worklist again until the dead code is removed.\n+      igvn->_worklist.push(this);\n+    }\n+    return nullptr;\n+  }\n+\n@@ -1689,1 +1725,0 @@\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n@@ -1949,0 +1984,6 @@\n+  if (tkls->offset() == in_bytes(Klass::misc_flags_offset())) {\n+    \/\/ The field is Klass::_misc_flags.  Return its (constant) value.\n+    \/\/ (Folds up the 2nd indirection in Reflection.getClassAccessFlags(aClassConstant).)\n+    assert(this->Opcode() == Op_LoadUB, \"must load an unsigned byte from _misc_flags\");\n+    return TypeInt::make(klass->misc_flags());\n+  }\n@@ -4574,1 +4615,1 @@\n-      if (!MemNode::all_controls_dominate(n, this))\n+      if (!MemNode::all_controls_dominate(n, this)) {\n@@ -4576,0 +4617,1 @@\n+      }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":82,"deletions":40,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -108,2 +109,6 @@\n-  \/\/ This one should probably be a phase-specific function:\n-  static bool all_controls_dominate(Node* dom, Node* sub);\n+  \/\/ The following two should probably be phase-specific functions:\n+  static DomResult maybe_all_controls_dominate(Node* dom, Node* sub);\n+  static bool all_controls_dominate(Node* dom, Node* sub) {\n+    DomResult dom_result = maybe_all_controls_dominate(dom, sub);\n+    return dom_result == DomResult::Dominate;\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -597,0 +597,63 @@\n+template<typename IntegerType>\n+static const IntegerType* and_value(const IntegerType* r0, const IntegerType* r1) {\n+  typedef typename IntegerType::NativeType NativeType;\n+  static_assert(std::is_signed<NativeType>::value, \"Native type of IntegerType must be signed!\");\n+\n+  int widen = MAX2(r0->_widen, r1->_widen);\n+\n+  \/\/ If both types are constants, we can calculate a constant result.\n+  if (r0->is_con() && r1->is_con()) {\n+    return IntegerType::make(r0->get_con() & r1->get_con());\n+  }\n+\n+  \/\/ If both ranges are positive, the result will range from 0 up to the hi value of the smaller range. The minimum\n+  \/\/ of the two constrains the upper bound because any higher value in the other range will see all zeroes, so it will be masked out.\n+  if (r0->_lo >= 0 && r1->_lo >= 0) {\n+    return IntegerType::make(0, MIN2(r0->_hi, r1->_hi), widen);\n+  }\n+\n+  \/\/ If only one range is positive, the result will range from 0 up to that range's maximum value.\n+  \/\/ For the operation 'x & C' where C is a positive constant, the result will be in the range [0..C]. With that observation,\n+  \/\/ we can say that for any integer c such that 0 <= c <= C will also be in the range [0..C]. Therefore, 'x & [c..C]'\n+  \/\/ where c >= 0 will be in the range [0..C].\n+  if (r0->_lo >= 0) {\n+    return IntegerType::make(0, r0->_hi, widen);\n+  }\n+\n+  if (r1->_lo >= 0) {\n+    return IntegerType::make(0, r1->_hi, widen);\n+  }\n+\n+  \/\/ At this point, all positive ranges will have already been handled, so the only remaining cases will be negative ranges\n+  \/\/ and constants.\n+\n+  assert(r0->_lo < 0 && r1->_lo < 0, \"positive ranges should already be handled!\");\n+\n+  \/\/ As two's complement means that both numbers will start with leading 1s, the lower bound of both ranges will contain\n+  \/\/ the common leading 1s of both minimum values. In order to count them with count_leading_zeros, the bits are inverted.\n+  NativeType sel_val = ~MIN2(r0->_lo, r1->_lo);\n+\n+  NativeType min;\n+  if (sel_val == 0) {\n+    \/\/ Since count_leading_zeros is undefined at 0, we short-circuit the condition where both ranges have a minimum of -1.\n+    min = -1;\n+  } else {\n+    \/\/ To get the number of bits to shift, we count the leading 0-bits and then subtract one, as the sign bit is already set.\n+    int shift_bits = count_leading_zeros(sel_val) - 1;\n+    min = std::numeric_limits<NativeType>::min() >> shift_bits;\n+  }\n+\n+  NativeType max;\n+  if (r0->_hi < 0 && r1->_hi < 0) {\n+    \/\/ If both ranges are negative, then the same optimization as both positive ranges will apply, and the smaller hi\n+    \/\/ value will mask off any bits set by higher values.\n+    max = MIN2(r0->_hi, r1->_hi);\n+  } else {\n+    \/\/ In the case of ranges that cross zero, negative values can cause the higher order bits to be set, so the maximum\n+    \/\/ positive value can be as high as the larger hi value.\n+    max = MAX2(r0->_hi, r1->_hi);\n+  }\n+\n+  return IntegerType::make(min, max, widen);\n+}\n+\n@@ -604,14 +667,2 @@\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-  int widen = MAX2(r0->_widen,r1->_widen);\n-\n-  \/\/ If either input is a constant, might be able to trim cases\n-  if( !r0->is_con() && !r1->is_con() )\n-    return TypeInt::INT;        \/\/ No constants to be had\n-\n-  \/\/ Both constants?  Return bits\n-  if( r0->is_con() && r1->is_con() )\n-    return TypeInt::make( r0->get_con() & r1->get_con() );\n-\n-  if( r0->is_con() && r0->get_con() > 0 )\n-    return TypeInt::make(0, r0->get_con(), widen);\n+  const TypeInt* r0 = t0->is_int();\n+  const TypeInt* r1 = t1->is_int();\n@@ -619,8 +670,1 @@\n-  if( r1->is_con() && r1->get_con() > 0 )\n-    return TypeInt::make(0, r1->get_con(), widen);\n-\n-  if( r0 == TypeInt::BOOL || r1 == TypeInt::BOOL ) {\n-    return TypeInt::BOOL;\n-  }\n-\n-  return TypeInt::INT;          \/\/ No constants to be had\n+  return and_value<TypeInt>(r0, r1);\n@@ -754,17 +798,2 @@\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-  int widen = MAX2(r0->_widen,r1->_widen);\n-\n-  \/\/ If either input is a constant, might be able to trim cases\n-  if( !r0->is_con() && !r1->is_con() )\n-    return TypeLong::LONG;      \/\/ No constants to be had\n-\n-  \/\/ Both constants?  Return bits\n-  if( r0->is_con() && r1->is_con() )\n-    return TypeLong::make( r0->get_con() & r1->get_con() );\n-\n-  if( r0->is_con() && r0->get_con() > 0 )\n-    return TypeLong::make(CONST64(0), r0->get_con(), widen);\n-\n-  if( r1->is_con() && r1->get_con() > 0 )\n-    return TypeLong::make(CONST64(0), r1->get_con(), widen);\n+  const TypeLong* r0 = t0->is_long();\n+  const TypeLong* r1 = t1->is_long();\n@@ -772,1 +801,1 @@\n-  return TypeLong::LONG;        \/\/ No constants to be had\n+  return and_value<TypeLong>(r0, r1);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":69,"deletions":40,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -1252,1 +1253,1 @@\n-bool Node::dominates(Node* sub, Node_List &nlist) {\n+Node::DomResult Node::dominates(Node* sub, Node_List &nlist) {\n@@ -1272,1 +1273,4 @@\n-    if (sub->is_top())  break; \/\/ Conservative answer for dead code.\n+    if (sub->is_top()) {\n+      \/\/ Conservative answer for dead code.\n+      return DomResult::EncounteredDeadCode;\n+    }\n@@ -1277,1 +1281,1 @@\n-        return true;\n+        return DomResult::Dominate;\n@@ -1291,1 +1295,1 @@\n-      return met_dom;\n+      return met_dom ? DomResult::Dominate : DomResult::NotDominate;\n@@ -1322,1 +1326,1 @@\n-            return false;\n+            return DomResult::NotDominate;\n@@ -1365,2 +1369,1 @@\n-  \/\/ Conservative answer for dead code.\n-  return false;\n+  return DomResult::NotDominate;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -1110,0 +1111,6 @@\n+  \/\/ Results of the dominance analysis.\n+  enum class DomResult {\n+    NotDominate,         \/\/ 'this' node does not dominate 'sub'.\n+    Dominate,            \/\/ 'this' node dominates or is equal to 'sub'.\n+    EncounteredDeadCode  \/\/ Result is undefined due to encountering dead code.\n+  };\n@@ -1111,1 +1118,1 @@\n-  bool dominates(Node* sub, Node_List &nlist);\n+  DomResult dominates(Node* sub, Node_List &nlist);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-  Node*         _alloc_with_final;   \/\/ An allocation node with final field\n+  Node*         _alloc_with_final_or_stable; \/\/ An allocation node with final or @Stable field\n@@ -406,4 +406,4 @@\n-  Node*    alloc_with_final() const   { return _alloc_with_final; }\n-  void set_alloc_with_final(Node* n)  {\n-    assert((_alloc_with_final == nullptr) || (_alloc_with_final == n), \"different init objects?\");\n-    _alloc_with_final = n;\n+  Node*    alloc_with_final_or_stable() const   { return _alloc_with_final_or_stable; }\n+  void set_alloc_with_final_or_stable(Node* n)  {\n+    assert((_alloc_with_final_or_stable == nullptr) || (_alloc_with_final_or_stable == n), \"different init objects?\");\n+    _alloc_with_final_or_stable = n;\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -415,1 +415,1 @@\n-  _alloc_with_final = nullptr;\n+  _alloc_with_final_or_stable = nullptr;\n@@ -991,2 +991,2 @@\n-  \/\/ 1. The constructor wrote a final. The effects of all initializations\n-  \/\/    must be committed to memory before any code after the constructor\n+  \/\/ 1. The constructor wrote a final or a @Stable field. All these\n+  \/\/    initializations must be ordered before any code after the constructor\n@@ -1017,1 +1017,1 @@\n-       (wrote_final() ||\n+       (wrote_final() || wrote_stable() ||\n@@ -1020,0 +1020,1 @@\n+    Node* recorded_alloc = alloc_with_final_or_stable();\n@@ -1021,1 +1022,1 @@\n-                          alloc_with_final());\n+                          recorded_alloc);\n@@ -1026,2 +1027,2 @@\n-    if (DoEscapeAnalysis && alloc_with_final()) {\n-      AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_with_final());\n+    if (DoEscapeAnalysis && (recorded_alloc != nullptr)) {\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(recorded_alloc);\n@@ -1032,13 +1033,1 @@\n-      tty->print_cr(\" writes finals and needs a memory barrier\");\n-    }\n-  }\n-\n-  \/\/ Any method can write a @Stable field; insert memory barriers\n-  \/\/ after those also. Can't bind predecessor allocation node (if any)\n-  \/\/ with barrier because allocation doesn't always dominate\n-  \/\/ MemBarRelease.\n-  if (wrote_stable()) {\n-    _exits.insert_mem_bar(Op_MemBarRelease);\n-    if (PrintOpto && (Verbose || WizardMode)) {\n-      method()->print_name();\n-      tty->print_cr(\" writes @Stable and needs a memory barrier\");\n+      tty->print_cr(\" writes finals\/@Stable and needs a memory barrier\");\n@@ -1665,1 +1654,1 @@\n-  if (target_bci < bci()) {\n+  if (target_bci <= bci()) {\n@@ -2137,2 +2126,2 @@\n-  Node* access_flags_addr = basic_plus_adr(klass, klass, in_bytes(Klass::access_flags_offset()));\n-  Node* access_flags = make_load(nullptr, access_flags_addr, TypeInt::INT, T_INT, MemNode::unordered);\n+  Node* access_flags_addr = basic_plus_adr(klass, klass, in_bytes(Klass::misc_flags_offset()));\n+  Node* access_flags = make_load(nullptr, access_flags_addr, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);\n@@ -2140,1 +2129,1 @@\n-  Node* mask  = _gvn.transform(new AndINode(access_flags, intcon(JVM_ACC_HAS_FINALIZER)));\n+  Node* mask  = _gvn.transform(new AndINode(access_flags, intcon(KlassFlags::_misc_has_finalizer)));\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":13,"deletions":24,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -239,1 +239,4 @@\n-    \/\/ Note the presence of writes to final non-static fields, so that we\n+    \/\/ If the field is @Stable, we can be in any method, but we only care about\n+    \/\/ constructors at this point.\n+    \/\/\n+    \/\/ Note the presence of writes to final\/@Stable non-static fields, so that we\n@@ -242,3 +245,7 @@\n-    \/\/ Any method can write a @Stable field; insert memory barriers after those also.\n-    if (field->is_final()) {\n-      set_wrote_final(true);\n+    if (field->is_final() || field->is_stable()) {\n+      if (field->is_final()) {\n+        set_wrote_final(true);\n+      }\n+      if (field->is_stable()) {\n+        set_wrote_stable(true);\n+      }\n@@ -248,2 +255,1 @@\n-        \/\/ Can't bind stable with its allocation, only record allocation for final field.\n-        set_alloc_with_final(obj);\n+        set_alloc_with_final_or_stable(obj);\n@@ -252,3 +258,0 @@\n-    if (field->is_stable()) {\n-      set_wrote_stable(true);\n-    }\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1626,17 +1626,0 @@\n-  \/\/ Change ((x & m) u<= m) or ((m & x) u<= m) to always true\n-  \/\/ Same with ((x & m) u< m+1) and ((m & x) u< m+1)\n-  if (cop == Op_CmpU &&\n-      cmp1_op == Op_AndI) {\n-    Node* bound = nullptr;\n-    if (_test._test == BoolTest::le) {\n-      bound = cmp2;\n-    } else if (_test._test == BoolTest::lt &&\n-               cmp2->Opcode() == Op_AddI &&\n-               cmp2->in(2)->find_int_con(0) == 1) {\n-      bound = cmp2->in(1);\n-    }\n-    if (cmp1->in(2) == bound || cmp1->in(1) == bound) {\n-      return ConINode::make(1);\n-    }\n-  }\n-\n@@ -1644,1 +1627,1 @@\n-  \/\/ This is the off-by-one variant of the above\n+  \/\/ This is the off-by-one variant of ((x & m) u<= m)\n@@ -1830,0 +1813,25 @@\n+\/\/ Change ((x & m) u<= m) or ((m & x) u<= m) to always true\n+\/\/ Same with ((x & m) u< m+1) and ((m & x) u< m+1)\n+const Type* BoolNode::Value_cmpu_and_mask(PhaseValues* phase) const {\n+  Node* cmp = in(1);\n+  if (cmp != nullptr && cmp->Opcode() == Op_CmpU) {\n+    Node* cmp1 = cmp->in(1);\n+    Node* cmp2 = cmp->in(2);\n+\n+    if (cmp1->Opcode() == Op_AndI) {\n+      Node* bound = nullptr;\n+      if (_test._test == BoolTest::le) {\n+        bound = cmp2;\n+      } else if (_test._test == BoolTest::lt && cmp2->Opcode() == Op_AddI && cmp2->in(2)->find_int_con(0) == 1) {\n+        bound = cmp2->in(1);\n+      }\n+\n+      if (cmp1->in(2) == bound || cmp1->in(1) == bound) {\n+        return TypeInt::ONE;\n+      }\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n@@ -1833,0 +1841,5 @@\n+  const Type* t = Value_cmpu_and_mask(phase);\n+  if (t != nullptr) {\n+    return t;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":32,"deletions":19,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -350,0 +350,1 @@\n+  const Type* Value_cmpu_and_mask(PhaseValues* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-static jint CurrentVersion = JNI_VERSION_21;\n+static jint CurrentVersion = JNI_VERSION_24;\n@@ -1159,1 +1159,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1212,1 +1212,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1263,1 +1263,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1356,1 +1356,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1409,1 +1409,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1461,1 +1461,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1557,1 +1557,1 @@\n-  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \\\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1612,2 +1612,2 @@\n-  k->initialize(CHECK_0); \\\n-  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \\\n+  k->initialize(CHECK_(ResultType{})); \\\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1666,1 +1666,1 @@\n-  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \\\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -2224,1 +2224,1 @@\n- HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);\n+  HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);\n@@ -2226,1 +2226,1 @@\n-  jsize ret = java_lang_String::utf8_length(java_string);\n+  jsize ret = java_lang_String::utf8_length_as_int(java_string);\n@@ -2231,0 +2231,8 @@\n+JNI_ENTRY(jlong, jni_GetStringUTFLengthAsLong(JNIEnv *env, jstring string))\n+  HOTSPOT_JNI_GETSTRINGUTFLENGTHASLONG_ENTRY(env, string);\n+  oop java_string = JNIHandles::resolve_non_null(string);\n+  size_t ret = java_lang_String::utf8_length(java_string);\n+  HOTSPOT_JNI_GETSTRINGUTFLENGTHASLONG_RETURN(ret);\n+return checked_cast<jlong>(ret);\n+JNI_END\n+\n@@ -2239,1 +2247,2 @@\n-    \/* JNI Specification states return null on OOM *\/\n+    \/\/ JNI Specification states return null on OOM.\n+    \/\/ The resulting sequence doesn't have to be NUL-terminated but we do.\n@@ -2242,1 +2251,1 @@\n-      java_lang_String::as_utf8_string(java_string, s_value, result, (int) length + 1);\n+      java_lang_String::as_utf8_string(java_string, s_value, result, length + 1);\n@@ -3400,1 +3409,5 @@\n-    jni_IsVirtualThread\n+    jni_IsVirtualThread,\n+\n+    \/\/ Large UTF8 support\n+\n+    jni_GetStringUTFLengthAsLong\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":29,"deletions":16,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-  if (!UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false)) {\n+  if (!UTF8::is_legal_utf8((const unsigned char*)name, strlen(name), false)) {\n@@ -1514,0 +1514,21 @@\n+    jlong full_length =  UNCHECKED()->GetStringUTFLengthAsLong(env,str);\n+    if (full_length > result) {\n+      ResourceMark rm(thr);\n+      stringStream ss;\n+      ss.print(\"WARNING: large String with modified UTF-8 length \" JLONG_FORMAT\n+                \" is reporting a reduced length of %d - use GetStringUTFLengthAsLong instead\",\n+                full_length, result);\n+      NativeReportJNIWarning(thr, ss.as_string());\n+    }\n+    functionExit(thr);\n+    return result;\n+JNI_END\n+\n+JNI_ENTRY_CHECKED(jlong,\n+  checked_jni_GetStringUTFLengthAsLong(JNIEnv *env,\n+                                       jstring str))\n+    functionEnter(thr);\n+    IN_VM(\n+      checkString(thr, str);\n+    )\n+    jlong result = UNCHECKED()->GetStringUTFLengthAsLong(env,str);\n@@ -2286,1 +2307,6 @@\n-    checked_jni_IsVirtualThread\n+    checked_jni_IsVirtualThread,\n+\n+    \/\/ Large UTF8 support\n+\n+    checked_jni_GetStringUTFLengthAsLong\n+\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -812,1 +812,1 @@\n-  assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false), \"illegal UTF name\");\n+  assert(UTF8::is_legal_utf8((const unsigned char*)name, strlen(name), false), \"illegal UTF name\");\n@@ -3406,1 +3406,1 @@\n-      THROW_HANDLE_0(h_exception);\n+      THROW_HANDLE_NULL(h_exception);\n@@ -3451,0 +3451,4 @@\n+JVM_ENTRY_NO_ENV(jboolean, JVM_IsStaticallyLinked(void))\n+  return is_vm_statically_linked() ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1324,1 +1324,1 @@\n-      int utf8_length = 0;\n+      size_t utf8_length = 0;\n@@ -2537,0 +2537,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2549,0 +2550,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2561,0 +2563,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2573,0 +2576,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -1468,1 +1469,0 @@\n-  ObjectMonitor *mon = nullptr;\n@@ -1498,3 +1498,5 @@\n-  if (mark.has_monitor()) {\n-    mon = mark.monitor();\n-    assert(mon != nullptr, \"must have monitor\");\n+  ObjectMonitor* mon = mark.has_monitor()\n+      ? ObjectSynchronizer::read_monitor(current_thread, hobj(), mark)\n+      : nullptr;\n+\n+  if (mon != nullptr) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -985,2 +985,0 @@\n-  JvmtiVTMSTransitionDisabler disabler;\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -276,1 +276,9 @@\n-  Handle name_arg = java_lang_String::create_from_str(jni_name, CHECK_NULL);\n+  Handle jni_class(THREAD, method->method_holder()->java_mirror());\n+  Handle jni_name_arg = java_lang_String::create_from_str(jni_name, CHECK_NULL);\n+  Handle java_name_arg = java_lang_String::create_from_str(method->name()->as_C_string(), CHECK_NULL);\n+\n+  JavaCallArguments args;\n+  args.push_oop(loader);\n+  args.push_oop(jni_class);\n+  args.push_oop(jni_name_arg);\n+  args.push_oop(java_name_arg);\n@@ -282,4 +290,2 @@\n-                         vmSymbols::classloader_string_long_signature(),\n-                         \/\/ Arguments\n-                         loader,\n-                         name_arg,\n+                         vmSymbols::classloader_class_string_string_long_signature(),\n+                         &args,\n@@ -412,0 +418,8 @@\n+  if (THREAD->has_pending_exception()) {\n+    oop exception = THREAD->pending_exception();\n+    if (exception->is_a(vmClasses::IllegalCallerException_klass())) {\n+      \/\/ we already have a pending exception from the restricted method check, just return\n+      return nullptr;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2501,0 +2501,7 @@\n+\/\/ Available cpus of the host machine, Linux only.\n+\/\/ Used in container testing.\n+WB_ENTRY(jint, WB_HostCPUs(JNIEnv* env, jobject o))\n+  LINUX_ONLY(return os::Linux::active_processor_count();)\n+  return -1; \/\/ Not used\/implemented on other platforms\n+WB_END\n+\n@@ -2586,1 +2593,1 @@\n-      current_frame->print_value_on(&st, nullptr);\n+      current_frame->print_value_on(&st);\n@@ -2942,0 +2949,1 @@\n+  {CC\"hostCPUs\",                  CC\"()I\",            (void*)&WB_HostCPUs },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -308,0 +308,2 @@\n+#define ILLEGAL_NATIVE_ACCESS \"illegal.native.access\"\n+#define ILLEGAL_NATIVE_ACCESS_LEN 21\n@@ -329,0 +331,1 @@\n+        matches_property_suffix(property_suffix, ILLEGAL_NATIVE_ACCESS, ILLEGAL_NATIVE_ACCESS_LEN) ||\n@@ -506,0 +509,3 @@\n+#ifdef LINUX\n+  { \"UseLinuxPosixThreadCPUClocks\", JDK_Version::jdk(24), JDK_Version::jdk(25), JDK_Version::jdk(26) },\n+#endif\n@@ -1819,0 +1825,4 @@\n+  if (UseObjectMonitorTable) {\n+    FLAG_SET_CMDLINE(UseObjectMonitorTable, false);\n+    warning(\"UseObjectMonitorTable not supported on this platform\");\n+  }\n@@ -1821,0 +1831,6 @@\n+  if (UseObjectMonitorTable && LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ ObjectMonitorTable requires lightweight locking.\n+    FLAG_SET_CMDLINE(UseObjectMonitorTable, false);\n+    warning(\"UseObjectMonitorTable requires LM_LIGHTWEIGHT\");\n+  }\n+\n@@ -2236,0 +2252,4 @@\n+    } else if (match_option(option, \"--illegal-native-access=\", &tail)) {\n+      if (!create_module_property(\"jdk.module.illegal.native.access\", tail, InternalProperty)) {\n+        return JNI_ENOMEM;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-#include \"runtime\/basicLock.hpp\"\n+#include \"runtime\/basicLock.inline.hpp\"\n+#include \"runtime\/objectMonitor.hpp\"\n@@ -32,5 +33,12 @@\n-  markWord mark_word = displaced_header();\n-  if (mark_word.value() != 0) {\n-    \/\/ Print monitor info if there's an owning oop and it refers to this BasicLock.\n-    bool print_monitor_info = (owner != nullptr) && (owner->mark() == markWord::from_pointer((void*)this));\n-    mark_word.print_on(st, print_monitor_info);\n+  if (UseObjectMonitorTable) {\n+    ObjectMonitor* mon = object_monitor_cache();\n+    if (mon != nullptr) {\n+      mon->print_on(st);\n+    }\n+  } else if (LockingMode == LM_LEGACY) {\n+    markWord mark_word = displaced_header();\n+    if (mark_word.value() != 0) {\n+      \/\/ Print monitor info if there's an owning oop and it refers to this BasicLock.\n+      bool print_monitor_info = (owner != nullptr) && (owner->mark() == markWord::from_pointer((void*)this));\n+      mark_word.print_on(st, print_monitor_info);\n+    }\n@@ -85,0 +93,5 @@\n+  } else if (UseObjectMonitorTable) {\n+    \/\/ Preserve the ObjectMonitor*, the cache is cleared when a box is reused\n+    \/\/ and only read while the lock is held, so no stale ObjectMonitor* is\n+    \/\/ encountered.\n+    dest->set_object_monitor_cache(object_monitor_cache());\n@@ -88,1 +101,1 @@\n-    dest->set_displaced_header(markWord(badDispHeaderDeopt));\n+    dest->set_bad_metadata_deopt();\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -37,0 +38,3 @@\n+  \/\/ * For LM_MONITOR\n+  \/\/ Unused.\n+  \/\/ * For LM_LEGACY\n@@ -39,1 +43,9 @@\n-  volatile markWord _displaced_header;\n+  \/\/ * For LM_LIGHTWEIGHT\n+  \/\/ Used as a cache of the ObjectMonitor* used when locking. Must either\n+  \/\/ be nullptr or the ObjectMonitor* used when locking.\n+  volatile uintptr_t _metadata;\n+\n+  uintptr_t get_metadata() const { return Atomic::load(&_metadata); }\n+  void set_metadata(uintptr_t value) { Atomic::store(&_metadata, value); }\n+  static int metadata_offset_in_bytes() { return (int)offset_of(BasicLock, _metadata); }\n+\n@@ -41,3 +53,2 @@\n-  markWord displaced_header() const {\n-    return Atomic::load(&_displaced_header);\n-  }\n+  \/\/ LM_MONITOR\n+  void set_bad_metadata_deopt() { set_metadata(badDispHeaderDeopt); }\n@@ -45,3 +56,10 @@\n-  void set_displaced_header(markWord header) {\n-    Atomic::store(&_displaced_header, header);\n-  }\n+  \/\/ LM_LEGACY\n+  inline markWord displaced_header() const;\n+  inline void set_displaced_header(markWord header);\n+  static int displaced_header_offset_in_bytes() { return metadata_offset_in_bytes(); }\n+\n+  \/\/ LM_LIGHTWEIGHT\n+  inline ObjectMonitor* object_monitor_cache() const;\n+  inline void clear_object_monitor_cache();\n+  inline void set_object_monitor_cache(ObjectMonitor* mon);\n+  static int object_monitor_cache_offset_in_bytes() { return metadata_offset_in_bytes(); }\n@@ -53,2 +71,0 @@\n-\n-  static int displaced_header_offset_in_bytes() { return (int)offset_of(BasicLock, _displaced_header); }\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_BASICLOCK_INLINE_HPP\n+#define SHARE_RUNTIME_BASICLOCK_INLINE_HPP\n+\n+#include \"runtime\/basicLock.hpp\"\n+\n+inline markWord BasicLock::displaced_header() const {\n+  assert(LockingMode == LM_LEGACY, \"must be\");\n+  return markWord(get_metadata());\n+}\n+\n+inline void BasicLock::set_displaced_header(markWord header) {\n+  assert(LockingMode == LM_LEGACY, \"must be\");\n+  Atomic::store(&_metadata, header.value());\n+}\n+\n+inline ObjectMonitor* BasicLock::object_monitor_cache() const {\n+  assert(UseObjectMonitorTable, \"must be\");\n+#if defined(X86) || defined(AARCH64) || defined(RISCV64)\n+  return reinterpret_cast<ObjectMonitor*>(get_metadata());\n+#else\n+  \/\/ Other platforms do not make use of the cache yet,\n+  \/\/ and are not as careful with maintaining the invariant\n+  \/\/ that the metadata either is nullptr or ObjectMonitor*.\n+  return nullptr;\n+#endif\n+}\n+\n+inline void BasicLock::clear_object_monitor_cache() {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  set_metadata(0);\n+}\n+\n+inline void BasicLock::set_object_monitor_cache(ObjectMonitor* mon) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  set_metadata(reinterpret_cast<uintptr_t>(mon));\n+}\n+\n+#endif \/\/ SHARE_RUNTIME_BASICLOCK_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+  friend class JVMCIVMStructs;\n@@ -81,1 +82,1 @@\n-  uint _pin_count;\n+  uint32_t _pin_count;\n@@ -111,1 +112,1 @@\n-    if (_pin_count == UINT_MAX) return false;\n+    if (_pin_count == UINT32_MAX) return false;\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -280,0 +280,18 @@\n+#ifdef _WINDOWS\n+static void map_stack_pages(JavaThread* thread, size_t size, address sp) {\n+  address new_sp = sp - size;\n+  address watermark = thread->stack_overflow_state()->shadow_zone_growth_watermark();\n+\n+  if (new_sp < watermark) {\n+    size_t page_size = os::vm_page_size();\n+    address last_touched_page = watermark - StackOverflow::stack_shadow_zone_size();\n+    size_t pages_to_touch = align_up(watermark - new_sp, page_size) \/ page_size;\n+    while (pages_to_touch-- > 0) {\n+      last_touched_page -= page_size;\n+      *last_touched_page = 0;\n+    }\n+    thread->stack_overflow_state()->set_shadow_zone_growth_watermark(new_sp);\n+  }\n+}\n+#endif\n+\n@@ -286,0 +304,1 @@\n+    WINDOWS_ONLY(map_stack_pages(thread, size, sp));\n@@ -880,1 +899,1 @@\n-    f.print_value_on(&ls, nullptr);\n+    f.print_value_on(&ls);\n@@ -889,1 +908,1 @@\n-    DEBUG_ONLY(hf.print_value_on(&ls, nullptr);)\n+    DEBUG_ONLY(hf.print_value_on(&ls);)\n@@ -2030,1 +2049,1 @@\n-    heap_frame.print_value_on(&ls, nullptr);\n+    heap_frame.print_value_on(&ls);\n@@ -2127,1 +2146,1 @@\n-    hf.print_value_on(&ls, nullptr);\n+    hf.print_value_on(&ls);\n@@ -2397,1 +2416,1 @@\n-    _cont.last_frame().print_value_on(&ls, nullptr);\n+    _cont.last_frame().print_value_on(&ls);\n@@ -2409,1 +2428,1 @@\n-    f.print_value_on(&ls, nullptr);\n+    f.print_value_on(&ls);\n@@ -2470,1 +2489,1 @@\n-    frame(sp).print_value_on(&ls, nullptr);\n+    frame(sp).print_value_on(&ls);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -78,0 +79,2 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/lockStack.inline.hpp\"\n@@ -87,1 +90,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -1637,1 +1640,11 @@\n-              mon_info->lock()->set_displaced_header(markWord::unused_mark());\n+              if (LockingMode == LM_LEGACY) {\n+                mon_info->lock()->set_displaced_header(markWord::unused_mark());\n+              } else if (UseObjectMonitorTable) {\n+                mon_info->lock()->clear_object_monitor_cache();\n+              }\n+#ifdef ASSERT\n+              else {\n+                assert(LockingMode == LM_MONITOR || !UseObjectMonitorTable, \"must be\");\n+                mon_info->lock()->set_bad_metadata_deopt();\n+              }\n+#endif\n@@ -1643,0 +1656,1 @@\n+        BasicLock* lock = mon_info->lock();\n@@ -1645,3 +1659,7 @@\n-          \/\/ Inflate the locks instead. Enter then inflate to avoid races with\n-          \/\/ deflation.\n-          ObjectSynchronizer::enter_for(obj, nullptr, deoptee_thread);\n+          \/\/ Entering may create an invalid lock stack. Inflate the lock if it\n+          \/\/ was fast_locked to restore the valid lock stack.\n+          ObjectSynchronizer::enter_for(obj, lock, deoptee_thread);\n+          if (deoptee_thread->lock_stack().contains(obj())) {\n+            LightweightSynchronizer::inflate_fast_locked_object(obj(), ObjectSynchronizer::InflateCause::inflate_cause_vm_internal,\n+                                                                deoptee_thread, thread);\n+          }\n@@ -1649,2 +1667,3 @@\n-          ObjectMonitor* mon = ObjectSynchronizer::inflate_for(deoptee_thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n-          assert(mon->owner() == deoptee_thread, \"must be\");\n+          assert(obj->mark().has_monitor(), \"must be\");\n+          assert(!deoptee_thread->lock_stack().contains(obj()), \"must be\");\n+          assert(ObjectSynchronizer::read_monitor(thread, obj(), obj->mark())->owner() == deoptee_thread, \"must be\");\n@@ -1652,1 +1671,0 @@\n-          BasicLock* lock = mon_info->lock();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  CDS_FLAGS(                  \\\n+  JVMCI_ONLY(JVMCI_FLAGS(     \\\n@@ -66,1 +66,1 @@\n-    constraint)               \\\n+    constraint))              \\\n@@ -68,1 +68,1 @@\n-  JVMCI_ONLY(JVMCI_FLAGS(     \\\n+  COMPILER1_PRESENT(C1_FLAGS( \\\n@@ -76,1 +76,1 @@\n-  COMPILER1_PRESENT(C1_FLAGS( \\\n+  COMPILER2_PRESENT(C2_FLAGS( \\\n@@ -84,1 +84,1 @@\n-  COMPILER2_PRESENT(C2_FLAGS( \\\n+  COMPILER_FLAGS(             \\\n@@ -90,1 +90,1 @@\n-    constraint))              \\\n+    constraint)               \\\n@@ -92,1 +92,1 @@\n-  COMPILER_FLAGS(             \\\n+  CDS_FLAGS(                  \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/allFlags.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -514,1 +514,1 @@\n-void frame::print_value_on(outputStream* st, JavaThread *thread) const {\n+void frame::print_value_on(outputStream* st) const {\n@@ -553,1 +553,1 @@\n-  print_value_on(st,nullptr);\n+  print_value_on(st);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -436,2 +436,2 @@\n-  void print_value() const { print_value_on(tty,nullptr); }\n-  void print_value_on(outputStream* st, JavaThread *thread) const;\n+  void print_value() const { print_value_on(tty); }\n+  void print_value_on(outputStream* st) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1959,0 +1959,11 @@\n+  product(bool, UseObjectMonitorTable, false, DIAGNOSTIC,                   \\\n+          \"With Lightweight Locking mode, use a table to record inflated \"  \\\n+          \"monitors rather than the first word of the object.\")             \\\n+                                                                            \\\n+  product(int, LightweightFastLockingSpins, 13, DIAGNOSTIC,                 \\\n+          \"Specifies the number of times lightweight fast locking will \"    \\\n+          \"attempt to CAS the markWord before inflating. Between each \"     \\\n+          \"CAS it will spin for exponentially more time, resulting in \"     \\\n+          \"a total number of spins on the order of O(2^value)\")             \\\n+          range(1, 30)                                                      \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+  \/\/ stub routines in initial blob are referenced by later generated code\n@@ -130,0 +131,2 @@\n+  \/\/ stack overflow exception blob is referenced by the interpreter\n+  SharedRuntime::generate_initial_stubs();\n@@ -147,0 +150,3 @@\n+#if INCLUDE_JFR\n+  SharedRuntime::generate_jfr_stubs();\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,3 @@\n+\/\/ This is defined in linkType.cpp due to linking restraints\n+extern bool is_vm_statically_linked();\n+\n","filename":"src\/hotspot\/share\/runtime\/java.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,8 +360,0 @@\n-  \/\/ Since the call stub sets up like the interpreter we call the from_interpreted_entry\n-  \/\/ so we can go compiled via a i2c. Otherwise initial entry method will always\n-  \/\/ run interpreted.\n-  address entry_point = method->from_interpreted_entry();\n-  if (JvmtiExport::can_post_interpreter_events() && thread->is_interp_only_mode()) {\n-    entry_point = method->interpreter_entry();\n-  }\n-\n@@ -401,0 +393,12 @@\n+\n+      address entry_point;\n+      {\n+        \/\/ The enter_interp_only_mode use handshake to set interp_only mode\n+        \/\/ so no safepoint should be allowed between is_interp_only_mode() and call\n+        NoSafepointVerifier nsv;\n+        if (JvmtiExport::can_post_interpreter_events() && thread->is_interp_only_mode()) {\n+          entry_point = method->interpreter_entry();\n+        } else {\n+          \/\/ Since the call stub sets up like the interpreter we call the from_interpreted_entry\n+          \/\/ so we can go compiled via a i2c.\n+          entry_point = method->from_interpreted_entry();\n@@ -402,10 +406,13 @@\n-      \/\/ Gets the alternative target (if any) that should be called\n-      Handle alternative_target = args->alternative_target();\n-      if (!alternative_target.is_null()) {\n-        \/\/ Must extract verified entry point from HotSpotNmethod after VM to Java\n-        \/\/ transition in JavaCallWrapper constructor so that it is safe with\n-        \/\/ respect to nmethod sweeping.\n-        address verified_entry_point = (address) HotSpotJVMCI::InstalledCode::entryPoint(nullptr, alternative_target());\n-        if (verified_entry_point != nullptr) {\n-          thread->set_jvmci_alternate_call_target(verified_entry_point);\n-          entry_point = method->adapter()->get_i2c_entry();\n+          \/\/ Gets the alternative target (if any) that should be called\n+          Handle alternative_target = args->alternative_target();\n+          if (!alternative_target.is_null()) {\n+            \/\/ Must extract verified entry point from HotSpotNmethod after VM to Java\n+            \/\/ transition in JavaCallWrapper constructor so that it is safe with\n+            \/\/ respect to nmethod sweeping.\n+            address verified_entry_point = (address) HotSpotJVMCI::InstalledCode::entryPoint(nullptr, alternative_target());\n+            if (verified_entry_point != nullptr) {\n+              thread->set_jvmci_alternate_call_target(verified_entry_point);\n+              entry_point = method->adapter()->get_i2c_entry();\n+            }\n+          }\n+#endif\n@@ -414,1 +421,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -507,1 +507,2 @@\n-  _lock_stack(this) {\n+  _lock_stack(this),\n+  _om_cache(this) {\n@@ -806,0 +807,2 @@\n+  om_clear_monitor_cache();\n+\n@@ -1906,1 +1909,1 @@\n-    fst.current()->print_value_on(tty, this);\n+    fst.current()->print_value_on(tty);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+class ObjectMonitor;\n@@ -1168,0 +1169,1 @@\n+  OMCache _om_cache;\n@@ -1179,0 +1181,7 @@\n+  static ByteSize om_cache_offset()        { return byte_offset_of(JavaThread, _om_cache); }\n+  static ByteSize om_cache_oops_offset()   { return om_cache_offset() + OMCache::entries_offset(); }\n+\n+  void om_set_monitor_cache(ObjectMonitor* monitor);\n+  void om_clear_monitor_cache();\n+  ObjectMonitor* om_get_from_monitor_cache(oop obj);\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/lockStack.inline.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -242,0 +244,21 @@\n+inline void JavaThread::om_set_monitor_cache(ObjectMonitor* monitor) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  assert(monitor != nullptr, \"use om_clear_monitor_cache to clear\");\n+  assert(this == current() || monitor->owner_raw() == this, \"only add owned monitors for other threads\");\n+  assert(this == current() || is_obj_deopt_suspend(), \"thread must not run concurrently\");\n+\n+  _om_cache.set_monitor(monitor);\n+}\n+\n+inline void JavaThread::om_clear_monitor_cache() {\n+  if (UseObjectMonitorTable) {\n+    _om_cache.clear();\n+  }\n+}\n+\n+inline ObjectMonitor* JavaThread::om_get_from_monitor_cache(oop obj) {\n+  assert(obj != nullptr, \"do not look for null objects\");\n+  assert(this == current(), \"only get own thread locals\");\n+  return _om_cache.get_monitor(obj);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,1223 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"jfrfiles\/jfrEventClasses.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"nmt\/memflags.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/basicLock.inline.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/lockStack.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/objectMonitor.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/perfData.inline.hpp\"\n+#include \"runtime\/safepointMechanism.inline.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n+#include \"runtime\/timerTrace.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n+#include \"utilities\/concurrentHashTable.inline.hpp\"\n+#include \"utilities\/concurrentHashTableTasks.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ ConcurrentHashTable storing links from objects to ObjectMonitors\n+class ObjectMonitorTable : AllStatic {\n+  struct Config {\n+    using Value = ObjectMonitor*;\n+    static uintx get_hash(Value const& value, bool* is_dead) {\n+      return (uintx)value->hash();\n+    }\n+    static void* allocate_node(void* context, size_t size, Value const& value) {\n+      ObjectMonitorTable::inc_items_count();\n+      return AllocateHeap(size, MEMFLAGS::mtObjectMonitor);\n+    };\n+    static void free_node(void* context, void* memory, Value const& value) {\n+      ObjectMonitorTable::dec_items_count();\n+      FreeHeap(memory);\n+    }\n+  };\n+  using ConcurrentTable = ConcurrentHashTable<Config, MEMFLAGS::mtObjectMonitor>;\n+\n+  static ConcurrentTable* _table;\n+  static volatile size_t _items_count;\n+  static size_t _table_size;\n+  static volatile bool _resize;\n+\n+  class Lookup : public StackObj {\n+    oop _obj;\n+\n+   public:\n+    explicit Lookup(oop obj) : _obj(obj) {}\n+\n+    uintx get_hash() const {\n+      uintx hash = _obj->mark().hash();\n+      assert(hash != 0, \"should have a hash\");\n+      return hash;\n+    }\n+\n+    bool equals(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return (*value)->object_refers_to(_obj);\n+    }\n+\n+    bool is_dead(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return false;\n+    }\n+  };\n+\n+  class LookupMonitor : public StackObj {\n+    ObjectMonitor* _monitor;\n+\n+   public:\n+    explicit LookupMonitor(ObjectMonitor* monitor) : _monitor(monitor) {}\n+\n+    uintx get_hash() const {\n+      return _monitor->hash();\n+    }\n+\n+    bool equals(ObjectMonitor** value) {\n+      return (*value) == _monitor;\n+    }\n+\n+    bool is_dead(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return (*value)->object_is_dead();\n+    }\n+  };\n+\n+  static void inc_items_count() {\n+    Atomic::inc(&_items_count);\n+  }\n+\n+  static void dec_items_count() {\n+    Atomic::dec(&_items_count);\n+  }\n+\n+  static double get_load_factor() {\n+    return (double)_items_count \/ (double)_table_size;\n+  }\n+\n+  static size_t table_size(Thread* current = Thread::current()) {\n+    return ((size_t)1) << _table->get_size_log2(current);\n+  }\n+\n+  static size_t max_log_size() {\n+    \/\/ TODO[OMTable]: Evaluate the max size.\n+    \/\/ TODO[OMTable]: Need to fix init order to use Universe::heap()->max_capacity();\n+    \/\/                Using MaxHeapSize directly this early may be wrong, and there\n+    \/\/                are definitely rounding errors (alignment).\n+    const size_t max_capacity = MaxHeapSize;\n+    const size_t min_object_size = CollectedHeap::min_dummy_object_size() * HeapWordSize;\n+    const size_t max_objects = max_capacity \/ MAX2(MinObjAlignmentInBytes, checked_cast<int>(min_object_size));\n+    const size_t log_max_objects = log2i_graceful(max_objects);\n+\n+    return MAX2(MIN2<size_t>(SIZE_BIG_LOG2, log_max_objects), min_log_size());\n+  }\n+\n+  static size_t min_log_size() {\n+    \/\/ ~= log(AvgMonitorsPerThreadEstimate default)\n+    return 10;\n+  }\n+\n+  template<typename V>\n+  static size_t clamp_log_size(V log_size) {\n+    return MAX2(MIN2(log_size, checked_cast<V>(max_log_size())), checked_cast<V>(min_log_size()));\n+  }\n+\n+  static size_t initial_log_size() {\n+    const size_t estimate = log2i(MAX2(os::processor_count(), 1)) + log2i(MAX2(AvgMonitorsPerThreadEstimate, size_t(1)));\n+    return clamp_log_size(estimate);\n+  }\n+\n+  static size_t grow_hint () {\n+    return ConcurrentTable::DEFAULT_GROW_HINT;\n+  }\n+\n+ public:\n+  static void create() {\n+    _table = new ConcurrentTable(initial_log_size(), max_log_size(), grow_hint());\n+    _items_count = 0;\n+    _table_size = table_size();\n+    _resize = false;\n+  }\n+\n+  static void verify_monitor_get_result(oop obj, ObjectMonitor* monitor) {\n+#ifdef ASSERT\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      bool has_monitor = obj->mark().has_monitor();\n+      assert(has_monitor == (monitor != nullptr),\n+          \"Inconsistency between markWord and ObjectMonitorTable has_monitor: %s monitor: \" PTR_FORMAT,\n+          BOOL_TO_STR(has_monitor), p2i(monitor));\n+    }\n+#endif\n+  }\n+\n+  static ObjectMonitor* monitor_get(Thread* current, oop obj) {\n+    ObjectMonitor* result = nullptr;\n+    Lookup lookup_f(obj);\n+    auto found_f = [&](ObjectMonitor** found) {\n+      assert((*found)->object_peek() == obj, \"must be\");\n+      result = *found;\n+    };\n+    _table->get(current, lookup_f, found_f);\n+    verify_monitor_get_result(obj, result);\n+    return result;\n+  }\n+\n+  static void try_notify_grow() {\n+    if (!_table->is_max_size_reached() && !Atomic::load(&_resize)) {\n+      Atomic::store(&_resize, true);\n+      if (Service_lock->try_lock()) {\n+        Service_lock->notify();\n+        Service_lock->unlock();\n+      }\n+    }\n+  }\n+\n+  static bool should_shrink() {\n+    \/\/ Not implemented;\n+    return false;\n+  }\n+\n+  static constexpr double GROW_LOAD_FACTOR = 0.75;\n+\n+  static bool should_grow() {\n+    return get_load_factor() > GROW_LOAD_FACTOR && !_table->is_max_size_reached();\n+  }\n+\n+  static bool should_resize() {\n+    return should_grow() || should_shrink() || Atomic::load(&_resize);\n+  }\n+\n+  template<typename Task, typename... Args>\n+  static bool run_task(JavaThread* current, Task& task, const char* task_name, Args&... args) {\n+    if (task.prepare(current)) {\n+      log_trace(monitortable)(\"Started to %s\", task_name);\n+      TraceTime timer(task_name, TRACETIME_LOG(Debug, monitortable, perf));\n+      while (task.do_task(current, args...)) {\n+        task.pause(current);\n+        {\n+          ThreadBlockInVM tbivm(current);\n+        }\n+        task.cont(current);\n+      }\n+      task.done(current);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  static bool grow(JavaThread* current) {\n+    ConcurrentTable::GrowTask grow_task(_table);\n+    if (run_task(current, grow_task, \"Grow\")) {\n+      _table_size = table_size(current);\n+      log_info(monitortable)(\"Grown to size: %zu\", _table_size);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  static bool clean(JavaThread* current) {\n+    ConcurrentTable::BulkDeleteTask clean_task(_table);\n+    auto is_dead = [&](ObjectMonitor** monitor) {\n+      return (*monitor)->object_is_dead();\n+    };\n+    auto do_nothing = [&](ObjectMonitor** monitor) {};\n+    NativeHeapTrimmer::SuspendMark sm(\"ObjectMonitorTable\");\n+    return run_task(current, clean_task, \"Clean\", is_dead, do_nothing);\n+  }\n+\n+  static bool resize(JavaThread* current) {\n+    LogTarget(Info, monitortable) lt;\n+    bool success = false;\n+\n+    if (should_grow()) {\n+      lt.print(\"Start growing with load factor %f\", get_load_factor());\n+      success = grow(current);\n+    } else {\n+      if (!_table->is_max_size_reached() && Atomic::load(&_resize)) {\n+        lt.print(\"WARNING: Getting resize hints with load factor %f\", get_load_factor());\n+      }\n+      lt.print(\"Start cleaning with load factor %f\", get_load_factor());\n+      success = clean(current);\n+    }\n+\n+    Atomic::store(&_resize, false);\n+\n+    return success;\n+  }\n+\n+  static ObjectMonitor* monitor_put_get(Thread* current, ObjectMonitor* monitor, oop obj) {\n+    \/\/ Enter the monitor into the concurrent hashtable.\n+    ObjectMonitor* result = monitor;\n+    Lookup lookup_f(obj);\n+    auto found_f = [&](ObjectMonitor** found) {\n+      assert((*found)->object_peek() == obj, \"must be\");\n+      result = *found;\n+    };\n+    bool grow;\n+    _table->insert_get(current, lookup_f, monitor, found_f, &grow);\n+    verify_monitor_get_result(obj, result);\n+    if (grow) {\n+      try_notify_grow();\n+    }\n+    return result;\n+  }\n+\n+  static bool remove_monitor_entry(Thread* current, ObjectMonitor* monitor) {\n+    LookupMonitor lookup_f(monitor);\n+    return _table->remove(current, lookup_f);\n+  }\n+\n+  static bool contains_monitor(Thread* current, ObjectMonitor* monitor) {\n+    LookupMonitor lookup_f(monitor);\n+    bool result = false;\n+    auto found_f = [&](ObjectMonitor** found) {\n+      result = true;\n+    };\n+    _table->get(current, lookup_f, found_f);\n+    return result;\n+  }\n+\n+  static void print_on(outputStream* st) {\n+    auto printer = [&] (ObjectMonitor** entry) {\n+       ObjectMonitor* om = *entry;\n+       oop obj = om->object_peek();\n+       st->print(\"monitor=\" PTR_FORMAT \", \", p2i(om));\n+       st->print(\"object=\" PTR_FORMAT, p2i(obj));\n+       assert(obj->mark().hash() == om->hash(), \"hash must match\");\n+       st->cr();\n+       return true;\n+    };\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      _table->do_safepoint_scan(printer);\n+    } else {\n+      _table->do_scan(Thread::current(), printer);\n+    }\n+  }\n+};\n+\n+ObjectMonitorTable::ConcurrentTable* ObjectMonitorTable::_table = nullptr;\n+volatile size_t ObjectMonitorTable::_items_count = 0;\n+size_t ObjectMonitorTable::_table_size = 0;\n+volatile bool ObjectMonitorTable::_resize = false;\n+\n+ObjectMonitor* LightweightSynchronizer::get_or_insert_monitor_from_table(oop object, JavaThread* current, bool* inserted) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+\n+  ObjectMonitor* monitor = get_monitor_from_table(current, object);\n+  if (monitor != nullptr) {\n+    *inserted = false;\n+    return monitor;\n+  }\n+\n+  ObjectMonitor* alloced_monitor = new ObjectMonitor(object);\n+  alloced_monitor->set_owner_anonymous();\n+\n+  \/\/ Try insert monitor\n+  monitor = add_monitor(current, alloced_monitor, object);\n+\n+  *inserted = alloced_monitor == monitor;\n+  if (!*inserted) {\n+    delete alloced_monitor;\n+  }\n+\n+  return monitor;\n+}\n+\n+static void log_inflate(Thread* current, oop object, ObjectSynchronizer::InflateCause cause) {\n+  if (log_is_enabled(Trace, monitorinflation)) {\n+    ResourceMark rm(current);\n+    log_trace(monitorinflation)(\"inflate: object=\" INTPTR_FORMAT \", mark=\"\n+                                INTPTR_FORMAT \", type='%s' cause=%s\", p2i(object),\n+                                object->mark().value(), object->klass()->external_name(),\n+                                ObjectSynchronizer::inflate_cause_name(cause));\n+  }\n+}\n+\n+static void post_monitor_inflate_event(EventJavaMonitorInflate* event,\n+                                       const oop obj,\n+                                       ObjectSynchronizer::InflateCause cause) {\n+  assert(event != nullptr, \"invariant\");\n+  event->set_monitorClass(obj->klass());\n+  event->set_address((uintptr_t)(void*)obj);\n+  event->set_cause((u1)cause);\n+  event->commit();\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::get_or_insert_monitor(oop object, JavaThread* current, ObjectSynchronizer::InflateCause cause) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+\n+  EventJavaMonitorInflate event;\n+\n+  bool inserted;\n+  ObjectMonitor* monitor = get_or_insert_monitor_from_table(object, current, &inserted);\n+\n+  if (inserted) {\n+    \/\/ Hopefully the performance counters are allocated on distinct\n+    \/\/ cache lines to avoid false sharing on MP systems ...\n+    OM_PERFDATA_OP(Inflations, inc());\n+    log_inflate(current, object, cause);\n+    if (event.should_commit()) {\n+      post_monitor_inflate_event(&event, object, cause);\n+    }\n+\n+    \/\/ The monitor has an anonymous owner so it is safe from async deflation.\n+    ObjectSynchronizer::_in_use_list.add(monitor);\n+  }\n+\n+  return monitor;\n+}\n+\n+\/\/ Add the hashcode to the monitor to match the object and put it in the hashtable.\n+ObjectMonitor* LightweightSynchronizer::add_monitor(JavaThread* current, ObjectMonitor* monitor, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  assert(obj == monitor->object(), \"must be\");\n+\n+  intptr_t hash = obj->mark().hash();\n+  assert(hash != 0, \"must be set when claiming the object monitor\");\n+  monitor->set_hash(hash);\n+\n+  return ObjectMonitorTable::monitor_put_get(current, monitor, obj);\n+}\n+\n+bool LightweightSynchronizer::remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  assert(monitor->object_peek() == obj, \"must be, cleared objects are removed by is_dead\");\n+\n+  return ObjectMonitorTable::remove_monitor_entry(current, monitor);\n+}\n+\n+void LightweightSynchronizer::deflate_mark_word(oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+\n+  markWord mark = obj->mark_acquire();\n+  assert(!mark.has_no_hash(), \"obj with inflated monitor must have had a hash\");\n+\n+  while (mark.has_monitor()) {\n+    const markWord new_mark = mark.clear_lock_bits().set_unlocked();\n+    mark = obj->cas_set_mark(new_mark, mark);\n+  }\n+}\n+\n+void LightweightSynchronizer::initialize() {\n+  if (!UseObjectMonitorTable) {\n+    return;\n+  }\n+  ObjectMonitorTable::create();\n+}\n+\n+bool LightweightSynchronizer::needs_resize() {\n+  if (!UseObjectMonitorTable) {\n+    return false;\n+  }\n+  return ObjectMonitorTable::should_resize();\n+}\n+\n+bool LightweightSynchronizer::resize_table(JavaThread* current) {\n+  if (!UseObjectMonitorTable) {\n+    return true;\n+  }\n+  return ObjectMonitorTable::resize(current);\n+}\n+\n+class LightweightSynchronizer::LockStackInflateContendedLocks : private OopClosure {\n+ private:\n+  oop _contended_oops[LockStack::CAPACITY];\n+  int _length;\n+\n+  void do_oop(oop* o) final {\n+    oop obj = *o;\n+    if (obj->mark_acquire().has_monitor()) {\n+      if (_length > 0 && _contended_oops[_length - 1] == obj) {\n+        \/\/ Recursive\n+        return;\n+      }\n+      _contended_oops[_length++] = obj;\n+    }\n+  }\n+\n+  void do_oop(narrowOop* o) final {\n+    ShouldNotReachHere();\n+  }\n+\n+ public:\n+  LockStackInflateContendedLocks() :\n+    _contended_oops(),\n+    _length(0) {};\n+\n+  void inflate(JavaThread* current) {\n+    assert(current == JavaThread::current(), \"must be\");\n+    current->lock_stack().oops_do(this);\n+    for (int i = 0; i < _length; i++) {\n+      LightweightSynchronizer::\n+        inflate_fast_locked_object(_contended_oops[i], ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n+    }\n+  }\n+};\n+\n+void LightweightSynchronizer::ensure_lock_stack_space(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+  LockStack& lock_stack = current->lock_stack();\n+\n+  \/\/ Make room on lock_stack\n+  if (lock_stack.is_full()) {\n+    \/\/ Inflate contended objects\n+    LockStackInflateContendedLocks().inflate(current);\n+    if (lock_stack.is_full()) {\n+      \/\/ Inflate the oldest object\n+      inflate_fast_locked_object(lock_stack.bottom(), ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n+    }\n+  }\n+}\n+\n+class LightweightSynchronizer::CacheSetter : StackObj {\n+  JavaThread* const _thread;\n+  BasicLock* const _lock;\n+  ObjectMonitor* _monitor;\n+\n+  NONCOPYABLE(CacheSetter);\n+\n+ public:\n+  CacheSetter(JavaThread* thread, BasicLock* lock) :\n+    _thread(thread),\n+    _lock(lock),\n+    _monitor(nullptr) {}\n+\n+  ~CacheSetter() {\n+    \/\/ Only use the cache if using the table.\n+    if (UseObjectMonitorTable) {\n+      if (_monitor != nullptr) {\n+        _thread->om_set_monitor_cache(_monitor);\n+        _lock->set_object_monitor_cache(_monitor);\n+      } else {\n+        _lock->clear_object_monitor_cache();\n+      }\n+    }\n+  }\n+\n+  void set_monitor(ObjectMonitor* monitor) {\n+    assert(_monitor == nullptr, \"only set once\");\n+    _monitor = monitor;\n+  }\n+\n+};\n+\n+class LightweightSynchronizer::VerifyThreadState {\n+  bool _no_safepoint;\n+\n+ public:\n+  VerifyThreadState(JavaThread* locking_thread, JavaThread* current) : _no_safepoint(locking_thread != current) {\n+    assert(current == Thread::current(), \"must be\");\n+    assert(locking_thread == current || locking_thread->is_obj_deopt_suspend(), \"locking_thread may not run concurrently\");\n+    if (_no_safepoint) {\n+      DEBUG_ONLY(JavaThread::current()->inc_no_safepoint_count();)\n+    }\n+  }\n+  ~VerifyThreadState() {\n+    if (_no_safepoint){\n+      DEBUG_ONLY(JavaThread::current()->dec_no_safepoint_count();)\n+    }\n+  }\n+};\n+\n+inline bool LightweightSynchronizer::fast_lock_try_enter(oop obj, LockStack& lock_stack, JavaThread* current) {\n+  markWord mark = obj->mark();\n+  while (mark.is_unlocked()) {\n+    ensure_lock_stack_space(current);\n+    assert(!lock_stack.is_full(), \"must have made room on the lock stack\");\n+    assert(!lock_stack.contains(obj), \"thread must not already hold the lock\");\n+    \/\/ Try to swing into 'fast-locked' state.\n+    markWord locked_mark = mark.set_fast_locked();\n+    markWord old_mark = mark;\n+    mark = obj->cas_set_mark(locked_mark, old_mark);\n+    if (old_mark == mark) {\n+      \/\/ Successfully fast-locked, push object to lock-stack and return.\n+      lock_stack.push(obj);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool LightweightSynchronizer::fast_lock_spin_enter(oop obj, LockStack& lock_stack, JavaThread* current, bool observed_deflation) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  \/\/ Will spin with exponential backoff with an accumulative O(2^spin_limit) spins.\n+  const int log_spin_limit = os::is_MP() ? LightweightFastLockingSpins : 1;\n+  const int log_min_safepoint_check_interval = 10;\n+\n+  markWord mark = obj->mark();\n+  const auto should_spin = [&]() {\n+    if (!mark.has_monitor()) {\n+      \/\/ Spin while not inflated.\n+      return true;\n+    } else if (observed_deflation) {\n+      \/\/ Spin while monitor is being deflated.\n+      ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n+      return monitor == nullptr || monitor->is_being_async_deflated();\n+    }\n+    \/\/ Else stop spinning.\n+    return false;\n+  };\n+  \/\/ Always attempt to lock once even when safepoint synchronizing.\n+  bool should_process = false;\n+  for (int i = 0; should_spin() && !should_process && i < log_spin_limit; i++) {\n+    \/\/ Spin with exponential backoff.\n+    const int total_spin_count = 1 << i;\n+    const int inner_spin_count = MIN2(1 << log_min_safepoint_check_interval, total_spin_count);\n+    const int outer_spin_count = total_spin_count \/ inner_spin_count;\n+    for (int outer = 0; outer < outer_spin_count; outer++) {\n+      should_process = SafepointMechanism::should_process(current);\n+      if (should_process) {\n+        \/\/ Stop spinning for safepoint.\n+        break;\n+      }\n+      for (int inner = 1; inner < inner_spin_count; inner++) {\n+        SpinPause();\n+      }\n+    }\n+\n+    if (fast_lock_try_enter(obj, lock_stack, current)) return true;\n+  }\n+  return false;\n+}\n+\n+void LightweightSynchronizer::enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  JavaThread* current = JavaThread::current();\n+  VerifyThreadState vts(locking_thread, current);\n+\n+  if (obj->klass()->is_value_based()) {\n+    ObjectSynchronizer::handle_sync_on_value_based_class(obj, locking_thread);\n+  }\n+\n+  locking_thread->inc_held_monitor_count();\n+\n+  CacheSetter cache_setter(locking_thread, lock);\n+\n+  LockStack& lock_stack = locking_thread->lock_stack();\n+\n+  ObjectMonitor* monitor = nullptr;\n+  if (lock_stack.contains(obj())) {\n+    monitor = inflate_fast_locked_object(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n+    bool entered = monitor->enter_for(locking_thread);\n+    assert(entered, \"recursive ObjectMonitor::enter_for must succeed\");\n+  } else {\n+    \/\/ It is assumed that enter_for must enter on an object without contention.\n+    monitor = inflate_and_enter(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n+  }\n+\n+  assert(monitor != nullptr, \"LightweightSynchronizer::enter_for must succeed\");\n+  cache_setter.set_monitor(monitor);\n+}\n+\n+void LightweightSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  if (obj->klass()->is_value_based()) {\n+    ObjectSynchronizer::handle_sync_on_value_based_class(obj, current);\n+  }\n+\n+  current->inc_held_monitor_count();\n+\n+  CacheSetter cache_setter(current, lock);\n+\n+  \/\/ Used when deflation is observed. Progress here requires progress\n+  \/\/ from the deflator. After observing that the deflator is not\n+  \/\/ making progress (after two yields), switch to sleeping.\n+  SpinYield spin_yield(0, 2);\n+  bool observed_deflation = false;\n+\n+  LockStack& lock_stack = current->lock_stack();\n+\n+  if (!lock_stack.is_full() && lock_stack.try_recursive_enter(obj())) {\n+    \/\/ Recursively fast locked\n+    return;\n+  }\n+\n+  if (lock_stack.contains(obj())) {\n+    ObjectMonitor* monitor = inflate_fast_locked_object(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, current, current);\n+    bool entered = monitor->enter(current);\n+    assert(entered, \"recursive ObjectMonitor::enter must succeed\");\n+    cache_setter.set_monitor(monitor);\n+    return;\n+  }\n+\n+  while (true) {\n+    \/\/ Fast-locking does not use the 'lock' argument.\n+    \/\/ Fast-lock spinning to avoid inflating for short critical sections.\n+    \/\/ The goal is to only inflate when the extra cost of using ObjectMonitors\n+    \/\/ is worth it.\n+    \/\/ If deflation has been observed we also spin while deflation is ongoing.\n+    if (fast_lock_try_enter(obj(), lock_stack, current)) {\n+      return;\n+    } else if (UseObjectMonitorTable && fast_lock_spin_enter(obj(), lock_stack, current, observed_deflation)) {\n+      return;\n+    }\n+\n+    if (observed_deflation) {\n+      spin_yield.wait();\n+    }\n+\n+    ObjectMonitor* monitor = inflate_and_enter(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, current, current);\n+    if (monitor != nullptr) {\n+      cache_setter.set_monitor(monitor);\n+      return;\n+    }\n+\n+    \/\/ If inflate_and_enter returns nullptr it is because a deflated monitor\n+    \/\/ was encountered. Fallback to fast locking. The deflater is responsible\n+    \/\/ for clearing out the monitor and transitioning the markWord back to\n+    \/\/ fast locking.\n+    observed_deflation = true;\n+  }\n+}\n+\n+void LightweightSynchronizer::exit(oop object, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(current == Thread::current(), \"must be\");\n+\n+  markWord mark = object->mark();\n+  assert(!mark.is_unlocked(), \"must be\");\n+\n+  LockStack& lock_stack = current->lock_stack();\n+  if (mark.is_fast_locked()) {\n+    if (lock_stack.try_recursive_exit(object)) {\n+      \/\/ This is a recursive exit which succeeded\n+      return;\n+    }\n+    if (lock_stack.is_recursive(object)) {\n+      \/\/ Must inflate recursive locks if try_recursive_exit fails\n+      \/\/ This happens for un-structured unlocks, could potentially\n+      \/\/ fix try_recursive_exit to handle these.\n+      inflate_fast_locked_object(object, ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n+    }\n+  }\n+\n+  while (mark.is_fast_locked()) {\n+    markWord unlocked_mark = mark.set_unlocked();\n+    markWord old_mark = mark;\n+    mark = object->cas_set_mark(unlocked_mark, old_mark);\n+    if (old_mark == mark) {\n+      \/\/ CAS successful, remove from lock_stack\n+      size_t recursion = lock_stack.remove(object) - 1;\n+      assert(recursion == 0, \"Should not have unlocked here\");\n+      return;\n+    }\n+  }\n+\n+  assert(mark.has_monitor(), \"must be\");\n+  \/\/ The monitor exists\n+  ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, object, mark);\n+  if (monitor->is_owner_anonymous()) {\n+    assert(current->lock_stack().contains(object), \"current must have object on its lock stack\");\n+    monitor->set_owner_from_anonymous(current);\n+    monitor->set_recursions(current->lock_stack().remove(object) - 1);\n+  }\n+\n+  monitor->exit(current);\n+}\n+\n+\/\/ LightweightSynchronizer::inflate_locked_or_imse is used to to get an inflated\n+\/\/ ObjectMonitor* with LM_LIGHTWEIGHT. It is used from contexts which require\n+\/\/ an inflated ObjectMonitor* for a monitor, and expects to throw a\n+\/\/ java.lang.IllegalMonitorStateException if it is not held by the current\n+\/\/ thread. Such as notify\/wait and jni_exit. LM_LIGHTWEIGHT keeps it invariant\n+\/\/ that it only inflates if it is already locked by the current thread or the\n+\/\/ current thread is in the process of entering. To maintain this invariant we\n+\/\/ need to throw a java.lang.IllegalMonitorStateException before inflating if\n+\/\/ the current thread is not the owner.\n+\/\/ LightweightSynchronizer::inflate_locked_or_imse facilitates this.\n+ObjectMonitor* LightweightSynchronizer::inflate_locked_or_imse(oop obj, ObjectSynchronizer::InflateCause cause, TRAPS) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  JavaThread* current = THREAD;\n+\n+  for (;;) {\n+    markWord mark = obj->mark_acquire();\n+    if (mark.is_unlocked()) {\n+      \/\/ No lock, IMSE.\n+      THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n+                 \"current thread is not owner\", nullptr);\n+    }\n+\n+    if (mark.is_fast_locked()) {\n+      if (!current->lock_stack().contains(obj)) {\n+        \/\/ Fast locked by other thread, IMSE.\n+        THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n+                   \"current thread is not owner\", nullptr);\n+      } else {\n+        \/\/ Current thread owns the lock, must inflate\n+        return inflate_fast_locked_object(obj, cause, current, current);\n+      }\n+    }\n+\n+    assert(mark.has_monitor(), \"must be\");\n+    ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n+    if (monitor != nullptr) {\n+      if (monitor->is_owner_anonymous()) {\n+        LockStack& lock_stack = current->lock_stack();\n+        if (lock_stack.contains(obj)) {\n+          \/\/ Current thread owns the lock but someone else inflated it.\n+          \/\/ Fix owner and pop lock stack.\n+          monitor->set_owner_from_anonymous(current);\n+          monitor->set_recursions(lock_stack.remove(obj) - 1);\n+        } else {\n+          \/\/ Fast locked (and inflated) by other thread, or deflation in progress, IMSE.\n+          THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n+                     \"current thread is not owner\", nullptr);\n+        }\n+      }\n+      return monitor;\n+    }\n+  }\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* inflating_thread, Thread* current) {\n+\n+  \/\/ The JavaThread* inflating_thread parameter is only used by LM_LIGHTWEIGHT and requires\n+  \/\/ that the inflating_thread == Thread::current() or is suspended throughout the call by\n+  \/\/ some other mechanism.\n+  \/\/ Even with LM_LIGHTWEIGHT the thread might be nullptr when called from a non\n+  \/\/ JavaThread. (As may still be the case from FastHashCode). However it is only\n+  \/\/ important for the correctness of the LM_LIGHTWEIGHT algorithm that the thread\n+  \/\/ is set when called from ObjectSynchronizer::enter from the owning thread,\n+  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n+  EventJavaMonitorInflate event;\n+\n+  for (;;) {\n+    const markWord mark = object->mark_acquire();\n+\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  inflated     - Just return if using stack-locking.\n+    \/\/                   If using fast-locking and the ObjectMonitor owner\n+    \/\/                   is anonymous and the inflating_thread owns the\n+    \/\/                   object lock, then we make the inflating_thread\n+    \/\/                   the ObjectMonitor owner and remove the lock from\n+    \/\/                   the inflating_thread's lock stack.\n+    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  unlocked     - Aggressively inflate the object.\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      ObjectMonitor* inf = mark.monitor();\n+      markWord dmw = inf->header();\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+      if (inf->is_owner_anonymous() &&\n+          inflating_thread != nullptr && inflating_thread->lock_stack().contains(object)) {\n+        inf->set_owner_from_anonymous(inflating_thread);\n+        size_t removed = inflating_thread->lock_stack().remove(object);\n+        inf->set_recursions(removed - 1);\n+      }\n+      return inf;\n+    }\n+\n+    \/\/ CASE: fast-locked\n+    \/\/ Could be fast-locked either by the inflating_thread or by some other thread.\n+    \/\/\n+    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_\n+    \/\/ attempting to set the object's mark to the new ObjectMonitor. If\n+    \/\/ the inflating_thread owns the monitor, then we set the ObjectMonitor's\n+    \/\/ owner to the inflating_thread. Otherwise, we set the ObjectMonitor's owner\n+    \/\/ to anonymous. If we lose the race to set the object's mark to the\n+    \/\/ new ObjectMonitor, then we just delete it and loop around again.\n+    \/\/\n+    if (mark.is_fast_locked()) {\n+      ObjectMonitor* monitor = new ObjectMonitor(object);\n+      monitor->set_header(mark.set_unlocked());\n+      bool own = inflating_thread != nullptr && inflating_thread->lock_stack().contains(object);\n+      if (own) {\n+        \/\/ Owned by inflating_thread.\n+        monitor->set_owner_from(nullptr, inflating_thread);\n+      } else {\n+        \/\/ Owned by somebody else.\n+        monitor->set_owner_anonymous();\n+      }\n+      markWord monitor_mark = markWord::encode(monitor);\n+      markWord old_mark = object->cas_set_mark(monitor_mark, mark);\n+      if (old_mark == mark) {\n+        \/\/ Success! Return inflated monitor.\n+        if (own) {\n+          size_t removed = inflating_thread->lock_stack().remove(object);\n+          monitor->set_recursions(removed - 1);\n+        }\n+        \/\/ Once the ObjectMonitor is configured and object is associated\n+        \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+        ObjectSynchronizer::_in_use_list.add(monitor);\n+\n+        \/\/ Hopefully the performance counters are allocated on distinct\n+        \/\/ cache lines to avoid false sharing on MP systems ...\n+        OM_PERFDATA_OP(Inflations, inc());\n+        log_inflate(current, object, cause);\n+        if (event.should_commit()) {\n+          post_monitor_inflate_event(&event, object, cause);\n+        }\n+        return monitor;\n+      } else {\n+        delete monitor;\n+        continue;  \/\/ Interference -- just retry\n+      }\n+    }\n+\n+    \/\/ CASE: unlocked\n+    \/\/ TODO-FIXME: for entry we currently inflate and then try to CAS _owner.\n+    \/\/ If we know we're inflating for entry it's better to inflate by swinging a\n+    \/\/ pre-locked ObjectMonitor pointer into the object header.   A successful\n+    \/\/ CAS inflates the object *and* confers ownership to the inflating thread.\n+    \/\/ In the current implementation we use a 2-step mechanism where we CAS()\n+    \/\/ to inflate and then CAS() again to try to swing _owner from null to current.\n+    \/\/ An inflateTry() method that we could call from enter() would be useful.\n+\n+    assert(mark.is_unlocked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    ObjectMonitor* m = new ObjectMonitor(object);\n+    \/\/ prepare m for installation - set monitor to initial state\n+    m->set_header(mark);\n+\n+    if (object->cas_set_mark(markWord::encode(m), mark) != mark) {\n+      delete m;\n+      m = nullptr;\n+      continue;\n+      \/\/ interference - the markword changed - just retry.\n+      \/\/ The state-transitions are one-way, so there's no chance of\n+      \/\/ live-lock -- \"Inflated\" is an absorbing state.\n+    }\n+\n+    \/\/ Once the ObjectMonitor is configured and object is associated\n+    \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+    ObjectSynchronizer::_in_use_list.add(m);\n+\n+    \/\/ Hopefully the performance counters are allocated on distinct\n+    \/\/ cache lines to avoid false sharing on MP systems ...\n+    OM_PERFDATA_OP(Inflations, inc());\n+    log_inflate(current, object, cause);\n+    if (event.should_commit()) {\n+      post_monitor_inflate_event(&event, object, cause);\n+    }\n+    return m;\n+  }\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::inflate_fast_locked_object(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used for lightweight\");\n+  VerifyThreadState vts(locking_thread, current);\n+  assert(locking_thread->lock_stack().contains(object), \"locking_thread must have object on its lock stack\");\n+\n+  ObjectMonitor* monitor;\n+\n+  if (!UseObjectMonitorTable) {\n+    return inflate_into_object_header(object, cause, locking_thread, current);\n+  }\n+\n+  \/\/ Inflating requires a hash code\n+  ObjectSynchronizer::FastHashCode(current, object);\n+\n+  markWord mark = object->mark_acquire();\n+  assert(!mark.is_unlocked(), \"Cannot be unlocked\");\n+\n+  for (;;) {\n+    \/\/ Fetch the monitor from the table\n+    monitor = get_or_insert_monitor(object, current, cause);\n+\n+    \/\/ ObjectMonitors are always inserted as anonymously owned, this thread is\n+    \/\/ the current holder of the monitor. So unless the entry is stale and\n+    \/\/ contains a deflating monitor it must be anonymously owned.\n+    if (monitor->is_owner_anonymous()) {\n+      \/\/ The monitor must be anonymously owned if it was added\n+      assert(monitor == get_monitor_from_table(current, object), \"The monitor must be found\");\n+      \/\/ New fresh monitor\n+      break;\n+    }\n+\n+    \/\/ If the monitor was not anonymously owned then we got a deflating monitor\n+    \/\/ from the table. We need to let the deflator make progress and remove this\n+    \/\/ entry before we are allowed to add a new one.\n+    os::naked_yield();\n+    assert(monitor->is_being_async_deflated(), \"Should be the reason\");\n+  }\n+\n+  \/\/ Set the mark word; loop to handle concurrent updates to other parts of the mark word\n+  while (mark.is_fast_locked()) {\n+    mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n+  }\n+\n+  \/\/ Indicate that the monitor now has a known owner\n+  monitor->set_owner_from_anonymous(locking_thread);\n+\n+  \/\/ Remove the entry from the thread's lock stack\n+  monitor->set_recursions(locking_thread->lock_stack().remove(object) - 1);\n+\n+  if (locking_thread == current) {\n+    \/\/ Only change the thread local state of the current thread.\n+    locking_thread->om_set_monitor_cache(monitor);\n+  }\n+\n+  return monitor;\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::inflate_and_enter(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used for lightweight\");\n+  VerifyThreadState vts(locking_thread, current);\n+\n+  \/\/ Note: In some paths (deoptimization) the 'current' thread inflates and\n+  \/\/ enters the lock on behalf of the 'locking_thread' thread.\n+\n+  ObjectMonitor* monitor = nullptr;\n+\n+  if (!UseObjectMonitorTable) {\n+    \/\/ Do the old inflate and enter.\n+    monitor = inflate_into_object_header(object, cause, locking_thread, current);\n+\n+    bool entered;\n+    if (locking_thread == current) {\n+      entered = monitor->enter(locking_thread);\n+    } else {\n+      entered = monitor->enter_for(locking_thread);\n+    }\n+\n+    \/\/ enter returns false for deflation found.\n+    return entered ? monitor : nullptr;\n+  }\n+\n+  NoSafepointVerifier nsv;\n+\n+  \/\/ Lightweight monitors require that hash codes are installed first\n+  ObjectSynchronizer::FastHashCode(locking_thread, object);\n+\n+  \/\/ Try to get the monitor from the thread-local cache.\n+  \/\/ There's no need to use the cache if we are locking\n+  \/\/ on behalf of another thread.\n+  if (current == locking_thread) {\n+    monitor = current->om_get_from_monitor_cache(object);\n+  }\n+\n+  \/\/ Get or create the monitor\n+  if (monitor == nullptr) {\n+    monitor = get_or_insert_monitor(object, current, cause);\n+  }\n+\n+  if (monitor->try_enter(locking_thread)) {\n+    return monitor;\n+  }\n+\n+  \/\/ Holds is_being_async_deflated() stable throughout this function.\n+  ObjectMonitorContentionMark contention_mark(monitor);\n+\n+  \/\/\/ First handle the case where the monitor from the table is deflated\n+  if (monitor->is_being_async_deflated()) {\n+    \/\/ The MonitorDeflation thread is deflating the monitor. The locking thread\n+    \/\/ must spin until further progress has been made.\n+\n+    const markWord mark = object->mark_acquire();\n+\n+    if (mark.has_monitor()) {\n+      \/\/ Waiting on the deflation thread to remove the deflated monitor from the table.\n+      os::naked_yield();\n+\n+    } else if (mark.is_fast_locked()) {\n+      \/\/ Some other thread managed to fast-lock the lock, or this is a\n+      \/\/ recursive lock from the same thread; yield for the deflation\n+      \/\/ thread to remove the deflated monitor from the table.\n+      os::naked_yield();\n+\n+    } else {\n+      assert(mark.is_unlocked(), \"Implied\");\n+      \/\/ Retry immediately\n+    }\n+\n+    \/\/ Retry\n+    return nullptr;\n+  }\n+\n+  for (;;) {\n+    const markWord mark = object->mark_acquire();\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  inflated     - If the ObjectMonitor owner is anonymous\n+    \/\/                   and the locking_thread owns the object\n+    \/\/                   lock, then we make the locking_thread\n+    \/\/                   the ObjectMonitor owner and remove the\n+    \/\/                   lock from the locking_thread's lock stack.\n+    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  neutral      - Inflate the object. Successful CAS is locked\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      LockStack& lock_stack = locking_thread->lock_stack();\n+      if (monitor->is_owner_anonymous() && lock_stack.contains(object)) {\n+        \/\/ The lock is fast-locked by the locking thread,\n+        \/\/ convert it to a held monitor with a known owner.\n+        monitor->set_owner_from_anonymous(locking_thread);\n+        monitor->set_recursions(lock_stack.remove(object) - 1);\n+      }\n+\n+      break; \/\/ Success\n+    }\n+\n+    \/\/ CASE: fast-locked\n+    \/\/ Could be fast-locked either by locking_thread or by some other thread.\n+    \/\/\n+    if (mark.is_fast_locked()) {\n+      markWord old_mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n+      if (old_mark != mark) {\n+        \/\/ CAS failed\n+        continue;\n+      }\n+\n+      \/\/ Success! Return inflated monitor.\n+      LockStack& lock_stack = locking_thread->lock_stack();\n+      if (lock_stack.contains(object)) {\n+        \/\/ The lock is fast-locked by the locking thread,\n+        \/\/ convert it to a held monitor with a known owner.\n+        monitor->set_owner_from_anonymous(locking_thread);\n+        monitor->set_recursions(lock_stack.remove(object) - 1);\n+      }\n+\n+      break; \/\/ Success\n+    }\n+\n+    \/\/ CASE: neutral (unlocked)\n+\n+    \/\/ Catch if the object's header is not neutral (not locked and\n+    \/\/ not marked is what we care about here).\n+    assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    markWord old_mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n+    if (old_mark != mark) {\n+      \/\/ CAS failed\n+      continue;\n+    }\n+\n+    \/\/ Transitioned from unlocked to monitor means locking_thread owns the lock.\n+    monitor->set_owner_from_anonymous(locking_thread);\n+\n+    return monitor;\n+  }\n+\n+  if (current == locking_thread) {\n+    \/\/ One round of spinning\n+    if (monitor->spin_enter(locking_thread)) {\n+      return monitor;\n+    }\n+\n+    \/\/ Monitor is contended, take the time before entering to fix the lock stack.\n+    LockStackInflateContendedLocks().inflate(current);\n+  }\n+\n+  \/\/ enter can block for safepoints; clear the unhandled object oop\n+  PauseNoSafepointVerifier pnsv(&nsv);\n+  object = nullptr;\n+\n+  if (current == locking_thread) {\n+    monitor->enter_with_contention_mark(locking_thread, contention_mark);\n+  } else {\n+    monitor->enter_for_with_contention_mark(locking_thread, contention_mark);\n+  }\n+\n+  return monitor;\n+}\n+\n+void LightweightSynchronizer::deflate_monitor(Thread* current, oop obj, ObjectMonitor* monitor) {\n+  if (obj != nullptr) {\n+    deflate_mark_word(obj);\n+  }\n+  bool removed = remove_monitor(current, monitor, obj);\n+  if (obj != nullptr) {\n+    assert(removed, \"Should have removed the entry if obj was alive\");\n+  }\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::get_monitor_from_table(Thread* current, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  return ObjectMonitorTable::monitor_get(current, obj);\n+}\n+\n+bool LightweightSynchronizer::contains_monitor(Thread* current, ObjectMonitor* monitor) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  return ObjectMonitorTable::contains_monitor(current, monitor);\n+}\n+\n+bool LightweightSynchronizer::quick_enter(oop obj, BasicLock* lock, JavaThread* current) {\n+  assert(current->thread_state() == _thread_in_Java, \"must be\");\n+  assert(obj != nullptr, \"must be\");\n+  NoSafepointVerifier nsv;\n+\n+  \/\/ If quick_enter succeeds with entering, the cache should be in a valid initialized state.\n+  CacheSetter cache_setter(current, lock);\n+\n+  LockStack& lock_stack = current->lock_stack();\n+  if (lock_stack.is_full()) {\n+    \/\/ Always go into runtime if the lock stack is full.\n+    return false;\n+  }\n+\n+  const markWord mark = obj->mark();\n+\n+#ifndef _LP64\n+  \/\/ Only for 32bit which has limited support for fast locking outside the runtime.\n+  if (lock_stack.try_recursive_enter(obj)) {\n+    \/\/ Recursive lock successful.\n+    current->inc_held_monitor_count();\n+    return true;\n+  }\n+\n+  if (mark.is_unlocked()) {\n+    markWord locked_mark = mark.set_fast_locked();\n+    if (obj->cas_set_mark(locked_mark, mark) == mark) {\n+      \/\/ Successfully fast-locked, push object to lock-stack and return.\n+      lock_stack.push(obj);\n+      current->inc_held_monitor_count();\n+      return true;\n+    }\n+  }\n+#endif\n+\n+  if (mark.has_monitor()) {\n+    ObjectMonitor* const monitor = UseObjectMonitorTable ? current->om_get_from_monitor_cache(obj) :\n+                                                           ObjectSynchronizer::read_monitor(mark);\n+\n+    if (monitor == nullptr) {\n+      \/\/ Take the slow-path on a cache miss.\n+      return false;\n+    }\n+\n+    if (monitor->try_enter(current)) {\n+      \/\/ ObjectMonitor enter successful.\n+      cache_setter.set_monitor(monitor);\n+      current->inc_held_monitor_count();\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Slow-path.\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":1223,"deletions":0,"binary":false,"changes":1223,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_LIGHTWEIGHTSYNCHRONIZER_HPP\n+#define SHARE_RUNTIME_LIGHTWEIGHTSYNCHRONIZER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/objectMonitor.hpp\"\n+#include \"runtime\/synchronizer.hpp\"\n+\n+class ObjectMonitorTable;\n+\n+class LightweightSynchronizer : AllStatic {\n+ private:\n+  static ObjectMonitor* get_or_insert_monitor_from_table(oop object, JavaThread* current, bool* inserted);\n+  static ObjectMonitor* get_or_insert_monitor(oop object, JavaThread* current, ObjectSynchronizer::InflateCause cause);\n+\n+  static ObjectMonitor* add_monitor(JavaThread* current, ObjectMonitor* monitor, oop obj);\n+  static bool remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj);\n+\n+  static void deflate_mark_word(oop object);\n+\n+  static void ensure_lock_stack_space(JavaThread* current);\n+\n+  class CacheSetter;\n+  class LockStackInflateContendedLocks;\n+  class VerifyThreadState;\n+\n+ public:\n+  static void initialize();\n+\n+  static bool needs_resize();\n+  static bool resize_table(JavaThread* current);\n+\n+ private:\n+  static inline bool fast_lock_try_enter(oop obj, LockStack& lock_stack, JavaThread* current);\n+  static bool fast_lock_spin_enter(oop obj, LockStack& lock_stack, JavaThread* current, bool observed_deflation);\n+\n+ public:\n+  static void enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread);\n+  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n+  static void exit(oop object, JavaThread* current);\n+\n+  static ObjectMonitor* inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* inflating_thread, Thread* current);\n+  static ObjectMonitor* inflate_locked_or_imse(oop object, ObjectSynchronizer::InflateCause cause, TRAPS);\n+  static ObjectMonitor* inflate_fast_locked_object(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current);\n+  static ObjectMonitor* inflate_and_enter(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current);\n+\n+  static void deflate_monitor(Thread* current, oop obj, ObjectMonitor* monitor);\n+\n+  static ObjectMonitor* get_monitor_from_table(Thread* current, oop obj);\n+\n+  static bool contains_monitor(Thread* current, ObjectMonitor* monitor);\n+\n+  static bool quick_enter(oop obj, BasicLock* Lock, JavaThread* current);\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_LIGHTWEIGHTSYNCHRONIZER_HPP\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/java.hpp\"\n+\n+\/\/ This is in a separate file since it will need to be compiled to two different\n+\/\/ object files, depending on if we are going to build a static or a dynamic\n+\/\/ library.\n+\n+bool is_vm_statically_linked(void) {\n+#ifdef STATIC_BUILD\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n","filename":"src\/hotspot\/share\/runtime\/linkType.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -37,0 +38,1 @@\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -43,0 +45,1 @@\n+#include \"utilities\/sizes.hpp\"\n@@ -117,0 +120,8 @@\n+\n+OMCache::OMCache(JavaThread* jt) : _entries() {\n+  STATIC_ASSERT(std::is_standard_layout<OMCache>::value);\n+  STATIC_ASSERT(std::is_standard_layout<OMCache::OMCacheEntry>::value);\n+  STATIC_ASSERT(offsetof(OMCache, _null_sentinel) == offsetof(OMCache, _entries) +\n+                offsetof(OMCache::OMCacheEntry, _oop) +\n+                OMCache::CAPACITY * in_bytes(oop_to_oop_difference()));\n+}\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class ObjectMonitor;\n@@ -39,0 +40,1 @@\n+class Thread;\n@@ -44,1 +46,1 @@\n-public:\n+ public:\n@@ -46,1 +48,1 @@\n-private:\n+ private:\n@@ -76,1 +78,1 @@\n-public:\n+ public:\n@@ -126,0 +128,25 @@\n+class OMCache {\n+  friend class VMStructs;\n+ public:\n+  static constexpr int CAPACITY = 8;\n+\n+ private:\n+  struct OMCacheEntry {\n+    oop _oop = nullptr;\n+    ObjectMonitor* _monitor = nullptr;\n+  } _entries[CAPACITY];\n+  const oop _null_sentinel = nullptr;\n+\n+ public:\n+  static ByteSize entries_offset() { return byte_offset_of(OMCache, _entries); }\n+  static constexpr ByteSize oop_to_oop_difference() { return in_ByteSize(sizeof(OMCacheEntry)); }\n+  static constexpr ByteSize oop_to_monitor_difference() { return in_ByteSize(sizeof(oop)); }\n+\n+  explicit OMCache(JavaThread* jt);\n+\n+  inline ObjectMonitor* get_monitor(oop o);\n+  inline void set_monitor(ObjectMonitor* monitor);\n+  inline void clear();\n+\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -225,0 +227,50 @@\n+inline void OMCache::set_monitor(ObjectMonitor *monitor) {\n+  const int end = OMCache::CAPACITY - 1;\n+\n+  oop obj = monitor->object_peek();\n+  assert(obj != nullptr, \"must be alive\");\n+  assert(monitor == LightweightSynchronizer::get_monitor_from_table(JavaThread::current(), obj), \"must exist in table\");\n+\n+  OMCacheEntry to_insert = {obj, monitor};\n+\n+  for (int i = 0; i < end; ++i) {\n+    if (_entries[i]._oop == obj ||\n+        _entries[i]._monitor == nullptr ||\n+        _entries[i]._monitor->is_being_async_deflated()) {\n+      \/\/ Use stale slot.\n+      _entries[i] = to_insert;\n+      return;\n+    }\n+    \/\/ Swap with the most recent value.\n+    ::swap(to_insert, _entries[i]);\n+  }\n+  _entries[end] = to_insert;\n+}\n+\n+inline ObjectMonitor* OMCache::get_monitor(oop o) {\n+  for (int i = 0; i < CAPACITY; ++i) {\n+    if (_entries[i]._oop == o) {\n+      assert(_entries[i]._monitor != nullptr, \"monitor must exist\");\n+      if (_entries[i]._monitor->is_being_async_deflated()) {\n+        \/\/ Bad monitor\n+        \/\/ Shift down rest\n+        for (; i < CAPACITY - 1; ++i) {\n+          _entries[i] = _entries[i + 1];\n+        }\n+        \/\/ Clear end\n+        _entries[i] = {};\n+        return nullptr;\n+      }\n+      return _entries[i]._monitor;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+inline void OMCache::clear() {\n+  for (size_t i = 0; i < CAPACITY; ++i) {\n+    \/\/ Clear\n+    _entries[i] = {};\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-  MUTEX_DEFN(JvmtiThreadState_lock           , PaddedMutex  , safepoint);   \/\/ Used by JvmtiThreadState\/JvmtiEventController\n+  MUTEX_DEFN(JvmtiVTMSTransition_lock        , PaddedMonitor, safepoint);   \/\/ used for Virtual Thread Mount State transition management\n@@ -357,1 +357,1 @@\n-  MUTEX_DEFL(JvmtiVTMSTransition_lock        , PaddedMonitor, JvmtiThreadState_lock); \/\/ used for Virtual Thread Mount State transition management\n+  MUTEX_DEFL(JvmtiThreadState_lock          , PaddedMutex  , JvmtiVTMSTransition_lock);   \/\/ Used by JvmtiThreadState\/JvmtiEventController\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -56,0 +57,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -249,1 +251,1 @@\n-  _header(markWord::zero()),\n+  _metadata(0),\n@@ -275,4 +277,0 @@\n-oop ObjectMonitor::object_peek() const {\n-  return _object.peek();\n-}\n-\n@@ -300,0 +298,6 @@\n+#define assert_mark_word_consistency()                                         \\\n+  assert(UseObjectMonitorTable || object()->mark() == markWord::encode(this),  \\\n+         \"object mark must match encoded this: mark=\" INTPTR_FORMAT            \\\n+         \", encoded this=\" INTPTR_FORMAT, object()->mark().value(),            \\\n+         markWord::encode(this).value());\n+\n@@ -303,1 +307,17 @@\n-bool ObjectMonitor::enter_for(JavaThread* locking_thread) {\n+bool ObjectMonitor::enter_is_async_deflating() {\n+  if (is_being_async_deflated()) {\n+    if (!UseObjectMonitorTable) {\n+      const oop l_object = object();\n+      if (l_object != nullptr) {\n+        \/\/ Attempt to restore the header\/dmw to the object's header so that\n+        \/\/ we only retry once if the deflater thread happens to be slow.\n+        install_displaced_markword_in_object(l_object);\n+      }\n+    }\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+void ObjectMonitor::enter_for_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark) {\n@@ -308,0 +328,2 @@\n+  assert(contention_mark._monitor == this, \"must be\");\n+  assert(!is_being_async_deflated(), \"must be\");\n@@ -309,2 +331,2 @@\n-  \/\/ Block out deflation as soon as possible.\n-  add_to_contentions(1);\n+\n+  void* prev_owner = try_set_owner_from(nullptr, locking_thread);\n@@ -313,2 +335,0 @@\n-  if (!is_being_async_deflated()) {\n-    void* prev_owner = try_set_owner_from(nullptr, locking_thread);\n@@ -316,25 +336,12 @@\n-    if (prev_owner == nullptr) {\n-      assert(_recursions == 0, \"invariant\");\n-      success = true;\n-    } else if (prev_owner == locking_thread) {\n-      _recursions++;\n-      success = true;\n-    } else if (prev_owner == DEFLATER_MARKER) {\n-      \/\/ Racing with deflation.\n-      prev_owner = try_set_owner_from(DEFLATER_MARKER, locking_thread);\n-      if (prev_owner == DEFLATER_MARKER) {\n-        \/\/ Cancelled deflation. Increment contentions as part of the deflation protocol.\n-        add_to_contentions(1);\n-        success = true;\n-      } else if (prev_owner == nullptr) {\n-        \/\/ At this point we cannot race with deflation as we have both incremented\n-        \/\/ contentions, seen contention > 0 and seen a DEFLATER_MARKER.\n-        \/\/ success will only be false if this races with something other than\n-        \/\/ deflation.\n-        prev_owner = try_set_owner_from(nullptr, locking_thread);\n-        success = prev_owner == nullptr;\n-      }\n-    } else if (LockingMode == LM_LEGACY && locking_thread->is_lock_owned((address)prev_owner)) {\n-      assert(_recursions == 0, \"must be\");\n-      _recursions = 1;\n-      set_owner_from_BasicLock(prev_owner, locking_thread);\n+  if (prev_owner == nullptr) {\n+    assert(_recursions == 0, \"invariant\");\n+    success = true;\n+  } else if (prev_owner == locking_thread) {\n+    _recursions++;\n+    success = true;\n+  } else if (prev_owner == DEFLATER_MARKER) {\n+    \/\/ Racing with deflation.\n+    prev_owner = try_set_owner_from(DEFLATER_MARKER, locking_thread);\n+    if (prev_owner == DEFLATER_MARKER) {\n+      \/\/ Cancelled deflation. Increment contentions as part of the deflation protocol.\n+      add_to_contentions(1);\n@@ -342,0 +349,7 @@\n+    } else if (prev_owner == nullptr) {\n+      \/\/ At this point we cannot race with deflation as we have both incremented\n+      \/\/ contentions, seen contention > 0 and seen a DEFLATER_MARKER.\n+      \/\/ success will only be false if this races with something other than\n+      \/\/ deflation.\n+      prev_owner = try_set_owner_from(nullptr, locking_thread);\n+      success = prev_owner == nullptr;\n@@ -343,13 +357,5 @@\n-    assert(success, \"Failed to enter_for: locking_thread=\" INTPTR_FORMAT\n-           \", this=\" INTPTR_FORMAT \"{owner=\" INTPTR_FORMAT \"}, observed owner: \" INTPTR_FORMAT,\n-           p2i(locking_thread), p2i(this), p2i(owner_raw()), p2i(prev_owner));\n-  } else {\n-    \/\/ Async deflation is in progress and our contentions increment\n-    \/\/ above lost the race to async deflation. Undo the work and\n-    \/\/ force the caller to retry.\n-    const oop l_object = object();\n-    if (l_object != nullptr) {\n-      \/\/ Attempt to restore the header\/dmw to the object's header so that\n-      \/\/ we only retry once if the deflater thread happens to be slow.\n-      install_displaced_markword_in_object(l_object);\n-    }\n+  } else if (LockingMode == LM_LEGACY && locking_thread->is_lock_owned((address)prev_owner)) {\n+    assert(_recursions == 0, \"must be\");\n+    _recursions = 1;\n+    set_owner_from_BasicLock(prev_owner, locking_thread);\n+    success = true;\n@@ -357,0 +363,6 @@\n+  assert(success, \"Failed to enter_for: locking_thread=\" INTPTR_FORMAT\n+          \", this=\" INTPTR_FORMAT \"{owner=\" INTPTR_FORMAT \"}, observed owner: \" INTPTR_FORMAT,\n+          p2i(locking_thread), p2i(this), p2i(owner_raw()), p2i(prev_owner));\n+}\n+\n+bool ObjectMonitor::enter_for(JavaThread* locking_thread) {\n@@ -358,1 +370,2 @@\n-  add_to_contentions(-1);\n+  \/\/ Block out deflation as soon as possible.\n+  ObjectMonitorContentionMark contention_mark(this);\n@@ -360,1 +373,4 @@\n-  assert(!success || owner_raw() == locking_thread, \"must be\");\n+  \/\/ Check for deflation.\n+  if (enter_is_async_deflating()) {\n+    return false;\n+  }\n@@ -362,1 +378,3 @@\n-  return success;\n+  enter_for_with_contention_mark(locking_thread, contention_mark);\n+  assert(owner_raw() == locking_thread, \"must be\");\n+  return true;\n@@ -365,7 +383,4 @@\n-bool ObjectMonitor::enter(JavaThread* current) {\n-  assert(current == JavaThread::current(), \"must be\");\n-  \/\/ The following code is ordered to check the most common cases first\n-  \/\/ and to reduce RTS->RTO cache line upgrades on SPARC and IA32 processors.\n-\n-  void* cur = try_set_owner_from(nullptr, current);\n-  if (cur == nullptr) {\n+bool ObjectMonitor::try_enter(JavaThread* current) {\n+  \/\/ TryLock avoids the CAS\n+  TryLockResult r = TryLock(current);\n+  if (r == TryLockResult::Success) {\n@@ -376,2 +391,1 @@\n-  if (cur == current) {\n-    \/\/ TODO-FIXME: check for integer overflow!  BUGID 6557169.\n+  if (r == TryLockResult::HasOwner && owner() == current) {\n@@ -382,1 +396,2 @@\n-  if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+  void* cur = owner_raw();\n+  if (LockingMode == LM_LEGACY && current->is_lock_owned((address)cur)) {\n@@ -389,0 +404,16 @@\n+  return false;\n+}\n+\n+bool ObjectMonitor::spin_enter(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  \/\/ Check for recursion.\n+  if (try_enter(current)) {\n+    return true;\n+  }\n+\n+  \/\/ Check for deflation.\n+  if (enter_is_async_deflating()) {\n+    return false;\n+  }\n+\n@@ -391,3 +422,1 @@\n-  \/\/ Try one round of spinning *before* enqueueing current\n-  \/\/ and before going through the awkward and expensive state\n-  \/\/ transitions.  The following spin is strictly optional ...\n+  \/\/ Do one round of spinning.\n@@ -399,4 +428,11 @@\n-    assert(object()->mark() == markWord::encode(this),\n-           \"object mark must match encoded this: mark=\" INTPTR_FORMAT\n-           \", encoded this=\" INTPTR_FORMAT, object()->mark().value(),\n-           markWord::encode(this).value());\n+    assert_mark_word_consistency();\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool ObjectMonitor::enter(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  if (spin_enter(current)) {\n@@ -411,13 +447,5 @@\n-  \/\/ Keep track of contention for JVM\/TI and M&M queries.\n-  add_to_contentions(1);\n-  if (is_being_async_deflated()) {\n-    \/\/ Async deflation is in progress and our contentions increment\n-    \/\/ above lost the race to async deflation. Undo the work and\n-    \/\/ force the caller to retry.\n-    const oop l_object = object();\n-    if (l_object != nullptr) {\n-      \/\/ Attempt to restore the header\/dmw to the object's header so that\n-      \/\/ we only retry once if the deflater thread happens to be slow.\n-      install_displaced_markword_in_object(l_object);\n-    }\n-    add_to_contentions(-1);\n+  \/\/ Keep is_being_async_deflated stable across the rest of enter\n+  ObjectMonitorContentionMark contention_mark(this);\n+\n+  \/\/ Check for deflation.\n+  if (enter_is_async_deflating()) {\n@@ -427,0 +455,11 @@\n+  \/\/ At this point this ObjectMonitor cannot be deflated, finish contended enter\n+  enter_with_contention_mark(current, contention_mark);\n+  return true;\n+}\n+\n+void ObjectMonitor::enter_with_contention_mark(JavaThread *current, ObjectMonitorContentionMark &cm) {\n+  assert(current == JavaThread::current(), \"must be\");\n+  assert(owner_raw() != current, \"must be\");\n+  assert(cm._monitor == this, \"must be\");\n+  assert(!is_being_async_deflated(), \"must be\");\n+\n@@ -483,1 +522,0 @@\n-  add_to_contentions(-1);\n@@ -490,1 +528,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_consistency();\n@@ -519,1 +557,0 @@\n-  return true;\n@@ -552,1 +589,1 @@\n-bool ObjectMonitor::deflate_monitor() {\n+bool ObjectMonitor::deflate_monitor(Thread* current) {\n@@ -623,0 +660,1 @@\n+  }\n@@ -624,0 +662,3 @@\n+  if (UseObjectMonitorTable) {\n+    LightweightSynchronizer::deflate_monitor(current, obj, this);\n+  } else if (obj != nullptr) {\n@@ -639,0 +680,1 @@\n+  assert(!UseObjectMonitorTable, \"ObjectMonitorTable has no dmw\");\n@@ -975,0 +1017,1 @@\n+  assert(current->thread_state() != _thread_blocked, \"invariant\");\n@@ -978,3 +1021,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n-\n-  assert(current->thread_state() != _thread_blocked, \"invariant\");\n+  assert_mark_word_consistency();\n@@ -1045,1 +1086,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_consistency();\n@@ -1671,1 +1712,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_consistency();\n@@ -2188,1 +2229,1 @@\n-\/\/   _header = 0x0000000000000001\n+\/\/   _metadata = 0x0000000000000001\n@@ -2217,1 +2258,1 @@\n-  st->print_cr(\"  _header = \" INTPTR_FORMAT, header().value());\n+  st->print_cr(\"  _metadata = \" INTPTR_FORMAT, _metadata);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":133,"deletions":92,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class ObjectMonitorContentionMark;\n@@ -72,1 +73,1 @@\n-\/\/ - The _header field must be at offset 0 because the displaced header\n+\/\/ - The _metadata field must be at offset 0 because the displaced header\n@@ -78,1 +79,1 @@\n-\/\/ - The _header and _owner fields should be separated by enough space\n+\/\/ - The _metadata and _owner fields should be separated by enough space\n@@ -82,1 +83,1 @@\n-\/\/     _header\n+\/\/     _metadata\n@@ -86,0 +87,1 @@\n+\/\/     <optional padding>\n@@ -109,10 +111,9 @@\n-\/\/   - Separating _owner from the <remaining_fields> by enough space to\n-\/\/     avoid false sharing might be profitable. Given\n-\/\/     http:\/\/blogs.oracle.com\/dave\/entry\/cas_and_cache_trivia_invalidate\n-\/\/     we know that the CAS in monitorenter will invalidate the line\n-\/\/     underlying _owner. We want to avoid an L1 data cache miss on that\n-\/\/     same line for monitorexit. Putting these <remaining_fields>:\n-\/\/     _recursions, _EntryList, _cxq, and _succ, all of which may be\n-\/\/     fetched in the inflated unlock path, on a different cache line\n-\/\/     would make them immune to CAS-based invalidation from the _owner\n-\/\/     field.\n+\/\/ - Separating _owner from the <remaining_fields> by enough space to\n+\/\/   avoid false sharing might be profitable. Given that the CAS in\n+\/\/   monitorenter will invalidate the line underlying _owner. We want\n+\/\/   to avoid an L1 data cache miss on that same line for monitorexit.\n+\/\/   Putting these <remaining_fields>:\n+\/\/   _recursions, _EntryList, _cxq, and _succ, all of which may be\n+\/\/   fetched in the inflated unlock path, on a different cache line\n+\/\/   would make them immune to CAS-based invalidation from the _owner\n+\/\/   field.\n@@ -120,3 +121,3 @@\n-\/\/   - The _recursions field should be of type int, or int32_t but not\n-\/\/     intptr_t. There's no reason to use a 64-bit type for this field\n-\/\/     in a 64-bit JVM.\n+\/\/ - The _recursions field should be of type int, or int32_t but not\n+\/\/   intptr_t. There's no reason to use a 64-bit type for this field\n+\/\/   in a 64-bit JVM.\n@@ -134,3 +135,7 @@\n-  \/\/ The sync code expects the header field to be at offset zero (0).\n-  \/\/ Enforced by the assert() in header_addr().\n-  volatile markWord _header;        \/\/ displaced object header word - mark\n+  \/\/ The sync code expects the metadata field to be at offset zero (0).\n+  \/\/ Enforced by the assert() in metadata_addr().\n+  \/\/ * LM_LIGHTWEIGHT with UseObjectMonitorTable:\n+  \/\/ Contains the _object's hashCode.\n+  \/\/ * LM_LEGACY, LM_MONITOR, LM_LIGHTWEIGHT without UseObjectMonitorTable:\n+  \/\/ Contains the displaced object header word - mark\n+  volatile uintptr_t _metadata;     \/\/ metadata\n@@ -138,2 +143,2 @@\n-  \/\/ Separate _header and _owner on different cache lines since both can\n-  \/\/ have busy multi-threaded access. _header and _object are set at initial\n+  \/\/ Separate _metadata and _owner on different cache lines since both can\n+  \/\/ have busy multi-threaded access. _metadata and _object are set at initial\n@@ -141,2 +146,2 @@\n-  \/\/ its cache line with _header.\n-  DEFINE_PAD_MINUS_SIZE(0, OM_CACHE_LINE_SIZE, sizeof(volatile markWord) +\n+  \/\/ its cache line with _metadata.\n+  DEFINE_PAD_MINUS_SIZE(0, OM_CACHE_LINE_SIZE, sizeof(_metadata) +\n@@ -152,2 +157,3 @@\n-  #define DEFLATER_MARKER reinterpret_cast<void*>(2)\n-public:\n+  static const uintptr_t DEFLATER_MARKER_VALUE = 2;\n+  #define DEFLATER_MARKER reinterpret_cast<void*>(DEFLATER_MARKER_VALUE)\n+ public:\n@@ -157,1 +163,1 @@\n-private:\n+ private:\n@@ -184,1 +190,1 @@\n- protected:\n+\n@@ -187,1 +193,0 @@\n- private:\n@@ -216,0 +221,1 @@\n+  static ByteSize metadata_offset()    { return byte_offset_of(ObjectMonitor, _metadata); }\n@@ -236,3 +242,9 @@\n-  markWord           header() const;\n-  volatile markWord* header_addr();\n-  void               set_header(markWord hdr);\n+  uintptr_t           metadata() const;\n+  void                set_metadata(uintptr_t value);\n+  volatile uintptr_t* metadata_addr();\n+\n+  markWord            header() const;\n+  void                set_header(markWord hdr);\n+\n+  intptr_t            hash() const;\n+  void                set_hash(intptr_t hash);\n@@ -309,0 +321,2 @@\n+  bool      object_is_dead() const;\n+  bool      object_refers_to(oop obj) const;\n@@ -331,0 +345,2 @@\n+\n+  bool      enter_is_async_deflating();\n@@ -332,0 +348,1 @@\n+  void      enter_for_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark);\n@@ -334,0 +351,3 @@\n+  bool      try_enter(JavaThread* current);\n+  bool      spin_enter(JavaThread* current);\n+  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark);\n@@ -367,1 +387,2 @@\n-  bool      deflate_monitor();\n+  bool      deflate_monitor(Thread* current);\n+ private:\n@@ -371,0 +392,14 @@\n+\/\/ RAII object to ensure that ObjectMonitor::is_being_async_deflated() is\n+\/\/ stable within the context of this mark.\n+class ObjectMonitorContentionMark : StackObj {\n+  DEBUG_ONLY(friend class ObjectMonitor;)\n+\n+  ObjectMonitor* _monitor;\n+\n+  NONCOPYABLE(ObjectMonitorContentionMark);\n+\n+ public:\n+  explicit ObjectMonitorContentionMark(ObjectMonitor* monitor);\n+  ~ObjectMonitorContentionMark();\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":67,"deletions":32,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/markWord.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -35,0 +37,2 @@\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -52,2 +56,6 @@\n-inline markWord ObjectMonitor::header() const {\n-  return Atomic::load(&_header);\n+inline uintptr_t ObjectMonitor::metadata() const {\n+  return Atomic::load(&_metadata);\n+}\n+\n+inline void ObjectMonitor::set_metadata(uintptr_t value) {\n+  Atomic::store(&_metadata, value);\n@@ -56,2 +64,9 @@\n-inline volatile markWord* ObjectMonitor::header_addr() {\n-  return &_header;\n+inline volatile uintptr_t* ObjectMonitor::metadata_addr() {\n+  STATIC_ASSERT(std::is_standard_layout<ObjectMonitor>::value);\n+  STATIC_ASSERT(offsetof(ObjectMonitor, _metadata) == 0);\n+  return &_metadata;\n+}\n+\n+inline markWord ObjectMonitor::header() const {\n+  assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use header\");\n+  return markWord(metadata());\n@@ -61,1 +76,12 @@\n-  Atomic::store(&_header, hdr);\n+  assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use header\");\n+  set_metadata(hdr.value());\n+}\n+\n+inline intptr_t ObjectMonitor::hash() const {\n+  assert(UseObjectMonitorTable, \"Only used by lightweight locking with OM table\");\n+  return metadata();\n+}\n+\n+inline void ObjectMonitor::set_hash(intptr_t hash) {\n+  assert(UseObjectMonitorTable, \"Only used by lightweight locking with OM table\");\n+  set_metadata(hash);\n@@ -183,0 +209,27 @@\n+inline ObjectMonitorContentionMark::ObjectMonitorContentionMark(ObjectMonitor* monitor)\n+  : _monitor(monitor) {\n+  _monitor->add_to_contentions(1);\n+}\n+\n+inline ObjectMonitorContentionMark::~ObjectMonitorContentionMark() {\n+  _monitor->add_to_contentions(-1);\n+}\n+\n+inline oop ObjectMonitor::object_peek() const {\n+  if (_object.is_null()) {\n+    return nullptr;\n+  }\n+  return _object.peek();\n+}\n+\n+inline bool ObjectMonitor::object_is_dead() const {\n+  return object_peek() == nullptr;\n+}\n+\n+inline bool ObjectMonitor::object_refers_to(oop obj) const {\n+  if (_object.is_null()) {\n+    return false;\n+  }\n+  return _object.peek() == obj;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":58,"deletions":5,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1019,1 +1019,1 @@\n-                        bool print_ascii, int bytes_per_line, const_address logical_start) {\n+                        bool print_ascii, int bytes_per_line, const_address logical_start, const_address highlight_address) {\n@@ -1024,0 +1024,3 @@\n+  assert(highlight_address == nullptr || (highlight_address >= start && highlight_address < end),\n+         \"address %p to highlight not in range %p - %p\", highlight_address, start, end);\n+\n@@ -1040,1 +1043,5 @@\n-      st->print(PTR_FORMAT \":   \", p2i(logical_p));\n+      \/\/ highlight start of line if address of interest is located in the line\n+      const bool should_highlight = (highlight_address >= p && highlight_address < p + bytes_per_line);\n+      const char* const prefix =\n+        (highlight_address != nullptr) ? (should_highlight ? \"=>\" : \"  \") : \"\";\n+      st->print(\"%s\" PTR_FORMAT \":   \", prefix, p2i(logical_p));\n@@ -1085,1 +1092,1 @@\n-  print_hex_dump(st, pc - 256, pc + 256, unitsize, \/* print_ascii=*\/false);\n+  print_hex_dump(st, pc - 256, pc + 256, unitsize, \/* print_ascii=*\/false, pc);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -860,3 +860,3 @@\n-                             int bytes_per_line, const_address logical_start);\n-  static void print_hex_dump(outputStream* st, const_address start, const_address end, int unitsize, bool print_ascii = true) {\n-    print_hex_dump(st, start, end, unitsize, print_ascii, \/*bytes_per_line=*\/16, \/*logical_start=*\/start);\n+                             int bytes_per_line, const_address logical_start, const_address highlight_address = nullptr);\n+  static void print_hex_dump(outputStream* st, const_address start, const_address end, int unitsize, bool print_ascii = true, const_address highlight_address = nullptr) {\n+    print_hex_dump(st, start, end, unitsize, print_ascii, \/*bytes_per_line=*\/16, \/*logical_start=*\/start, highlight_address);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1007,3 +1007,3 @@\n-          THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),\n-                      vmSymbols::throwable_void_signature(),\n-                      &args);\n+          THROW_ARG_NULL(vmSymbols::java_lang_reflect_InvocationTargetException(),\n+                         vmSymbols::throwable_void_signature(),\n+                         &args);\n@@ -1031,3 +1031,3 @@\n-            THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),\n-              vmSymbols::throwable_void_signature(),\n-              &args);\n+            THROW_ARG_NULL(vmSymbols::java_lang_reflect_InvocationTargetException(),\n+                           vmSymbols::throwable_void_signature(),\n+                           &args);\n@@ -1120,3 +1120,3 @@\n-    THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),\n-                vmSymbols::throwable_void_signature(),\n-                &args);\n+    THROW_ARG_NULL(vmSymbols::java_lang_reflect_InvocationTargetException(),\n+                   vmSymbols::throwable_void_signature(),\n+                   &args);\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -734,0 +734,5 @@\n+\n+  \/\/ The oops in the monitor cache are cleared to prevent stale cache entries\n+  \/\/ from keeping dead objects alive. Because these oops are always cleared\n+  \/\/ before safepoint operations they are not visited in JavaThread::oops_do.\n+  _thread->om_clear_monitor_cache();\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"memory\/universe.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -38,0 +38,3 @@\n+#include \"prims\/jvmtiImpl.hpp\"\n+#include \"prims\/jvmtiTagMap.hpp\"\n+#include \"prims\/resolvedMethodTable.hpp\"\n@@ -43,1 +46,1 @@\n-#include \"runtime\/serviceThread.hpp\"\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -46,3 +49,1 @@\n-#include \"prims\/jvmtiImpl.hpp\"\n-#include \"prims\/jvmtiTagMap.hpp\"\n-#include \"prims\/resolvedMethodTable.hpp\"\n+#include \"runtime\/serviceThread.hpp\"\n@@ -97,0 +98,1 @@\n+    bool object_monitor_table_work = false;\n@@ -124,1 +126,2 @@\n-              (oopmap_cache_work = OopMapCache::has_cleanup_work())\n+              (oopmap_cache_work = OopMapCache::has_cleanup_work()) |\n+              (object_monitor_table_work = LightweightSynchronizer::needs_resize())\n@@ -186,0 +189,4 @@\n+\n+    if (object_monitor_table_work) {\n+      LightweightSynchronizer::resize_table(jt);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -72,1 +73,2 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n+#include \"runtime\/timerTrace.hpp\"\n@@ -79,0 +81,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -89,8 +92,2 @@\n-\/\/ Shared stub locations\n-RuntimeStub*        SharedRuntime::_wrong_method_blob;\n-RuntimeStub*        SharedRuntime::_wrong_method_abstract_blob;\n-RuntimeStub*        SharedRuntime::_ic_miss_blob;\n-RuntimeStub*        SharedRuntime::_resolve_opt_virtual_call_blob;\n-RuntimeStub*        SharedRuntime::_resolve_virtual_call_blob;\n-RuntimeStub*        SharedRuntime::_resolve_static_call_blob;\n-address             SharedRuntime::_resolve_static_call_entry;\n+\/\/ Shared runtime stub routines reside in their own unique blob with a\n+\/\/ single entry point\n@@ -98,4 +95,5 @@\n-DeoptimizationBlob* SharedRuntime::_deopt_blob;\n-SafepointBlob*      SharedRuntime::_polling_page_vectors_safepoint_handler_blob;\n-SafepointBlob*      SharedRuntime::_polling_page_safepoint_handler_blob;\n-SafepointBlob*      SharedRuntime::_polling_page_return_handler_blob;\n+\n+#define SHARED_STUB_FIELD_DEFINE(name, type) \\\n+  type        SharedRuntime::BLOB_FIELD_NAME(name);\n+  SHARED_STUBS_DO(SHARED_STUB_FIELD_DEFINE)\n+#undef SHARED_STUB_FIELD_DEFINE\n@@ -105,0 +103,5 @@\n+#define SHARED_STUB_NAME_DECLARE(name, type) \"Shared Runtime \" # name \"_blob\",\n+const char *SharedRuntime::_stub_names[] = {\n+  SHARED_STUBS_DO(SHARED_STUB_NAME_DECLARE)\n+};\n+\n@@ -106,0 +109,7 @@\n+void SharedRuntime::generate_initial_stubs() {\n+  \/\/ Build this early so it's available for the interpreter.\n+  _throw_StackOverflowError_blob =\n+    generate_throw_exception(SharedStubId::throw_StackOverflowError_id,\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));\n+}\n+\n@@ -107,7 +117,34 @@\n-  _wrong_method_blob                   = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method),          \"wrong_method_stub\");\n-  _wrong_method_abstract_blob          = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_abstract), \"wrong_method_abstract_stub\");\n-  _ic_miss_blob                        = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_ic_miss),  \"ic_miss_stub\");\n-  _resolve_opt_virtual_call_blob       = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_opt_virtual_call_C),   \"resolve_opt_virtual_call\");\n-  _resolve_virtual_call_blob           = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_virtual_call_C),       \"resolve_virtual_call\");\n-  _resolve_static_call_blob            = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_static_call_C),        \"resolve_static_call\");\n-  _resolve_static_call_entry           = _resolve_static_call_blob->entry_point();\n+  _wrong_method_blob =\n+    generate_resolve_blob(SharedStubId::wrong_method_id,\n+                          CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method));\n+  _wrong_method_abstract_blob =\n+    generate_resolve_blob(SharedStubId::wrong_method_abstract_id,\n+                          CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_abstract));\n+  _ic_miss_blob =\n+    generate_resolve_blob(SharedStubId::ic_miss_id,\n+                          CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_ic_miss));\n+  _resolve_opt_virtual_call_blob =\n+    generate_resolve_blob(SharedStubId::resolve_opt_virtual_call_id,\n+                          CAST_FROM_FN_PTR(address, SharedRuntime::resolve_opt_virtual_call_C));\n+  _resolve_virtual_call_blob =\n+    generate_resolve_blob(SharedStubId::resolve_virtual_call_id,\n+                          CAST_FROM_FN_PTR(address, SharedRuntime::resolve_virtual_call_C));\n+  _resolve_static_call_blob =\n+    generate_resolve_blob(SharedStubId::resolve_static_call_id,\n+                          CAST_FROM_FN_PTR(address, SharedRuntime::resolve_static_call_C));\n+\n+  _throw_delayed_StackOverflowError_blob =\n+    generate_throw_exception(SharedStubId::throw_delayed_StackOverflowError_id,\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError));\n+\n+  _throw_AbstractMethodError_blob =\n+    generate_throw_exception(SharedStubId::throw_AbstractMethodError_id,\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));\n+\n+  _throw_IncompatibleClassChangeError_blob =\n+    generate_throw_exception(SharedStubId::throw_IncompatibleClassChangeError_id,\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));\n+\n+  _throw_NullPointerException_at_call_blob =\n+    generate_throw_exception(SharedStubId::throw_NullPointerException_at_call_id,\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));\n@@ -121,1 +158,3 @@\n-    _polling_page_vectors_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_VECTOR_LOOP);\n+    _polling_page_vectors_safepoint_handler_blob =\n+      generate_handler_blob(SharedStubId::polling_page_vectors_safepoint_handler_id,\n+                            CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception));\n@@ -124,2 +163,6 @@\n-  _polling_page_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_LOOP);\n-  _polling_page_return_handler_blob    = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_RETURN);\n+  _polling_page_safepoint_handler_blob =\n+    generate_handler_blob(SharedStubId::polling_page_safepoint_handler_id,\n+                          CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception));\n+  _polling_page_return_handler_blob =\n+    generate_handler_blob(SharedStubId::polling_page_return_handler_id,\n+                          CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception));\n@@ -130,0 +173,13 @@\n+#if INCLUDE_JFR\n+\/\/------------------------------generate jfr runtime stubs ------\n+void SharedRuntime::generate_jfr_stubs() {\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_jfr_stubs\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  _jfr_write_checkpoint_blob = generate_jfr_write_checkpoint();\n+  _jfr_return_lease_blob = generate_jfr_return_lease();\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -868,1 +924,1 @@\n-        return StubRoutines::throw_StackOverflowError_entry();\n+        return SharedRuntime::throw_StackOverflowError_entry();\n@@ -894,1 +950,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -915,1 +971,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -926,1 +982,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -932,1 +988,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -1468,1 +1524,1 @@\n-  address res = StubRoutines::throw_AbstractMethodError_entry();\n+  address res = SharedRuntime::throw_AbstractMethodError_entry();\n@@ -1886,1 +1942,1 @@\n-    if (ObjectSynchronizer::quick_enter(obj, current, lock)) {\n+    if (ObjectSynchronizer::quick_enter(obj, lock, current)) {\n@@ -2388,1 +2444,1 @@\n-                                                                StubRoutines::throw_AbstractMethodError_entry(),\n+                                                                SharedRuntime::throw_AbstractMethodError_entry(),\n@@ -2948,0 +3004,2 @@\n+      } else if (UseObjectMonitorTable) {\n+        buf[i] = (intptr_t)lock->object_monitor_cache();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":89,"deletions":31,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/stubDeclarations.hpp\"\n@@ -45,0 +46,10 @@\n+\/\/ define SharedStubId enum tags: wrong_method_id, etc\n+\n+#define SHARED_STUB_ID_ENUM_DECLARE(name, type) STUB_ID_NAME(name),\n+enum class SharedStubId :int {\n+  NO_STUBID = -1,\n+  SHARED_STUBS_DO(SHARED_STUB_ID_ENUM_DECLARE)\n+  NUM_STUBIDS\n+};\n+#undef SHARED_STUB_ID_ENUM_DECLARE\n+\n@@ -49,15 +60,28 @@\n-  \/\/ Shared stub locations\n-\n-  static RuntimeStub*        _wrong_method_blob;\n-  static RuntimeStub*        _wrong_method_abstract_blob;\n-  static RuntimeStub*        _ic_miss_blob;\n-  static RuntimeStub*        _resolve_opt_virtual_call_blob;\n-  static RuntimeStub*        _resolve_virtual_call_blob;\n-  static RuntimeStub*        _resolve_static_call_blob;\n-  static address             _resolve_static_call_entry;\n-\n-  static DeoptimizationBlob* _deopt_blob;\n-\n-  static SafepointBlob*      _polling_page_vectors_safepoint_handler_blob;\n-  static SafepointBlob*      _polling_page_safepoint_handler_blob;\n-  static SafepointBlob*      _polling_page_return_handler_blob;\n+  \/\/ Declare shared stub fields\n+#define SHARED_STUB_FIELD_DECLARE(name, type) \\\n+  static type        BLOB_FIELD_NAME(name);\n+  SHARED_STUBS_DO(SHARED_STUB_FIELD_DECLARE)\n+#undef SHARED_STUB_FIELD_DECLARE\n+\n+#ifdef ASSERT\n+  static bool is_resolve_id(SharedStubId id) {\n+    return (id == SharedStubId::wrong_method_id ||\n+            id == SharedStubId::wrong_method_abstract_id ||\n+            id == SharedStubId::ic_miss_id ||\n+            id == SharedStubId::resolve_opt_virtual_call_id ||\n+            id == SharedStubId::resolve_virtual_call_id ||\n+            id == SharedStubId::resolve_static_call_id);\n+  }\n+  static bool is_polling_page_id(SharedStubId id) {\n+    return (id == SharedStubId::polling_page_vectors_safepoint_handler_id ||\n+            id == SharedStubId::polling_page_safepoint_handler_id ||\n+            id == SharedStubId::polling_page_return_handler_id);\n+  }\n+  static bool is_throw_id(SharedStubId id) {\n+    return (id == SharedStubId::throw_AbstractMethodError_id ||\n+            id == SharedStubId::throw_IncompatibleClassChangeError_id ||\n+            id == SharedStubId::throw_NullPointerException_at_call_id ||\n+            id == SharedStubId::throw_StackOverflowError_id ||\n+            id == SharedStubId::throw_delayed_StackOverflowError_id);\n+  }\n+#endif\n@@ -65,0 +89,4 @@\n+  \/\/ cont_doYieldStub is not yet folded into the general model for\n+  \/\/ shared stub\/blob handling. It is actually a specially generated\n+  \/\/ native wrapper for a specific native method, as also is it's\n+  \/\/ counterpart the continuation do_enter method.\n@@ -67,0 +95,3 @@\n+  \/\/ Stub names indexed by SharedStubId\n+  static const char *_stub_names[];\n+\n@@ -73,4 +104,3 @@\n-  enum { POLL_AT_RETURN,  POLL_AT_LOOP, POLL_AT_VECTOR_LOOP };\n-  static SafepointBlob* generate_handler_blob(address call_ptr, int poll_type);\n-  static RuntimeStub*   generate_resolve_blob(address destination, const char* name);\n-\n+  static SafepointBlob* generate_handler_blob(SharedStubId id, address call_ptr);\n+  static RuntimeStub*   generate_resolve_blob(SharedStubId id, address destination);\n+  static RuntimeStub*   generate_throw_exception(SharedStubId id, address runtime_entry);\n@@ -78,0 +108,1 @@\n+  static void generate_initial_stubs(void);\n@@ -79,0 +110,14 @@\n+#if INCLUDE_JFR\n+  static void generate_jfr_stubs(void);\n+  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+  \/\/ It returns a jobject handle to the event writer.\n+  \/\/ The handle is dereferenced and the return value is the event writer oop.\n+  static RuntimeStub* generate_jfr_write_checkpoint();\n+  \/\/ For c2: call to runtime to return a buffer lease.\n+  static RuntimeStub* generate_jfr_return_lease();\n+#endif\n+\n+  static const char *stub_name(SharedStubId id) {\n+    assert(id > SharedStubId::NO_STUBID && id < SharedStubId::NUM_STUBIDS, \"stub id out of range\");\n+    return _stub_names[(int)id];\n+  }\n@@ -244,0 +289,12 @@\n+  \/\/ Implicit exceptions\n+  static address throw_AbstractMethodError_entry()          { return _throw_AbstractMethodError_blob->entry_point(); }\n+  static address throw_IncompatibleClassChangeError_entry() { return _throw_IncompatibleClassChangeError_blob->entry_point(); }\n+  static address throw_NullPointerException_at_call_entry() { return _throw_NullPointerException_at_call_blob->entry_point(); }\n+  static address throw_StackOverflowError_entry()           { return _throw_StackOverflowError_blob->entry_point(); }\n+  static address throw_delayed_StackOverflowError_entry()   { return _throw_delayed_StackOverflowError_blob->entry_point(); }\n+\n+#if INCLUDE_JFR\n+  static address jfr_write_checkpoint() { return _jfr_write_checkpoint_blob->entry_point(); }\n+  static address jfr_return_lease()     { return _jfr_return_lease_blob->entry_point(); }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":76,"deletions":19,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -296,0 +296,10 @@\n+  address shadow_zone_growth_watermark() const {\n+    assert(_shadow_zone_growth_watermark != nullptr, \"Don't call this before the field is initialized.\");\n+    return _shadow_zone_growth_watermark;\n+  }\n+\n+  void set_shadow_zone_growth_watermark(address new_watermark) {\n+    assert(_shadow_zone_growth_watermark != nullptr, \"Don't call this before the field is initialized.\");\n+    _shadow_zone_growth_watermark = new_watermark;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/stackOverflow.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_STUBDECLARATIONS_HPP\n+#define SHARE_RUNTIME_STUBDECLARATIONS_HPP\n+\n+#include \"utilities\/macros.hpp\"\n+\n+\/\/ macros for generating definitions and declarations for shared, c1\n+\/\/ and opto blob fields and associated stub ids\n+\n+\/\/ Different shared stubs can have different blob types and may\n+\/\/ include some JFR stubs\n+\/\/\n+\/\/ n.b resolve, handler and throw stubs must remain grouped in the\n+\/\/ same order to allow id values to be range checked\n+\n+#if INCLUDE_JFR\n+\/\/ do_blob(name, type)\n+#define SHARED_JFR_STUBS_DO(do_blob)                                   \\\n+  do_blob(jfr_write_checkpoint, RuntimeStub*)                          \\\n+  do_blob(jfr_return_lease, RuntimeStub*)                              \\\n+\n+#else\n+#define SHARED_JFR_STUBS_DO(do_blob)\n+#endif\n+\n+\/\/ do_blob(name, type)\n+#define SHARED_STUBS_DO(do_blob)                                       \\\n+  do_blob(deopt, DeoptimizationBlob*)                                  \\\n+  \/* resolve stubs *\/                                                  \\\n+  do_blob(wrong_method, RuntimeStub*)                                  \\\n+  do_blob(wrong_method_abstract, RuntimeStub*)                         \\\n+  do_blob(ic_miss, RuntimeStub*)                                       \\\n+  do_blob(resolve_opt_virtual_call, RuntimeStub*)                      \\\n+  do_blob(resolve_virtual_call, RuntimeStub*)                          \\\n+  do_blob(resolve_static_call, RuntimeStub*)                           \\\n+  \/* handler stubs *\/                                                  \\\n+  do_blob(polling_page_vectors_safepoint_handler, SafepointBlob*)      \\\n+  do_blob(polling_page_safepoint_handler, SafepointBlob*)              \\\n+  do_blob(polling_page_return_handler, SafepointBlob*)                 \\\n+  \/* throw stubs *\/                                                    \\\n+  do_blob(throw_AbstractMethodError, RuntimeStub*)                     \\\n+  do_blob(throw_IncompatibleClassChangeError, RuntimeStub*)            \\\n+  do_blob(throw_NullPointerException_at_call, RuntimeStub*)            \\\n+  do_blob(throw_StackOverflowError, RuntimeStub*)                      \\\n+  do_blob(throw_delayed_StackOverflowError, RuntimeStub*)              \\\n+  \/* other stubs *\/                                                    \\\n+  SHARED_JFR_STUBS_DO(do_blob)                                         \\\n+\n+\/\/ generate a stub id enum tag from a name\n+\n+#define STUB_ID_NAME(base) base##_id\n+\n+\/\/ generate a blob id enum tag from a name\n+\n+#define BLOB_ID_NAME(base) base##_id\n+\n+\/\/ generate a blob field name\n+\n+#define BLOB_FIELD_NAME(base) _##base##_blob\n+\n+#endif \/\/ SHARE_RUNTIME_STUBDECLARATIONS_HPP\n+\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -64,5 +64,0 @@\n-address StubRoutines::_throw_AbstractMethodError_entry          = nullptr;\n-address StubRoutines::_throw_IncompatibleClassChangeError_entry = nullptr;\n-address StubRoutines::_throw_NullPointerException_at_call_entry = nullptr;\n-address StubRoutines::_throw_StackOverflowError_entry           = nullptr;\n-address StubRoutines::_throw_delayed_StackOverflowError_entry   = nullptr;\n@@ -194,5 +189,0 @@\n-JFR_ONLY(RuntimeStub* StubRoutines::_jfr_write_checkpoint_stub = nullptr;)\n-JFR_ONLY(address StubRoutines::_jfr_write_checkpoint = nullptr;)\n-JFR_ONLY(RuntimeStub* StubRoutines::_jfr_return_lease_stub = nullptr;)\n-JFR_ONLY(address StubRoutines::_jfr_return_lease = nullptr;)\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,28 @@\n-\/\/ points are defined in the platform-specific inner class.\n+\/\/ points are defined in the platform-specific inner class. Most\n+\/\/ routines have a single (main) entry point. However, a few routines\n+\/\/ do provide alternative entry points.\n+\/\/\n+\/\/ Stub routines whose entries are advertised via class StubRoutines\n+\/\/ are generated in batches at well-defined stages during JVM init:\n+\/\/ initial stubs, continuation stubs, compiler stubs, final stubs.\n+\/\/ Each batch is embedded in a single, associated blob (an instance of\n+\/\/ BufferBlob) i.e. the blob to entry relationship is 1-m.\n+\/\/\n+\/\/ Note that this constrasts with the much smaller number of stub\n+\/\/ routines generated via classes SharedRuntime, c1_Runtime1 and\n+\/\/ OptoRuntime. The latter routines are also generated at well-defined\n+\/\/ points during JVM init. However, each stub routine has its own\n+\/\/ unique blob (various subclasses of RuntimeBlob) i.e. the blob to\n+\/\/ entry relationship is 1-1. The difference arises because\n+\/\/ SharedRuntime routines may need to be relocatable or advertise\n+\/\/ properties such as a frame size via their blob.\n+\/\/\n+\/\/ Staging of stub routine generation is needed in order to manage\n+\/\/ init dependencies between 1) stubs and other stubs or 2) stubs and\n+\/\/ other runtime components. For example, some exception throw stubs\n+\/\/ need to be generated before compiler stubs (such as the\n+\/\/ deoptimization stub) so that the latter can invoke the thrwo rotine\n+\/\/ in bail-out code. Likewise, stubs that access objects (such as the\n+\/\/ object array copy stub) need to be created after initialization of\n+\/\/ some GC constants and generation of the GC barrier stubs they might\n+\/\/ need to invoke.\n@@ -52,2 +79,1 @@\n-\/\/    stubRoutines_<os_family>.cpp       stubGenerator_<arch>.cpp\n-\/\/    stubRoutines_<os_arch>.cpp\n+\/\/                                       stubGenerator_<arch>.cpp\n@@ -78,0 +104,2 @@\n+\/\/ 5. ensure the entry is generated in the right blob to satisfy initialization\n+\/\/    dependencies between it and other stubs or runtime components.\n@@ -140,5 +168,0 @@\n-  static address _throw_AbstractMethodError_entry;\n-  static address _throw_IncompatibleClassChangeError_entry;\n-  static address _throw_NullPointerException_at_call_entry;\n-  static address _throw_StackOverflowError_entry;\n-  static address _throw_delayed_StackOverflowError_entry;\n@@ -272,5 +295,0 @@\n-  JFR_ONLY(static RuntimeStub* _jfr_write_checkpoint_stub;)\n-  JFR_ONLY(static address _jfr_write_checkpoint;)\n-  JFR_ONLY(static RuntimeStub* _jfr_return_lease_stub;)\n-  JFR_ONLY(static address _jfr_return_lease;)\n-\n@@ -332,6 +350,0 @@\n-  \/\/ Implicit exceptions\n-  static address throw_AbstractMethodError_entry()         { return _throw_AbstractMethodError_entry; }\n-  static address throw_IncompatibleClassChangeError_entry(){ return _throw_IncompatibleClassChangeError_entry; }\n-  static address throw_NullPointerException_at_call_entry(){ return _throw_NullPointerException_at_call_entry; }\n-  static address throw_StackOverflowError_entry()          { return _throw_StackOverflowError_entry; }\n-  static address throw_delayed_StackOverflowError_entry()  { return _throw_delayed_StackOverflowError_entry; }\n@@ -490,3 +502,0 @@\n-  JFR_ONLY(static address jfr_write_checkpoint() { return _jfr_write_checkpoint; })\n-  JFR_ONLY(static address jfr_return_lease() { return _jfr_return_lease; })\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":31,"deletions":22,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -44,0 +45,1 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -55,1 +57,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -279,0 +281,4 @@\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LightweightSynchronizer::initialize();\n+  }\n@@ -352,1 +358,5 @@\n-    ObjectMonitor* const mon = mark.monitor();\n+    ObjectMonitor* const mon = read_monitor(current, obj, mark);\n+    if (LockingMode == LM_LIGHTWEIGHT && mon == nullptr) {\n+      \/\/ Racing with inflation\/deflation go slow path\n+      return false;\n+    }\n@@ -379,0 +389,7 @@\n+static bool useHeavyMonitors() {\n+#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64) || defined(S390)\n+  return LockingMode == LM_MONITOR;\n+#else\n+  return false;\n+#endif\n+}\n@@ -386,2 +403,1 @@\n-bool ObjectSynchronizer::quick_enter(oop obj, JavaThread* current,\n-                                     BasicLock * lock) {\n+bool ObjectSynchronizer::quick_enter_legacy(oop obj, BasicLock* lock, JavaThread* current) {\n@@ -389,2 +405,0 @@\n-  NoSafepointVerifier nsv;\n-  if (obj == nullptr) return false;       \/\/ Need to throw NPE\n@@ -392,2 +406,2 @@\n-  if (obj->klass()->is_value_based()) {\n-    return false;\n+  if (useHeavyMonitors()) {\n+    return false;  \/\/ Slow path\n@@ -397,10 +411,1 @@\n-    LockStack& lock_stack = current->lock_stack();\n-    if (lock_stack.is_full()) {\n-      \/\/ Always go into runtime if the lock stack is full.\n-      return false;\n-    }\n-    if (lock_stack.try_recursive_enter(obj)) {\n-      \/\/ Recursive lock successful.\n-      current->inc_held_monitor_count();\n-      return true;\n-    }\n+    return LightweightSynchronizer::quick_enter(obj, lock, current);\n@@ -409,0 +414,2 @@\n+  assert(LockingMode == LM_LEGACY, \"legacy mode below\");\n+\n@@ -412,1 +419,2 @@\n-    ObjectMonitor* const m = mark.monitor();\n+\n+    ObjectMonitor* const m = read_monitor(mark);\n@@ -432,12 +440,10 @@\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ This Java Monitor is inflated so obj's header will never be\n-      \/\/ displaced to this thread's BasicLock. Make the displaced header\n-      \/\/ non-null so this BasicLock is not seen as recursive nor as\n-      \/\/ being locked. We do this unconditionally so that this thread's\n-      \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n-      \/\/ performance reasons, stack walkers generally first check for\n-      \/\/ stack-locking in the object's header, the second check is for\n-      \/\/ recursive stack-locking in the displaced header in the BasicLock,\n-      \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n-      lock->set_displaced_header(markWord::unused_mark());\n-    }\n+    \/\/ This Java Monitor is inflated so obj's header will never be\n+    \/\/ displaced to this thread's BasicLock. Make the displaced header\n+    \/\/ non-null so this BasicLock is not seen as recursive nor as\n+    \/\/ being locked. We do this unconditionally so that this thread's\n+    \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n+    \/\/ performance reasons, stack walkers generally first check for\n+    \/\/ stack-locking in the object's header, the second check is for\n+    \/\/ recursive stack-locking in the displaced header in the BasicLock,\n+    \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n+    lock->set_displaced_header(markWord::unused_mark());\n@@ -511,8 +517,0 @@\n-static bool useHeavyMonitors() {\n-#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64) || defined(S390)\n-  return LockingMode == LM_MONITOR;\n-#else\n-  return false;\n-#endif\n-}\n-\n@@ -527,0 +525,5 @@\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    return LightweightSynchronizer::enter_for(obj, lock, locking_thread);\n+  }\n+\n@@ -543,2 +546,1 @@\n-void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n-  assert(current == Thread::current(), \"must be\");\n+void ObjectSynchronizer::enter_legacy(Handle obj, BasicLock* lock, JavaThread* current) {\n@@ -564,0 +566,1 @@\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"Use LightweightSynchronizer\");\n@@ -572,55 +575,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast-locking does not use the 'lock' argument.\n-      LockStack& lock_stack = locking_thread->lock_stack();\n-      if (lock_stack.is_full()) {\n-        \/\/ We unconditionally make room on the lock stack by inflating\n-        \/\/ the least recently locked object on the lock stack.\n-\n-        \/\/ About the choice to inflate least recently locked object.\n-        \/\/ First we must chose to inflate a lock, either some lock on\n-        \/\/ the lock-stack or the lock that is currently being entered\n-        \/\/ (which may or may not be on the lock-stack).\n-        \/\/ Second the best lock to inflate is a lock which is entered\n-        \/\/ in a control flow where there are only a very few locks being\n-        \/\/ used, as the costly part of inflated locking is inflation,\n-        \/\/ not locking. But this property is entirely program dependent.\n-        \/\/ Third inflating the lock currently being entered on when it\n-        \/\/ is not present on the lock-stack will result in a still full\n-        \/\/ lock-stack. This creates a scenario where every deeper nested\n-        \/\/ monitorenter must call into the runtime.\n-        \/\/ The rational here is as follows:\n-        \/\/ Because we cannot (currently) figure out the second, and want\n-        \/\/ to avoid the third, we inflate a lock on the lock-stack.\n-        \/\/ The least recently locked lock is chosen as it is the lock\n-        \/\/ with the longest critical section.\n-\n-        log_info(monitorinflation)(\"LockStack capacity exceeded, inflating.\");\n-        ObjectMonitor* monitor = inflate_for(locking_thread, lock_stack.bottom(), inflate_cause_vm_internal);\n-        assert(monitor->owner() == locking_thread, \"must be owner=\" PTR_FORMAT \" locking_thread=\" PTR_FORMAT \" mark=\" PTR_FORMAT,\n-               p2i(monitor->owner()), p2i(locking_thread), monitor->object()->mark_acquire().value());\n-        assert(!lock_stack.is_full(), \"must have made room here\");\n-      }\n-\n-      markWord mark = obj()->mark_acquire();\n-      while (mark.is_unlocked()) {\n-        \/\/ Retry until a lock state change has been observed. cas_set_mark() may collide with non lock bits modifications.\n-        \/\/ Try to swing into 'fast-locked' state.\n-        assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n-        const markWord locked_mark = mark.set_fast_locked();\n-        const markWord old_mark = obj()->cas_set_mark(locked_mark, mark);\n-        if (old_mark == mark) {\n-          \/\/ Successfully fast-locked, push object to lock-stack and return.\n-          lock_stack.push(obj());\n-          return true;\n-        }\n-        mark = old_mark;\n-      }\n-\n-      if (mark.is_fast_locked() && lock_stack.try_recursive_enter(obj())) {\n-        \/\/ Recursive lock successful.\n-        return true;\n-      }\n-\n-      \/\/ Failed to fast lock.\n-      return false;\n-    } else if (LockingMode == LM_LEGACY) {\n+    if (LockingMode == LM_LEGACY) {\n@@ -659,2 +608,2 @@\n-void ObjectSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n-  current->dec_held_monitor_count();\n+void ObjectSynchronizer::exit_legacy(oop object, BasicLock* lock, JavaThread* current) {\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"Use LightweightSynchronizer\");\n@@ -664,26 +613,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast-locking does not use the 'lock' argument.\n-      LockStack& lock_stack = current->lock_stack();\n-      if (mark.is_fast_locked() && lock_stack.try_recursive_exit(object)) {\n-        \/\/ Recursively unlocked.\n-        return;\n-      }\n-\n-      if (mark.is_fast_locked() && lock_stack.is_recursive(object)) {\n-        \/\/ This lock is recursive but is not at the top of the lock stack so we're\n-        \/\/ doing an unbalanced exit. We have to fall thru to inflation below and\n-        \/\/ let ObjectMonitor::exit() do the unlock.\n-      } else {\n-        while (mark.is_fast_locked()) {\n-          \/\/ Retry until a lock state change has been observed. cas_set_mark() may collide with non lock bits modifications.\n-          const markWord unlocked_mark = mark.set_unlocked();\n-          const markWord old_mark = object->cas_set_mark(unlocked_mark, mark);\n-          if (old_mark == mark) {\n-            size_t recursions = lock_stack.remove(object) - 1;\n-            assert(recursions == 0, \"must not be recursive here\");\n-            return;\n-          }\n-          mark = old_mark;\n-        }\n-      }\n-    } else if (LockingMode == LM_LEGACY) {\n+    if (LockingMode == LM_LEGACY) {\n@@ -711,1 +635,1 @@\n-            ObjectMonitor* m = mark.monitor();\n+            ObjectMonitor* m = read_monitor(mark);\n@@ -755,2 +679,10 @@\n-    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_jni_enter);\n-    if (monitor->enter(current)) {\n+    ObjectMonitor* monitor;\n+    bool entered;\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      entered = LightweightSynchronizer::inflate_and_enter(obj(), inflate_cause_jni_enter, current, current) != nullptr;\n+    } else {\n+      monitor = inflate(current, obj(), inflate_cause_jni_enter);\n+      entered = monitor->enter(current);\n+    }\n+\n+    if (entered) {\n@@ -768,3 +700,8 @@\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n-  ObjectMonitor* monitor = inflate(current, obj, inflate_cause_jni_exit);\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj, inflate_cause_jni_exit, CHECK);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+    \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n+    monitor = inflate(current, obj, inflate_cause_jni_exit);\n+  }\n@@ -803,0 +740,1 @@\n+\n@@ -808,4 +746,10 @@\n-  \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n-  \/\/ field is incremented before ownership is dropped and decremented\n-  \/\/ after ownership is regained.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_wait);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK_0);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n+    \/\/ field is incremented before ownership is dropped and decremented\n+    \/\/ after ownership is regained.\n+    monitor = inflate(current, obj(), inflate_cause_wait);\n+  }\n@@ -828,3 +772,8 @@\n-  ObjectSynchronizer::inflate(THREAD,\n-                              obj(),\n-                              inflate_cause_wait)->wait(millis, false, THREAD);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK);\n+  } else {\n+    monitor = inflate(THREAD, obj(), inflate_cause_wait);\n+  }\n+  monitor->wait(millis, false, THREAD);\n@@ -849,3 +798,9 @@\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped by the calling thread.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_notify);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+    \/\/ dropped by the calling thread.\n+    monitor = inflate(current, obj(), inflate_cause_notify);\n+  }\n@@ -871,3 +826,9 @@\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped by the calling thread.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_notify);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+    \/\/ dropped by the calling thread.\n+    monitor = inflate(current, obj(), inflate_cause_notify);\n+  }\n@@ -971,1 +932,1 @@\n-static inline intptr_t get_next_hash(Thread* current, oop obj) {\n+static intptr_t get_next_hash(Thread* current, oop obj) {\n@@ -1011,0 +972,21 @@\n+static intptr_t install_hash_code(Thread* current, oop obj) {\n+  assert(UseObjectMonitorTable && LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+\n+  markWord mark = obj->mark_acquire();\n+  for (;;) {\n+    intptr_t hash = mark.hash();\n+    if (hash != 0) {\n+      return hash;\n+    }\n+\n+    hash = get_next_hash(current, obj);\n+    const markWord old_mark = mark;\n+    const markWord new_mark = old_mark.copy_set_hash(hash);\n+\n+    mark = obj->cas_set_mark(new_mark, old_mark);\n+    if (old_mark == mark) {\n+      return hash;\n+    }\n+  }\n+}\n+\n@@ -1012,0 +994,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Since the monitor isn't in the object header, the hash can simply be\n+    \/\/ installed in the object header.\n+    return install_hash_code(current, obj);\n+  }\n@@ -1105,1 +1092,1 @@\n-      uintptr_t v = Atomic::cmpxchg((volatile uintptr_t*)monitor->header_addr(), mark.value(), temp.value());\n+      uintptr_t v = Atomic::cmpxchg(monitor->metadata_addr(), mark.value(), temp.value());\n@@ -1117,1 +1104,1 @@\n-      if (monitor->is_being_async_deflated()) {\n+      if (monitor->is_being_async_deflated() && !UseObjectMonitorTable) {\n@@ -1148,1 +1135,15 @@\n-  if (mark.has_monitor()) {\n+  while (LockingMode == LM_LIGHTWEIGHT && mark.has_monitor()) {\n+    ObjectMonitor* monitor = read_monitor(current, obj, mark);\n+    if (monitor != nullptr) {\n+      return monitor->is_entered(current) != 0;\n+    }\n+    \/\/ Racing with inflation\/deflation, retry\n+    mark = obj->mark_acquire();\n+\n+    if (mark.is_fast_locked()) {\n+      \/\/ Some other thread fast_locked, current could not have held the lock\n+      return false;\n+    }\n+  }\n+\n+  if (LockingMode != LM_LIGHTWEIGHT && mark.has_monitor()) {\n@@ -1152,1 +1153,1 @@\n-    ObjectMonitor* monitor = mark.monitor();\n+    ObjectMonitor* monitor = read_monitor(mark);\n@@ -1176,1 +1177,15 @@\n-  if (mark.has_monitor()) {\n+  while (LockingMode == LM_LIGHTWEIGHT && mark.has_monitor()) {\n+    ObjectMonitor* monitor = read_monitor(Thread::current(), obj, mark);\n+    if (monitor != nullptr) {\n+      return Threads::owning_thread_from_monitor(t_list, monitor);\n+    }\n+    \/\/ Racing with inflation\/deflation, retry\n+    mark = obj->mark_acquire();\n+\n+    if (mark.is_fast_locked()) {\n+      \/\/ Some other thread fast_locked\n+      return Threads::owning_thread_from_object(t_list, h_obj());\n+    }\n+  }\n+\n+  if (LockingMode != LM_LIGHTWEIGHT && mark.has_monitor()) {\n@@ -1180,1 +1195,1 @@\n-    ObjectMonitor* monitor = mark.monitor();\n+    ObjectMonitor* monitor = read_monitor(mark);\n@@ -1392,0 +1407,1 @@\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"only inflate through enter\");\n@@ -1394,1 +1410,1 @@\n-    ObjectMonitor* monitor = mark.monitor();\n+    ObjectMonitor* monitor = read_monitor(mark);\n@@ -1404,4 +1420,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT && current->is_Java_thread()) {\n-    return inflate_impl(JavaThread::cast(current), obj, cause);\n-  }\n-  return inflate_impl(nullptr, obj, cause);\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"only inflate through enter\");\n+  return inflate_impl(obj, cause);\n@@ -1412,12 +1426,6 @@\n-  return inflate_impl(thread, obj, cause);\n-}\n-\n-ObjectMonitor* ObjectSynchronizer::inflate_impl(JavaThread* inflating_thread, oop object, const InflateCause cause) {\n-  \/\/ The JavaThread* inflating_thread parameter is only used by LM_LIGHTWEIGHT and requires\n-  \/\/ that the inflating_thread == Thread::current() or is suspended throughout the call by\n-  \/\/ some other mechanism.\n-  \/\/ Even with LM_LIGHTWEIGHT the thread might be nullptr when called from a non\n-  \/\/ JavaThread. (As may still be the case from FastHashCode). However it is only\n-  \/\/ important for the correctness of the LM_LIGHTWEIGHT algorithm that the thread\n-  \/\/ is set when called from ObjectSynchronizer::enter from the owning thread,\n-  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"LM_LIGHTWEIGHT cannot use inflate_for\");\n+  return inflate_impl(obj, cause);\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::inflate_impl(oop object, const InflateCause cause) {\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"LM_LIGHTWEIGHT cannot use inflate_impl\");\n@@ -1430,7 +1438,1 @@\n-    \/\/ *  inflated     - Just return if using stack-locking.\n-    \/\/                   If using fast-locking and the ObjectMonitor owner\n-    \/\/                   is anonymous and the inflating_thread owns the\n-    \/\/                   object lock, then we make the inflating_thread\n-    \/\/                   the ObjectMonitor owner and remove the lock from\n-    \/\/                   the inflating_thread's lock stack.\n-    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  inflated     - Just return it.\n@@ -1447,6 +1449,0 @@\n-      if (LockingMode == LM_LIGHTWEIGHT && inf->is_owner_anonymous() &&\n-          inflating_thread != nullptr && inflating_thread->lock_stack().contains(object)) {\n-        inf->set_owner_from_anonymous(inflating_thread);\n-        size_t removed = inflating_thread->lock_stack().remove(object);\n-        inf->set_recursions(removed - 1);\n-      }\n@@ -1456,65 +1452,9 @@\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ New lightweight locking does not use INFLATING.\n-      \/\/ CASE: inflation in progress - inflating over a stack-lock.\n-      \/\/ Some other thread is converting from stack-locked to inflated.\n-      \/\/ Only that thread can complete inflation -- other threads must wait.\n-      \/\/ The INFLATING value is transient.\n-      \/\/ Currently, we spin\/yield\/park and poll the markword, waiting for inflation to finish.\n-      \/\/ We could always eliminate polling by parking the thread on some auxiliary list.\n-      if (mark == markWord::INFLATING()) {\n-        read_stable_mark(object);\n-        continue;\n-      }\n-    }\n-\n-    \/\/ CASE: fast-locked\n-    \/\/ Could be fast-locked either by the inflating_thread or by some other thread.\n-    \/\/\n-    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_\n-    \/\/ attempting to set the object's mark to the new ObjectMonitor. If\n-    \/\/ the inflating_thread owns the monitor, then we set the ObjectMonitor's\n-    \/\/ owner to the inflating_thread. Otherwise, we set the ObjectMonitor's owner\n-    \/\/ to anonymous. If we lose the race to set the object's mark to the\n-    \/\/ new ObjectMonitor, then we just delete it and loop around again.\n-    \/\/\n-    LogStreamHandle(Trace, monitorinflation) lsh;\n-    if (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked()) {\n-      ObjectMonitor* monitor = new ObjectMonitor(object);\n-      monitor->set_header(mark.set_unlocked());\n-      bool own = inflating_thread != nullptr && inflating_thread->lock_stack().contains(object);\n-      if (own) {\n-        \/\/ Owned by inflating_thread.\n-        monitor->set_owner_from(nullptr, inflating_thread);\n-      } else {\n-        \/\/ Owned by somebody else.\n-        monitor->set_owner_anonymous();\n-      }\n-      markWord monitor_mark = markWord::encode(monitor);\n-      markWord old_mark = object->cas_set_mark(monitor_mark, mark);\n-      if (old_mark == mark) {\n-        \/\/ Success! Return inflated monitor.\n-        if (own) {\n-          size_t removed = inflating_thread->lock_stack().remove(object);\n-          monitor->set_recursions(removed - 1);\n-        }\n-        \/\/ Once the ObjectMonitor is configured and object is associated\n-        \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n-        _in_use_list.add(monitor);\n-\n-        \/\/ Hopefully the performance counters are allocated on distinct\n-        \/\/ cache lines to avoid false sharing on MP systems ...\n-        OM_PERFDATA_OP(Inflations, inc());\n-        if (log_is_enabled(Trace, monitorinflation)) {\n-          ResourceMark rm;\n-          lsh.print_cr(\"inflate(has_locker): object=\" INTPTR_FORMAT \", mark=\"\n-                       INTPTR_FORMAT \", type='%s'\", p2i(object),\n-                       object->mark().value(), object->klass()->external_name());\n-        }\n-        if (event.should_commit()) {\n-          post_monitor_inflate_event(&event, object, cause);\n-        }\n-        return monitor;\n-      } else {\n-        delete monitor;\n-        continue;  \/\/ Interference -- just retry\n-      }\n+    \/\/ CASE: inflation in progress - inflating over a stack-lock.\n+    \/\/ Some other thread is converting from stack-locked to inflated.\n+    \/\/ Only that thread can complete inflation -- other threads must wait.\n+    \/\/ The INFLATING value is transient.\n+    \/\/ Currently, we spin\/yield\/park and poll the markword, waiting for inflation to finish.\n+    \/\/ We could always eliminate polling by parking the thread on some auxiliary list.\n+    if (mark == markWord::INFLATING()) {\n+      read_stable_mark(object);\n+      continue;\n@@ -1534,0 +1474,1 @@\n+    LogStreamHandle(Trace, monitorinflation) lsh;\n@@ -1535,1 +1476,0 @@\n-      assert(LockingMode != LM_LIGHTWEIGHT, \"cannot happen with new lightweight locking\");\n@@ -1667,0 +1607,1 @@\n+  Thread* current = Thread::current();\n@@ -1673,1 +1614,1 @@\n-    if (mid->deflate_monitor()) {\n+    if (mid->deflate_monitor(current)) {\n@@ -1691,0 +1632,5 @@\n+    if (thread->is_Java_thread()) {\n+      \/\/ Clear OM cache\n+      JavaThread* jt = JavaThread::cast(thread);\n+      jt->om_clear_monitor_cache();\n+    }\n@@ -1837,0 +1783,8 @@\n+#ifdef ASSERT\n+    if (UseObjectMonitorTable) {\n+      for (ObjectMonitor* monitor : delete_list) {\n+        assert(!LightweightSynchronizer::contains_monitor(current, monitor), \"Should have been removed\");\n+      }\n+    }\n+#endif\n+\n@@ -2045,1 +1999,2 @@\n-  if (n->header().value() == 0) {\n+\n+  if (n->metadata() == 0) {\n@@ -2047,1 +2002,1 @@\n-                  \"have non-null _header field.\", p2i(n));\n+                  \"have non-null _metadata (header\/hash) field.\", p2i(n));\n@@ -2050,0 +2005,1 @@\n+\n@@ -2051,17 +2007,21 @@\n-  if (obj != nullptr) {\n-    const markWord mark = obj->mark();\n-    if (!mark.has_monitor()) {\n-      out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n-                    \"object does not think it has a monitor: obj=\"\n-                    INTPTR_FORMAT \", mark=\" INTPTR_FORMAT, p2i(n),\n-                    p2i(obj), mark.value());\n-      *error_cnt_p = *error_cnt_p + 1;\n-    }\n-    ObjectMonitor* const obj_mon = mark.monitor();\n-    if (n != obj_mon) {\n-      out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n-                    \"object does not refer to the same monitor: obj=\"\n-                    INTPTR_FORMAT \", mark=\" INTPTR_FORMAT \", obj_mon=\"\n-                    INTPTR_FORMAT, p2i(n), p2i(obj), mark.value(), p2i(obj_mon));\n-      *error_cnt_p = *error_cnt_p + 1;\n-    }\n+  if (obj == nullptr) {\n+    return;\n+  }\n+\n+  const markWord mark = obj->mark();\n+  if (!mark.has_monitor()) {\n+    out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n+                  \"object does not think it has a monitor: obj=\"\n+                  INTPTR_FORMAT \", mark=\" INTPTR_FORMAT, p2i(n),\n+                  p2i(obj), mark.value());\n+    *error_cnt_p = *error_cnt_p + 1;\n+    return;\n+  }\n+\n+  ObjectMonitor* const obj_mon = read_monitor(Thread::current(), obj, mark);\n+  if (n != obj_mon) {\n+    out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n+                  \"object does not refer to the same monitor: obj=\"\n+                  INTPTR_FORMAT \", mark=\" INTPTR_FORMAT \", obj_mon=\"\n+                  INTPTR_FORMAT, p2i(n), p2i(obj), mark.value(), p2i(obj_mon));\n+    *error_cnt_p = *error_cnt_p + 1;\n@@ -2090,1 +2050,1 @@\n-        const markWord mark = monitor->header();\n+        const intptr_t hash = UseObjectMonitorTable ? monitor->hash() : monitor->header().hash();\n@@ -2093,1 +2053,1 @@\n-                   monitor->is_busy(), mark.hash() != 0, monitor->owner() != nullptr,\n+                   monitor->is_busy(), hash != 0, monitor->owner() != nullptr,\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":228,"deletions":268,"binary":false,"changes":496,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -96,2 +97,3 @@\n-  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n-  static void exit(oop obj, BasicLock* lock, JavaThread* current);\n+  static inline void enter(Handle obj, BasicLock* lock, JavaThread* current);\n+  static inline void exit(oop obj, BasicLock* lock, JavaThread* current);\n+\n@@ -109,0 +111,3 @@\n+  static bool quick_enter_legacy(oop obj, BasicLock* Lock, JavaThread* current);\n+  static void enter_legacy(Handle obj, BasicLock* Lock, JavaThread* current);\n+  static void exit_legacy(oop obj, BasicLock* lock, JavaThread* current);\n@@ -121,1 +126,1 @@\n-  static bool quick_enter(oop obj, JavaThread* current, BasicLock* Lock);\n+  static inline bool quick_enter(oop obj, BasicLock* Lock, JavaThread* current);\n@@ -135,1 +140,1 @@\n-  static ObjectMonitor* inflate_impl(JavaThread* thread, oop obj, const InflateCause cause);\n+  static ObjectMonitor* inflate_impl(oop obj, const InflateCause cause);\n@@ -142,0 +147,3 @@\n+  inline static ObjectMonitor* read_monitor(markWord mark);\n+  inline static ObjectMonitor* read_monitor(Thread* current, oop obj, markWord mark);\n+\n@@ -203,0 +211,1 @@\n+  friend class LightweightSynchronizer;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_SYNCHRONIZER_INLINE_HPP\n+#define SHARE_RUNTIME_SYNCHRONIZER_INLINE_HPP\n+\n+#include \"runtime\/synchronizer.hpp\"\n+\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+\n+inline ObjectMonitor* ObjectSynchronizer::read_monitor(markWord mark) {\n+  return mark.monitor();\n+}\n+\n+inline ObjectMonitor* ObjectSynchronizer::read_monitor(Thread* current, oop obj, markWord mark) {\n+  if (!UseObjectMonitorTable) {\n+    return read_monitor(mark);\n+  } else {\n+    return LightweightSynchronizer::get_monitor_from_table(current, obj);\n+  }\n+}\n+\n+inline void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n+  assert(current == Thread::current(), \"must be\");\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LightweightSynchronizer::enter(obj, lock, current);\n+  } else {\n+    enter_legacy(obj, lock, current);\n+  }\n+}\n+\n+inline bool ObjectSynchronizer::quick_enter(oop obj, BasicLock* lock, JavaThread* current) {\n+  assert(current->thread_state() == _thread_in_Java, \"invariant\");\n+  NoSafepointVerifier nsv;\n+  if (obj == nullptr) return false;       \/\/ Need to throw NPE\n+\n+  if (obj->klass()->is_value_based()) {\n+    return false;\n+  }\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    return LightweightSynchronizer::quick_enter(obj, lock, current);\n+  } else {\n+    return quick_enter_legacy(obj, lock, current);\n+  }\n+}\n+\n+inline void ObjectSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n+  current->dec_held_monitor_count();\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LightweightSynchronizer::exit(object, current);\n+  } else {\n+    exit_legacy(object, lock, current);\n+  }\n+}\n+\n+#endif \/\/ SHARE_RUNTIME_SYNCHRONIZER_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -987,0 +987,1 @@\n+  if (version == JNI_VERSION_24) return JNI_TRUE;\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -250,3 +250,6 @@\n-          if (mark.has_monitor() &&\n-              ( \/\/ we have marked ourself as pending on this monitor\n-                mark.monitor() == thread()->current_pending_monitor() ||\n+          if (mark.has_monitor()) {\n+            ObjectMonitor* mon = ObjectSynchronizer::read_monitor(current, monitor->owner(), mark);\n+            if (\/\/ if the monitor is null we must be in the process of locking\n+                mon == nullptr ||\n+                \/\/ we have marked ourself as pending on this monitor\n+                mon == thread()->current_pending_monitor() ||\n@@ -254,3 +257,3 @@\n-                !mark.monitor()->is_entered(thread())\n-              )) {\n-            lock_state = \"waiting to lock\";\n+                !mon->is_entered(thread())) {\n+              lock_state = \"waiting to lock\";\n+            }\n@@ -622,1 +625,1 @@\n-  if (WizardMode) _fr.print_value_on(output, nullptr);\n+  if (WizardMode) _fr.print_value_on(output);\n@@ -737,1 +740,1 @@\n-  _fr.print_value_on(output, nullptr);\n+  _fr.print_value_on(output);\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -90,1 +90,2 @@\n-  template(JFRCheckpoint)                         \\\n+  template(JFRSafepointClear)                     \\\n+  template(JFRSafepointWrite)                     \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -249,1 +249,0 @@\n-  nonstatic_field(InstanceKlass,               _is_marked_dependent,                          bool)                                  \\\n@@ -567,0 +566,6 @@\n+  \/*****************************************************\/                                                                            \\\n+  \/* UpcallStubs (NOTE: incomplete, but only a little) *\/                                                                            \\\n+  \/*****************************************************\/                                                                            \\\n+                                                                                                                                     \\\n+  nonstatic_field(UpcallStub,                  _frame_data_offset,                            ByteSize)                              \\\n+                                                                                                                                     \\\n@@ -781,1 +786,1 @@\n-  volatile_nonstatic_field(ObjectMonitor,      _header,                                       markWord)                              \\\n+  volatile_nonstatic_field(ObjectMonitor,      _metadata,                                     uintptr_t)                             \\\n@@ -785,1 +790,1 @@\n-  volatile_nonstatic_field(BasicLock,          _displaced_header,                             markWord)                              \\\n+  volatile_nonstatic_field(BasicLock,          _metadata,                                     uintptr_t)                             \\\n@@ -1016,1 +1021,3 @@\n-  nonstatic_field(InvocationCounter,           _counter,                                      unsigned int)\n+  nonstatic_field(InvocationCounter,           _counter,                                      unsigned int)                          \\\n+                                                                                                                                     \\\n+  nonstatic_field(UpcallStub::FrameData,       jfa,                                           JavaFrameAnchor)\n@@ -1310,0 +1317,1 @@\n+  declare_type(UpcallStub,               RuntimeBlob)                     \\\n@@ -1904,0 +1912,1 @@\n+  declare_integer_type(ByteSize)                                          \\\n@@ -1952,0 +1961,1 @@\n+  declare_toplevel_type(UpcallStub::FrameData)                            \\\n@@ -2019,2 +2029,0 @@\n-  declare_constant(JVM_ACC_HAS_FINALIZER)                                 \\\n-  declare_constant(JVM_ACC_IS_CLONEABLE_FAST)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,0 +131,16 @@\n+bool ClassLoadingService::get_verbose() {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n+    \/\/ set_verbose looks for a non-exact match for class+load,\n+    \/\/ so look for all tag sets that match class+load*\n+    if (ts->contains(LogTag::_class) &&\n+        ts->contains(LogTag::_load)) {\n+      LogLevelType l = ts->level_for(LogConfiguration::StdoutLog);\n+      if (l != LogLevel::Info && l != LogLevel::Debug && l != LogLevel::Trace) {\n+        return false;\n+      }\n+    }\n+  }\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/classLoadingService.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+  static bool get_verbose() NOT_MANAGEMENT_RETURN_(false);\n@@ -66,1 +67,0 @@\n-  static bool get_verbose() { return log_is_enabled(Info, class, load); }\n","filename":"src\/hotspot\/share\/services\/classLoadingService.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    const int length = java_lang_String::utf8_length(string, value);\n+    const size_t length = java_lang_String::utf8_length(string, value);\n","filename":"src\/hotspot\/share\/services\/finalizerService.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -205,0 +205,15 @@\n+bool MemoryService::get_verbose() {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n+    \/\/ set_verbose only sets gc and not gc*, so check for an exact match\n+    const bool is_gc_exact_match = ts->contains(LogTag::_gc) && ts->ntags() == 1;\n+    if (is_gc_exact_match) {\n+      LogLevelType l = ts->level_for(LogConfiguration::StdoutLog);\n+      if (l == LogLevel::Info || l == LogLevel::Debug || l == LogLevel::Trace) {\n+        return true;\n+      }\n+    }\n+  }\n+\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/memoryService.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,0 @@\n-  static bool get_verbose() { return log_is_enabled(Info, gc); }\n@@ -111,0 +110,1 @@\n+  static bool get_verbose();\n","filename":"src\/hotspot\/share\/services\/memoryService.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,3 +43,0 @@\n-  \/\/ HotSpot-specific access flags\n-  \/\/ These Klass flags should be migrated, to a field such as InstanceKlass::_misc_flags,\n-  \/\/ or to a similar flags field in Klass itself.\n@@ -47,4 +44,0 @@\n-  JVM_ACC_HAS_FINALIZER           = 0x40000000,     \/\/ True if klass has a non-empty finalize() method\n-  JVM_ACC_IS_CLONEABLE_FAST       = (int)0x80000000,\/\/ True if klass implements the Cloneable interface and can be optimized in generated code\n-  JVM_ACC_IS_HIDDEN_CLASS         = 0x04000000,     \/\/ True if klass is hidden\n-  JVM_ACC_IS_VALUE_BASED_CLASS    = 0x08000000,     \/\/ True if klass is marked as a ValueBased class\n@@ -80,6 +73,0 @@\n-  \/\/ Klass* flags\n-  bool has_finalizer           () const { return (_flags & JVM_ACC_HAS_FINALIZER          ) != 0; }\n-  bool is_cloneable_fast       () const { return (_flags & JVM_ACC_IS_CLONEABLE_FAST      ) != 0; }\n-  bool is_hidden_class         () const { return (_flags & JVM_ACC_IS_HIDDEN_CLASS        ) != 0; }\n-  bool is_value_based_class    () const { return (_flags & JVM_ACC_IS_VALUE_BASED_CLASS   ) != 0; }\n-\n@@ -105,7 +92,0 @@\n-  \/\/ Klass* flags\n-  \/\/ These are set at classfile parsing time so do not require atomic access.\n-  void set_has_finalizer()             { _flags |= JVM_ACC_HAS_FINALIZER; }\n-  void set_is_cloneable_fast()         { _flags |= JVM_ACC_IS_CLONEABLE_FAST; }\n-  void set_is_hidden_class()           { _flags |= JVM_ACC_IS_HIDDEN_CLASS; }\n-  void set_is_value_based_class()      { _flags |= JVM_ACC_IS_VALUE_BASED_CLASS; }\n-\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -786,0 +786,4 @@\n+#define HOTSPOT_JNI_GETSTRINGUTFLENGTHASLONG_ENTRY(arg0, arg1)\n+#define HOTSPOT_JNI_GETSTRINGUTFLENGTHASLONG_ENTRY_ENABLED()  0\n+#define HOTSPOT_JNI_GETSTRINGUTFLENGTHASLONG_RETURN(arg0)\n+#define HOTSPOT_JNI_GETSTRINGUTFLENGTHASLONG_RETURN_ENABLED()  0\n","filename":"src\/hotspot\/share\/utilities\/dtrace_disabled.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -154,1 +154,3 @@\n-void ExceptionsEventLog::log(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {\n+void ExceptionsEventLog::log(Thread* thread, Handle h_exception,\n+                             const char* message, const char* file, int line,\n+                             int message_length_limit) {\n@@ -166,1 +168,5 @@\n-  st.print(\"%s%s> (\" PTR_FORMAT \") \\n\"\n+  if (message != nullptr) {\n+    int len = message_length_limit > 0 ? message_length_limit : (int)strlen(message);\n+    st.print(\": %.*s\", len, message);\n+  }\n+  st.print(\"> (\" PTR_FORMAT \") \\n\"\n@@ -168,1 +174,0 @@\n-           message ? \": \" : \"\", message ? message : \"\",\n","filename":"src\/hotspot\/share\/utilities\/events.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -210,1 +210,3 @@\n-  void log(Thread* thread, Handle h_exception, const char* message, const char* file, int line);\n+  \/\/ Message length limit of zero means no limit.\n+  void log(Thread* thread, Handle h_exception, const char* message,\n+           const char* file, int line, int message_length_limit = 0);\n@@ -278,1 +280,1 @@\n-  static void log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line);\n+  static void log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line, int message_length_limit = 0);\n@@ -348,1 +350,3 @@\n-inline void Events::log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {\n+inline void Events::log_exception(Thread* thread, Handle h_exception,\n+                                  const char* message, const char* file,\n+                                  int line, int message_length_limit) {\n@@ -350,1 +354,1 @@\n-    _exceptions->log(thread, h_exception, message, file, line);\n+    _exceptions->log(thread, h_exception, message, file, line, message_length_limit);\n","filename":"src\/hotspot\/share\/utilities\/events.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-  Events::log_exception(thread, h_exception, message, file, line);\n+  Events::log_exception(thread, h_exception, message, file, line, MAX_LEN);\n@@ -291,1 +291,1 @@\n-  assert(UTF8::is_legal_utf8((const unsigned char*)msg, (int)strlen(msg), true), \"must be\");\n+  assert(UTF8::is_legal_utf8((const unsigned char*)msg, strlen(msg), true), \"must be\");\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -314,0 +314,3 @@\n+#define THROW_HANDLE_NULL(e)                THROW_HANDLE_(e, nullptr)\n+#define THROW_ARG_NULL(name, signature, arg) THROW_ARG_(name, signature, arg, nullptr)\n+\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -101,1 +101,7 @@\n-\/\/ Count bytes of the form 10xxxxxx and deduct this count\n+\/\/ The number of unicode characters in a utf8 sequence can be easily\n+\/\/ determined by noting that bytes of the form 10xxxxxx are part of\n+\/\/ a 2 or 3-byte multi-byte sequence, all others are either characters\n+\/\/ themselves or else the start of a multi-byte character.\n+\n+\/\/ Calculate the unicode length of a utf8 string of known size\n+\/\/ by counting bytes of the form 10xxxxxx and deducting this count\n@@ -104,2 +110,2 @@\n-int UTF8::unicode_length(const char* str, int len, bool& is_latin1, bool& has_multibyte) {\n-  int num_chars = len;\n+int UTF8::unicode_length(const char* str, size_t len, bool& is_latin1, bool& has_multibyte) {\n+  size_t num_chars = len;\n@@ -109,1 +115,1 @@\n-  for (int i = 0; i < len; i++) {\n+  for (size_t i = 0; i < len; i++) {\n@@ -121,1 +127,1 @@\n-  return num_chars;\n+  return checked_cast<int>(num_chars);\n@@ -124,3 +130,3 @@\n-\/\/ Count bytes of the utf8 string except those in form\n-\/\/ 10xxxxxx which only appear in multibyte characters.\n-\/\/ The utf8 string must be in legal form and has been\n+\/\/ Calculate the unicode length of a nul-terminated utf8 string\n+\/\/ by counting bytes of the utf8 string except those in the form\n+\/\/ 10xxxxxx. The utf8 string must be in legal form and has been\n@@ -198,1 +204,1 @@\n-int UTF8::quoted_ascii_length(const char* utf8_str, int utf8_length) {\n+size_t UTF8::quoted_ascii_length(const char* utf8_str, size_t utf8_length) {\n@@ -201,1 +207,1 @@\n-  int result = 0;\n+  size_t result = 0;\n@@ -215,1 +221,1 @@\n-void UTF8::as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, int buflen) {\n+void UTF8::as_quoted_ascii(const char* utf8_str, size_t utf8_length, char* buf, size_t buflen) {\n@@ -251,1 +257,1 @@\n-  int length = ptr - quoted_ascii_str;\n+  size_t length = ptr - quoted_ascii_str;\n@@ -333,1 +339,1 @@\n-bool UTF8::is_legal_utf8(const unsigned char* buffer, int length,\n+bool UTF8::is_legal_utf8(const unsigned char* buffer, size_t length,\n@@ -335,3 +341,3 @@\n-  int i = 0;\n-  int count = length >> 2;\n-  for (int k=0; k<count; k++) {\n+  size_t i = 0;\n+  size_t count = length >> 2;\n+  for (size_t k = 0; k < count; k++) {\n@@ -408,1 +414,1 @@\n-void UTF8::truncate_to_legal_utf8(unsigned char* buffer, int length) {\n+void UTF8::truncate_to_legal_utf8(unsigned char* buffer, size_t length) {\n@@ -436,1 +442,1 @@\n-  for (int index = length - 2; index > 0; index--) {\n+  for (size_t index = length - 2; index > 0; index--) {\n@@ -444,1 +450,1 @@\n-        if ((index - 3) >= 0 &&\n+        if (index >= 3 &&\n@@ -473,1 +479,1 @@\n-int UNICODE::utf8_size(jchar c) {\n+size_t UNICODE::utf8_size(jchar c) {\n@@ -484,1 +490,1 @@\n-int UNICODE::utf8_size(jbyte c) {\n+size_t UNICODE::utf8_size(jbyte c) {\n@@ -497,1 +503,10 @@\n-int UNICODE::utf8_length(const T* base, int length) {\n+size_t UNICODE::utf8_length(const T* base, int length) {\n+  size_t result = 0;\n+  for (int index = 0; index < length; index++) {\n+    result += utf8_size(base[index]);\n+  }\n+  return result;\n+}\n+\n+template<typename T>\n+int UNICODE::utf8_length_as_int(const T* base, int length) {\n@@ -501,1 +516,4 @@\n-    int sz = utf8_size(c);\n+    size_t sz = utf8_size(c);\n+    \/\/ If the length is > INT_MAX-1 we truncate at a completed\n+    \/\/ modified-UTF8 encoding. This allows for +1 to be added\n+    \/\/ by the caller for NUL-termination, without overflow.\n@@ -511,2 +529,3 @@\n-char* UNICODE::as_utf8(const T* base, int& length) {\n-  int utf8_len = utf8_length(base, length);\n+char* UNICODE::as_utf8(const T* base, size_t& length) {\n+  \/\/ Incoming length must be <= INT_MAX\n+  size_t utf8_len = utf8_length(base, static_cast<int>(length));\n@@ -514,3 +533,3 @@\n-  char* result = as_utf8(base, length, (char*) buf, utf8_len + 1);\n-  assert((int) strlen(result) == utf8_len, \"length prediction must be correct\");\n-  \/\/ Set string length to uft8 length\n+  char* result = as_utf8(base, static_cast<int>(length), (char*) buf, utf8_len + 1);\n+  assert(strlen(result) == utf8_len, \"length prediction must be correct\");\n+  \/\/ Set outgoing string length to uft8 length\n@@ -521,1 +540,1 @@\n-char* UNICODE::as_utf8(const jchar* base, int length, char* buf, int buflen) {\n+char* UNICODE::as_utf8(const jchar* base, int length, char* buf, size_t buflen) {\n@@ -526,2 +545,3 @@\n-    buflen -= utf8_size(c);\n-    if (buflen <= 0) break; \/\/ string is truncated\n+    size_t sz = utf8_size(c);\n+    if (sz >= buflen) break; \/\/ string is truncated\n+    buflen -= sz;\n@@ -534,1 +554,1 @@\n-char* UNICODE::as_utf8(const jbyte* base, int length, char* buf, int buflen) {\n+char* UNICODE::as_utf8(const jbyte* base, int length, char* buf, size_t buflen) {\n@@ -539,1 +559,2 @@\n-    int sz = utf8_size(c);\n+    size_t sz = utf8_size(c);\n+    if (sz >= buflen) break; \/\/ string is truncated\n@@ -541,1 +562,0 @@\n-    if (buflen <= 0) break; \/\/ string is truncated\n@@ -546,0 +566,1 @@\n+      assert(sz == 2, \"must be!\");\n@@ -564,2 +585,2 @@\n-int UNICODE::quoted_ascii_length(const T* base, int length) {\n-  int result = 0;\n+size_t UNICODE::quoted_ascii_length(const T* base, int length) {\n+  size_t result = 0;\n@@ -579,1 +600,1 @@\n-void UNICODE::as_quoted_ascii(const T* base, int length, char* buf, int buflen) {\n+void UNICODE::as_quoted_ascii(const T* base, int length, char* buf, size_t buflen) {\n@@ -597,8 +618,10 @@\n-template int UNICODE::utf8_length(const jbyte* base, int length);\n-template int UNICODE::utf8_length(const jchar* base, int length);\n-template char* UNICODE::as_utf8(const jbyte* base, int& length);\n-template char* UNICODE::as_utf8(const jchar* base, int& length);\n-template int UNICODE::quoted_ascii_length<jbyte>(const jbyte* base, int length);\n-template int UNICODE::quoted_ascii_length<jchar>(const jchar* base, int length);\n-template void UNICODE::as_quoted_ascii<jbyte>(const jbyte* base, int length, char* buf, int buflen);\n-template void UNICODE::as_quoted_ascii<jchar>(const jchar* base, int length, char* buf, int buflen);\n+template size_t UNICODE::utf8_length(const jbyte* base, int length);\n+template size_t UNICODE::utf8_length(const jchar* base, int length);\n+template int UNICODE::utf8_length_as_int(const jbyte* base, int length);\n+template int UNICODE::utf8_length_as_int(const jchar* base, int length);\n+template char* UNICODE::as_utf8(const jbyte* base, size_t& length);\n+template char* UNICODE::as_utf8(const jchar* base, size_t& length);\n+template size_t UNICODE::quoted_ascii_length<jbyte>(const jbyte* base, int length);\n+template size_t UNICODE::quoted_ascii_length<jchar>(const jchar* base, int length);\n+template void UNICODE::as_quoted_ascii<jbyte>(const jbyte* base, int length, char* buf, size_t buflen);\n+template void UNICODE::as_quoted_ascii<jchar>(const jchar* base, int length, char* buf, size_t buflen);\n","filename":"src\/hotspot\/share\/utilities\/utf8.cpp","additions":68,"deletions":45,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -32,0 +32,39 @@\n+\/**\n+\n+String handling within Java and the VM requires a bit of explanation.\n+\n+Logically a java.lang.String is a sequence of 16-bit Unicode characters\n+encoded in UTF-16. In the past a String contained a Java char[] and so\n+could theoretically contain INT_MAX 16-bit characters. Then came JEP 254:\n+Compact Strings.\n+\n+With Compact Strings the Java char[] becomes a Java byte[], and that byte[]\n+contains either latin-1 characters all of which fit in 8-bits, or else each\n+pair of bytes represents a UTF-16 character. Consequently the maximum length\n+in characters of a latin-1 string is INT_MAX, whilst for non-latin-1 it is INT_MAX\/2.\n+\n+In the code below if we have latin-1 content then we treat the String's data\n+array as a jbyte[], else a jchar[]. The lengths of these arrays are specified\n+as an int value, with a nominal maximum of INT_MAX.\n+\n+The modified UTF-8 encoding specified for the VM, nominally encodes characters\n+in 1, 2, 3 or 6 bytes. The 6-byte representation is actually two 3-byte representations\n+for two UTF-16 characters forming a surrogate pair. If we are dealing with\n+a latin-1 string then each character will be encoded as either 1 or 2 bytes and so the\n+maximum UTF8 length is 2*INT_MAX. This can't be stored in an int so utf8 buffers must\n+use a size_t length. For non-latin-1 strings each UTF-16 character will encode as either\n+2 or 3 bytes, so the maximum UTF8 length in that case is 3 * INT_MAX\/2 i.e. 1.5*INT_MAX.\n+\n+The \"quoted ascii\" form of a unicode string is at worst 6 times longer than its\n+regular form, and so these lengths must always be size_t - though if we know we only\n+ever do this to symbols (or small symbol combinations) then we could use int.\n+\n+There is an additional assumption\/expectation that our UTF8 API's are never dealing with\n+invalid UTF8, and more generally that all UTF8 sequences could form valid Strings.\n+Consequently the Unicode length of a UTF8 sequence is assumed to always be representable\n+by an int. However, there are API's, such as JNI NewStringUTF, that do deal with such input\n+and could potentially have an unrepresentable string. The long standing position with JNI\n+is that the user must supply valid input so we do not try to account for these cases.\n+\n+*\/\n+\n@@ -44,1 +83,1 @@\n-  static int unicode_length(const char* utf8_str, int len) {\n+  static int unicode_length(const char* utf8_str, size_t len) {\n@@ -48,1 +87,1 @@\n-  static int unicode_length(const char* utf8_str, int len, bool& is_latin1, bool& has_multibyte);\n+  static int unicode_length(const char* utf8_str, size_t len, bool& is_latin1, bool& has_multibyte);\n@@ -54,1 +93,1 @@\n-  static int quoted_ascii_length(const char* utf8_str, int utf8_length);\n+  static size_t quoted_ascii_length(const char* utf8_str, size_t utf8_length);\n@@ -57,1 +96,1 @@\n-  static void as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, int buflen);\n+  static void as_quoted_ascii(const char* utf8_str, size_t utf8_length, char* buf, size_t buflen);\n@@ -85,1 +124,1 @@\n-  static bool   equal(const jbyte* base1, int length1, const jbyte* base2,int length2);\n+  static bool   equal(const jbyte* base1, int length1, const jbyte* base2, int length2);\n@@ -89,1 +128,1 @@\n-  static bool   is_legal_utf8(const unsigned char* buffer, int length,\n+  static bool   is_legal_utf8(const unsigned char* buffer, size_t length,\n@@ -91,1 +130,1 @@\n-  static void   truncate_to_legal_utf8(unsigned char* buffer, int length);\n+  static void   truncate_to_legal_utf8(unsigned char* buffer, size_t length);\n@@ -102,0 +141,6 @@\n+\n+  \/\/ returns the utf8 size of a unicode character\n+  \/\/ uses size_t for convenience in overflow checks\n+  static size_t utf8_size(jchar c);\n+  static size_t utf8_size(jbyte c);\n+\n@@ -109,4 +154,0 @@\n-  \/\/ returns the utf8 size of a unicode character\n-  static int utf8_size(jchar c);\n-  static int utf8_size(jbyte c);\n-\n@@ -114,1 +155,4 @@\n-  template<typename T> static int utf8_length(const T* base, int length);\n+  template<typename T> static size_t utf8_length(const T* base, int length);\n+\n+  \/\/ returns the utf8 length of a unicode string as an int - truncated if needed\n+  template<typename T> static int utf8_length_as_int(const T* base, int length);\n@@ -121,4 +165,4 @@\n-  \/\/ parameter is set to the length of the result utf8 string.\n-  template<typename T> static char* as_utf8(const T* base, int& length);\n-  static char* as_utf8(const jchar* base, int length, char* buf, int buflen);\n-  static char* as_utf8(const jbyte* base, int length, char* buf, int buflen);\n+  \/\/ parameter is set to the length of the resulting utf8 string.\n+  template<typename T> static char* as_utf8(const T* base, size_t& length);\n+  static char* as_utf8(const jchar* base, int length, char* buf, size_t buflen);\n+  static char* as_utf8(const jbyte* base, int length, char* buf, size_t buflen);\n@@ -127,1 +171,1 @@\n-  template<typename T> static int quoted_ascii_length(const T* base, int length);\n+  template<typename T> static size_t quoted_ascii_length(const T* base, int length);\n@@ -130,1 +174,1 @@\n-  template<typename T> static void as_quoted_ascii(const T* base, int length, char* buf, int buflen);\n+  template<typename T> static void as_quoted_ascii(const T* base, int length, char* buf, size_t buflen);\n","filename":"src\/hotspot\/share\/utilities\/utf8.hpp","additions":62,"deletions":18,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,3 +49,2 @@\n-JNIEXPORT jboolean JNICALL\n-Java_java_nio_MappedMemoryUtils_isLoaded0(JNIEnv *env, jobject obj, jlong address,\n-                                         jlong len, jlong numPages)\n+jboolean JNICALL MappedMemoryUtils_isLoaded0(JNIEnv *env, jobject obj, jlong address,\n+                                             jlong len, jlong numPages)\n@@ -96,2 +95,1 @@\n-JNIEXPORT void JNICALL\n-Java_java_nio_MappedMemoryUtils_load0(JNIEnv *env, jobject obj, jlong address,\n+void JNICALL MappedMemoryUtils_load0(JNIEnv *env, jobject obj, jlong address,\n@@ -107,3 +105,2 @@\n-JNIEXPORT void JNICALL\n-Java_java_nio_MappedMemoryUtils_unload0(JNIEnv *env, jobject obj, jlong address,\n-                                     jlong len)\n+void JNICALL MappedMemoryUtils_unload0(JNIEnv *env, jobject obj, jlong address,\n+                                       jlong len)\n@@ -201,2 +198,1 @@\n-JNIEXPORT void JNICALL\n-Java_java_nio_MappedMemoryUtils_force0(JNIEnv *env, jobject obj, jobject fdo,\n+void JNICALL MappedMemoryUtils_force0(JNIEnv *env, jobject obj, jobject fdo,\n@@ -221,0 +217,16 @@\n+\n+#define FD \"Ljava\/io\/FileDescriptor;\"\n+\n+static JNINativeMethod methods[] = {\n+    {\"isLoaded0\", \"(JJJ)Z\",             (void *)&MappedMemoryUtils_isLoaded0},\n+    {\"load0\",     \"(JJ)V\",              (void *)&MappedMemoryUtils_load0},\n+    {\"unload0\",   \"(JJ)V\",              (void *)&MappedMemoryUtils_unload0},\n+    {\"force0\",    \"(\" FD \"JJ)V\",        (void *)&MappedMemoryUtils_force0},\n+};\n+\n+JNIEXPORT void JNICALL\n+Java_java_nio_MappedMemoryUtils_registerNatives(JNIEnv *env, jclass cls)\n+{\n+    (*env)->RegisterNatives(env, cls,\n+                            methods, sizeof(methods)\/sizeof(methods[0]));\n+}\n","filename":"src\/java.base\/aix\/native\/libnio\/MappedMemoryUtils.c","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -100,7 +100,12 @@\n-    \/\/ Get buffer size needed to read all processes\n-    int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0};\n-    if (sysctl(mib, 4, NULL, &bufSize, NULL, 0) < 0) {\n-        JNU_ThrowByNameWithLastError(env,\n-            \"java\/lang\/RuntimeException\", \"sysctl failed\");\n-        return -1;\n-    }\n+    int errsysctl;\n+    int maxRetries = 100;\n+    void *buffer = NULL;\n+    do {\n+        int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_ALL, 0};\n+        if (buffer != NULL) free(buffer);\n+        \/\/ Get buffer size needed to read all processes\n+        if (sysctl(mib, 4, NULL, &bufSize, NULL, 0) < 0) {\n+            JNU_ThrowByNameWithMessageAndLastError(env,\n+                \"java\/lang\/RuntimeException\", \"sysctl failed\");\n+            return -1;\n+        }\n@@ -108,6 +113,12 @@\n-    \/\/ Allocate buffer big enough for all processes\n-    void *buffer = malloc(bufSize);\n-    if (buffer == NULL) {\n-        JNU_ThrowOutOfMemoryError(env, \"malloc failed\");\n-        return -1;\n-    }\n+        \/\/ Allocate buffer big enough for all processes; add a little\n+        \/\/ bit of space to be able to hold a few more proc infos\n+        \/\/ for processes started right after the first sysctl call\n+        buffer = malloc(bufSize + 4 * sizeof(struct kinfo_proc));\n+        if (buffer == NULL) {\n+            JNU_ThrowOutOfMemoryError(env, \"malloc failed\");\n+            return -1;\n+        }\n+\n+        \/\/ Read process info for all processes\n+        errsysctl = sysctl(mib, 4, buffer, &bufSize, NULL, 0);\n+    } while (errsysctl < 0 && errno == ENOMEM && maxRetries-- > 0);\n@@ -115,4 +126,3 @@\n-    \/\/ Read process info for all processes\n-    if (sysctl(mib, 4, buffer, &bufSize, NULL, 0) < 0) {\n-        JNU_ThrowByNameWithLastError(env,\n-            \"java\/lang\/RuntimeException\", \"sysctl failed\");\n+    if (errsysctl < 0) {\n+        JNU_ThrowByNameWithMessageAndLastError(env,\n+            \"java\/lang\/RuntimeException\", \"sysctl failed to get info about all processes\");\n","filename":"src\/java.base\/macosx\/native\/libjava\/ProcessHandleImpl_macosx.c","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -431,3 +431,3 @@\n-#ifdef STATIC_BUILD\n-    return JNI_TRUE;\n-#else\n+    if (JLI_IsStaticallyLinked()) {\n+        return JNI_TRUE;\n+    }\n@@ -441,1 +441,0 @@\n-#endif\n@@ -454,10 +453,11 @@\n-#ifdef STATIC_BUILD\n-        char jvm_cfg[MAXPATHLEN];\n-        JLI_Snprintf(jvm_cfg, sizeof(jvm_cfg), \"%s\/lib\/jvm.cfg\", path);\n-        if (access(jvm_cfg, F_OK) == 0) {\n-            return JNI_TRUE;\n-        }\n-#else\n-        JLI_Snprintf(libjava, sizeof(libjava), \"%s\/lib\/\" JAVA_DLL, path);\n-        if (access(libjava, F_OK) == 0) {\n-            return JNI_TRUE;\n+        if (JLI_IsStaticallyLinked()) {\n+            char jvm_cfg[MAXPATHLEN];\n+            JLI_Snprintf(jvm_cfg, sizeof(jvm_cfg), \"%s\/lib\/jvm.cfg\", path);\n+            if (access(jvm_cfg, F_OK) == 0) {\n+                return JNI_TRUE;\n+            }\n+        } else {\n+            JLI_Snprintf(libjava, sizeof(libjava), \"%s\/lib\/\" JAVA_DLL, path);\n+            if (access(libjava, F_OK) == 0) {\n+                return JNI_TRUE;\n+            }\n@@ -465,1 +465,0 @@\n-#endif\n@@ -484,15 +483,17 @@\n-#ifdef STATIC_BUILD\n-    char jvm_cfg[MAXPATHLEN];\n-    char *p = NULL;\n-    strncpy(jvm_cfg, selfInfo.dli_fname, MAXPATHLEN);\n-    p = strrchr(jvm_cfg, '\/'); *p = '\\0';\n-    p = strrchr(jvm_cfg, '\/');\n-    if (strcmp(p, \"\/.\") == 0) {\n-      *p = '\\0';\n-      p = strrchr(jvm_cfg, '\/'); *p = '\\0';\n-    }\n-    else *p = '\\0';\n-    strncpy(path, jvm_cfg, pathsize);\n-    strncat(jvm_cfg, \"\/lib\/jvm.cfg\", MAXPATHLEN);\n-    if (access(jvm_cfg, F_OK) == 0) {\n-      return JNI_TRUE;\n+    if (JLI_IsStaticallyLinked()) {\n+        char jvm_cfg[MAXPATHLEN];\n+        char *p = NULL;\n+        strncpy(jvm_cfg, selfInfo.dli_fname, MAXPATHLEN);\n+        p = strrchr(jvm_cfg, '\/'); *p = '\\0';\n+        p = strrchr(jvm_cfg, '\/');\n+        if (strcmp(p, \"\/.\") == 0) {\n+            *p = '\\0';\n+            p = strrchr(jvm_cfg, '\/'); *p = '\\0';\n+        } else {\n+          *p = '\\0';\n+        }\n+        strncpy(path, jvm_cfg, pathsize);\n+        strncat(jvm_cfg, \"\/lib\/jvm.cfg\", MAXPATHLEN);\n+        if (access(jvm_cfg, F_OK) == 0) {\n+           return JNI_TRUE;\n+        }\n@@ -500,1 +501,0 @@\n-#endif\n@@ -552,5 +552,6 @@\n-#ifndef STATIC_BUILD\n-    libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);\n-#else\n-    libjvm = dlopen(NULL, RTLD_FIRST);\n-#endif\n+    if (!JLI_IsStaticallyLinked()) {\n+        libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);\n+    } else {\n+        libjvm = dlopen(NULL, RTLD_FIRST);\n+    }\n+\n@@ -606,2 +607,0 @@\n-\n-#ifdef STATIC_BUILD\n@@ -609,5 +608,6 @@\n-        fptr = (void *)&SetExecname;\n-#else\n-        int (*fptr)();\n-        fptr = (int (*)())dlsym(RTLD_DEFAULT, \"main\");\n-#endif\n+\n+        if (JLI_IsStaticallyLinked()) {\n+            fptr = (void *)&SetExecname;\n+        } else {\n+            fptr = dlsym(RTLD_DEFAULT, \"main\");\n+        }\n","filename":"src\/java.base\/macosx\/native\/libjli\/java_md_macosx.m","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2120,0 +2120,5 @@\n+     * <p> If a file with the generated name cannot be created by the\n+     * underlying platform, then an {@code IOException} will be thrown.\n+     * This could occur for example if the supplied prefix or suffix contains\n+     * one or more characters not supported by the underlying file system.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/io\/File.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1250,1 +1250,1 @@\n-     * @jls 6.7 Fully Qualified Names\n+     * @jls 6.7 Fully Qualified Names and Canonical Names\n@@ -1463,1 +1463,1 @@\n-     * @jls 9.1.1. Interface Modifiers\n+     * @jls 9.1.1 Interface Modifiers\n@@ -1997,1 +1997,1 @@\n-     * @jls 14.3 Local Class Declarations\n+     * @jls 14.3 Local Class and Interface Declarations\n@@ -2010,1 +2010,1 @@\n-     * @jls 8.5 Member Type Declarations\n+     * @jls 8.5 Member Class and Interface Declarations\n@@ -2547,1 +2547,1 @@\n-     * @jls 8.5 Member Type Declarations\n+     * @jls 8.5 Member Class and Interface Declarations\n@@ -4650,1 +4650,1 @@\n-            return \"[\" + componentType.descriptorString();\n+            return \"[\".concat(componentType.descriptorString());\n@@ -4663,5 +4663,1 @@\n-            return new StringBuilder(name.length() + 2)\n-                    .append('L')\n-                    .append(name)\n-                    .append(';')\n-                    .toString();\n+            return StringConcatHelper.concat(\"L\", name, \";\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -226,1 +226,1 @@\n- * @jls 6.7 Fully Qualified Names\n+ * @jls 6.7 Fully Qualified Names and Canonical Names\n@@ -2445,1 +2445,1 @@\n-    \/*\n+    \/**\n@@ -2447,0 +2447,18 @@\n+     * @param loader the class loader used to look up the native library symbol\n+     * @param clazz the class in which the native method is declared\n+     * @param entryName the native method's mangled name (this is the name used for the native lookup)\n+     * @param javaName the native method's declared name\n+     *\/\n+    static long findNative(ClassLoader loader, Class<?> clazz, String entryName, String javaName) {\n+        NativeLibraries nativeLibraries = nativeLibrariesFor(loader);\n+        long addr = nativeLibraries.find(entryName);\n+        if (addr != 0 && loader != null) {\n+            Reflection.ensureNativeAccess(clazz, clazz, javaName, true);\n+        }\n+        return addr;\n+    }\n+\n+    \/*\n+     * This is also called by SymbolLookup::loaderLookup. In that case, we need\n+     * to avoid a restricted check, as that check has already been performed when\n+     * obtaining the lookup.\n@@ -2448,1 +2466,1 @@\n-    static long findNative(ClassLoader loader, String entryName) {\n+    static NativeLibraries nativeLibrariesFor(ClassLoader loader) {\n@@ -2450,1 +2468,1 @@\n-            return BootLoader.getNativeLibraries().find(entryName);\n+            return BootLoader.getNativeLibraries();\n@@ -2452,1 +2470,1 @@\n-            return loader.libraries.find(entryName);\n+            return loader.libraries;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -347,2 +347,2 @@\n- * @jls 4.2.3 Floating-Point Types, Formats, and Values\n- * @jls 4.2.4. Floating-Point Operations\n+ * @jls 4.2.3 Floating-Point Types and Values\n+ * @jls 4.2.4 Floating-Point Operations\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import jdk.internal.misc.VM;\n@@ -66,0 +67,1 @@\n+import jdk.internal.module.ModuleBootstrap.IllegalNativeAccess;\n@@ -303,1 +305,1 @@\n-    void ensureNativeAccess(Class<?> owner, String methodName, Class<?> currentClass) {\n+    void ensureNativeAccess(Class<?> owner, String methodName, Class<?> currentClass, boolean jni) {\n@@ -306,3 +308,10 @@\n-        if (!EnableNativeAccess.isNativeAccessEnabled(target)) {\n-            if (ModuleBootstrap.hasEnableNativeAccessFlag()) {\n-                throw new IllegalCallerException(\"Illegal native access from: \" + this);\n+        ModuleBootstrap.IllegalNativeAccess illegalNativeAccess = ModuleBootstrap.illegalNativeAccess();\n+        if (illegalNativeAccess != ModuleBootstrap.IllegalNativeAccess.ALLOW &&\n+                !EnableNativeAccess.isNativeAccessEnabled(target)) {\n+            String mod = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n+            if (currentClass != null) {\n+                \/\/ try to extract location of the current class (e.g. jar or folder)\n+                URL url = System.codeSource(currentClass);\n+                if (url != null) {\n+                    mod += \" (\" + url + \")\";\n+                }\n@@ -310,1 +319,3 @@\n-            if (EnableNativeAccess.trySetEnableNativeAccess(target)) {\n+            if (illegalNativeAccess == ModuleBootstrap.IllegalNativeAccess.DENY) {\n+                throw new IllegalCallerException(\"Illegal native access from \" + mod);\n+            } else if (EnableNativeAccess.trySetEnableNativeAccess(target)) {\n@@ -314,1 +325,0 @@\n-                String mod = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n@@ -317,6 +327,15 @@\n-                System.err.printf(\"\"\"\n-                        WARNING: A restricted method in %s has been called\n-                        WARNING: %s has been called by %s in %s\n-                        WARNING: Use --enable-native-access=%s to avoid a warning for callers in this module\n-                        WARNING: Restricted methods will be blocked in a future release unless native access is enabled\n-                        %n\"\"\", cls, mtd, caller, mod, modflag);\n+                if (jni) {\n+                    VM.initialErr().printf(\"\"\"\n+                            WARNING: A native method in %s has been bound\n+                            WARNING: %s is declared in %s\n+                            WARNING: Use --enable-native-access=%s to avoid a warning for native methods declared in this module\n+                            WARNING: Restricted methods will be blocked in a future release unless native access is enabled\n+                            %n\"\"\", cls, mtd, mod, modflag);\n+                } else {\n+                    VM.initialErr().printf(\"\"\"\n+                            WARNING: A restricted method in %s has been called\n+                            WARNING: %s has been called by %s in %s\n+                            WARNING: Use --enable-native-access=%s to avoid a warning for callers in this module\n+                            WARNING: Restricted methods will be blocked in a future release unless native access is enabled\n+                            %n\"\"\", cls, mtd, caller, mod, modflag);\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":31,"deletions":12,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-                \"enableNativeAccess\");\n+                \"enableNativeAccess\", false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ModuleLayer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n- * @jls 8.10 Record Types\n+ * @jls 8.10 Record Classes\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Record.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import jdk.internal.javac.Restricted;\n@@ -831,0 +832,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -837,0 +840,1 @@\n+    @Restricted\n@@ -838,1 +842,3 @@\n-        load0(Reflection.getCallerClass(), filename);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, Runtime.class, \"load\", false);\n+        load0(caller, filename);\n@@ -897,0 +903,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -902,0 +910,1 @@\n+    @Restricted\n@@ -903,1 +912,3 @@\n-        loadLibrary0(Reflection.getCallerClass(), libname);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, Runtime.class, \"loadLibrary\", false);\n+        loadLibrary0(caller, libname);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Runtime.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,1 +173,1 @@\n-         * @jvms 4.3.3 Method Descriptor\n+         * @jvms 4.3.3 Method Descriptors\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StackWalker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -37,0 +38,39 @@\n+    \/**\n+     * Count the number of leading non-zero ascii chars in the range.\n+     *\/\n+    public static int countNonZeroAscii(String s) {\n+        byte[] value = s.value();\n+        if (s.isLatin1()) {\n+            return countNonZeroAsciiLatin1(value, 0, value.length);\n+        } else {\n+            return countNonZeroAsciiUTF16(value, 0, s.length());\n+        }\n+    }\n+\n+    \/**\n+     * Count the number of non-zero ascii chars in the range.\n+     *\/\n+    public static int countNonZeroAsciiLatin1(byte[] ba, int off, int len) {\n+        int limit = off + len;\n+        for (int i = off; i < limit; i++) {\n+            if (ba[i] <= 0) {\n+                return i - off;\n+            }\n+        }\n+        return len;\n+    }\n+\n+    \/**\n+     * Count the number of leading non-zero ascii chars in the range.\n+     *\/\n+    public static int countNonZeroAsciiUTF16(byte[] ba, int off, int strlen) {\n+        int limit = off + strlen;\n+        for (int i = off; i < limit; i++) {\n+            char c = StringUTF16.charAt(ba, i);\n+            if (c == 0 || c > 0x7F) {\n+                return i - off;\n+            }\n+        }\n+        return strlen;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -31,0 +32,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -42,0 +44,92 @@\n+    static abstract class StringConcatBase {\n+        @Stable\n+        final String[] constants;\n+        final int      length;\n+        final byte     coder;\n+\n+        StringConcatBase(String[] constants) {\n+            int  length = 0;\n+            byte coder  = String.LATIN1;\n+            for (String c : constants) {\n+                length += c.length();\n+                coder  |= c.coder();\n+            }\n+            this.constants = constants;\n+            this.length    = length;\n+            this.coder     = coder;\n+        }\n+    }\n+\n+    static final class Concat1 extends StringConcatBase {\n+        Concat1(String[] constants) {\n+            super(constants);\n+        }\n+\n+        @ForceInline\n+        String concat0(String value) {\n+            int length = stringSize(this.length, value);\n+            byte coder = (byte) (this.coder | value.coder());\n+            byte[] buf = newArray(length << coder);\n+            String prefix = constants[0];\n+            prefix.getBytes(buf, 0, coder);\n+            value.getBytes(buf, prefix.length(), coder);\n+            constants[1].getBytes(buf, prefix.length() + value.length(), coder);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(boolean value) {\n+            int length = stringSize(this.length, value);\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(char value) {\n+            int length = stringSize(this.length, value);\n+            byte coder = (byte) (this.coder | stringCoder(value));\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(int value) {\n+            int length = stringSize(this.length, value);\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(long value) {\n+            int length = stringSize(this.length, value);\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(Object value) {\n+            return concat0(stringOf(value));\n+        }\n+\n+        @ForceInline\n+        String concat(float value) {\n+            return concat0(Float.toString(value));\n+        }\n+\n+        @ForceInline\n+        String concat(double value) {\n+            return concat0(Double.toString(value));\n+        }\n+    }\n@@ -378,0 +472,58 @@\n+    static String stringOf(float value) {\n+        return Float.toString(value);\n+    }\n+\n+    static String stringOf(double value) {\n+        return Double.toString(value);\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, char value) {\n+        return checkOverflow(length + 1);\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, boolean value) {\n+        return checkOverflow(length + (value ? 4 : 5));\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, int value) {\n+        return checkOverflow(length + DecimalDigits.stringSize(value));\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, long value) {\n+        return checkOverflow(length + DecimalDigits.stringSize(value));\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, String value) {\n+        return checkOverflow(length + value.length());\n+    }\n+\n@@ -443,0 +595,207 @@\n+    \/**\n+     * Allocates an uninitialized byte array based on the length and coder\n+     * information, then prepends the given suffix string at the end of the\n+     * byte array before returning it. The calling code must adjust the\n+     * indexCoder so that it's taken the coder of the suffix into account, but\n+     * subtracted the length of the suffix.\n+     *\n+     * @param suffix\n+     * @param indexCoder\n+     * @return the newly allocated byte array\n+     *\/\n+    @ForceInline\n+    static byte[] newArrayWithSuffix(String suffix, int index, byte coder) {\n+        byte[] buf = newArray((index + suffix.length()) << coder);\n+        if (coder == String.LATIN1) {\n+            suffix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            suffix.getBytes(buf, index, String.UTF16);\n+        }\n+        return buf;\n+    }\n+\n+    \/**\n+     * Return the coder for the character.\n+     * @param value character\n+     * @return      coder\n+     *\/\n+    static byte stringCoder(char value) {\n+        return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      boolean value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, boolean value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            if (value) {\n+                index -= 4;\n+                buf[index] = 't';\n+                buf[index + 1] = 'r';\n+                buf[index + 2] = 'u';\n+                buf[index + 3] = 'e';\n+            } else {\n+                index -= 5;\n+                buf[index] = 'f';\n+                buf[index + 1] = 'a';\n+                buf[index + 2] = 'l';\n+                buf[index + 3] = 's';\n+                buf[index + 4] = 'e';\n+            }\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            if (value) {\n+                index -= 4;\n+                StringUTF16.putChar(buf, index, 't');\n+                StringUTF16.putChar(buf, index + 1, 'r');\n+                StringUTF16.putChar(buf, index + 2, 'u');\n+                StringUTF16.putChar(buf, index + 3, 'e');\n+            } else {\n+                index -= 5;\n+                StringUTF16.putChar(buf, index, 'f');\n+                StringUTF16.putChar(buf, index + 1, 'a');\n+                StringUTF16.putChar(buf, index + 2, 'l');\n+                StringUTF16.putChar(buf, index + 3, 's');\n+                StringUTF16.putChar(buf, index + 4, 'e');\n+            }\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      char value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, char value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            buf[--index] = (byte) (value & 0xFF);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            StringUTF16.putChar(buf, --index, value);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      int value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, int value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            index = StringLatin1.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            index = StringUTF16.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      long value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, long value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            index = StringLatin1.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            index = StringUTF16.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      boolean value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, String value, String prefix) {\n+        index -= value.length();\n+        if (coder == String.LATIN1) {\n+            value.getBytes(buf, index, String.LATIN1);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            value.getBytes(buf, index, String.UTF16);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Check for overflow, throw exception on overflow.\n+     *\n+     * @param value\n+     * @return the given parameter value, if valid\n+     *\/\n+    @ForceInline\n+    static int checkOverflow(int value) {\n+        if (value >= 0) {\n+            return value;\n+        }\n+        throw new OutOfMemoryError(\"Overflow: String length out of range\");\n+    }\n+\n+    @ForceInline\n+    private static String concat0(String prefix, String str, String suffix) {\n+        byte coder = (byte) (prefix.coder() | str.coder() | suffix.coder());\n+        int len = prefix.length() + str.length();\n+        byte[] buf = newArrayWithSuffix(suffix, len, coder);\n+        prepend(len, coder, buf, str, prefix);\n+        return new String(buf, coder);\n+    }\n+\n+    @ForceInline\n+    static String concat(String prefix, Object value, String suffix) {\n+        if (prefix == null) prefix = \"null\";\n+        if (suffix == null) suffix = \"null\";\n+        return concat0(prefix, stringOf(value), suffix);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":359,"deletions":0,"binary":false,"changes":359,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+import java.util.concurrent.Executor;\n@@ -72,0 +73,2 @@\n+import jdk.internal.javac.Restricted;\n+import jdk.internal.loader.NativeLibraries;\n@@ -358,1 +361,1 @@\n-    private static URL codeSource(Class<?> clazz) {\n+    static URL codeSource(Class<?> clazz) {\n@@ -2020,0 +2023,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -2026,0 +2031,1 @@\n+    @Restricted\n@@ -2027,1 +2033,3 @@\n-        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, System.class, \"load\", false);\n+        Runtime.getRuntime().load0(caller, filename);\n@@ -2058,0 +2066,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -2064,0 +2074,1 @@\n+    @Restricted\n@@ -2065,1 +2076,3 @@\n-        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, System.class, \"loadLibrary\", false);\n+        Runtime.getRuntime().loadLibrary0(caller, libname);\n@@ -2542,2 +2555,2 @@\n-            public void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass) {\n-                m.ensureNativeAccess(owner, methodName, currentClass);\n+            public void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass, boolean jni) {\n+                m.ensureNativeAccess(owner, methodName, currentClass, jni);\n@@ -2561,0 +2574,3 @@\n+            public int countNonZeroAscii(String s) {\n+                return StringCoding.countNonZeroAscii(s);\n+            }\n@@ -2626,0 +2642,12 @@\n+            public Object stringConcat1(String[] constants) {\n+                return new StringConcatHelper.Concat1(constants);\n+            }\n+\n+            public byte stringInitCoder() {\n+                return String.COMPACT_STRINGS ? String.LATIN1 : String.UTF16;\n+            }\n+\n+            public byte stringCoder(String str) {\n+                return str.coder();\n+            }\n+\n@@ -2638,0 +2666,4 @@\n+            public String concat(String prefix, Object value, String suffix) {\n+                return StringConcatHelper.concat(prefix, value, suffix);\n+            }\n+\n@@ -2643,2 +2675,2 @@\n-            public long findNative(ClassLoader loader, String entry) {\n-                return ClassLoader.findNative(loader, entry);\n+            public NativeLibraries nativeLibrariesFor(ClassLoader loader) {\n+                return ClassLoader.nativeLibrariesFor(loader);\n@@ -2742,0 +2774,4 @@\n+            public Executor virtualThreadDefaultScheduler() {\n+                return VirtualThread.defaultScheduler();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":43,"deletions":7,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -460,4 +460,3 @@\n-        ThreadSleepEvent event = null;\n-        if (ThreadSleepEvent.isTurnedOn()) {\n-            try {\n-                event = new ThreadSleepEvent();\n+        try {\n+            ThreadSleepEvent event = new ThreadSleepEvent();\n+            if (event.isEnabled()) {\n@@ -466,2 +465,1 @@\n-            } catch (OutOfMemoryError e) {\n-                event = null;\n+                return event;\n@@ -469,0 +467,2 @@\n+        } catch (OutOfMemoryError e) {\n+            \/\/ ignore\n@@ -470,1 +470,1 @@\n-        return event;\n+        return null;\n@@ -473,0 +473,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -145,0 +145,8 @@\n+\n+    \/**\n+     * Returns the default scheduler.\n+     *\/\n+    static Executor defaultScheduler() {\n+        return DEFAULT_SCHEDULER;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,16 @@\n- * Models an annotation on a declaration.\n+ * Models an {@code annotation} structure (JVMS {@jvms 4.7.16}) or part of a {@code\n+ * type_annotation} structure (JVMS {@jvms 4.7.20}). This model indicates the\n+ * interface of the annotation and a set of element-value pairs.\n+ * <p>\n+ * This model can reconstruct an annotation, given the location of the modeled structure\n+ * in the class file and the definition of the annotation interface.\n+ * <p>\n+ * Two {@code Annotation} objects should be compared using the {@link\n+ * Object#equals(Object) equals} method.\n+ *\n+ * @apiNote\n+ * For Java programs, the location of the modeled structure indicates the source code\n+ * element or type (JLS {@jls 9.7.4}) on which the reconstructed annotation appears,\n+ * and the annotation interface definition determines whether the reconstructed annotation has\n+ * elements with default values (JLS {@jls 9.6.2}), and whether the reconstructed annotation\n+ * is a container annotation for multiple annotations (JLS {@jls 9.7.5}).\n@@ -44,0 +59,1 @@\n+ * @see TypeAnnotation\n@@ -49,1 +65,0 @@\n- * @sealedGraph\n@@ -54,1 +69,1 @@\n-        permits TypeAnnotation, AnnotationImpl {\n+        permits AnnotationImpl {\n@@ -57,1 +72,2 @@\n-     * {@return the class of the annotation}\n+     * {@return the constant pool entry holding the {@linkplain Class#descriptorString\n+     * descriptor string} of the annotation interface}\n@@ -62,1 +78,1 @@\n-     * {@return the class of the annotation, as a symbolic descriptor}\n+     * {@return the annotation interface, as a symbolic descriptor}\n@@ -69,1 +85,1 @@\n-     * {@return the elements of the annotation}\n+     * {@return the element-value pairs of the annotation}\n@@ -75,2 +91,3 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the constant pool entry holding the descriptor string\n+     *                        of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n@@ -85,2 +102,3 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the constant pool entry holding the descriptor string\n+     *                        of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n@@ -95,2 +113,2 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the descriptor of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n@@ -105,2 +123,2 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the descriptor of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Annotation.java","additions":32,"deletions":14,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -35,1 +35,7 @@\n- * Models a key-value pair of an annotation.\n+ * Models an element-value pair in the {@code element_value_pairs}\n+ * table in the {@code annotation} structure defined in JVMS\n+ * {@jvms 4.7.16} or the {@code type_annotation} structure defined\n+ * in JVMS {@jvms 4.7.20}.\n+ * <p>\n+ * Two {@code AnnotationElement} objects should be compared using the\n+ * {@link Object#equals(Object) equals} method.\n@@ -48,0 +54,6 @@\n+     *\n+     * @apiNote\n+     * In Java source code, by convention, the name of the sole element in a\n+     * single-element annotation interface is {@code value}. (JLS {@jls 9.6.1})\n+     * This is the case for single-element annotations (JLS {@jls 9.7.3}) and\n+     * container annotations for multiple annotations (JLS {@jls 9.6.3}).\n@@ -57,1 +69,1 @@\n-     * {@return an annotation key-value pair}\n+     * {@return an element-value pair}\n@@ -67,1 +79,1 @@\n-     * {@return an annotation key-value pair}\n+     * {@return an element-value pair}\n@@ -77,1 +89,1 @@\n-     * {@return an annotation key-value pair for a class-valued annotation}\n+     * {@return an element-value pair for a class-valued element}\n@@ -80,0 +92,1 @@\n+     * @see AnnotationValue#ofClass(ClassDesc) AnnotationValue::ofClass\n@@ -87,1 +100,1 @@\n-     * {@return an annotation key-value pair for a string-valued annotation}\n+     * {@return an element-value pair for a string-valued element}\n@@ -90,0 +103,1 @@\n+     * @see AnnotationValue#ofString(String) AnnotationValue::ofString\n@@ -97,1 +111,1 @@\n-     * {@return an annotation key-value pair for a long-valued annotation}\n+     * {@return an element-value pair for a long-valued element}\n@@ -100,0 +114,1 @@\n+     * @see AnnotationValue#ofLong(long) AnnotationValue::ofLong\n@@ -107,1 +122,1 @@\n-     * {@return an annotation key-value pair for an int-valued annotation}\n+     * {@return an element-value pair for an int-valued element}\n@@ -110,0 +125,1 @@\n+     * @see AnnotationValue#ofInt(int) AnnotationValue::ofInt\n@@ -117,1 +133,1 @@\n-     * {@return an annotation key-value pair for a char-valued annotation}\n+     * {@return an element-value pair for a char-valued element}\n@@ -120,0 +136,1 @@\n+     * @see AnnotationValue#ofChar(char) AnnotationValue::ofChar\n@@ -127,1 +144,1 @@\n-     * {@return an annotation key-value pair for a short-valued annotation}\n+     * {@return an element-value pair for a short-valued element}\n@@ -130,0 +147,1 @@\n+     * @see AnnotationValue#ofShort(short) AnnotationValue::ofShort\n@@ -137,1 +155,1 @@\n-     * {@return an annotation key-value pair for a byte-valued annotation}\n+     * {@return an element-value pair for a byte-valued element}\n@@ -140,0 +158,1 @@\n+     * @see AnnotationValue#ofByte(byte) AnnotationValue::ofByte\n@@ -142,1 +161,1 @@\n-                                      byte value) {\n+                                    byte value) {\n@@ -147,1 +166,1 @@\n-     * {@return an annotation key-value pair for a boolean-valued annotation}\n+     * {@return an element-value pair for a boolean-valued element}\n@@ -150,0 +169,1 @@\n+     * @see AnnotationValue#ofBoolean(boolean) AnnotationValue::ofBoolean\n@@ -152,1 +172,1 @@\n-                                      boolean value) {\n+                                       boolean value) {\n@@ -157,1 +177,1 @@\n-     * {@return an annotation key-value pair for a double-valued annotation}\n+     * {@return an element-value pair for a double-valued element}\n@@ -160,0 +180,1 @@\n+     * @see AnnotationValue#ofDouble(double) AnnotationValue::ofDouble\n@@ -167,1 +188,1 @@\n-     * {@return an annotation key-value pair for a float-valued annotation}\n+     * {@return an element-value pair for a float-valued element}\n@@ -170,0 +191,1 @@\n+     * @see AnnotationValue#ofFloat(float) AnnotationValue::ofFloat\n@@ -177,1 +199,1 @@\n-     * {@return an annotation key-value pair for an annotation-valued annotation}\n+     * {@return an element-value pair for an annotation-valued element}\n@@ -180,0 +202,1 @@\n+     * @see AnnotationValue#ofAnnotation AnnotationValue::ofAnnotation\n@@ -187,1 +210,1 @@\n-     * {@return an annotation key-value pair for an array-valued annotation}\n+     * {@return an element-value pair for an array-valued element}\n@@ -190,0 +213,1 @@\n+     * @see AnnotationValue#ofArray(AnnotationValue...) AnnotationValue::ofArray\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationElement.java","additions":41,"deletions":17,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -44,1 +44,5 @@\n- * Models the value of a key-value pair of an annotation.\n+ * Models an {@code element_value} structure, or a value of an element-value\n+ * pair of an annotation, as defined in JVMS {@jvms 4.7.16.1}.\n+ * <p>\n+ * Two {@code AnnotationValue} objects should be compared using the {@link\n+ * Object#equals(Object) equals} method.\n@@ -56,2 +60,2 @@\n-     * Models an annotation-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_ANNOTATION}.\n+     * Models an annotation value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_ANNOTATION}.\n@@ -69,2 +73,2 @@\n-     * Models an array-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_ARRAY}.\n+     * Models an array value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_ARRAY}.\n@@ -82,1 +86,3 @@\n-         * which must not be an array type. ({@jls 9.6.1})\n+         * which must not be an array type. (JLS {@jls 9.6.1}) If such elements are\n+         * annotations, they have the same annotation interface; if such elements\n+         * are enum, they belong to the same enum class.\n@@ -88,1 +94,1 @@\n-     * Models a constant-valued element.\n+     * Models a constant value of an element-value pair.\n@@ -94,4 +100,1 @@\n-    sealed interface OfConstant\n-            extends AnnotationValue\n-            permits OfString, OfDouble, OfFloat, OfLong, OfInt, OfShort, OfChar, OfByte,\n-                    OfBoolean, AnnotationImpl.OfConstantImpl {\n+    sealed interface OfConstant extends AnnotationValue {\n@@ -102,1 +105,3 @@\n-         * Different types of constant values may share the same type of entry.\n+         * Different types of constant values may share the same type of entry\n+         * because they have the same {@linkplain TypeKind##computational-type\n+         * computational type}.\n@@ -126,2 +131,2 @@\n-     * Models a string-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_STRING}.\n+     * Models a string value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_STRING}.\n@@ -154,2 +159,2 @@\n-     * Models a double-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_DOUBLE}.\n+     * Models a double value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_DOUBLE}.\n@@ -182,2 +187,2 @@\n-     * Models a float-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_FLOAT}.\n+     * Models a float value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_FLOAT}.\n@@ -210,2 +215,2 @@\n-     * Models a long-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_LONG}.\n+     * Models a long value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_LONG}.\n@@ -238,2 +243,2 @@\n-     * Models an int-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_INT}.\n+     * Models an int value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_INT}.\n@@ -266,2 +271,2 @@\n-     * Models a short-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_SHORT}.\n+     * Models a short value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_SHORT}.\n@@ -297,2 +302,2 @@\n-     * Models a char-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_CHAR}.\n+     * Models a char value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_CHAR}.\n@@ -328,2 +333,2 @@\n-     * Models a byte-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_BYTE}.\n+     * Models a byte value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_BYTE}.\n@@ -359,2 +364,2 @@\n-     * Models a boolean-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_BOOLEAN}.\n+     * Models a boolean value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_BOOLEAN}.\n@@ -390,2 +395,2 @@\n-     * Models a class-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_CLASS}.\n+     * Models a class value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_CLASS}.\n@@ -408,2 +413,2 @@\n-     * Models an enum-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_ENUM}.\n+     * Models an enum value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_ENUM}.\n@@ -429,1 +434,2 @@\n-     * {@return the tag character for this type as per {@jvms 4.7.16.1}}\n+     * {@return the tag character for this value as per JVMS {@jvms 4.7.16.1}}\n+     * The tag characters have a one-to-one mapping to the types of annotation element values.\n@@ -434,1 +440,1 @@\n-     * {@return an annotation element for a enum-valued element}\n+     * {@return an enum value for an element-value pair}\n@@ -444,1 +450,1 @@\n-     * {@return an annotation element for a enum-valued element}\n+     * {@return an enum value for an element-value pair}\n@@ -454,1 +460,1 @@\n-     * {@return an annotation element for a class-valued element}\n+     * {@return a class value for an element-value pair}\n@@ -462,1 +468,1 @@\n-     * {@return an annotation element for a class-valued element}\n+     * {@return a class value for an element-value pair}\n@@ -470,1 +476,1 @@\n-     * {@return an annotation element for a string-valued element}\n+     * {@return a string value for an element-value pair}\n@@ -478,1 +484,1 @@\n-     * {@return an annotation element for a string-valued element}\n+     * {@return a string value for an element-value pair}\n@@ -486,1 +492,1 @@\n-     * {@return an annotation element for a double-valued element}\n+     * {@return a double value for an element-value pair}\n@@ -494,1 +500,1 @@\n-     * {@return an annotation element for a double-valued element}\n+     * {@return a double value for an element-value pair}\n@@ -502,1 +508,1 @@\n-     * {@return an annotation element for a float-valued element}\n+     * {@return a float value for an element-value pair}\n@@ -510,1 +516,1 @@\n-     * {@return an annotation element for a float-valued element}\n+     * {@return a float value for an element-value pair}\n@@ -518,1 +524,1 @@\n-     * {@return an annotation element for a long-valued element}\n+     * {@return a long value for an element-value pair}\n@@ -526,1 +532,1 @@\n-     * {@return an annotation element for a long-valued element}\n+     * {@return a long value for an element-value pair}\n@@ -534,1 +540,1 @@\n-     * {@return an annotation element for an int-valued element}\n+     * {@return an int value for an element-value pair}\n@@ -542,1 +548,1 @@\n-     * {@return an annotation element for an int-valued element}\n+     * {@return an int value for an element-value pair}\n@@ -550,1 +556,1 @@\n-     * {@return an annotation element for a short-valued element}\n+     * {@return a short value for an element-value pair}\n@@ -558,1 +564,1 @@\n-     * {@return an annotation element for a short-valued element}\n+     * {@return a short value for an element-value pair}\n@@ -566,1 +572,1 @@\n-     * {@return an annotation element for a char-valued element}\n+     * {@return a char value for an element-value pair}\n@@ -574,1 +580,1 @@\n-     * {@return an annotation element for a char-valued element}\n+     * {@return a char value for an element-value pair}\n@@ -582,1 +588,1 @@\n-     * {@return an annotation element for a byte-valued element}\n+     * {@return a byte value for an element-value pair}\n@@ -590,1 +596,1 @@\n-     * {@return an annotation element for a byte-valued element}\n+     * {@return a byte value for an element-value pair}\n@@ -598,1 +604,1 @@\n-     * {@return an annotation element for a boolean-valued element}\n+     * {@return a boolean value for an element-value pair}\n@@ -606,1 +612,1 @@\n-     * {@return an annotation element for a boolean-valued element}\n+     * {@return a boolean value for an element-value pair}\n@@ -615,1 +621,1 @@\n-     * {@return an annotation element for an annotation-valued element}\n+     * {@return an annotation value for an element-value pair}\n@@ -623,1 +629,6 @@\n-     * {@return an annotation element for an array-valued element}\n+     * {@return an array value for an element-value pair}\n+     *\n+     * @apiNote\n+     * See {@link AnnotationValue.OfArray#values() values()} for conventions\n+     * on array values derived from Java source code.\n+     *\n@@ -631,1 +642,6 @@\n-     * {@return an annotation element for an array-valued element}\n+     * {@return an array value for an element-value pair}\n+     *\n+     * @apiNote\n+     * See {@link AnnotationValue.OfArray#values() values()} for conventions\n+     * on array values derived from Java source code.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationValue.java","additions":76,"deletions":60,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n- * Models a classfile attribute {@jvms 4.7}.  Many, though not all, subtypes of\n+ * Models a classfile attribute (JVMS {@jvms 4.7}).  Many, though not all, subtypes of\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-public interface AttributeMapper<A> {\n+public interface AttributeMapper<A extends Attribute<A>> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AttributeMapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-        return withField(name, descriptor, fb -> fb.withFlags(flags));\n+        return withField(name, descriptor, Util.buildingFlags(flags));\n@@ -197,1 +197,1 @@\n-        return withField(name, descriptor, fb -> fb.withFlags(flags));\n+        return withField(name, descriptor, Util.buildingFlags(flags));\n@@ -244,1 +244,1 @@\n-        return withMethod(name, descriptor, methodFlags, mb -> mb.withCode(handler));\n+        return withMethod(name, descriptor, methodFlags, Util.buildingCode(handler));\n@@ -279,4 +279,1 @@\n-        return withMethodBody(constantPool().utf8Entry(name),\n-                              constantPool().utf8Entry(descriptor),\n-                              methodFlags,\n-                              handler);\n+        return withMethod(name, descriptor, methodFlags, Util.buildingCode(handler));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassBuilder.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * Models the generic signature of a class file, as defined by {@jvms 4.7.9}.\n+ * Models the generic signature of a class file, as defined by JVMS {@jvms 4.7.9}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassSignature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-        if (opcode.kind() != Opcode.Kind.BRANCH || opcode.primaryTypeKind() == TypeKind.VoidType) {\n+        if (opcode.kind() != Opcode.Kind.BRANCH || BytecodeHelpers.isUnconditionalBranch(opcode)) {\n@@ -315,1 +315,1 @@\n-        if (opcode.kind() != Opcode.Kind.BRANCH || opcode.primaryTypeKind() == TypeKind.VoidType) {\n+        if (opcode.kind() != Opcode.Kind.BRANCH || BytecodeHelpers.isUnconditionalBranch(opcode)) {\n@@ -553,1 +553,2 @@\n-     * @throws IllegalArgumentException for conversions of {@code VoidType} or {@code ReferenceType}\n+     * @throws IllegalArgumentException for conversions of {@link TypeKind#VOID void} or\n+     *         {@link TypeKind#REFERENCE reference}\n@@ -557,73 +558,47 @@\n-        return switch (fromType) {\n-            case IntType, ByteType, CharType, ShortType, BooleanType ->\n-                    switch (toType) {\n-                        case IntType -> this;\n-                        case LongType -> i2l();\n-                        case DoubleType -> i2d();\n-                        case FloatType -> i2f();\n-                        case ByteType -> i2b();\n-                        case CharType -> i2c();\n-                        case ShortType -> i2s();\n-                        case BooleanType -> iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case LongType ->\n-                    switch (toType) {\n-                        case IntType -> l2i();\n-                        case LongType -> this;\n-                        case DoubleType -> l2d();\n-                        case FloatType -> l2f();\n-                        case ByteType -> l2i().i2b();\n-                        case CharType -> l2i().i2c();\n-                        case ShortType -> l2i().i2s();\n-                        case BooleanType -> l2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case DoubleType ->\n-                    switch (toType) {\n-                        case IntType -> d2i();\n-                        case LongType -> d2l();\n-                        case DoubleType -> this;\n-                        case FloatType -> d2f();\n-                        case ByteType -> d2i().i2b();\n-                        case CharType -> d2i().i2c();\n-                        case ShortType -> d2i().i2s();\n-                        case BooleanType -> d2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case FloatType ->\n-                    switch (toType) {\n-                        case IntType -> f2i();\n-                        case LongType -> f2l();\n-                        case DoubleType -> f2d();\n-                        case FloatType -> this;\n-                        case ByteType -> f2i().i2b();\n-                        case CharType -> f2i().i2c();\n-                        case ShortType -> f2i().i2s();\n-                        case BooleanType -> f2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case VoidType, ReferenceType ->\n-                throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-        };\n-    }\n-\n-    \/**\n-     * Generate an instruction pushing a constant onto the operand stack\n-     * @see Opcode.Kind#CONSTANT\n-     * @param opcode the constant instruction opcode\n-     * @param value the constant value\n-     * @return this builder\n-     * @since 23\n-     *\/\n-    default CodeBuilder loadConstant(Opcode opcode, ConstantDesc value) {\n-        BytecodeHelpers.validateValue(opcode, value);\n-        return with(switch (opcode) {\n-            case SIPUSH, BIPUSH -> ConstantInstruction.ofArgument(opcode, ((Number)value).intValue());\n-            case LDC, LDC_W, LDC2_W -> ConstantInstruction.ofLoad(opcode, BytecodeHelpers.constantEntry(constantPool(), value));\n-            default -> ConstantInstruction.ofIntrinsic(opcode);\n-        });\n+        var computationalFrom = fromType.asLoadable();\n+        var computationalTo = toType.asLoadable();\n+        if (computationalFrom != computationalTo) {\n+            switch (computationalTo) {\n+                case INT -> {\n+                    switch (computationalFrom) {\n+                        case FLOAT -> f2i();\n+                        case LONG -> l2i();\n+                        case DOUBLE -> d2i();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+                case FLOAT -> {\n+                    switch (computationalFrom) {\n+                        case INT -> i2f();\n+                        case LONG -> l2f();\n+                        case DOUBLE -> d2f();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+                case LONG -> {\n+                    switch (computationalFrom) {\n+                        case INT -> i2l();\n+                        case FLOAT -> f2l();\n+                        case DOUBLE -> d2l();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+                case DOUBLE -> {\n+                    switch (computationalFrom) {\n+                        case INT -> i2d();\n+                        case FLOAT -> f2d();\n+                        case LONG -> l2d();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+            }\n+        }\n+        if (computationalTo == TypeKind.INT && toType != TypeKind.INT) {\n+            switch (toType) {\n+                case BOOLEAN -> iconst_1().iand();\n+                case BYTE -> i2b();\n+                case CHAR -> i2c();\n+                case SHORT -> i2s();\n+            }\n+        }\n+        return this;\n@@ -642,26 +617,28 @@\n-        if (value instanceof Integer iVal)\n-            return switch (iVal) {\n-                case -1 -> iconst_m1();\n-                case  0 -> iconst_0();\n-                case  1 -> iconst_1();\n-                case  2 -> iconst_2();\n-                case  3 -> iconst_3();\n-                case  4 -> iconst_4();\n-                case  5 -> iconst_5();\n-                default -> (iVal >= Byte.MIN_VALUE && iVal <= Byte.MAX_VALUE) ? bipush(iVal)\n-                         : (iVal >= Short.MIN_VALUE && iVal <= Short.MAX_VALUE) ? sipush(iVal)\n-                         : ldc(constantPool().intEntry(iVal));\n-            };\n-        if (value instanceof Long lVal)\n-            return lVal == 0l ? lconst_0()\n-                 : lVal == 1l ? lconst_1()\n-                 : ldc(constantPool().longEntry(lVal));\n-        if (value instanceof Float fVal)\n-            return Float.floatToRawIntBits(fVal) == 0 ? fconst_0()\n-                 : fVal == 1.0f ? fconst_1()\n-                 : fVal == 2.0f ? fconst_2()\n-                 : ldc(constantPool().floatEntry(fVal));\n-        if (value instanceof Double dVal)\n-            return Double.doubleToRawLongBits(dVal) == 0l ? dconst_0()\n-                 : dVal == 1.0d ? dconst_1()\n-                 : ldc(constantPool().doubleEntry(dVal));\n+        if (value instanceof Number) {\n+            if (value instanceof Integer iVal)\n+                return switch (iVal) {\n+                    case -1 -> iconst_m1();\n+                    case 0 -> iconst_0();\n+                    case 1 -> iconst_1();\n+                    case 2 -> iconst_2();\n+                    case 3 -> iconst_3();\n+                    case 4 -> iconst_4();\n+                    case 5 -> iconst_5();\n+                    default -> (iVal >= Byte.MIN_VALUE && iVal <= Byte.MAX_VALUE) ? bipush(iVal)\n+                            : (iVal >= Short.MIN_VALUE && iVal <= Short.MAX_VALUE) ? sipush(iVal)\n+                            : ldc(constantPool().intEntry(iVal));\n+                };\n+            if (value instanceof Long lVal)\n+                return lVal == 0L ? lconst_0()\n+                        : lVal == 1L ? lconst_1()\n+                        : ldc(constantPool().longEntry(lVal));\n+            if (value instanceof Float fVal)\n+                return Float.floatToRawIntBits(fVal) == 0 ? fconst_0()\n+                        : fVal == 1.0f ? fconst_1()\n+                        : fVal == 2.0f ? fconst_2()\n+                        : ldc(constantPool().floatEntry(fVal));\n+            if (value instanceof Double dVal)\n+                return Double.doubleToRawLongBits(dVal) == 0L ? dconst_0()\n+                        : dVal == 1.0d ? dconst_1()\n+                        : ldc(constantPool().doubleEntry(dVal));\n+        }\n@@ -843,1 +820,1 @@\n-        return arrayLoad(TypeKind.ReferenceType);\n+        return arrayLoad(TypeKind.REFERENCE);\n@@ -851,1 +828,1 @@\n-        return arrayStore(TypeKind.ReferenceType);\n+        return arrayStore(TypeKind.REFERENCE);\n@@ -864,1 +841,1 @@\n-        return loadLocal(TypeKind.ReferenceType, slot);\n+        return loadLocal(TypeKind.REFERENCE, slot);\n@@ -891,1 +868,1 @@\n-        return return_(TypeKind.ReferenceType);\n+        return return_(TypeKind.REFERENCE);\n@@ -912,1 +889,1 @@\n-        return storeLocal(TypeKind.ReferenceType, slot);\n+        return storeLocal(TypeKind.REFERENCE, slot);\n@@ -928,1 +905,1 @@\n-        return arrayLoad(TypeKind.ByteType);\n+        return arrayLoad(TypeKind.BYTE);\n@@ -936,1 +913,1 @@\n-        return arrayStore(TypeKind.ByteType);\n+        return arrayStore(TypeKind.BYTE);\n@@ -940,2 +917,2 @@\n-     * Generate an instruction pushing a byte onto the operand stack\n-     * @param b the byte\n+     * Generate an instruction pushing an int in the range of byte onto the operand stack.\n+     * @param b the int in the range of byte\n@@ -945,1 +922,1 @@\n-        return loadConstant(Opcode.BIPUSH, b);\n+        return with(ConstantInstruction.ofArgument(Opcode.BIPUSH, b));\n@@ -953,1 +930,1 @@\n-        return arrayLoad(TypeKind.CharType);\n+        return arrayLoad(TypeKind.CHAR);\n@@ -961,1 +938,1 @@\n-        return arrayStore(TypeKind.CharType);\n+        return arrayStore(TypeKind.CHAR);\n@@ -1020,1 +997,1 @@\n-        return arrayLoad(TypeKind.DoubleType);\n+        return arrayLoad(TypeKind.DOUBLE);\n@@ -1028,1 +1005,1 @@\n-        return arrayStore(TypeKind.DoubleType);\n+        return arrayStore(TypeKind.DOUBLE);\n@@ -1081,1 +1058,1 @@\n-        return loadLocal(TypeKind.DoubleType, slot);\n+        return loadLocal(TypeKind.DOUBLE, slot);\n@@ -1113,1 +1090,1 @@\n-        return return_(TypeKind.DoubleType);\n+        return return_(TypeKind.DOUBLE);\n@@ -1126,1 +1103,1 @@\n-        return storeLocal(TypeKind.DoubleType, slot);\n+        return storeLocal(TypeKind.DOUBLE, slot);\n@@ -1224,1 +1201,1 @@\n-        return arrayLoad(TypeKind.FloatType);\n+        return arrayLoad(TypeKind.FLOAT);\n@@ -1232,1 +1209,1 @@\n-        return arrayStore(TypeKind.FloatType);\n+        return arrayStore(TypeKind.FLOAT);\n@@ -1293,1 +1270,1 @@\n-        return loadLocal(TypeKind.FloatType, slot);\n+        return loadLocal(TypeKind.FLOAT, slot);\n@@ -1325,1 +1302,1 @@\n-        return return_(TypeKind.FloatType);\n+        return return_(TypeKind.FLOAT);\n@@ -1338,1 +1315,1 @@\n-        return storeLocal(TypeKind.FloatType, slot);\n+        return storeLocal(TypeKind.FLOAT, slot);\n@@ -1479,1 +1456,1 @@\n-        return arrayLoad(TypeKind.IntType);\n+        return arrayLoad(TypeKind.INT);\n@@ -1495,1 +1472,1 @@\n-        return arrayStore(TypeKind.IntType);\n+        return arrayStore(TypeKind.INT);\n@@ -1726,1 +1703,1 @@\n-        return loadLocal(TypeKind.IntType, slot);\n+        return loadLocal(TypeKind.INT, slot);\n@@ -1955,1 +1932,1 @@\n-        return return_(TypeKind.IntType);\n+        return return_(TypeKind.INT);\n@@ -1984,1 +1961,1 @@\n-        return storeLocal(TypeKind.IntType, slot);\n+        return storeLocal(TypeKind.INT, slot);\n@@ -2058,1 +2035,1 @@\n-        return arrayLoad(TypeKind.LongType);\n+        return arrayLoad(TypeKind.LONG);\n@@ -2074,1 +2051,1 @@\n-        return arrayStore(TypeKind.LongType);\n+        return arrayStore(TypeKind.LONG);\n@@ -2125,4 +2102,1 @@\n-        return with(ConstantInstruction.ofLoad(\n-                entry.typeKind().slotSize() == 2 ? Opcode.LDC2_W\n-                : entry.index() > 0xff ? Opcode.LDC_W\n-                : Opcode.LDC, entry));\n+        return with(ConstantInstruction.ofLoad(BytecodeHelpers.ldcOpcode(entry), entry));\n@@ -2149,1 +2123,1 @@\n-        return loadLocal(TypeKind.LongType, slot);\n+        return loadLocal(TypeKind.LONG, slot);\n@@ -2189,1 +2163,1 @@\n-        return return_(TypeKind.LongType);\n+        return return_(TypeKind.LONG);\n@@ -2218,1 +2192,1 @@\n-        return storeLocal(TypeKind.LongType, slot);\n+        return storeLocal(TypeKind.LONG, slot);\n@@ -2388,1 +2362,1 @@\n-        return return_(TypeKind.VoidType);\n+        return return_(TypeKind.VOID);\n@@ -2396,1 +2370,1 @@\n-        return arrayLoad(TypeKind.ShortType);\n+        return arrayLoad(TypeKind.SHORT);\n@@ -2404,1 +2378,1 @@\n-        return arrayStore(TypeKind.ShortType);\n+        return arrayStore(TypeKind.SHORT);\n@@ -2408,2 +2382,2 @@\n-     * Generate an instruction pushing a short onto the operand stack\n-     * @param s the short\n+     * Generate an instruction pushing an int in the range of short onto the operand stack.\n+     * @param s the int in the range of short\n@@ -2413,1 +2387,1 @@\n-        return loadConstant(Opcode.SIPUSH, s);\n+        return with(ConstantInstruction.ofArgument(Opcode.SIPUSH, s));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":118,"deletions":144,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * Models the generic signature of a method, as defined by {@jvms 4.7.9}.\n+ * Models the generic signature of a method, as defined by JVMS {@jvms 4.7.9}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodSignature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import java.lang.constant.ConstantDesc;\n-import java.lang.constant.ConstantDescs;\n@@ -32,1 +30,1 @@\n- * Describes the opcodes of the JVM instruction set, as described in {@jvms 6.5}.\n+ * Describes the opcodes of the JVM instruction set, as described in JVMS {@jvms 6.5}.\n@@ -48,1 +46,1 @@\n-    ACONST_NULL(ClassFile.ACONST_NULL, 1, Kind.CONSTANT, TypeKind.ReferenceType, 0, ConstantDescs.NULL),\n+    ACONST_NULL(ClassFile.ACONST_NULL, 1, Kind.CONSTANT),\n@@ -51,1 +49,1 @@\n-    ICONST_M1(ClassFile.ICONST_M1, 1, Kind.CONSTANT, TypeKind.IntType, 0, -1),\n+    ICONST_M1(ClassFile.ICONST_M1, 1, Kind.CONSTANT),\n@@ -54,1 +52,1 @@\n-    ICONST_0(ClassFile.ICONST_0, 1, Kind.CONSTANT, TypeKind.IntType, 0, 0),\n+    ICONST_0(ClassFile.ICONST_0, 1, Kind.CONSTANT),\n@@ -57,1 +55,1 @@\n-    ICONST_1(ClassFile.ICONST_1, 1, Kind.CONSTANT, TypeKind.IntType, 0, 1),\n+    ICONST_1(ClassFile.ICONST_1, 1, Kind.CONSTANT),\n@@ -60,1 +58,1 @@\n-    ICONST_2(ClassFile.ICONST_2, 1, Kind.CONSTANT, TypeKind.IntType, 0, 2),\n+    ICONST_2(ClassFile.ICONST_2, 1, Kind.CONSTANT),\n@@ -63,1 +61,1 @@\n-    ICONST_3(ClassFile.ICONST_3, 1, Kind.CONSTANT, TypeKind.IntType, 0, 3),\n+    ICONST_3(ClassFile.ICONST_3, 1, Kind.CONSTANT),\n@@ -66,1 +64,1 @@\n-    ICONST_4(ClassFile.ICONST_4, 1, Kind.CONSTANT, TypeKind.IntType, 0, 4),\n+    ICONST_4(ClassFile.ICONST_4, 1, Kind.CONSTANT),\n@@ -69,1 +67,1 @@\n-    ICONST_5(ClassFile.ICONST_5, 1, Kind.CONSTANT, TypeKind.IntType, 0, 5),\n+    ICONST_5(ClassFile.ICONST_5, 1, Kind.CONSTANT),\n@@ -72,1 +70,1 @@\n-    LCONST_0(ClassFile.LCONST_0, 1, Kind.CONSTANT, TypeKind.LongType, 0, 0L),\n+    LCONST_0(ClassFile.LCONST_0, 1, Kind.CONSTANT),\n@@ -75,1 +73,1 @@\n-    LCONST_1(ClassFile.LCONST_1, 1, Kind.CONSTANT, TypeKind.LongType, 0, 1L),\n+    LCONST_1(ClassFile.LCONST_1, 1, Kind.CONSTANT),\n@@ -78,1 +76,1 @@\n-    FCONST_0(ClassFile.FCONST_0, 1, Kind.CONSTANT, TypeKind.FloatType, 0, 0.0f),\n+    FCONST_0(ClassFile.FCONST_0, 1, Kind.CONSTANT),\n@@ -81,1 +79,1 @@\n-    FCONST_1(ClassFile.FCONST_1, 1, Kind.CONSTANT, TypeKind.FloatType, 0, 1.0f),\n+    FCONST_1(ClassFile.FCONST_1, 1, Kind.CONSTANT),\n@@ -84,1 +82,1 @@\n-    FCONST_2(ClassFile.FCONST_2, 1, Kind.CONSTANT, TypeKind.FloatType, 0, 2.0f),\n+    FCONST_2(ClassFile.FCONST_2, 1, Kind.CONSTANT),\n@@ -87,1 +85,1 @@\n-    DCONST_0(ClassFile.DCONST_0, 1, Kind.CONSTANT, TypeKind.DoubleType, 0, 0.0d),\n+    DCONST_0(ClassFile.DCONST_0, 1, Kind.CONSTANT),\n@@ -90,1 +88,1 @@\n-    DCONST_1(ClassFile.DCONST_1, 1, Kind.CONSTANT, TypeKind.DoubleType, 0, 1.0d),\n+    DCONST_1(ClassFile.DCONST_1, 1, Kind.CONSTANT),\n@@ -93,1 +91,1 @@\n-    BIPUSH(ClassFile.BIPUSH, 2, Kind.CONSTANT, TypeKind.ByteType),\n+    BIPUSH(ClassFile.BIPUSH, 2, Kind.CONSTANT),\n@@ -96,1 +94,1 @@\n-    SIPUSH(ClassFile.SIPUSH, 3, Kind.CONSTANT, TypeKind.ShortType),\n+    SIPUSH(ClassFile.SIPUSH, 3, Kind.CONSTANT),\n@@ -108,1 +106,1 @@\n-    ILOAD(ClassFile.ILOAD, 2, Kind.LOAD, TypeKind.IntType, -1),\n+    ILOAD(ClassFile.ILOAD, 2, Kind.LOAD),\n@@ -111,1 +109,1 @@\n-    LLOAD(ClassFile.LLOAD, 2, Kind.LOAD, TypeKind.LongType, -1),\n+    LLOAD(ClassFile.LLOAD, 2, Kind.LOAD),\n@@ -114,1 +112,1 @@\n-    FLOAD(ClassFile.FLOAD, 2, Kind.LOAD, TypeKind.FloatType, -1),\n+    FLOAD(ClassFile.FLOAD, 2, Kind.LOAD),\n@@ -117,1 +115,1 @@\n-    DLOAD(ClassFile.DLOAD, 2, Kind.LOAD, TypeKind.DoubleType, -1),\n+    DLOAD(ClassFile.DLOAD, 2, Kind.LOAD),\n@@ -120,1 +118,1 @@\n-    ALOAD(ClassFile.ALOAD, 2, Kind.LOAD, TypeKind.ReferenceType, -1),\n+    ALOAD(ClassFile.ALOAD, 2, Kind.LOAD),\n@@ -123,1 +121,1 @@\n-    ILOAD_0(ClassFile.ILOAD_0, 1, Kind.LOAD, TypeKind.IntType, 0),\n+    ILOAD_0(ClassFile.ILOAD_0, 1, Kind.LOAD),\n@@ -126,1 +124,1 @@\n-    ILOAD_1(ClassFile.ILOAD_1, 1, Kind.LOAD, TypeKind.IntType, 1),\n+    ILOAD_1(ClassFile.ILOAD_1, 1, Kind.LOAD),\n@@ -129,1 +127,1 @@\n-    ILOAD_2(ClassFile.ILOAD_2, 1, Kind.LOAD, TypeKind.IntType, 2),\n+    ILOAD_2(ClassFile.ILOAD_2, 1, Kind.LOAD),\n@@ -132,1 +130,1 @@\n-    ILOAD_3(ClassFile.ILOAD_3, 1, Kind.LOAD, TypeKind.IntType, 3),\n+    ILOAD_3(ClassFile.ILOAD_3, 1, Kind.LOAD),\n@@ -135,1 +133,1 @@\n-    LLOAD_0(ClassFile.LLOAD_0, 1, Kind.LOAD, TypeKind.LongType, 0),\n+    LLOAD_0(ClassFile.LLOAD_0, 1, Kind.LOAD),\n@@ -138,1 +136,1 @@\n-    LLOAD_1(ClassFile.LLOAD_1, 1, Kind.LOAD, TypeKind.LongType, 1),\n+    LLOAD_1(ClassFile.LLOAD_1, 1, Kind.LOAD),\n@@ -141,1 +139,1 @@\n-    LLOAD_2(ClassFile.LLOAD_2, 1, Kind.LOAD, TypeKind.LongType, 2),\n+    LLOAD_2(ClassFile.LLOAD_2, 1, Kind.LOAD),\n@@ -144,1 +142,1 @@\n-    LLOAD_3(ClassFile.LLOAD_3, 1, Kind.LOAD, TypeKind.LongType, 3),\n+    LLOAD_3(ClassFile.LLOAD_3, 1, Kind.LOAD),\n@@ -147,1 +145,1 @@\n-    FLOAD_0(ClassFile.FLOAD_0, 1, Kind.LOAD, TypeKind.FloatType, 0),\n+    FLOAD_0(ClassFile.FLOAD_0, 1, Kind.LOAD),\n@@ -150,1 +148,1 @@\n-    FLOAD_1(ClassFile.FLOAD_1, 1, Kind.LOAD, TypeKind.FloatType, 1),\n+    FLOAD_1(ClassFile.FLOAD_1, 1, Kind.LOAD),\n@@ -153,1 +151,1 @@\n-    FLOAD_2(ClassFile.FLOAD_2, 1, Kind.LOAD, TypeKind.FloatType, 2),\n+    FLOAD_2(ClassFile.FLOAD_2, 1, Kind.LOAD),\n@@ -156,1 +154,1 @@\n-    FLOAD_3(ClassFile.FLOAD_3, 1, Kind.LOAD, TypeKind.FloatType, 3),\n+    FLOAD_3(ClassFile.FLOAD_3, 1, Kind.LOAD),\n@@ -159,1 +157,1 @@\n-    DLOAD_0(ClassFile.DLOAD_0, 1, Kind.LOAD, TypeKind.DoubleType, 0),\n+    DLOAD_0(ClassFile.DLOAD_0, 1, Kind.LOAD),\n@@ -162,1 +160,1 @@\n-    DLOAD_1(ClassFile.DLOAD_1, 1, Kind.LOAD, TypeKind.DoubleType, 1),\n+    DLOAD_1(ClassFile.DLOAD_1, 1, Kind.LOAD),\n@@ -165,1 +163,1 @@\n-    DLOAD_2(ClassFile.DLOAD_2, 1, Kind.LOAD, TypeKind.DoubleType, 2),\n+    DLOAD_2(ClassFile.DLOAD_2, 1, Kind.LOAD),\n@@ -168,1 +166,1 @@\n-    DLOAD_3(ClassFile.DLOAD_3, 1, Kind.LOAD, TypeKind.DoubleType, 3),\n+    DLOAD_3(ClassFile.DLOAD_3, 1, Kind.LOAD),\n@@ -171,1 +169,1 @@\n-    ALOAD_0(ClassFile.ALOAD_0, 1, Kind.LOAD, TypeKind.ReferenceType, 0),\n+    ALOAD_0(ClassFile.ALOAD_0, 1, Kind.LOAD),\n@@ -174,1 +172,1 @@\n-    ALOAD_1(ClassFile.ALOAD_1, 1, Kind.LOAD, TypeKind.ReferenceType, 1),\n+    ALOAD_1(ClassFile.ALOAD_1, 1, Kind.LOAD),\n@@ -177,1 +175,1 @@\n-    ALOAD_2(ClassFile.ALOAD_2, 1, Kind.LOAD, TypeKind.ReferenceType, 2),\n+    ALOAD_2(ClassFile.ALOAD_2, 1, Kind.LOAD),\n@@ -180,1 +178,1 @@\n-    ALOAD_3(ClassFile.ALOAD_3, 1, Kind.LOAD, TypeKind.ReferenceType, 3),\n+    ALOAD_3(ClassFile.ALOAD_3, 1, Kind.LOAD),\n@@ -183,1 +181,1 @@\n-    IALOAD(ClassFile.IALOAD, 1, Kind.ARRAY_LOAD, TypeKind.IntType),\n+    IALOAD(ClassFile.IALOAD, 1, Kind.ARRAY_LOAD),\n@@ -186,1 +184,1 @@\n-    LALOAD(ClassFile.LALOAD, 1, Kind.ARRAY_LOAD, TypeKind.LongType),\n+    LALOAD(ClassFile.LALOAD, 1, Kind.ARRAY_LOAD),\n@@ -189,1 +187,1 @@\n-    FALOAD(ClassFile.FALOAD, 1, Kind.ARRAY_LOAD, TypeKind.FloatType),\n+    FALOAD(ClassFile.FALOAD, 1, Kind.ARRAY_LOAD),\n@@ -192,1 +190,1 @@\n-    DALOAD(ClassFile.DALOAD, 1, Kind.ARRAY_LOAD, TypeKind.DoubleType),\n+    DALOAD(ClassFile.DALOAD, 1, Kind.ARRAY_LOAD),\n@@ -195,1 +193,1 @@\n-    AALOAD(ClassFile.AALOAD, 1, Kind.ARRAY_LOAD, TypeKind.ReferenceType),\n+    AALOAD(ClassFile.AALOAD, 1, Kind.ARRAY_LOAD),\n@@ -198,1 +196,1 @@\n-    BALOAD(ClassFile.BALOAD, 1, Kind.ARRAY_LOAD, TypeKind.ByteType),\n+    BALOAD(ClassFile.BALOAD, 1, Kind.ARRAY_LOAD),\n@@ -201,1 +199,1 @@\n-    CALOAD(ClassFile.CALOAD, 1, Kind.ARRAY_LOAD, TypeKind.CharType),\n+    CALOAD(ClassFile.CALOAD, 1, Kind.ARRAY_LOAD),\n@@ -204,1 +202,1 @@\n-    SALOAD(ClassFile.SALOAD, 1, Kind.ARRAY_LOAD, TypeKind.ShortType),\n+    SALOAD(ClassFile.SALOAD, 1, Kind.ARRAY_LOAD),\n@@ -207,1 +205,1 @@\n-    ISTORE(ClassFile.ISTORE, 2, Kind.STORE, TypeKind.IntType, -1),\n+    ISTORE(ClassFile.ISTORE, 2, Kind.STORE),\n@@ -210,1 +208,1 @@\n-    LSTORE(ClassFile.LSTORE, 2, Kind.STORE, TypeKind.LongType, -1),\n+    LSTORE(ClassFile.LSTORE, 2, Kind.STORE),\n@@ -213,1 +211,1 @@\n-    FSTORE(ClassFile.FSTORE, 2, Kind.STORE, TypeKind.FloatType, -1),\n+    FSTORE(ClassFile.FSTORE, 2, Kind.STORE),\n@@ -216,1 +214,1 @@\n-    DSTORE(ClassFile.DSTORE, 2, Kind.STORE, TypeKind.DoubleType, -1),\n+    DSTORE(ClassFile.DSTORE, 2, Kind.STORE),\n@@ -219,1 +217,1 @@\n-    ASTORE(ClassFile.ASTORE, 2, Kind.STORE, TypeKind.ReferenceType, -1),\n+    ASTORE(ClassFile.ASTORE, 2, Kind.STORE),\n@@ -222,1 +220,1 @@\n-    ISTORE_0(ClassFile.ISTORE_0, 1, Kind.STORE, TypeKind.IntType, 0),\n+    ISTORE_0(ClassFile.ISTORE_0, 1, Kind.STORE),\n@@ -225,1 +223,1 @@\n-    ISTORE_1(ClassFile.ISTORE_1, 1, Kind.STORE, TypeKind.IntType, 1),\n+    ISTORE_1(ClassFile.ISTORE_1, 1, Kind.STORE),\n@@ -228,1 +226,1 @@\n-    ISTORE_2(ClassFile.ISTORE_2, 1, Kind.STORE, TypeKind.IntType, 2),\n+    ISTORE_2(ClassFile.ISTORE_2, 1, Kind.STORE),\n@@ -231,1 +229,1 @@\n-    ISTORE_3(ClassFile.ISTORE_3, 1, Kind.STORE, TypeKind.IntType, 3),\n+    ISTORE_3(ClassFile.ISTORE_3, 1, Kind.STORE),\n@@ -234,1 +232,1 @@\n-    LSTORE_0(ClassFile.LSTORE_0, 1, Kind.STORE, TypeKind.LongType, 0),\n+    LSTORE_0(ClassFile.LSTORE_0, 1, Kind.STORE),\n@@ -237,1 +235,1 @@\n-    LSTORE_1(ClassFile.LSTORE_1, 1, Kind.STORE, TypeKind.LongType, 1),\n+    LSTORE_1(ClassFile.LSTORE_1, 1, Kind.STORE),\n@@ -240,1 +238,1 @@\n-    LSTORE_2(ClassFile.LSTORE_2, 1, Kind.STORE, TypeKind.LongType, 2),\n+    LSTORE_2(ClassFile.LSTORE_2, 1, Kind.STORE),\n@@ -243,1 +241,1 @@\n-    LSTORE_3(ClassFile.LSTORE_3, 1, Kind.STORE, TypeKind.LongType, 3),\n+    LSTORE_3(ClassFile.LSTORE_3, 1, Kind.STORE),\n@@ -246,1 +244,1 @@\n-    FSTORE_0(ClassFile.FSTORE_0, 1, Kind.STORE, TypeKind.FloatType, 0),\n+    FSTORE_0(ClassFile.FSTORE_0, 1, Kind.STORE),\n@@ -249,1 +247,1 @@\n-    FSTORE_1(ClassFile.FSTORE_1, 1, Kind.STORE, TypeKind.FloatType, 1),\n+    FSTORE_1(ClassFile.FSTORE_1, 1, Kind.STORE),\n@@ -252,1 +250,1 @@\n-    FSTORE_2(ClassFile.FSTORE_2, 1, Kind.STORE, TypeKind.FloatType, 2),\n+    FSTORE_2(ClassFile.FSTORE_2, 1, Kind.STORE),\n@@ -255,1 +253,1 @@\n-    FSTORE_3(ClassFile.FSTORE_3, 1, Kind.STORE, TypeKind.FloatType, 3),\n+    FSTORE_3(ClassFile.FSTORE_3, 1, Kind.STORE),\n@@ -258,1 +256,1 @@\n-    DSTORE_0(ClassFile.DSTORE_0, 1, Kind.STORE, TypeKind.DoubleType, 0),\n+    DSTORE_0(ClassFile.DSTORE_0, 1, Kind.STORE),\n@@ -261,1 +259,1 @@\n-    DSTORE_1(ClassFile.DSTORE_1, 1, Kind.STORE, TypeKind.DoubleType, 1),\n+    DSTORE_1(ClassFile.DSTORE_1, 1, Kind.STORE),\n@@ -264,1 +262,1 @@\n-    DSTORE_2(ClassFile.DSTORE_2, 1, Kind.STORE, TypeKind.DoubleType, 2),\n+    DSTORE_2(ClassFile.DSTORE_2, 1, Kind.STORE),\n@@ -267,1 +265,1 @@\n-    DSTORE_3(ClassFile.DSTORE_3, 1, Kind.STORE, TypeKind.DoubleType, 3),\n+    DSTORE_3(ClassFile.DSTORE_3, 1, Kind.STORE),\n@@ -270,1 +268,1 @@\n-    ASTORE_0(ClassFile.ASTORE_0, 1, Kind.STORE, TypeKind.ReferenceType, 0),\n+    ASTORE_0(ClassFile.ASTORE_0, 1, Kind.STORE),\n@@ -273,1 +271,1 @@\n-    ASTORE_1(ClassFile.ASTORE_1, 1, Kind.STORE, TypeKind.ReferenceType, 1),\n+    ASTORE_1(ClassFile.ASTORE_1, 1, Kind.STORE),\n@@ -276,1 +274,1 @@\n-    ASTORE_2(ClassFile.ASTORE_2, 1, Kind.STORE, TypeKind.ReferenceType, 2),\n+    ASTORE_2(ClassFile.ASTORE_2, 1, Kind.STORE),\n@@ -279,1 +277,1 @@\n-    ASTORE_3(ClassFile.ASTORE_3, 1, Kind.STORE, TypeKind.ReferenceType, 3),\n+    ASTORE_3(ClassFile.ASTORE_3, 1, Kind.STORE),\n@@ -282,1 +280,1 @@\n-    IASTORE(ClassFile.IASTORE, 1, Kind.ARRAY_STORE, TypeKind.IntType),\n+    IASTORE(ClassFile.IASTORE, 1, Kind.ARRAY_STORE),\n@@ -285,1 +283,1 @@\n-    LASTORE(ClassFile.LASTORE, 1, Kind.ARRAY_STORE, TypeKind.LongType),\n+    LASTORE(ClassFile.LASTORE, 1, Kind.ARRAY_STORE),\n@@ -288,1 +286,1 @@\n-    FASTORE(ClassFile.FASTORE, 1, Kind.ARRAY_STORE, TypeKind.FloatType),\n+    FASTORE(ClassFile.FASTORE, 1, Kind.ARRAY_STORE),\n@@ -291,1 +289,1 @@\n-    DASTORE(ClassFile.DASTORE, 1, Kind.ARRAY_STORE, TypeKind.DoubleType),\n+    DASTORE(ClassFile.DASTORE, 1, Kind.ARRAY_STORE),\n@@ -294,1 +292,1 @@\n-    AASTORE(ClassFile.AASTORE, 1, Kind.ARRAY_STORE, TypeKind.ReferenceType),\n+    AASTORE(ClassFile.AASTORE, 1, Kind.ARRAY_STORE),\n@@ -297,1 +295,1 @@\n-    BASTORE(ClassFile.BASTORE, 1, Kind.ARRAY_STORE, TypeKind.ByteType),\n+    BASTORE(ClassFile.BASTORE, 1, Kind.ARRAY_STORE),\n@@ -300,1 +298,1 @@\n-    CASTORE(ClassFile.CASTORE, 1, Kind.ARRAY_STORE, TypeKind.CharType),\n+    CASTORE(ClassFile.CASTORE, 1, Kind.ARRAY_STORE),\n@@ -303,1 +301,1 @@\n-    SASTORE(ClassFile.SASTORE, 1, Kind.ARRAY_STORE, TypeKind.ShortType),\n+    SASTORE(ClassFile.SASTORE, 1, Kind.ARRAY_STORE),\n@@ -333,1 +331,1 @@\n-    IADD(ClassFile.IADD, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IADD(ClassFile.IADD, 1, Kind.OPERATOR),\n@@ -336,1 +334,1 @@\n-    LADD(ClassFile.LADD, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LADD(ClassFile.LADD, 1, Kind.OPERATOR),\n@@ -339,1 +337,1 @@\n-    FADD(ClassFile.FADD, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FADD(ClassFile.FADD, 1, Kind.OPERATOR),\n@@ -342,1 +340,1 @@\n-    DADD(ClassFile.DADD, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DADD(ClassFile.DADD, 1, Kind.OPERATOR),\n@@ -345,1 +343,1 @@\n-    ISUB(ClassFile.ISUB, 1, Kind.OPERATOR, TypeKind.IntType),\n+    ISUB(ClassFile.ISUB, 1, Kind.OPERATOR),\n@@ -348,1 +346,1 @@\n-    LSUB(ClassFile.LSUB, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LSUB(ClassFile.LSUB, 1, Kind.OPERATOR),\n@@ -351,1 +349,1 @@\n-    FSUB(ClassFile.FSUB, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FSUB(ClassFile.FSUB, 1, Kind.OPERATOR),\n@@ -354,1 +352,1 @@\n-    DSUB(ClassFile.DSUB, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DSUB(ClassFile.DSUB, 1, Kind.OPERATOR),\n@@ -357,1 +355,1 @@\n-    IMUL(ClassFile.IMUL, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IMUL(ClassFile.IMUL, 1, Kind.OPERATOR),\n@@ -360,1 +358,1 @@\n-    LMUL(ClassFile.LMUL, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LMUL(ClassFile.LMUL, 1, Kind.OPERATOR),\n@@ -363,1 +361,1 @@\n-    FMUL(ClassFile.FMUL, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FMUL(ClassFile.FMUL, 1, Kind.OPERATOR),\n@@ -366,1 +364,1 @@\n-    DMUL(ClassFile.DMUL, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DMUL(ClassFile.DMUL, 1, Kind.OPERATOR),\n@@ -369,1 +367,1 @@\n-    IDIV(ClassFile.IDIV, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IDIV(ClassFile.IDIV, 1, Kind.OPERATOR),\n@@ -372,1 +370,1 @@\n-    LDIV(ClassFile.LDIV, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LDIV(ClassFile.LDIV, 1, Kind.OPERATOR),\n@@ -375,1 +373,1 @@\n-    FDIV(ClassFile.FDIV, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FDIV(ClassFile.FDIV, 1, Kind.OPERATOR),\n@@ -378,1 +376,1 @@\n-    DDIV(ClassFile.DDIV, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DDIV(ClassFile.DDIV, 1, Kind.OPERATOR),\n@@ -381,1 +379,1 @@\n-    IREM(ClassFile.IREM, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IREM(ClassFile.IREM, 1, Kind.OPERATOR),\n@@ -384,1 +382,1 @@\n-    LREM(ClassFile.LREM, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LREM(ClassFile.LREM, 1, Kind.OPERATOR),\n@@ -387,1 +385,1 @@\n-    FREM(ClassFile.FREM, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FREM(ClassFile.FREM, 1, Kind.OPERATOR),\n@@ -390,1 +388,1 @@\n-    DREM(ClassFile.DREM, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DREM(ClassFile.DREM, 1, Kind.OPERATOR),\n@@ -393,1 +391,1 @@\n-    INEG(ClassFile.INEG, 1, Kind.OPERATOR, TypeKind.IntType),\n+    INEG(ClassFile.INEG, 1, Kind.OPERATOR),\n@@ -396,1 +394,1 @@\n-    LNEG(ClassFile.LNEG, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LNEG(ClassFile.LNEG, 1, Kind.OPERATOR),\n@@ -399,1 +397,1 @@\n-    FNEG(ClassFile.FNEG, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FNEG(ClassFile.FNEG, 1, Kind.OPERATOR),\n@@ -402,1 +400,1 @@\n-    DNEG(ClassFile.DNEG, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DNEG(ClassFile.DNEG, 1, Kind.OPERATOR),\n@@ -405,1 +403,1 @@\n-    ISHL(ClassFile.ISHL, 1, Kind.OPERATOR, TypeKind.IntType),\n+    ISHL(ClassFile.ISHL, 1, Kind.OPERATOR),\n@@ -408,1 +406,1 @@\n-    LSHL(ClassFile.LSHL, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LSHL(ClassFile.LSHL, 1, Kind.OPERATOR),\n@@ -411,1 +409,1 @@\n-    ISHR(ClassFile.ISHR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    ISHR(ClassFile.ISHR, 1, Kind.OPERATOR),\n@@ -414,1 +412,1 @@\n-    LSHR(ClassFile.LSHR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LSHR(ClassFile.LSHR, 1, Kind.OPERATOR),\n@@ -417,1 +415,1 @@\n-    IUSHR(ClassFile.IUSHR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IUSHR(ClassFile.IUSHR, 1, Kind.OPERATOR),\n@@ -420,1 +418,1 @@\n-    LUSHR(ClassFile.LUSHR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LUSHR(ClassFile.LUSHR, 1, Kind.OPERATOR),\n@@ -423,1 +421,1 @@\n-    IAND(ClassFile.IAND, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IAND(ClassFile.IAND, 1, Kind.OPERATOR),\n@@ -426,1 +424,1 @@\n-    LAND(ClassFile.LAND, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LAND(ClassFile.LAND, 1, Kind.OPERATOR),\n@@ -429,1 +427,1 @@\n-    IOR(ClassFile.IOR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IOR(ClassFile.IOR, 1, Kind.OPERATOR),\n@@ -432,1 +430,1 @@\n-    LOR(ClassFile.LOR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LOR(ClassFile.LOR, 1, Kind.OPERATOR),\n@@ -435,1 +433,1 @@\n-    IXOR(ClassFile.IXOR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IXOR(ClassFile.IXOR, 1, Kind.OPERATOR),\n@@ -438,1 +436,1 @@\n-    LXOR(ClassFile.LXOR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LXOR(ClassFile.LXOR, 1, Kind.OPERATOR),\n@@ -441,1 +439,1 @@\n-    IINC(ClassFile.IINC, 3, Kind.INCREMENT, TypeKind.IntType, -1),\n+    IINC(ClassFile.IINC, 3, Kind.INCREMENT),\n@@ -444,1 +442,1 @@\n-    I2L(ClassFile.I2L, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.LongType),\n+    I2L(ClassFile.I2L, 1, Kind.CONVERT),\n@@ -447,1 +445,1 @@\n-    I2F(ClassFile.I2F, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.FloatType),\n+    I2F(ClassFile.I2F, 1, Kind.CONVERT),\n@@ -450,1 +448,1 @@\n-    I2D(ClassFile.I2D, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.DoubleType),\n+    I2D(ClassFile.I2D, 1, Kind.CONVERT),\n@@ -453,1 +451,1 @@\n-    L2I(ClassFile.L2I, 1, Kind.CONVERT, TypeKind.LongType, TypeKind.IntType),\n+    L2I(ClassFile.L2I, 1, Kind.CONVERT),\n@@ -456,1 +454,1 @@\n-    L2F(ClassFile.L2F, 1, Kind.CONVERT, TypeKind.LongType, TypeKind.FloatType),\n+    L2F(ClassFile.L2F, 1, Kind.CONVERT),\n@@ -459,1 +457,1 @@\n-    L2D(ClassFile.L2D, 1, Kind.CONVERT, TypeKind.LongType, TypeKind.DoubleType),\n+    L2D(ClassFile.L2D, 1, Kind.CONVERT),\n@@ -462,1 +460,1 @@\n-    F2I(ClassFile.F2I, 1, Kind.CONVERT, TypeKind.FloatType, TypeKind.IntType),\n+    F2I(ClassFile.F2I, 1, Kind.CONVERT),\n@@ -465,1 +463,1 @@\n-    F2L(ClassFile.F2L, 1, Kind.CONVERT, TypeKind.FloatType, TypeKind.LongType),\n+    F2L(ClassFile.F2L, 1, Kind.CONVERT),\n@@ -468,1 +466,1 @@\n-    F2D(ClassFile.F2D, 1, Kind.CONVERT, TypeKind.FloatType, TypeKind.DoubleType),\n+    F2D(ClassFile.F2D, 1, Kind.CONVERT),\n@@ -471,1 +469,1 @@\n-    D2I(ClassFile.D2I, 1, Kind.CONVERT, TypeKind.DoubleType, TypeKind.IntType),\n+    D2I(ClassFile.D2I, 1, Kind.CONVERT),\n@@ -474,1 +472,1 @@\n-    D2L(ClassFile.D2L, 1, Kind.CONVERT, TypeKind.DoubleType, TypeKind.LongType),\n+    D2L(ClassFile.D2L, 1, Kind.CONVERT),\n@@ -477,1 +475,1 @@\n-    D2F(ClassFile.D2F, 1, Kind.CONVERT, TypeKind.DoubleType, TypeKind.FloatType),\n+    D2F(ClassFile.D2F, 1, Kind.CONVERT),\n@@ -480,1 +478,1 @@\n-    I2B(ClassFile.I2B, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.ByteType),\n+    I2B(ClassFile.I2B, 1, Kind.CONVERT),\n@@ -483,1 +481,1 @@\n-    I2C(ClassFile.I2C, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.CharType),\n+    I2C(ClassFile.I2C, 1, Kind.CONVERT),\n@@ -486,1 +484,1 @@\n-    I2S(ClassFile.I2S, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.ShortType),\n+    I2S(ClassFile.I2S, 1, Kind.CONVERT),\n@@ -489,1 +487,1 @@\n-    LCMP(ClassFile.LCMP, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LCMP(ClassFile.LCMP, 1, Kind.OPERATOR),\n@@ -492,1 +490,1 @@\n-    FCMPL(ClassFile.FCMPL, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FCMPL(ClassFile.FCMPL, 1, Kind.OPERATOR),\n@@ -495,1 +493,1 @@\n-    FCMPG(ClassFile.FCMPG, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FCMPG(ClassFile.FCMPG, 1, Kind.OPERATOR),\n@@ -498,1 +496,1 @@\n-    DCMPL(ClassFile.DCMPL, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DCMPL(ClassFile.DCMPL, 1, Kind.OPERATOR),\n@@ -501,1 +499,1 @@\n-    DCMPG(ClassFile.DCMPG, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DCMPG(ClassFile.DCMPG, 1, Kind.OPERATOR),\n@@ -504,1 +502,1 @@\n-    IFEQ(ClassFile.IFEQ, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFEQ(ClassFile.IFEQ, 3, Kind.BRANCH),\n@@ -507,1 +505,1 @@\n-    IFNE(ClassFile.IFNE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFNE(ClassFile.IFNE, 3, Kind.BRANCH),\n@@ -510,1 +508,1 @@\n-    IFLT(ClassFile.IFLT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFLT(ClassFile.IFLT, 3, Kind.BRANCH),\n@@ -513,1 +511,1 @@\n-    IFGE(ClassFile.IFGE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFGE(ClassFile.IFGE, 3, Kind.BRANCH),\n@@ -516,1 +514,1 @@\n-    IFGT(ClassFile.IFGT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFGT(ClassFile.IFGT, 3, Kind.BRANCH),\n@@ -519,1 +517,1 @@\n-    IFLE(ClassFile.IFLE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFLE(ClassFile.IFLE, 3, Kind.BRANCH),\n@@ -522,1 +520,1 @@\n-    IF_ICMPEQ(ClassFile.IF_ICMPEQ, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPEQ(ClassFile.IF_ICMPEQ, 3, Kind.BRANCH),\n@@ -525,1 +523,1 @@\n-    IF_ICMPNE(ClassFile.IF_ICMPNE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPNE(ClassFile.IF_ICMPNE, 3, Kind.BRANCH),\n@@ -528,1 +526,1 @@\n-    IF_ICMPLT(ClassFile.IF_ICMPLT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPLT(ClassFile.IF_ICMPLT, 3, Kind.BRANCH),\n@@ -531,1 +529,1 @@\n-    IF_ICMPGE(ClassFile.IF_ICMPGE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPGE(ClassFile.IF_ICMPGE, 3, Kind.BRANCH),\n@@ -534,1 +532,1 @@\n-    IF_ICMPGT(ClassFile.IF_ICMPGT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPGT(ClassFile.IF_ICMPGT, 3, Kind.BRANCH),\n@@ -537,1 +535,1 @@\n-    IF_ICMPLE(ClassFile.IF_ICMPLE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPLE(ClassFile.IF_ICMPLE, 3, Kind.BRANCH),\n@@ -540,1 +538,1 @@\n-    IF_ACMPEQ(ClassFile.IF_ACMPEQ, 3, Kind.BRANCH, TypeKind.ReferenceType),\n+    IF_ACMPEQ(ClassFile.IF_ACMPEQ, 3, Kind.BRANCH),\n@@ -543,1 +541,1 @@\n-    IF_ACMPNE(ClassFile.IF_ACMPNE, 3, Kind.BRANCH, TypeKind.ReferenceType),\n+    IF_ACMPNE(ClassFile.IF_ACMPNE, 3, Kind.BRANCH),\n@@ -546,1 +544,1 @@\n-    GOTO(ClassFile.GOTO, 3, Kind.BRANCH, TypeKind.VoidType),\n+    GOTO(ClassFile.GOTO, 3, Kind.BRANCH),\n@@ -567,1 +565,1 @@\n-    IRETURN(ClassFile.IRETURN, 1, Kind.RETURN, TypeKind.IntType),\n+    IRETURN(ClassFile.IRETURN, 1, Kind.RETURN),\n@@ -570,1 +568,1 @@\n-    LRETURN(ClassFile.LRETURN, 1, Kind.RETURN, TypeKind.LongType),\n+    LRETURN(ClassFile.LRETURN, 1, Kind.RETURN),\n@@ -573,1 +571,1 @@\n-    FRETURN(ClassFile.FRETURN, 1, Kind.RETURN, TypeKind.FloatType),\n+    FRETURN(ClassFile.FRETURN, 1, Kind.RETURN),\n@@ -576,1 +574,1 @@\n-    DRETURN(ClassFile.DRETURN, 1, Kind.RETURN, TypeKind.DoubleType),\n+    DRETURN(ClassFile.DRETURN, 1, Kind.RETURN),\n@@ -579,1 +577,1 @@\n-    ARETURN(ClassFile.ARETURN, 1, Kind.RETURN, TypeKind.ReferenceType),\n+    ARETURN(ClassFile.ARETURN, 1, Kind.RETURN),\n@@ -582,1 +580,1 @@\n-    RETURN(ClassFile.RETURN, 1, Kind.RETURN, TypeKind.VoidType),\n+    RETURN(ClassFile.RETURN, 1, Kind.RETURN),\n@@ -624,1 +622,1 @@\n-    ARRAYLENGTH(ClassFile.ARRAYLENGTH, 1, Kind.OPERATOR, TypeKind.IntType),\n+    ARRAYLENGTH(ClassFile.ARRAYLENGTH, 1, Kind.OPERATOR),\n@@ -645,1 +643,1 @@\n-    IFNULL(ClassFile.IFNULL, 3, Kind.BRANCH, TypeKind.ReferenceType),\n+    IFNULL(ClassFile.IFNULL, 3, Kind.BRANCH),\n@@ -648,1 +646,1 @@\n-    IFNONNULL(ClassFile.IFNONNULL, 3, Kind.BRANCH, TypeKind.ReferenceType),\n+    IFNONNULL(ClassFile.IFNONNULL, 3, Kind.BRANCH),\n@@ -651,1 +649,1 @@\n-    GOTO_W(ClassFile.GOTO_W, 5, Kind.BRANCH, TypeKind.VoidType),\n+    GOTO_W(ClassFile.GOTO_W, 5, Kind.BRANCH),\n@@ -660,1 +658,1 @@\n-    ILOAD_W((ClassFile.WIDE << 8) | ClassFile.ILOAD, 4, Kind.LOAD, TypeKind.IntType, -1),\n+    ILOAD_W((ClassFile.WIDE << 8) | ClassFile.ILOAD, 4, Kind.LOAD),\n@@ -663,1 +661,1 @@\n-    LLOAD_W((ClassFile.WIDE << 8) | ClassFile.LLOAD, 4, Kind.LOAD, TypeKind.LongType, -1),\n+    LLOAD_W((ClassFile.WIDE << 8) | ClassFile.LLOAD, 4, Kind.LOAD),\n@@ -666,1 +664,1 @@\n-    FLOAD_W((ClassFile.WIDE << 8) | ClassFile.FLOAD, 4, Kind.LOAD, TypeKind.FloatType, -1),\n+    FLOAD_W((ClassFile.WIDE << 8) | ClassFile.FLOAD, 4, Kind.LOAD),\n@@ -669,1 +667,1 @@\n-    DLOAD_W((ClassFile.WIDE << 8) | ClassFile.DLOAD, 4, Kind.LOAD, TypeKind.DoubleType, -1),\n+    DLOAD_W((ClassFile.WIDE << 8) | ClassFile.DLOAD, 4, Kind.LOAD),\n@@ -672,1 +670,1 @@\n-    ALOAD_W((ClassFile.WIDE << 8) | ClassFile.ALOAD, 4, Kind.LOAD, TypeKind.ReferenceType, -1),\n+    ALOAD_W((ClassFile.WIDE << 8) | ClassFile.ALOAD, 4, Kind.LOAD),\n@@ -675,1 +673,1 @@\n-    ISTORE_W((ClassFile.WIDE << 8) | ClassFile.ISTORE, 4, Kind.STORE, TypeKind.IntType, -1),\n+    ISTORE_W((ClassFile.WIDE << 8) | ClassFile.ISTORE, 4, Kind.STORE),\n@@ -678,1 +676,1 @@\n-    LSTORE_W((ClassFile.WIDE << 8) | ClassFile.LSTORE, 4, Kind.STORE, TypeKind.LongType, -1),\n+    LSTORE_W((ClassFile.WIDE << 8) | ClassFile.LSTORE, 4, Kind.STORE),\n@@ -681,1 +679,1 @@\n-    FSTORE_W((ClassFile.WIDE << 8) | ClassFile.FSTORE, 4, Kind.STORE, TypeKind.FloatType, -1),\n+    FSTORE_W((ClassFile.WIDE << 8) | ClassFile.FSTORE, 4, Kind.STORE),\n@@ -684,1 +682,1 @@\n-    DSTORE_W((ClassFile.WIDE << 8) | ClassFile.DSTORE, 4, Kind.STORE, TypeKind.DoubleType, -1),\n+    DSTORE_W((ClassFile.WIDE << 8) | ClassFile.DSTORE, 4, Kind.STORE),\n@@ -687,1 +685,1 @@\n-    ASTORE_W((ClassFile.WIDE << 8) | ClassFile.ASTORE, 4, Kind.STORE, TypeKind.ReferenceType, -1),\n+    ASTORE_W((ClassFile.WIDE << 8) | ClassFile.ASTORE, 4, Kind.STORE),\n@@ -696,1 +694,1 @@\n-    IINC_W((ClassFile.WIDE << 8) | ClassFile.IINC, 6, Kind.INCREMENT, TypeKind.IntType, -1);\n+    IINC_W((ClassFile.WIDE << 8) | ClassFile.IINC, 6, Kind.INCREMENT);\n@@ -1081,4 +1079,0 @@\n-    private final TypeKind primaryTypeKind;\n-    private final TypeKind secondaryTypeKind;\n-    private final int slot;\n-    private final ConstantDesc constantValue;\n@@ -1087,26 +1081,0 @@\n-        this(bytecode, sizeIfFixed, kind, null, null, -1, null);\n-    }\n-\n-    Opcode(int bytecode, int sizeIfFixed, Kind kind, TypeKind typeKind) {\n-        this(bytecode, sizeIfFixed, kind, typeKind, null, -1, null);\n-    }\n-\n-    Opcode(int bytecode, int sizeIfFixed, Kind kind, TypeKind typeKind, int slot) {\n-        this(bytecode, sizeIfFixed, kind, typeKind, null, slot, null);\n-    }\n-\n-    Opcode(int bytecode, int sizeIfFixed, Kind kind, TypeKind typeKind, int slot, ConstantDesc constantValue) {\n-        this(bytecode, sizeIfFixed, kind, typeKind, null, slot, constantValue);\n-    }\n-\n-    Opcode(int bytecode, int sizeIfFixed, Kind kind, TypeKind primaryTypeKind, TypeKind secondaryTypeKind) {\n-        this(bytecode, sizeIfFixed, kind, primaryTypeKind, secondaryTypeKind, 0, null);\n-    }\n-\n-    Opcode(int bytecode,\n-           int sizeIfFixed,\n-           Kind kind,\n-           TypeKind primaryTypeKind,\n-           TypeKind secondaryTypeKind,\n-           int slot,\n-           ConstantDesc constantValue) {\n@@ -1116,4 +1084,0 @@\n-        this.primaryTypeKind = primaryTypeKind;\n-        this.secondaryTypeKind = secondaryTypeKind;\n-        this.slot = slot;\n-        this.constantValue = constantValue;\n@@ -1123,1 +1087,3 @@\n-     * {@return bytecode}\n+     * {@return the opcode value} For {@linkplain #isWide() wide} pseudo-opcodes, returns the\n+     * first 2 bytes of the instruction, which are the {@code wide} opcode and the functional\n+     * local variable opcode, as a U2 value.\n@@ -1128,1 +1094,14 @@\n-     * {@return true if the instruction has extended local variable index by additional bytes}\n+     * {@return true if this is a pseudo-opcode modified by {@code wide}}\n+     *\n+     * @see #ILOAD_W\n+     * @see #LLOAD_W\n+     * @see #FLOAD_W\n+     * @see #DLOAD_W\n+     * @see #ALOAD_W\n+     * @see #ISTORE_W\n+     * @see #LSTORE_W\n+     * @see #FSTORE_W\n+     * @see #DSTORE_W\n+     * @see #ASTORE_W\n+     * @see #RET_W\n+     * @see #IINC_W\n@@ -1133,1 +1112,2 @@\n-     * {@return size of the instruction if fixed, or -1 otherwise}\n+     * {@return size of the instruction in bytes if fixed, or -1 otherwise} This size includes\n+     * the opcode itself.\n@@ -1141,38 +1121,0 @@\n-\n-    \/**\n-     * {@return primary type kind for instructions operating with at least one type, or null otherwise}\n-     *\/\n-    public TypeKind primaryTypeKind() {\n-        return primaryTypeKind;\n-    }\n-\n-    \/**\n-     * {@return secondary type kind for instructions operating with two types, or null otherwise}\n-     *\/\n-    public TypeKind secondaryTypeKind() {\n-        return secondaryTypeKind;\n-    }\n-\n-    \/**\n-     * {@return local variable slot for instructions operating with local variable, or -1 otherwise}\n-     *\/\n-    public int slot() {\n-        return slot;\n-    }\n-\n-    \/**\n-     * {@return constant value for constant instructions, or null otherwise}\n-     *\/\n-    public ConstantDesc constantValue() {\n-        return constantValue;\n-    }\n-\n-    \/**\n-     * {@return true if the instruction represents an unconditional branch}\n-     *\/\n-    public boolean isUnconditionalBranch() {\n-        return switch (this) {\n-            case GOTO, ATHROW, GOTO_W, LOOKUPSWITCH, TABLESWITCH -> true;\n-            default -> kind() == Kind.RETURN;\n-        };\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Opcode.java","additions":197,"deletions":255,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * Models generic Java type signatures, as defined in {@jvms 4.7.9.1}.\n+ * Models generic Java type signatures, as defined in JVMS {@jvms 4.7.9.1}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Signature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.lang.constant.ClassDesc;\n@@ -33,1 +32,0 @@\n-import java.lang.classfile.constantpool.Utf8Entry;\n@@ -59,1 +57,0 @@\n-import jdk.internal.classfile.impl.TemporaryConstantPool;\n@@ -63,1 +60,11 @@\n- * Models an annotation on a type use, as defined in {@jvms 4.7.19} and {@jvms 4.7.20}.\n+ * Models a {@code type_annotation} structure (JVMS {@jvms 4.7.20}). This model\n+ * indicates the annotated type within a declaration or expression and the part\n+ * of the indicated type that is annotated, in addition to what is {@linkplain\n+ * #annotation() available} in an {@code Annotation}.\n+ * <p>\n+ * This model can reconstruct an annotation on a type or a part of a type, given\n+ * the location of the {@code type_annotation} structure in the class file and\n+ * the definition of the annotation interface.\n+ * <p>\n+ * Two {@code TypeAnnotation} objects should be compared using the {@link\n+ * Object#equals(Object) equals} method.\n@@ -65,0 +72,1 @@\n+ * @see Annotation\n@@ -72,1 +80,0 @@\n-        extends Annotation\n@@ -76,1 +83,1 @@\n-     * The kind of target on which the annotation appears, as defined in {@jvms 4.7.20.1}.\n+     * The kind of target on which the annotation appears, as defined in JVMS {@jvms 4.7.20.1}.\n@@ -173,1 +180,1 @@\n-     * is annotated}\n+     * is annotated} This models the {@code target_type} and {@code target_info} items.\n@@ -183,19 +190,4 @@\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClassUtf8Entry the annotation class\n-     * @param annotationElements the annotation elements\n-     *\/\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             Utf8Entry annotationClassUtf8Entry,\n-                             List<AnnotationElement> annotationElements) {\n-        return new UnboundAttribute.UnboundTypeAnnotation(targetInfo, targetPath,\n-                annotationClassUtf8Entry, annotationElements);\n-    }\n-\n-    \/**\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClass the annotation class\n-     * @param annotationElements the annotation elements\n+     * {@return the annotation applied to the part indicated by {@link #targetPath()}}\n+     * This models the interface of the annotation and the set of element-value pairs,\n+     * the subset of the {@code type_annotation} structure that is identical to the\n+     * {@code annotation} structure.\n@@ -203,19 +195,1 @@\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             ClassDesc annotationClass,\n-                             AnnotationElement... annotationElements) {\n-        return of(targetInfo, targetPath, annotationClass, List.of(annotationElements));\n-    }\n-\n-    \/**\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClass the annotation class\n-     * @param annotationElements the annotation elements\n-     *\/\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             ClassDesc annotationClass,\n-                             List<AnnotationElement> annotationElements) {\n-        return of(targetInfo, targetPath,\n-                TemporaryConstantPool.INSTANCE.utf8Entry(annotationClass.descriptorString()), annotationElements);\n-    }\n+    Annotation annotation();\n@@ -224,1 +198,1 @@\n-     * {@return a type annotation}\n+     * {@return a {@code type_annotation} structure}\n@@ -227,2 +201,1 @@\n-     * @param annotationClassUtf8Entry the annotation class\n-     * @param annotationElements the annotation elements\n+     * @param annotation the annotation\n@@ -231,3 +204,2 @@\n-                             Utf8Entry annotationClassUtf8Entry,\n-                             AnnotationElement... annotationElements) {\n-        return of(targetInfo, targetPath, annotationClassUtf8Entry, List.of(annotationElements));\n+                             Annotation annotation) {\n+        return new UnboundAttribute.UnboundTypeAnnotation(targetInfo, targetPath, annotation);\n@@ -776,1 +748,1 @@\n-     * as defined in {@jvms 4.7.20.2}\n+     * as defined in JVMS {@jvms 4.7.20.2}\n@@ -785,1 +757,1 @@\n-         * Type path kind, as defined in {@jvms 4.7.20.2}\n+         * Type path kind, as defined in JVMS {@jvms 4.7.20.2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeAnnotation.java","additions":26,"deletions":54,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import java.lang.classfile.instruction.DiscontinuedInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n@@ -30,0 +33,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -32,1 +36,7 @@\n- * Describes the types that can be part of a field or method descriptor.\n+ * Describes the data types Java Virtual Machine operates on.\n+ * This omits {@code returnAddress} (JVMS {@jvms 2.3.3}),\n+ * which is only used by discontinued {@link\n+ * DiscontinuedInstruction.JsrInstruction jsr} and {@link\n+ * DiscontinuedInstruction.RetInstruction ret} instructions,\n+ * and includes {@link #VOID void} (JVMS {@jvms 4.3.3}), which\n+ * appears as a method return type.\n@@ -34,0 +44,12 @@\n+ * <h2 id=\"computational-type\">Computational Type<\/h2>\n+ * In the {@code class} file format, local variables (JVMS {@jvms 2.6.1}),\n+ * and the operand stack (JVMS {@jvms 2.6.2}) of the Java Virtual Machine,\n+ * {@link #BOOLEAN boolean}, {@link #BYTE byte}, {@link #CHAR char},\n+ * {@link #SHORT short} types do not exist and are {@linkplain\n+ * #asLoadable() represented} by the {@link #INT int} computational type.\n+ * {@link #INT int}, {@link #FLOAT float}, {@link #REFERENCE reference},\n+ * {@code returnAddress}, {@link #LONG long}, and {@link #DOUBLE doule}\n+ * are the computational types of the Java Virtual Machine.\n+ *\n+ * @jvms 2.2 Data Types\n+ * @jvms 2.11.1 Types and the Java Virtual Machine\n@@ -38,20 +60,67 @@\n-    \/** the primitive type byte *\/\n-    ByteType(\"byte\", \"B\", 8),\n-    \/** the primitive type short *\/\n-    ShortType(\"short\", \"S\", 9),\n-    \/** the primitive type int *\/\n-    IntType(\"int\", \"I\", 10),\n-    \/** the primitive type float *\/\n-    FloatType(\"float\", \"F\", 6),\n-    \/** the primitive type long *\/\n-    LongType(\"long\", \"J\", 11),\n-    \/** the primitive type double *\/\n-    DoubleType(\"double\", \"D\", 7),\n-    \/** a reference type *\/\n-    ReferenceType(\"reference type\", \"L\", -1),\n-    \/** the primitive type char *\/\n-    CharType(\"char\", \"C\", 5),\n-    \/** the primitive type boolean *\/\n-    BooleanType(\"boolean\", \"Z\", 4),\n-    \/** void *\/\n-    VoidType(\"void\", \"V\", -1);\n+    \/\/ Elements are grouped so frequently used switch ranges such as\n+    \/\/ primitives (boolean - double) and computational (int - void) are together.\n+    \/\/ This also follows the order of typed opcodes\n+    \/\/ Begin primitive types\n+    \/**\n+     * The primitive type {@code boolean}. Its {@linkplain ##computational-type\n+     * computational type} is {@link #INT int}. {@code 0} represents {@code false},\n+     * and {@code 1} represents {@code true}. It is zero-extended to an {@code int}\n+     * when loaded onto the operand stack and narrowed by taking the bitwise AND\n+     * with {@code 1} when stored.\n+     *\n+     * @jvms 2.3.4 The {@code boolean} Type\n+     *\/\n+    BOOLEAN(1, 4),\n+    \/**\n+     * The primitive type {@code byte}. Its {@linkplain ##computational-type\n+     * computational type} is {@link #INT int}. It is sign-extended to an\n+     * {@code int} when loaded onto the operand stack and truncated when\n+     * stored.\n+     *\/\n+    BYTE(1, 8),\n+    \/**\n+     * The primitive type {@code char}. Its {@linkplain ##computational-type\n+     * computational type} is {@link #INT int}. It is zero-extended to an\n+     * {@code int} when loaded onto the operand stack and truncated when\n+     * stored.\n+     *\/\n+    CHAR(1, 5),\n+    \/**\n+     * The primitive type {@code short}. Its {@linkplain ##computational-type\n+     * computational type} is {@link #INT int}. It is sign-extended to an\n+     * {@code int} when loaded onto the operand stack and truncated when\n+     * stored.\n+     *\/\n+    SHORT(1, 9),\n+    \/\/ Begin computational types\n+    \/**\n+     * The primitive type {@code int}.\n+     *\/\n+    INT(1, 10),\n+    \/**\n+     * The primitive type {@code long}. It is of {@linkplain #slotSize() category} 2.\n+     *\/\n+    LONG(2, 11),\n+    \/**\n+     * The primitive type {@code float}.\n+     *\/\n+    FLOAT(1, 6),\n+    \/**\n+     * The primitive type {@code double}. It is of {@linkplain #slotSize() category} 2.\n+     *\/\n+    DOUBLE(2, 7),\n+    \/\/ End primitive types\n+    \/**\n+     * A reference type.\n+     * @jvms 2.4 Reference Types and Values\n+     *\/\n+    REFERENCE(1, -1),\n+    \/**\n+     * The {@code void} type, for absence of a value. While this is not a data type,\n+     * this can be a method return type indicating no change in {@linkplain #slotSize()\n+     * operand stack depth}.\n+     *\n+     * @jvms 4.3.3 Method Descriptors\n+     *\/\n+    VOID(0, -1);\n+    \/\/ End computational types\n@@ -59,2 +128,2 @@\n-    private final String name;\n-    private final String descriptor;\n+    private @Stable ClassDesc upperBound;\n+    private final int slots;\n@@ -63,2 +132,4 @@\n-    \/** {@return the human-readable name corresponding to this type} *\/\n-    public String typeName() { return name; }\n+    TypeKind(int slots, int newarrayCode) {\n+        this.slots = slots;\n+        this.newarrayCode = newarrayCode;\n+    }\n@@ -66,2 +137,27 @@\n-    \/** {@return the field descriptor character corresponding to this type} *\/\n-    public String descriptor() { return descriptor; }\n+    \/**\n+     * {@return the most specific upper bound field descriptor that can store any value\n+     * of this type} This is the primitive class descriptor for primitive types and\n+     * {@link #VOID void} and {@link ConstantDescs#CD_Object Object} descriptor for\n+     * {@link #REFERENCE reference}.\n+     *\/\n+    public ClassDesc upperBound() {\n+        var upper = this.upperBound;\n+        if (upper == null)\n+            return this.upperBound = fetchUpperBound();\n+        return upper;\n+    }\n+\n+    private ClassDesc fetchUpperBound() {\n+        return switch (this) {\n+            case BOOLEAN -> ConstantDescs.CD_boolean;\n+            case BYTE -> ConstantDescs.CD_byte;\n+            case CHAR -> ConstantDescs.CD_char;\n+            case SHORT -> ConstantDescs.CD_short;\n+            case INT -> ConstantDescs.CD_int;\n+            case FLOAT -> ConstantDescs.CD_float;\n+            case LONG -> ConstantDescs.CD_long;\n+            case DOUBLE -> ConstantDescs.CD_double;\n+            case REFERENCE -> ConstantDescs.CD_Object;\n+            case VOID -> ConstantDescs.CD_void;\n+        };\n+    }\n@@ -70,1 +166,2 @@\n-     * {@return the code used by the {@code newarray} opcode corresponding to this type}\n+     * {@return the code used by the {@link Opcode#NEWARRAY newarray} instruction to create an array\n+     * of this component type, or {@code -1} if this type is not supported by {@code newarray}}\n@@ -72,0 +169,1 @@\n+     * @jvms 6.5.newarray <i>newarray<\/i>\n@@ -78,1 +176,6 @@\n-     * {@return the number of local variable slots consumed by this type}\n+     * {@return the number of local variable index or operand stack depth consumed by this type}\n+     * This is also the category of this type for instructions operating on the operand stack without\n+     * regard to type (JVMS {@jvms 2.11.1}), such as {@link Opcode#POP pop} versus {@link Opcode#POP2\n+     * pop2}.\n+     * @jvms 2.6.1 Local Variables\n+     * @jvms 2.6.2 Operand Stacks\n@@ -81,5 +184,1 @@\n-        return switch (this) {\n-            case VoidType -> 0;\n-            case LongType, DoubleType -> 2;\n-            default -> 1;\n-        };\n+        return this.slots;\n@@ -89,3 +188,2 @@\n-     * Erase this type kind to the type which will be used for xLOAD, xSTORE,\n-     * and xRETURN bytecodes\n-     * @return the erased type kind\n+     * {@return the {@linkplain ##computational-type computational type} for this type, or {@link #VOID void}\n+     * for {@code void}}\n@@ -94,10 +192,1 @@\n-        return switch (this) {\n-            case BooleanType, ByteType, CharType, ShortType -> TypeKind.IntType;\n-            default -> this;\n-        };\n-    }\n-\n-    TypeKind(String name, String descriptor, int newarrayCode) {\n-        this.name = name;\n-        this.descriptor = descriptor;\n-        this.newarrayCode = newarrayCode;\n+        return ordinal() < 4 ? INT : this;\n@@ -107,2 +196,2 @@\n-     * {@return the type kind associated with the array type described by the\n-     * array code used as an operand to {@code newarray}}\n+     * {@return the component type described by the array code used as an operand to {@link Opcode#NEWARRAY\n+     * newarray}}\n@@ -112,0 +201,1 @@\n+     * @jvms 6.5.newarray <i>newarray<\/i>\n@@ -115,8 +205,8 @@\n-            case 4 -> TypeKind.BooleanType;\n-            case 5 -> TypeKind.CharType;\n-            case 6 -> TypeKind.FloatType;\n-            case 7 -> TypeKind.DoubleType;\n-            case 8 -> TypeKind.ByteType;\n-            case 9 -> TypeKind.ShortType;\n-            case 10 -> TypeKind.IntType;\n-            case 11 -> TypeKind.LongType;\n+            case 4 -> BOOLEAN;\n+            case 5 -> CHAR;\n+            case 6 -> FLOAT;\n+            case 7 -> DOUBLE;\n+            case 8 -> BYTE;\n+            case 9 -> SHORT;\n+            case 10 -> INT;\n+            case 11 -> LONG;\n@@ -128,1 +218,1 @@\n-     * {@return the type kind associated with the specified field descriptor}\n+     * {@return the type associated with the specified field descriptor}\n@@ -137,10 +227,10 @@\n-            case '[', 'L' -> TypeKind.ReferenceType;\n-            case 'B' -> TypeKind.ByteType;\n-            case 'C' -> TypeKind.CharType;\n-            case 'Z' -> TypeKind.BooleanType;\n-            case 'S' -> TypeKind.ShortType;\n-            case 'I' -> TypeKind.IntType;\n-            case 'F' -> TypeKind.FloatType;\n-            case 'J' -> TypeKind.LongType;\n-            case 'D' -> TypeKind.DoubleType;\n-            case 'V' -> TypeKind.VoidType;\n+            case '[', 'L' -> REFERENCE;\n+            case 'B' -> BYTE;\n+            case 'C' -> CHAR;\n+            case 'Z' -> BOOLEAN;\n+            case 'S' -> SHORT;\n+            case 'I' -> INT;\n+            case 'F' -> FLOAT;\n+            case 'J' -> LONG;\n+            case 'D' -> DOUBLE;\n+            case 'V' -> VOID;\n@@ -152,1 +242,1 @@\n-     * {@return the type kind associated with the specified field descriptor}\n+     * {@return the type associated with the specified field descriptor}\n@@ -158,1 +248,1 @@\n-                : TypeKind.ReferenceType;\n+                : REFERENCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeKind.java","additions":160,"deletions":70,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code AnnotationDefault} attribute {@jvms 4.7.22}, which can\n+ * Models the {@code AnnotationDefault} attribute (JVMS {@jvms 4.7.22}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/AnnotationDefaultAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code BootstrapMethods} attribute {@jvms 4.7.23}, which serves as\n+ * Models the {@code BootstrapMethods} attribute (JVMS {@jvms 4.7.23}), which serves as\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/BootstrapMethodsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * Models the {@code Code} attribute {@jvms 4.7.3}, appears on non-native,\n+ * Models the {@code Code} attribute (JVMS {@jvms 4.7.3}), appears on non-native,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/CodeAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code ConstantValue} attribute {@jvms 4.7.2}, which can appear on\n+ * Models the {@code ConstantValue} attribute (JVMS {@jvms 4.7.2}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ConstantValueAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code Deprecated} attribute {@jvms 4.7.15}, which can appear on\n+ * Models the {@code Deprecated} attribute (JVMS {@jvms 4.7.15}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/DeprecatedAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * Models the {@code EnclosingMethod} attribute {@jvms 4.7.7}, which can appear\n+ * Models the {@code EnclosingMethod} attribute (JVMS {@jvms 4.7.7}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/EnclosingMethodAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * Models the {@code Exceptions} attribute {@jvms 4.7.5}, which can appear on\n+ * Models the {@code Exceptions} attribute (JVMS {@jvms 4.7.5}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ExceptionsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code InnerClasses} attribute {@jvms 4.7.6}, which can\n+ * Models the {@code InnerClasses} attribute (JVMS {@jvms 4.7.6}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/InnerClassesAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * Models the {@code LineNumberTable} attribute {@jvms 4.7.12}, which can appear\n+ * Models the {@code LineNumberTable} attribute (JVMS {@jvms 4.7.12}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LineNumberTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * Models the {@code LocalVariableTable} attribute {@jvms 4.7.13}, which can appear\n+ * Models the {@code LocalVariableTable} attribute (JVMS {@jvms 4.7.13}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LocalVariableTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code LocalVariableTypeTable} attribute {@jvms 4.7.14}, which can appear\n+ * Models the {@code LocalVariableTypeTable} attribute (JVMS {@jvms 4.7.14}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LocalVariableTypeTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code MethodParameters} attribute {@jvms 4.7.24}, which can\n+ * Models the {@code MethodParameters} attribute (JVMS {@jvms 4.7.24}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/MethodParametersAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * Models the {@code Module} attribute {@jvms 4.7.25}, which can\n+ * Models the {@code Module} attribute (JVMS {@jvms 4.7.25}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code ModuleMainClass} attribute {@jvms 4.7.27}, which can\n+ * Models the {@code ModuleMainClass} attribute (JVMS {@jvms 4.7.27}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleMainClassAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * Models the {@code ModulePackages} attribute {@jvms 4.7.26}, which can\n+ * Models the {@code ModulePackages} attribute (JVMS {@jvms 4.7.26}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModulePackagesAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code NestHost} attribute {@jvms 4.7.28}, which can\n+ * Models the {@code NestHost} attribute (JVMS {@jvms 4.7.28}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/NestHostAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * Models the {@code NestMembers} attribute {@jvms 4.7.29}, which can\n+ * Models the {@code NestMembers} attribute (JVMS {@jvms 4.7.29}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/NestMembersAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * Models the {@code PermittedSubclasses} attribute {@jvms 4.7.31}, which can\n+ * Models the {@code PermittedSubclasses} attribute (JVMS {@jvms 4.7.31}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/PermittedSubclassesAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code Record} attribute {@jvms 4.7.30}, which can\n+ * Models the {@code Record} attribute (JVMS {@jvms 4.7.30}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RecordAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code RuntimeInvisibleAnnotations} attribute {@jvms 4.7.17}, which\n+ * Models the {@code RuntimeInvisibleAnnotations} attribute (JVMS {@jvms 4.7.17}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * {@jvms 4.7.19}, which can appear on methods. Delivered as a {@link\n+ * (JVMS {@jvms 4.7.19}), which can appear on methods. Delivered as a {@link\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleParameterAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * Models the {@code RuntimeInvisibleTypeAnnotations} attribute {@jvms 4.7.21}, which\n+ * Models the {@code RuntimeInvisibleTypeAnnotations} attribute (JVMS {@jvms 4.7.21}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleTypeAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code RuntimeVisibleAnnotations} attribute {@jvms 4.7.16}, which\n+ * Models the {@code RuntimeVisibleAnnotations} attribute (JVMS {@jvms 4.7.16}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * Models the {@code RuntimeVisibleParameterAnnotations} attribute {@jvms 4.7.18}, which\n+ * Models the {@code RuntimeVisibleParameterAnnotations} attribute (JVMS {@jvms 4.7.18}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleParameterAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * Models the {@code RuntimeVisibleTypeAnnotations} attribute {@jvms 4.7.20}, which\n+ * Models the {@code RuntimeVisibleTypeAnnotations} attribute (JVMS {@jvms 4.7.20}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleTypeAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * Models the {@code Signature} attribute {@jvms 4.7.9}, which\n+ * Models the {@code Signature} attribute (JVMS {@jvms 4.7.9}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SignatureAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code SourceFile} attribute {@jvms 4.7.10}, which\n+ * Models the {@code SourceFile} attribute (JVMS {@jvms 4.7.10}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SourceFileAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * Models stack map frame of {@code StackMapTable} attribute {@jvms 4.7.4}.\n+ * Models stack map frame of {@code StackMapTable} attribute (JVMS {@jvms 4.7.4}).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapFrameInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code StackMapTable} attribute {@jvms 4.7.4}, which can appear\n+ * Models the {@code StackMapTable} attribute (JVMS {@jvms 4.7.4}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code Synthetic} attribute {@jvms 4.7.8}, which can appear on\n+ * Models the {@code Synthetic} attribute (JVMS {@jvms 4.7.8}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SyntheticAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,1 +184,1 @@\n-                                                    storeStack.push(StoreInstruction.of(TypeKind.ReferenceType, slot++));\n+                                                    storeStack.push(StoreInstruction.of(TypeKind.REFERENCE, slot++));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/snippet-files\/PackageSnippets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n-     * @param refKind the reference kind of the method handle {@jvms 4.4.8}\n+     * @param refKind the reference kind of the method handle (JVMS {@jvms 4.4.8})\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        return TypeKind.DoubleType;\n+        return TypeKind.DOUBLE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/DoubleEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        return TypeKind.FloatType;\n+        return TypeKind.FLOAT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/FloatEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        return TypeKind.IntType;\n+        return TypeKind.INT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/IntegerEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-        return TypeKind.ReferenceType;\n+        return TypeKind.REFERENCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/LoadableConstantEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        return TypeKind.LongType;\n+        return TypeKind.LONG;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/LongEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-     * {@return the reference kind of this method handle {@jvms 4.4.8}}\n+     * {@return the reference kind of this method handle (JVMS {@jvms 4.4.8})}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/MethodHandleEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,3 @@\n-     * {@return the component type of the array}\n+     * {@return the component type of the array} The {@link TypeKind#BYTE byte}\n+     * type load instruction {@link Opcode#BALOAD baload} also operates on\n+     * {@link TypeKind#BOOLEAN boolean} arrays.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ArrayLoadInstruction.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,3 @@\n-     * {@return the component type of the array}\n+     * {@return the component type of the array} The {@link TypeKind#BYTE byte}\n+     * type store instruction {@link Opcode#BASTORE bastore} also operates on\n+     * {@link TypeKind#BOOLEAN boolean} arrays.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ArrayStoreInstruction.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n@@ -77,1 +78,1 @@\n-            return opcode().primaryTypeKind();\n+            return BytecodeHelpers.intrinsicConstantType(opcode());\n@@ -100,1 +101,1 @@\n-            return opcode().primaryTypeKind();\n+            return TypeKind.INT;\n@@ -139,1 +140,1 @@\n-        if (op.constantValue() == null)\n+        if (op.sizeIfFixed() != 1)\n@@ -147,2 +148,2 @@\n-     * @param op the opcode for the specific type of intrinsic constant instruction,\n-     *           which must be of kind {@link Opcode.Kind#CONSTANT}\n+     * @param op the opcode for the specific type of argument constant instruction,\n+     *           which must be {@link Opcode#BIPUSH} or {@link Opcode#SIPUSH}\n@@ -151,1 +152,2 @@\n-     *                                  or {@link Opcode#SIPUSH}\n+     *         or {@link Opcode#SIPUSH}, or if the constant value is out of range\n+     *         for the opcode\n@@ -154,2 +156,5 @@\n-        Util.checkKind(op, Opcode.Kind.CONSTANT);\n-        if (op != Opcode.BIPUSH && op != Opcode.SIPUSH)\n+        if (op == Opcode.BIPUSH) {\n+            BytecodeHelpers.validateBipush(value);\n+        } else if (op == Opcode.SIPUSH) {\n+            BytecodeHelpers.validateSipush(value);\n+        } else {\n@@ -157,0 +162,1 @@\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ConstantInstruction.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-     * {@return the {@code count} value of an {@code invokeinterface} instruction, as defined in {@jvms 6.5}\n+     * {@return the {@code count} value of an {@code invokeinterface} instruction, as defined in JVMS {@jvms 6.5}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/InvokeInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            throw new IllegalArgumentException(\"Illegal component type: \" + typeKind.typeName());\n+            throw new IllegalArgumentException(\"Illegal component type for primitive array: \" + typeKind.name());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewPrimitiveArrayInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n- * java.lang.Object)} method for mapping back to the classfile format.  It also\n+ * java.lang.classfile.Attribute)} method for mapping back to the classfile format.  It also\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,1 @@\n-                                                    storeStack.push(StoreInstruction.of(TypeKind.ReferenceType, slot++));\n+                                                    storeStack.push(StoreInstruction.of(TypeKind.REFERENCE, slot++));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/snippet-files\/PackageSnippets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import static jdk.internal.constant.ConstantUtils.concat;\n+import static jdk.internal.constant.ConstantUtils.forPrimitiveType;\n@@ -85,1 +87,1 @@\n-        return ClassDesc.ofDescriptor(\"L\" + binaryToInternal(name) + \";\");\n+        return ClassDesc.ofDescriptor(concat(\"L\", binaryToInternal(name), \";\"));\n@@ -111,1 +113,1 @@\n-        return ClassDesc.ofDescriptor(\"L\" + name + \";\");\n+        return ClassDesc.ofDescriptor(concat(\"L\", name, \";\"));\n@@ -134,2 +136,2 @@\n-        return ofDescriptor(\"L\" + binaryToInternal(packageName) +\n-                \"\/\" + className + \";\");\n+        return ofDescriptor('L' + binaryToInternal(packageName) +\n+                '\/' + className + ';');\n@@ -167,1 +169,1 @@\n-               ? Wrapper.forPrimitiveType(descriptor.charAt(0)).basicClassDescriptor()\n+               ? forPrimitiveType(descriptor, 0)\n@@ -363,1 +365,1 @@\n-            return c.displayName() + \"[]\".repeat(depth);\n+            return c.displayName().concat(\"[]\".repeat(depth));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-    public static final ClassDesc CD_int = new PrimitiveClassDescImpl(\"I\");\n+    public static final ClassDesc CD_int = PrimitiveClassDescImpl.CD_int;\n@@ -246,1 +246,1 @@\n-    public static final ClassDesc CD_long = new PrimitiveClassDescImpl(\"J\");\n+    public static final ClassDesc CD_long = PrimitiveClassDescImpl.CD_long;\n@@ -249,1 +249,1 @@\n-    public static final ClassDesc CD_float = new PrimitiveClassDescImpl(\"F\");\n+    public static final ClassDesc CD_float = PrimitiveClassDescImpl.CD_float;\n@@ -252,1 +252,1 @@\n-    public static final ClassDesc CD_double = new PrimitiveClassDescImpl(\"D\");\n+    public static final ClassDesc CD_double = PrimitiveClassDescImpl.CD_double;\n@@ -255,1 +255,1 @@\n-    public static final ClassDesc CD_short = new PrimitiveClassDescImpl(\"S\");\n+    public static final ClassDesc CD_short = PrimitiveClassDescImpl.CD_short;\n@@ -258,1 +258,1 @@\n-    public static final ClassDesc CD_byte = new PrimitiveClassDescImpl(\"B\");\n+    public static final ClassDesc CD_byte = PrimitiveClassDescImpl.CD_byte;\n@@ -261,1 +261,1 @@\n-    public static final ClassDesc CD_char = new PrimitiveClassDescImpl(\"C\");\n+    public static final ClassDesc CD_char = PrimitiveClassDescImpl.CD_char;\n@@ -264,1 +264,1 @@\n-    public static final ClassDesc CD_boolean = new PrimitiveClassDescImpl(\"Z\");\n+    public static final ClassDesc CD_boolean = PrimitiveClassDescImpl.CD_boolean;\n@@ -267,1 +267,1 @@\n-    public static final ClassDesc CD_void = new PrimitiveClassDescImpl(\"V\");\n+    public static final ClassDesc CD_void = PrimitiveClassDescImpl.CD_void;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-     * @jls 6.5.3 Module Names and Package Names\n+     * @jls 6.5.3 Meaning of Module Names and Package Names\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/PackageDesc.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -616,1 +616,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -687,1 +687,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -736,1 +736,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -577,1 +577,3 @@\n-     * Otherwise, the returned method handle throws {@link IndexOutOfBoundsException}.\n+     * Otherwise, the returned method handle throws {@link IndexOutOfBoundsException}. Moreover,\n+     * the value of {@code b} must be such that the computation for {@code offset} does not overflow,\n+     * or the returned method handle throws {@link ArithmeticException}.\n@@ -667,3 +669,4 @@\n-     * {@code P} and {@code P'} are derived, where P contains all the path elements from\n-     * 0 to {@code k - 1} and {@code P'} contains all the path elements from {@code k + 1}\n-     * to {@code m} (if any). Then, the returned var handle is computed as follows:\n+     * {@code P} and {@code Q} are derived, where P contains all the path elements from\n+     * 0 to {@code k - 1} and {@code Q} contains all the path elements from {@code k + 1}\n+     * to {@code m} ({@code Q} could be an empty layout path if {@code k == m}).\n+     * Then, the returned var handle is computed as follows:\n@@ -674,1 +677,1 @@\n-     * VarHandle targetHandle = target.varHandle(P);\n+     * VarHandle targetHandle = target.varHandle(Q);\n@@ -947,1 +950,1 @@\n-         *    <li>if {@code F < 0}, then {@code B = ceilDiv(-(S + 1), -F)}<\/li>\n+         *    <li>if {@code F < 0}, then {@code B = ceilDiv(S + 1, -F)}<\/li>\n@@ -975,2 +978,2 @@\n-         * {@return a path element that dereferences an address layout as its\n-         * {@linkplain AddressLayout#targetLayout() target layout} (where set)}\n+         * {@return a path element that selects the {@linkplain AddressLayout#targetLayout() target layout} of\n+         * an address layout (where set)}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n- *       ptr = z.reinterpret(16, arena, null);                       \/\/ size = 4, scope = arena.scope()\n+ *       ptr = z.reinterpret(16, arena, null);                       \/\/ size = 16, scope = arena.scope()\n@@ -1573,2 +1573,3 @@\n-        copy(srcSegment, ValueLayout.JAVA_BYTE, srcOffset,\n-                dstSegment, ValueLayout.JAVA_BYTE, dstOffset,\n+\n+        AbstractMemorySegmentImpl.copy((AbstractMemorySegmentImpl) srcSegment, srcOffset,\n+                (AbstractMemorySegmentImpl) dstSegment, dstOffset,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.loader.NativeLibraries;\n@@ -259,1 +260,2 @@\n-            long addr = javaLangAccess.findNative(loader, name);\n+            NativeLibraries nativeLibraries = javaLangAccess.nativeLibrariesFor(loader);\n+            long addr = nativeLibraries.find(name);\n@@ -288,1 +290,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -295,1 +297,1 @@\n-                SymbolLookup.class, \"libraryLookup\");\n+                SymbolLookup.class, \"libraryLookup\", false);\n@@ -322,1 +324,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -329,1 +331,1 @@\n-                SymbolLookup.class, \"libraryLookup\");\n+                SymbolLookup.class, \"libraryLookup\", false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -168,4 +168,5 @@\n- * the special value {@code ALL-UNNAMED} can be used). If this option is specified,\n- * access to restricted methods are only granted to the modules listed by that option.\n- * If this option is not specified, access to restricted methods is enabled for all\n- * modules, but access to restricted methods will result in runtime warnings.\n+ * the special value {@code ALL-UNNAMED} can be used). Access to restricted methods\n+ * from modules not listed by that option is deemed <em>illegal<\/em>. Clients can\n+ * control how access to restricted methods is handled, using the command line\n+ * option {@code --illegal-native-access}. If this option is not specified,\n+ * illegal access to restricted methods will result in runtime warnings.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-                            .invokeExact(caller, name, (MethodType)type,\n+                            .invokeBasic(caller, name, (MethodType)type,\n@@ -134,5 +134,1 @@\n-                            .invokeExact(caller, name, (MethodType)type, (MethodType)argv[0],\n-                                    (MethodHandle)argv[1], (MethodType)argv[2]);\n-                } else if (isLambdaMetafactoryCondyBSM(bsmType) && argv.length == 3) {\n-                    result = bootstrapMethod\n-                            .invokeExact(caller, name, (Class<?>)type, (MethodType)argv[0],\n+                            .invokeBasic(caller, name, (MethodType)type, (MethodType)argv[0],\n@@ -144,1 +140,1 @@\n-                    result = (CallSite)bootstrapMethod.invokeExact(caller, name, (MethodType)type, recipe, shiftedArgs);\n+                    result = (CallSite)bootstrapMethod.invokeBasic(caller, name, (MethodType)type, recipe, shiftedArgs);\n@@ -147,1 +143,1 @@\n-                    result = (CallSite)bootstrapMethod.invokeExact(caller, name, (MethodType)type, argv);\n+                    result = (CallSite)bootstrapMethod.invokeBasic(caller, name, (MethodType)type, argv);\n@@ -150,1 +146,1 @@\n-                    result = bootstrapMethod.invokeExact(caller, name, (TypeDescriptor)type, (Class<?>)argv[0], (String)argv[1], mhs);\n+                    result = bootstrapMethod.invokeBasic(caller, name, (TypeDescriptor)type, (Class<?>)argv[0], (String)argv[1], mhs);\n@@ -255,3 +251,0 @@\n-    private static final MethodType LMF_CONDY_MT = MethodType.methodType(Object.class,\n-            Lookup.class, String.class, Class.class, MethodType.class, MethodHandle.class, MethodType.class);\n-\n@@ -270,9 +263,0 @@\n-    \/**\n-     * @return true iff the BSM method type exactly matches\n-     *         {@link java.lang.invoke.LambdaMetafactory#metafactory(\n-     *          MethodHandles.Lookup,String,Class,MethodType,MethodHandle,MethodType)}\n-     *\/\n-    private static boolean isLambdaMetafactoryCondyBSM(MethodType bsmType) {\n-        return bsmType == LMF_CONDY_MT;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BootstrapMethodInvoker.java","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.lang.invoke.InnerClassLambdaMetafactory.MethodBody;\n@@ -71,2 +70,0 @@\n-    private static final Consumer<FieldBuilder> STATIC_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_STATIC);\n-    private static final Consumer<FieldBuilder> FINAL_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_FINAL);\n@@ -628,1 +625,1 @@\n-                       .withField(sdFieldName, CD_SPECIES_DATA, STATIC_FIELD_FLAGS);\n+                       .withField(sdFieldName, CD_SPECIES_DATA, ACC_STATIC);\n@@ -712,1 +709,1 @@\n-                        clb.withField(field.name, field.desc, FINAL_FIELD_FLAGS);\n+                        clb.withField(field.name, field.desc, ACC_FINAL);\n@@ -716,2 +713,2 @@\n-                    clb.withMethod(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n-                            new MethodBody(new Consumer<CodeBuilder>() {\n+                    clb.withMethodBody(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n+                            new Consumer<>() {\n@@ -723,1 +720,1 @@\n-                            }));\n+                            });\n@@ -730,2 +727,2 @@\n-                    clb.withMethod(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE,\n-                            new MethodBody(new Consumer<CodeBuilder>() {\n+                    clb.withMethodBody(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE,\n+                            new Consumer<>() {\n@@ -756,1 +753,1 @@\n-                            }));\n+                            });\n@@ -760,2 +757,2 @@\n-                    clb.withMethod(\"make\", methodDesc(ftryType), ACC_STATIC,\n-                            new MethodBody(new Consumer<CodeBuilder>() {\n+                    clb.withMethodBody(\"make\", methodDesc(ftryType), ACC_STATIC,\n+                            new Consumer<>() {\n@@ -776,1 +773,1 @@\n-                            }));\n+                            });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.constant.ConstantUtils;\n@@ -115,1 +116,1 @@\n-        return Wrapper.forPrimitiveType(name.charAt(0)).primitiveType();\n+        return ConstantUtils.forPrimitiveType(name, 0).resolveConstantDesc(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ConstantBootstraps.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -566,1 +566,1 @@\n-                new InvokerBytecodeGenerator(className, names[i], forms[i], forms[i].methodType()).addMethod(clb);\n+                new InvokerBytecodeGenerator(className, names[i], forms[i], forms[i].methodType()).addMethod(clb, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,14 +75,0 @@\n-    \/\/ Static builders to avoid lambdas\n-    record FieldFlags(int flags) implements Consumer<FieldBuilder> {\n-        @Override\n-        public void accept(FieldBuilder fb) {\n-            fb.withFlags(flags);\n-        }\n-    };\n-    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n-        @Override\n-        public void accept(MethodBuilder mb) {\n-            mb.withCode(code);\n-        }\n-    };\n-\n@@ -114,1 +100,2 @@\n-    private final ClassDesc lambdaClassDesc;         \/\/ Type descriptor for the generated class \"X$$Lambda$1\"\n+    private final ConstantPoolBuilder pool = ConstantPoolBuilder.of();\n+    private final ClassEntry lambdaClassEntry;       \/\/ Class entry for the generated class \"X$$Lambda$1\"\n@@ -174,1 +161,0 @@\n-        constructorTypeDesc = methodDesc(constructorType);\n@@ -176,1 +162,1 @@\n-        lambdaClassDesc = ClassDesc.ofInternalName(lambdaClassName);\n+        lambdaClassEntry = pool.classEntry(ReferenceClassDescImpl.ofValidated(ConstantUtils.concat(\"L\", lambdaClassName, \";\")));\n@@ -200,0 +186,1 @@\n+        constructorTypeDesc = MethodTypeDescImpl.ofValidated(CD_void, argDescs);\n@@ -208,1 +195,1 @@\n-        return name.replace('.', '\/') + \"$$Lambda\";\n+        return name.replace('.', '\/').concat(\"$$Lambda\");\n@@ -238,1 +225,1 @@\n-                    Object inst = mh.asType(methodType(Object.class)).invokeExact();\n+                    Object inst = mh.invokeBasic();\n@@ -320,1 +307,1 @@\n-        final byte[] classBytes = ClassFile.of().build(lambdaClassDesc, new Consumer<ClassBuilder>() {\n+        final byte[] classBytes = ClassFile.of().build(lambdaClassEntry, pool, new Consumer<ClassBuilder>() {\n@@ -327,1 +314,1 @@\n-                    clb.withField(argNames[i], argDescs[i], new FieldFlags(ACC_PRIVATE | ACC_FINAL));\n+                    clb.withField(argNames[i], argDescs[i], ACC_PRIVATE | ACC_FINAL);\n@@ -337,1 +324,1 @@\n-                clb.withMethod(interfaceMethodName,\n+                clb.withMethodBody(interfaceMethodName,\n@@ -345,1 +332,1 @@\n-                        clb.withMethod(interfaceMethodName,\n+                        clb.withMethodBody(interfaceMethodName,\n@@ -379,1 +366,1 @@\n-        clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, new FieldFlags(ACC_PRIVATE | ACC_STATIC | ACC_FINAL));\n+        clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n@@ -382,1 +369,1 @@\n-        clb.withMethod(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new Consumer<>() {\n@@ -386,1 +373,1 @@\n-                cob.new_(lambdaClassDesc)\n+                cob.new_(lambdaClassEntry)\n@@ -388,2 +375,2 @@\n-                   .invokespecial(lambdaClassDesc, INIT_NAME, constructorTypeDesc)\n-                   .putstatic(lambdaClassDesc, LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor)\n+                   .invokespecial(pool.methodRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(INIT_NAME, constructorTypeDesc)))\n+                   .putstatic(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor)))\n@@ -392,1 +379,1 @@\n-        }));\n+        });\n@@ -400,2 +387,2 @@\n-        clb.withMethod(INIT_NAME, constructorTypeDesc, ACC_PRIVATE,\n-                new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(INIT_NAME, constructorTypeDesc, ACC_PRIVATE,\n+                new Consumer<>() {\n@@ -411,1 +398,1 @@\n-                            cob.putfield(lambdaClassDesc, argNames[i], argDescs[i]);\n+                            cob.putfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n@@ -415,1 +402,1 @@\n-                }));\n+                });\n@@ -442,2 +429,2 @@\n-        clb.withMethod(SerializationSupport.NAME_METHOD_WRITE_REPLACE, SerializationSupport.MTD_Object, ACC_PRIVATE | ACC_FINAL,\n-                new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(SerializationSupport.NAME_METHOD_WRITE_REPLACE, SerializationSupport.MTD_Object, ACC_PRIVATE | ACC_FINAL,\n+                new Consumer<>() {\n@@ -463,1 +450,1 @@\n-                               .getfield(lambdaClassDesc, argNames[i], argDescs[i]);\n+                               .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n@@ -471,1 +458,1 @@\n-                }));\n+                });\n@@ -507,2 +494,2 @@\n-    Consumer<MethodBuilder> forwardingMethod(MethodType methodType) {\n-        return new MethodBody(new Consumer<CodeBuilder>() {\n+    Consumer<CodeBuilder> forwardingMethod(MethodType methodType) {\n+        return new Consumer<>() {\n@@ -522,1 +509,1 @@\n-                       .getfield(lambdaClassDesc, argNames[i], argDescs[i]);\n+                       .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n@@ -545,1 +532,1 @@\n-        });\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":28,"deletions":41,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,3 @@\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.FieldRefEntry;\n@@ -60,0 +63,2 @@\n+import static jdk.internal.constant.ConstantUtils.concat;\n+import static jdk.internal.constant.ConstantUtils.validateInternalClassName;\n@@ -70,0 +75,1 @@\n+    private static final ClassDesc CD_MemberName = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MemberName;\");\n@@ -86,15 +92,0 @@\n-    \/\/ Static builders to avoid lambdas\n-    private static final Consumer<FieldBuilder> STATIC_FINAL_FIELD = new Consumer<FieldBuilder>() {\n-        @Override\n-        public void accept(FieldBuilder fb) {\n-            fb.withFlags(ACC_STATIC | ACC_FINAL);\n-        }\n-    };\n-\n-    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n-        @Override\n-        public void accept(MethodBuilder mb) {\n-            mb.withCode(code);\n-        }\n-    };\n-\n@@ -107,1 +98,2 @@\n-    private final ClassDesc classDesc;\n+    private final ConstantPoolBuilder pool = ConstantPoolBuilder.of();\n+    private final ClassEntry classEntry;\n@@ -143,2 +135,3 @@\n-        this.className = CLASS_PREFIX + name;\n-        this.classDesc = ClassDesc.ofInternalName(className);\n+        this.className = CLASS_PREFIX.concat(name);\n+        validateInternalClassName(name);\n+        this.classEntry = pool.classEntry(ReferenceClassDescImpl.ofValidated(concat(\"L\", className, \";\")));\n@@ -160,2 +153,2 @@\n-            Wrapper w = Wrapper.forBasicType(mt.parameterType(i - 1));\n-            index += w.stackSlots();\n+            Class<?> cl = mt.parameterType(i - 1);\n+            index += (cl == long.class || cl == double.class) ? 2 : 1;\n@@ -198,17 +191,0 @@\n-        String sfx = ctr.toString();\n-        while (sfx.length() < 3)\n-            sfx = \"0\" + sfx;\n-        className += sfx;\n-        return className;\n-    }\n-\n-    static class ClassData {\n-        final String name;\n-        final ClassDesc desc;\n-        final Object value;\n-\n-        ClassData(String name, ClassDesc desc, Object value) {\n-            this.name = name;\n-            this.desc = desc;\n-            this.value = value;\n-        }\n@@ -216,3 +192,6 @@\n-        public String name() { return name; }\n-        public String toString() {\n-            return name + \",value=\"+value;\n+        var buf = new StringBuilder(className.length() + 3).append(className);\n+        int ctrVal = ctr;\n+        if (ctrVal < 10) {\n+            buf.repeat('0', 2);\n+        } else if (ctrVal < 100) {\n+            buf.append('0');\n@@ -220,0 +199,2 @@\n+        buf.append(ctrVal);\n+        return buf.toString();\n@@ -222,11 +203,1 @@\n-    String classData(Object arg) {\n-        ClassDesc desc;\n-        if (arg instanceof Class) {\n-            desc = CD_Class;\n-        } else if (arg instanceof MethodHandle) {\n-            desc = CD_MethodHandle;\n-        } else if (arg instanceof LambdaForm) {\n-            desc = CD_LambdaForm;\n-        } else {\n-            desc = CD_Object;\n-        }\n+    record ClassData(FieldRefEntry field, Object value) {}\n@@ -234,0 +205,1 @@\n+    FieldRefEntry classData(ClassFileBuilder<?, ?> cfb, Object arg, ClassDesc desc) {\n@@ -236,0 +208,1 @@\n+        List<ClassData> classData = this.classData;\n@@ -245,3 +218,3 @@\n-        ClassData cd = new ClassData(name, desc, arg);\n-        classData.add(cd);\n-        return name;\n+        var field = pool.fieldRefEntry(classEntry, pool.nameAndTypeEntry(name, desc));\n+        classData.add(new ClassData(field, arg));\n+        return field;\n@@ -276,1 +249,1 @@\n-            return ClassFile.of().build(classDesc, new Consumer<>() {\n+            return ClassFile.of().build(classEntry, pool, new Consumer<>() {\n@@ -279,1 +252,1 @@\n-                    clb.withFlags(ACC_FINAL | ACC_SUPER)\n+                    clb.withFlags(ACC_ABSTRACT | ACC_SUPER)\n@@ -305,1 +278,2 @@\n-        return switch (cd.size()) {\n+        int size = cd.size();\n+        return switch (size) {\n@@ -312,2 +286,2 @@\n-                Object[] data = new Object[classData.size()];\n-                for (int i = 0; i < classData.size(); i++) {\n+                Object[] data = new Object[size];\n+                for (int i = 0; i < size; i++) {\n@@ -325,1 +299,1 @@\n-    static void clinit(ClassBuilder clb, ClassDesc classDesc, List<ClassData> classData) {\n+    static void clinit(ClassBuilder clb, ClassEntry classEntry, List<ClassData> classData) {\n@@ -329,6 +303,1 @@\n-        for (ClassData p : classData) {\n-            \/\/ add the static field\n-            clb.withField(p.name, p.desc, STATIC_FINAL_FIELD);\n-        }\n-\n-        clb.withMethod(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new Consumer<>() {\n@@ -337,1 +306,1 @@\n-                cob.loadConstant(classDesc)\n+                cob.ldc(classEntry)\n@@ -339,4 +308,10 @@\n-                if (classData.size() == 1) {\n-                    ClassData p = classData.get(0);\n-                    cob.checkcast(p.desc)\n-                       .putstatic(classDesc, p.name, p.desc);\n+                int size = classData.size();\n+                if (size == 1) {\n+                    var field = classData.getFirst().field;\n+                    \/\/ add the static field\n+                    clb.withField(field.name(), field.type(), ACC_STATIC | ACC_FINAL);\n+\n+                    var ft = field.typeSymbol();\n+                    if (ft != CD_Object)\n+                        cob.checkcast(ft);\n+                    cob.putstatic(field);\n@@ -348,1 +323,4 @@\n-                    for (ClassData p : classData) {\n+                    for (int i = 0; i < size; i++) {\n+                        var field = classData.get(i).field;\n+                        \/\/ add the static field\n+                        clb.withField(field.name(), field.type(), ACC_STATIC | ACC_FINAL);\n@@ -352,3 +330,5 @@\n-                           .invokeinterface(listGet)\n-                           .checkcast(p.desc)\n-                           .putstatic(classDesc, p.name, p.desc);\n+                           .invokeinterface(listGet);\n+                        var ft = field.typeSymbol();\n+                        if (ft != CD_Object)\n+                            cob.checkcast(ft);\n+                        cob.putstatic(field);\n@@ -359,1 +339,1 @@\n-        }));\n+        });\n@@ -372,2 +352,0 @@\n-     *\n-     * @param wrapper primitive type class to box.\n@@ -381,2 +359,0 @@\n-     *\n-     * @param wrapper wrapper type class to unbox.\n@@ -386,3 +362,3 @@\n-            case BooleanType -> emitReferenceCast(cob, Boolean.class, null);\n-            case CharType -> emitReferenceCast(cob, Character.class, null);\n-            case ByteType, DoubleType, FloatType, IntType, LongType, ShortType ->\n+            case BOOLEAN -> emitReferenceCast(cob, Boolean.class, null);\n+            case CHAR -> emitReferenceCast(cob, Character.class, null);\n+            case BYTE, DOUBLE, FLOAT, INT, LONG, SHORT ->\n@@ -451,1 +427,1 @@\n-            cob.getstatic(classDesc, classData(cls), CD_Class)\n+            cob.getstatic(classData(cob, cls, CD_Class))\n@@ -461,1 +437,1 @@\n-            emitStoreInsn(cob, TypeKind.ReferenceType, writeBack.index());\n+            emitStoreInsn(cob, TypeKind.REFERENCE, writeBack.index());\n@@ -551,0 +527,5 @@\n+    \/\/ Suppress method in backtraces displayed to the user, mark this method as\n+    \/\/ a compiled LambdaForm, then either force or prohibit inlining.\n+    public static final RuntimeVisibleAnnotationsAttribute LF_DONTINLINE_ANNOTATIONS = RuntimeVisibleAnnotationsAttribute.of(HIDDEN, LF_COMPILED, DONTINLINE);\n+    public static final RuntimeVisibleAnnotationsAttribute LF_FORCEINLINE_ANNOTATIONS = RuntimeVisibleAnnotationsAttribute.of(HIDDEN, LF_COMPILED, FORCEINLINE);\n+\n@@ -555,1 +536,1 @@\n-        final byte[] classFile = classFileSetup(new Consumer<ClassBuilder>() {\n+        final byte[] classFile = classFileSetup(new Consumer<>() {\n@@ -558,2 +539,2 @@\n-                addMethod(clb);\n-                clinit(clb, classDesc, classData);\n+                addMethod(clb, true);\n+                clinit(clb, classEntry, classData);\n@@ -566,2 +547,2 @@\n-    void addMethod(ClassBuilder clb) {\n-        methodSetup(clb, new Consumer<MethodBuilder>() {\n+    void addMethod(ClassBuilder clb, boolean alive) {\n+        methodSetup(clb, new Consumer<>() {\n@@ -571,8 +552,0 @@\n-                List<Annotation> annotations = new ArrayList<>(3);\n-\n-                \/\/ Suppress this method in backtraces displayed to the user.\n-                annotations.add(HIDDEN);\n-\n-                \/\/ Mark this method as a compiled LambdaForm\n-                annotations.add(LF_COMPILED);\n-\n@@ -580,2 +553,1 @@\n-                    \/\/ Force inlining of this invoker method.\n-                    annotations.add(FORCEINLINE);\n+                    mb.accept(LF_FORCEINLINE_ANNOTATIONS);\n@@ -583,1 +555,1 @@\n-                    annotations.add(DONTINLINE);\n+                    mb.accept(LF_DONTINLINE_ANNOTATIONS);\n@@ -585,1 +557,0 @@\n-                mb.accept(RuntimeVisibleAnnotationsAttribute.of(annotations));\n@@ -587,1 +558,3 @@\n-                classData(lambdaForm); \/\/ keep LambdaForm instance & its compiled form lifetime tightly coupled.\n+                if (alive) {\n+                    classData(mb, lambdaForm, CD_LambdaForm); \/\/ keep LambdaForm instance & its compiled form lifetime tightly coupled.\n+                }\n@@ -589,1 +562,1 @@\n-                mb.withCode(new Consumer<CodeBuilder>() {\n+                mb.withCode(new Consumer<>() {\n@@ -597,2 +570,1 @@\n-                            cob.getstatic(classDesc, classData(lambdaForm.customized), CD_MethodHandle)\n-                               .checkcast(CD_MethodHandle);\n+                            cob.getstatic(classData(cob, lambdaForm.customized, CD_MethodHandle));\n@@ -731,1 +703,1 @@\n-            cob.getstatic(classDesc, classData(target), CD_MethodHandle);\n+            cob.getstatic(classData(cob, target, CD_MethodHandle));\n@@ -919,1 +891,1 @@\n-        emitStoreInsn(cob, TypeKind.ReferenceType, receiver.index());  \/\/ store the MH in the receiver slot\n+        emitStoreInsn(cob, TypeKind.REFERENCE, receiver.index());  \/\/ store the MH in the receiver slot\n@@ -931,1 +903,1 @@\n-        emitStoreInsn(cob, TypeKind.ReferenceType, receiver.index());  \/\/ store the MH in the receiver slot\n+        emitStoreInsn(cob, TypeKind.REFERENCE, receiver.index());  \/\/ store the MH in the receiver slot\n@@ -1169,1 +1141,1 @@\n-        emitStoreInsn(cob, TypeKind.ReferenceType, casesLocal);\n+        emitStoreInsn(cob, TypeKind.REFERENCE, casesLocal);\n@@ -1190,1 +1162,1 @@\n-            emitLoadInsn(cob, TypeKind.ReferenceType, casesLocal);\n+            emitLoadInsn(cob, TypeKind.REFERENCE, casesLocal);\n@@ -1329,1 +1301,1 @@\n-        emitStoreInsn(cob, TypeKind.ReferenceType, clauseDataIndex);\n+        emitStoreInsn(cob, TypeKind.REFERENCE, clauseDataIndex);\n@@ -1416,1 +1388,1 @@\n-        emitLoadInsn(cob, TypeKind.ReferenceType, clauseDataSlot);\n+        emitLoadInsn(cob, TypeKind.REFERENCE, clauseDataSlot);\n@@ -1456,1 +1428,1 @@\n-                cob.getstatic(classDesc, classData(arg), CD_Object);\n+                cob.getstatic(classData(cob, arg, CD_Object));\n@@ -1515,1 +1487,1 @@\n-        if (from != to && from != TypeKind.BooleanType) try {\n+        if (from != to && from != TypeKind.BOOLEAN) try {\n@@ -1535,1 +1507,1 @@\n-        final byte[] classFile = classFileSetup(new Consumer<ClassBuilder>() {\n+        final byte[] classFile = classFileSetup(new Consumer<>() {\n@@ -1538,1 +1510,1 @@\n-                methodSetup(clb, new Consumer<MethodBuilder>() {\n+                methodSetup(clb, new Consumer<>() {\n@@ -1547,1 +1519,1 @@\n-                        mb.withCode(new Consumer<CodeBuilder>() {\n+                        mb.withCode(new Consumer<>() {\n@@ -1585,1 +1557,1 @@\n-                clinit(clb, classDesc, classData);\n+                clinit(clb, classEntry, classData);\n@@ -1604,1 +1576,1 @@\n-        final byte[] classFile = classFileSetup(new Consumer<ClassBuilder>() {\n+        final byte[] classFile = classFileSetup(new Consumer<>() {\n@@ -1607,1 +1579,1 @@\n-                methodSetup(clb, new Consumer<MethodBuilder>() {\n+                methodSetup(clb, new Consumer<>() {\n@@ -1616,1 +1588,1 @@\n-                        mb.withCode(new Consumer<CodeBuilder>() {\n+                        mb.withCode(new Consumer<>() {\n@@ -1661,1 +1633,1 @@\n-                clinit(clb, classDesc, classData);\n+                clinit(clb, classEntry, classData);\n@@ -1674,1 +1646,1 @@\n-            clb.withMethod(\"dummy\", MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+            clb.withMethodBody(\"dummy\", MTD_void, ACC_STATIC, new Consumer<>() {\n@@ -1681,1 +1653,1 @@\n-            }));\n+            });\n@@ -1687,2 +1659,1 @@\n-        return cls.isPrimitive() ? Wrapper.forPrimitiveType(cls).basicClassDescriptor()\n-             : cls == MethodHandle.class ? CD_MethodHandle\n+        return cls == MethodHandle.class ? CD_MethodHandle\n@@ -1691,0 +1662,3 @@\n+             : cls == MemberName.class ? CD_MemberName\n+             : cls == MethodType.class ? CD_MethodType\n+             : cls.isPrimitive() ? Wrapper.forPrimitiveType(cls).basicClassDescriptor()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":102,"deletions":128,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -141,6 +141,6 @@\n-        L_TYPE('L', Object.class, Wrapper.OBJECT, TypeKind.ReferenceType), \/\/ all reference types\n-        I_TYPE('I', int.class,    Wrapper.INT,    TypeKind.IntType),\n-        J_TYPE('J', long.class,   Wrapper.LONG,   TypeKind.LongType),\n-        F_TYPE('F', float.class,  Wrapper.FLOAT,  TypeKind.FloatType),\n-        D_TYPE('D', double.class, Wrapper.DOUBLE, TypeKind.DoubleType),  \/\/ all primitive types\n-        V_TYPE('V', void.class,   Wrapper.VOID,   TypeKind.VoidType);    \/\/ not valid in all contexts\n+        L_TYPE('L', Object.class, Wrapper.OBJECT, TypeKind.REFERENCE), \/\/ all reference types\n+        I_TYPE('I', int.class,    Wrapper.INT,    TypeKind.INT),\n+        J_TYPE('J', long.class,   Wrapper.LONG,   TypeKind.LONG),\n+        F_TYPE('F', float.class,  Wrapper.FLOAT,  TypeKind.FLOAT),\n+        D_TYPE('D', double.class, Wrapper.DOUBLE, TypeKind.DOUBLE),  \/\/ all primitive types\n+        V_TYPE('V', void.class,   Wrapper.VOID,   TypeKind.VOID);    \/\/ not valid in all contexts\n@@ -1558,0 +1558,1 @@\n+            Object[] arguments = this.arguments;\n@@ -1565,15 +1566,0 @@\n-        \/** Return the number of occurrences of n in the argument array.\n-         *  Return 0 if the name is not used.\n-         *\/\n-        int useCount(Name n) {\n-            int count = 0;\n-            if (arguments != null) {\n-                for (Object argument : arguments) {\n-                    if (argument == n) {\n-                        count++;\n-                    }\n-                }\n-            }\n-            return count;\n-        }\n-\n@@ -1621,0 +1607,1 @@\n+        Name[] names = this.names;\n@@ -1622,1 +1609,8 @@\n-            count += names[i++].useCount(n);\n+            Object[] arguments = names[i++].arguments;\n+            if (arguments != null) {\n+                for (Object argument : arguments) {\n+                    if (argument == n) {\n+                        count++;\n+                    }\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2209,1 +2209,1 @@\n-         * @jls 12.7 Unloading of Classes and Interface\n+         * @jls 12.7 Unloading of Classes and Interfaces\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -31,0 +32,2 @@\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -33,0 +36,2 @@\n+import jdk.internal.util.ReferenceKey;\n+import jdk.internal.util.ReferencedKeyMap;\n@@ -36,0 +41,1 @@\n+import java.lang.classfile.Annotation;\n@@ -39,0 +45,1 @@\n+import java.lang.classfile.MethodBuilder;\n@@ -40,0 +47,1 @@\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -41,1 +49,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -44,1 +51,2 @@\n-import java.lang.reflect.AccessFlag;\n+import java.lang.ref.SoftReference;\n+import java.util.Map;\n@@ -47,0 +55,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -48,0 +57,1 @@\n+import java.util.function.Supplier;\n@@ -49,1 +59,2 @@\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -110,1 +121,0 @@\n-\n@@ -112,0 +122,2 @@\n+    private static final int CACHE_THRESHOLD;\n+    private static final int FORCE_INLINE_THRESHOLD;\n@@ -115,1 +127,7 @@\n-        HIGH_ARITY_THRESHOLD = highArity != null ? Integer.parseInt(highArity) : 20;\n+        HIGH_ARITY_THRESHOLD = highArity != null ? Integer.parseInt(highArity) : 0;\n+\n+        String cacheThreshold = VM.getSavedProperty(\"java.lang.invoke.StringConcat.cacheThreshold\");\n+        CACHE_THRESHOLD = cacheThreshold != null ? Integer.parseInt(cacheThreshold) : 256;\n+\n+        String inlineThreshold = VM.getSavedProperty(\"java.lang.invoke.StringConcat.inlineThreshold\");\n+        FORCE_INLINE_THRESHOLD = inlineThreshold != null ? Integer.parseInt(inlineThreshold) : 16;\n@@ -374,7 +392,3 @@\n-            if (concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n-                return new ConstantCallSite(\n-                        generateMHInlineCopy(concatType, constantStrings)\n-                                .viewAsType(concatType, true));\n-            } else {\n-                return new ConstantCallSite(\n-                        SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings));\n+            MethodHandle mh = makeSimpleConcat(concatType, constantStrings);\n+            if (mh == null && concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n+                mh = generateMHInlineCopy(concatType, constantStrings);\n@@ -382,0 +396,7 @@\n+\n+            if (mh == null) {\n+                mh = InlineHiddenClassStrategy.generate(lookup, concatType, constantStrings);\n+            }\n+            mh = mh.viewAsType(concatType, true);\n+\n+            return new ConstantCallSite(mh);\n@@ -430,1 +451,1 @@\n-                consts[oCount++] = acc.length() > 0 ? acc.toString() : null;\n+                consts[oCount++] = acc.length() > 0 ? acc.toString() : \"\";\n@@ -446,1 +467,1 @@\n-        consts[oCount] = acc.length() > 0 ? acc.toString() : null;\n+        consts[oCount] = acc.length() > 0 ? acc.toString() : \"\";\n@@ -469,8 +490,1 @@\n-    \/**\n-     * <p>This strategy replicates what StringBuilders are doing: it builds the\n-     * byte[] array on its own and passes that byte[] array to String\n-     * constructor. This strategy requires access to some private APIs in JDK,\n-     * most notably, the private String constructor that accepts byte[] arrays\n-     * without copying.\n-     *\/\n-    private static MethodHandle generateMHInlineCopy(MethodType mt, String[] constants) {\n+    private static MethodHandle makeSimpleConcat(MethodType mt, String[] constants) {\n@@ -487,2 +501,2 @@\n-            if (prefix == null) {\n-                if (suffix == null) {\n+            if (prefix.isEmpty()) {\n+                if (suffix.isEmpty()) {\n@@ -493,1 +507,1 @@\n-            } else if (suffix == null && !mt.hasPrimitives()) {\n+            } else if (suffix.isEmpty() && !mt.hasPrimitives()) {\n@@ -497,3 +511,2 @@\n-        }\n-        if (paramCount == 2 && !mt.hasPrimitives() && suffix == null\n-                && constants[0] == null && constants[1] == null) {\n+        } else if (paramCount == 2 && !mt.hasPrimitives() && suffix.isEmpty()\n+                && constants[0].isEmpty() && constants[1].isEmpty()) {\n@@ -503,0 +516,16 @@\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * <p>This strategy replicates what StringBuilders are doing: it builds the\n+     * byte[] array on its own and passes that byte[] array to String\n+     * constructor. This strategy requires access to some private APIs in JDK,\n+     * most notably, the private String constructor that accepts byte[] arrays\n+     * without copying.\n+     *\/\n+    private static MethodHandle generateMHInlineCopy(MethodType mt, String[] constants) {\n+        int paramCount = mt.parameterCount();\n+        String suffix = constants[paramCount];\n+\n+\n@@ -1046,1 +1075,1 @@\n-     * Bytecode StringBuilder strategy.\n+     * Implement efficient hidden class strategy for String concatenation\n@@ -1048,2 +1077,5 @@\n-     * <p>This strategy emits StringBuilder chains as similar as possible\n-     * to what javac would. No exact sizing of parameters or estimates.\n+     * <p>This strategy replicates based on the bytecode what StringBuilders are doing: it builds the\n+     * byte[] array on its own and passes that byte[] array to String\n+     * constructor. This strategy requires access to some private APIs in JDK,\n+     * most notably, the private String constructor that accepts byte[] arrays\n+     * without copying.\n@@ -1051,3 +1083,4 @@\n-    private static final class SimpleStringBuilderStrategy {\n-        static final String METHOD_NAME = \"concat\";\n-        static final ClassDesc STRING_BUILDER = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringBuilder;\");\n+    private static final class InlineHiddenClassStrategy {\n+        static final String CLASS_NAME   = \"java.lang.String$$StringConcat\";\n+        static final String METHOD_NAME  = \"concat\";\n+\n@@ -1056,10 +1089,62 @@\n-        static final MethodTypeDesc APPEND_BOOLEAN_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_boolean);\n-        static final MethodTypeDesc APPEND_CHAR_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_char);\n-        static final MethodTypeDesc APPEND_DOUBLE_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_double);\n-        static final MethodTypeDesc APPEND_FLOAT_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_float);\n-        static final MethodTypeDesc APPEND_INT_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_int);\n-        static final MethodTypeDesc APPEND_LONG_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_long);\n-        static final MethodTypeDesc APPEND_OBJECT_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_Object);\n-        static final MethodTypeDesc APPEND_STRING_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_String);\n-        static final MethodTypeDesc INT_CONSTRUCTOR_TYPE = MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_int);\n-        static final MethodTypeDesc TO_STRING_TYPE = MethodTypeDesc.of(ConstantDescs.CD_String);\n+        static final MethodHandles.Lookup STR_LOOKUP = new MethodHandles.Lookup(String.class);\n+\n+        static final ClassDesc CD_CONCAT             = ConstantUtils.binaryNameToDesc(CLASS_NAME);\n+        static final ClassDesc CD_StringConcatHelper = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper;\");\n+        static final ClassDesc CD_StringConcatBase   = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper$StringConcatBase;\");\n+        static final ClassDesc CD_Array_byte         = ReferenceClassDescImpl.ofValidated(\"[B\");\n+        static final ClassDesc CD_Array_String       = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/String;\");\n+\n+        static final MethodTypeDesc MTD_byte_char       = MethodTypeDescImpl.ofValidated(CD_byte, CD_char);\n+        static final MethodTypeDesc MTD_byte            = MethodTypeDescImpl.ofValidated(CD_byte);\n+        static final MethodTypeDesc MTD_int             = MethodTypeDescImpl.ofValidated(CD_int);\n+        static final MethodTypeDesc MTD_int_int_boolean = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_boolean);\n+        static final MethodTypeDesc MTD_int_int_char    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_char);\n+        static final MethodTypeDesc MTD_int_int_int     = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_int);\n+        static final MethodTypeDesc MTD_int_int_long    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_long);\n+        static final MethodTypeDesc MTD_int_int_String  = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_String);\n+        static final MethodTypeDesc MTD_String_float    = MethodTypeDescImpl.ofValidated(CD_String, CD_float);\n+        static final MethodTypeDesc MTD_String_double   = MethodTypeDescImpl.ofValidated(CD_String, CD_double);\n+        static final MethodTypeDesc MTD_String_Object   = MethodTypeDescImpl.ofValidated(CD_String, CD_Object);\n+\n+        static final MethodTypeDesc MTD_INIT             = MethodTypeDescImpl.ofValidated(CD_void, CD_Array_String);\n+        static final MethodTypeDesc MTD_NEW_ARRAY_SUFFIX = MethodTypeDescImpl.ofValidated(CD_Array_byte, CD_String, CD_int, CD_byte);\n+        static final MethodTypeDesc MTD_STRING_INIT      = MethodTypeDescImpl.ofValidated(CD_void, CD_Array_byte, CD_byte);\n+\n+        static final MethodTypeDesc PREPEND_int     = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_int, CD_String);\n+        static final MethodTypeDesc PREPEND_long    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_long, CD_String);\n+        static final MethodTypeDesc PREPEND_boolean = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_boolean, CD_String);\n+        static final MethodTypeDesc PREPEND_char    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_char, CD_String);\n+        static final MethodTypeDesc PREPEND_String  = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_String, CD_String);\n+\n+        static final RuntimeVisibleAnnotationsAttribute FORCE_INLINE = RuntimeVisibleAnnotationsAttribute.of(Annotation.of(ClassDesc.ofDescriptor(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\")));\n+\n+        static final MethodType CONSTRUCTOR_METHOD_TYPE        = MethodType.methodType(void.class, String[].class);\n+        static final Consumer<CodeBuilder> CONSTRUCTOR_BUILDER = new Consumer<CodeBuilder>() {\n+            @Override\n+            public void accept(CodeBuilder cb) {\n+                \/*\n+                 * super(constants);\n+                 *\/\n+                int thisSlot      = cb.receiverSlot(),\n+                    constantsSlot = cb.parameterSlot(0);\n+                cb.aload(thisSlot)\n+                  .aload(constantsSlot)\n+                  .invokespecial(CD_StringConcatBase, INIT_NAME, MTD_INIT, false)\n+                  .return_();\n+            }\n+        };\n+\n+        static final ReferencedKeyMap<MethodType, SoftReference<MethodHandlePair>> CACHE =\n+                ReferencedKeyMap.create(true, true,\n+                        new Supplier<>() {\n+                            @Override\n+                            public Map<ReferenceKey<MethodType>, SoftReference<MethodHandlePair>> get() {\n+                                return new ConcurrentHashMap<>(64);\n+                            }\n+                        });\n+\n+        private InlineHiddenClassStrategy() {\n+            \/\/ no instantiation\n+        }\n+\n+        private record MethodHandlePair(MethodHandle constructor, MethodHandle concatenator) { };\n@@ -1068,2 +1153,1 @@\n-         * Ensure a capacity in the initial StringBuilder to accommodate all\n-         * constants plus this factor times the number of arguments.\n+         * The parameter types are normalized into 7 types: int,long,boolean,char,float,double,Object\n@@ -1071,1 +1155,20 @@\n-        static final int ARGUMENT_SIZE_FACTOR = 4;\n+        private static MethodType erasedArgs(MethodType args) {\n+            int parameterCount = args.parameterCount();\n+            var paramTypes = new Class<?>[parameterCount];\n+            boolean changed = false;\n+            for (int i = 0; i < parameterCount; i++) {\n+                Class<?> cl = args.parameterType(i);\n+                \/\/ Use int as the logical type for subword integral types\n+                \/\/ (byte and short). char and boolean require special\n+                \/\/ handling so don't change the logical type of those\n+                if (cl == byte.class || cl == short.class) {\n+                    cl = int.class;\n+                    changed = true;\n+                } else if (cl != Object.class && !cl.isPrimitive()) {\n+                    cl = Object.class;\n+                    changed = true;\n+                }\n+                paramTypes[i] = cl;\n+            }\n+            return changed ? MethodType.methodType(args.returnType(), paramTypes, true) : args;\n+        }\n@@ -1073,1 +1176,21 @@\n-        static final Set<Lookup.ClassOption> SET_OF_STRONG = Set.of(STRONG);\n+        \/**\n+         * Construct the MethodType of the prepend method, The parameters only support 5 types:\n+         * int\/long\/char\/boolean\/String. Not int\/long\/char\/boolean type, use String type<p>\n+         *\n+         * The following is an example of the generated target code:\n+         * <blockquote><pre>\n+         *  int prepend(int length, byte coder, byte[] buff,  String[] constants\n+         *      int arg0, long arg1, boolean arg2, char arg3, String arg5)\n+         * <\/pre><\/blockquote>\n+         *\/\n+        private static MethodTypeDesc prependArgs(MethodType concatArgs, boolean staticConcat) {\n+            int parameterCount = concatArgs.parameterCount();\n+            int prefixArgs = staticConcat ? 3 : 4;\n+            var paramTypes = new ClassDesc[parameterCount + prefixArgs];\n+            paramTypes[0] = CD_int;          \/\/ length\n+            paramTypes[1] = CD_byte;         \/\/ coder\n+            paramTypes[2] = CD_Array_byte;   \/\/ buff\n+\n+            if (!staticConcat) {\n+                paramTypes[3] = CD_Array_String; \/\/ constants\n+            }\n@@ -1075,2 +1198,54 @@\n-        private SimpleStringBuilderStrategy() {\n-            \/\/ no instantiation\n+            for (int i = 0; i < parameterCount; i++) {\n+                var cl = concatArgs.parameterType(i);\n+                paramTypes[i + prefixArgs] = needStringOf(cl) ? CD_String : ConstantUtils.classDesc(cl);\n+            }\n+            return MethodTypeDescImpl.ofValidated(CD_int, paramTypes);\n+        }\n+\n+        \/**\n+         * Construct the MethodType of the coder method. The first parameter is the initialized coder.\n+         * Only parameter types which can be UTF16 are added.\n+         * Returns null if no such parameter exists or CompactStrings is off.\n+         *\/\n+        private static MethodTypeDesc coderArgsIfMaybeUTF16(MethodType concatArgs) {\n+            if (JLA.stringInitCoder() != 0) {\n+                return null;\n+            }\n+\n+            int parameterCount = concatArgs.parameterCount();\n+\n+            int maybeUTF16Count = 0;\n+            for (int i = 0; i < parameterCount; i++) {\n+                if (maybeUTF16(concatArgs.parameterType(i))) {\n+                    maybeUTF16Count++;\n+                }\n+            }\n+\n+            if (maybeUTF16Count == 0) {\n+                return null;\n+            }\n+\n+            var paramTypes = new ClassDesc[maybeUTF16Count + 1];\n+            paramTypes[0] = CD_int; \/\/ init coder\n+            for (int i = 0, paramIndex = 1; i < parameterCount; i++) {\n+                var cl = concatArgs.parameterType(i);\n+                if (maybeUTF16(cl)) {\n+                    paramTypes[paramIndex++] = cl == char.class ? CD_char : CD_String;\n+                }\n+            }\n+            return MethodTypeDescImpl.ofValidated(CD_int, paramTypes);\n+        }\n+\n+        \/**\n+         * Construct the MethodType of the length method,\n+         * The first parameter is the initialized length\n+         *\/\n+        private static MethodTypeDesc lengthArgs(MethodType concatArgs) {\n+            int parameterCount = concatArgs.parameterCount();\n+            var paramTypes = new ClassDesc[parameterCount + 1];\n+            paramTypes[0] = CD_int; \/\/ init long\n+            for (int i = 0; i < parameterCount; i++) {\n+                var cl = concatArgs.parameterType(i);\n+                paramTypes[i + 1] = needStringOf(cl) ? CD_String : ConstantUtils.classDesc(cl);\n+            }\n+            return MethodTypeDescImpl.ofValidated(CD_int, paramTypes);\n@@ -1080,1 +1255,27 @@\n-            String className = getClassName(lookup.lookupClass());\n+            lookup = STR_LOOKUP;\n+            final MethodType concatArgs = erasedArgs(args);\n+\n+            \/\/ 1 argument use built-in method\n+            if (args.parameterCount() == 1) {\n+                Object concat1 = JLA.stringConcat1(constants);\n+                var handle = lookup.findVirtual(concat1.getClass(), METHOD_NAME, concatArgs);\n+                return handle.bindTo(concat1);\n+            }\n+\n+            boolean forceInline  = concatArgs.parameterCount() <  FORCE_INLINE_THRESHOLD;\n+            boolean staticConcat = concatArgs.parameterCount() >= CACHE_THRESHOLD;\n+\n+            if (!staticConcat) {\n+                var weakConstructorHandle = CACHE.get(concatArgs);\n+                if (weakConstructorHandle != null) {\n+                    MethodHandlePair handlePair = weakConstructorHandle.get();\n+                    if (handlePair != null) {\n+                        try {\n+                            var instance = handlePair.constructor.invokeBasic((Object)constants);\n+                            return handlePair.concatenator.bindTo(instance);\n+                        } catch (Throwable e) {\n+                            throw new StringConcatException(\"Exception while utilizing the hidden class\", e);\n+                        }\n+                    }\n+                }\n+            }\n@@ -1082,1 +1283,5 @@\n-            byte[] classBytes = ClassFile.of().build(ConstantUtils.binaryNameToDesc(className),\n+            MethodTypeDesc lengthArgs  = lengthArgs(concatArgs),\n+                           coderArgs   = coderArgsIfMaybeUTF16(concatArgs),\n+                           prependArgs = prependArgs(concatArgs, staticConcat);\n+\n+            byte[] classBytes = ClassFile.of().build(CD_CONCAT,\n@@ -1086,5 +1291,63 @@\n-                            clb.withFlags(AccessFlag.FINAL, AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n-                                .withMethodBody(METHOD_NAME,\n-                                        ConstantUtils.methodTypeDesc(args),\n-                                        ClassFile.ACC_FINAL | ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC,\n-                                        generateMethod(constants, args));\n+                            if (staticConcat) {\n+                                clb.withSuperclass(CD_Object)\n+                                   .withFlags(ACC_ABSTRACT | ACC_SUPER | ACC_SYNTHETIC);\n+                            } else {\n+                                clb.withSuperclass(CD_StringConcatBase)\n+                                   .withFlags(ACC_FINAL | ACC_SUPER | ACC_SYNTHETIC)\n+                                   .withMethodBody(INIT_NAME, MTD_INIT, 0, CONSTRUCTOR_BUILDER);\n+                            }\n+\n+                            clb.withMethod(\"length\",\n+                                        lengthArgs,\n+                                        ACC_STATIC | ACC_PRIVATE,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generateLengthMethod(lengthArgs));\n+                                            }\n+                                        })\n+                                .withMethod(\"prepend\",\n+                                        prependArgs,\n+                                        ACC_STATIC | ACC_PRIVATE,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generatePrependMethod(prependArgs, staticConcat, constants));\n+                                            }\n+                                        })\n+                                .withMethod(METHOD_NAME,\n+                                        ConstantUtils.methodTypeDesc(concatArgs),\n+                                        staticConcat ? ACC_STATIC | ACC_FINAL : ACC_FINAL,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generateConcatMethod(\n+                                                        staticConcat,\n+                                                        constants,\n+                                                        CD_CONCAT,\n+                                                        concatArgs,\n+                                                        lengthArgs,\n+                                                        coderArgs,\n+                                                        prependArgs));\n+                                            }\n+                                        });\n+\n+                            if (coderArgs != null) {\n+                                clb.withMethod(\"coder\",\n+                                        coderArgs,\n+                                        ACC_STATIC | ACC_PRIVATE,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generateCoderMethod(coderArgs));\n+                                            }\n+                                        });\n+                            }\n@@ -1093,5 +1356,13 @@\n-                Lookup hiddenLookup = lookup.makeHiddenClassDefiner(className, classBytes, SET_OF_STRONG, DUMPER)\n-                                            .defineClassAsLookup(true);\n-                Class<?> innerClass = hiddenLookup.lookupClass();\n-                return hiddenLookup.findStatic(innerClass, METHOD_NAME, args);\n-            } catch (Exception e) {\n+                var hiddenClass = lookup.makeHiddenClassDefiner(CLASS_NAME, classBytes, Set.of(), DUMPER)\n+                                        .defineClass(true, null);\n+\n+                if (staticConcat) {\n+                    return lookup.findStatic(hiddenClass, METHOD_NAME, concatArgs);\n+                }\n+\n+                var constructor = lookup.findConstructor(hiddenClass, CONSTRUCTOR_METHOD_TYPE);\n+                var concatenator = lookup.findVirtual(hiddenClass, METHOD_NAME, concatArgs);\n+                CACHE.put(concatArgs, new SoftReference<>(new MethodHandlePair(constructor, concatenator)));\n+                var instance = constructor.invokeBasic((Object)constants);\n+                return concatenator.bindTo(instance);\n+            } catch (Throwable e) {\n@@ -1102,1 +1373,73 @@\n-        private static Consumer<CodeBuilder> generateMethod(String[] constants, MethodType args) {\n+        \/**\n+         * Generate InlineCopy-based code. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         *  import static java.lang.StringConcatHelper.newArrayWithSuffix;\n+         *  import static java.lang.StringConcatHelper.prepend;\n+         *  import static java.lang.StringConcatHelper.stringCoder;\n+         *  import static java.lang.StringConcatHelper.stringSize;\n+         *\n+         *  class StringConcat extends java.lang.StringConcatHelper.StringConcatBase {\n+         *      \/\/ super class defines\n+         *      \/\/ String[] constants;\n+         *      \/\/ int length;\n+         *      \/\/ byte coder;\n+         *\n+         *      StringConcat(String[] constants) {\n+         *          super(constants);\n+         *      }\n+         *\n+         *      String concat(int arg0, long arg1, boolean arg2, char arg3, String arg4,\n+         *          float arg5, double arg6, Object arg7\n+         *      ) {\n+         *          \/\/ Types other than byte\/short\/int\/long\/boolean\/String require a local variable to store\n+         *          String str4 = stringOf(arg4);\n+         *          String str5 = stringOf(arg5);\n+         *          String str6 = stringOf(arg6);\n+         *          String str7 = stringOf(arg7);\n+         *\n+         *          int coder  = coder(this.coder, arg0, arg1, arg2, arg3, str4, str5, str6, str7);\n+         *          int length = length(this.length, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n+         *          String[] constants = this.constants;\n+         *          byte[] buf = newArrayWithSuffix(constants[paramCount], length. coder);\n+         *\n+         *          prepend(length, coder, buf, constants, arg0, arg1, arg2, arg3, str4, str5, str6, str7);\n+         *\n+         *          return new String(buf, coder);\n+         *      }\n+         *\n+         *      static int length(int length, int arg0, long arg1, boolean arg2, char arg3,\n+         *                       String arg4, String arg5, String arg6, String arg7) {\n+         *          return stringSize(stringSize(stringSize(stringSize(stringSize(stringSize(stringSize(stringSize(\n+         *                      length, arg0), arg1), arg2), arg3), arg4), arg5), arg6), arg7);\n+         *      }\n+         *\n+         *      static int cocder(int coder, char arg3, String str4, String str5, String str6, String str7) {\n+         *          return coder | stringCoder(arg3) | str4.coder() | str5.coder() | str6.coder() | str7.coder();\n+         *      }\n+         *\n+         *      static int prepend(int length, int coder, byte[] buf, String[] constants,\n+         *                     int arg0, long arg1, boolean arg2, char arg3,\n+         *                     String str4, String str5, String str6, String str7) {\n+         *          \/\/ StringConcatHelper.prepend\n+         *          return prepend(prepend(prepend(prepend(\n+         *                  prepend(apppend(prepend(prepend(length,\n+         *                       buf, str7, constant[7]), buf, str6, constant[6]),\n+         *                       buf, str5, constant[5]), buf, str4, constant[4]),\n+         *                       buf, arg3, constant[3]), buf, arg2, constant[2]),\n+         *                       buf, arg1, constant[1]), buf, arg0, constant[0]);\n+         *      }\n+         *  }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        private static Consumer<CodeBuilder> generateConcatMethod(\n+                boolean        staticConcat,\n+                String[]       constants,\n+                ClassDesc      concatClass,\n+                MethodType     concatArgs,\n+                MethodTypeDesc lengthArgs,\n+                MethodTypeDesc coderArgs,\n+                MethodTypeDesc prependArgs\n+        ) {\n@@ -1106,2 +1449,37 @@\n-                    cb.new_(STRING_BUILDER);\n-                    cb.dup();\n+                    \/\/ Compute parameter variable slots\n+                    int paramCount    = concatArgs.parameterCount(),\n+                        thisSlot      = staticConcat ? 0 : cb.receiverSlot(),\n+                        lengthSlot    = cb.allocateLocal(TypeKind.INT),\n+                        coderSlot     = cb.allocateLocal(TypeKind.BYTE),\n+                        bufSlot       = cb.allocateLocal(TypeKind.REFERENCE),\n+                        constantsSlot = cb.allocateLocal(TypeKind.REFERENCE),\n+                        suffixSlot    = cb.allocateLocal(TypeKind.REFERENCE);\n+\n+                    \/*\n+                     * Types other than int\/long\/char\/boolean require local variables to store the result of stringOf.\n+                     *\n+                     * stringSlots stores the slots of parameters relative to local variables\n+                     *\n+                     * str0 = stringOf(arg0);\n+                     * str1 = stringOf(arg1);\n+                     * ...\n+                     * strN = toString(argN);\n+                     *\/\n+                    int[] stringSlots = new int[paramCount];\n+                    for (int i = 0; i < paramCount; i++) {\n+                        var cl = concatArgs.parameterType(i);\n+                        if (needStringOf(cl)) {\n+                            MethodTypeDesc methodTypeDesc;\n+                            if (cl == float.class) {\n+                                methodTypeDesc = MTD_String_float;\n+                            } else if (cl == double.class) {\n+                                methodTypeDesc = MTD_String_double;\n+                            } else {\n+                                methodTypeDesc = MTD_String_Object;\n+                            }\n+                            stringSlots[i] = cb.allocateLocal(TypeKind.REFERENCE);\n+                            cb.loadLocal(TypeKind.from(cl), cb.parameterSlot(i))\n+                              .invokestatic(CD_StringConcatHelper, \"stringOf\", methodTypeDesc)\n+                              .astore(stringSlots[i]);\n+                        }\n+                    }\n@@ -1109,4 +1487,6 @@\n-                    int len = 0;\n-                    for (String constant : constants) {\n-                        if (constant != null) {\n-                            len += constant.length();\n+                    int coder  = JLA.stringInitCoder(),\n+                        length = 0;\n+                    if (staticConcat) {\n+                        for (var constant : constants) {\n+                            coder |= JLA.stringCoder(constant);\n+                            length += constant.length();\n@@ -1115,11 +1495,25 @@\n-                    len += args.parameterCount() * ARGUMENT_SIZE_FACTOR;\n-                    cb.loadConstant(len);\n-                    cb.invokespecial(STRING_BUILDER, \"<init>\", INT_CONSTRUCTOR_TYPE);\n-\n-                    \/\/ At this point, we have a blank StringBuilder on stack, fill it in with .append calls.\n-                    {\n-                        int off = 0;\n-                        for (int c = 0; c < args.parameterCount(); c++) {\n-                            if (constants[c] != null) {\n-                                cb.ldc(constants[c]);\n-                                cb.invokevirtual(STRING_BUILDER, \"append\", APPEND_STRING_TYPE);\n+\n+                    \/*\n+                     * coder = coder(this.coder, arg0, arg1, ... argN);\n+                     *\/\n+                    if (staticConcat) {\n+                        \/\/ coder can only be 0 or 1\n+                        if (coder == 0) {\n+                            cb.iconst_0();\n+                        } else {\n+                            cb.iconst_1();\n+                        }\n+                    } else {\n+                        cb.aload(thisSlot)\n+                          .getfield(concatClass, \"coder\", CD_byte);\n+                    }\n+\n+                    if (coderArgs != null) {\n+                        for (int i = 0; i < paramCount; i++) {\n+                            var cl = concatArgs.parameterType(i);\n+                            if (maybeUTF16(cl)) {\n+                                if (cl == char.class) {\n+                                    cb.loadLocal(TypeKind.CHAR, cb.parameterSlot(i));\n+                                } else {\n+                                    cb.aload(stringSlots[i]);\n+                                }\n@@ -1127,6 +1521,0 @@\n-                            Class<?> cl = args.parameterType(c);\n-                            TypeKind kind = TypeKind.from(cl);\n-                            cb.loadLocal(kind, off);\n-                            off += kind.slotSize();\n-                            MethodTypeDesc desc = getSBAppendDesc(cl);\n-                            cb.invokevirtual(STRING_BUILDER, \"append\", desc);\n@@ -1134,3 +1522,20 @@\n-                        if (constants[constants.length - 1] != null) {\n-                            cb.ldc(constants[constants.length - 1]);\n-                            cb.invokevirtual(STRING_BUILDER, \"append\", APPEND_STRING_TYPE);\n+                        cb.invokestatic(concatClass, \"coder\", coderArgs);\n+                    }\n+                    cb.istore(coderSlot);\n+\n+                    \/*\n+                     * length = length(this.length, arg0, arg1, ..., argN);\n+                     *\/\n+                    if (staticConcat) {\n+                        cb.ldc(length);\n+                    } else {\n+                        cb.aload(thisSlot)\n+                          .getfield(concatClass, \"length\", CD_int);\n+                    }\n+\n+                    for (int i = 0; i < paramCount; i++) {\n+                        var cl        = concatArgs.parameterType(i);\n+                        int paramSlot = cb.parameterSlot(i);\n+                        if (needStringOf(cl)) {\n+                            paramSlot = stringSlots[i];\n+                            cl = String.class;\n@@ -1138,0 +1543,25 @@\n+                        cb.loadLocal(TypeKind.from(cl), paramSlot);\n+                    }\n+                    cb.invokestatic(concatClass, \"length\", lengthArgs);\n+\n+                    \/*\n+                     * String[] constants = this.constants;\n+                     * suffix  = constants[paramCount];\n+                     * length -= suffix.length();\n+                     *\/\n+                    if (staticConcat) {\n+                        cb.ldc(constants[paramCount].length())\n+                          .isub()\n+                          .istore(lengthSlot);\n+                    } else {\n+                        cb.aload(thisSlot)\n+                          .getfield(concatClass, \"constants\", CD_Array_String)\n+                          .dup()\n+                          .astore(constantsSlot)\n+                          .ldc(paramCount)\n+                          .aaload()\n+                          .dup()\n+                          .astore(suffixSlot)\n+                          .invokevirtual(CD_String, \"length\", MTD_int)\n+                          .isub()\n+                          .istore(lengthSlot);\n@@ -1140,2 +1570,43 @@\n-                    cb.invokevirtual(STRING_BUILDER, \"toString\", TO_STRING_TYPE);\n-                    cb.areturn();\n+                    \/*\n+                     * Allocate buffer :\n+                     *\n+                     *  buf = newArrayWithSuffix(suffix, length, coder)\n+                     *\/\n+                    if (staticConcat) {\n+                        cb.ldc(constants[paramCount]);\n+                    } else {\n+                        cb.aload(suffixSlot);\n+                    }\n+                    cb.iload(lengthSlot)\n+                      .iload(coderSlot)\n+                      .invokestatic(CD_StringConcatHelper, \"newArrayWithSuffix\", MTD_NEW_ARRAY_SUFFIX)\n+                      .astore(bufSlot);\n+\n+                    \/*\n+                     * prepend(length, coder, buf, constants, ar0, ar1, ..., argN);\n+                     *\/\n+                    cb.iload(lengthSlot)\n+                      .iload(coderSlot)\n+                      .aload(bufSlot);\n+                    if (!staticConcat) {\n+                        cb.aload(constantsSlot);\n+                    }\n+                    for (int i = 0; i < paramCount; i++) {\n+                        var cl = concatArgs.parameterType(i);\n+                        int paramSlot = cb.parameterSlot(i);\n+                        var kind = TypeKind.from(cl);\n+                        if (needStringOf(cl)) {\n+                            paramSlot = stringSlots[i];\n+                            kind = TypeKind.REFERENCE;\n+                        }\n+                        cb.loadLocal(kind, paramSlot);\n+                    }\n+                    cb.invokestatic(concatClass, \"prepend\", prependArgs);\n+\n+                    \/\/ return new String(buf, coder);\n+                    cb.new_(CD_String)\n+                      .dup()\n+                      .aload(bufSlot)\n+                      .iload(coderSlot)\n+                      .invokespecial(CD_String, INIT_NAME, MTD_STRING_INIT)\n+                      .areturn();\n@@ -1147,3 +1618,12 @@\n-         * The generated class is in the same package as the host class as\n-         * it's the implementation of the string concatenation for the host\n-         * class.\n+         * Generate length method. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         * import static java.lang.StringConcatHelper.stringSize;\n+         *\n+         * static int length(int length, int arg0, long arg1, boolean arg2, char arg3,\n+         *                  String arg4, String arg5, String arg6, String arg7) {\n+         *     return stringSize(stringSize(stringSize(length, arg0), arg1), ..., arg7);\n+         * }\n+         * <\/pre><\/blockquote>\n@@ -1151,4 +1631,26 @@\n-        private static String getClassName(Class<?> hostClass) {\n-            String name = hostClass.isHidden() ? hostClass.getName().replace('\/', '_')\n-                    : hostClass.getName();\n-            return name + \"$$StringConcat\";\n+        private static Consumer<CodeBuilder> generateLengthMethod(MethodTypeDesc lengthArgs) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    int lengthSlot = cb.parameterSlot(0);\n+                    cb.iload(lengthSlot);\n+                    for (int i = 1; i < lengthArgs.parameterCount(); i++) {\n+                        var cl = lengthArgs.parameterType(i);\n+                        MethodTypeDesc methodTypeDesc;\n+                        if (cl == CD_char) {\n+                            methodTypeDesc = MTD_int_int_char;\n+                        } else if (cl == CD_int) {\n+                            methodTypeDesc = MTD_int_int_int;\n+                        } else if (cl == CD_long) {\n+                            methodTypeDesc = MTD_int_int_long;\n+                        } else if (cl == CD_boolean) {\n+                            methodTypeDesc = MTD_int_int_boolean;\n+                        } else {\n+                            methodTypeDesc = MTD_int_int_String;\n+                        }\n+                        cb.loadLocal(TypeKind.from(cl), cb.parameterSlot(i))\n+                          .invokestatic(CD_StringConcatHelper, \"stringSize\", methodTypeDesc);\n+                    }\n+                    cb.ireturn();\n+                }\n+            };\n@@ -1157,16 +1659,33 @@\n-        private static MethodTypeDesc getSBAppendDesc(Class<?> cl) {\n-            if (cl.isPrimitive()) {\n-                if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {\n-                    return APPEND_INT_TYPE;\n-                } else if (cl == Boolean.TYPE) {\n-                    return APPEND_BOOLEAN_TYPE;\n-                } else if (cl == Character.TYPE) {\n-                    return APPEND_CHAR_TYPE;\n-                } else if (cl == Double.TYPE) {\n-                    return APPEND_DOUBLE_TYPE;\n-                } else if (cl == Float.TYPE) {\n-                    return APPEND_FLOAT_TYPE;\n-                } else if (cl == Long.TYPE) {\n-                    return APPEND_LONG_TYPE;\n-                } else {\n-                    throw new IllegalStateException(\"Unhandled primitive StringBuilder.append: \" + cl);\n+        \/**\n+         * Generate coder method. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         * import static java.lang.StringConcatHelper.stringCoder;\n+         *\n+         * static int cocder(int coder, char arg3, String str4, String str5, String str6, String str7) {\n+         *     return coder | stringCoder(arg3) | str4.coder() | str5.coder() | str6.coder() | str7.coder();\n+         * }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        private static Consumer<CodeBuilder> generateCoderMethod(MethodTypeDesc coderArgs) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    \/*\n+                     * return coder | stringCoder(argN) | ... | arg1.coder() | arg0.coder();\n+                     *\/\n+                    int coderSlot = cb.parameterSlot(0);\n+                    cb.iload(coderSlot);\n+                    for (int i = 1; i < coderArgs.parameterCount(); i++) {\n+                        var cl = coderArgs.parameterType(i);\n+                        cb.loadLocal(TypeKind.from(cl), cb.parameterSlot(i));\n+                        if (cl == CD_char) {\n+                            cb.invokestatic(CD_StringConcatHelper, \"stringCoder\", MTD_byte_char);\n+                        } else {\n+                            cb.invokevirtual(CD_String, \"coder\", MTD_byte);\n+                        }\n+                        cb.ior();\n+                    }\n+                    cb.ireturn();\n@@ -1174,5 +1693,90 @@\n-            } else if (cl == String.class) {\n-                return APPEND_STRING_TYPE;\n-            } else {\n-                return APPEND_OBJECT_TYPE;\n-            }\n+            };\n+        }\n+\n+        \/**\n+         * Generate prepend method. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         * import static java.lang.StringConcatHelper.prepend;\n+         *\n+         * static int prepend(int length, int coder, byte[] buf, String[] constants,\n+         *                int arg0, long arg1, boolean arg2, char arg3,\n+         *                String str4, String str5, String str6, String str7) {\n+         *\n+         *     return prepend(prepend(prepend(prepend(\n+         *             prepend(prepend(prepend(prepend(length,\n+         *                  buf, str7, constant[7]), buf, str6, constant[6]),\n+         *                  buf, str5, constant[5]), buf, str4, constant[4]),\n+         *                  buf, arg3, constant[3]), buf, arg2, constant[2]),\n+         *                  buf, arg1, constant[1]), buf, arg0, constant[0]);\n+         * }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        private static Consumer<CodeBuilder> generatePrependMethod(\n+                MethodTypeDesc prependArgs,\n+                boolean staticConcat, String[] constants\n+        ) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    \/\/ Compute parameter variable slots\n+                    int lengthSlot    = cb.parameterSlot(0),\n+                        coderSlot     = cb.parameterSlot(1),\n+                        bufSlot       = cb.parameterSlot(2),\n+                        constantsSlot = cb.parameterSlot(3);\n+                    \/*\n+                     * \/\/ StringConcatHelper.prepend\n+                     * return prepend(prepend(prepend(prepend(\n+                     *         prepend(apppend(prepend(prepend(length,\n+                     *              buf, str7, constant[7]), buf, str6, constant[6]),\n+                     *              buf, str5, constant[5]), buf, arg4, constant[4]),\n+                     *              buf, arg3, constant[3]), buf, arg2, constant[2]),\n+                     *              buf, arg1, constant[1]), buf, arg0, constant[0]);\n+                     *\/\n+                    cb.iload(lengthSlot);\n+                    for (int i = prependArgs.parameterCount() - 1, end = staticConcat ? 3 : 4; i >= end; i--) {\n+                        var cl   = prependArgs.parameterType(i);\n+                        var kind = TypeKind.from(cl);\n+\n+                        \/\/ There are only 5 types of parameters: int, long, boolean, char, String\n+                        MethodTypeDesc methodTypeDesc;\n+                        if (cl == CD_int) {\n+                            methodTypeDesc = PREPEND_int;\n+                        } else if (cl == CD_long) {\n+                            methodTypeDesc = PREPEND_long;\n+                        } else if (cl == CD_boolean) {\n+                            methodTypeDesc = PREPEND_boolean;\n+                        } else if (cl == CD_char) {\n+                            methodTypeDesc = PREPEND_char;\n+                        } else {\n+                            kind = TypeKind.REFERENCE;\n+                            methodTypeDesc = PREPEND_String;\n+                        }\n+\n+                        cb.iload(coderSlot)\n+                          .aload(bufSlot)\n+                          .loadLocal(kind, cb.parameterSlot(i));\n+\n+                        if (staticConcat) {\n+                            cb.ldc(constants[i - 3]);\n+                        } else {\n+                            cb.aload(constantsSlot)\n+                              .ldc(i - 4)\n+                              .aaload();\n+                        }\n+\n+                        cb.invokestatic(CD_StringConcatHelper, \"prepend\", methodTypeDesc);\n+                    }\n+                    cb.ireturn();\n+                }\n+            };\n+        }\n+\n+        static boolean needStringOf(Class<?> cl) {\n+            return cl != int.class && cl != long.class && cl != boolean.class && cl != char.class;\n+        }\n+\n+        static boolean maybeUTF16(Class<?> cl) {\n+            return cl == char.class || !cl.isPrimitive();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":723,"deletions":119,"binary":false,"changes":842,"status":"modified"},{"patch":"@@ -72,8 +72,8 @@\n-        if (type == Integer.class)   return TypeKind.IntType;\n-        if (type == Long.class)      return TypeKind.LongType;\n-        if (type == Boolean.class)   return TypeKind.BooleanType;\n-        if (type == Short.class)     return TypeKind.ShortType;\n-        if (type == Byte.class)      return TypeKind.ByteType;\n-        if (type == Character.class) return TypeKind.CharType;\n-        if (type == Float.class)     return TypeKind.FloatType;\n-        if (type == Double.class)    return TypeKind.DoubleType;\n+        if (type == Integer.class)   return TypeKind.INT;\n+        if (type == Long.class)      return TypeKind.LONG;\n+        if (type == Boolean.class)   return TypeKind.BOOLEAN;\n+        if (type == Short.class)     return TypeKind.SHORT;\n+        if (type == Byte.class)      return TypeKind.BYTE;\n+        if (type == Character.class) return TypeKind.CHAR;\n+        if (type == Float.class)     return TypeKind.FLOAT;\n+        if (type == Double.class)    return TypeKind.DOUBLE;\n@@ -97,8 +97,8 @@\n-            case BooleanType -> cob.invokestatic(BoxHolder.BOX_BOOLEAN);\n-            case ByteType    -> cob.invokestatic(BoxHolder.BOX_BYTE);\n-            case CharType    -> cob.invokestatic(BoxHolder.BOX_CHAR);\n-            case DoubleType  -> cob.invokestatic(BoxHolder.BOX_DOUBLE);\n-            case FloatType   -> cob.invokestatic(BoxHolder.BOX_FLOAT);\n-            case IntType     -> cob.invokestatic(BoxHolder.BOX_INT);\n-            case LongType    -> cob.invokestatic(BoxHolder.BOX_LONG);\n-            case ShortType   -> cob.invokestatic(BoxHolder.BOX_SHORT);\n+            case BOOLEAN -> cob.invokestatic(BoxHolder.BOX_BOOLEAN);\n+            case BYTE -> cob.invokestatic(BoxHolder.BOX_BYTE);\n+            case CHAR -> cob.invokestatic(BoxHolder.BOX_CHAR);\n+            case DOUBLE -> cob.invokestatic(BoxHolder.BOX_DOUBLE);\n+            case FLOAT -> cob.invokestatic(BoxHolder.BOX_FLOAT);\n+            case INT -> cob.invokestatic(BoxHolder.BOX_INT);\n+            case LONG -> cob.invokestatic(BoxHolder.BOX_LONG);\n+            case SHORT -> cob.invokestatic(BoxHolder.BOX_SHORT);\n@@ -110,8 +110,8 @@\n-            case BooleanType -> cob.invokevirtual(BoxHolder.UNBOX_BOOLEAN);\n-            case ByteType    -> cob.invokevirtual(BoxHolder.UNBOX_BYTE);\n-            case CharType    -> cob.invokevirtual(BoxHolder.UNBOX_CHAR);\n-            case DoubleType  -> cob.invokevirtual(BoxHolder.UNBOX_DOUBLE);\n-            case FloatType   -> cob.invokevirtual(BoxHolder.UNBOX_FLOAT);\n-            case IntType     -> cob.invokevirtual(BoxHolder.UNBOX_INT);\n-            case LongType    -> cob.invokevirtual(BoxHolder.UNBOX_LONG);\n-            case ShortType   -> cob.invokevirtual(BoxHolder.UNBOX_SHORT);\n+            case BOOLEAN -> cob.invokevirtual(BoxHolder.UNBOX_BOOLEAN);\n+            case BYTE -> cob.invokevirtual(BoxHolder.UNBOX_BYTE);\n+            case CHAR -> cob.invokevirtual(BoxHolder.UNBOX_CHAR);\n+            case DOUBLE -> cob.invokevirtual(BoxHolder.UNBOX_DOUBLE);\n+            case FLOAT -> cob.invokevirtual(BoxHolder.UNBOX_FLOAT);\n+            case INT -> cob.invokevirtual(BoxHolder.UNBOX_INT);\n+            case LONG -> cob.invokevirtual(BoxHolder.UNBOX_LONG);\n+            case SHORT -> cob.invokevirtual(BoxHolder.UNBOX_SHORT);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/TypeConvertingMethodAdapter.java","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -31,0 +32,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -48,1 +50,1 @@\n-    static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, long.class);\n+    static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, MemoryLayout.class, long.class, long.class);\n@@ -56,1 +58,1 @@\n-        return accessType.accessModeType(MemorySegment.class, $type$.class, long.class);\n+        return accessType.accessModeType(MemorySegment.class, $type$.class, MemoryLayout.class, long.class, long.class);\n@@ -100,1 +102,1 @@\n-    static AbstractMemorySegmentImpl checkReadOnly(Object obb, boolean ro) {\n+    static AbstractMemorySegmentImpl checkSegment(Object obb, Object encl, long base, boolean ro) {\n@@ -102,1 +104,1 @@\n-        oo.checkReadOnly(ro);\n+        oo.checkEnclosingLayout(base, (MemoryLayout)encl, ro);\n@@ -107,1 +109,1 @@\n-    static long offsetNonPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+    static long offsetNonPlain(AbstractMemorySegmentImpl bb, long base, long offset, long alignmentMask) {\n@@ -111,1 +113,1 @@\n-        return offsetPlain(bb, offset);\n+        return offsetPlain(bb, base, offset);\n@@ -115,3 +117,3 @@\n-    static long offsetPlain(AbstractMemorySegmentImpl bb, long offset) {\n-        long base = bb.unsafeGetOffset();\n-        return base + offset;\n+    static long offsetPlain(AbstractMemorySegmentImpl bb, long base, long offset) {\n+        long segment_base = bb.unsafeGetOffset();\n+        return segment_base + base + offset;\n@@ -121,1 +123,1 @@\n-    static $type$ get(VarHandle ob, Object obb, long base) {\n+    static $type$ get(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -123,1 +125,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -127,1 +129,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -134,1 +136,1 @@\n-                offsetPlain(bb, base));\n+                offsetPlain(bb, base, offset));\n@@ -138,1 +140,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -145,1 +147,1 @@\n-    static void set(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void set(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -147,1 +149,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -151,1 +153,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -158,1 +160,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -163,1 +165,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -171,1 +173,1 @@\n-    static $type$ getVolatile(VarHandle ob, Object obb, long base) {\n+    static $type$ getVolatile(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -173,1 +175,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -177,1 +179,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n@@ -181,1 +183,1 @@\n-    static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setVolatile(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -183,1 +185,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -186,1 +188,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -191,1 +193,1 @@\n-    static $type$ getAcquire(VarHandle ob, Object obb, long base) {\n+    static $type$ getAcquire(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -193,1 +195,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -197,1 +199,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n@@ -201,1 +203,1 @@\n-    static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -203,1 +205,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -206,1 +208,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -211,1 +213,1 @@\n-    static $type$ getOpaque(VarHandle ob, Object obb, long base) {\n+    static $type$ getOpaque(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -213,1 +215,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -217,1 +219,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n@@ -221,1 +223,1 @@\n-    static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setOpaque(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -223,1 +225,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -226,1 +228,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -232,1 +234,1 @@\n-    static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean compareAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -234,1 +236,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -237,1 +239,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -242,1 +244,1 @@\n-    static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchange(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -244,1 +246,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -248,1 +250,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -253,1 +255,1 @@\n-    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -255,1 +257,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -259,1 +261,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -264,1 +266,1 @@\n-    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -266,1 +268,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -270,1 +272,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -275,1 +277,1 @@\n-    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -277,1 +279,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -280,1 +282,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -285,1 +287,1 @@\n-    static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -287,1 +289,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -290,1 +292,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -295,1 +297,1 @@\n-    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -297,1 +299,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -300,1 +302,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -305,1 +307,1 @@\n-    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -307,1 +309,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -310,1 +312,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -315,1 +317,1 @@\n-    static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -317,1 +319,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -321,1 +323,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -326,1 +328,1 @@\n-    static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSetAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -328,1 +330,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -332,1 +334,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -337,1 +339,1 @@\n-    static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSetRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -339,1 +341,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -343,1 +345,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -350,1 +352,1 @@\n-    static $type$ getAndAdd(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAdd(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n@@ -352,1 +354,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -356,1 +358,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -359,1 +361,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n@@ -364,1 +366,1 @@\n-    static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAddAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n@@ -366,1 +368,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -370,1 +372,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -373,1 +375,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n@@ -378,1 +380,1 @@\n-    static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAddRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n@@ -380,1 +382,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -384,1 +386,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -387,1 +389,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n@@ -406,1 +408,1 @@\n-    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -408,1 +410,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -412,1 +414,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -415,1 +417,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -420,1 +422,1 @@\n-    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -422,1 +424,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -426,1 +428,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -429,1 +431,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -434,1 +436,1 @@\n-    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -436,1 +438,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -440,1 +442,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -443,1 +445,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -460,1 +462,1 @@\n-    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -462,1 +464,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -466,1 +468,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -469,1 +471,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -474,1 +476,1 @@\n-    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -476,1 +478,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -480,1 +482,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -483,1 +485,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -488,1 +490,1 @@\n-    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -490,1 +492,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -494,1 +496,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -497,1 +499,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -515,1 +517,1 @@\n-    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -517,1 +519,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -521,1 +523,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -524,1 +526,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -529,1 +531,1 @@\n-    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -531,1 +533,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -535,1 +537,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -538,1 +540,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -543,1 +545,1 @@\n-    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -545,1 +547,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -549,1 +551,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -552,1 +554,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":120,"deletions":118,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -157,3 +157,3 @@\n- * specific. In the JDK the default set of root modules contains every module\n- * that is observable on the upgrade module path or among the system modules,\n- * and that exports at least one package without qualification. <\/p>\n+ * specific. In the JDK the default set of root modules contains every module on\n+ * the upgrade module path or among the system modules that exports at least one\n+ * package, without qualification. <\/p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -531,1 +531,1 @@\n-         * @jvms 4.6 Method\n+         * @jvms 4.6 Methods\n@@ -543,1 +543,1 @@\n-         * @jvms 4.7.24. The MethodParameters Attribute\n+         * @jvms 4.7.24 The MethodParameters Attribute\n@@ -549,1 +549,1 @@\n-         * @jvms 4.7.25. The Module Attribute\n+         * @jvms 4.7.25 The Module Attribute\n@@ -555,1 +555,1 @@\n-         * @jvms 4.7.25. The Module Attribute\n+         * @jvms 4.7.25 The Module Attribute\n@@ -561,1 +561,1 @@\n-         * @jvms 4.7.25. The Module Attribute\n+         * @jvms 4.7.25 The Module Attribute\n@@ -567,1 +567,1 @@\n-         * @jvms 4.7.25. The Module Attribute\n+         * @jvms 4.7.25 The Module Attribute\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,2 +50,2 @@\n- * <em>declaration annotation<\/em> and an annotation on a type is a\n- * <em>type annotation<\/em>.\n+ * <dfn>{@index \"declaration annotation\"}<\/dfn> and an annotation on a type is a\n+ * <dfn>{@index \"type annotation\"}<\/dfn>.\n@@ -81,1 +81,1 @@\n- * <li> An annotation <i>A<\/i> is <em>directly present<\/em> on an\n+ * <li> An annotation <i>A<\/i> is <dfn>{@index \"directly present\"}<\/dfn> on an\n@@ -88,1 +88,1 @@\n- * <li>An annotation <i>A<\/i> is <em>indirectly present<\/em> on an\n+ * <li>An annotation <i>A<\/i> is <dfn>{@index \"indirectly present\"}<\/dfn> on an\n@@ -95,1 +95,1 @@\n- * <li>An annotation <i>A<\/i> is <em>present<\/em> on an element <i>E<\/i> if either:\n+ * <li>An annotation <i>A<\/i> is <dfn>{@index \"present\"}<\/dfn> on an element <i>E<\/i> if either:\n@@ -107,1 +107,1 @@\n- * <li>An annotation <i>A<\/i> is <em>associated<\/em> with an element <i>E<\/i>\n+ * <li>An annotation <i>A<\/i> is <dfn>{@index \"associated\"}<\/dfn> with an element <i>E<\/i>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AnnotatedElement.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -168,0 +168,8 @@\n+    \/\/ Creates a new root constructor with a custom accessor for serialization hooks.\n+    Constructor<T> newWithAccessor(ConstructorAccessor accessor) {\n+        var res = new Constructor<>(clazz, parameterTypes, exceptionTypes, modifiers, slot,\n+                signature, annotations, parameterAnnotations);\n+        res.constructorAccessor = accessor;\n+        return res;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -257,1 +257,1 @@\n-     * @jvms 5.4.3. Method Resolution\n+     * @jvms 5.4.3 Resolution\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/InvocationHandler.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -176,15 +176,0 @@\n-    \/**\n-     * Make a copy of a leaf method.\n-     *\/\n-    Method leafCopy() {\n-        if (this.root == null)\n-            throw new IllegalArgumentException(\"Can only leafCopy a non-root Method\");\n-\n-        Method res = new Method(clazz, name, parameterTypes, returnType,\n-                exceptionTypes, modifiers, slot, signature,\n-                annotations, parameterAnnotations, annotationDefault);\n-        res.root = root;\n-        res.methodAccessor = methodAccessor;\n-        return res;\n-    }\n-\n@@ -773,1 +758,1 @@\n-     * @jls 9.6.2 Defaults for Annotation Type Elements\n+     * @jls 9.6.2 Defaults for Annotation Interface Elements\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import jdk.internal.reflect.MethodAccessor;\n+import jdk.internal.access.JavaLangReflectAccess;\n@@ -34,53 +34,3 @@\n-\n-class ReflectAccess implements jdk.internal.access.JavaLangReflectAccess {\n-    public <T> Constructor<T> newConstructor(Class<T> declaringClass,\n-                                             Class<?>[] parameterTypes,\n-                                             Class<?>[] checkedExceptions,\n-                                             int modifiers,\n-                                             int slot,\n-                                             String signature,\n-                                             byte[] annotations,\n-                                             byte[] parameterAnnotations)\n-    {\n-        return new Constructor<>(declaringClass,\n-                                  parameterTypes,\n-                                  checkedExceptions,\n-                                  modifiers,\n-                                  slot,\n-                                  signature,\n-                                  annotations,\n-                                  parameterAnnotations);\n-    }\n-\n-    public MethodAccessor getMethodAccessor(Method m) {\n-        return m.getMethodAccessor();\n-    }\n-\n-    public void setMethodAccessor(Method m, MethodAccessor accessor) {\n-        m.setMethodAccessor(accessor);\n-    }\n-\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c) {\n-        return c.getConstructorAccessor();\n-    }\n-\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor)\n-    {\n-        c.setConstructorAccessor(accessor);\n-    }\n-\n-    public int getConstructorSlot(Constructor<?> c) {\n-        return c.getSlot();\n-    }\n-\n-    public String getConstructorSignature(Constructor<?> c) {\n-        return c.getSignature();\n-    }\n-\n-    public byte[] getConstructorAnnotations(Constructor<?> c) {\n-        return c.getRawAnnotations();\n-    }\n-\n-    public byte[] getConstructorParameterAnnotations(Constructor<?> c) {\n-        return c.getRawParameterAnnotations();\n+final class ReflectAccess implements JavaLangReflectAccess {\n+    public <T> Constructor<T> newConstructorWithAccessor(Constructor<T> original, ConstructorAccessor accessor) {\n+        return original.newWithAccessor(accessor);\n@@ -108,3 +58,0 @@\n-    public Method      leafCopyMethod(Method arg) {\n-        return arg.leafCopy();\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":5,"deletions":58,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -59,3 +57,1 @@\n-    private static final MethodType DESCRIPTOR_MT = MethodType.methodType(MethodType.class);\n-    private static final MethodType NAMES_MT = MethodType.methodType(List.class);\n-    private static final MethodHandle FALSE = MethodHandles.constant(boolean.class, false);\n+    private static final MethodHandle FALSE = MethodHandles.zero(boolean.class);\n@@ -63,1 +59,1 @@\n-    private static final MethodHandle ZERO = MethodHandles.constant(int.class, 0);\n+    private static final MethodHandle ZERO = MethodHandles.zero(int.class);\n@@ -65,1 +61,0 @@\n-    private static final MethodHandle OBJECT_EQUALS;\n@@ -70,3 +65,0 @@\n-    private static final MethodHandle OBJECT_HASHCODE;\n-    private static final MethodHandle OBJECT_TO_STRING;\n-    private static final MethodHandle STRING_FORMAT;\n@@ -85,5 +77,0 @@\n-            @SuppressWarnings(\"removal\")\n-            ClassLoader loader = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n-                @Override public ClassLoader run() { return ClassLoader.getPlatformClassLoader(); }\n-            });\n-\n@@ -92,8 +79,0 @@\n-            OBJECT_EQUALS = publicLookup.findVirtual(Object.class, \"equals\",\n-                                                     MethodType.methodType(boolean.class, Object.class));\n-            OBJECT_HASHCODE = publicLookup.findVirtual(Object.class, \"hashCode\",\n-                                                       MethodType.fromMethodDescriptorString(\"()I\", loader));\n-            OBJECT_TO_STRING = publicLookup.findVirtual(Object.class, \"toString\",\n-                                                        MethodType.methodType(String.class));\n-            STRING_FORMAT = publicLookup.findStatic(String.class, \"format\",\n-                                                    MethodType.methodType(String.class, String.class, Object[].class));\n@@ -110,1 +89,1 @@\n-                                              MethodType.fromMethodDescriptorString(\"(II)I\", loader));\n+                                              MethodType.methodType(int.class, int.class, int.class));\n@@ -113,1 +92,1 @@\n-                                                              MethodType.fromMethodDescriptorString(\"(BB)Z\", loader)));\n+                                                              MethodType.methodType(boolean.class, byte.class, byte.class)));\n@@ -115,1 +94,1 @@\n-                                                               MethodType.fromMethodDescriptorString(\"(SS)Z\", loader)));\n+                                                               MethodType.methodType(boolean.class, short.class, short.class)));\n@@ -117,1 +96,1 @@\n-                                                              MethodType.fromMethodDescriptorString(\"(CC)Z\", loader)));\n+                                                              MethodType.methodType(boolean.class, char.class, char.class)));\n@@ -119,1 +98,1 @@\n-                                                             MethodType.fromMethodDescriptorString(\"(II)Z\", loader)));\n+                                                             MethodType.methodType(boolean.class, int.class, int.class)));\n@@ -121,1 +100,1 @@\n-                                                              MethodType.fromMethodDescriptorString(\"(JJ)Z\", loader)));\n+                                                              MethodType.methodType(boolean.class, long.class, long.class)));\n@@ -123,1 +102,1 @@\n-                                                               MethodType.fromMethodDescriptorString(\"(FF)Z\", loader)));\n+                                                               MethodType.methodType(boolean.class, float.class, float.class)));\n@@ -125,1 +104,1 @@\n-                                                                MethodType.fromMethodDescriptorString(\"(DD)Z\", loader)));\n+                                                                MethodType.methodType(boolean.class, double.class, double.class)));\n@@ -127,1 +106,1 @@\n-                                                                 MethodType.fromMethodDescriptorString(\"(ZZ)Z\", loader)));\n+                                                                 MethodType.methodType(boolean.class, boolean.class, boolean.class)));\n@@ -130,1 +109,1 @@\n-                                                               MethodType.fromMethodDescriptorString(\"(B)I\", loader)));\n+                                                               MethodType.methodType(int.class, byte.class)));\n@@ -132,1 +111,1 @@\n-                                                                MethodType.fromMethodDescriptorString(\"(S)I\", loader)));\n+                                                                MethodType.methodType(int.class, short.class)));\n@@ -134,1 +113,1 @@\n-                                                               MethodType.fromMethodDescriptorString(\"(C)I\", loader)));\n+                                                               MethodType.methodType(int.class, char.class)));\n@@ -136,1 +115,1 @@\n-                                                              MethodType.fromMethodDescriptorString(\"(I)I\", loader)));\n+                                                              MethodType.methodType(int.class, int.class)));\n@@ -138,1 +117,1 @@\n-                                                               MethodType.fromMethodDescriptorString(\"(J)I\", loader)));\n+                                                               MethodType.methodType(int.class, long.class)));\n@@ -140,1 +119,1 @@\n-                                                                MethodType.fromMethodDescriptorString(\"(F)I\", loader)));\n+                                                                MethodType.methodType(int.class, float.class)));\n@@ -142,1 +121,1 @@\n-                                                                 MethodType.fromMethodDescriptorString(\"(D)I\", loader)));\n+                                                                 MethodType.methodType(int.class, double.class)));\n@@ -144,1 +123,1 @@\n-                                                                  MethodType.fromMethodDescriptorString(\"(Z)I\", loader)));\n+                                                                  MethodType.methodType(int.class, boolean.class)));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":19,"deletions":40,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import java.util.stream.Stream;\n+\n@@ -53,0 +53,1 @@\n+import jdk.internal.constant.MethodTypeDescImpl;\n@@ -84,0 +85,2 @@\n+    private static final ClassDesc CD_BiPredicate = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/function\/BiPredicate;\");\n+    private static final ClassDesc CD_Objects = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n@@ -85,1 +88,11 @@\n-    private static final MethodType TYPES_SWITCH_TYPE = MethodType.methodType(int.class,\n+    private static final MethodTypeDesc CHECK_INDEX_DESCRIPTOR =\n+            MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int, ConstantDescs.CD_int, ConstantDescs.CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH_EXTRA = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int,\n+            CD_BiPredicate,\n+            ConstantDescs.CD_List);\n+    private static final MethodType MT_TYPE_SWITCH_EXTRA = MethodType.methodType(int.class,\n@@ -90,7 +103,3 @@\n-\n-    private static final MethodTypeDesc TYPES_SWITCH_DESCRIPTOR =\n-            MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;ILjava\/util\/function\/BiPredicate;Ljava\/util\/List;)I\");\n-    private static final MethodTypeDesc CHECK_INDEX_DESCRIPTOR =\n-            MethodTypeDesc.ofDescriptor(\"(II)I\");\n-\n-    private static final ClassDesc CD_Objects = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n+    private static final MethodType MT_TYPE_SWITCH = MethodType.methodType(int.class,\n+            Object.class,\n+            int.class);\n@@ -183,1 +192,1 @@\n-\n+        target = target.asType(invocationType);\n@@ -275,1 +284,0 @@\n-        requireNonNull(labels);\n@@ -277,1 +285,1 @@\n-        labels = labels.clone();\n+        labels = labels.clone(); \/\/ implicit null check\n@@ -304,1 +312,0 @@\n-\n@@ -437,0 +444,27 @@\n+    \/**\n+     * Check if the labelConstants can be converted statically to bytecode, or\n+     * whether we'll need to compute and pass in extra information at the call site.\n+     *\/\n+    private static boolean needsExtraInfo(Class<?> selectorType, Object[] labelConstants) {\n+        for (int idx = labelConstants.length - 1; idx >= 0; idx--) {\n+            Object currentLabel = labelConstants[idx];\n+            if (currentLabel instanceof Class<?> classLabel) {\n+                \/\/ No extra info needed for exact matches or primitives\n+                if (unconditionalExactnessCheck(selectorType, classLabel) || classLabel.isPrimitive()) {\n+                    continue;\n+                }\n+                \/\/ Hidden classes - or arrays thereof - can't be nominally\n+                \/\/ represented. Passed in as arguments.\n+                while (classLabel.isArray()) {\n+                    classLabel = classLabel.getComponentType();\n+                }\n+                if (classLabel.isHidden()) {\n+                    return true;\n+                }\n+            } else if (currentLabel instanceof EnumDesc<?>) {\n+                \/\/ EnumDescs labels needs late binding\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n@@ -470,3 +504,4 @@\n-            record Element(Label target, Label next, Object caseLabel) { }\n-            List<Element> cases = new ArrayList<>();\n-            List<SwitchCase> switchCases = new ArrayList<>();\n+            Label[] caseTargets = new Label[labelConstants.length];\n+            Label[] caseNext = new Label[labelConstants.length];\n+            Object[] caseLabels = new Object[labelConstants.length];\n+            SwitchCase[] switchCases = new SwitchCase[labelConstants.length];\n@@ -481,1 +516,1 @@\n-                    next = cases.getLast().next();\n+                    next = caseNext[idx + 1];\n@@ -483,1 +518,1 @@\n-                    next = cases.getLast().target();\n+                    next = caseTargets[idx + 1];\n@@ -486,2 +521,4 @@\n-                cases.add(new Element(target, next, currentLabel));\n-                switchCases.add(SwitchCase.of(idx, target));\n+                caseTargets[idx] = target;\n+                caseNext[idx] = next;\n+                caseLabels[idx] = currentLabel;\n+                switchCases[idx] = SwitchCase.of(idx, target);\n@@ -489,8 +526,6 @@\n-            cases = cases.reversed();\n-            switchCases = switchCases.reversed();\n-            cb.tableswitch(0, labelConstants.length - 1, dflt, switchCases);\n-            for (int idx = 0; idx < cases.size(); idx++) {\n-                Element element = cases.get(idx);\n-                Label next = element.next();\n-                cb.labelBinding(element.target());\n-                if (element.caseLabel() instanceof Class<?> classLabel) {\n+            cb.tableswitch(0, labelConstants.length - 1, dflt, Arrays.asList(switchCases));\n+            for (int idx = 0; idx < labelConstants.length; idx++) {\n+                Label next = caseNext[idx];\n+                Object caseLabel = caseLabels[idx];\n+                cb.labelBinding(caseTargets[idx]);\n+                if (caseLabel instanceof Class<?> classLabel) {\n@@ -580,1 +615,1 @@\n-                } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n+                } else if (caseLabel instanceof EnumDesc<?> enumLabel) {\n@@ -590,1 +625,1 @@\n-                    cb.invokeinterface(referenceClassDesc(BiPredicate.class),\n+                    cb.invokeinterface(CD_BiPredicate,\n@@ -596,1 +631,1 @@\n-                } else if (element.caseLabel() instanceof String stringLabel) {\n+                } else if (caseLabel instanceof String stringLabel) {\n@@ -604,1 +639,1 @@\n-                } else if (element.caseLabel() instanceof Integer integerLabel) {\n+                } else if (caseLabel instanceof Integer integerLabel) {\n@@ -629,5 +664,5 @@\n-                } else if ((element.caseLabel() instanceof Long ||\n-                        element.caseLabel() instanceof Float ||\n-                        element.caseLabel() instanceof Double ||\n-                        element.caseLabel() instanceof Boolean)) {\n-                    if (element.caseLabel() instanceof Boolean c) {\n+                } else if ((caseLabel instanceof Long ||\n+                        caseLabel instanceof Float ||\n+                        caseLabel instanceof Double ||\n+                        caseLabel instanceof Boolean)) {\n+                    if (caseLabel instanceof Boolean c) {\n@@ -636,1 +671,1 @@\n-                        cb.loadConstant((ConstantDesc) element.caseLabel());\n+                        cb.loadConstant((ConstantDesc) caseLabel);\n@@ -638,1 +673,1 @@\n-                    var caseLabelWrapper = Wrapper.forWrapperType(element.caseLabel().getClass());\n+                    var caseLabelWrapper = Wrapper.forWrapperType(caseLabel.getClass());\n@@ -651,1 +686,1 @@\n-                            element.caseLabel().getClass());\n+                            caseLabel.getClass());\n@@ -657,1 +692,1 @@\n-            cb.loadConstant(cases.size());\n+            cb.loadConstant(labelConstants.length);\n@@ -666,2 +701,3 @@\n-        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n-        List<Class<?>> extraClassLabels = new ArrayList<>();\n+        boolean addExtraInfo = needsExtraInfo(selectorType, labelConstants);\n+        List<EnumDesc<?>> enumDescs = addExtraInfo ? new ArrayList<>() : null;\n+        List<Class<?>> extraClassLabels = addExtraInfo ? new ArrayList<>() : null;\n@@ -673,1 +709,1 @@\n-                                       TYPES_SWITCH_DESCRIPTOR,\n+                                       addExtraInfo ? MTD_TYPE_SWITCH_EXTRA : MTD_TYPE_SWITCH,\n@@ -684,7 +720,5 @@\n-                                                        TYPES_SWITCH_TYPE);\n-            typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(new EnumDesc<?>[0])),\n-                                                       List.copyOf(extraClassLabels));\n-            typeSwitch = MethodHandles.explicitCastArguments(typeSwitch,\n-                                                             MethodType.methodType(int.class,\n-                                                                                   selectorType,\n-                                                                                   int.class));\n+                                                        addExtraInfo ? MT_TYPE_SWITCH_EXTRA : MT_TYPE_SWITCH);\n+            if (addExtraInfo) {\n+                typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(new EnumDesc<?>[0])),\n+                        List.copyOf(extraClassLabels));\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":85,"deletions":51,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -398,1 +398,1 @@\n-     *          socket is already bound.\n+     *          socket is already bound or is closed.\n@@ -425,0 +425,5 @@\n+     * <p> If this socket is already connected, then this method will attempt to\n+     * connect to the given address. If this connect fails then the state of\n+     * this socket is unknown - it may or may not be connected to the address\n+     * that it was previously connected to.\n+     *\n@@ -464,1 +469,1 @@\n-     *         may be thrown if connect fails, for example, if the\n+     *         if the port is 0 or connect fails, for example, if the\n@@ -487,0 +492,5 @@\n+     * <p> If this socket is already connected, then this method will attempt to\n+     * connect to the given address. If this connect fails then the state of\n+     * this socket is unknown - it may or may not be connected to the address\n+     * that it was previously connected to.\n+     *\n@@ -646,1 +656,1 @@\n-     * @throws     IOException  if an I\/O error occurs.\n+     * @throws     IOException  if an I\/O error occurs, or the socket is closed.\n@@ -705,1 +715,1 @@\n-     * @throws     IOException  if an I\/O error occurs.\n+     * @throws     IOException  if an I\/O error occurs, or the socket is closed.\n@@ -773,1 +783,2 @@\n-     * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -787,1 +798,2 @@\n-     * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -823,2 +835,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -844,2 +856,2 @@\n-     * @throws    SocketException if there is an error in\n-     * the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -881,2 +893,2 @@\n-     * @throws    SocketException if there is an error in\n-     * the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -902,1 +914,2 @@\n-     * @throws    SocketException if there is an error in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -962,2 +975,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -986,3 +999,2 @@\n-     * @throws  SocketException\n-     *          if there is an error in the underlying protocol, such as an UDP\n-     *          error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -1006,2 +1018,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -1052,2 +1064,2 @@\n-     * @throws SocketException if there is an error setting the\n-     * traffic class or type-of-service\n+     * @throws SocketException if there is an error setting the traffic class or type-of-service,\n+     *         or the socket is closed.\n@@ -1077,2 +1089,2 @@\n-     * @throws SocketException if there is an error obtaining the\n-     * traffic class or type-of-service value.\n+     * @throws SocketException if there is an error obtaining the traffic class\n+     *         or type-of-service value, or the socket is closed.\n@@ -1095,0 +1107,3 @@\n+     *\n+     * <p> Once closed, several of the methods defined by this class will throw\n+     * an exception if invoked on the closed socket.\n@@ -1302,1 +1317,1 @@\n-     *         multicasting\n+     *         multicasting, or the socket is closed\n@@ -1346,1 +1361,1 @@\n-     *         is not a multicast address.\n+     *         is not a multicast address, or the socket is closed.\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocket.java","additions":42,"deletions":27,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-     *             while setting the default time-to-live value\n+     *             while setting the default time-to-live value, or the socket is closed.\n@@ -253,1 +253,1 @@\n-     *          default time-to-live value\n+     *          default time-to-live value, or the socket is closed.\n@@ -268,1 +268,1 @@\n-     * while getting the default time-to-live value\n+     *            while getting the default time-to-live value, or the socket is closed.\n@@ -288,1 +288,1 @@\n-     * getting the default time-to-live value\n+     *            getting the default time-to-live value, or the socket is closed.\n@@ -314,1 +314,1 @@\n-     *             or the platform does not support multicasting\n+     *             or the platform does not support multicasting, or the socket is closed.\n@@ -342,1 +342,1 @@\n-     *             or when the address is not a multicast address.\n+     *             or when the address is not a multicast address, or the socket is closed.\n@@ -396,1 +396,1 @@\n-     *             the underlying protocol, such as a TCP error.\n+     *             the underlying protocol, such as a TCP error, or the socket is closed.\n@@ -416,1 +416,1 @@\n-     *             underlying protocol, such as a TCP error.\n+     *             underlying protocol, such as a TCP error, or the socket is closed.\n@@ -437,1 +437,1 @@\n-     * the underlying protocol, such as a TCP error.\n+     *            the underlying protocol, such as a TCP error, or the socket is closed.\n@@ -457,1 +457,1 @@\n-     *         the underlying protocol, such as a TCP error.\n+     *         the underlying protocol, such as a TCP error, or the socket is closed.\n@@ -479,1 +479,2 @@\n-     * @throws     SocketException if an error occurs while setting the value\n+     * @throws     SocketException if an error occurs while setting the value, or\n+     *             the socket is closed.\n@@ -496,1 +497,2 @@\n-     * @throws     SocketException if an error occurs while getting the value\n+     * @throws     SocketException if an error occurs while getting the value, or\n+     *             the socket is closed.\n@@ -537,2 +539,1 @@\n-     * @throws     IOException is raised if an error occurs i.e\n-     *             error while setting ttl.\n+     * @throws     IOException  if an I\/O error occurs, or the socket is closed.\n","filename":"src\/java.base\/share\/classes\/java\/net\/MulticastSocket.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,4 +38,26 @@\n- * This class represents a Network Interface made up of a name,\n- * and a list of IP addresses assigned to this interface.\n- * It is used to identify the local interface on which a multicast group\n- * is joined.\n+ * This class represents a Network Interface.\n+ * <p>\n+ * A Network Interface is an abstraction encapsulating\n+ * the characteristics of a Network Interface Controller, or\n+ * Virtual Network adapter, which is a system hardware\/software\n+ * component connecting a computer, or host system, to a computer\n+ * network. A Network Interface can be physical or virtual.\n+ * A Network Interface has a name, zero or more assigned\n+ * {@linkplain InetAddress IP addresses}, zero or more {@linkplain\n+ * InterfaceAddress MAC Addresses}, and may have an index.\n+ * The name is highly platform specific but a name such as \"le0\"\n+ * is typical; it may not be unique. The index is a highly platform\n+ * specific number that identifies the interface. The network\n+ * configuration may change during the lifetime of the JVM.\n+ * For example, the set of IP addresses assigned to a network\n+ * interface can be transient and dynamically allocated, and may\n+ * change at any time.\n+ * <p>\n+ * When obtaining a {@code NetworkInterface} instance, part of its\n+ * configuration (such as its name and the list of assigned IP addresses),\n+ * is reflective of its configuration at creation time.\n+ * Obtaining an updated view of the network configuration may require\n+ * looking up a network interface again in order to obtain a new instance.\n+ * <p>\n+ * Network interface instances are typically used to identify the local\n+ * interface on which a multicast group is joined.\n@@ -43,1 +65,10 @@\n- * Interfaces are normally known by names such as \"le0\".\n+ * @apiNote <a id=\"lookup\"><\/a>Several static methods in this class are\n+ * factory methods, returning a new instance of a {@code NetworkInterface},\n+ * reflecting the configuration at the time of instantiation.\n+ * The network configuration may change at any time, and as such,\n+ * these methods may need to be invoked again in order to obtain\n+ * a more up-to-date view of the network interfaces.\n+ * In particular, there is no guarantee that the same interface will be\n+ * found at the same index, or that the same network addresses will be\n+ * bound to the interface, if the network configuration of the system\n+ * has changed.\n@@ -90,1 +121,1 @@\n-     * Get an Enumeration with all or a subset of the InetAddresses bound to\n+     * Get an Enumeration with all, or a subset, of the InetAddresses bound to\n@@ -100,1 +131,6 @@\n-     * @return an Enumeration object with all or a subset of the InetAddresses\n+     * @implNote\n+     * The returned enumeration contains all, or a subset, of the InetAddresses that were\n+     * bound to the interface at the time the {@linkplain #getNetworkInterfaces()\n+     * interface configuration was read}\n+     *\n+     * @return an Enumeration object with all, or a subset, of the InetAddresses\n@@ -109,1 +145,1 @@\n-     * Get a Stream of all or a subset of the InetAddresses bound to this\n+     * Get a Stream of all, or a subset, of the InetAddresses bound to this\n@@ -119,1 +155,6 @@\n-     * @return a Stream object with all or a subset of the InetAddresses\n+     * @implNote\n+     * The stream contains all, or a subset, of the InetAddresses that were\n+     * bound to the interface at the time the {@linkplain #getNetworkInterfaces()\n+     * interface configuration was read}\n+     *\n+     * @return a Stream object with all, or a subset, of the InetAddresses\n@@ -153,1 +194,1 @@\n-     * Get a List of all or a subset of the {@code InterfaceAddresses}\n+     * Get a List of all, or a subset, of the {@code InterfaceAddresses}\n@@ -161,1 +202,1 @@\n-     * @return a {@code List} object with all or a subset of the\n+     * @return a {@code List} object with all, or a subset, of the\n@@ -252,0 +293,6 @@\n+     * @apiNote\n+     * The returned interface instance may reflect a snapshot of the\n+     * configuration taken at the time the instance is created.\n+     * See the general discussion of {@linkplain NetworkInterface##lookup\n+     * snapshots and configuration} for the semantics of the returned interface.\n+     *\n@@ -274,0 +321,6 @@\n+     * @apiNote\n+     * The returned interface instance may reflect a snapshot of the\n+     * configuration taken at the time the instance is created.\n+     * See the general discussion of {@linkplain NetworkInterface##lookup\n+     * snapshots and configuration} for the semantics of the returned interface.\n+     *\n@@ -297,0 +350,6 @@\n+     * @apiNote\n+     * The returned interface instance may reflect a snapshot of the\n+     * configuration taken at the time the instance is created.\n+     * See the general discussion of {@linkplain NetworkInterface##lookup\n+     * snapshots and configuration} for the semantics of the returned interface.\n+     *\n@@ -337,2 +396,8 @@\n-     * @apiNote this method can be used in combination with\n-     * {@link #getInetAddresses()} to obtain all IP addresses for this node\n+     * @apiNote\n+     * This method can be used in combination with\n+     * {@link #getInetAddresses()} to obtain all IP addresses for this node.\n+     * <p>\n+     * The returned interface instances may reflect a snapshot of the\n+     * configuration taken at the time the instance is created.\n+     * See the general discussion of {@linkplain NetworkInterface##lookup\n+     * snapshots and configuration} for the semantics of the returned interface.\n@@ -362,1 +427,1 @@\n-     * @apiNote this method can be used in combination with\n+     * @apiNote This method can be used in combination with\n@@ -369,0 +434,5 @@\n+     * <p>\n+     * The returned interface instances may reflect a snapshot of the\n+     * configuration taken at the time the instance is created.\n+     * See the general discussion of {@linkplain NetworkInterface##lookup\n+     * snapshots and configuration} for the semantics of the returned interface.\n","filename":"src\/java.base\/share\/classes\/java\/net\/NetworkInterface.java","additions":85,"deletions":15,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.access.foreign.MappedMemoryUtilsProxy;\n@@ -807,0 +808,1 @@\n+\n@@ -889,17 +891,2 @@\n-                public void force(FileDescriptor fd, long address, boolean isSync, long offset, long size) {\n-                    MappedMemoryUtils.force(fd, address, isSync, offset, size);\n-                }\n-\n-                @Override\n-                public void load(long address, boolean isSync, long size) {\n-                    MappedMemoryUtils.load(address, isSync, size);\n-                }\n-\n-                @Override\n-                public void unload(long address, boolean isSync, long size) {\n-                    MappedMemoryUtils.unload(address, isSync, size);\n-                }\n-\n-                @Override\n-                public boolean isLoaded(long address, boolean isSync, long size) {\n-                    return MappedMemoryUtils.isLoaded(address, isSync, size);\n+                public MappedMemoryUtilsProxy mappedMemoryUtils() {\n+                    return MappedMemoryUtils.PROXY;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.access.foreign.MappedMemoryUtilsProxy;\n@@ -197,1 +198,1 @@\n-        return SCOPED_MEMORY_ACCESS.isLoaded(session(), address, isSync, capacity());\n+        return SCOPED_MEMORY_ACCESS.isLoaded(session(), MappedMemoryUtils.PROXY, address, isSync, capacity());\n@@ -215,1 +216,1 @@\n-            SCOPED_MEMORY_ACCESS.load(session(), address, isSync, capacity());\n+            SCOPED_MEMORY_ACCESS.load(session(), MappedMemoryUtils.PROXY, address, isSync, capacity());\n@@ -315,1 +316,1 @@\n-            SCOPED_MEMORY_ACCESS.force(session(), fd, address, isSync, index, length);\n+            SCOPED_MEMORY_ACCESS.force(session(), MappedMemoryUtils.PROXY, fd, address, isSync, index, length);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/MappedByteBuffer.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+\n+import jdk.internal.access.foreign.MappedMemoryUtilsProxy;\n@@ -119,0 +121,11 @@\n+    \/* Register the natives via the static initializer.\n+     *\n+     * This is required, as these native methods are \"scoped methods\" (see ScopedMemoryAccess).\n+     * As such, it's better not to end up doing a full JNI lookup while in a scoped method context,\n+     * as that will make the stack trace too deep.\n+     *\/\n+    private static native void registerNatives();\n+    static {\n+        registerNatives();\n+    }\n+\n@@ -167,0 +180,22 @@\n+\n+    static final MappedMemoryUtilsProxy PROXY = new MappedMemoryUtilsProxy() {\n+        @Override\n+        public boolean isLoaded(long address, boolean isSync, long size) {\n+            return MappedMemoryUtils.isLoaded(address, isSync, size);\n+        }\n+\n+        @Override\n+        public void load(long address, boolean isSync, long size) {\n+            MappedMemoryUtils.load(address, isSync, size);\n+        }\n+\n+        @Override\n+        public void unload(long address, boolean isSync, long size) {\n+            MappedMemoryUtils.unload(address, isSync, size);\n+        }\n+\n+        @Override\n+        public void force(FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+            MappedMemoryUtils.force(fd, address, isSync, index, length);\n+        }\n+    };\n","filename":"src\/java.base\/share\/classes\/java\/nio\/MappedMemoryUtils.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -228,2 +228,2 @@\n-            return Boolean.parseBoolean(provider.getProperty(\n-                    \"SecureRandom.\" + algorithm + \" ThreadSafe\", \"false\"));\n+            Service service = provider.getService(\"SecureRandom\", algorithm);\n+            return Boolean.parseBoolean(service.getAttribute(\"ThreadSafe\"));\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -655,1 +655,0 @@\n-                val = getNumberValue(number, divisor);\n@@ -657,0 +656,3 @@\n+            roundedNumber = roundedNumber \/ divisor;\n+            decimalFormat.setDigitList(roundedNumber, isNegative, getMaximumFractionDigits());\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -663,2 +665,0 @@\n-                    roundedNumber = roundedNumber \/ divisor;\n-                    decimalFormat.setDigitList(roundedNumber, isNegative, getMaximumFractionDigits());\n@@ -737,1 +737,0 @@\n-                val = getNumberValue(number, divisor);\n@@ -739,0 +738,12 @@\n+            var noFraction = number % divisor == 0;\n+            if (noFraction) {\n+                number = number \/ divisor;\n+                decimalFormat.setDigitList(number, isNegative, 0);\n+            } else {\n+                \/\/ To avoid truncation of fractional part store\n+                \/\/ the value in double and follow double path instead of\n+                \/\/ long path\n+                double dNumber = (double) number \/ divisor;\n+                decimalFormat.setDigitList(dNumber, isNegative, getMaximumFractionDigits());\n+            }\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -744,18 +755,4 @@\n-                    if ((number % divisor == 0)) {\n-                        number = number \/ divisor;\n-                        decimalFormat.setDigitList(number, isNegative, 0);\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, true, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    } else {\n-                        \/\/ To avoid truncation of fractional part store\n-                        \/\/ the value in double and follow double path instead of\n-                        \/\/ long path\n-                        double dNumber = (double) number \/ divisor;\n-                        decimalFormat.setDigitList(dNumber, isNegative, getMaximumFractionDigits());\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, false, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    }\n+                    decimalFormat.subformatNumber(result, delegate,\n+                            isNegative, noFraction, getMaximumIntegerDigits(),\n+                            getMinimumIntegerDigits(), getMaximumFractionDigits(),\n+                            getMinimumFractionDigits());\n@@ -836,1 +833,0 @@\n-                val = getNumberValue(number.doubleValue(), divisor.doubleValue());\n@@ -838,0 +834,3 @@\n+            number = number.divide(new BigDecimal(divisor.toString()), getRoundingMode());\n+            decimalFormat.setDigitList(number, isNegative, getMaximumFractionDigits());\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -843,2 +842,0 @@\n-                    number = number.divide(new BigDecimal(divisor.toString()), getRoundingMode());\n-                    decimalFormat.setDigitList(number, isNegative, getMaximumFractionDigits());\n@@ -907,1 +904,0 @@\n-                val = getNumberValue(number.doubleValue(), divisor.doubleValue());\n@@ -909,0 +905,14 @@\n+            var noFraction = number.mod(new BigInteger(divisor.toString()))\n+                    .compareTo(BigInteger.ZERO) == 0;\n+            if (noFraction) {\n+                number = number.divide(new BigInteger(divisor.toString()));\n+                decimalFormat.setDigitList(number, isNegative, 0);\n+            } else {\n+                \/\/ To avoid truncation of fractional part store the value in\n+                \/\/ BigDecimal and follow BigDecimal path instead of\n+                \/\/ BigInteger path\n+                BigDecimal nDecimal = new BigDecimal(number)\n+                        .divide(new BigDecimal(divisor.toString()), getRoundingMode());\n+                decimalFormat.setDigitList(nDecimal, isNegative, getMaximumFractionDigits());\n+            }\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -914,21 +924,4 @@\n-                    if (number.mod(new BigInteger(divisor.toString()))\n-                            .compareTo(BigInteger.ZERO) == 0) {\n-                        number = number.divide(new BigInteger(divisor.toString()));\n-\n-                        decimalFormat.setDigitList(number, isNegative, 0);\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, true, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    } else {\n-                        \/\/ To avoid truncation of fractional part store the value in\n-                        \/\/ BigDecimal and follow BigDecimal path instead of\n-                        \/\/ BigInteger path\n-                        BigDecimal nDecimal = new BigDecimal(number)\n-                                .divide(new BigDecimal(divisor.toString()), getRoundingMode());\n-                        decimalFormat.setDigitList(nDecimal, isNegative, getMaximumFractionDigits());\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, false, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    }\n+                    decimalFormat.subformatNumber(result, delegate,\n+                        isNegative, noFraction, getMaximumIntegerDigits(),\n+                        getMinimumIntegerDigits(), getMaximumFractionDigits(),\n+                        getMinimumFractionDigits());\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":40,"deletions":47,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -1802,0 +1802,8 @@\n+    \/**\n+     * {@return the {@code DigitList} used by this {@code DecimalFormat} instance}\n+     * Declared as package-private, intended for {@code CompactNumberFormat}.\n+     *\/\n+    DigitList getDigitList() {\n+        return digitList;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,3 +223,3 @@\n-    private final byte BITARRAYMASK = (byte)0x1;\n-    private final int  BYTEPOWER = 3;\n-    private final int  BYTEMASK = (1 << BYTEPOWER) - 1;\n+    private static final byte BITARRAYMASK = (byte)0x1;\n+    private static final int BYTEPOWER = 3;\n+    private static final int BYTEMASK = (1 << BYTEPOWER) - 1;\n","filename":"src\/java.base\/share\/classes\/java\/text\/MergeCollation.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -695,1 +695,4 @@\n-     * does not necessarily equal the previously applied pattern.\n+     * does not necessarily equal the previously applied pattern. The order of\n+     * {@code FormatStyle} matching is not guaranteed. That is, a {@code\n+     * FormatStyle} produced may not be equivalent to the corresponding style passed,\n+     * in the instance that multiple styles are equivalent.\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1969,0 +1969,8 @@\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Prints the toString result to the given buf, avoiding extra string allocations.\n+     *\/\n+    void formatTo(StringBuilder buf) {\n@@ -1972,1 +1980,0 @@\n-        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDateTime.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1926,1 +1926,4 @@\n-        return dateTime.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var buf = new StringBuilder(29 + offsetStr.length());\n+        dateTime.formatTo(buf);\n+        return buf.append(offsetStr).toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetDateTime.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1401,1 +1401,4 @@\n-        return time.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var buf = new StringBuilder(18 + offsetStr.length());\n+        time.formatTo(buf);\n+        return buf.append(offsetStr).toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetTime.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2217,1 +2217,3 @@\n-        String str = dateTime.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var zoneStr = (String) null;\n+        int length = 29 + offsetStr.length();\n@@ -2219,1 +2221,2 @@\n-            str += '[' + zone.toString() + ']';\n+            zoneStr = zone.toString();\n+            length += zoneStr.length() + 2;\n@@ -2221,1 +2224,7 @@\n-        return str;\n+        var buf = new StringBuilder(length);\n+        dateTime.formatTo(buf);\n+        buf.append(offsetStr);\n+        if (zoneStr != null) {\n+            buf.append('[').append(zoneStr).append(']');\n+        }\n+        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1585,0 +1585,7 @@\n+\n+        @Override\n+        public void sort(Comparator<? super E> c) {\n+            checkForComodification();\n+            root.sortRange(c, offset, offset + size);\n+            updateSizeAndModCount(0);\n+        }\n@@ -1802,1 +1809,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -1804,0 +1810,5 @@\n+        sortRange(c, 0, size);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private void sortRange(Comparator<? super E> c, int fromIndex, int toIndex) {\n@@ -1805,1 +1816,1 @@\n-        Arrays.sort((E[]) elementData, 0, size, c);\n+        Arrays.sort((E[]) elementData, fromIndex, toIndex, c);\n","filename":"src\/java.base\/share\/classes\/java\/util\/ArrayList.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3024,9 +3024,1 @@\n-    private static class FixedString implements FormatString {\n-        private final String s;\n-        private final int start;\n-        private final int end;\n-        FixedString(String s, int start, int end) {\n-            this.s = s;\n-            this.start = start;\n-            this.end = end;\n-        }\n+    private record FixedString(String s, int start, int end) implements FormatString {\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -991,1 +991,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(baseloc, LOCALE_CREATOR);\n+            return LocaleCache.cache(baseloc);\n@@ -994,1 +994,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n+            return LocaleCache.cache(key);\n@@ -998,2 +998,9 @@\n-    private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n-            = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+    private static final class LocaleCache implements Function<Object, Locale> {\n+        private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n+                = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+\n+        private static final Function<Object, Locale> LOCALE_CREATOR = new LocaleCache();\n+\n+        public static Locale cache(Object key) {\n+            return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n+        }\n@@ -1001,1 +1008,0 @@\n-    private static final Function<Object, Locale> LOCALE_CREATOR = new Function<>() {\n@@ -1010,1 +1016,1 @@\n-    };\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2808,1 +2808,1 @@\n-     * before the given timeout.\n+     * before the given timeout elapsed.\n@@ -2828,1 +2828,1 @@\n-     * otherwise completed before the given timeout.\n+     * otherwise completed before the given timeout elapsed.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,7 +142,1 @@\n-     * contention. We approach this by defining the Nodes that we need\n-     * anyway as ThreadLocals, and include in them per-thread index\n-     * and related bookkeeping state. (We can safely reuse per-thread\n-     * nodes rather than creating them fresh each time because slots\n-     * alternate between pointing to a node vs null, so cannot\n-     * encounter ABA problems. However, we do need some care in\n-     * resetting them between uses.)\n+     * contention.\n@@ -150,13 +144,22 @@\n-     * Implementing an effective arena requires allocating a bunch of\n-     * space, so we only do so upon detecting contention (except on\n-     * uniprocessors, where they wouldn't help, so aren't used).\n-     * Otherwise, exchanges use the single-slot slotExchange method.\n-     * On contention, not only must the slots be in different\n-     * locations, but the locations must not encounter memory\n-     * contention due to being on the same cache line (or more\n-     * generally, the same coherence unit).  Because, as of this\n-     * writing, there is no way to determine cacheline size, we define\n-     * a value that is enough for common platforms.  Additionally,\n-     * extra care elsewhere is taken to avoid other false\/unintended\n-     * sharing and to enhance locality, including adding padding (via\n-     * @Contended) to Nodes, embedding \"bound\" as an Exchanger field.\n+     * We approach this by defining the Nodes holding references to\n+     * transfered items as ThreadLocals, and include in them\n+     * per-thread index and related bookkeeping state. We can safely\n+     * reuse per-thread nodes rather than creating them fresh each\n+     * time because slots alternate between pointing to a node vs\n+     * null, so cannot encounter ABA problems. However, we must ensure\n+     * that object transfer fields are reset between uses. Given this,\n+     * Participant nodes can be defined as static ThreadLocals. As\n+     * seen for example in class Striped64, using indices established\n+     * in one instance across others usually improves overall\n+     * performance.  Nodes also include a participant-local random\n+     * number generator.\n+     *\n+     * Spreading out contention requires that the memory locations\n+     * used by the arena slots don't share a cache line -- otherwise,\n+     * the arena would have almost no benefit. We arrange this by\n+     * adding another level of indirection: The arena elements point\n+     * to \"Slots\", each of which is padded using @Contended. We only\n+     * create a single Slot on intialization, adding more when\n+     * needed. The per-thread Participant Nodes may also be subject to\n+     * false-sharing contention, but tend to be more scattered in\n+     * memory, so are unpadded, with some occasional performance impact.\n@@ -166,13 +169,6 @@\n-     * while trying to exchange. By nature of the above algorithm, the\n-     * only kinds of collision that reliably indicate contention are\n-     * when two attempted releases collide -- one of two attempted\n-     * offers can legitimately fail to CAS without indicating\n-     * contention by more than one other thread. (Note: it is possible\n-     * but not worthwhile to more precisely detect contention by\n-     * reading slot values after CAS failures.)  When a thread has\n-     * collided at each slot within the current arena bound, it tries\n-     * to expand the arena size by one. We track collisions within\n-     * bounds by using a version (sequence) number on the \"bound\"\n-     * field, and conservatively reset collision counts when a\n-     * participant notices that bound has been updated (in either\n-     * direction).\n+     * while trying to exchange. And shrink it via \"spinouts\" in which\n+     * threads give up waiting at a slot.  By nature of the above\n+     * algorithm, the only kinds of collision that reliably indicate\n+     * contention are when two attempted releases collide -- one of\n+     * two attempted offers can legitimately fail to CAS without\n+     * indicating contention by more than one other thread.\n@@ -180,25 +176,15 @@\n-     * The effective arena size is reduced (when there is more than\n-     * one slot) by giving up on waiting after a while and trying to\n-     * decrement the arena size on expiration. The value of \"a while\"\n-     * is an empirical matter.  We implement by piggybacking on the\n-     * use of spin->yield->block that is essential for reasonable\n-     * waiting performance anyway -- in a busy exchanger, offers are\n-     * usually almost immediately released, in which case context\n-     * switching on multiprocessors is extremely slow\/wasteful.  Arena\n-     * waits just omit the blocking part, and instead cancel. The spin\n-     * count is empirically chosen to be a value that avoids blocking\n-     * 99% of the time under maximum sustained exchange rates on a\n-     * range of test machines. Spins and yields entail some limited\n-     * randomness (using a cheap xorshift) to avoid regular patterns\n-     * that can induce unproductive grow\/shrink cycles. (Using a\n-     * pseudorandom also helps regularize spin cycle duration by\n-     * making branches unpredictable.)  Also, during an offer, a\n-     * waiter can \"know\" that it will be released when its slot has\n-     * changed, but cannot yet proceed until match is set.  In the\n-     * mean time it cannot cancel the offer, so instead spins\/yields.\n-     * Note: It is possible to avoid this secondary check by changing\n-     * the linearization point to be a CAS of the match field (as done\n-     * in one case in the Scott & Scherer DISC paper), which also\n-     * increases asynchrony a bit, at the expense of poorer collision\n-     * detection and inability to always reuse per-thread nodes. So\n-     * the current scheme is typically a better tradeoff.\n+     * Arena size (the value of field \"bound\") is controlled by random\n+     * sampling. On each miss (collision or spinout), a thread chooses\n+     * a new random index within the arena.  Upon the third collision\n+     * with the same current bound, it tries to grow the arena. And\n+     * upon the second spinout, it tries to shrink. The asymmetry in\n+     * part reflects relative costs, and reduces flailing. Because\n+     * they cannot be changed without also changing the sampling\n+     * strategy, these rules are directly incorporated into uses of\n+     * the xchg \"misses\" variable.  The bound field is tagged with\n+     * sequence numbers to reduce stale decisions. Uniform random\n+     * indices are generated using XorShift with enough bits so that\n+     * bias (See Knuth TAoCP vol 2) is negligible for moduli used here\n+     * (at most 256) without requiring rejection tests. Using\n+     * nonuniform randoms with greater weight to higher indices is\n+     * also possible but does not seem worthwhile in practice.\n@@ -206,11 +192,15 @@\n-     * On collisions, indices traverse the arena cyclically in reverse\n-     * order, restarting at the maximum index (which will tend to be\n-     * sparsest) when bounds change. (On expirations, indices instead\n-     * are halved until reaching 0.) It is possible (and has been\n-     * tried) to use randomized, prime-value-stepped, or double-hash\n-     * style traversal instead of simple cyclic traversal to reduce\n-     * bunching.  But empirically, whatever benefits these may have\n-     * don't overcome their added overhead: We are managing operations\n-     * that occur very quickly unless there is sustained contention,\n-     * so simpler\/faster control policies work better than more\n-     * accurate but slower ones.\n+     * These mechanics rely on a reasonable choice of constant SPINS.\n+     * The time cost of SPINS * Thread.onSpinWait() should be at least\n+     * the expected cost of a park\/unpark context switch, and larger\n+     * than that of two failed CASes, but still small enough to avoid\n+     * excessive delays during arena shrinkage.  We also deal with the\n+     * possibility that when an offering thread waits for a release,\n+     * spin-waiting would be useless because the releasing thread is\n+     * descheduled. On multiprocessors, we cannot know this in\n+     * general. But when Virtual Threads are used, method\n+     * ForkJoinWorkerThread.hasKnownQueuedWork serves as a guide to\n+     * whether to spin or immediately block, allowing a context switch\n+     * that may enable a releaser.  Note also that when many threads\n+     * are being run on few cores, enountering enough collisions to\n+     * trigger arena growth is rare, and soon followed by shrinkage,\n+     * so this doesn't require special handling.\n@@ -218,5 +208,5 @@\n-     * Because we use expiration for arena size control, we cannot\n-     * throw TimeoutExceptions in the timed version of the public\n-     * exchange method until the arena size has shrunken to zero (or\n-     * the arena isn't enabled). This may delay response to timeout\n-     * but is still within spec.\n+     * The basic exchange mechanics rely on checks that Node item\n+     * fields are not null, which doesn't work when offered items are\n+     * null. We trap this case by translating nulls to the\n+     * (un-Exchangeable) value of the static Participant\n+     * reference.\n@@ -224,10 +214,8 @@\n-     * Essentially all of the implementation is in methods\n-     * slotExchange and arenaExchange. These have similar overall\n-     * structure, but differ in too many details to combine. The\n-     * slotExchange method uses the single Exchanger field \"slot\"\n-     * rather than arena array elements. However, it still needs\n-     * minimal collision detection to trigger arena construction.\n-     * (The messiest part is making sure interrupt status and\n-     * InterruptedExceptions come out right during transitions when\n-     * both methods may be called. This is done by using null return\n-     * as a sentinel to recheck interrupt status.)\n+     * Essentially all of the implementation is in method xchg.  As is\n+     * too common in this sort of code, most of the logic relies on\n+     * reads of fields that are maintained as local variables so can't\n+     * be nicely factored. It is structured as a main loop with a\n+     * leading volatile read (of field bound), that causes others to\n+     * be freshly read even though declared in plain mode.  We don't\n+     * use compareAndExchange that would otherwise save some re-reads\n+     * because of the need to recheck indices and bounds on failures.\n@@ -235,18 +223,15 @@\n-     * As is too common in this sort of code, methods are monolithic\n-     * because most of the logic relies on reads of fields that are\n-     * maintained as local variables so can't be nicely factored --\n-     * mainly, here, bulky spin->yield->block\/cancel code.  Note that\n-     * field Node.item is not declared as volatile even though it is\n-     * read by releasing threads, because they only do so after CAS\n-     * operations that must precede access, and all uses by the owning\n-     * thread are otherwise acceptably ordered by other operations.\n-     * (Because the actual points of atomicity are slot CASes, it\n-     * would also be legal for the write to Node.match in a release to\n-     * be weaker than a full volatile write. However, this is not done\n-     * because it could allow further postponement of the write,\n-     * delaying progress.)\n-     *\/\n-\n-    \/**\n-     * The index distance (as a shift value) between any two used slots\n-     * in the arena, spacing them out to avoid false sharing.\n+     * Support for optional timeouts in a single method adds further\n+     * complexity. Note that for the sake of arena bounds control,\n+     * time bounds must be ignored during spinouts, which may delay\n+     * TimeoutExceptions (but no more so than would excessive context\n+     * switching that could occur otherwise).  Responses to\n+     * interruption are handled similarly, postponing commitment to\n+     * throw InterruptedException until successfully cancelled.\n+     *\n+     * Design differences from previous releases include:\n+     * * Accommodation of VirtualThreads.\n+     * * Use of Slots vs spaced indices for the arena and static\n+     *   ThreadLocals, avoiding separate arena vs non-arena modes.\n+     * * Use of random sampling for grow\/shrink decisions, with typically\n+     *   faster and more stable adaptation (as was mentioned as a\n+     *   possible improvement in previous version).\n@@ -254,1 +239,0 @@\n-    private static final int ASHIFT = 5;\n@@ -258,3 +242,3 @@\n-     * arena size is MMASK + 1. Must be a power of two minus one, less\n-     * than (1<<(31-ASHIFT)). The cap of 255 (0xff) more than suffices\n-     * for the expected scaling limits of the main algorithms.\n+     * arena size is MMASK + 1. Must be a power of two minus one. The\n+     * cap of 255 (0xff) more than suffices for the expected scaling\n+     * limits of the main algorithms.\n@@ -270,3 +254,0 @@\n-    \/** The number of CPUs, for sizing and spin control *\/\n-    private static final int NCPU = Runtime.getRuntime().availableProcessors();\n-\n@@ -274,10 +255,2 @@\n-     * The maximum slot index of the arena: The number of slots that\n-     * can in principle hold all threads without contention, or at\n-     * most the maximum indexable value.\n-     *\/\n-    static final int FULL = (NCPU >= (MMASK << 1)) ? MMASK : NCPU >>> 1;\n-\n-    \/**\n-     * The bound for spins while waiting for a match. The actual\n-     * number of iterations will on average be about twice this value\n-     * due to randomization. Note: Spinning is disabled when NCPU==1.\n+     * The bound for spins while waiting for a match before either\n+     * blocking or possibly shrinking arena.\n@@ -288,10 +261,1 @@\n-     * Value representing null arguments\/returns from public\n-     * methods. Needed because the API originally didn't disallow null\n-     * arguments, which it should have.\n-     *\/\n-    private static final Object NULL_ITEM = new Object();\n-\n-    \/**\n-     * Sentinel value returned by internal exchange methods upon\n-     * timeout, to avoid need for separate timed versions of these\n-     * methods.\n+     * Padded arena cells to avoid false-sharing memory contention\n@@ -299,1 +263,4 @@\n-    private static final Object TIMED_OUT = new Object();\n+    @jdk.internal.vm.annotation.Contended\n+    static final class Slot {\n+        Node entry;\n+    }\n@@ -303,1 +270,1 @@\n-     * bookkeeping. Padded via @Contended to reduce memory contention.\n+     * bookkeeping.\n@@ -305,1 +272,2 @@\n-    @jdk.internal.vm.annotation.Contended static final class Node {\n+    static final class Node {\n+        long seed;              \/\/ Random seed\n@@ -307,3 +275,0 @@\n-        int bound;              \/\/ Last recorded value of Exchanger.bound\n-        int collides;           \/\/ Number of CAS failures at current bound\n-        int hash;               \/\/ Pseudo-random for spins\n@@ -313,0 +278,4 @@\n+        Node() {\n+            index = -1;         \/\/ initialize on first use\n+            seed = Thread.currentThread().threadId();\n+        }\n@@ -321,1 +290,4 @@\n-     * Per-thread state.\n+     * The participant thread-locals. Because it is impossible to\n+     * exchange, we also use this reference for dealing with null user\n+     * arguments that are translated in and out of this value\n+     * surrounding use.\n@@ -323,1 +295,1 @@\n-    private final Participant participant;\n+    private static final Participant participant = new Participant();\n@@ -326,2 +298,2 @@\n-     * Elimination array; null until enabled (within slotExchange).\n-     * Element accesses use emulation of volatile gets and CAS.\n+     * Elimination array; element accesses use emulation of volatile\n+     * gets and CAS.\n@@ -329,1 +301,1 @@\n-    private volatile Node[] arena;\n+    private final Slot[] arena;\n@@ -332,1 +304,2 @@\n-     * Slot used until contention detected.\n+     * Number of cores, for sizing and spin control. Computed only\n+     * upon construction.\n@@ -334,1 +307,1 @@\n-    private volatile Node slot;\n+    private final int ncpu;\n@@ -337,4 +310,1 @@\n-     * The index of the largest valid arena position, OR'ed with SEQ\n-     * number in high bits, incremented on each update.  The initial\n-     * update from 0 to SEQ is used to ensure that the arena array is\n-     * constructed only once.\n+     * The index of the largest valid arena position.\n@@ -345,1 +315,1 @@\n-     * Exchange function when arenas enabled. See above for explanation.\n+     * Exchange function. See above for explanation.\n@@ -347,5 +317,5 @@\n-     * @param item the (non-null) item to exchange\n-     * @param timed true if the wait is timed\n-     * @param ns if timed, the maximum wait time, else 0L\n-     * @return the other thread's item; or null if interrupted; or\n-     * TIMED_OUT if timed and timed out\n+     * @param x the item to exchange\n+     * @param deadline if zero, untimed, else timeout deadline\n+     * @return the other thread's item\n+     * @throws InterruptedException if interrupted while waiting\n+     * @throws TimeoutException if deadline nonzero and timed out\n@@ -353,2 +323,3 @@\n-    private final Object arenaExchange(Object item, boolean timed, long ns) {\n-        Node[] a = arena;\n+    private final V xchg(V x, long deadline)\n+        throws InterruptedException, TimeoutException {\n+        Slot[] a = arena;\n@@ -356,14 +327,39 @@\n-        Node p = participant.get();\n-        for (int i = p.index;;) {                      \/\/ access slot at i\n-            int b, m, c;\n-            int j = (i << ASHIFT) + ((1 << ASHIFT) - 1);\n-            if (j < 0 || j >= alen)\n-                j = alen - 1;\n-            Node q = (Node)AA.getAcquire(a, j);\n-            if (q != null && AA.compareAndSet(a, j, q, null)) {\n-                Object v = q.item;                     \/\/ release\n-                q.match = item;\n-                Thread w = q.parked;\n-                if (w != null)\n-                    LockSupport.unpark(w);\n-                return v;\n+        Participant ps = participant;\n+        Object item = (x == null) ? ps : x;      \/\/ translate nulls\n+        Node p = ps.get();\n+        int i = p.index;                         \/\/ if < 0, move\n+        int misses = 0;                          \/\/ ++ on collide, -- on spinout\n+        Object offered = null;                   \/\/ for cleanup\n+        Object v = null;\n+        outer: for (;;) {\n+            int b, m; Slot s; Node q;\n+            if ((m = (b = bound) & MMASK) == 0)  \/\/ volatile read\n+                i = 0;\n+            if (i < 0 || i > m || i >= alen || (s = a[i]) == null) {\n+                long r = p.seed;                 \/\/ randomly move\n+                r ^= r << 13; r ^= r >>> 7; r ^= r << 17; \/\/ xorShift\n+                i = p.index = (int)((p.seed = r) % (m + 1));\n+            }\n+            else if ((q = s.entry) != null) {    \/\/ try release\n+                if (ENTRY.compareAndSet(s, q, null)) {\n+                    Thread w;\n+                    v = q.item;\n+                    q.match = item;\n+                    if (i == 0 && (w = q.parked) != null)\n+                        LockSupport.unpark(w);\n+                    break;\n+                }\n+                else {                           \/\/ collision\n+                    int nb;\n+                    i = -1;                      \/\/ move index\n+                    if (b != bound)              \/\/ stale\n+                        misses = 0;\n+                    else if (misses <= 2)        \/\/ continue sampling\n+                        ++misses;\n+                    else if ((nb = (b + 1) & MMASK) < alen) {\n+                        misses = 0;              \/\/ try to grow\n+                        if (BOUND.compareAndSet(this, b, b + 1 + SEQ) &&\n+                            a[i = p.index = nb] == null)\n+                            AA.compareAndSet(a, nb, null, new Slot());\n+                    }\n+                }\n@@ -371,12 +367,15 @@\n-            else if (i <= (m = (b = bound) & MMASK) && q == null) {\n-                p.item = item;                         \/\/ offer\n-                if (AA.compareAndSet(a, j, null, p)) {\n-                    long end = (timed && m == 0) ? System.nanoTime() + ns : 0L;\n-                    Thread t = Thread.currentThread(); \/\/ wait\n-                    for (int h = p.hash, spins = SPINS;;) {\n-                        Object v = p.match;\n-                        if (v != null) {\n-                            MATCH.setRelease(p, null);\n-                            p.item = null;             \/\/ clear for next use\n-                            p.hash = h;\n-                            return v;\n+            else {                               \/\/ try offer\n+                if (offered == null)\n+                    offered = p.item = item;\n+                if (ENTRY.compareAndSet(s, null, p)) {\n+                    boolean tryCancel;           \/\/ true if interrupted\n+                    Thread t = Thread.currentThread();\n+                    if (!(tryCancel = t.isInterrupted()) && ncpu > 1 &&\n+                        (i != 0 ||               \/\/ check for busy VTs\n+                         (!ForkJoinWorkerThread.hasKnownQueuedWork()))) {\n+                        for (int j = SPINS; j > 0; --j) {\n+                            if ((v = p.match) != null) {\n+                                MATCH.set(p, null);\n+                                break outer;     \/\/ spin wait\n+                            }\n+                            Thread.onSpinWait();\n@@ -384,7 +383,5 @@\n-                        else if (spins > 0) {\n-                            h ^= h << 1; h ^= h >>> 3; h ^= h << 10; \/\/ xorshift\n-                            if (h == 0)                \/\/ initialize hash\n-                                h = SPINS | (int)t.threadId();\n-                            else if (h < 0 &&          \/\/ approx 50% true\n-                                     (--spins & ((SPINS >>> 1) - 1)) == 0)\n-                                Thread.yield();        \/\/ two yields per wait\n+                    }\n+                    for (long ns = 1L;;) {       \/\/ block or cancel offer\n+                        if ((v = p.match) != null) {\n+                            MATCH.set(p, null);\n+                            break outer;\n@@ -392,8 +389,6 @@\n-                        else if (AA.getAcquire(a, j) != p)\n-                            spins = SPINS;       \/\/ releaser hasn't set match yet\n-                        else if (!t.isInterrupted() && m == 0 &&\n-                                 (!timed ||\n-                                  (ns = end - System.nanoTime()) > 0L)) {\n-                            p.parked = t;              \/\/ minimize window\n-                            if (AA.getAcquire(a, j) == p) {\n-                                if (ns == 0L)\n+                        if (i == 0 && !tryCancel &&\n+                            (deadline == 0L ||\n+                             ((ns = deadline - System.nanoTime()) > 0L))) {\n+                            p.parked = t;        \/\/ emable unpark and recheck\n+                            if (p.match == null) {\n+                                if (deadline == 0L)\n@@ -403,0 +398,1 @@\n+                                tryCancel = t.isInterrupted();\n@@ -406,7 +402,2 @@\n-                        else if (AA.getAcquire(a, j) == p &&\n-                                 AA.compareAndSet(a, j, p, null)) {\n-                            if (m != 0)                \/\/ try to shrink\n-                                BOUND.compareAndSet(this, b, b + SEQ - 1);\n-                            p.item = null;\n-                            p.hash = h;\n-                            i = p.index >>>= 1;        \/\/ descend\n+                        else if (ENTRY.compareAndSet(s, p, null)) { \/\/ cancel\n+                            offered = p.item = null;\n@@ -414,4 +405,13 @@\n-                                return null;\n-                            if (timed && m == 0 && ns <= 0L)\n-                                return TIMED_OUT;\n-                            break;                     \/\/ expired; restart\n+                                throw new InterruptedException();\n+                            if (deadline != 0L && ns <= 0L)\n+                                throw new TimeoutException();\n+                            i = -1;              \/\/ move and restart\n+                            if (bound != b)\n+                                misses = 0;      \/\/ stale\n+                            else if (misses >= 0)\n+                                --misses;        \/\/ continue sampling\n+                            else if ((b & MMASK) != 0) {\n+                                misses = 0;      \/\/ try to shrink\n+                                BOUND.compareAndSet(this, b, b - 1 + SEQ);\n+                            }\n+                            continue outer;\n@@ -421,91 +421,0 @@\n-                else\n-                    p.item = null;                     \/\/ clear offer\n-            }\n-            else {\n-                if (p.bound != b) {                    \/\/ stale; reset\n-                    p.bound = b;\n-                    p.collides = 0;\n-                    i = (i != m || m == 0) ? m : m - 1;\n-                }\n-                else if ((c = p.collides) < m || m == FULL ||\n-                         !BOUND.compareAndSet(this, b, b + SEQ + 1)) {\n-                    p.collides = c + 1;\n-                    i = (i == 0) ? m : i - 1;          \/\/ cyclically traverse\n-                }\n-                else\n-                    i = m + 1;                         \/\/ grow\n-                p.index = i;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Exchange function used until arenas enabled. See above for explanation.\n-     *\n-     * @param item the item to exchange\n-     * @param timed true if the wait is timed\n-     * @param ns if timed, the maximum wait time, else 0L\n-     * @return the other thread's item; or null if either the arena\n-     * was enabled or the thread was interrupted before completion; or\n-     * TIMED_OUT if timed and timed out\n-     *\/\n-    private final Object slotExchange(Object item, boolean timed, long ns) {\n-        Node p = participant.get();\n-        Thread t = Thread.currentThread();\n-        if (t.isInterrupted()) \/\/ preserve interrupt status so caller can recheck\n-            return null;\n-\n-        for (Node q;;) {\n-            if ((q = slot) != null) {\n-                if (SLOT.compareAndSet(this, q, null)) {\n-                    Object v = q.item;\n-                    q.match = item;\n-                    Thread w = q.parked;\n-                    if (w != null)\n-                        LockSupport.unpark(w);\n-                    return v;\n-                }\n-                \/\/ create arena on contention, but continue until slot null\n-                if (NCPU > 1 && bound == 0 &&\n-                    BOUND.compareAndSet(this, 0, SEQ))\n-                    arena = new Node[(FULL + 2) << ASHIFT];\n-            }\n-            else if (arena != null)\n-                return null; \/\/ caller must reroute to arenaExchange\n-            else {\n-                p.item = item;\n-                if (SLOT.compareAndSet(this, null, p))\n-                    break;\n-                p.item = null;\n-            }\n-        }\n-\n-        \/\/ await release\n-        int h = p.hash;\n-        long end = timed ? System.nanoTime() + ns : 0L;\n-        int spins = (NCPU > 1) ? SPINS : 1;\n-        Object v;\n-        while ((v = p.match) == null) {\n-            if (spins > 0) {\n-                h ^= h << 1; h ^= h >>> 3; h ^= h << 10;\n-                if (h == 0)\n-                    h = SPINS | (int)t.threadId();\n-                else if (h < 0 && (--spins & ((SPINS >>> 1) - 1)) == 0)\n-                    Thread.yield();\n-            }\n-            else if (slot != p)\n-                spins = SPINS;\n-            else if (!t.isInterrupted() && arena == null &&\n-                     (!timed || (ns = end - System.nanoTime()) > 0L)) {\n-                p.parked = t;\n-                if (slot == p) {\n-                    if (ns == 0L)\n-                        LockSupport.park(this);\n-                    else\n-                        LockSupport.parkNanos(this, ns);\n-                }\n-                p.parked = null;\n-            }\n-            else if (SLOT.compareAndSet(this, p, null)) {\n-                v = timed && ns <= 0L && !t.isInterrupted() ? TIMED_OUT : null;\n-                break;\n@@ -514,4 +423,4 @@\n-        MATCH.setRelease(p, null);\n-        p.item = null;\n-        p.hash = h;\n-        return v;\n+        if (offered != null)                     \/\/ cleanup\n+            p.item = null;\n+        @SuppressWarnings(\"unchecked\") V ret = (v == participant) ? null : (V)v;\n+        return ret;\n@@ -524,1 +433,3 @@\n-        participant = new Participant();\n+        int h = (ncpu = Runtime.getRuntime().availableProcessors()) >>> 1;\n+        int size = (h == 0) ? 1 : (h > MMASK) ? MMASK + 1 : h;\n+        (arena = new Slot[size])[0] = new Slot();\n@@ -560,1 +471,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -562,9 +472,5 @@\n-        Object v;\n-        Node[] a;\n-        Object item = (x == null) ? NULL_ITEM : x; \/\/ translate null args\n-        if (((a = arena) != null ||\n-             (v = slotExchange(item, false, 0L)) == null) &&\n-            (Thread.interrupted() || \/\/ disambiguates null return\n-             (v = arenaExchange(item, false, 0L)) == null))\n-            throw new InterruptedException();\n-        return (v == NULL_ITEM) ? null : (V)v;\n+        try {\n+            return xchg(x, 0L);\n+        } catch (TimeoutException cannotHappen) {\n+            return null; \/\/ not reached\n+        }\n@@ -615,1 +521,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -618,11 +523,2 @@\n-        Object v;\n-        Object item = (x == null) ? NULL_ITEM : x;\n-        long ns = unit.toNanos(timeout);\n-        if ((arena != null ||\n-             (v = slotExchange(item, true, ns)) == null) &&\n-            (Thread.interrupted() ||\n-             (v = arenaExchange(item, true, ns)) == null))\n-            throw new InterruptedException();\n-        if (v == TIMED_OUT)\n-            throw new TimeoutException();\n-        return (v == NULL_ITEM) ? null : (V)v;\n+        long d = unit.toNanos(timeout) + System.nanoTime();\n+        return xchg(x, (d == 0L) ? 1L : d); \/\/ avoid zero deadline\n@@ -633,1 +529,0 @@\n-    private static final VarHandle SLOT;\n@@ -635,0 +530,1 @@\n+    private static final VarHandle ENTRY;\n@@ -640,1 +536,0 @@\n-            SLOT = l.findVarHandle(Exchanger.class, \"slot\", Node.class);\n@@ -642,1 +537,2 @@\n-            AA = MethodHandles.arrayElementVarHandle(Node[].class);\n+            ENTRY = l.findVarHandle(Slot.class, \"entry\", Node.class);\n+            AA = MethodHandles.arrayElementVarHandle(Slot[].class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Exchanger.java","additions":223,"deletions":327,"binary":false,"changes":550,"status":"modified"},{"patch":"@@ -673,1 +673,1 @@\n-     * released soon therafter. This is checked by setting the\n+     * released soon thereafter. This is checked by setting the\n@@ -858,1 +858,1 @@\n-     * exceptions is preferred to throwing InterruptedExecptions,\n+     * exceptions is preferred to throwing InterruptedExceptions,\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1075,1 +1075,1 @@\n-     * (possibly exceptionally) before the given timeout and\n+     * (possibly exceptionally) before the given timeout elapsed and\n@@ -1100,1 +1100,1 @@\n-     * (possibly exceptionally) before the given timeout.\n+     * (possibly exceptionally) before the given timeout elapsed.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -205,0 +207,24 @@\n+    \/**\n+     * Returns true if the current task is being executed by a\n+     * ForkJoinWorkerThread that is momentarily known to have one or\n+     * more queued tasks that it could execute immediately. This\n+     * method is approximate and useful only as a heuristic indicator\n+     * within a running task.\n+     *\n+     * @return true if the current task is being executed by a worker\n+     * that has queued work\n+     *\/\n+    static boolean hasKnownQueuedWork() {\n+        ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue q, sq;\n+        ForkJoinPool p; ForkJoinPool.WorkQueue[] qs; int i;\n+        Thread c = JLA.currentCarrierThread();\n+        return ((c instanceof ForkJoinWorkerThread) &&\n+                (p = (wt = (ForkJoinWorkerThread)c).pool) != null &&\n+                (q = wt.workQueue) != null &&\n+                (i = q.source) >= 0 && \/\/ check local and current source queues\n+                (((qs = p.queues) != null && qs.length > i &&\n+                  (sq = qs[i]) != null && sq.top - sq.base > 0) ||\n+                 q.top - q.base > 0));\n+    }\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinWorkerThread.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -429,2 +429,2 @@\n-            if (w.isVirtual())             \/\/ don't spin\n-                spin = false;\n+            if (spin && ForkJoinWorkerThread.hasKnownQueuedWork())\n+                spin = false;              \/\/ don't spin\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/LinkedTransferQueue.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -185,0 +185,5 @@\n+    \/**\n+     * Maximum delay is effectively 146 years\n+     *\/\n+    private static final long MAX_NANOS = (Long.MAX_VALUE >>> 1) - 1;\n+\n@@ -528,19 +533,1 @@\n-        return System.nanoTime() +\n-            ((delay < (Long.MAX_VALUE >> 1)) ? delay : overflowFree(delay));\n-    }\n-\n-    \/**\n-     * Constrains the values of all delays in the queue to be within\n-     * Long.MAX_VALUE of each other, to avoid overflow in compareTo.\n-     * This may occur if a task is eligible to be dequeued, but has\n-     * not yet been, while some other task is added with a delay of\n-     * Long.MAX_VALUE.\n-     *\/\n-    private long overflowFree(long delay) {\n-        Delayed head = (Delayed) super.getQueue().peek();\n-        if (head != null) {\n-            long headDelay = head.getDelay(NANOSECONDS);\n-            if (headDelay < 0 && (delay - headDelay < 0))\n-                delay = Long.MAX_VALUE + headDelay;\n-        }\n-        return delay;\n+        return System.nanoTime() + Math.min(delay, MAX_NANOS);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ScheduledThreadPoolExecutor.java","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -280,0 +280,34 @@\n+    \/**\n+     * Repeatedly invokes acquire, if its execution throws an Error or a Runtime Exception,\n+     * using an Unsafe.park-based backoff\n+     * @param node which to reacquire\n+     * @param arg the acquire argument\n+     *\/\n+    private final void reacquire(Node node, long arg) {\n+        try {\n+            acquire(node, arg, false, false, false, 0L);\n+        } catch (Error | RuntimeException firstEx) {\n+            \/\/ While we currently do not emit an JFR events in this situation, mainly\n+            \/\/ because the conditions under which this happens are such that it\n+            \/\/ cannot be presumed to be possible to actually allocate an event, and\n+            \/\/ using a preconstructed one would have limited value in serviceability.\n+            \/\/ Having said that, the following place would be the more appropriate\n+            \/\/ place to put such logic:\n+            \/\/     emit JFR event\n+\n+            for (long nanos = 1L;;) {\n+                U.park(false, nanos); \/\/ must use Unsafe park to sleep\n+                if (nanos < 1L << 30)            \/\/ max about 1 second\n+                    nanos <<= 1;\n+\n+                try {\n+                    acquire(node, arg, false, false, false, 0L);\n+                } catch (Error | RuntimeException ignored) {\n+                    continue;\n+                }\n+\n+                throw firstEx;\n+            }\n+        }\n+    }\n+\n@@ -1302,1 +1336,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1349,1 +1383,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1392,1 +1426,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1436,1 +1470,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1481,1 +1515,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/AbstractQueuedLongSynchronizer.java","additions":39,"deletions":5,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -659,0 +659,34 @@\n+    \/**\n+     * Repeatedly invokes acquire, if its execution throws an Error or a Runtime Exception,\n+     * using an Unsafe.park-based backoff\n+     * @param node which to reacquire\n+     * @param arg the acquire argument\n+     *\/\n+    private final void reacquire(Node node, int arg) {\n+        try {\n+            acquire(node, arg, false, false, false, 0L);\n+        } catch (Error | RuntimeException firstEx) {\n+            \/\/ While we currently do not emit an JFR events in this situation, mainly\n+            \/\/ because the conditions under which this happens are such that it\n+            \/\/ cannot be presumed to be possible to actually allocate an event, and\n+            \/\/ using a preconstructed one would have limited value in serviceability.\n+            \/\/ Having said that, the following place would be the more appropriate\n+            \/\/ place to put such logic:\n+            \/\/     emit JFR event\n+\n+            for (long nanos = 1L;;) {\n+                U.park(false, nanos); \/\/ must use Unsafe park to sleep\n+                if (nanos < 1L << 30)            \/\/ max about 1 second\n+                    nanos <<= 1;\n+\n+                try {\n+                    acquire(node, arg, false, false, false, 0L);\n+                } catch (Error | RuntimeException ignored) {\n+                    continue;\n+                }\n+\n+                throw firstEx;\n+            }\n+        }\n+    }\n+\n@@ -1681,1 +1715,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1728,1 +1762,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1771,1 +1805,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1815,1 +1849,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1860,1 +1894,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/AbstractQueuedSynchronizer.java","additions":39,"deletions":5,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -197,7 +197,10 @@\n-            static final TerminalOp<?, ?> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.REFERENCE, Optional.empty(),\n-                    Optional::isPresent, FindSink.OfRef::new);\n-\n-            static final TerminalOp<?, ?> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.REFERENCE, Optional.empty(),\n-                    Optional::isPresent, FindSink.OfRef::new);\n+            static final TerminalOp<?, ?> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<Optional<Object>> isPresent = Optional::isPresent;\n+                Supplier<TerminalSink<Object, Optional<Object>>> newSink\n+                        = FindSink.OfRef::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.REFERENCE,\n+                        Optional.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.REFERENCE,\n+                        Optional.empty(), isPresent, newSink);\n+            }\n@@ -220,6 +223,10 @@\n-            static final TerminalOp<Integer, OptionalInt> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.INT_VALUE, OptionalInt.empty(),\n-                    OptionalInt::isPresent, FindSink.OfInt::new);\n-            static final TerminalOp<Integer, OptionalInt> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.INT_VALUE, OptionalInt.empty(),\n-                    OptionalInt::isPresent, FindSink.OfInt::new);\n+            static final TerminalOp<Integer, OptionalInt> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<OptionalInt> isPresent = OptionalInt::isPresent;\n+                Supplier<TerminalSink<Integer, OptionalInt>> newSink\n+                        = FindSink.OfInt::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.INT_VALUE,\n+                        OptionalInt.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.INT_VALUE,\n+                        OptionalInt.empty(), isPresent, newSink);\n+            }\n@@ -242,6 +249,10 @@\n-            static final TerminalOp<Long, OptionalLong> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.LONG_VALUE, OptionalLong.empty(),\n-                    OptionalLong::isPresent, FindSink.OfLong::new);\n-            static final TerminalOp<Long, OptionalLong> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.LONG_VALUE, OptionalLong.empty(),\n-                    OptionalLong::isPresent, FindSink.OfLong::new);\n+            static final TerminalOp<Long, OptionalLong> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<OptionalLong> isPresent = OptionalLong::isPresent;\n+                Supplier<TerminalSink<Long, OptionalLong>> newSink\n+                        = FindSink.OfLong::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.LONG_VALUE,\n+                        OptionalLong.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.LONG_VALUE,\n+                        OptionalLong.empty(), isPresent, newSink);\n+            }\n@@ -264,6 +275,10 @@\n-            static final TerminalOp<Double, OptionalDouble> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.DOUBLE_VALUE, OptionalDouble.empty(),\n-                    OptionalDouble::isPresent, FindSink.OfDouble::new);\n-            static final TerminalOp<Double, OptionalDouble> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.DOUBLE_VALUE, OptionalDouble.empty(),\n-                    OptionalDouble::isPresent, FindSink.OfDouble::new);\n+            static final TerminalOp<Double, OptionalDouble> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<OptionalDouble> isPresent = OptionalDouble::isPresent;\n+                Supplier<TerminalSink<Double, OptionalDouble>> newSink\n+                        = FindSink.OfDouble::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.DOUBLE_VALUE,\n+                        OptionalDouble.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.DOUBLE_VALUE,\n+                        OptionalDouble.empty(), isPresent, newSink);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/FindOps.java","additions":40,"deletions":25,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -46,0 +47,1 @@\n+import java.util.concurrent.Executor;\n@@ -49,0 +51,1 @@\n+import jdk.internal.loader.NativeLibraries;\n@@ -284,2 +287,6 @@\n-     * Ensure that the given module has native access. If not, warn or\n-     * throw exception depending on the configuration.\n+     * Ensure that the given module has native access. If not, warn or throw exception depending on the configuration.\n+     * @param m the module in which native access occurred\n+     * @param owner the owner of the restricted method being called (or the JNI method being bound)\n+     * @param methodName the name of the restricted method being called (or the JNI method being bound)\n+     * @param currentClass the class calling the restricted method (for JNI, this is the same as {@code owner})\n+     * @param jni {@code true}, if this event is related to a JNI method being bound\n@@ -287,1 +294,1 @@\n-    void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass);\n+    void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass, boolean jni);\n@@ -317,0 +324,5 @@\n+    \/**\n+     * Count the number of leading non-zero ascii chars in the String.\n+     *\/\n+    int countNonZeroAscii(String s);\n+\n@@ -449,0 +461,12 @@\n+    Object stringConcat1(String[] constants);\n+\n+    \/**\n+     * Get the string initial coder, When COMPACT_STRINGS is on, it returns 0, and when it is off, it returns 1.\n+     *\/\n+    byte stringInitCoder();\n+\n+    \/**\n+     * Get the Coder of String, which is used by StringConcatFactory to calculate the initCoder of constants\n+     *\/\n+    byte stringCoder(String str);\n+\n@@ -454,0 +478,5 @@\n+    \/**\n+     * Concatenation of prefix and suffix characters to a String for early bootstrap\n+     *\/\n+    String concat(String prefix, Object value, String suffix);\n+\n@@ -465,1 +494,5 @@\n-    long findNative(ClassLoader loader, String entry);\n+    \/**\n+     * Returns the {@link NativeLibraries} object associated with the provided class loader.\n+     * This is used by {@link SymbolLookup#loaderLookup()}.\n+     *\/\n+    NativeLibraries nativeLibrariesFor(ClassLoader loader);\n@@ -577,0 +610,5 @@\n+    \/**\n+     * Returns the virtual thread default scheduler.\n+     *\/\n+    Executor virtualThreadDefaultScheduler();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":42,"deletions":4,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,1 @@\n-    internals of java.lang.reflect. *\/\n-\n+    internals of java.lang.reflect. Use as a last resort! *\/\n@@ -35,25 +34,5 @@\n-    \/** Creates a new java.lang.reflect.Constructor. Access checks as\n-      per java.lang.reflect.AccessibleObject are not overridden. *\/\n-    public <T> Constructor<T> newConstructor(Class<T> declaringClass,\n-                                             Class<?>[] parameterTypes,\n-                                             Class<?>[] checkedExceptions,\n-                                             int modifiers,\n-                                             int slot,\n-                                             String signature,\n-                                             byte[] annotations,\n-                                             byte[] parameterAnnotations);\n-\n-    \/** Gets the MethodAccessor object for a java.lang.reflect.Method *\/\n-    public MethodAccessor getMethodAccessor(Method m);\n-\n-    \/** Sets the MethodAccessor object for a java.lang.reflect.Method *\/\n-    public void setMethodAccessor(Method m, MethodAccessor accessor);\n-\n-    \/** Gets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c);\n-\n-    \/** Sets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor);\n+    \/**\n+     * Creates a new root constructor from the original one, with\n+     * a custom accessor. Used by serialization hooks.\n+     *\/\n+    <T> Constructor<T> newConstructorWithAccessor(Constructor<T> original, ConstructorAccessor accessor);\n@@ -64,12 +43,0 @@\n-    \/** Gets the \"slot\" field from a Constructor (used for serialization) *\/\n-    public int getConstructorSlot(Constructor<?> c);\n-\n-    \/** Gets the \"signature\" field from a Constructor (used for serialization) *\/\n-    public String getConstructorSignature(Constructor<?> c);\n-\n-    \/** Gets the \"annotations\" field from a Constructor (used for serialization) *\/\n-    public byte[] getConstructorAnnotations(Constructor<?> c);\n-\n-    \/** Gets the \"parameterAnnotations\" field from a Constructor (used for serialization) *\/\n-    public byte[] getConstructorParameterAnnotations(Constructor<?> c);\n-\n@@ -82,1 +49,0 @@\n-    \/\/\n@@ -85,1 +51,0 @@\n-    \/\/\n@@ -90,3 +55,0 @@\n-    \/** Makes a copy of this non-root a Method *\/\n-    public Method      leafCopyMethod(Method arg);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":7,"deletions":45,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.access.foreign.MappedMemoryUtilsProxy;\n@@ -110,10 +111,0 @@\n-    \/**\n-     * Used by {@code jdk.internal.foreign.MappedMemorySegmentImpl} and byte buffer var handle views.\n-     *\/\n-    void force(FileDescriptor fd, long address, boolean isSync, long offset, long size);\n-\n-    \/**\n-     * Used by {@code jdk.internal.foreign.MappedMemorySegmentImpl} and byte buffer var handle views.\n-     *\/\n-    void load(long address, boolean isSync, long size);\n-\n@@ -123,6 +114,1 @@\n-    void unload(long address, boolean isSync, long size);\n-\n-    \/**\n-     * Used by {@code jdk.internal.foreign.MappedMemorySegmentImpl} and byte buffer var handle views.\n-     *\/\n-    boolean isLoaded(long address, boolean isSync, long size);\n+    MappedMemoryUtilsProxy mappedMemoryUtils();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -56,1 +56,7 @@\n-    for this purpose, namely the loss of compile-time checking. *\/\n+    for this purpose, namely the loss of compile-time checking.\n+ * <p><strong>\n+ * Usage of these APIs often means bad encapsulation designs,\n+ * increased complexity and lack of sustainability.\n+ * Use this only as a last resort!\n+ * <\/strong>\n+ *\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.access.foreign;\n+\n+import java.io.FileDescriptor;\n+\n+\/**\n+ * This proxy interface is required to allow access to @{code MappedMemoryUtils} methods from {@code ScopedMemoryAccess}.\n+ * This allows to avoid pesky initialization issues in the middle of memory mapped scoped methods.\n+ *\/\n+public interface MappedMemoryUtilsProxy {\n+    boolean isLoaded(long address, boolean isSync, long size);\n+    void load(long address, boolean isSync, long size);\n+    void unload(long address, boolean isSync, long size);\n+    void force(FileDescriptor fd, long address, boolean isSync, long index, long length);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/foreign\/MappedMemoryUtilsProxy.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -65,1 +65,2 @@\n-    public final void writeAttribute(BufWriter buf, T attr) {\n+    public final void writeAttribute(BufWriter writer, T attr) {\n+        BufWriterImpl buf = (BufWriterImpl) writer;\n@@ -67,2 +68,1 @@\n-        buf.writeInt(0);\n-        int start = buf.size();\n+        int lengthIndex = buf.skip(4);\n@@ -70,2 +70,2 @@\n-        int written = buf.size() - start;\n-        buf.patchInt(start - 4, 4, written);\n+        int written = buf.size() - lengthIndex - 4;\n+        buf.patchInt(lengthIndex, written);\n@@ -660,1 +660,1 @@\n-            AnnotationReader.writeAnnotations(buf, attr.annotations());\n+            AnnotationReader.writeTypeAnnotations(buf, attr.annotations());\n@@ -717,1 +717,1 @@\n-            AnnotationReader.writeAnnotations(buf, attr.annotations());\n+            AnnotationReader.writeTypeAnnotations(buf, attr.annotations());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        if (Util.isAttributeAllowed(a, context.attributesProcessingOption())) {\n+        if (Util.isAttributeAllowed(a, context)) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractDirectBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-    final int size;\n@@ -106,1 +105,2 @@\n-        return size;\n+        \/\/ Note: only lookupswitch and tableswitch have variable sizes\n+        return op.sizeIfFixed();\n@@ -109,1 +109,1 @@\n-    public AbstractInstruction(Opcode op, int size) {\n+    AbstractInstruction(Opcode op) {\n@@ -111,1 +111,0 @@\n-        this.size = size;\n@@ -121,2 +120,2 @@\n-        protected BoundInstruction(Opcode op, int size, CodeImpl code, int pos) {\n-            super(op, size);\n+        protected BoundInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op);\n@@ -134,1 +133,1 @@\n-            code.classReader.copyBytesTo(writer.bytecodesBufWriter, pos, size);\n+            code.classReader.copyBytesTo(writer.bytecodesBufWriter, pos, op.sizeIfFixed());\n@@ -142,1 +141,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -148,1 +147,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.loadType(op);\n@@ -158,1 +157,1 @@\n-            return switch (size) {\n+            return switch (sizeInBytes()) {\n@@ -171,1 +170,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -176,1 +175,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.storeType(op);\n@@ -186,1 +185,1 @@\n-            return switch (size) {\n+            return switch (sizeInBytes()) {\n@@ -189,1 +188,1 @@\n-                default -> throw new IllegalArgumentException(\"Unexpected op size: \" + size + \" -- \" + op);\n+                default -> throw new IllegalArgumentException(\"Unexpected op size: \" + sizeInBytes() + \" -- \" + op);\n@@ -199,1 +198,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -204,1 +203,1 @@\n-            return size == 6 ? code.classReader.readU2(pos + 2) : code.classReader.readU1(pos + 1);\n+            return sizeInBytes() == 6 ? code.classReader.readU2(pos + 2) : code.classReader.readU1(pos + 1);\n@@ -209,1 +208,1 @@\n-            return size == 6 ? code.classReader.readS2(pos + 4) : (byte) code.classReader.readS1(pos + 2);\n+            return sizeInBytes() == 6 ? code.classReader.readS2(pos + 4) : code.classReader.readS1(pos + 2);\n@@ -223,1 +222,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -232,2 +231,2 @@\n-            return size == 3\n-                   ? (int) (short) code.classReader.readU2(pos + 1)\n+            return sizeInBytes() == 3\n+                   ? code.classReader.readS2(pos + 1)\n@@ -259,0 +258,1 @@\n+        private final int size;\n@@ -261,3 +261,2 @@\n-            super(op, size(code, code.codeStart, pos), code, pos);\n-\n-            this.afterPad = pos + 1 + ((4 - ((pos + 1 - code.codeStart) & 3)) & 3);\n+            super(op, code, pos);\n+            this.afterPad = code.codeStart + RawBytecodeHelper.align(pos + 1 - code.codeStart);\n@@ -268,7 +267,1 @@\n-        }\n-\n-        static int size(CodeImpl code, int codeStart, int pos) {\n-            int afterPad = pos + 1 + ((4 - ((pos + 1 - codeStart) & 3)) & 3);\n-            int pad = afterPad - (pos + 1);\n-            int npairs = code.classReader.readInt(afterPad + 4);\n-            return 1 + pad + 8 + npairs * 8;\n+            this.size = afterPad + 8 + npairs * 8 - pos;\n@@ -281,0 +274,5 @@\n+        @Override\n+        public int sizeInBytes() {\n+            return size;\n+        }\n+\n@@ -284,2 +282,1 @@\n-            for (int i = 0; i < npairs; ++i) {\n-                int z = afterPad + 8 + 8 * i;\n+            for (int i = 0, z = afterPad + 8; i < npairs; ++i, z += 8) {\n@@ -311,3 +308,4 @@\n-        BoundTableSwitchInstruction(Opcode op, CodeImpl code, int pos) {\n-            super(op, size(code, code.codeStart, pos), code, pos);\n-        }\n+        private final int afterPad;\n+        private final int low;\n+        private final int high;\n+        private final int size;\n@@ -315,5 +313,5 @@\n-        static int size(CodeImpl code, int codeStart, int pos) {\n-            int ap = pos + 1 + ((4 - ((pos + 1 - codeStart) & 3)) & 3);\n-            int pad = ap - (pos + 1);\n-            int low = code.classReader.readInt(ap + 4);\n-            int high = code.classReader.readInt(ap + 8);\n+        BoundTableSwitchInstruction(Opcode op, CodeImpl code, int pos) {\n+            super(op, code, pos);\n+            afterPad = code.codeStart + RawBytecodeHelper.align(pos + 1 - code.codeStart);\n+            low = code.classReader.readInt(afterPad + 4);\n+            high = code.classReader.readInt(afterPad + 8);\n@@ -324,1 +322,1 @@\n-            return 1 + pad + 12 + cnt * 4;\n+            size = afterPad + 12 + cnt * 4 - pos;\n@@ -327,3 +325,3 @@\n-        private int afterPadding() {\n-            int p = pos;\n-            return p + 1 + ((4 - ((p + 1 - code.codeStart) & 3)) & 3);\n+        @Override\n+        public int sizeInBytes() {\n+            return size;\n@@ -339,1 +337,1 @@\n-            return code.classReader.readInt(afterPadding() + 4);\n+            return low;\n@@ -344,1 +342,1 @@\n-            return code.classReader.readInt(afterPadding() + 8);\n+            return high;\n@@ -353,2 +351,1 @@\n-            int z = afterPadding() + 12;\n-            for (int i = lowValue(); i <= high; ++i) {\n+            for (int i = low, z = afterPad + 12; i <= high; ++i, z += 4) {\n@@ -359,1 +356,0 @@\n-                z += 4;\n@@ -365,1 +361,1 @@\n-            return code.classReader.readInt(afterPadding());\n+            return code.classReader.readInt(afterPad);\n@@ -386,1 +382,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -416,1 +412,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -456,1 +452,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -496,1 +492,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -526,1 +522,1 @@\n-            super(Opcode.NEW, Opcode.NEW.sizeIfFixed(), code, pos);\n+            super(Opcode.NEW, code, pos);\n@@ -555,1 +551,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -574,1 +570,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -600,1 +596,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -633,1 +629,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -662,1 +658,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -671,1 +667,1 @@\n-            return size == 3 ? code.classReader.readS2(pos + 1) : code.classReader.readS1(pos + 1);\n+            return sizeInBytes() == 3 ? code.classReader.readS2(pos + 1) : code.classReader.readS1(pos + 1);\n@@ -685,1 +681,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -720,1 +716,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -729,1 +725,1 @@\n-            return size == 3\n+            return sizeInBytes() == 3\n@@ -750,1 +746,1 @@\n-            super(op, op.sizeIfFixed(), code, pos);\n+            super(op, code, pos);\n@@ -760,1 +756,1 @@\n-            return switch (size) {\n+            return switch (sizeInBytes()) {\n@@ -772,1 +768,1 @@\n-            super(op, op.sizeIfFixed());\n+            super(op);\n@@ -803,1 +799,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.loadType(op);\n@@ -834,1 +830,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.storeType(op);\n@@ -996,1 +992,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.returnType(op);\n@@ -1229,1 +1225,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.arrayLoadType(op);\n@@ -1242,1 +1238,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.arrayStoreType(op);\n@@ -1289,1 +1285,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.convertFromType(op);\n@@ -1294,1 +1290,1 @@\n-            return op.secondaryTypeKind();\n+            return BytecodeHelpers.convertToType(op);\n@@ -1307,1 +1303,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.operatorOperandType(op);\n@@ -1313,2 +1309,0 @@\n-        final ConstantDesc constant;\n-\n@@ -1317,6 +1311,0 @@\n-            constant = op.constantValue();\n-        }\n-\n-        @Override\n-        public void writeTo(DirectCodeBuilder writer) {\n-            super.writeTo(writer);\n@@ -1327,1 +1315,1 @@\n-            return constant;\n+            return BytecodeHelpers.intrinsicConstantValue(op);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":72,"deletions":84,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -412,0 +412,1 @@\n+            pool.writeU1(tag);\n@@ -413,1 +414,0 @@\n-                pool.writeU1(tag);\n@@ -419,47 +419,1 @@\n-                if (stringValue.length() > 65535) {\n-                    throw new IllegalArgumentException(\"string too long\");\n-                }\n-                pool.writeU1(tag);\n-                pool.writeU2(charLen);\n-                for (int i = 0; i < charLen; ++i) {\n-                    char c = stringValue.charAt(i);\n-                    if (c >= '\\001' && c <= '\\177') {\n-                        \/\/ Optimistic writing -- hope everything is bytes\n-                        \/\/ If not, we bail out, and alternate path patches the length\n-                        pool.writeU1((byte) c);\n-                    }\n-                    else {\n-                        int charLength = stringValue.length();\n-                        int byteLength = i;\n-                        char c1;\n-                        for (int j = i; j < charLength; ++j) {\n-                            c1 = (stringValue).charAt(j);\n-                            if (c1 >= '\\001' && c1 <= '\\177') {\n-                                byteLength++;\n-                            } else if (c1 > '\\u07FF') {\n-                                byteLength += 3;\n-                            } else {\n-                                byteLength += 2;\n-                            }\n-                        }\n-                        if (byteLength > 65535) {\n-                            throw new IllegalArgumentException();\n-                        }\n-                        int byteLengthFinal = byteLength;\n-                        pool.patchInt(pool.size() - i - 2, 2, byteLengthFinal);\n-                        for (int j = i; j < charLength; ++j) {\n-                            c1 = (stringValue).charAt(j);\n-                            if (c1 >= '\\001' && c1 <= '\\177') {\n-                                pool.writeU1((byte) c1);\n-                            } else if (c1 > '\\u07FF') {\n-                                pool.writeU1((byte) (0xE0 | c1 >> 12 & 0xF));\n-                                pool.writeU1((byte) (0x80 | c1 >> 6 & 0x3F));\n-                                pool.writeU1((byte) (0x80 | c1 & 0x3F));\n-                            } else {\n-                                pool.writeU1((byte) (0xC0 | c1 >> 6 & 0x1F));\n-                                pool.writeU1((byte) (0x80 | c1 & 0x3F));\n-                            }\n-                        }\n-                        break;\n-                    }\n-                }\n+                pool.writeUTF(stringValue);\n@@ -537,9 +491,0 @@\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (o == this) { return true; }\n-            if (o instanceof AbstractNamedEntry ne) {\n-                return tag == ne.tag() && name().equals(ref1());\n-            }\n-            return false;\n-        }\n@@ -1042,16 +987,1 @@\n-    abstract static sealed class PrimitiveEntry<T extends ConstantDesc>\n-            extends AbstractPoolEntry {\n-        protected final T val;\n-\n-        public PrimitiveEntry(ConstantPool constantPool, int tag, int index, T val) {\n-            super(constantPool, tag, index, hash1(tag, val.hashCode()));\n-            this.val = val;\n-        }\n-\n-        public T value() {\n-            return val;\n-        }\n-\n-        public ConstantDesc constantValue() {\n-            return value();\n-        }\n+    public static final class IntegerEntryImpl extends AbstractPoolEntry implements IntegerEntry {\n@@ -1059,8 +989,1 @@\n-        @Override\n-        public String toString() {\n-            return \"\" + tag() + value();\n-        }\n-    }\n-\n-    public static final class IntegerEntryImpl extends PrimitiveEntry<Integer>\n-            implements IntegerEntry {\n+        private final int val;\n@@ -1069,1 +992,2 @@\n-            super(cpm, ClassFile.TAG_INTEGER, index, i);\n+            super(cpm, ClassFile.TAG_INTEGER, index, hash1(ClassFile.TAG_INTEGER, Integer.hashCode(i)));\n+            val = i;\n@@ -1085,1 +1009,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n@@ -1098,1 +1027,1 @@\n-    public static final class FloatEntryImpl extends PrimitiveEntry<Float>\n+    public static final class FloatEntryImpl extends AbstractPoolEntry\n@@ -1101,0 +1030,2 @@\n+        private final float val;\n+\n@@ -1102,1 +1033,2 @@\n-            super(cpm, ClassFile.TAG_FLOAT, index, f);\n+            super(cpm, ClassFile.TAG_FLOAT, index, hash1(ClassFile.TAG_FLOAT, Float.hashCode(f)));\n+            val = f;\n@@ -1118,1 +1050,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n@@ -1131,1 +1068,3 @@\n-    public static final class LongEntryImpl extends PrimitiveEntry<Long> implements LongEntry {\n+    public static final class LongEntryImpl extends AbstractPoolEntry implements LongEntry {\n+\n+        private final long val;\n@@ -1134,1 +1073,2 @@\n-            super(cpm, ClassFile.TAG_LONG, index, l);\n+            super(cpm, ClassFile.TAG_LONG, index, hash1(ClassFile.TAG_LONG, Long.hashCode(l)));\n+            val = l;\n@@ -1150,1 +1090,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n@@ -1163,1 +1108,3 @@\n-    public static final class DoubleEntryImpl extends PrimitiveEntry<Double> implements DoubleEntry {\n+    public static final class DoubleEntryImpl extends AbstractPoolEntry implements DoubleEntry {\n+\n+        private final double val;\n@@ -1166,1 +1113,2 @@\n-            super(cpm, ClassFile.TAG_DOUBLE, index, d);\n+            super(cpm, ClassFile.TAG_DOUBLE, index, hash1(ClassFile.TAG_DOUBLE, Double.hashCode(d)));\n+            val = d;\n@@ -1182,1 +1130,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":45,"deletions":92,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-        implements Annotation, Util.Writable {\n+        implements Annotation {\n@@ -40,10 +40,0 @@\n-    @Override\n-    public void writeTo(BufWriterImpl buf) {\n-        buf.writeIndex(className());\n-        buf.writeU2(elements().size());\n-        for (var e : elements) {\n-            buf.writeIndex(e.name());\n-            AnnotationReader.writeAnnotationValue(buf, e.value());\n-        }\n-    }\n-\n@@ -55,8 +45,0 @@\n-        if (!evps.isEmpty())\n-            sb.append(\" [\");\n-        for (AnnotationElement evp : evps) {\n-            sb.append(evp.name().stringValue())\n-                    .append(\"=\")\n-                    .append(evp.value().toString())\n-                    .append(\", \");\n-        }\n@@ -64,2 +46,1 @@\n-            sb.delete(sb.length()-1, sb.length());\n-            sb.append(\"]\");\n+            sb.append(' ').append(evps);\n@@ -73,2 +54,1 @@\n-            implements AnnotationElement, Util.Writable {\n-\n+            implements AnnotationElement {\n@@ -76,3 +56,2 @@\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeIndex(name());\n-            AnnotationReader.writeAnnotationValue(buf, value());\n+        public String toString() {\n+            return name + \"=\" + value;\n@@ -82,10 +61,0 @@\n-    public sealed interface OfConstantImpl extends AnnotationValue.OfConstant, Util.Writable {\n-\n-        @Override\n-        default void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeIndex(constant());\n-        }\n-\n-    }\n-\n@@ -93,2 +62,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfString {\n-\n+            implements AnnotationValue.OfString {\n@@ -107,2 +75,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfDouble {\n-\n+            implements AnnotationValue.OfDouble {\n@@ -121,2 +88,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfFloat {\n-\n+            implements AnnotationValue.OfFloat {\n@@ -135,2 +101,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfLong {\n-\n+            implements AnnotationValue.OfLong {\n@@ -149,2 +114,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfInt {\n-\n+            implements AnnotationValue.OfInt {\n@@ -163,2 +127,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfShort {\n-\n+            implements AnnotationValue.OfShort {\n@@ -177,2 +140,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfChar {\n-\n+            implements AnnotationValue.OfChar {\n@@ -191,2 +153,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfByte {\n-\n+            implements AnnotationValue.OfByte {\n@@ -205,2 +166,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfBoolean {\n-\n+            implements AnnotationValue.OfBoolean {\n@@ -219,2 +179,1 @@\n-            implements AnnotationValue.OfArray, Util.Writable {\n-\n+            implements AnnotationValue.OfArray {\n@@ -229,10 +188,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeU2(values.size());\n-            for (var e : values) {\n-                AnnotationReader.writeAnnotationValue(buf, e);\n-            }\n-        }\n-\n@@ -242,1 +191,1 @@\n-            implements AnnotationValue.OfEnum, Util.Writable {\n+            implements AnnotationValue.OfEnum {\n@@ -247,8 +196,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeIndex(className);\n-            buf.writeIndex(constantName);\n-        }\n-\n@@ -258,1 +199,1 @@\n-            implements AnnotationValue.OfAnnotation, Util.Writable {\n+            implements AnnotationValue.OfAnnotation {\n@@ -263,7 +204,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            AnnotationReader.writeAnnotation(buf, annotation);\n-        }\n-\n@@ -273,1 +207,1 @@\n-            implements AnnotationValue.OfClass, Util.Writable {\n+            implements AnnotationValue.OfClass {\n@@ -278,7 +212,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeIndex(className);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationImpl.java","additions":18,"deletions":91,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -244,4 +244,2 @@\n-        Utf8Entry type = classReader.readEntry(p, Utf8Entry.class);\n-        p += 2;\n-        return TypeAnnotation.of(targetInfo, List.of(typePath), type,\n-                                 readAnnotationElementValuePairs(classReader, p));\n+        var anno = readAnnotation(classReader, p);\n+        return TypeAnnotation.of(targetInfo, List.of(typePath), anno);\n@@ -286,3 +284,7 @@\n-        \/\/ handles annotations and type annotations\n-        \/\/ TODO annotation cleanup later\n-        ((Util.Writable) annotation).writeTo(buf);\n+        buf.writeIndex(annotation.className());\n+        var elements = annotation.elements();\n+        buf.writeU2(elements.size());\n+        for (var e : elements) {\n+            buf.writeIndex(e.name());\n+            AnnotationReader.writeAnnotationValue(buf, e.value());\n+        }\n@@ -291,2 +293,1 @@\n-    public static void writeAnnotations(BufWriter buf, List<? extends Annotation> list) {\n-        \/\/ handles annotations and type annotations\n+    public static void writeAnnotations(BufWriter buf, List<Annotation> list) {\n@@ -300,0 +301,60 @@\n+    private static int labelToBci(LabelContext lr, Label label, TypeAnnotation ta) {\n+        \/\/helper method to avoid NPE\n+        if (lr == null) throw new IllegalArgumentException(\"Illegal targetType '%s' in TypeAnnotation outside of Code attribute\".formatted(ta.targetInfo().targetType()));\n+        return lr.labelToBci(label);\n+    }\n+\n+    public static void writeTypeAnnotation(BufWriterImpl buf, TypeAnnotation ta) {\n+        LabelContext lr = buf.labelContext();\n+        \/\/ target_type\n+        buf.writeU1(ta.targetInfo().targetType().targetTypeValue());\n+\n+        \/\/ target_info\n+        switch (ta.targetInfo()) {\n+            case TypeAnnotation.TypeParameterTarget tpt -> buf.writeU1(tpt.typeParameterIndex());\n+            case TypeAnnotation.SupertypeTarget st -> buf.writeU2(st.supertypeIndex());\n+            case TypeAnnotation.TypeParameterBoundTarget tpbt -> {\n+                buf.writeU1(tpbt.typeParameterIndex());\n+                buf.writeU1(tpbt.boundIndex());\n+            }\n+            case TypeAnnotation.EmptyTarget _ -> {\n+                \/\/ nothing to write\n+            }\n+            case TypeAnnotation.FormalParameterTarget fpt -> buf.writeU1(fpt.formalParameterIndex());\n+            case TypeAnnotation.ThrowsTarget tt -> buf.writeU2(tt.throwsTargetIndex());\n+            case TypeAnnotation.LocalVarTarget lvt -> {\n+                buf.writeU2(lvt.table().size());\n+                for (var e : lvt.table()) {\n+                    int startPc = labelToBci(lr, e.startLabel(), ta);\n+                    buf.writeU2(startPc);\n+                    buf.writeU2(labelToBci(lr, e.endLabel(), ta) - startPc);\n+                    buf.writeU2(e.index());\n+                }\n+            }\n+            case TypeAnnotation.CatchTarget ct -> buf.writeU2(ct.exceptionTableIndex());\n+            case TypeAnnotation.OffsetTarget ot -> buf.writeU2(labelToBci(lr, ot.target(), ta));\n+            case TypeAnnotation.TypeArgumentTarget tat -> {\n+                buf.writeU2(labelToBci(lr, tat.target(), ta));\n+                buf.writeU1(tat.typeArgumentIndex());\n+            }\n+        }\n+\n+        \/\/ target_path\n+        buf.writeU1(ta.targetPath().size());\n+        for (TypeAnnotation.TypePathComponent component : ta.targetPath()) {\n+            buf.writeU1(component.typePathKind().tag());\n+            buf.writeU1(component.typeArgumentIndex());\n+        }\n+\n+        \/\/ annotation data\n+        writeAnnotation(buf, ta.annotation());\n+    }\n+\n+    public static void writeTypeAnnotations(BufWriter buf, List<TypeAnnotation> list) {\n+        var internalBuf = (BufWriterImpl) buf;\n+        internalBuf.writeU2(list.size());\n+        for (var e : list) {\n+            writeTypeAnnotation(internalBuf, e);\n+        }\n+    }\n+\n@@ -301,2 +362,21 @@\n-        \/\/ TODO annotation cleanup later\n-        ((Util.Writable) value).writeTo(buf);\n+        var tag = value.tag();\n+        buf.writeU1(tag);\n+        switch (value.tag()) {\n+            case AEV_BOOLEAN, AEV_BYTE, AEV_CHAR, AEV_DOUBLE, AEV_FLOAT, AEV_INT, AEV_LONG, AEV_SHORT, AEV_STRING ->\n+                    buf.writeIndex(((AnnotationValue.OfConstant) value).constant());\n+            case AEV_CLASS -> buf.writeIndex(((AnnotationValue.OfClass) value).className());\n+            case AEV_ENUM -> {\n+                var enumValue = (AnnotationValue.OfEnum) value;\n+                buf.writeIndex(enumValue.className());\n+                buf.writeIndex(enumValue.constantName());\n+            }\n+            case AEV_ANNOTATION -> writeAnnotation(buf, ((AnnotationValue.OfAnnotation) value).annotation());\n+            case AEV_ARRAY -> {\n+                var array = ((AnnotationValue.OfArray) value).values();\n+                buf.writeU2(array.size());\n+                for (var e : array) {\n+                    writeAnnotationValue(buf, e);\n+                }\n+            }\n+            default -> throw new InternalError(\"Unknown value \" + value);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":91,"deletions":11,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -56,0 +56,8 @@\n+    @SuppressWarnings(\"unchecked\")\n+    <A extends Attribute<A>> A get(AttributeMapper<A> am) {\n+        for (Attribute<?> a : attributes)\n+            if (a.attributeMapper() == am)\n+                return (A)a;\n+        return null;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AttributeHolder.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-            if (element instanceof Instruction i && i.opcode().isUnconditionalBranch())\n+            if (element instanceof Instruction i && BytecodeHelpers.isUnconditionalBranch(i.opcode()))\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BlockCodeBuilderImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-                filled.add((Attribute<?>) Objects.requireNonNull(mapper.readAttribute(enclosing, reader, p)));\n+                filled.add(Objects.requireNonNull(mapper.readAttribute(enclosing, reader, p)));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -28,1 +29,0 @@\n-import java.nio.ByteBuffer;\n@@ -37,0 +37,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -38,0 +41,1 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -94,1 +98,2 @@\n-        writeIntBytes(1, x);\n+        reserveSpace(1);\n+        elems[offset++] = (byte) x;\n@@ -99,1 +104,6 @@\n-        writeIntBytes(2, x);\n+        reserveSpace(2);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 8);\n+        elems[offset + 1] = (byte) x;\n+        this.offset = offset + 2;\n@@ -104,1 +114,8 @@\n-        writeIntBytes(4, x);\n+        reserveSpace(4);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 24);\n+        elems[offset + 1] = (byte) (x >> 16);\n+        elems[offset + 2] = (byte) (x >> 8);\n+        elems[offset + 3] = (byte)  x;\n+        this.offset = offset + 4;\n@@ -114,1 +131,12 @@\n-        writeIntBytes(8, x);\n+        reserveSpace(8);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 56);\n+        elems[offset + 1] = (byte) (x >> 48);\n+        elems[offset + 2] = (byte) (x >> 40);\n+        elems[offset + 3] = (byte) (x >> 32);\n+        elems[offset + 4] = (byte) (x >> 24);\n+        elems[offset + 5] = (byte) (x >> 16);\n+        elems[offset + 6] = (byte) (x >> 8);\n+        elems[offset + 7] = (byte)  x;\n+        this.offset = offset + 8;\n@@ -131,0 +159,46 @@\n+    @SuppressWarnings(\"deprecation\")\n+    void writeUTF(String str) {\n+        int strlen = str.length();\n+        int countNonZeroAscii = JLA.countNonZeroAscii(str);\n+        int utflen = strlen;\n+        if (countNonZeroAscii != strlen) {\n+            for (int i = countNonZeroAscii; i < strlen; i++) {\n+                int c = str.charAt(i);\n+                if (c >= 0x80 || c == 0)\n+                    utflen += (c >= 0x800) ? 2 : 1;\n+            }\n+        }\n+        if (utflen > 65535) {\n+            throw new IllegalArgumentException(\"string too long\");\n+        }\n+        reserveSpace(utflen + 2);\n+\n+        int offset = this.offset;\n+        byte[] elems = this.elems;\n+\n+        elems[offset    ] = (byte) (utflen >> 8);\n+        elems[offset + 1] = (byte)  utflen;\n+        offset += 2;\n+\n+        str.getBytes(0, countNonZeroAscii, elems, offset);\n+        offset += countNonZeroAscii;\n+\n+        for (int i = countNonZeroAscii; i < strlen; ++i) {\n+            char c = str.charAt(i);\n+            if (c >= '\\001' && c <= '\\177') {\n+                elems[offset++] = (byte) c;\n+            } else if (c > '\\u07FF') {\n+                elems[offset    ] = (byte) (0xE0 | c >> 12 & 0xF);\n+                elems[offset + 1] = (byte) (0x80 | c >> 6 & 0x3F);\n+                elems[offset + 2] = (byte) (0x80 | c      & 0x3F);\n+                offset += 3;\n+            } else {\n+                elems[offset    ] = (byte) (0xC0 | c >> 6 & 0x1F);\n+                elems[offset + 1] = (byte) (0x80 | c      & 0x3F);\n+                offset += 2;\n+            }\n+        }\n+\n+        this.offset = offset;\n+    }\n+\n@@ -146,0 +220,14 @@\n+    public void patchU2(int offset, int x) {\n+        byte[] elems = this.elems;\n+        elems[offset    ] = (byte) (x >> 8);\n+        elems[offset + 1] = (byte)  x;\n+    }\n+\n+    public void patchInt(int offset, int x) {\n+        byte[] elems = this.elems;\n+        elems[offset    ] = (byte) (x >> 24);\n+        elems[offset + 1] = (byte) (x >> 16);\n+        elems[offset + 2] = (byte) (x >> 8);\n+        elems[offset + 3] = (byte)  x;\n+    }\n+\n@@ -154,0 +242,12 @@\n+    \/**\n+     * Skip a few bytes in the output buffer. The skipped area has undefined value.\n+     * @param bytes number of bytes to skip\n+     * @return the index, for later patching\n+     *\/\n+    public int skip(int bytes) {\n+        int now = offset;\n+        reserveSpace(bytes);\n+        offset += bytes;\n+        return now;\n+    }\n+\n@@ -156,6 +256,10 @@\n-        if (offset + freeBytes > elems.length) {\n-            int newsize = elems.length * 2;\n-            while (offset + freeBytes > newsize) {\n-                newsize *= 2;\n-            }\n-            elems = Arrays.copyOf(elems, newsize);\n+        int minCapacity = offset + freeBytes;\n+        if (minCapacity > elems.length) {\n+            grow(minCapacity);\n+        }\n+    }\n+\n+    private void grow(int minCapacity) {\n+        int newsize = elems.length * 2;\n+        while (minCapacity > newsize) {\n+            newsize *= 2;\n@@ -163,0 +267,1 @@\n+        elems = Arrays.copyOf(elems, newsize);\n@@ -170,2 +275,2 @@\n-    public ByteBuffer asByteBuffer() {\n-        return ByteBuffer.wrap(elems, 0, offset).slice();\n+    public RawBytecodeHelper.CodeRange bytecodeView() {\n+        return RawBytecodeHelper.of(elems, offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":118,"deletions":13,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -176,6 +176,1 @@\n-            builder.withCode(new Consumer<>() {\n-                @Override\n-                public void accept(CodeBuilder cb) {\n-                    forEach(cb);\n-                }\n-            });\n+            builder.withCode(Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -107,6 +107,1 @@\n-            builder.withField(name, desc, new Consumer<>() {\n-                @Override\n-                public void accept(FieldBuilder fieldBuilder) {\n-                    elements.forEach(fieldBuilder);\n-                }\n-            });\n+            builder.withField(name, desc, Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedFieldBuilder.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -208,6 +208,1 @@\n-            builder.withMethod(methodName(), methodType(), methodFlags(), new Consumer<>() {\n-                @Override\n-                public void accept(MethodBuilder mb) {\n-                    forEach(mb);\n-                }\n-            });\n+            builder.withMethod(methodName(), methodType(), methodFlags(), Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedMethodBuilder.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -48,0 +49,5 @@\n+import static java.lang.classfile.ClassFile.*;\n+\n+\/**\n+ * Note: This class switches on opcode.bytecode for code size\n+ *\/\n@@ -53,0 +59,4 @@\n+    public static IllegalArgumentException cannotConvertException(TypeKind from, TypeKind to) {\n+        return new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+    }\n+\n@@ -55,36 +65,57 @@\n-            case IntType, ShortType, ByteType, CharType, BooleanType -> switch (slot) {\n-                case 0 -> Opcode.ILOAD_0;\n-                case 1 -> Opcode.ILOAD_1;\n-                case 2 -> Opcode.ILOAD_2;\n-                case 3 -> Opcode.ILOAD_3;\n-                default -> (slot < 256) ? Opcode.ILOAD : Opcode.ILOAD_W;\n-            };\n-            case LongType -> switch (slot) {\n-                case 0 -> Opcode.LLOAD_0;\n-                case 1 -> Opcode.LLOAD_1;\n-                case 2 -> Opcode.LLOAD_2;\n-                case 3 -> Opcode.LLOAD_3;\n-                default -> (slot < 256) ? Opcode.LLOAD : Opcode.LLOAD_W;\n-            };\n-            case DoubleType -> switch (slot) {\n-                case 0 -> Opcode.DLOAD_0;\n-                case 1 -> Opcode.DLOAD_1;\n-                case 2 -> Opcode.DLOAD_2;\n-                case 3 -> Opcode.DLOAD_3;\n-                default -> (slot < 256) ? Opcode.DLOAD : Opcode.DLOAD_W;\n-            };\n-            case FloatType -> switch (slot) {\n-                case 0 -> Opcode.FLOAD_0;\n-                case 1 -> Opcode.FLOAD_1;\n-                case 2 -> Opcode.FLOAD_2;\n-                case 3 -> Opcode.FLOAD_3;\n-                default -> (slot < 256) ? Opcode.FLOAD : Opcode.FLOAD_W;\n-            };\n-            case ReferenceType -> switch (slot) {\n-                case 0 -> Opcode.ALOAD_0;\n-                case 1 -> Opcode.ALOAD_1;\n-                case 2 -> Opcode.ALOAD_2;\n-                case 3 -> Opcode.ALOAD_3;\n-                default -> (slot < 256) ? Opcode.ALOAD : Opcode.ALOAD_W;\n-            };\n-            case VoidType -> throw new IllegalArgumentException(\"void\");\n+            case INT, SHORT, BYTE, CHAR, BOOLEAN\n+                           -> iload(slot);\n+            case LONG      -> lload(slot);\n+            case DOUBLE    -> dload(slot);\n+            case FLOAT     -> fload(slot);\n+            case REFERENCE -> aload(slot);\n+            case VOID      -> throw new IllegalArgumentException(\"void\");\n+        };\n+    }\n+\n+    public static Opcode aload(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.ALOAD_0;\n+            case 1 -> Opcode.ALOAD_1;\n+            case 2 -> Opcode.ALOAD_2;\n+            case 3 -> Opcode.ALOAD_3;\n+            default -> (slot < 256) ? Opcode.ALOAD : Opcode.ALOAD_W;\n+        };\n+    }\n+\n+    public static Opcode fload(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.FLOAD_0;\n+            case 1 -> Opcode.FLOAD_1;\n+            case 2 -> Opcode.FLOAD_2;\n+            case 3 -> Opcode.FLOAD_3;\n+            default -> (slot < 256) ? Opcode.FLOAD : Opcode.FLOAD_W;\n+        };\n+    }\n+\n+    public static Opcode dload(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.DLOAD_0;\n+            case 1 -> Opcode.DLOAD_1;\n+            case 2 -> Opcode.DLOAD_2;\n+            case 3 -> Opcode.DLOAD_3;\n+            default -> (slot < 256) ? Opcode.DLOAD : Opcode.DLOAD_W;\n+        };\n+    }\n+\n+    public static Opcode lload(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.LLOAD_0;\n+            case 1 -> Opcode.LLOAD_1;\n+            case 2 -> Opcode.LLOAD_2;\n+            case 3 -> Opcode.LLOAD_3;\n+            default -> (slot < 256) ? Opcode.LLOAD : Opcode.LLOAD_W;\n+        };\n+    }\n+\n+    public static Opcode iload(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.ILOAD_0;\n+            case 1 -> Opcode.ILOAD_1;\n+            case 2 -> Opcode.ILOAD_2;\n+            case 3 -> Opcode.ILOAD_3;\n+            default -> (slot < 256) ? Opcode.ILOAD : Opcode.ILOAD_W;\n@@ -96,36 +127,57 @@\n-            case IntType, ShortType, ByteType, CharType, BooleanType -> switch (slot) {\n-                case 0 -> Opcode.ISTORE_0;\n-                case 1 -> Opcode.ISTORE_1;\n-                case 2 -> Opcode.ISTORE_2;\n-                case 3 -> Opcode.ISTORE_3;\n-                default -> (slot < 256) ? Opcode.ISTORE : Opcode.ISTORE_W;\n-            };\n-            case LongType -> switch (slot) {\n-                case 0 -> Opcode.LSTORE_0;\n-                case 1 -> Opcode.LSTORE_1;\n-                case 2 -> Opcode.LSTORE_2;\n-                case 3 -> Opcode.LSTORE_3;\n-                default -> (slot < 256) ? Opcode.LSTORE : Opcode.LSTORE_W;\n-            };\n-            case DoubleType -> switch (slot) {\n-                case 0 -> Opcode.DSTORE_0;\n-                case 1 -> Opcode.DSTORE_1;\n-                case 2 -> Opcode.DSTORE_2;\n-                case 3 -> Opcode.DSTORE_3;\n-                default -> (slot < 256) ? Opcode.DSTORE : Opcode.DSTORE_W;\n-            };\n-            case FloatType -> switch (slot) {\n-                case 0 -> Opcode.FSTORE_0;\n-                case 1 -> Opcode.FSTORE_1;\n-                case 2 -> Opcode.FSTORE_2;\n-                case 3 -> Opcode.FSTORE_3;\n-                default -> (slot < 256) ? Opcode.FSTORE : Opcode.FSTORE_W;\n-            };\n-            case ReferenceType -> switch (slot) {\n-                case 0 -> Opcode.ASTORE_0;\n-                case 1 -> Opcode.ASTORE_1;\n-                case 2 -> Opcode.ASTORE_2;\n-                case 3 -> Opcode.ASTORE_3;\n-                default -> (slot < 256) ? Opcode.ASTORE : Opcode.ASTORE_W;\n-            };\n-            case VoidType -> throw new IllegalArgumentException(\"void\");\n+            case INT, SHORT, BYTE, CHAR, BOOLEAN\n+                           -> istore(slot);\n+            case LONG      -> lstore(slot);\n+            case DOUBLE    -> dstore(slot);\n+            case FLOAT     -> fstore(slot);\n+            case REFERENCE -> astore(slot);\n+            case VOID      -> throw new IllegalArgumentException(\"void\");\n+        };\n+    }\n+\n+    public static Opcode astore(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.ASTORE_0;\n+            case 1 -> Opcode.ASTORE_1;\n+            case 2 -> Opcode.ASTORE_2;\n+            case 3 -> Opcode.ASTORE_3;\n+            default -> (slot < 256) ? Opcode.ASTORE : Opcode.ASTORE_W;\n+        };\n+    }\n+\n+    public static Opcode fstore(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.FSTORE_0;\n+            case 1 -> Opcode.FSTORE_1;\n+            case 2 -> Opcode.FSTORE_2;\n+            case 3 -> Opcode.FSTORE_3;\n+            default -> (slot < 256) ? Opcode.FSTORE : Opcode.FSTORE_W;\n+        };\n+    }\n+\n+    public static Opcode dstore(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.DSTORE_0;\n+            case 1 -> Opcode.DSTORE_1;\n+            case 2 -> Opcode.DSTORE_2;\n+            case 3 -> Opcode.DSTORE_3;\n+            default -> (slot < 256) ? Opcode.DSTORE : Opcode.DSTORE_W;\n+        };\n+    }\n+\n+    public static Opcode lstore(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.LSTORE_0;\n+            case 1 -> Opcode.LSTORE_1;\n+            case 2 -> Opcode.LSTORE_2;\n+            case 3 -> Opcode.LSTORE_3;\n+            default -> (slot < 256) ? Opcode.LSTORE : Opcode.LSTORE_W;\n+        };\n+    }\n+\n+    public static Opcode istore(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.ISTORE_0;\n+            case 1 -> Opcode.ISTORE_1;\n+            case 2 -> Opcode.ISTORE_2;\n+            case 3 -> Opcode.ISTORE_3;\n+            default -> (slot < 256) ? Opcode.ISTORE : Opcode.ISTORE_W;\n@@ -137,6 +189,6 @@\n-            case ByteType, ShortType, IntType, CharType, BooleanType -> Opcode.IRETURN;\n-            case FloatType -> Opcode.FRETURN;\n-            case LongType -> Opcode.LRETURN;\n-            case DoubleType -> Opcode.DRETURN;\n-            case ReferenceType -> Opcode.ARETURN;\n-            case VoidType -> Opcode.RETURN;\n+            case BYTE, SHORT, INT, CHAR, BOOLEAN -> Opcode.IRETURN;\n+            case FLOAT -> Opcode.FRETURN;\n+            case LONG -> Opcode.LRETURN;\n+            case DOUBLE -> Opcode.DRETURN;\n+            case REFERENCE -> Opcode.ARETURN;\n+            case VOID -> Opcode.RETURN;\n@@ -148,9 +200,9 @@\n-            case ByteType, BooleanType -> Opcode.BALOAD;\n-            case ShortType -> Opcode.SALOAD;\n-            case IntType -> Opcode.IALOAD;\n-            case FloatType -> Opcode.FALOAD;\n-            case LongType -> Opcode.LALOAD;\n-            case DoubleType -> Opcode.DALOAD;\n-            case ReferenceType -> Opcode.AALOAD;\n-            case CharType -> Opcode.CALOAD;\n-            case VoidType -> throw new IllegalArgumentException(\"void not an allowable array type\");\n+            case BYTE, BOOLEAN -> Opcode.BALOAD;\n+            case SHORT -> Opcode.SALOAD;\n+            case INT -> Opcode.IALOAD;\n+            case FLOAT -> Opcode.FALOAD;\n+            case LONG -> Opcode.LALOAD;\n+            case DOUBLE -> Opcode.DALOAD;\n+            case REFERENCE -> Opcode.AALOAD;\n+            case CHAR -> Opcode.CALOAD;\n+            case VOID -> throw new IllegalArgumentException(\"void not an allowable array type\");\n@@ -162,9 +214,9 @@\n-            case ByteType, BooleanType -> Opcode.BASTORE;\n-            case ShortType -> Opcode.SASTORE;\n-            case IntType -> Opcode.IASTORE;\n-            case FloatType -> Opcode.FASTORE;\n-            case LongType -> Opcode.LASTORE;\n-            case DoubleType -> Opcode.DASTORE;\n-            case ReferenceType -> Opcode.AASTORE;\n-            case CharType -> Opcode.CASTORE;\n-            case VoidType -> throw new IllegalArgumentException(\"void not an allowable array type\");\n+            case BYTE, BOOLEAN -> Opcode.BASTORE;\n+            case SHORT -> Opcode.SASTORE;\n+            case INT -> Opcode.IASTORE;\n+            case FLOAT -> Opcode.FASTORE;\n+            case LONG -> Opcode.LASTORE;\n+            case DOUBLE -> Opcode.DASTORE;\n+            case REFERENCE -> Opcode.AASTORE;\n+            case CHAR -> Opcode.CASTORE;\n+            case VOID -> throw new IllegalArgumentException(\"void not an allowable array type\");\n@@ -192,1 +244,1 @@\n-            default -> throw new IllegalArgumentException(\"Unknown branch instruction: \" + op);\n+            default -> throw Util.badOpcodeKindException(op, Opcode.Kind.BRANCH);\n@@ -198,1 +250,1 @@\n-            case IntType ->\n+            case INT ->\n@@ -200,7 +252,7 @@\n-                        case LongType -> Opcode.I2L;\n-                        case FloatType -> Opcode.I2F;\n-                        case DoubleType -> Opcode.I2D;\n-                        case ByteType -> Opcode.I2B;\n-                        case CharType -> Opcode.I2C;\n-                        case ShortType -> Opcode.I2S;\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        case LONG -> Opcode.I2L;\n+                        case FLOAT -> Opcode.I2F;\n+                        case DOUBLE -> Opcode.I2D;\n+                        case BYTE -> Opcode.I2B;\n+                        case CHAR -> Opcode.I2C;\n+                        case SHORT -> Opcode.I2S;\n+                        default -> throw cannotConvertException(from, to);\n@@ -208,1 +260,1 @@\n-            case LongType ->\n+            case LONG ->\n@@ -210,4 +262,4 @@\n-                        case FloatType -> Opcode.L2F;\n-                        case DoubleType -> Opcode.L2D;\n-                        case IntType -> Opcode.L2I;\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        case FLOAT -> Opcode.L2F;\n+                        case DOUBLE -> Opcode.L2D;\n+                        case INT -> Opcode.L2I;\n+                        default -> throw cannotConvertException(from, to);\n@@ -215,1 +267,1 @@\n-            case DoubleType ->\n+            case DOUBLE ->\n@@ -217,4 +269,4 @@\n-                        case FloatType -> Opcode.D2F;\n-                        case LongType -> Opcode.D2L;\n-                        case IntType -> Opcode.D2I;\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        case FLOAT -> Opcode.D2F;\n+                        case LONG -> Opcode.D2L;\n+                        case INT -> Opcode.D2I;\n+                        default -> throw cannotConvertException(from, to);\n@@ -222,1 +274,1 @@\n-            case FloatType ->\n+            case FLOAT ->\n@@ -224,4 +276,4 @@\n-                        case LongType -> Opcode.F2L;\n-                        case DoubleType -> Opcode.F2D;\n-                        case IntType -> Opcode.F2I;\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        case LONG -> Opcode.F2L;\n+                        case DOUBLE -> Opcode.F2D;\n+                        case INT -> Opcode.F2I;\n+                        default -> throw cannotConvertException(from, to);\n@@ -229,1 +281,1 @@\n-            default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+            default -> throw cannotConvertException(from, to);\n@@ -233,9 +285,8 @@\n-    static void validateSIPUSH(ConstantDesc d) {\n-        if (d instanceof Integer iVal && Short.MIN_VALUE <= iVal && iVal <= Short.MAX_VALUE)\n-            return;\n-\n-        if (d instanceof Long lVal && Short.MIN_VALUE <= lVal && Short.MAX_VALUE <= lVal)\n-            return;\n-\n-        throw new IllegalArgumentException(\"SIPUSH: value must be within: Short.MIN_VALUE <= value <= Short.MAX_VALUE\"\n-                                           + \", found: \" + d);\n+    public static TypeKind convertFromType(Opcode opcode) {\n+        return switch (opcode) {\n+            case I2D, I2F, I2L, I2B, I2C, I2S -> TypeKind.INT;\n+            case L2D, L2F, L2I -> TypeKind.LONG;\n+            case F2D, F2I, F2L -> TypeKind.FLOAT;\n+            case D2F, D2I, D2L -> TypeKind.DOUBLE;\n+            default -> throw Util.badOpcodeKindException(opcode, Opcode.Kind.CONVERT);\n+        };\n@@ -244,3 +295,12 @@\n-    static void validateBIPUSH(ConstantDesc d) {\n-        if (d instanceof Integer iVal && Byte.MIN_VALUE <= iVal && iVal <= Byte.MAX_VALUE)\n-            return;\n+    public static TypeKind convertToType(Opcode opcode) {\n+        return switch (opcode) {\n+            case I2B -> TypeKind.BYTE;\n+            case I2C -> TypeKind.CHAR;\n+            case I2S -> TypeKind.SHORT;\n+            case L2I, F2I, D2I -> TypeKind.INT;\n+            case I2L, F2L, D2L -> TypeKind.LONG;\n+            case I2F, L2F, D2F -> TypeKind.FLOAT;\n+            case I2D, L2D, F2D -> TypeKind.DOUBLE;\n+            default -> throw Util.badOpcodeKindException(opcode, Opcode.Kind.CONVERT);\n+        };\n+    }\n@@ -248,2 +308,6 @@\n-        if (d instanceof Long lVal && Byte.MIN_VALUE <= lVal && Byte.MAX_VALUE <= lVal)\n-            return;\n+    public static void validateSipush(int value) {\n+        if (value != (short) value)\n+            throw new IllegalArgumentException(\n+                    \"SIPUSH: value must be within: Short.MIN_VALUE <= value <= Short.MAX_VALUE, found: \"\n+                            .concat(Long.toString(value)));\n+    }\n@@ -251,2 +315,5 @@\n-        throw new IllegalArgumentException(\"BIPUSH: value must be within: Byte.MIN_VALUE <= value <= Byte.MAX_VALUE\"\n-                                           + \", found: \" + d);\n+    public static void validateBipush(int value) {\n+        if (value != (byte) value)\n+            throw new IllegalArgumentException(\n+                    \"BIPUSH: value must be within: Byte.MIN_VALUE <= value <= Byte.MAX_VALUE, found: \"\n+                            .concat(Long.toString(value)));\n@@ -278,9 +345,1 @@\n-\n-        var bootstrapDesc = desc.bootstrapMethod();\n-        ClassEntry bsOwner = constantPool.classEntry(bootstrapDesc.owner());\n-        NameAndTypeEntry bsNameAndType = constantPool.nameAndTypeEntry(bootstrapDesc.methodName(),\n-                                                               bootstrapDesc.invocationType());\n-        int bsRefKind = bootstrapDesc.refKind();\n-\n-        MemberRefEntry memberRefEntry = toBootstrapMemberRef(constantPool, bsRefKind, bsOwner, bsNameAndType, bootstrapDesc.isOwnerInterface());\n-        MethodHandleEntry methodHandleEntry = constantPool.methodHandleEntry(bsRefKind, memberRefEntry);\n+        MethodHandleEntry methodHandleEntry = handleDescToHandleInfo(constantPool, desc.bootstrapMethod());\n@@ -293,24 +352,4 @@\n-    public static void validateValue(Opcode opcode, ConstantDesc v) {\n-        switch (opcode) {\n-            case ACONST_NULL -> {\n-                if (v != null && v != ConstantDescs.NULL)\n-                    throw new IllegalArgumentException(\"value must be null or ConstantDescs.NULL with opcode ACONST_NULL\");\n-            }\n-            case SIPUSH ->\n-                    validateSIPUSH(v);\n-            case BIPUSH ->\n-                    validateBIPUSH(v);\n-            case LDC, LDC_W, LDC2_W -> {\n-                if (v == null)\n-                    throw new IllegalArgumentException(\"`null` must use ACONST_NULL\");\n-            }\n-            default -> {\n-                var exp = opcode.constantValue();\n-                if (exp == null)\n-                    throw new IllegalArgumentException(\"Can not use Opcode: \" + opcode + \" with constant()\");\n-                if (v == null || !(v.equals(exp) || (exp instanceof Long l && v.equals(l.intValue())))) {\n-                    var t = (exp instanceof Long) ? \"L\" : (exp instanceof Float) ? \"f\" : (exp instanceof Double) ? \"d\" : \"\";\n-                    throw new IllegalArgumentException(\"value must be \" + exp + t + \" with opcode \" + opcode.name());\n-                }\n-            }\n-        }\n+    public static Opcode ldcOpcode(LoadableConstantEntry entry) {\n+        return entry.typeKind().slotSize() == 2 ? Opcode.LDC2_W\n+                : entry.index() > 0xff ? Opcode.LDC_W\n+                : Opcode.LDC;\n@@ -350,0 +389,141 @@\n+\n+    public static ConstantDesc intrinsicConstantValue(Opcode opcode) {\n+        return switch (opcode) {\n+            case ACONST_NULL -> ConstantDescs.NULL;\n+            case ICONST_M1 -> -1;\n+            case ICONST_0 -> 0;\n+            case ICONST_1 -> 1;\n+            case ICONST_2 -> 2;\n+            case ICONST_3 -> 3;\n+            case ICONST_4 -> 4;\n+            case ICONST_5 -> 5;\n+            case LCONST_0 -> 0L;\n+            case LCONST_1 -> 1L;\n+            case FCONST_0 -> 0F;\n+            case FCONST_1 -> 1F;\n+            case FCONST_2 -> 2F;\n+            case DCONST_0 -> 0D;\n+            case DCONST_1 -> 1D;\n+            default -> throw Util.badOpcodeKindException(opcode, Opcode.Kind.CONSTANT);\n+        };\n+    }\n+\n+    public static TypeKind intrinsicConstantType(Opcode opcode) {\n+        return switch (opcode) {\n+            case ACONST_NULL -> TypeKind.REFERENCE;\n+            case ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5 -> TypeKind.INT;\n+            case LCONST_0, LCONST_1 -> TypeKind.LONG;\n+            case FCONST_0, FCONST_1, FCONST_2 -> TypeKind.FLOAT;\n+            case DCONST_0, DCONST_1 -> TypeKind.DOUBLE;\n+            default -> throw Util.badOpcodeKindException(opcode, Opcode.Kind.CONSTANT);\n+        };\n+    }\n+\n+    public static boolean isUnconditionalBranch(Opcode opcode) {\n+        return switch (opcode) {\n+            case GOTO, ATHROW, GOTO_W, LOOKUPSWITCH, TABLESWITCH -> true;\n+            default -> opcode.kind() == Opcode.Kind.RETURN;\n+        };\n+    }\n+\n+    \/\/ Must check Opcode.sizeIfFixed() == 1 before call!\n+    public static int intrinsicLoadSlot(Opcode loadOpcode) {\n+        return switch (loadOpcode) {\n+            case ILOAD_0, LLOAD_0, FLOAD_0, DLOAD_0, ALOAD_0 -> 0;\n+            case ILOAD_1, LLOAD_1, FLOAD_1, DLOAD_1, ALOAD_1 -> 1;\n+            case ILOAD_2, LLOAD_2, FLOAD_2, DLOAD_2, ALOAD_2 -> 2;\n+            case ILOAD_3, LLOAD_3, FLOAD_3, DLOAD_3, ALOAD_3 -> 3;\n+            default -> throw Util.badOpcodeKindException(loadOpcode, Opcode.Kind.LOAD);\n+        };\n+    }\n+\n+    \/\/ Must check Opcode.sizeIfFixed() == 1 before call!\n+    public static int intrinsicStoreSlot(Opcode storeOpcode) {\n+        return switch (storeOpcode) {\n+            case ISTORE_0, LSTORE_0, FSTORE_0, DSTORE_0, ASTORE_0 -> 0;\n+            case ISTORE_1, LSTORE_1, FSTORE_1, DSTORE_1, ASTORE_1 -> 1;\n+            case ISTORE_2, LSTORE_2, FSTORE_2, DSTORE_2, ASTORE_2 -> 2;\n+            case ISTORE_3, LSTORE_3, FSTORE_3, DSTORE_3, ASTORE_3 -> 3;\n+            default -> throw Util.badOpcodeKindException(storeOpcode, Opcode.Kind.STORE);\n+        };\n+    }\n+\n+    public static TypeKind loadType(Opcode loadOpcode) {\n+        \/\/ Note: 0xFF handles wide pseudo-opcodes\n+        return switch (loadOpcode.bytecode() & 0xFF) {\n+            case ILOAD, ILOAD_0, ILOAD_1, ILOAD_2, ILOAD_3 -> TypeKind.INT;\n+            case LLOAD, LLOAD_0, LLOAD_1, LLOAD_2, LLOAD_3 -> TypeKind.LONG;\n+            case FLOAD, FLOAD_0, FLOAD_1, FLOAD_2, FLOAD_3 -> TypeKind.FLOAT;\n+            case DLOAD, DLOAD_0, DLOAD_1, DLOAD_2, DLOAD_3 -> TypeKind.DOUBLE;\n+            case ALOAD, ALOAD_0, ALOAD_1, ALOAD_2, ALOAD_3 -> TypeKind.REFERENCE;\n+            default -> throw Util.badOpcodeKindException(loadOpcode, Opcode.Kind.LOAD);\n+        };\n+    }\n+\n+    public static TypeKind storeType(Opcode storeOpcode) {\n+        \/\/ Note: 0xFF handles wide pseudo-opcodes\n+        return switch (storeOpcode.bytecode() & 0xFF) {\n+            case ISTORE, ISTORE_0, ISTORE_1, ISTORE_2, ISTORE_3 -> TypeKind.INT;\n+            case LSTORE, LSTORE_0, LSTORE_1, LSTORE_2, LSTORE_3 -> TypeKind.LONG;\n+            case FSTORE, FSTORE_0, FSTORE_1, FSTORE_2, FSTORE_3 -> TypeKind.FLOAT;\n+            case DSTORE, DSTORE_0, DSTORE_1, DSTORE_2, DSTORE_3 -> TypeKind.DOUBLE;\n+            case ASTORE, ASTORE_0, ASTORE_1, ASTORE_2, ASTORE_3 -> TypeKind.REFERENCE;\n+            default -> throw Util.badOpcodeKindException(storeOpcode, Opcode.Kind.STORE);\n+        };\n+    }\n+\n+    public static TypeKind arrayLoadType(Opcode arrayLoadOpcode) {\n+        return switch (arrayLoadOpcode) {\n+            case IALOAD -> TypeKind.INT;\n+            case LALOAD -> TypeKind.LONG;\n+            case FALOAD -> TypeKind.FLOAT;\n+            case DALOAD -> TypeKind.DOUBLE;\n+            case AALOAD -> TypeKind.REFERENCE;\n+            case BALOAD -> TypeKind.BYTE;\n+            case CALOAD -> TypeKind.CHAR;\n+            case SALOAD -> TypeKind.SHORT;\n+            default -> throw Util.badOpcodeKindException(arrayLoadOpcode, Opcode.Kind.ARRAY_LOAD);\n+        };\n+    }\n+\n+    public static TypeKind arrayStoreType(Opcode arrayStoreOpcode) {\n+        return switch (arrayStoreOpcode) {\n+            case IASTORE -> TypeKind.INT;\n+            case LASTORE -> TypeKind.LONG;\n+            case FASTORE -> TypeKind.FLOAT;\n+            case DASTORE -> TypeKind.DOUBLE;\n+            case AASTORE -> TypeKind.REFERENCE;\n+            case BASTORE -> TypeKind.BYTE;\n+            case CASTORE -> TypeKind.CHAR;\n+            case SASTORE -> TypeKind.SHORT;\n+            default -> throw Util.badOpcodeKindException(arrayStoreOpcode, Opcode.Kind.ARRAY_STORE);\n+        };\n+    }\n+\n+    public static TypeKind returnType(Opcode returnOpcode) {\n+        return switch (returnOpcode) {\n+            case IRETURN -> TypeKind.INT;\n+            case LRETURN -> TypeKind.LONG;\n+            case FRETURN -> TypeKind.FLOAT;\n+            case DRETURN -> TypeKind.DOUBLE;\n+            case ARETURN -> TypeKind.REFERENCE;\n+            case RETURN -> TypeKind.VOID;\n+            default -> throw Util.badOpcodeKindException(returnOpcode, Opcode.Kind.RETURN);\n+        };\n+    }\n+\n+    public static TypeKind operatorOperandType(Opcode operationOpcode) {\n+        return switch (operationOpcode) {\n+            case IADD, ISUB, IMUL, IDIV, IREM, INEG,\n+                 ISHL, ISHR, IUSHR, IAND, IOR, IXOR,\n+                 ARRAYLENGTH -> TypeKind.INT;\n+            case LADD, LSUB, LMUL, LDIV, LREM, LNEG,\n+                 LSHL, LSHR, LUSHR, LAND, LOR, LXOR,\n+                 LCMP -> TypeKind.LONG;\n+            case FADD, FSUB, FMUL, FDIV, FREM, FNEG,\n+                 FCMPL, FCMPG -> TypeKind.FLOAT;\n+            case DADD, DSUB, DMUL, DDIV, DREM, DNEG,\n+                 DCMPL, DCMPG -> TypeKind.DOUBLE;\n+            default -> throw Util.badOpcodeKindException(operationOpcode, Opcode.Kind.OPERATOR);\n+        };\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":351,"deletions":171,"binary":false,"changes":522,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -81,0 +82,9 @@\n+    @Override\n+    public ClassBuilder withMethod(String name, MethodTypeDesc descriptor, int flags, Consumer<? super MethodBuilder> handler) {\n+        var mb = new BufferedMethodBuilder(terminal.constantPool, terminal.context,\n+                constantPool().utf8Entry(name), constantPool().utf8Entry(descriptor), flags, null);\n+        mb.mDesc = descriptor;\n+        consumer.accept(mb.run(handler).toModel());\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedClassBuilder.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.lang.classfile.ClassFile.*;\n@@ -44,10 +43,34 @@\n-public record ClassFileImpl(StackMapsOption stackMapsOption,\n-                            DebugElementsOption debugElementsOption,\n-                            LineNumbersOption lineNumbersOption,\n-                            AttributesProcessingOption attributesProcessingOption,\n-                            ConstantPoolSharingOption constantPoolSharingOption,\n-                            ShortJumpsOption shortJumpsOption,\n-                            DeadCodeOption deadCodeOption,\n-                            DeadLabelsOption deadLabelsOption,\n-                            ClassHierarchyResolverOption classHierarchyResolverOption,\n-                            AttributeMapperOption attributeMapperOption) implements ClassFile {\n+public final class ClassFileImpl implements ClassFile {\n+\n+    private Option stackMapsOption;\n+    private Option debugElementsOption;\n+    private Option lineNumbersOption;\n+    private Option attributesProcessingOption;\n+    private Option constantPoolSharingOption;\n+    private Option shortJumpsOption;\n+    private Option deadCodeOption;\n+    private Option deadLabelsOption;\n+    private Option classHierarchyResolverOption;\n+    private Option attributeMapperOption;\n+\n+    private ClassFileImpl(Option stackMapsOption,\n+                          Option debugElementsOption,\n+                          Option lineNumbersOption,\n+                          Option attributesProcessingOption,\n+                          Option constantPoolSharingOption,\n+                          Option shortJumpsOption,\n+                          Option deadCodeOption,\n+                          Option deadLabelsOption,\n+                          Option classHierarchyResolverOption,\n+                          Option attributeMapperOption) {\n+        this.stackMapsOption              = stackMapsOption;\n+        this.debugElementsOption          = debugElementsOption;\n+        this.lineNumbersOption            = lineNumbersOption;\n+        this.attributesProcessingOption   = attributesProcessingOption;\n+        this.constantPoolSharingOption    = constantPoolSharingOption;\n+        this.shortJumpsOption             = shortJumpsOption;\n+        this.deadCodeOption               = deadCodeOption;\n+        this.deadLabelsOption             = deadLabelsOption;\n+        this.classHierarchyResolverOption = classHierarchyResolverOption;\n+        this.attributeMapperOption        = attributeMapperOption;\n+    }\n@@ -56,15 +79,11 @@\n-            StackMapsOption.STACK_MAPS_WHEN_REQUIRED,\n-            DebugElementsOption.PASS_DEBUG,\n-            LineNumbersOption.PASS_LINE_NUMBERS,\n-            AttributesProcessingOption.PASS_ALL_ATTRIBUTES,\n-            ConstantPoolSharingOption.SHARED_POOL,\n-            ShortJumpsOption.FIX_SHORT_JUMPS,\n-            DeadCodeOption.PATCH_DEAD_CODE,\n-            DeadLabelsOption.FAIL_ON_DEAD_LABELS,\n-            new ClassHierarchyResolverOptionImpl(ClassHierarchyResolver.defaultResolver()),\n-            new AttributeMapperOptionImpl(new Function<>() {\n-                @Override\n-                public AttributeMapper<?> apply(Utf8Entry k) {\n-                    return null;\n-                }\n-            }));\n+            null, \/\/ StackMapsOption.STACK_MAPS_WHEN_REQUIRED\n+            null, \/\/ DebugElementsOption.PASS_DEBUG,\n+            null, \/\/ LineNumbersOption.PASS_LINE_NUMBERS,\n+            null, \/\/ AttributesProcessingOption.PASS_ALL_ATTRIBUTES,\n+            null, \/\/ ConstantPoolSharingOption.SHARED_POOL,\n+            null, \/\/ ShortJumpsOption.FIX_SHORT_JUMPS,\n+            null, \/\/ DeadCodeOption.PATCH_DEAD_CODE,\n+            null, \/\/ DeadLabelsOption.FAIL_ON_DEAD_LABELS,\n+            null, \/\/ new ClassHierarchyResolverOptionImpl(ClassHierarchyResolver.defaultResolver()),\n+            null  \/\/ _ -> null\n+        );\n@@ -86,11 +105,22 @@\n-            switch (o) {\n-                case StackMapsOption oo -> smo = oo;\n-                case DebugElementsOption oo -> deo = oo;\n-                case LineNumbersOption oo -> lno = oo;\n-                case AttributesProcessingOption oo -> apo = oo;\n-                case ConstantPoolSharingOption oo -> cpso = oo;\n-                case ShortJumpsOption oo -> sjo = oo;\n-                case DeadCodeOption oo -> dco = oo;\n-                case DeadLabelsOption oo -> dlo = oo;\n-                case ClassHierarchyResolverOption oo -> chro = oo;\n-                case AttributeMapperOption oo -> amo = oo;\n+            if (o instanceof StackMapsOption oo) {\n+                smo = oo;\n+            } else if (o instanceof ClassHierarchyResolverOption oo) {\n+                chro = oo;\n+            } else if (o instanceof DebugElementsOption oo) {\n+                deo = oo;\n+            } else if (o instanceof LineNumbersOption oo) {\n+                lno = oo;\n+            } else if (o instanceof AttributesProcessingOption oo) {\n+                apo = oo;\n+            } else if (o instanceof ConstantPoolSharingOption oo) {\n+                cpso = oo;\n+            } else if (o instanceof ShortJumpsOption oo) {\n+                sjo = oo;\n+            } else if (o instanceof DeadCodeOption oo) {\n+                dco = oo;\n+            } else if (o instanceof DeadLabelsOption oo) {\n+                dlo = oo;\n+            } else if (o instanceof AttributeMapperOption oo) {\n+                amo = oo;\n+            } else { \/\/ null or unknown Option type\n+                throw new IllegalArgumentException(\"Invalid option: \" + o);\n@@ -119,3 +149,2 @@\n-        ConstantPoolBuilder constantPool = constantPoolSharingOption() == ConstantPoolSharingOption.SHARED_POOL\n-                                                                     ? ConstantPoolBuilder.of(model)\n-                                                                     : ConstantPoolBuilder.of();\n+        ConstantPoolBuilder constantPool = sharedConstantPool() ? ConstantPoolBuilder.of(model)\n+                                                                : ConstantPoolBuilder.of();\n@@ -133,0 +162,4 @@\n+    public boolean sharedConstantPool() {\n+        return constantPoolSharingOption == null || constantPoolSharingOption == ConstantPoolSharingOption.SHARED_POOL;\n+    }\n+\n@@ -136,1 +169,1 @@\n-            return VerifierImpl.verify(model, classHierarchyResolverOption().classHierarchyResolver(), null);\n+            return VerifierImpl.verify(model, classHierarchyResolver(), null);\n@@ -151,0 +184,52 @@\n+    public Function<Utf8Entry, AttributeMapper<?>> attributeMapper() {\n+        if (attributeMapperOption == null) {\n+            return _ -> null;\n+        } else {\n+            return ((AttributeMapperOption)attributeMapperOption).attributeMapper();\n+        }\n+    }\n+\n+    public ClassHierarchyResolver classHierarchyResolver() {\n+        if (classHierarchyResolverOption == null) {\n+            return ClassHierarchyImpl.DEFAULT_RESOLVER;\n+        } else {\n+            return ((ClassHierarchyResolverOption)classHierarchyResolverOption).classHierarchyResolver();\n+        }\n+    }\n+\n+    public boolean dropDeadLabels() {\n+        return (deadLabelsOption != null && deadLabelsOption == DeadLabelsOption.DROP_DEAD_LABELS);\n+    }\n+\n+    public boolean passDebugElements() {\n+        return (debugElementsOption == null || debugElementsOption == DebugElementsOption.PASS_DEBUG);\n+    }\n+\n+    public boolean passLineNumbers() {\n+        return (lineNumbersOption == null || lineNumbersOption == LineNumbersOption.PASS_LINE_NUMBERS);\n+    }\n+\n+    public AttributesProcessingOption attributesProcessingOption() {\n+        return (attributesProcessingOption == null) ? AttributesProcessingOption.PASS_ALL_ATTRIBUTES : (AttributesProcessingOption)attributesProcessingOption;\n+    }\n+\n+    public boolean fixShortJumps() {\n+        return (shortJumpsOption == null || shortJumpsOption == ShortJumpsOption.FIX_SHORT_JUMPS);\n+    }\n+\n+    public boolean stackMapsWhenRequired() {\n+        return (stackMapsOption == null || stackMapsOption == StackMapsOption.STACK_MAPS_WHEN_REQUIRED);\n+    }\n+\n+    public boolean generateStackMaps() {\n+        return (stackMapsOption == StackMapsOption.GENERATE_STACK_MAPS);\n+    }\n+\n+    public boolean dropStackMaps() {\n+        return (stackMapsOption == StackMapsOption.DROP_STACK_MAPS);\n+    }\n+\n+    public boolean patchDeadCode() {\n+        return (deadCodeOption == null || deadCodeOption == DeadCodeOption.PATCH_DEAD_CODE);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileImpl.java","additions":127,"deletions":42,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -854,1 +854,1 @@\n-                                \"descriptor\", newa.typeKind().typeName()));\n+                                \"descriptor\", newa.typeKind().upperBound().displayName()));\n@@ -1041,1 +1041,1 @@\n-                        .with(leaf(\"annotation class\", a.className().stringValue()),\n+                        .with(leaf(\"annotation class\", a.annotation().className().stringValue()),\n@@ -1043,1 +1043,1 @@\n-                        .with(elementValuePairsToTree(a.elements()))));\n+                        .with(elementValuePairsToTree(a.annotation().elements()))));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-        this.attributeMapper = this.context.attributeMapperOption().attributeMapper();\n+        this.attributeMapper = this.context.attributeMapper();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -261,2 +261,1 @@\n-                    cob.loadConstant(ldc.opcode(),\n-                            mapConstantValue(ldc.constantValue()));\n+                    cob.ldc(mapConstantValue(ldc.constantValue()));\n@@ -404,3 +403,1 @@\n-                a.targetPath(), map(a.classSymbol()),\n-                a.elements().stream().map(el -> AnnotationElement.of(el.name(),\n-                        mapAnnotationValue(el.value()))).toList())).toList();\n+                a.targetPath(), mapAnnotation(a.annotation()))).toList();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-                    case LOAD -> LoadInstruction.of(o, o.slot());\n+                    case LOAD -> LoadInstruction.of(o, BytecodeHelpers.intrinsicLoadSlot(o));\n@@ -64,1 +64,1 @@\n-                    case STORE -> StoreInstruction.of(o, o.slot());\n+                    case STORE -> StoreInstruction.of(o, BytecodeHelpers.intrinsicStoreSlot(o));\n@@ -125,1 +125,1 @@\n-            if (classReader.context().lineNumbersOption() == ClassFile.LineNumbersOption.PASS_LINE_NUMBERS)\n+            if (classReader.context().passLineNumbers())\n@@ -150,6 +150,1 @@\n-                                    new Consumer<CodeBuilder>() {\n-                                        @Override\n-                                        public void accept(CodeBuilder cb) {\n-                                            forEach(cb);\n-                                        }\n-                                    },\n+                                    Util.writingAll(this),\n@@ -175,1 +170,1 @@\n-        if (classReader.context().debugElementsOption() == ClassFile.DebugElementsOption.PASS_DEBUG)\n+        if (classReader.context().passDebugElements())\n@@ -266,0 +261,8 @@\n+                        case LookupSwitchInstruction ls -> {\n+                            ls.defaultTarget();\n+                            ls.cases();\n+                        }\n+                        case TableSwitchInstruction ts -> {\n+                            ts.defaultTarget();\n+                            ts.cases();\n+                        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-                        shift(cob, ii.slot(), TypeKind.IntType),\n+                        shift(cob, ii.slot(), TypeKind.INT),\n@@ -76,1 +76,1 @@\n-                                        : TypeKind.ReferenceType),\n+                                        : TypeKind.REFERENCE),\n@@ -86,1 +86,1 @@\n-        if (tk == TypeKind.VoidType)  throw new IllegalArgumentException(\"Illegal local void type\");\n+        if (tk == TypeKind.VOID)  throw new IllegalArgumentException(\"Illegal local void type\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeLocalsShifterImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,1 +149,1 @@\n-            if (type != TypeKind.VoidType) stack.push(type);\n+            if (type != TypeKind.VOID) stack.push(type);\n@@ -231,1 +231,1 @@\n-                pop(i.dimensions());push(TypeKind.ReferenceType);\n+                pop(i.dimensions());push(TypeKind.REFERENCE);\n@@ -234,1 +234,1 @@\n-                push(TypeKind.ReferenceType);\n+                push(TypeKind.REFERENCE);\n@@ -236,1 +236,1 @@\n-                pop(1);push(TypeKind.ReferenceType);\n+                pop(1);push(TypeKind.REFERENCE);\n@@ -239,1 +239,1 @@\n-                pop(1);push(TypeKind.ReferenceType);\n+                pop(1);push(TypeKind.REFERENCE);\n@@ -332,1 +332,1 @@\n-                        pop(1);push(TypeKind.ReferenceType);\n+                        pop(1);push(TypeKind.REFERENCE);\n@@ -335,1 +335,1 @@\n-                        pop(1);push(TypeKind.IntType);\n+                        pop(1);push(TypeKind.INT);\n@@ -340,1 +340,1 @@\n-                map.put(i.handler(), new Stack(new Item(TypeKind.ReferenceType, null), 1, 1));\n+                map.put(i.handler(), new Stack(new Item(TypeKind.REFERENCE, null), 1, 1));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeStackTrackerImpl.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -29,0 +30,2 @@\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -84,0 +87,21 @@\n+    @Override\n+    public ClassBuilder withFlags(int flags) {\n+        setFlags(flags);\n+        return this;\n+    }\n+\n+    @Override\n+    public ClassBuilder withField(String name,\n+                                  ClassDesc descriptor,\n+                                  int flags) {\n+        return withField(new DirectFieldBuilder(constantPool, context,\n+                constantPool.utf8Entry(name), constantPool.utf8Entry(descriptor), flags, null));\n+    }\n+\n+    @Override\n+    public ClassBuilder withField(Utf8Entry name,\n+                                  Utf8Entry descriptor,\n+                                  int flags) {\n+        return withField(new DirectFieldBuilder(constantPool, context, name, descriptor, flags, null));\n+    }\n+\n@@ -88,1 +112,1 @@\n-        return withField(new DirectFieldBuilder(constantPool, context, name, descriptor, null)\n+        return withField(new DirectFieldBuilder(constantPool, context, name, descriptor, 0, null)\n@@ -95,1 +119,1 @@\n-                                                            field.fieldType(), field);\n+                                                            field.fieldType(), 0, field);\n@@ -109,0 +133,7 @@\n+    @Override\n+    public ClassBuilder withMethod(String name, MethodTypeDesc descriptor, int flags, Consumer<? super MethodBuilder> handler) {\n+        var method = new DirectMethodBuilder(constantPool, context, constantPool.utf8Entry(name), constantPool.utf8Entry(descriptor), flags, null);\n+        method.mDesc = descriptor;\n+        return withMethod(method.run(handler));\n+    }\n+\n@@ -187,1 +218,1 @@\n-            tail.patchInt(attributesOffset, 2, attributes.size() + 1);\n+            tail.patchU2(attributesOffset, attributes.size() + 1);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -27,9 +28,0 @@\n-import java.util.ArrayList;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.IdentityHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n@@ -46,1 +38,0 @@\n-import java.lang.classfile.instruction.SwitchCase;\n@@ -58,0 +49,1 @@\n+import java.lang.classfile.constantpool.MethodRefEntry;\n@@ -62,0 +54,12 @@\n+import java.lang.classfile.instruction.SwitchCase;\n+import java.lang.constant.ConstantDesc;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static java.lang.classfile.Opcode.*;\n@@ -63,8 +67,1 @@\n-import static java.lang.classfile.Opcode.GOTO;\n-import static java.lang.classfile.Opcode.GOTO_W;\n-import static java.lang.classfile.Opcode.IINC;\n-import static java.lang.classfile.Opcode.IINC_W;\n-import static java.lang.classfile.Opcode.JSR;\n-import static java.lang.classfile.Opcode.JSR_W;\n-import static java.lang.classfile.Opcode.LDC2_W;\n-import static java.lang.classfile.Opcode.LDC_W;\n+import static jdk.internal.classfile.impl.BytecodeHelpers.*;\n@@ -109,1 +106,1 @@\n-            if (context.shortJumpsOption() == ClassFile.ShortJumpsOption.FIX_SHORT_JUMPS) {\n+            if (context.fixShortJumps()) {\n@@ -128,1 +125,1 @@\n-        this.transformBackJumps = context.shortJumpsOption() == ClassFile.ShortJumpsOption.FIX_SHORT_JUMPS;\n+        this.transformBackJumps = context.fixShortJumps();\n@@ -201,1 +198,1 @@\n-                if (context.deadLabelsOption() == ClassFile.DeadLabelsOption.DROP_DEAD_LABELS) {\n+                if (context.dropDeadLabels()) {\n@@ -215,1 +212,1 @@\n-            buf.patchInt(pos, 2, handlersSize);\n+            buf.patchU2(pos, handlersSize);\n@@ -225,1 +222,1 @@\n-        if (context.debugElementsOption() == ClassFile.DebugElementsOption.PASS_DEBUG) {\n+        if (context.passDebugElements()) {\n@@ -238,1 +235,1 @@\n-                                if (context.deadLabelsOption() == ClassFile.DeadLabelsOption.DROP_DEAD_LABELS) {\n+                                if (context.dropDeadLabels()) {\n@@ -252,1 +249,1 @@\n-                            b.patchInt(pos, 2, crSize);\n+                            b.patchU2(pos, crSize);\n@@ -267,1 +264,1 @@\n-                                if (context.deadLabelsOption() == ClassFile.DeadLabelsOption.DROP_DEAD_LABELS) {\n+                                if (context.dropDeadLabels()) {\n@@ -275,1 +272,1 @@\n-                            b.patchInt(pos, 2, lvSize);\n+                            b.patchU2(pos, lvSize);\n@@ -290,1 +287,1 @@\n-                                if (context.deadLabelsOption() == ClassFile.DeadLabelsOption.DROP_DEAD_LABELS) {\n+                                if (context.dropDeadLabels()) {\n@@ -298,1 +295,1 @@\n-                            b.patchInt(pos, 2, lvtSize);\n+                            b.patchU2(pos, lvtSize);\n@@ -363,9 +360,7 @@\n-                    switch (context.stackMapsOption()) {\n-                        case STACK_MAPS_WHEN_REQUIRED -> {\n-                            attributes.withAttribute(original.findAttribute(Attributes.stackMapTable()).orElse(null));\n-                            writeCounters(true, buf);\n-                        }\n-                        case GENERATE_STACK_MAPS ->\n-                            generateStackMaps(buf);\n-                        case DROP_STACK_MAPS ->\n-                            writeCounters(true, buf);\n+                    if (context.stackMapsWhenRequired()) {\n+                        attributes.withAttribute(original.findAttribute(Attributes.stackMapTable()).orElse(null));\n+                        writeCounters(true, buf);\n+                    } else if (context.generateStackMaps()) {\n+                        generateStackMaps(buf);\n+                    } else if (context.dropStackMaps()) {\n+                        writeCounters(true, buf);\n@@ -374,7 +369,6 @@\n-                    switch (context.stackMapsOption()) {\n-                        case STACK_MAPS_WHEN_REQUIRED ->\n-                            tryGenerateStackMaps(false, buf);\n-                        case GENERATE_STACK_MAPS ->\n-                            generateStackMaps(buf);\n-                        case DROP_STACK_MAPS ->\n-                            writeCounters(false, buf);\n+                    if (context.stackMapsWhenRequired()) {\n+                        tryGenerateStackMaps(false, buf);\n+                    } else if (context.generateStackMaps()) {\n+                        generateStackMaps(buf);\n+                    } else if (context.dropStackMaps()) {\n+                        writeCounters(false, buf);\n@@ -461,2 +455,1 @@\n-            int pc = curPc();\n-            bytecodesBufWriter.writeIntBytes(nBytes, 0);\n+            int pc = bytecodesBufWriter.skip(nBytes);\n@@ -478,2 +471,7 @@\n-                if (dl.size == 2 && (short)branchOffset != branchOffset) throw new LabelOverflowException();\n-                bytecodesBufWriter.patchInt(dl.labelPc, dl.size, branchOffset);\n+                if (dl.size == 2) {\n+                    if ((short)branchOffset != branchOffset) throw new LabelOverflowException();\n+                    bytecodesBufWriter.patchU2(dl.labelPc, branchOffset);\n+                } else {\n+                    assert dl.size == 4;\n+                    bytecodesBufWriter.patchInt(dl.labelPc, branchOffset);\n+                }\n@@ -546,1 +544,1 @@\n-        writeBytecode(Opcode.LOOKUPSWITCH);\n+        writeBytecode(LOOKUPSWITCH);\n@@ -549,1 +547,1 @@\n-            bytecodesBufWriter.writeIntBytes(pad, 0);\n+            bytecodesBufWriter.skip(pad); \/\/ padding content can be anything\n@@ -553,1 +551,1 @@\n-        cases.sort(new Comparator<SwitchCase>() {\n+        cases.sort(new Comparator<>() {\n@@ -567,1 +565,1 @@\n-        writeBytecode(Opcode.TABLESWITCH);\n+        writeBytecode(TABLESWITCH);\n@@ -570,1 +568,1 @@\n-            bytecodesBufWriter.writeIntBytes(pad, 0);\n+            bytecodesBufWriter.skip(pad); \/\/ padding content can be anything\n@@ -603,1 +601,1 @@\n-        writeBytecode(Opcode.INVOKEDYNAMIC);\n+        writeBytecode(INVOKEDYNAMIC);\n@@ -609,1 +607,1 @@\n-        writeBytecode(Opcode.NEW);\n+        writeBytecode(NEW);\n@@ -614,1 +612,1 @@\n-        writeBytecode(Opcode.NEWARRAY);\n+        writeBytecode(NEWARRAY);\n@@ -619,1 +617,1 @@\n-        writeBytecode(Opcode.ANEWARRAY);\n+        writeBytecode(ANEWARRAY);\n@@ -624,1 +622,1 @@\n-        writeBytecode(Opcode.MULTIANEWARRAY);\n+        writeBytecode(MULTIANEWARRAY);\n@@ -780,0 +778,745 @@\n+\n+    \/\/ Fast overrides to avoid intermediate instructions\n+    \/\/ These are helpful for direct class building\n+\n+    @Override\n+    public CodeBuilder return_(TypeKind tk) {\n+        writeBytecode(BytecodeHelpers.returnOpcode(tk));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder storeLocal(TypeKind tk, int slot) {\n+        writeLocalVar(BytecodeHelpers.storeOpcode(tk, slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder loadLocal(TypeKind tk, int slot) {\n+        writeLocalVar(BytecodeHelpers.loadOpcode(tk, slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invoke(Opcode opcode, MemberRefEntry ref) {\n+        if (opcode == INVOKEINTERFACE) {\n+            int slots = Util.parameterSlots(Util.methodTypeSymbol(ref.nameAndType())) + 1;\n+            writeInvokeInterface(opcode, (InterfaceMethodRefEntry) ref, slots);\n+        } else {\n+            writeInvokeNormal(opcode, ref);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fieldAccess(Opcode opcode, FieldRefEntry ref) {\n+        writeFieldAccess(opcode, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder arrayLoad(TypeKind tk) {\n+        writeBytecode(BytecodeHelpers.arrayLoadOpcode(tk));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder arrayStore(TypeKind tk) {\n+        writeBytecode(BytecodeHelpers.arrayStoreOpcode(tk));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder branch(Opcode op, Label target) {\n+        writeBranch(op, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder nop() {\n+        writeBytecode(NOP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder aconst_null() {\n+        writeBytecode(ACONST_NULL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder aload(int slot) {\n+        writeLocalVar(BytecodeHelpers.aload(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder anewarray(ClassEntry entry) {\n+        writeNewReferenceArray(entry);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder arraylength() {\n+        writeBytecode(ARRAYLENGTH);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder astore(int slot) {\n+        writeLocalVar(BytecodeHelpers.astore(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder athrow() {\n+        writeBytecode(ATHROW);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder bipush(int b) {\n+        BytecodeHelpers.validateBipush(b);\n+        writeArgumentConstant(BIPUSH, b);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder checkcast(ClassEntry type) {\n+        writeTypeCheck(CHECKCAST, type);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder d2f() {\n+        writeBytecode(D2F);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder d2i() {\n+        writeBytecode(D2I);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder d2l() {\n+        writeBytecode(D2L);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dadd() {\n+        writeBytecode(DADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dcmpg() {\n+        writeBytecode(DCMPG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dcmpl() {\n+        writeBytecode(DCMPL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dconst_0() {\n+        writeBytecode(DCONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dconst_1() {\n+        writeBytecode(DCONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ddiv() {\n+        writeBytecode(DDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dload(int slot) {\n+        writeLocalVar(BytecodeHelpers.dload(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dmul() {\n+        writeBytecode(DMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dneg() {\n+        writeBytecode(DNEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder drem() {\n+        writeBytecode(DREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dstore(int slot) {\n+        writeLocalVar(BytecodeHelpers.dstore(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dsub() {\n+        writeBytecode(DSUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup() {\n+        writeBytecode(DUP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup2() {\n+        writeBytecode(DUP2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup2_x1() {\n+        writeBytecode(DUP2_X1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup2_x2() {\n+        writeBytecode(DUP2_X2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup_x1() {\n+        writeBytecode(DUP_X1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup_x2() {\n+        writeBytecode(DUP_X2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder f2d() {\n+        writeBytecode(F2D);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder f2i() {\n+        writeBytecode(F2I);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder f2l() {\n+        writeBytecode(F2L);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fadd() {\n+        writeBytecode(FADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fcmpg() {\n+        writeBytecode(FCMPG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fcmpl() {\n+        writeBytecode(FCMPL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fconst_0() {\n+        writeBytecode(FCONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fconst_1() {\n+        writeBytecode(FCONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fconst_2() {\n+        writeBytecode(FCONST_2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fdiv() {\n+        writeBytecode(FDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fload(int slot) {\n+        writeLocalVar(BytecodeHelpers.fload(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fmul() {\n+        writeBytecode(FMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fneg() {\n+        writeBytecode(FNEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder frem() {\n+        writeBytecode(FREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fstore(int slot) {\n+        writeLocalVar(BytecodeHelpers.fstore(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fsub() {\n+        writeBytecode(FSUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2b() {\n+        writeBytecode(I2B);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2c() {\n+        writeBytecode(I2C);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2d() {\n+        writeBytecode(I2D);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2f() {\n+        writeBytecode(I2F);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2l() {\n+        writeBytecode(I2L);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2s() {\n+        writeBytecode(I2S);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iadd() {\n+        writeBytecode(IADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iand() {\n+        writeBytecode(IAND);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_0() {\n+        writeBytecode(ICONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_1() {\n+        writeBytecode(ICONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_2() {\n+        writeBytecode(ICONST_2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_3() {\n+        writeBytecode(ICONST_3);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_4() {\n+        writeBytecode(ICONST_4);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_5() {\n+        writeBytecode(ICONST_5);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_m1() {\n+        writeBytecode(ICONST_M1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder idiv() {\n+        writeBytecode(IDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iinc(int slot, int val) {\n+        writeIncrement(slot, val);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iload(int slot) {\n+        writeLocalVar(BytecodeHelpers.iload(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder imul() {\n+        writeBytecode(IMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ineg() {\n+        writeBytecode(INEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder instanceOf(ClassEntry target) {\n+        writeTypeCheck(INSTANCEOF, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokedynamic(InvokeDynamicEntry ref) {\n+        writeInvokeDynamic(ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokeinterface(InterfaceMethodRefEntry ref) {\n+        writeInvokeInterface(INVOKEINTERFACE, ref, Util.parameterSlots(ref.typeSymbol()) + 1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokespecial(InterfaceMethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESPECIAL, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokespecial(MethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESPECIAL, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokestatic(InterfaceMethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESTATIC, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokestatic(MethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESTATIC, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokevirtual(MethodRefEntry ref) {\n+        writeInvokeNormal(INVOKEVIRTUAL, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ior() {\n+        writeBytecode(IOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder irem() {\n+        writeBytecode(IREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ishl() {\n+        writeBytecode(ISHL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ishr() {\n+        writeBytecode(ISHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder istore(int slot) {\n+        writeLocalVar(BytecodeHelpers.istore(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder isub() {\n+        writeBytecode(ISUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iushr() {\n+        writeBytecode(IUSHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ixor() {\n+        writeBytecode(IXOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lookupswitch(Label defaultTarget, List<SwitchCase> cases) {\n+        writeLookupSwitch(defaultTarget, cases);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder l2d() {\n+        writeBytecode(L2D);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder l2f() {\n+        writeBytecode(L2F);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder l2i() {\n+        writeBytecode(L2I);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ladd() {\n+        writeBytecode(LADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder land() {\n+        writeBytecode(LAND);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lcmp() {\n+        writeBytecode(LCMP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lconst_0() {\n+        writeBytecode(LCONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lconst_1() {\n+        writeBytecode(LCONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ldc(LoadableConstantEntry entry) {\n+        writeLoadConstant(BytecodeHelpers.ldcOpcode(entry), entry);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ldiv() {\n+        writeBytecode(LDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lload(int slot) {\n+        writeLocalVar(BytecodeHelpers.lload(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lmul() {\n+        writeBytecode(LMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lneg() {\n+        writeBytecode(LNEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lor() {\n+        writeBytecode(LOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lrem() {\n+        writeBytecode(LREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lshl() {\n+        writeBytecode(LSHL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lshr() {\n+        writeBytecode(LSHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lstore(int slot) {\n+        writeLocalVar(BytecodeHelpers.lstore(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lsub() {\n+        writeBytecode(LSUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lushr() {\n+        writeBytecode(LUSHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lxor() {\n+        writeBytecode(LXOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder monitorenter() {\n+        writeBytecode(MONITORENTER);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder monitorexit() {\n+        writeBytecode(MONITOREXIT);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder multianewarray(ClassEntry array, int dims) {\n+        writeNewMultidimensionalArray(dims, array);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder new_(ClassEntry clazz) {\n+        writeNewObject(clazz);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder newarray(TypeKind typeKind) {\n+        int atype = typeKind.newarrayCode(); \/\/ implicit null check\n+        if (atype < 0)\n+            throw new IllegalArgumentException(\"Illegal component type: \".concat(typeKind.upperBound().displayName()));\n+        writeNewPrimitiveArray(atype);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder pop() {\n+        writeBytecode(POP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder pop2() {\n+        writeBytecode(POP2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder sipush(int s) {\n+        BytecodeHelpers.validateSipush(s);\n+        writeArgumentConstant(SIPUSH, s);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder swap() {\n+        writeBytecode(SWAP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder tableswitch(int low, int high, Label defaultTarget, List<SwitchCase> cases) {\n+        writeTableSwitch(low, high, defaultTarget, cases);\n+        return this;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":802,"deletions":59,"binary":false,"changes":861,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+                              int flags,\n@@ -52,1 +53,1 @@\n-        this.flags = 0;\n+        this.flags = flags;\n@@ -70,0 +71,6 @@\n+    @Override\n+    public FieldBuilder withFlags(int flags) {\n+        setFlags(flags);\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -64,0 +64,6 @@\n+    @Override\n+    public MethodBuilder withFlags(int flags) {\n+        setFlags(flags);\n+        return this;\n+    }\n+\n@@ -101,0 +107,3 @@\n+        if (paramNo == 0) {\n+            return ((flags & ClassFile.ACC_STATIC) != 0) ? 0 : 1;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -102,6 +102,1 @@\n-            builder.withField(fieldName(), fieldType(), new Consumer<>() {\n-                @Override\n-                public void accept(FieldBuilder fb) {\n-                    FieldImpl.this.forEach(fb);\n-                }\n-            });\n+            builder.withField(fieldName(), fieldType(), Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/FieldImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -139,7 +139,1 @@\n-            builder.withMethod(methodName(), methodType(), methodFlags(),\n-                               new Consumer<>() {\n-                @Override\n-                public void accept(MethodBuilder mb) {\n-                    MethodImpl.this.forEach(mb);\n-                }\n-            });\n+            builder.withMethod(methodName(), methodType(), methodFlags(), Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,6 +27,9 @@\n-import java.nio.ByteBuffer;\n-import static java.lang.classfile.ClassFile.ASTORE_3;\n-import static java.lang.classfile.ClassFile.ISTORE;\n-import static java.lang.classfile.ClassFile.LOOKUPSWITCH;\n-import static java.lang.classfile.ClassFile.TABLESWITCH;\n-import static java.lang.classfile.ClassFile.WIDE;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.util.Preconditions;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import static java.lang.classfile.ClassFile.*;\n@@ -36,0 +39,14 @@\n+    public static final BiFunction<String, List<Number>, IllegalArgumentException>\n+            IAE_FORMATTER = Preconditions.outOfBoundsExceptionFormatter(new Function<>() {\n+        @Override\n+        public IllegalArgumentException apply(String s) {\n+            return new IllegalArgumentException(s);\n+        }\n+    });\n+\n+    public record CodeRange(byte[] array, int length) {\n+        public RawBytecodeHelper start() {\n+            return new RawBytecodeHelper(this);\n+        }\n+    }\n+\n@@ -38,6 +55,32 @@\n-    private static final byte[] LENGTHS = new byte[] {\n-        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 2, 3, 3, 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-        2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 2 | (4 << 4), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3 | (6 << 4), 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2 | (4 << 4), 0, 0, 1, 1, 1,\n-        1, 1, 1, 3, 3, 3, 3, 3, 3, 3, 5, 5, 3, 2, 3, 1, 1, 3, 3, 1, 1, 0, 4, 3, 3, 5, 5, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 4, 4, 4, 2, 4, 3, 3, 0, 0, 1, 3, 2, 3, 3, 3, 1, 2, 1,\n-        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n+    \/**\n+     * The length of opcodes, or -1 for no fixed length.\n+     * This is generated as if:\n+     * {@snippet lang=java :\n+     * var lengths = new byte[0x100];\n+     * Arrays.fill(lengths, (byte) -1);\n+     * for (var op : Opcode.values()) {\n+     *     if (!op.isWide()) {\n+     *         lengths[op.bytecode()] = (byte) op.sizeIfFixed();\n+     *     }\n+     * }\n+     * }\n+     * Tested in UtilTest::testOpcodeLengthTable.\n+     *\/\n+    \/\/ Note: Consider distinguishing non-opcode and non-fixed-length opcode\n+    public static final @Stable byte[] LENGTHS = new byte[] {\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            2, 3, 2, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 3, 3, 3, 3,\n+            3, 3, 3, 3, 3, 3, 3, 3, 3, 2, -1, -1, 1, 1, 1, 1,\n+            1, 1, 3, 3, 3, 3, 3, 3, 3, 5, 5, 3, 2, 3, 1, 1,\n+            3, 3, 1, 1, -1, 4, 3, 3, 5, 5, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+            -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n@@ -54,4 +97,6 @@\n-    private final ByteBuffer bytecode;\n-    public int bci, nextBci, endBci;\n-    public int rawCode;\n-    public boolean isWide;\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    public final CodeRange code;\n+    private int nextBci;\n+    private int bci;\n+    private int opcode;\n+    private boolean isWide;\n@@ -59,5 +104,2 @@\n-    public RawBytecodeHelper(ByteBuffer bytecode) {\n-        this.bytecode = bytecode;\n-        this.bci = 0;\n-        this.nextBci = 0;\n-        this.endBci = bytecode.capacity();\n+    public static CodeRange of(byte[] array) {\n+        return new CodeRange(array, array.length);\n@@ -66,2 +108,2 @@\n-    public boolean isLastBytecode() {\n-        return nextBci >= endBci;\n+    public static CodeRange of(byte[] array, int limit) {\n+        return new CodeRange(array, limit);\n@@ -70,2 +112,2 @@\n-    public int getShort(int bci) {\n-        return bytecode.getShort(bci);\n+    private RawBytecodeHelper(CodeRange range) {\n+        this.code = range;\n@@ -74,2 +116,5 @@\n-    public int dest() {\n-        return bci + getShort(bci + 1);\n+    \/\/ immutable states\n+\n+    \/** {@return the end of the code array} *\/\n+    public int endBci() {\n+        return code.length;\n@@ -78,2 +123,10 @@\n-    public int getInt(int bci) {\n-        return bytecode.getInt(bci);\n+    \/\/ setup\n+\n+    \/**\n+     * Sets the starting bci for bytecode reading. Can be set to\n+     * {@link #endBci} to end scanning. Must be followed by a\n+     * {@link #next} before getter access.\n+     *\/\n+    public void reset(int nextBci) {\n+        Preconditions.checkIndex(nextBci, endBci() + 1, IAE_FORMATTER);\n+        this.nextBci = nextBci;\n@@ -82,2 +135,10 @@\n-    public int destW() {\n-        return bci + getInt(bci + 1);\n+    \/\/ getters after transition\n+\n+    \/**\n+     * Returns the current functional opcode, or {@link #ILLEGAL} if\n+     * the next instruction is invalid in format.\n+     * If this returns a valid opcode, that instruction's format must\n+     * be valid and can be accessed unchecked.\n+     *\/\n+    public int opcode() {\n+        return opcode;\n@@ -86,2 +147,5 @@\n-    public int getIndexU1() {\n-        return bytecode.get(bci + 1) & 0xff;\n+    \/**\n+     * Returns whether the current functional opcode is in wide.\n+     *\/\n+    public boolean isWide() {\n+        return isWide;\n@@ -90,0 +154,9 @@\n+    \/**\n+     * Returns the last validated instruction's index.\n+     *\/\n+    public int bci() {\n+        return bci;\n+    }\n+\n+    \/\/ general utilities\n+\n@@ -91,1 +164,2 @@\n-        return bytecode.get(bci) & 0xff;\n+        Preconditions.checkIndex(bci, endBci(), IAE_FORMATTER);\n+        return getU1Unchecked(bci);\n@@ -94,3 +168,3 @@\n-    public int rawNext(int jumpTo) {\n-        this.nextBci = jumpTo;\n-        return rawNext();\n+    public int getU2(int bci) {\n+        Preconditions.checkFromIndexSize(bci, 2, endBci(), IAE_FORMATTER);\n+        return getU2Unchecked(bci);\n@@ -99,59 +173,18 @@\n-    public int rawNext() {\n-        bci = nextBci;\n-        int code = bytecode.get(bci) & 0xff;\n-        int len = LENGTHS[code] & 0xf;\n-        if (len > 0 && (bci <= endBci - len)) {\n-            isWide = false;\n-            nextBci += len;\n-            if (nextBci <= bci) {\n-                code = ILLEGAL;\n-            }\n-            rawCode = code;\n-            return code;\n-        } else {\n-            len = switch (bytecode.get(bci) & 0xff) {\n-                case WIDE -> {\n-                    if (bci + 1 >= endBci) {\n-                        yield -1;\n-                    }\n-                    yield LENGTHS[bytecode.get(bci + 1) & 0xff] >> 4;\n-                }\n-                case TABLESWITCH -> {\n-                    int aligned_bci = align(bci + 1);\n-                    if (aligned_bci + 3 * 4 >= endBci) {\n-                        yield -1;\n-                    }\n-                    int lo = bytecode.getInt(aligned_bci + 1 * 4);\n-                    int hi = bytecode.getInt(aligned_bci + 2 * 4);\n-                    int l = aligned_bci - bci + (3 + hi - lo + 1) * 4;\n-                    if (l > 0) yield l; else yield -1;\n-                }\n-                case LOOKUPSWITCH -> {\n-                    int aligned_bci = align(bci + 1);\n-                    if (aligned_bci + 2 * 4 >= endBci) {\n-                        yield -1;\n-                    }\n-                    int npairs = bytecode.getInt(aligned_bci + 4);\n-                    int l = aligned_bci - bci + (2 + 2 * npairs) * 4;\n-                    if (l > 0) yield l; else yield -1;\n-                }\n-                default ->\n-                    0;\n-            };\n-            if (len <= 0 || (bci > endBci - len) || (bci - len >= nextBci)) {\n-                code = ILLEGAL;\n-            } else {\n-                nextBci += len;\n-                isWide = false;\n-                if (code == WIDE) {\n-                    if (bci + 1 >= endBci) {\n-                        code = ILLEGAL;\n-                    } else {\n-                        code = bytecode.get(bci + 1) & 0xff;\n-                        isWide = true;\n-                    }\n-                }\n-            }\n-            rawCode = code;\n-            return code;\n-        }\n+    public int getShort(int bci) {\n+        Preconditions.checkFromIndexSize(bci, 2, endBci(), IAE_FORMATTER);\n+        return getShortUnchecked(bci);\n+    }\n+\n+    public int getInt(int bci) {\n+        Preconditions.checkFromIndexSize(bci, 4, endBci(), IAE_FORMATTER);\n+        return getIntUnchecked(bci);\n+    }\n+\n+    \/\/ Unchecked accessors: only if opcode() is validated\n+\n+    public int getU1Unchecked(int bci) {\n+        return Byte.toUnsignedInt(code.array[bci]);\n+    }\n+\n+    public int getU2Unchecked(int bci) {\n+        return UNSAFE.getCharUnaligned(code.array, (long) Unsafe.ARRAY_BYTE_BASE_OFFSET + bci, true);\n@@ -160,0 +193,20 @@\n+    public int getShortUnchecked(int bci) {\n+        return UNSAFE.getShortUnaligned(code.array, (long) Unsafe.ARRAY_BYTE_BASE_OFFSET + bci, true);\n+    }\n+\n+    \/\/ used after switch validation\n+    public int getIntUnchecked(int bci) {\n+        return UNSAFE.getIntUnaligned(code.array, (long) Unsafe.ARRAY_BYTE_BASE_OFFSET + bci, true);\n+    }\n+\n+    \/\/ non-wide branches\n+    public int dest() {\n+        return bci + getShortUnchecked(bci + 1);\n+    }\n+\n+    \/\/ goto_w and jsr_w\n+    public int destW() {\n+        return bci + getIntUnchecked(bci + 1);\n+    }\n+\n+    \/\/ *load, *store, iinc\n@@ -161,1 +214,1 @@\n-        return (isWide) ? getIndexU2Raw(bci + 2) : getIndexU1();\n+        return isWide ? getU2Unchecked(bci + 2) : getIndexU1();\n@@ -164,0 +217,6 @@\n+    \/\/ ldc\n+    public int getIndexU1() {\n+        return getU1Unchecked(bci + 1);\n+    }\n+\n+    \/\/ usually cp entry index\n@@ -165,1 +224,1 @@\n-        return getIndexU2Raw(bci + 1);\n+        return getU2Unchecked(bci + 1);\n@@ -168,2 +227,65 @@\n-    public int getIndexU2Raw(int bci) {\n-        return bytecode.getShort(bci) & 0xffff;\n+    \/\/ Transition methods\n+\n+    \/**\n+     * Transitions to the next instruction and returns whether scanning should\n+     * continue. If the next instruction is malformed, {@link #opcode()} returns\n+     * {@link #ILLEGAL}, so we can perform value access without bound checks if\n+     * we have a valid opcode.\n+     *\/\n+    public boolean next() {\n+        var bci = nextBci;\n+        var end = endBci();\n+        if (bci >= end) {\n+            return false;\n+        }\n+\n+        int code = getU1Unchecked(bci);\n+        int len = LENGTHS[code & 0xFF]; \/\/ & 0xFF eliminates bound check\n+        this.bci = bci;\n+        opcode = code;\n+        isWide = false;\n+        if (len <= 0) {\n+            len = checkSpecialInstruction(bci, end, code); \/\/ sets opcode\n+        }\n+\n+        if (len <= 0 || (nextBci += len) > end) {\n+            opcode = ILLEGAL;\n+        }\n+\n+        return true;\n+    }\n+\n+    \/\/ Put rarely used code in another method to reduce code size\n+    private int checkSpecialInstruction(int bci, int end, int code) {\n+        if (code == WIDE) {\n+            if (bci + 1 >= end) {\n+                return -1;\n+            }\n+            opcode = code = getIndexU1();\n+            isWide = true;\n+            \/\/ Validated in UtilTest.testOpcodeLengthTable\n+            return LENGTHS[code] * 2;\n+        }\n+        if (code == TABLESWITCH) {\n+            int alignedBci = align(bci + 1);\n+            if (alignedBci + 3 * 4 >= end) {\n+                return -1;\n+            }\n+            int lo = getIntUnchecked(alignedBci + 1 * 4);\n+            int hi = getIntUnchecked(alignedBci + 2 * 4);\n+            long l = alignedBci - bci + (3L + (long) hi - lo + 1L) * 4L;\n+            return l > 0 && ((int) l == l) ? (int) l : -1;\n+        }\n+        if (code == LOOKUPSWITCH) {\n+            int alignedBci = align(bci + 1);\n+            if (alignedBci + 2 * 4 >= end) {\n+                return -1;\n+            }\n+            int npairs = getIntUnchecked(alignedBci + 4);\n+            if (npairs < 0) {\n+                return -1;\n+            }\n+            long l = alignedBci - bci + (2L + 2L * npairs) * 4L;\n+            return l > 0 && ((int) l == l) ? (int) l : -1;\n+        }\n+        return -1;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/RawBytecodeHelper.java","additions":223,"deletions":101,"binary":false,"changes":324,"status":"modified"},{"patch":"@@ -145,2 +145,2 @@\n-            buf.patchInt(pos + 2, 4, attrLen - 6);\n-            buf.patchInt(pos + 6, 2, bsmSize);\n+            buf.patchInt(pos + 2, attrLen - 6);\n+            buf.patchU2(pos + 6, bsmSize);\n@@ -269,2 +269,2 @@\n-    private <T extends ConstantDesc> PoolEntry findPrimitiveEntry(int tag, T val) {\n-        int hash = AbstractPoolEntry.hash1(tag, val.hashCode());\n+    private IntegerEntry findIntEntry(int val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_INTEGER, Integer.hashCode(val));\n@@ -274,4 +274,55 @@\n-            if (e.tag() == tag\n-                && e instanceof AbstractPoolEntry.PrimitiveEntry<?> ce\n-                && ce.value().equals(val))\n-                return e;\n+            if (e.tag() == TAG_INTEGER\n+                    && e instanceof AbstractPoolEntry.IntegerEntryImpl ce\n+                    && ce.intValue() == val)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findIntEntry(val);\n+        }\n+        return null;\n+    }\n+\n+    private LongEntry findLongEntry(long val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_LONG, Long.hashCode(val));\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == TAG_LONG\n+                    && e instanceof AbstractPoolEntry.LongEntryImpl ce\n+                    && ce.longValue() == val)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findLongEntry(val);\n+        }\n+        return null;\n+    }\n+\n+    private FloatEntry findFloatEntry(float val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_FLOAT, Float.hashCode(val));\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == TAG_FLOAT\n+                    && e instanceof AbstractPoolEntry.FloatEntryImpl ce\n+                    && ce.floatValue() == val)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findFloatEntry(val);\n+        }\n+        return null;\n+    }\n+\n+    private DoubleEntry findDoubleEntry(double val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_DOUBLE, Double.hashCode(val));\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == TAG_DOUBLE\n+                    && e instanceof AbstractPoolEntry.DoubleEntryImpl ce\n+                    && ce.doubleValue() == val)\n+                return ce;\n@@ -281,1 +332,1 @@\n-            return findPrimitiveEntry(tag, val);\n+            return findDoubleEntry(val);\n@@ -545,1 +596,1 @@\n-        var e = (IntegerEntry) findPrimitiveEntry(TAG_INTEGER, value);\n+        var e = findIntEntry(value);\n@@ -551,1 +602,1 @@\n-        var e = (FloatEntry) findPrimitiveEntry(TAG_FLOAT, value);\n+        var e = findFloatEntry(value);\n@@ -557,1 +608,1 @@\n-        var e = (LongEntry) findPrimitiveEntry(TAG_LONG, value);\n+        var e = findLongEntry(value);\n@@ -563,1 +614,1 @@\n-        var e = (DoubleEntry) findPrimitiveEntry(TAG_DOUBLE, value);\n+        var e = findDoubleEntry(value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":64,"deletions":13,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.Attributes;\n@@ -29,0 +30,2 @@\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n@@ -32,0 +35,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -33,1 +37,0 @@\n-import java.nio.ByteBuffer;\n@@ -38,0 +41,1 @@\n+import java.util.stream.Collectors;\n@@ -40,2 +44,0 @@\n-import java.lang.constant.ClassDesc;\n-import java.util.stream.Collectors;\n@@ -50,0 +52,1 @@\n+                dcb.attributes.get(Attributes.stackMapTable()),\n@@ -54,1 +57,1 @@\n-                dcb.bytecodesBufWriter.asByteBuffer(),\n+                dcb.bytecodesBufWriter.bytecodeView(),\n@@ -66,1 +69,0 @@\n-    private final ByteBuffer bytecode;\n@@ -90,1 +92,1 @@\n-                bcs.nextBci = en.bci;\n+                bcs.reset(en.bci);\n@@ -95,1 +97,1 @@\n-        bcs.nextBci = bcs.endBci;\n+        bcs.reset(bcs.endBci());\n@@ -100,0 +102,1 @@\n+                     StackMapTableAttribute smta,\n@@ -104,1 +107,1 @@\n-                     ByteBuffer bytecode,\n+                     RawBytecodeHelper.CodeRange bytecode,\n@@ -111,1 +114,0 @@\n-        this.bytecode = bytecode;\n@@ -114,1 +116,2 @@\n-        maxStack = stack = rets = 0;\n+        stack = rets = 0;\n+        maxStack = handlers.isEmpty() ? 0 : 1;\n@@ -116,0 +119,11 @@\n+        if (smta != null) {\n+            for (var smfi : smta.entries()) {\n+                int frameStack = smfi.stack().size();\n+                for (var vti : smfi.stack()) {\n+                    if (vti == StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_LONG\n+                     || vti == StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_DOUBLE) frameStack++;\n+                }\n+                if (maxStack < frameStack) maxStack = frameStack;\n+                targets.add(new Target(labelContext.labelToBci(smfi.target()), frameStack));\n+            }\n+        }\n@@ -118,2 +132,2 @@\n-        bcs = new RawBytecodeHelper(bytecode);\n-        visited = new BitSet(bcs.endBci);\n+        bcs = bytecode.start();\n+        visited = new BitSet(bcs.endBci());\n@@ -122,4 +136,3 @@\n-            while (!bcs.isLastBytecode()) {\n-                bcs.rawNext();\n-                int opcode = bcs.rawCode;\n-                int bci = bcs.bci;\n+            while (bcs.next()) {\n+                int opcode = bcs.opcode();\n+                int bci = bcs.bci();\n@@ -253,1 +266,1 @@\n-                        int defaultOfset = bcs.getInt(alignedBci);\n+                        int defaultOffset = bcs.getIntUnchecked(alignedBci);\n@@ -256,3 +269,3 @@\n-                        if (bcs.rawCode == TABLESWITCH) {\n-                            int low = bcs.getInt(alignedBci + 4);\n-                            int high = bcs.getInt(alignedBci + 2 * 4);\n+                        if (bcs.opcode() == TABLESWITCH) {\n+                            int low = bcs.getIntUnchecked(alignedBci + 4);\n+                            int high = bcs.getIntUnchecked(alignedBci + 2 * 4);\n@@ -268,1 +281,1 @@\n-                            keys = bcs.getInt(alignedBci + 4);\n+                            keys = bcs.getIntUnchecked(alignedBci + 4);\n@@ -274,2 +287,2 @@\n-                                int this_key = bcs.getInt(alignedBci + (2 + 2 * i) * 4);\n-                                int next_key = bcs.getInt(alignedBci + (2 + 2 * i + 2) * 4);\n+                                int this_key = bcs.getIntUnchecked(alignedBci + (2 + 2 * i) * 4);\n+                                int next_key = bcs.getIntUnchecked(alignedBci + (2 + 2 * i + 2) * 4);\n@@ -281,1 +294,1 @@\n-                        int target = bci + defaultOfset;\n+                        int target = bci + defaultOffset;\n@@ -284,2 +297,1 @@\n-                            alignedBci = RawBytecodeHelper.align(bcs.bci + 1);\n-                            target = bci + bcs.getInt(alignedBci + (3 + i * delta) * 4);\n+                            target = bci + bcs.getIntUnchecked(alignedBci + (3 + i * delta) * 4);\n@@ -300,1 +312,1 @@\n-                        switch (bcs.rawCode) {\n+                        switch (bcs.opcode()) {\n@@ -316,1 +328,1 @@\n-                        addStackSlot(Util.slotSize(mtd.returnType()) - Util.parameterSlots(mtd));\n+                        var delta = Util.slotSize(mtd.returnType()) - Util.parameterSlots(mtd);\n@@ -318,1 +330,1 @@\n-                            addStackSlot(-1);\n+                            delta--;\n@@ -320,0 +332,1 @@\n+                        addStackSlot(delta);\n@@ -322,1 +335,1 @@\n-                        addStackSlot (1 - bcs.getU1(bcs.bci + 3));\n+                        addStackSlot(1 - bcs.getU1Unchecked(bcs.bci() + 3));\n@@ -380,1 +393,1 @@\n-                bcs.bci,\n+                bcs.bci(),\n@@ -383,1 +396,1 @@\n-        Util.dumpMethod(cp, thisClass, methodName, methodDesc, isStatic ? ACC_STATIC : 0, bytecode, sb::append);\n+        Util.dumpMethod(cp, thisClass, methodName, methodDesc, isStatic ? ACC_STATIC : 0, bcs.code, sb::append);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":45,"deletions":32,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import java.util.Arrays;\n+import java.util.Comparator;\n@@ -40,1 +42,0 @@\n-import java.util.TreeMap;\n@@ -49,0 +50,1 @@\n+    private static final StackMapFrameInfo[] NO_STACK_FRAME_INFOS = new StackMapFrameInfo[0];\n@@ -106,1 +108,2 @@\n-        var map = new TreeMap<Integer, StackMapFrameInfo>();\n+        \/\/ avoid using method handles due to early bootstrap\n+        StackMapFrameInfo[] infos = entries.toArray(NO_STACK_FRAME_INFOS);\n@@ -108,7 +111,11 @@\n-        for (var fr : entries) {\n-            map.put(dcb.labelToBci(fr.target()), fr);\n-        }\n-        b.writeU2(map.size());\n-        for (var me : map.entrySet()) {\n-            int offset = me.getKey();\n-            var fr = me.getValue();\n+        Arrays.sort(infos, new Comparator<StackMapFrameInfo>() {\n+            public int compare(final StackMapFrameInfo o1, final StackMapFrameInfo o2) {\n+                return Integer.compare(dcb.labelToBci(o1.target()), dcb.labelToBci(o2.target()));\n+            }\n+        });\n+        b.writeU2(infos.length);\n+        for (var fr : infos) {\n+            int offset = dcb.labelToBci(fr.target());\n+            if (offset == prevOffset) {\n+                throw new IllegalArgumentException(\"Duplicated stack frame bytecode index: \" + offset);\n+            }\n@@ -164,2 +171,2 @@\n-        switch (vti) {\n-            case SimpleVerificationTypeInfo svti ->\n+        switch (vti.tag()) {\n+            case VT_TOP, VT_INTEGER, VT_FLOAT, VT_DOUBLE, VT_LONG, VT_NULL, VT_UNINITIALIZED_THIS ->\n@@ -167,4 +174,5 @@\n-            case ObjectVerificationTypeInfo ovti ->\n-                bw.writeIndex(ovti.className());\n-            case UninitializedVerificationTypeInfo uvti ->\n-                bw.writeU2(bw.labelContext().labelToBci(uvti.newTarget()));\n+            case VT_OBJECT ->\n+                bw.writeIndex(((ObjectVerificationTypeInfo)vti).className());\n+            case VT_UNINITIALIZED ->\n+                bw.writeU2(bw.labelContext().labelToBci(((UninitializedVerificationTypeInfo)vti).newTarget()));\n+            default -> throw new IllegalArgumentException(\"Invalid verification type tag: \" + vti.tag());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.nio.ByteBuffer;\n@@ -49,0 +48,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -155,1 +155,1 @@\n-                dcb.bytecodesBufWriter.asByteBuffer(),\n+                dcb.bytecodesBufWriter.bytecodeView(),\n@@ -191,1 +191,1 @@\n-    private final ByteBuffer bytecode;\n+    private final RawBytecodeHelper.CodeRange bytecode;\n@@ -225,1 +225,1 @@\n-                     ByteBuffer bytecode,\n+                     RawBytecodeHelper.CodeRange bytecode,\n@@ -238,3 +238,3 @@\n-        this.classHierarchy = new ClassHierarchyImpl(context.classHierarchyResolverOption().classHierarchyResolver());\n-        this.patchDeadCode = context.deadCodeOption() == ClassFile.DeadCodeOption.PATCH_DEAD_CODE;\n-        this.filterDeadLabels = context.deadLabelsOption() == ClassFile.DeadLabelsOption.DROP_DEAD_LABELS;\n+        this.classHierarchy = new ClassHierarchyImpl(context.classHierarchyResolver());\n+        this.patchDeadCode = context.patchDeadCode();\n+        this.filterDeadLabels = context.dropDeadLabels();\n@@ -292,1 +292,1 @@\n-        exMin = bytecode.capacity();\n+        exMin = bytecode.length();\n@@ -329,1 +329,1 @@\n-                int blockSize = (i < framesCount - 1 ? frames.get(i + 1).offset : bytecode.limit()) - frame.offset;\n+                int end = (i < framesCount - 1 ? frames.get(i + 1).offset : bytecode.length()) - 1;\n@@ -331,5 +331,3 @@\n-                bytecode.position(frame.offset);\n-                for (int n=1; n<blockSize; n++) {\n-                    bytecode.put((byte) NOP);\n-                }\n-                bytecode.put((byte) ATHROW);\n+                var arr = bytecode.array();\n+                Arrays.fill(arr, frame.offset, end, (byte) NOP);\n+                arr[end] = (byte) ATHROW;\n@@ -337,1 +335,1 @@\n-                removeRangeFromExcTable(frame.offset, frame.offset + blockSize);\n+                removeRangeFromExcTable(frame.offset, end + 1);\n@@ -410,1 +408,1 @@\n-        RawBytecodeHelper bcs = new RawBytecodeHelper(bytecode);\n+        var bcs = bytecode.start();\n@@ -412,3 +410,2 @@\n-        while (!bcs.isLastBytecode()) {\n-            bcs.rawNext();\n-            currentFrame.offset = bcs.bci;\n+        while (bcs.next()) {\n+            currentFrame.offset = bcs.bci();\n@@ -417,1 +414,1 @@\n-                if (ncf && thisOffset > bcs.bci) {\n+                if (ncf && thisOffset > bcs.bci()) {\n@@ -420,1 +417,1 @@\n-                if (thisOffset == bcs.bci) {\n+                if (thisOffset == bcs.bci()) {\n@@ -429,2 +426,3 @@\n-                    bcs.rawNext(nextFrame.offset); \/\/skip code up-to the next frame\n-                    currentFrame.offset = bcs.bci;\n+                    bcs.reset(nextFrame.offset); \/\/skip code up-to the next frame\n+                    bcs.next();\n+                    currentFrame.offset = bcs.bci();\n@@ -433,1 +431,1 @@\n-                } else if (thisOffset < bcs.bci) {\n+                } else if (thisOffset < bcs.bci()) {\n@@ -444,1 +442,1 @@\n-        int opcode = bcs.rawCode;\n+        int opcode = bcs.opcode();\n@@ -448,1 +446,1 @@\n-        int bci = bcs.bci;\n+        int bci = bcs.bci();\n@@ -654,1 +652,1 @@\n-                int dim = bcs.getU1(bcs.bci + 3);\n+                int dim = bcs.getU1Unchecked(bcs.bci() + 3);\n@@ -711,1 +709,1 @@\n-        int bci = bcs.bci;\n+        int bci = bcs.bci();\n@@ -713,1 +711,1 @@\n-        int defaultOfset = bcs.getInt(alignedBci);\n+        int defaultOffset = bcs.getIntUnchecked(alignedBci);\n@@ -716,3 +714,3 @@\n-        if (bcs.rawCode == TABLESWITCH) {\n-            int low = bcs.getInt(alignedBci + 4);\n-            int high = bcs.getInt(alignedBci + 2 * 4);\n+        if (bcs.opcode() == TABLESWITCH) {\n+            int low = bcs.getIntUnchecked(alignedBci + 4);\n+            int high = bcs.getIntUnchecked(alignedBci + 2 * 4);\n@@ -728,1 +726,1 @@\n-            keys = bcs.getInt(alignedBci + 4);\n+            keys = bcs.getIntUnchecked(alignedBci + 4);\n@@ -734,2 +732,2 @@\n-                int this_key = bcs.getInt(alignedBci + (2 + 2 * i) * 4);\n-                int next_key = bcs.getInt(alignedBci + (2 + 2 * i + 2) * 4);\n+                int this_key = bcs.getIntUnchecked(alignedBci + (2 + 2 * i) * 4);\n+                int next_key = bcs.getIntUnchecked(alignedBci + (2 + 2 * i + 2) * 4);\n@@ -741,1 +739,1 @@\n-        int target = bci + defaultOfset;\n+        int target = bci + defaultOffset;\n@@ -744,2 +742,1 @@\n-            alignedBci = RawBytecodeHelper.align(bcs.bci + 1);\n-            target = bci + bcs.getInt(alignedBci + (3 + i * delta) * 4);\n+            target = bci + bcs.getIntUnchecked(alignedBci + (3 + i * delta) * 4);\n@@ -752,1 +749,1 @@\n-        switch (bcs.rawCode) {\n+        switch (bcs.opcode()) {\n@@ -774,1 +771,1 @@\n-        int opcode = bcs.rawCode;\n+        int opcode = bcs.opcode();\n@@ -780,1 +777,1 @@\n-        int bci = bcs.bci;\n+        int bci = bcs.bci();\n@@ -793,1 +790,1 @@\n-                    int new_class_index = bcs.getIndexU2Raw(new_offset + 1);\n+                    int new_class_index = bcs.getU2(new_offset + 1);\n@@ -852,1 +849,1 @@\n-                if (i < 0 || i >= bytecode.capacity()) throw new IllegalArgumentException();\n+                Preconditions.checkIndex(i, bytecode.length(), RawBytecodeHelper.IAE_FORMATTER);\n@@ -856,1 +853,1 @@\n-        RawBytecodeHelper bcs = new RawBytecodeHelper(bytecode);\n+        var bcs = bytecode.start();\n@@ -859,3 +856,3 @@\n-        while (!bcs.isLastBytecode()) try {\n-            opcode = bcs.rawNext();\n-            bci = bcs.bci;\n+        while (bcs.next()) try {\n+            opcode = bcs.opcode();\n+            bci = bcs.bci();\n@@ -883,1 +880,1 @@\n-                            int default_ofset = bcs.getInt(aligned_bci);\n+                            int default_ofset = bcs.getIntUnchecked(aligned_bci);\n@@ -885,3 +882,3 @@\n-                            if (bcs.rawCode == TABLESWITCH) {\n-                                int low = bcs.getInt(aligned_bci + 4);\n-                                int high = bcs.getInt(aligned_bci + 2 * 4);\n+                            if (bcs.opcode() == TABLESWITCH) {\n+                                int low = bcs.getIntUnchecked(aligned_bci + 4);\n+                                int high = bcs.getIntUnchecked(aligned_bci + 2 * 4);\n@@ -891,1 +888,1 @@\n-                                keys = bcs.getInt(aligned_bci + 4);\n+                                keys = bcs.getIntUnchecked(aligned_bci + 4);\n@@ -896,1 +893,1 @@\n-                                offsets.set(bci + bcs.getInt(aligned_bci + (3 + i * delta) * 4));\n+                                offsets.set(bci + bcs.getIntUnchecked(aligned_bci + (3 + i * delta) * 4));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":50,"deletions":53,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.classfile.AnnotationElement;\n@@ -39,1 +38,0 @@\n-import java.lang.classfile.Label;\n@@ -761,52 +759,1 @@\n-                                        Utf8Entry className,\n-                                        List<AnnotationElement> elements) implements TypeAnnotation, Util.Writable {\n-\n-        public UnboundTypeAnnotation(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                                     Utf8Entry className, List<AnnotationElement> elements) {\n-            this.targetInfo = targetInfo;\n-            this.targetPath = List.copyOf(targetPath);\n-            this.className = className;\n-            this.elements = List.copyOf(elements);\n-        }\n-\n-        private int labelToBci(LabelContext lr, Label label) {\n-            \/\/helper method to avoid NPE\n-            if (lr == null) throw new IllegalArgumentException(\"Illegal targetType '%s' in TypeAnnotation outside of Code attribute\".formatted(targetInfo.targetType()));\n-            return lr.labelToBci(label);\n-        }\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            LabelContext lr = buf.labelContext();\n-            \/\/ target_type\n-            buf.writeU1(targetInfo.targetType().targetTypeValue());\n-\n-            \/\/ target_info\n-            switch (targetInfo) {\n-                case TypeParameterTarget tpt -> buf.writeU1(tpt.typeParameterIndex());\n-                case SupertypeTarget st -> buf.writeU2(st.supertypeIndex());\n-                case TypeParameterBoundTarget tpbt -> {\n-                    buf.writeU1(tpbt.typeParameterIndex());\n-                    buf.writeU1(tpbt.boundIndex());\n-                }\n-                case EmptyTarget et -> {\n-                    \/\/ nothing to write\n-                }\n-                case FormalParameterTarget fpt -> buf.writeU1(fpt.formalParameterIndex());\n-                case ThrowsTarget tt -> buf.writeU2(tt.throwsTargetIndex());\n-                case LocalVarTarget lvt -> {\n-                    buf.writeU2(lvt.table().size());\n-                    for (var e : lvt.table()) {\n-                        int startPc = labelToBci(lr, e.startLabel());\n-                        buf.writeU2(startPc);\n-                        buf.writeU2(labelToBci(lr, e.endLabel()) - startPc);\n-                        buf.writeU2(e.index());\n-                    }\n-                }\n-                case CatchTarget ct -> buf.writeU2(ct.exceptionTableIndex());\n-                case OffsetTarget ot -> buf.writeU2(labelToBci(lr, ot.target()));\n-                case TypeArgumentTarget tat -> {\n-                    buf.writeU2(labelToBci(lr, tat.target()));\n-                    buf.writeU1(tat.typeArgumentIndex());\n-                }\n-            }\n+                                        Annotation annotation) implements TypeAnnotation {\n@@ -814,16 +761,2 @@\n-            \/\/ target_path\n-            buf.writeU1(targetPath().size());\n-            for (TypePathComponent component : targetPath()) {\n-                buf.writeU1(component.typePathKind().tag());\n-                buf.writeU1(component.typeArgumentIndex());\n-            }\n-\n-            \/\/ type_index\n-            buf.writeIndex(className);\n-\n-            \/\/ element_value_pairs\n-            buf.writeU2(elements.size());\n-            for (AnnotationElement pair : elements()) {\n-                buf.writeIndex(pair.name());\n-                AnnotationReader.writeAnnotationValue(buf, pair.value());\n-            }\n+        public UnboundTypeAnnotation {\n+            targetPath = List.copyOf(targetPath);\n@@ -919,2 +852,1 @@\n-            b.writeInt(0);\n-            int start = b.size();\n+            int lengthIndex = b.skip(4);\n@@ -922,2 +854,2 @@\n-            int written = b.size() - start;\n-            b.patchInt(start - 4, 4, written);\n+            int written = b.size() - lengthIndex - 4;\n+            b.patchInt(lengthIndex, written);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":6,"deletions":74,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.classfile.CodeBuilder;\n@@ -28,0 +29,2 @@\n+import java.lang.classfile.FieldBuilder;\n+import java.lang.classfile.MethodBuilder;\n@@ -53,1 +56,0 @@\n-import java.nio.ByteBuffer;\n@@ -56,0 +58,4 @@\n+import static jdk.internal.constant.PrimitiveClassDescImpl.CD_double;\n+import static jdk.internal.constant.PrimitiveClassDescImpl.CD_long;\n+import static jdk.internal.constant.PrimitiveClassDescImpl.CD_void;\n+\n@@ -66,0 +72,30 @@\n+    public static <T> Consumer<Consumer<T>> writingAll(Iterable<T> container) {\n+        record ForEachConsumer<T>(Iterable<T> container) implements Consumer<Consumer<T>> {\n+            @Override\n+            public void accept(Consumer<T> consumer) {\n+                container.forEach(consumer);\n+            }\n+        }\n+        return new ForEachConsumer<>(container);\n+    }\n+\n+    public static Consumer<MethodBuilder> buildingCode(Consumer<? super CodeBuilder> codeHandler) {\n+        record WithCodeMethodHandler(Consumer<? super CodeBuilder> codeHandler) implements Consumer<MethodBuilder> {\n+            @Override\n+            public void accept(MethodBuilder builder) {\n+                builder.withCode(codeHandler);\n+            }\n+        }\n+        return new WithCodeMethodHandler(codeHandler);\n+    }\n+\n+    public static Consumer<FieldBuilder> buildingFlags(int flags) {\n+        record WithFlagFieldHandler(int flags) implements Consumer<FieldBuilder> {\n+            @Override\n+            public void accept(FieldBuilder builder) {\n+                builder.withFlags(flags);\n+            }\n+        }\n+        return new WithFlagFieldHandler(flags);\n+    }\n+\n@@ -69,1 +105,1 @@\n-                                             final ClassFile.AttributesProcessingOption processingOption) {\n+                                             final ClassFileImpl context) {\n@@ -71,1 +107,1 @@\n-                ? ATTRIBUTE_STABILITY_COUNT - attr.attributeMapper().stability().ordinal() > processingOption.ordinal()\n+                ? ATTRIBUTE_STABILITY_COUNT - attr.attributeMapper().stability().ordinal() > context.attributesProcessingOption().ordinal()\n@@ -76,3 +112,5 @@\n-        int count = 0;\n-        for (int i = 0; i < mDesc.parameterCount(); i++) {\n-            count += slotSize(mDesc.parameterType(i));\n+        int count = mDesc.parameterCount();\n+        for (int i = count - 1; i >= 0; i--) {\n+            if (isDoubleSlot(mDesc.parameterType(i))) {\n+                count++;\n+            }\n@@ -88,1 +126,1 @@\n-            count += slotSize(mDesc.parameterType(i));\n+            count += paramSlotSize(mDesc.parameterType(i));\n@@ -94,5 +132,1 @@\n-        int count = ((flags & ACC_STATIC) != 0) ? 0 : 1;\n-        for (int i = 0; i < mDesc.parameterCount(); i++) {\n-            count += slotSize(mDesc.parameterType(i));\n-        }\n-        return count;\n+        return parameterSlots(mDesc) + ((flags & ACC_STATIC) == 0 ? 1 : 0) ;\n@@ -155,2 +189,6 @@\n-            throw new IllegalArgumentException(\n-                    String.format(\"Wrong opcode kind specified; found %s(%s), expected %s\", op, op.kind(), k));\n+            throw badOpcodeKindException(op, k);\n+    }\n+\n+    public static IllegalArgumentException badOpcodeKindException(Opcode op, Opcode.Kind k) {\n+        return new IllegalArgumentException(\n+                String.format(\"Wrong opcode kind specified; found %s(%s), expected %s\", op, op.kind(), k));\n@@ -194,1 +232,1 @@\n-    private static <T> void writeAttribute(BufWriterImpl writer, Attribute<?> attr) {\n+    private static <T extends Attribute<T>> void writeAttribute(BufWriterImpl writer, Attribute<?> attr) {\n@@ -219,5 +257,5 @@\n-        return switch (desc.descriptorString().charAt(0)) {\n-            case 'V' -> 0;\n-            case 'D','J' -> 2;\n-            default -> 1;\n-        };\n+        return desc == CD_void ? 0 : isDoubleSlot(desc) ? 2 : 1;\n+    }\n+\n+    public static int paramSlotSize(ClassDesc desc) {\n+        return isDoubleSlot(desc) ? 2 : 1;\n@@ -227,2 +265,1 @@\n-        char ch = desc.descriptorString().charAt(0);\n-        return ch == 'D' || ch == 'J';\n+        return desc == CD_double || desc == CD_long;\n@@ -236,1 +273,1 @@\n-                                  ByteBuffer bytecode,\n+                                  RawBytecodeHelper.CodeRange bytecode,\n@@ -249,2 +286,2 @@\n-                                    b.writeInt(bytecode.limit());\n-                                    b.writeBytes(bytecode.array(), 0, bytecode.limit());\n+                                    b.writeInt(bytecode.length());\n+                                    b.writeBytes(bytecode.array(), 0, bytecode.length());\n@@ -258,6 +295,8 @@\n-            bytecode.rewind();\n-            while (bytecode.position() < bytecode.limit()) {\n-                dump.accept(\"%n%04x:\".formatted(bytecode.position()));\n-                for (int i = 0; i < 16 && bytecode.position() < bytecode.limit(); i++) {\n-                    dump.accept(\" %02x\".formatted(bytecode.get()));\n-                }\n+            dumpBytesHex(dump, bytecode.array(), bytecode.length());\n+        }\n+    }\n+\n+    public static void dumpBytesHex(Consumer<String> dump, byte[] bytes, int length) {\n+        for (int i = 0; i < length; i++) {\n+            if (i % 16 == 0) {\n+                dump.accept(\"%n%04x:\".formatted(i));\n@@ -265,0 +304,1 @@\n+            dump.accept(\" %02x\".formatted(bytes[i]));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":71,"deletions":31,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,6 +233,6 @@\n-                    case BooleanType, ByteType, CharType, IntType, ShortType -> cve instanceof IntegerEntry;\n-                    case DoubleType -> cve instanceof DoubleEntry;\n-                    case FloatType -> cve instanceof FloatEntry;\n-                    case LongType -> cve instanceof LongEntry;\n-                    case ReferenceType -> type.equals(ConstantDescs.CD_String) && cve instanceof StringEntry;\n-                    case VoidType -> false;\n+                    case BOOLEAN, BYTE, CHAR, INT, SHORT -> cve instanceof IntegerEntry;\n+                    case DOUBLE -> cve instanceof DoubleEntry;\n+                    case FLOAT -> cve instanceof FloatEntry;\n+                    case LONG -> cve instanceof LongEntry;\n+                    case REFERENCE -> type.equals(ConstantDescs.CD_String) && cve instanceof StringEntry;\n+                    case VOID -> false;\n@@ -396,1 +396,1 @@\n-            l += 2 + an.targetInfo().size() + 2 * an.targetPath().size() + annotationSize(an);\n+            l += 2 + an.targetInfo().size() + 2 * an.targetPath().size() + annotationSize(an.annotation());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.nio.ByteBuffer;\n-\n@@ -30,0 +28,1 @@\n+\n@@ -86,4 +85,0 @@\n-    static int wide_length_for(int code) {\n-        return is_valid(code) ? _lengths[code] >> 4 : -1;\n-    }\n-\n@@ -96,32 +91,0 @@\n-    static int special_length_at(int code, byte bytecode[], int bci, int end) {\n-        switch (code) {\n-            case ClassFile.WIDE:\n-                if (bci + 1 >= end) {\n-                    return -1;\n-                }\n-                return wide_length_for(bytecode[bci + 1] & 0xff);\n-            case ClassFile.TABLESWITCH:\n-                int aligned_bci = align(bci + 1);\n-                if (aligned_bci + 3 * 4 >= end) {\n-                    return -1;\n-                }\n-                ByteBuffer bb = ByteBuffer.wrap(bytecode, aligned_bci + 1 * 4, 2 * 4);\n-                int lo = bb.getInt();\n-                int hi = bb.getInt();\n-                int len = aligned_bci - bci + (3 + hi - lo + 1) * 4;\n-                return len > 0 ? len : -1;\n-            case ClassFile.LOOKUPSWITCH:\n-            case _fast_binaryswitch:\n-            case _fast_linearswitch:\n-                aligned_bci = align(bci + 1);\n-                if (aligned_bci + 2 * 4 >= end) {\n-                    return -1;\n-                }\n-                int npairs = ByteBuffer.wrap(bytecode, aligned_bci + 4, 4).getInt();\n-                len = aligned_bci - bci + (2 + 2 * npairs) * 4;\n-                return len > 0 ? len : -1;\n-            default:\n-                return 0;\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationBytecodes.java","additions":1,"deletions":38,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -319,2 +318,2 @@\n-        var code = ByteBuffer.wrap(codeArray, 0, _method.codeLength());\n-        byte[] code_data = generate_code_data(code, code_length);\n+        var code = RawBytecodeHelper.of(codeArray);\n+        byte[] code_data = generate_code_data(code);\n@@ -327,1 +326,1 @@\n-        var bcs = new RawBytecodeHelper(code);\n+        var bcs = code.start();\n@@ -330,3 +329,3 @@\n-        while (!bcs.isLastBytecode()) {\n-            opcode = bcs.rawNext();\n-            bci = bcs.bci;\n+        while (bcs.next()) {\n+            opcode = bcs.opcode();\n+            bci = bcs.bci();\n@@ -343,1 +342,1 @@\n-                if (bcs.isWide) {\n+                if (bcs.isWide()) {\n@@ -1198,1 +1197,1 @@\n-                        int dim = _method.codeArray()[bcs.bci+3] & 0xff;\n+                        int dim = _method.codeArray()[bcs.bci() +3] & 0xff;\n@@ -1233,7 +1232,7 @@\n-    private byte[] generate_code_data(ByteBuffer code, int code_length) {\n-        byte code_data[] = new byte[code_length];\n-        var bcs = new RawBytecodeHelper(code);\n-        while (!bcs.isLastBytecode()) {\n-            if (bcs.rawNext() != ILLEGAL) {\n-                int bci = bcs.bci;\n-                if (bcs.rawCode == ClassFile.NEW) {\n+    private byte[] generate_code_data(RawBytecodeHelper.CodeRange code) {\n+        byte[] code_data = new byte[code.length()];\n+        var bcs = code.start();\n+        while (bcs.next()) {\n+            if (bcs.opcode() != ILLEGAL) {\n+                int bci = bcs.bci();\n+                if (bcs.opcode() == ClassFile.NEW) {\n@@ -1413,1 +1412,1 @@\n-        int bci = bcs.bci;\n+        int bci = bcs.bci();\n@@ -1425,1 +1424,1 @@\n-        int default_ofset = bcs.getInt(aligned_bci);\n+        int default_offset = bcs.getIntUnchecked(aligned_bci);\n@@ -1428,3 +1427,3 @@\n-        if (bcs.rawCode == ClassFile.TABLESWITCH) {\n-            int low = bcs.getInt(aligned_bci + 4);\n-            int high = bcs.getInt(aligned_bci + 2*4);\n+        if (bcs.opcode() == ClassFile.TABLESWITCH) {\n+            int low = bcs.getIntUnchecked(aligned_bci + 4);\n+            int high = bcs.getIntUnchecked(aligned_bci + 2*4);\n@@ -1441,1 +1440,1 @@\n-            keys = bcs.getInt(aligned_bci + 4);\n+            keys = bcs.getIntUnchecked(aligned_bci + 4);\n@@ -1447,2 +1446,2 @@\n-                int this_key = bcs.getInt(aligned_bci + (2+2*i)*4);\n-                int next_key = bcs.getInt(aligned_bci + (2+2*i+2)*4);\n+                int this_key = bcs.getIntUnchecked(aligned_bci + (2+2*i)*4);\n+                int next_key = bcs.getIntUnchecked(aligned_bci + (2+2*i+2)*4);\n@@ -1454,1 +1453,1 @@\n-        int target = bci + default_ofset;\n+        int target = bci + default_offset;\n@@ -1457,2 +1456,2 @@\n-            aligned_bci = VerificationBytecodes.align(bcs.bci + 1);\n-            target = bci + bcs.getInt(aligned_bci + (3+i*delta)*4);\n+            aligned_bci = VerificationBytecodes.align(bcs.bci() + 1);\n+            target = bci + bcs.getIntUnchecked(aligned_bci + (3+i*delta)*4);\n@@ -1465,1 +1464,1 @@\n-        verify_cp_type(bcs.bci, index, cp, 1 << JVM_CONSTANT_Fieldref);\n+        verify_cp_type(bcs.bci(), index, cp, 1 << JVM_CONSTANT_Fieldref);\n@@ -1480,1 +1479,1 @@\n-        switch (bcs.rawCode) {\n+        switch (bcs.opcode()) {\n@@ -1527,1 +1526,1 @@\n-        int bci = bcs.bci;\n+        int bci = bcs.bci();\n@@ -1555,1 +1554,1 @@\n-            int new_class_index = bcs.getIndexU2Raw(new_offset + 1);\n+            int new_class_index = bcs.getU2(new_offset + 1);\n@@ -1586,1 +1585,1 @@\n-        int opcode = bcs.rawCode;\n+        int opcode = bcs.opcode();\n@@ -1604,1 +1603,1 @@\n-        verify_cp_type(bcs.bci, index, cp, types);\n+        verify_cp_type(bcs.bci(), index, cp, types);\n@@ -1622,1 +1621,1 @@\n-        int bci = bcs.bci;\n+        int bci = bcs.bci();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":33,"deletions":34,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -38,0 +38,4 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import static jdk.internal.constant.PrimitiveClassDescImpl.*;\n+\n@@ -42,0 +46,2 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -67,1 +73,1 @@\n-        return ReferenceClassDescImpl.ofValidated(\"L\" + binaryToInternal(binaryName) + \";\");\n+        return ReferenceClassDescImpl.ofValidated(concat(\"L\", binaryToInternal(binaryName), \";\"));\n@@ -272,33 +278,13 @@\n-    \/**\n-     * Parses a method descriptor string, and return a list of field descriptor\n-     * strings, return type first, then parameter types\n-     *\n-     * @param descriptor the descriptor string\n-     * @return the list of types\n-     * @throws IllegalArgumentException if the descriptor string is not valid\n-     *\/\n-    public static List<ClassDesc> parseMethodDescriptor(String descriptor) {\n-        int cur = 0, end = descriptor.length();\n-        ArrayList<ClassDesc> ptypes = new ArrayList<>();\n-        ptypes.add(null); \/\/ placeholder for return type\n-\n-        if (cur >= end || descriptor.charAt(cur) != '(')\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-\n-        ++cur;  \/\/ skip '('\n-        while (cur < end && descriptor.charAt(cur) != ')') {\n-            int len = skipOverFieldSignature(descriptor, cur, end, false);\n-            if (len == 0)\n-                throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-            ptypes.add(resolveClassDesc(descriptor, cur, len));\n-            cur += len;\n-        }\n-        if (cur >= end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ++cur;  \/\/ skip ')'\n-\n-        int rLen = skipOverFieldSignature(descriptor, cur, end, true);\n-        if (rLen == 0 || cur + rLen != end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ptypes.set(0, resolveClassDesc(descriptor, cur, rLen));\n-        return ptypes;\n+    public static PrimitiveClassDescImpl forPrimitiveType(String descriptor, int offset) {\n+        return switch (descriptor.charAt(offset)) {\n+            case JVM_SIGNATURE_BYTE    -> CD_byte;\n+            case JVM_SIGNATURE_CHAR    -> CD_char;\n+            case JVM_SIGNATURE_FLOAT   -> CD_float;\n+            case JVM_SIGNATURE_DOUBLE  -> CD_double;\n+            case JVM_SIGNATURE_INT     -> CD_int;\n+            case JVM_SIGNATURE_LONG    -> CD_long;\n+            case JVM_SIGNATURE_SHORT   -> CD_short;\n+            case JVM_SIGNATURE_VOID    -> CD_void;\n+            case JVM_SIGNATURE_BOOLEAN -> CD_boolean;\n+            default -> throw badMethodDescriptor(descriptor);\n+        };\n@@ -307,1 +293,1 @@\n-    private static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n+    static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n@@ -309,1 +295,1 @@\n-            return Wrapper.forPrimitiveType(descriptor.charAt(start)).basicClassDescriptor();\n+            return forPrimitiveType(descriptor, start);\n@@ -311,1 +297,2 @@\n-        \/\/ Pre-verified in parseMethodDescriptor; avoid redundant verification\n+\n+        \/\/ Pre-verified in MethodTypeDescImpl#ofDescriptor; avoid redundant verification\n@@ -315,0 +302,4 @@\n+    static IllegalArgumentException badMethodDescriptor(String descriptor) {\n+        return new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+    }\n+\n@@ -319,2 +310,0 @@\n-    private static final char JVM_SIGNATURE_ENDCLASS = ';';\n-    private static final char JVM_SIGNATURE_ENUM = 'E';\n@@ -323,2 +312,0 @@\n-    private static final char JVM_SIGNATURE_FUNC = '(';\n-    private static final char JVM_SIGNATURE_ENDFUNC = ')';\n@@ -337,1 +324,0 @@\n-     * @param voidOK is void acceptable?\n@@ -341,2 +327,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n-    static int skipOverFieldSignature(String descriptor, int start, int end, boolean voidOK) {\n+    static int skipOverFieldSignature(String descriptor, int start, int end) {\n@@ -345,3 +330,10 @@\n-        while (index < end) {\n-            switch (descriptor.charAt(index)) {\n-                case JVM_SIGNATURE_VOID: if (!voidOK) { return 0; }\n+        if (index < end) {\n+            char ch;\n+            while ((ch = descriptor.charAt(index++)) == JVM_SIGNATURE_ARRAY) {\n+                arrayDim++;\n+            }\n+            if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+                throw maxArrayTypeDescDimensions();\n+            }\n+\n+            switch (ch) {\n@@ -356,1 +348,1 @@\n-                    return index - start + 1;\n+                    return index - start;\n@@ -361,2 +353,2 @@\n-                    while (++index < end) {\n-                        switch (descriptor.charAt(index)) {\n+                    while (index < end) {\n+                        switch (descriptor.charAt(index++)) {\n@@ -365,1 +357,1 @@\n-                                return legal ? index - start + 1 : 0;\n+                                return legal ? index - start : 0;\n@@ -380,10 +372,0 @@\n-                    return 0;\n-                case JVM_SIGNATURE_ARRAY:\n-                    arrayDim++;\n-                    if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-                        throw new IllegalArgumentException(String.format(\"Cannot create an array type descriptor with more than %d dimensions\",\n-                                ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n-                    }\n-                    \/\/ The rest of what's there better be a legal descriptor\n-                    index++;\n-                    voidOK = false;\n@@ -392,1 +374,1 @@\n-                    return 0;\n+                    break;\n@@ -397,0 +379,10 @@\n+\n+    private static IllegalArgumentException maxArrayTypeDescDimensions() {\n+        return new IllegalArgumentException(String.format(\n+                        \"Cannot create an array type descriptor with more than %d dimensions\",\n+                        ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n+    }\n+\n+    public static String concat(String prefix, Object value, String suffix) {\n+        return JLA.concat(prefix, value, suffix);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":54,"deletions":62,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -35,0 +37,1 @@\n+import java.util.ArrayList;\n@@ -41,0 +44,6 @@\n+import static jdk.internal.constant.ConstantUtils.badMethodDescriptor;\n+import static jdk.internal.constant.ConstantUtils.resolveClassDesc;\n+import static jdk.internal.constant.ConstantUtils.skipOverFieldSignature;\n+import static jdk.internal.constant.ConstantUtils.EMPTY_CLASSDESC;\n+import static jdk.internal.constant.PrimitiveClassDescImpl.CD_void;\n+\n@@ -94,1 +103,1 @@\n-            return new MethodTypeDescImpl(returnType, ConstantUtils.EMPTY_CLASSDESC);\n+            return new MethodTypeDescImpl(returnType, EMPTY_CLASSDESC);\n@@ -108,8 +117,17 @@\n-        \/\/ Implicit null-check of descriptor\n-        List<ClassDesc> ptypes = ConstantUtils.parseMethodDescriptor(descriptor);\n-        int args = ptypes.size() - 1;\n-        ClassDesc[] paramTypes = args > 0\n-                ? ptypes.subList(1, args + 1).toArray(ConstantUtils.EMPTY_CLASSDESC)\n-                : ConstantUtils.EMPTY_CLASSDESC;\n-\n-        MethodTypeDescImpl result = ofValidated(ptypes.get(0), paramTypes);\n+        int length = descriptor.length();\n+        int rightBracket, retTypeLength;\n+        if (descriptor.charAt(0) != '('\n+                || (rightBracket = (descriptor.charAt(1) == ')' ? 1 : descriptor.lastIndexOf(')'))) <= 0\n+                || (retTypeLength = length - rightBracket - 1) == 0\n+                || (retTypeLength != 1 \/\/ if retTypeLength == 1, check correctness in resolveClassDesc\n+                    && retTypeLength != skipOverFieldSignature(descriptor, rightBracket + 1, length))\n+        ) {\n+            throw badMethodDescriptor(descriptor);\n+        }\n+\n+        var returnType = resolveClassDesc(descriptor, rightBracket + 1, retTypeLength);\n+        if (length == 3 && returnType == CD_void) {\n+            return (MethodTypeDescImpl) ConstantDescs.MTD_void;\n+        }\n+        var paramTypes = paramTypes(descriptor, 1, rightBracket);\n+        var result = new MethodTypeDescImpl(returnType, paramTypes);\n@@ -120,0 +138,71 @@\n+    private static ClassDesc[] paramTypes(String descriptor, int start, int end) {\n+        if (start == end) {\n+            return EMPTY_CLASSDESC;\n+        }\n+\n+        \/*\n+         * If the length of the first 8 parameters is < 256, save them in lengths to avoid ArrayList allocation\n+         * Stop storing for the last parameter (we can compute length), or if too many parameters or too long.\n+         *\/\n+        \/\/ little endian storage - lowest byte is encoded length 0\n+        long packedLengths = 0;\n+        int packedCount = 0;\n+        int cur = start;\n+        while (cur < end) {\n+            int len = skipOverFieldSignature(descriptor, cur, end);\n+            if (len == 0) {\n+                throw badMethodDescriptor(descriptor);\n+            }\n+            cur += len;\n+            if (len > 0xFF || packedCount >= Long.SIZE \/ Byte.SIZE || cur == end) {\n+                \/\/ Cannot or do not have to pack this item, but is already scanned and valid\n+                break;\n+            }\n+            packedLengths = packedLengths | (((long) len) << (Byte.SIZE * packedCount++));\n+        }\n+\n+        \/\/ Invariant: packedCount parameters encoded in packedLengths,\n+        \/\/ And another valid parameter pointed by cur\n+\n+        \/\/ Recover encoded elements\n+        ClassDesc[]     paramTypes    = null;\n+        List<ClassDesc> paramTypeList = null;\n+        if (cur == end) {\n+            paramTypes = new ClassDesc[packedCount + 1];\n+        } else {\n+            paramTypeList = new ArrayList<>(32);\n+        }\n+\n+        int last = start;\n+        for (int i = 0; i < packedCount; i++) {\n+            int len = Byte.toUnsignedInt((byte) (packedLengths >> (Byte.SIZE * i)));\n+            var cd = resolveClassDesc(descriptor, last, len);\n+            if (paramTypes != null) {\n+                paramTypes[i] = cd;\n+            } else {\n+                paramTypeList.add(cd);\n+            }\n+            last += len;\n+        }\n+        var lastCd = resolveClassDesc(descriptor, last, cur - last);\n+\n+        if (paramTypes != null) {\n+            paramTypes[packedCount] = lastCd;\n+            return paramTypes;\n+        }\n+        paramTypeList.add(lastCd);\n+        return buildParamTypes(descriptor, cur, end, paramTypeList);\n+    }\n+\n+    \/\/ slow path\n+    private static ClassDesc[] buildParamTypes(String descriptor, int cur, int end, List<ClassDesc> list) {\n+        while (cur < end) {\n+            int len = skipOverFieldSignature(descriptor, cur, end);\n+            if (len == 0)\n+                throw badMethodDescriptor(descriptor);\n+            list.add(resolveClassDesc(descriptor, cur, len));\n+            cur += len;\n+        }\n+\n+        return list.toArray(EMPTY_CLASSDESC);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":98,"deletions":9,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -43,0 +44,27 @@\n+    \/** {@link ClassDesc} representing the primitive type {@code int} *\/\n+    public static final PrimitiveClassDescImpl CD_int = new PrimitiveClassDescImpl(\"I\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code long} *\/\n+    public static final PrimitiveClassDescImpl CD_long = new PrimitiveClassDescImpl(\"J\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code float} *\/\n+    public static final PrimitiveClassDescImpl CD_float = new PrimitiveClassDescImpl(\"F\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code double} *\/\n+    public static final PrimitiveClassDescImpl CD_double = new PrimitiveClassDescImpl(\"D\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code short} *\/\n+    public static final PrimitiveClassDescImpl CD_short = new PrimitiveClassDescImpl(\"S\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code byte} *\/\n+    public static final PrimitiveClassDescImpl CD_byte = new PrimitiveClassDescImpl(\"B\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code char} *\/\n+    public static final PrimitiveClassDescImpl CD_char = new PrimitiveClassDescImpl(\"C\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code boolean} *\/\n+    public static final PrimitiveClassDescImpl CD_boolean = new PrimitiveClassDescImpl(\"Z\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code void} *\/\n+    public static final PrimitiveClassDescImpl CD_void = new PrimitiveClassDescImpl(\"V\");\n+\n@@ -44,0 +72,1 @@\n+    private @Stable Wrapper lazyWrapper; \/\/ initialized only after this\n@@ -55,1 +84,1 @@\n-    public PrimitiveClassDescImpl(String descriptor) {\n+    private PrimitiveClassDescImpl(String descriptor) {\n@@ -57,3 +86,0 @@\n-        if (descriptor.length() != 1\n-            || \"VIJCSBFDZ\".indexOf(descriptor.charAt(0)) < 0)\n-            throw new IllegalArgumentException(String.format(\"not a valid primitive type descriptor: %s\", descriptor));\n@@ -63,0 +89,7 @@\n+    public Wrapper wrapper() {\n+        var wrapper = this.lazyWrapper;\n+        if (wrapper != null)\n+            return wrapper;\n+        return this.lazyWrapper = Wrapper.forBasicType(descriptorString().charAt(0));\n+    }\n+\n@@ -70,1 +103,1 @@\n-        return Wrapper.forBasicType(descriptorString().charAt(0)).primitiveType();\n+        return wrapper().primitiveType();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/PrimitiveClassDescImpl.java","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen, false);\n+        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen);\n@@ -69,1 +69,1 @@\n-        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length(), false)\n+        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length())\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ReferenceClassDescImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,9 +33,0 @@\n-    private static final ThreadSleepEvent EVENT = new ThreadSleepEvent();\n-\n-    \/**\n-     * Returns {@code true} if event is enabled, {@code false} otherwise.\n-     *\/\n-    public static boolean isTurnedOn() {\n-        return EVENT.isEnabled();\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/ThreadSleepEvent.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import jdk.internal.util.Architecture;\n@@ -155,1 +156,1 @@\n-        Reflection.ensureNativeAccess(callerClass, MemorySegment.class, \"reinterpret\");\n+        Reflection.ensureNativeAccess(callerClass, MemorySegment.class, \"reinterpret\", false);\n@@ -191,0 +192,4 @@\n+    \/\/ FILL_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n+    \/\/ Update the value for Aarch64 once 8338975 is fixed.\n+    private static final long FILL_NATIVE_THRESHOLD = 1L << (Architecture.isAARCH64() ? 10 : 5);\n+\n@@ -192,3 +197,41 @@\n-    public final MemorySegment fill(byte value){\n-        checkAccess(0, length, false);\n-        SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n+    @ForceInline\n+    public final MemorySegment fill(byte value) {\n+        checkReadOnly(false);\n+        if (length == 0) {\n+            \/\/ Implicit state check\n+            checkValidState();\n+        } else if (length < FILL_NATIVE_THRESHOLD) {\n+            \/\/ 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+\n+            \/\/ Handle smaller segments directly without transitioning to native code\n+            final long u = Byte.toUnsignedLong(value);\n+            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+\n+            int offset = 0;\n+            \/\/ 0...0X...X000\n+            final int limit = (int) (length & (FILL_NATIVE_THRESHOLD - 8));\n+            for (; offset < limit; offset += 8) {\n+                SCOPED_MEMORY_ACCESS.putLong(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, longValue);\n+            }\n+            int remaining = (int) length - limit;\n+            \/\/ 0...0X00\n+            if (remaining >= 4) {\n+                SCOPED_MEMORY_ACCESS.putInt(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (int) longValue);\n+                offset += 4;\n+                remaining -= 4;\n+            }\n+            \/\/ 0...00X0\n+            if (remaining >= 2) {\n+                SCOPED_MEMORY_ACCESS.putShort(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (short) longValue);\n+                offset += 2;\n+                remaining -= 2;\n+            }\n+            \/\/ 0...000X\n+            if (remaining == 1) {\n+                SCOPED_MEMORY_ACCESS.putByte(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, value);\n+            }\n+            \/\/ We have now fully handled 0...0X...XXXX\n+        } else {\n+            \/\/ Handle larger segments via native calls\n+            SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n+        }\n@@ -264,2 +307,12 @@\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);\n-        if (unsafeGetBase() == that.unsafeGetBase()) {  \/\/ both either native or heap\n+        final AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);\n+        if (overlaps(that)) {\n+            final long offsetToThat = that.address() - this.address();\n+            final long newOffset = offsetToThat >= 0 ? offsetToThat : 0;\n+            return Optional.of(asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @ForceInline\n+    private boolean overlaps(AbstractMemorySegmentImpl that) {\n+        if (unsafeGetBase() == that.unsafeGetBase()) {  \/\/ both either native or the same heap segment\n@@ -270,6 +323,1 @@\n-\n-            if (thisStart < thatEnd && thisEnd > thatStart) {  \/\/overlap occurs\n-                long offsetToThat = that.address() - this.address();\n-                long newOffset = offsetToThat >= 0 ? offsetToThat : 0;\n-                return Optional.of(asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat)));\n-            }\n+            return (thisStart < thatEnd && thisEnd > thatStart); \/\/overlap occurs?\n@@ -277,1 +325,1 @@\n-        return Optional.empty();\n+        return false;\n@@ -376,0 +424,10 @@\n+    @ForceInline\n+    public final void checkEnclosingLayout(long offset, MemoryLayout enclosing, boolean readOnly) {\n+        checkAccess(offset, enclosing.byteSize(), readOnly);\n+        if (!isAlignedForElement(offset, enclosing)) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Target offset %d is incompatible with alignment constraint %d (of %s) for segment %s\"\n+                    , offset, enclosing.byteAlignment(), enclosing, this));\n+        }\n+    }\n+\n@@ -595,0 +653,58 @@\n+    \/\/ COPY_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n+    private static final long COPY_NATIVE_THRESHOLD = 1 << 6;\n+\n+    @ForceInline\n+    public static void copy(AbstractMemorySegmentImpl src, long srcOffset,\n+                            AbstractMemorySegmentImpl dst, long dstOffset,\n+                            long size) {\n+\n+        Utils.checkNonNegativeIndex(size, \"size\");\n+        \/\/ Implicit null check for src and dst\n+        src.checkAccess(srcOffset, size, true);\n+        dst.checkAccess(dstOffset, size, false);\n+\n+        if (size <= 0) {\n+            \/\/ Do nothing\n+        } else if (size < COPY_NATIVE_THRESHOLD && !src.overlaps(dst)) {\n+            \/\/ 0 < size < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+            \/\/\n+            \/\/ Strictly, we could check for !src.asSlice(srcOffset, size).overlaps(dst.asSlice(dstOffset, size) but\n+            \/\/ this is a bit slower and it likely very unusual there is any difference in the outcome. Also, if there\n+            \/\/ is an overlap, we could tolerate one particular direction of overlap (but not the other).\n+\n+            \/\/ 0...0X...X000\n+            final int limit = (int) (size & (COPY_NATIVE_THRESHOLD - 8));\n+            int offset = 0;\n+            for (; offset < limit; offset += 8) {\n+                final long v = SCOPED_MEMORY_ACCESS.getLong(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n+                SCOPED_MEMORY_ACCESS.putLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n+            }\n+            int remaining = (int) size - offset;\n+            \/\/ 0...0X00\n+            if (remaining >= 4) {\n+                final int v = SCOPED_MEMORY_ACCESS.getInt(src.sessionImpl(), src.unsafeGetBase(),src.unsafeGetOffset() + srcOffset + offset);\n+                SCOPED_MEMORY_ACCESS.putInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n+                offset += 4;\n+                remaining -= 4;\n+            }\n+            \/\/ 0...00X0\n+            if (remaining >= 2) {\n+                final short v = SCOPED_MEMORY_ACCESS.getShort(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n+                SCOPED_MEMORY_ACCESS.putShort(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n+                offset += 2;\n+                remaining -=2;\n+            }\n+            \/\/ 0...000X\n+            if (remaining == 1) {\n+                final byte v = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n+                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n+            }\n+            \/\/ We have now fully handled 0...0X...XXXX\n+        } else {\n+            \/\/ For larger sizes, the transition to native code pays off\n+            SCOPED_MEMORY_ACCESS.copyMemory(src.sessionImpl(), dst.sessionImpl(),\n+                    src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset,\n+                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, size);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":129,"deletions":13,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    private static final MethodHandle MH_ADD;\n+    private static final MethodHandle MH_ADD_EXACT;\n@@ -83,2 +83,2 @@\n-                    MethodType.methodType(MemorySegment.class, MemorySegment.class, MemoryLayout.class));\n-            MH_ADD = lookup.findStatic(Long.class, \"sum\",\n+                    MethodType.methodType(MemorySegment.class, MemorySegment.class));\n+            MH_ADD_EXACT = lookup.findStatic(Math.class, \"addExact\",\n@@ -183,2 +183,1 @@\n-        handle = MethodHandles.filterReturnValue(handle,\n-                MethodHandles.insertArguments(MH_SEGMENT_RESIZE, 1, derefLayout));\n+        handle = MethodHandles.filterReturnValue(handle, MH_SEGMENT_RESIZE);\n@@ -188,2 +187,4 @@\n-    private static MemorySegment resizeSegment(MemorySegment segment, MemoryLayout layout) {\n-        return Utils.longToAddress(segment.address(), layout.byteSize(), layout.byteAlignment());\n+    private static MemorySegment resizeSegment(MemorySegment segment) {\n+        \/\/ Avoid adapting for specific target layout. The check for the root layout\n+        \/\/ size and alignment will be inserted by LayoutPath::dereferenceHandle anyway.\n+        return Utils.longToAddress(segment.address(), Long.MAX_VALUE, 1);\n@@ -208,13 +209,9 @@\n-        VarHandle handle = Utils.makeRawSegmentViewVarHandle(valueLayout);\n-        handle = MethodHandles.collectCoordinates(handle, 1, offsetHandle());\n-\n-        \/\/ we only have to check the alignment of the root layout for the first dereference we do,\n-        \/\/ as each dereference checks the alignment of the target address when constructing its segment\n-        \/\/ (see Utils::longToAddress)\n-        if (derefAdapters.length == 0) {\n-            \/\/ insert align check for the root layout on the initial MS + offset\n-            List<Class<?>> coordinateTypes = handle.coordinateTypes();\n-            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ENCL_LAYOUT, 2, rootLayout());\n-            handle = MethodHandles.collectCoordinates(handle, 0, alignCheck);\n-            int[] reorder = IntStream.concat(IntStream.of(0, 1), IntStream.range(0, coordinateTypes.size())).toArray();\n-            handle = MethodHandles.permuteCoordinates(handle, coordinateTypes, reorder);\n+        VarHandle handle = Utils.makeRawSegmentViewVarHandle(valueLayout);              \/\/ (MS, ML, long, long)\n+        handle = MethodHandles.insertCoordinates(handle, 1, rootLayout());          \/\/ (MS, long, long)\n+        if (strides.length > 0) {\n+            MethodHandle offsetAdapter = offsetHandle();\n+            offsetAdapter = MethodHandles.insertArguments(offsetAdapter, 0, 0L);\n+            handle = MethodHandles.collectCoordinates(handle, 2, offsetAdapter);    \/\/ (MS, long)\n+        } else {\n+            \/\/ simpler adaptation\n+            handle = MethodHandles.insertCoordinates(handle, 2, offset);            \/\/ (MS, long)\n@@ -244,0 +241,2 @@\n+        \/\/ note: the below can overflow, depending on 'base'. When constructing var handles\n+        \/\/ through the layout API, this is never the case, as the injected 'base' is always 0.\n@@ -248,1 +247,1 @@\n-        MethodHandle mh = MethodHandles.insertArguments(MH_ADD, 0, offset);\n+        MethodHandle mh = MH_ADD_EXACT;\n@@ -251,3 +250,7 @@\n-            \/\/ (J, ...) -> J to (J, J, ...) -> J\n-            \/\/ i.e. new coord is prefixed. Last coord will correspond to innermost layout\n-            mh = MethodHandles.collectArguments(mh, 0, collector);\n+            \/\/ (J, J, ...) -> J to (J, J, J, ...) -> J\n+            \/\/ 1. the leading argument is the base offset (externally provided).\n+            \/\/ 2. index arguments are added. The last index correspond to the innermost layout.\n+            \/\/ 3. overflow can only occur at the outermost layer, due to the final addition with the base offset.\n+            \/\/ This is because the layout API ensures (by construction) that all offsets generated from layout paths\n+            \/\/ are always < Long.MAX_VALUE.\n+            mh = MethodHandles.collectArguments(mh, 1, collector);\n@@ -255,2 +258,1 @@\n-\n-        return mh;\n+        return MethodHandles.insertArguments(mh, 1, offset);\n@@ -288,6 +290,1 @@\n-        ((AbstractMemorySegmentImpl)segment).checkAccess(offset, enclosing.byteSize(), true);\n-        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(offset, enclosing)) {\n-            throw new IllegalArgumentException(String.format(\n-                    \"Target offset %d is incompatible with alignment constraint %d (of %s) for segment %s\"\n-                    , offset, enclosing.byteAlignment(), enclosing, segment));\n-        }\n+        ((AbstractMemorySegmentImpl)segment).checkEnclosingLayout(offset, enclosing, true);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":29,"deletions":32,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -75,1 +75,2 @@\n-            SCOPED_MEMORY_ACCESS.load(sessionImpl(), min, unmapper.isSync(), length);\n+            SCOPED_MEMORY_ACCESS.load(sessionImpl(), NIO_ACCESS.mappedMemoryUtils(),\n+                    min, unmapper.isSync(), length);\n@@ -81,1 +82,2 @@\n-            SCOPED_MEMORY_ACCESS.unload(sessionImpl(), min, unmapper.isSync(), length);\n+            SCOPED_MEMORY_ACCESS.unload(sessionImpl(), NIO_ACCESS.mappedMemoryUtils(),\n+                    min, unmapper.isSync(), length);\n@@ -86,1 +88,3 @@\n-        return unmapper == null || SCOPED_MEMORY_ACCESS.isLoaded(sessionImpl(), min, unmapper.isSync(), length);\n+        return unmapper == null ||\n+                SCOPED_MEMORY_ACCESS.isLoaded(sessionImpl(),\n+                        NIO_ACCESS.mappedMemoryUtils(), min, unmapper.isSync(), length);\n@@ -91,1 +95,2 @@\n-            SCOPED_MEMORY_ACCESS.force(sessionImpl(), unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n+            SCOPED_MEMORY_ACCESS.force(sessionImpl(), NIO_ACCESS.mappedMemoryUtils(),\n+                    unmapper.fileDescriptor(), min, unmapper.isSync(), 0, length);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-    private static final MethodHandle LONG_TO_ADDRESS;\n+    private static final MethodHandle LONG_TO_ADDRESS_TARGET;\n+    private static final MethodHandle LONG_TO_ADDRESS_NO_TARGET;\n@@ -77,2 +78,4 @@\n-            LONG_TO_ADDRESS = lookup.findStatic(Utils.class, \"longToAddress\",\n-                    MethodType.methodType(MemorySegment.class, long.class, long.class, long.class));\n+            LONG_TO_ADDRESS_TARGET = lookup.findStatic(Utils.class, \"longToAddress\",\n+                    MethodType.methodType(MemorySegment.class, long.class, AddressLayout.class));\n+            LONG_TO_ADDRESS_NO_TARGET = lookup.findStatic(Utils.class, \"longToAddress\",\n+                    MethodType.methodType(MemorySegment.class, long.class));\n@@ -132,5 +135,4 @@\n-            handle = MethodHandles.filterValue(handle,\n-                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemorySegment.class)),\n-                    MethodHandles.explicitCastArguments(MethodHandles.insertArguments(LONG_TO_ADDRESS, 1,\n-                                    pointeeByteSize(addressLayout), pointeeByteAlign(addressLayout)),\n-                            MethodType.methodType(MemorySegment.class, baseCarrier)));\n+            MethodHandle longToAddressAdapter = addressLayout.targetLayout().isPresent() ?\n+                    MethodHandles.insertArguments(LONG_TO_ADDRESS_TARGET, 1, addressLayout) :\n+                    LONG_TO_ADDRESS_NO_TARGET;\n+            handle = MethodHandles.filterValue(handle, ADDRESS_TO_LONG, longToAddressAdapter);\n@@ -149,0 +151,10 @@\n+    @ForceInline\n+    public static MemorySegment longToAddress(long addr) {\n+        return longToAddress(addr, 0, 1);\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment longToAddress(long addr, AddressLayout layout) {\n+        return longToAddress(addr, pointeeByteSize(layout), pointeeByteAlign(layout));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\");\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\", false);\n@@ -91,1 +91,1 @@\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\");\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\", false);\n@@ -118,1 +118,1 @@\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"upcallStub\");\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"upcallStub\", false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-                    int scopeLocal = cb.allocateLocal(ReferenceType);\n+                    int scopeLocal = cb.allocateLocal(REFERENCE);\n@@ -279,1 +279,1 @@\n-                    cb.storeLocal(ReferenceType, scopeLocal); \/\/ need to initialize all scope locals here in case an exception occurs\n+                    cb.storeLocal(REFERENCE, scopeLocal); \/\/ need to initialize all scope locals here in case an exception occurs\n@@ -295,2 +295,2 @@\n-        contextIdx = cb.allocateLocal(ReferenceType);\n-        cb.storeLocal(ReferenceType, contextIdx);\n+        contextIdx = cb.allocateLocal(REFERENCE);\n+        cb.storeLocal(REFERENCE, contextIdx);\n@@ -303,2 +303,2 @@\n-            returnBufferIdx = cb.allocateLocal(ReferenceType);\n-            cb.storeLocal(ReferenceType, returnBufferIdx);\n+            returnBufferIdx = cb.allocateLocal(REFERENCE);\n+            cb.storeLocal(REFERENCE, returnBufferIdx);\n@@ -327,1 +327,1 @@\n-                    cb.loadLocal(ReferenceType, returnBufferIdx);\n+                    cb.loadLocal(REFERENCE, returnBufferIdx);\n@@ -342,2 +342,2 @@\n-                    returnBufferIdx = cb.allocateLocal(ReferenceType);\n-                    cb.storeLocal(ReferenceType, returnBufferIdx);\n+                    returnBufferIdx = cb.allocateLocal(REFERENCE);\n+                    cb.storeLocal(REFERENCE, returnBufferIdx);\n@@ -358,1 +358,1 @@\n-            cb.loadLocal(ReferenceType, 0); \/\/ load target arg\n+            cb.loadLocal(REFERENCE, 0); \/\/ load target arg\n@@ -509,1 +509,1 @@\n-            cb.loadLocal(ReferenceType, scopeSlots[i]);\n+            cb.loadLocal(REFERENCE, scopeSlots[i]);\n@@ -518,1 +518,1 @@\n-        cb.storeLocal(ReferenceType, nextScopeLocal); \/\/ store off one to release later\n+        cb.storeLocal(REFERENCE, nextScopeLocal); \/\/ store off one to release later\n@@ -532,1 +532,1 @@\n-            cb.loadLocal(ReferenceType, scopeLocal);\n+            cb.loadLocal(REFERENCE, scopeLocal);\n@@ -534,1 +534,1 @@\n-                ifCb.loadLocal(ReferenceType, scopeLocal);\n+                ifCb.loadLocal(REFERENCE, scopeLocal);\n@@ -554,1 +554,1 @@\n-        cb.loadLocal(ReferenceType, contextIdx);\n+        cb.loadLocal(REFERENCE, contextIdx);\n@@ -562,1 +562,1 @@\n-        cb.loadLocal(ReferenceType, contextIdx);\n+        cb.loadLocal(REFERENCE, contextIdx);\n@@ -567,1 +567,1 @@\n-        cb.loadLocal(ReferenceType, contextIdx);\n+        cb.loadLocal(REFERENCE, contextIdx);\n@@ -588,1 +588,1 @@\n-            cb.loadLocal(ReferenceType, returnAllocatorIdx);\n+            cb.loadLocal(REFERENCE, returnAllocatorIdx);\n@@ -621,4 +621,4 @@\n-            int longValueIdx = cb.allocateLocal(LongType);\n-            cb.storeLocal(LongType, longValueIdx);\n-            int writeAddrIdx = cb.allocateLocal(ReferenceType);\n-            cb.storeLocal(ReferenceType, writeAddrIdx);\n+            int longValueIdx = cb.allocateLocal(LONG);\n+            cb.storeLocal(LONG, longValueIdx);\n+            int writeAddrIdx = cb.allocateLocal(REFERENCE);\n+            cb.storeLocal(REFERENCE, writeAddrIdx);\n@@ -651,1 +651,1 @@\n-                cb.loadLocal(LongType, longValueIdx);\n+                cb.loadLocal(LONG, longValueIdx);\n@@ -665,1 +665,1 @@\n-                cb.loadLocal(ReferenceType, writeAddrIdx);\n+                cb.loadLocal(REFERENCE, writeAddrIdx);\n@@ -697,1 +697,1 @@\n-                cb.loadLocal(ReferenceType, returnBufferIdx);\n+                cb.loadLocal(REFERENCE, returnBufferIdx);\n@@ -717,1 +717,1 @@\n-                cb.loadLocal(ReferenceType, returnBufferIdx);\n+                cb.loadLocal(REFERENCE, returnBufferIdx);\n@@ -817,2 +817,2 @@\n-            int readAddrIdx = cb.allocateLocal(ReferenceType);\n-            cb.storeLocal(ReferenceType, readAddrIdx);\n+            int readAddrIdx = cb.allocateLocal(REFERENCE);\n+            cb.storeLocal(REFERENCE, readAddrIdx);\n@@ -821,2 +821,2 @@\n-            int resultIdx = cb.allocateLocal(LongType);\n-            cb.storeLocal(LongType, resultIdx);\n+            int resultIdx = cb.allocateLocal(LONG);\n+            cb.storeLocal(LONG, resultIdx);\n@@ -851,1 +851,1 @@\n-                cb.loadLocal(ReferenceType, readAddrIdx);\n+                cb.loadLocal(REFERENCE, readAddrIdx);\n@@ -866,1 +866,1 @@\n-                cb.loadLocal(LongType, resultIdx);\n+                cb.loadLocal(LONG, resultIdx);\n@@ -868,1 +868,1 @@\n-                cb.storeLocal(LongType, resultIdx);\n+                cb.storeLocal(LONG, resultIdx);\n@@ -874,1 +874,1 @@\n-            cb.loadLocal(LongType, resultIdx);\n+            cb.loadLocal(LONG, resultIdx);\n@@ -900,2 +900,2 @@\n-        int storeIdx = cb.allocateLocal(ReferenceType);\n-        cb.storeLocal(ReferenceType, storeIdx);\n+        int storeIdx = cb.allocateLocal(REFERENCE);\n+        cb.storeLocal(REFERENCE, storeIdx);\n@@ -906,1 +906,1 @@\n-        cb.loadLocal(ReferenceType, storeIdx);\n+        cb.loadLocal(REFERENCE, storeIdx);\n@@ -985,5 +985,5 @@\n-            case BooleanType, ByteType, ShortType, CharType, IntType -> cb.iconst_0();\n-            case LongType -> cb.lconst_0();\n-            case FloatType -> cb.fconst_0();\n-            case DoubleType -> cb.dconst_0();\n-            case ReferenceType -> cb.aconst_null();\n+            case BOOLEAN, BYTE, SHORT, CHAR, INT -> cb.iconst_0();\n+            case LONG -> cb.lconst_0();\n+            case FLOAT -> cb.fconst_0();\n+            case DOUBLE -> cb.dconst_0();\n+            case REFERENCE -> cb.aconst_null();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":42,"deletions":42,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-            Reflection.ensureNativeAccess(Reflection.getCallerClass(), AddressLayout.class, \"withTargetLayout\");\n+            Reflection.ensureNativeAccess(Reflection.getCallerClass(), AddressLayout.class, \"withTargetLayout\", false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+                    @SuppressWarnings(\"restricted\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/NativeImageBuffer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.io.InterruptedIOException;\n@@ -90,18 +89,0 @@\n-\n-        \/\/ This code has been uglified to protect against interrupts.\n-        \/\/ Even if a thread has been interrupted when loading resources,\n-        \/\/ the IO should not abort, so must carefully retry, failing only\n-        \/\/ if the retry leads to some other IO exception.\n-\n-        boolean isInterrupted = Thread.interrupted();\n-        int len;\n-        for (;;) {\n-            try {\n-                len = getContentLength();\n-                break;\n-            } catch (InterruptedIOException iioe) {\n-                Thread.interrupted();\n-                isInterrupted = true;\n-            }\n-        }\n-\n@@ -109,0 +90,1 @@\n+            int len = getContentLength();\n@@ -124,7 +106,1 @@\n-                int cc = 0;\n-                try {\n-                    cc = in.read(b, pos, bytesToRead);\n-                } catch (InterruptedIOException iioe) {\n-                    Thread.interrupted();\n-                    isInterrupted = true;\n-                }\n+                int cc = in.read(b, pos, bytesToRead);\n@@ -146,2 +122,0 @@\n-            } catch (InterruptedIOException iioe) {\n-                isInterrupted = true;\n@@ -149,4 +123,0 @@\n-\n-            if (isInterrupted) {\n-                Thread.currentThread().interrupt();\n-            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/Resource.java","additions":3,"deletions":33,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,0 @@\n-import java.util.zip.ZipEntry;\n@@ -442,1 +441,2 @@\n-            Loader loader;\n+            Loader loader = null;\n+            final URL[] loaderClassPathURLs;\n@@ -447,4 +447,1 @@\n-                URL[] urls = loader.getClassPath();\n-                if (urls != null) {\n-                    push(urls);\n-                }\n+                loaderClassPathURLs = loader.getClassPath();\n@@ -452,1 +449,8 @@\n-                \/\/ Silently ignore for now...\n+                \/\/ log the error and close the unusable loader (if any)\n+                if (DEBUG) {\n+                    System.err.println(\"Failed to construct a loader or construct its\" +\n+                            \" local classpath for \" + url + \", cause:\" + e);\n+                }\n+                if (loader != null) {\n+                    closeQuietly(loader);\n+                }\n@@ -455,3 +459,3 @@\n-                \/\/ Always silently ignore. The context, if there is one, that\n-                \/\/ this URLClassPath was given during construction will never\n-                \/\/ have permission to access the URL.\n+                \/\/ log the error and close the unusable loader (if any).\n+                \/\/ The context, if there is one, that this URLClassPath was\n+                \/\/ given during construction will never have permission to access the URL.\n@@ -461,0 +465,3 @@\n+                if (loader != null) {\n+                    closeQuietly(loader);\n+                }\n@@ -463,0 +470,3 @@\n+            if (loaderClassPathURLs != null) {\n+                push(loaderClassPathURLs);\n+            }\n@@ -470,0 +480,11 @@\n+    \/\/ closes the given loader and ignores any IOException that may occur during close\n+    private static void closeQuietly(final Loader loader) {\n+        try {\n+            loader.close();\n+        } catch (IOException ioe) {\n+            if (DEBUG) {\n+                System.err.println(\"ignoring exception \" + ioe + \" while closing loader \" + loader);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.access.foreign.MappedMemoryUtilsProxy;\n@@ -240,1 +241,1 @@\n-    public boolean isLoaded(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public boolean isLoaded(MemorySessionImpl session, MappedMemoryUtilsProxy mappedUtils, long address, boolean isSync, long size) {\n@@ -242,1 +243,1 @@\n-            return isLoadedInternal(session, address, isSync, size);\n+            return isLoadedInternal(session, mappedUtils, address, isSync, size);\n@@ -249,1 +250,1 @@\n-    public boolean isLoadedInternal(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public boolean isLoadedInternal(MemorySessionImpl session, MappedMemoryUtilsProxy mappedUtils, long address, boolean isSync, long size) {\n@@ -254,1 +255,1 @@\n-            return SharedSecrets.getJavaNioAccess().isLoaded(address, isSync, size);\n+            return mappedUtils.isLoaded(address, isSync, size);\n@@ -261,1 +262,1 @@\n-    public void load(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public void load(MemorySessionImpl session, MappedMemoryUtilsProxy mappedUtils, long address, boolean isSync, long size) {\n@@ -263,1 +264,1 @@\n-            loadInternal(session, address, isSync, size);\n+            loadInternal(session, mappedUtils, address, isSync, size);\n@@ -270,1 +271,1 @@\n-    public void loadInternal(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public void loadInternal(MemorySessionImpl session, MappedMemoryUtilsProxy mappedUtils, long address, boolean isSync, long size) {\n@@ -275,1 +276,1 @@\n-            SharedSecrets.getJavaNioAccess().load(address, isSync, size);\n+            mappedUtils.load(address, isSync, size);\n@@ -282,1 +283,1 @@\n-    public void unload(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public void unload(MemorySessionImpl session, MappedMemoryUtilsProxy mappedUtils, long address, boolean isSync, long size) {\n@@ -284,1 +285,1 @@\n-            unloadInternal(session, address, isSync, size);\n+            unloadInternal(session, mappedUtils, address, isSync, size);\n@@ -291,1 +292,1 @@\n-    public void unloadInternal(MemorySessionImpl session, long address, boolean isSync, long size) {\n+    public void unloadInternal(MemorySessionImpl session, MappedMemoryUtilsProxy mappedUtils, long address, boolean isSync, long size) {\n@@ -296,1 +297,1 @@\n-            SharedSecrets.getJavaNioAccess().unload(address, isSync, size);\n+            mappedUtils.unload(address, isSync, size);\n@@ -303,1 +304,1 @@\n-    public void force(MemorySessionImpl session, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+    public void force(MemorySessionImpl session, MappedMemoryUtilsProxy mappedUtils, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n@@ -305,1 +306,1 @@\n-            forceInternal(session, fd, address, isSync, index, length);\n+            forceInternal(session, mappedUtils, fd, address, isSync, index, length);\n@@ -312,1 +313,1 @@\n-    public void forceInternal(MemorySessionImpl session, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n+    public void forceInternal(MemorySessionImpl session, MappedMemoryUtilsProxy mappedUtils, FileDescriptor fd, long address, boolean isSync, long index, long length) {\n@@ -317,1 +318,1 @@\n-            SharedSecrets.getJavaNioAccess().force(fd, address, isSync, index, length);\n+            mappedUtils.force(fd, address, isSync, index, length);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -790,1 +790,0 @@\n-    private static final boolean HAS_ENABLE_NATIVE_ACCESS_FLAG;\n@@ -793,0 +792,1 @@\n+    private static final IllegalNativeAccess ILLEGAL_NATIVE_ACCESS;\n@@ -794,2 +794,8 @@\n-    public static boolean hasEnableNativeAccessFlag() {\n-        return HAS_ENABLE_NATIVE_ACCESS_FLAG;\n+    public enum IllegalNativeAccess {\n+        ALLOW,\n+        WARN,\n+        DENY\n+    }\n+\n+    public static IllegalNativeAccess illegalNativeAccess() {\n+        return ILLEGAL_NATIVE_ACCESS;\n@@ -799,0 +805,1 @@\n+        ILLEGAL_NATIVE_ACCESS = addIllegalNativeAccess();\n@@ -800,1 +807,0 @@\n-        HAS_ENABLE_NATIVE_ACCESS_FLAG = !USER_NATIVE_ACCESS_MODULES.isEmpty();\n@@ -850,0 +856,21 @@\n+    \/**\n+     * Process the --illegal-native-access option (and its default).\n+     *\/\n+    private static IllegalNativeAccess addIllegalNativeAccess() {\n+        String value = getAndRemoveProperty(\"jdk.module.illegal.native.access\");\n+        \/\/ don't use a switch: bootstrapping issues!\n+        if (value == null) {\n+            return IllegalNativeAccess.WARN; \/\/ default\n+        } else if (value.equals(\"deny\")) {\n+            return IllegalNativeAccess.DENY;\n+        } else if (value.equals(\"allow\")) {\n+            return IllegalNativeAccess.ALLOW;\n+        } else if (value.equals(\"warn\")) {\n+            return IllegalNativeAccess.WARN;\n+        } else {\n+            fail(\"Value specified to --illegal-native-access not recognized:\"\n+                    + \" '\" + value + \"'\");\n+            return null;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-    public static void ensureNativeAccess(Class<?> currentClass, Class<?> owner, String methodName) {\n+    public static void ensureNativeAccess(Class<?> currentClass, Class<?> owner, String methodName, boolean jni) {\n@@ -122,1 +122,4 @@\n-        Holder.JLA.ensureNativeAccess(module, owner, methodName, currentClass);\n+        if (module != null) {\n+            \/\/ not in init phase\n+            Holder.JLA.ensureNativeAccess(module, owner, methodName, currentClass, jni);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,35 +182,0 @@\n-    \/** Creates a new java.lang.reflect.Constructor. Access checks as\n-        per java.lang.reflect.AccessibleObject are not overridden. *\/\n-    public Constructor<?> newConstructor(Class<?> declaringClass,\n-                                         Class<?>[] parameterTypes,\n-                                         Class<?>[] checkedExceptions,\n-                                         int modifiers,\n-                                         int slot,\n-                                         String signature,\n-                                         byte[] annotations,\n-                                         byte[] parameterAnnotations)\n-    {\n-        return langReflectAccess.newConstructor(declaringClass,\n-                                                parameterTypes,\n-                                                checkedExceptions,\n-                                                modifiers,\n-                                                slot,\n-                                                signature,\n-                                                annotations,\n-                                                parameterAnnotations);\n-    }\n-\n-    \/** Gets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c) {\n-        return langReflectAccess.getConstructorAccessor(c);\n-    }\n-\n-    \/** Sets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor)\n-    {\n-        langReflectAccess.setConstructorAccessor(c, accessor);\n-    }\n-\n@@ -228,1 +193,2 @@\n-        return langReflectAccess.leafCopyMethod(arg);\n+        Method root = langReflectAccess.getRoot(arg);\n+        return langReflectAccess.copyMethod(root);\n@@ -231,1 +197,0 @@\n-\n@@ -372,9 +337,0 @@\n-\n-        Constructor<?> ctor = newConstructor(constructorToCall.getDeclaringClass(),\n-                                             constructorToCall.getParameterTypes(),\n-                                             constructorToCall.getExceptionTypes(),\n-                                             constructorToCall.getModifiers(),\n-                                             langReflectAccess.getConstructorSlot(constructorToCall),\n-                                             langReflectAccess.getConstructorSignature(constructorToCall),\n-                                             langReflectAccess.getConstructorAnnotations(constructorToCall),\n-                                             langReflectAccess.getConstructorParameterAnnotations(constructorToCall));\n@@ -389,1 +345,1 @@\n-            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, ctor);\n+            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, constructorToCall);\n@@ -391,1 +347,4 @@\n-        setConstructorAccessor(ctor, acc);\n+        \/\/ Unlike other root constructors, this constructor is not copied for mutation\n+        \/\/ but directly mutated, as it is not cached. To cache this constructor,\n+        \/\/ setAccessible call must be done on a copy and return that copy instead.\n+        Constructor<?> ctor = langReflectAccess.newConstructorWithAccessor(constructorToCall, acc);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":8,"deletions":49,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -83,1 +82,5 @@\n-        String value = GetPropertyAction.privilegedGetProperty(key);\n+        \/*\n+         * GetPropertyAction.privilegedGetProperty cannot be used here, Using VM.getSavedProperty to avoid a bootstrap\n+         * circularity issue in the java\/lang\/String\/concat\/WithSecurityManager.java test\n+         *\/\n+        String value = VM.getSavedProperty(key);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ClassFileDumper.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -430,0 +430,1 @@\n+    @IntrinsicCandidate\n@@ -437,0 +438,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+        jdk.management,\n@@ -259,1 +260,2 @@\n-        jdk.internal.vm.ci;\n+        jdk.internal.vm.ci,\n+        jdk.jfr;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -307,15 +307,0 @@\n-    \/** Return the wrapper that corresponds to the provided basic type char.\n-     *  The basic type char must be for one of the eight primitive types, or void.\n-     *  @throws IllegalArgumentException for unexpected types\n-     *\/\n-    public static Wrapper forPrimitiveType(char basicTypeChar) {\n-        Wrapper w = FROM_CHAR[(basicTypeChar + (basicTypeChar >> 1)) & 0xf];\n-        if (w == null || w.basicTypeChar != basicTypeChar) {\n-            throw basicTypeError(basicTypeChar);\n-        }\n-        if (w == OBJECT) {\n-            throw newIllegalArgumentException(\"not primitive: \" + basicTypeChar);\n-        }\n-        return w;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+\\    --illegal-native-access=<value>\\n\\\n+\\                  allow or deny access to code and data outside the Java runtime\\n\\\n+\\                  by code in modules for which native access is not explicitly enabled.\\n\\\n+\\                  <value> is one of \"deny\", \"warn\" or \"allow\". The default value is \"warn\".\\n\\\n+\\                  This option will be removed in a future release.\\n\\\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -686,0 +686,1 @@\n+            long remainingNanos = nanos;\n@@ -691,3 +692,0 @@\n-                    long remainingNanos = (nanos > 0)\n-                            ? nanos - (System.nanoTime() - startNanos)\n-                            : 0;\n@@ -714,1 +712,0 @@\n-                            \/\/ copy bytes to the DatagramPacket, and set length and sender\n@@ -716,0 +713,1 @@\n+                                \/\/ copy bytes to the DatagramPacket, and set length and sender\n@@ -723,0 +721,8 @@\n+                            } else {\n+                                \/\/ need to retry, adjusting timeout if needed\n+                                if (nanos > 0) {\n+                                    remainingNanos = nanos - (System.nanoTime() - startNanos);\n+                                    if (remainingNanos <= 0) {\n+                                        throw new SocketTimeoutException(\"Receive timed out\");\n+                                    }\n+                                }\n@@ -749,0 +755,1 @@\n+        assert nanos >= 0;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -405,1 +405,1 @@\n-                        char c = UNMAPPABLE_DECODING;\n+                        char c;\n@@ -455,1 +455,1 @@\n-                    char c =  UNMAPPABLE_DECODING;\n+                    char c;\n@@ -506,2 +506,2 @@\n-        private final int SS2 =  0x8E;\n-        private final int SS3 =  0x8F;\n+        private static final int SS2 = 0x8E;\n+        private static final int SS3 = 0x8F;\n@@ -559,1 +559,1 @@\n-        protected final int MAX_SINGLEBYTE = 0xff;\n+        protected static final int MAX_SINGLEBYTE = 0xff;\n@@ -662,1 +662,1 @@\n-                        return CoderResult.OVERFLOW;\n+                            return CoderResult.OVERFLOW;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/DoubleByte.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import sun.security.provider.SHAKE256;\n+import sun.security.provider.SHA3.SHAKE256;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAParameters.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-import sun.security.provider.SHAKE256;\n+import sun.security.provider.SHA3.SHAKE256;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS7.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import sun.security.provider.SHAKE256;\n+import sun.security.provider.SHA3.SHAKE256;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/SignerInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import static java.lang.Math.min;\n+\n@@ -49,1 +51,1 @@\n-abstract class SHA3 extends DigestBase {\n+public abstract class SHA3 extends DigestBase {\n@@ -68,0 +70,3 @@\n+    \/\/ The starting byte combining the 2 or 4-bit domain separator and\n+    \/\/ leading bits of the 10*1 padding, see Table 6 in B.2 of FIPS PUB 202\n+    \/\/ for examples\n@@ -69,0 +74,2 @@\n+\n+    \/\/ the state matrix flattened into an array\n@@ -71,0 +78,10 @@\n+    \/\/ The byte offset in the state where the next squeeze() will start.\n+    \/\/ -1 indicates that either we are in the absorbing phase (only\n+    \/\/ update() calls were made so far) in an extendable-output function (XOF)\n+    \/\/ or the class was initialized as a hash.\n+    \/\/ The first squeeze() call (after a possibly empty sequence of update()\n+    \/\/ calls) will set it to 0 at its start.\n+    \/\/ When a squeeze() call uses up all available bytes from this state\n+    \/\/ and so a new keccak() call is made, squeezeOffset is reset to 0.\n+    protected int squeezeOffset = -1;\n+\n@@ -78,1 +95,1 @@\n-    SHA3(String name, int digestLength, byte suffix, int c) {\n+    private SHA3(String name, int digestLength, byte suffix, int c) {\n@@ -106,0 +123,9 @@\n+     void finishAbsorb() {\n+        int numOfPadding =\n+                setPaddingBytes(suffix, buffer, (int)(bytesProcessed % blockSize));\n+        if (numOfPadding < 1) {\n+            throw new ProviderException(\"Incorrect pad size: \" + numOfPadding);\n+        }\n+        implCompress(buffer, 0);\n+    }\n+\n@@ -111,0 +137,2 @@\n+        \/\/ Moving this allocation to the block where it is used causes a little\n+        \/\/ performance drop, that is why it is here.\n@@ -112,4 +140,3 @@\n-        int numOfPadding =\n-            setPaddingBytes(suffix, buffer, (int)(bytesProcessed % blockSize));\n-        if (numOfPadding < 1) {\n-            throw new ProviderException(\"Incorrect pad size: \" + numOfPadding);\n+        if (engineGetDigestLength() == 0) {\n+            \/\/ This is an XOF, so the digest() call is illegal.\n+            throw new ProviderException(\"Calling digest() is not allowed in an XOF\");\n@@ -117,2 +144,4 @@\n-        implCompress(buffer, 0);\n-        int availableBytes = blockSize; \/\/ i.e. buffer.length\n+\n+        finishAbsorb();\n+\n+        int availableBytes = blockSize;\n@@ -120,0 +149,1 @@\n+\n@@ -121,1 +151,1 @@\n-            for (int i = 0; i < availableBytes \/ 8 ; i++) {\n+            for (int i = 0; i < availableBytes \/ 8; i++) {\n@@ -128,1 +158,1 @@\n-        int numLongs = (numBytes + 7) \/ 8;\n+        int numLongs = numBytes \/ 8;\n@@ -130,1 +160,1 @@\n-        for (int i = 0; i < numLongs - 1; i++) {\n+        for (int i = 0; i < numLongs; i++) {\n@@ -134,6 +164,3 @@\n-        if (numBytes == numLongs * 8) {\n-            asLittleEndian.set(out, ofs, state[numLongs - 1]);\n-        } else {\n-            asLittleEndian.set(byteState, 0, state[numLongs - 1]);\n-            System.arraycopy(byteState, 0,\n-                    out, ofs, numBytes - (numLongs - 1) * 8);\n+        if (numBytes % 8 != 0) {\n+            asLittleEndian.set(byteState, 0, state[numLongs]);\n+            System.arraycopy(byteState, 0, out, ofs, numBytes % 8);\n@@ -143,0 +170,75 @@\n+    void implSqueeze(byte[] output, int offset, int numBytes) {\n+        \/\/ Moving this allocation to the block where it is used causes a little\n+        \/\/ performance drop, that is why it is here.\n+        byte[] byteState = new byte[8];\n+        if (engineGetDigestLength() != 0) {\n+            \/\/ This is not an XOF, so the squeeze() call is illegal.\n+            throw new ProviderException(\"Squeezing is only allowed in XOF mode.\");\n+        }\n+\n+        if (squeezeOffset == -1) {\n+            finishAbsorb();\n+            squeezeOffset = 0;\n+        }\n+\n+        int availableBytes = blockSize - squeezeOffset;\n+\n+        while (numBytes > availableBytes) {\n+            int longOffset = squeezeOffset \/ 8;\n+            int bytesToCopy = 0;\n+\n+            if (longOffset * 8 < squeezeOffset) {\n+                asLittleEndian.set(byteState, 0, state[longOffset]);\n+                longOffset++;\n+                bytesToCopy = longOffset * 8 - squeezeOffset;\n+                System.arraycopy(byteState, 8 - bytesToCopy,\n+                        output, offset, bytesToCopy);\n+                offset += bytesToCopy;\n+            }\n+            for (int i = longOffset; i < blockSize \/ 8; i++) {\n+                asLittleEndian.set(output, offset, state[i]);\n+                offset += 8;\n+            }\n+            keccak();\n+            squeezeOffset = 0;\n+            numBytes -= availableBytes;\n+            availableBytes = blockSize;\n+        }\n+        \/\/ now numBytes <= availableBytes\n+        int longOffset = squeezeOffset \/ 8;\n+\n+        if (longOffset * 8 < squeezeOffset) {\n+            asLittleEndian.set(byteState, 0, state[longOffset]);\n+            int bytesToCopy = min((longOffset + 1) * 8 - squeezeOffset, numBytes);\n+            System.arraycopy(byteState, squeezeOffset - 8 * longOffset,\n+                    output, offset, bytesToCopy);\n+            longOffset++;\n+            numBytes -= bytesToCopy;\n+            offset += bytesToCopy;\n+            squeezeOffset += bytesToCopy;\n+\n+            if (numBytes == 0) return;\n+        }\n+\n+        int numLongs = numBytes \/ 8;\n+\n+        for (int i = longOffset; i < longOffset + numLongs; i++) {\n+            asLittleEndian.set(output, offset, state[i]);\n+            offset += 8;\n+            numBytes -= 8;\n+            squeezeOffset += 8;\n+        }\n+\n+        if (numBytes > 0) {\n+            asLittleEndian.set(byteState, 0, state[squeezeOffset \/ 8]);\n+            System.arraycopy(byteState, 0, output, offset, numBytes);\n+            squeezeOffset += numBytes;\n+        }\n+    }\n+\n+    byte[] implSqueeze(int numBytes) {\n+        byte[] result = new byte[numBytes];\n+        implSqueeze(result, 0, numBytes);\n+        return result;\n+    }\n+\n@@ -148,0 +250,1 @@\n+        squeezeOffset = -1;\n@@ -152,2 +255,3 @@\n-     * pad10*1 algorithm (section 5.1) and the 2-bit suffix \"01\" required\n-     * for SHA-3 hash (section 6.1).\n+     * pad10*1 algorithm (section 5.1) and the 2-bit suffix \"01\" or 4-bit\n+     * suffix \"1111\" required for SHA-3 hash functions (section 6.1) and\n+     * extendable-output functions (section 6.1) respectively.\n@@ -172,0 +276,4 @@\n+        keccak(state);\n+    }\n+\n+    public static void keccak(long[] stateArr) {\n@@ -175,5 +283,5 @@\n-        a0 = state[0]; a1 = state[1]; a2 = state[2]; a3 = state[3]; a4 = state[4];\n-        a5 = state[5]; a6 = state[6]; a7 = state[7]; a8 = state[8]; a9 = state[9];\n-        a10 = state[10]; a11 = state[11]; a12 = state[12]; a13 = state[13]; a14 = state[14];\n-        a15 = state[15]; a16 = state[16]; a17 = state[17]; a18 = state[18]; a19 = state[19];\n-        a20 = state[20]; a21 = state[21]; a22 = state[22]; a23 = state[23]; a24 = state[24];\n+        a0 = stateArr[0]; a1 = stateArr[1]; a2 = stateArr[2]; a3 = stateArr[3]; a4 = stateArr[4];\n+        a5 = stateArr[5]; a6 = stateArr[6]; a7 = stateArr[7]; a8 = stateArr[8]; a9 = stateArr[9];\n+        a10 = stateArr[10]; a11 = stateArr[11]; a12 = stateArr[12]; a13 = stateArr[13]; a14 = stateArr[14];\n+        a15 = stateArr[15]; a16 = stateArr[16]; a17 = stateArr[17]; a18 = stateArr[18]; a19 = stateArr[19];\n+        a20 = stateArr[20]; a21 = stateArr[21]; a22 = stateArr[22]; a23 = stateArr[23]; a24 = stateArr[24];\n@@ -181,1 +289,1 @@\n-        \/\/ process the lanes through step mappings\n+        \/\/ process the stateArr through step mappings\n@@ -283,5 +391,5 @@\n-        state[0] = a0; state[1] = a1; state[2] = a2; state[3] = a3; state[4] = a4;\n-        state[5] = a5; state[6] = a6; state[7] = a7; state[8] = a8; state[9] = a9;\n-        state[10] = a10; state[11] = a11; state[12] = a12; state[13] = a13; state[14] = a14;\n-        state[15] = a15; state[16] = a16; state[17] = a17; state[18] = a18; state[19] = a19;\n-        state[20] = a20; state[21] = a21; state[22] = a22; state[23] = a23; state[24] = a24;\n+        stateArr[0] = a0; stateArr[1] = a1; stateArr[2] = a2; stateArr[3] = a3; stateArr[4] = a4;\n+        stateArr[5] = a5; stateArr[6] = a6; stateArr[7] = a7; stateArr[8] = a8; stateArr[9] = a9;\n+        stateArr[10] = a10; stateArr[11] = a11; stateArr[12] = a12; stateArr[13] = a13; stateArr[14] = a14;\n+        stateArr[15] = a15; stateArr[16] = a16; stateArr[17] = a17; stateArr[18] = a18; stateArr[19] = a19;\n+        stateArr[20] = a20; stateArr[21] = a21; stateArr[22] = a22; stateArr[23] = a23; stateArr[24] = a24;\n@@ -331,0 +439,81 @@\n+\n+    public abstract static class SHA3XOF extends SHA3 {\n+        public SHA3XOF(String name, int digestLength, byte offset, int c) {\n+            super(name, digestLength, offset, c);\n+        }\n+        public void update(byte in) {\n+            if (squeezeOffset != -1) {\n+                throw new ProviderException(\"update() after squeeze() is not allowed.\");\n+            }\n+            engineUpdate(in);\n+        }\n+        public void update(byte[] in, int off, int len) {\n+            if (squeezeOffset != -1) {\n+                throw new ProviderException(\"update() after squeeze() is not allowed.\");\n+            }\n+            engineUpdate(in, off, len);\n+        }\n+\n+        public void update(byte[] in) {\n+            if (squeezeOffset != -1) {\n+                throw new ProviderException(\"update() after squeeze() is not allowed.\");\n+            }\n+            engineUpdate(in, 0, in.length);\n+        }\n+\n+        public byte[] digest() {\n+            return engineDigest();\n+        }\n+\n+        public void squeeze(byte[] output, int offset, int numBytes) {\n+            implSqueeze(output, offset, numBytes);\n+        }\n+        public byte[] squeeze(int numBytes) {\n+            return implSqueeze(numBytes);\n+        }\n+\n+        public void reset() {\n+            engineReset();\n+        }\n+    }\n+\n+    \/*\n+     * The SHAKE128 extendable output function.\n+     *\/\n+    public static final class SHAKE128 extends SHA3XOF {\n+        \/\/ d is the required number of output bytes.\n+        \/\/ If this constructor is used with d > 0, the squeezing methods\n+        \/\/ will throw a ProviderException.\n+        public SHAKE128(int d) {\n+            super(\"SHAKE128\", d, (byte) 0x1F, 32);\n+        }\n+\n+        \/\/ If this constructor is used to get an instance of the class, then,\n+        \/\/ after the last update, one can get the generated bytes using the\n+        \/\/ squeezing methods.\n+        \/\/ Calling digest method will throw a ProviderException.\n+        public SHAKE128() {\n+            super(\"SHAKE128\", 0, (byte) 0x1F, 32);\n+        }\n+    }\n+\n+    \/*\n+     * The SHAKE256 extendable output function.\n+     *\/\n+    public static final class SHAKE256 extends SHA3XOF {\n+        \/\/ d is the required number of output bytes.\n+        \/\/ If this constructor is used with d > 0, the squeezing methods will\n+        \/\/ throw a ProviderException.\n+        public SHAKE256(int d) {\n+            super(\"SHAKE256\", d, (byte) 0x1F, 64);\n+        }\n+\n+        \/\/ If this constructor is used to get an instance of the class, then,\n+        \/\/ after the last update, one can get the generated bytes using the\n+        \/\/ squeezing methods.\n+        \/\/ Calling a digest method will throw a ProviderException.\n+        public SHAKE256() {\n+            super(\"SHAKE256\", 0, (byte) 0x1F, 64);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA3.java","additions":219,"deletions":30,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.security.provider;\n-\n-\/*\n- * The SHAKE128 extendable output function.\n- *\/\n-public final class SHAKE128 extends SHA3 {\n-    public SHAKE128(int d) {\n-        super(\"SHAKE128\", d, (byte) 0x1F, 32);\n-    }\n-\n-    public void update(byte in) {\n-        engineUpdate(in);\n-    }\n-    public void update(byte[] in, int off, int len) {\n-        engineUpdate(in, off, len);\n-    }\n-\n-    public byte[] digest() {\n-        return engineDigest();\n-    }\n-\n-    public void reset() {\n-        engineReset();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHAKE128.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.security.provider;\n-\n-\/*\n- * The SHAKE256 extendable output function.\n- *\/\n-public final class SHAKE256 extends SHA3 {\n-    public SHAKE256(int d) {\n-        super(\"SHAKE256\", d, (byte) 0x1F, 64);\n-    }\n-\n-    public void update(byte in) {\n-        engineUpdate(in);\n-    }\n-    public void update(byte[] in, int off, int len) {\n-        engineUpdate(in, off, len);\n-    }\n-\n-    public byte[] digest() {\n-        return engineDigest();\n-    }\n-\n-    public void reset() {\n-        engineReset();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHAKE256.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1142,1 +1142,3 @@\n-            NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.math.BigInteger;\n@@ -33,0 +32,1 @@\n+import java.util.Arrays;\n@@ -121,5 +121,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -224,5 +219,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -304,1 +294,1 @@\n-        } catch  (GeneralSecurityException gse) {\n+        } catch (GeneralSecurityException gse) {\n@@ -335,2 +325,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -354,2 +343,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -366,2 +354,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -378,6 +365,2 @@\n-            SessionId newId = new SessionId(true,\n-                hc.sslContext.getSecureRandom());\n-\n-            SecretKey resumptionMasterSecret =\n-                hc.handshakeSession.getResumptionMasterSecret();\n-            if (resumptionMasterSecret == null) {\n+            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n+            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n@@ -385,3 +368,2 @@\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"no resumption secret\");\n+                    SSLLogger.fine(\"No session ticket produced: \" +\n+                            \"session timeout is too long\");\n@@ -393,13 +375,11 @@\n-            \/\/ construct the PSK and handshake message\n-            BigInteger nonce = hc.handshakeSession.incrTicketNonceCounter();\n-            byte[] nonceArr = nonce.toByteArray();\n-            SecretKey psk = derivePreSharedKey(\n-                    hc.negotiatedCipherSuite.hashAlg,\n-                    resumptionMasterSecret, nonceArr);\n-\n-            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n-            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"session timeout\");\n+            \/\/ Send NewSessionTickets to the client based\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                int i = 0;\n+                NewSessionTicketMessage nstm;\n+                while (i < SSLConfiguration.serverNewSessionTicketCount) {\n+                    nstm = generateNST(hc, sessionCache);\n+                    if (nstm == null) {\n+                        break;\n+                    }\n+                    nstm.write(hc.handshakeOutput);\n+                    i++;\n@@ -408,1 +388,28 @@\n-                return null;\n+                hc.handshakeOutput.flush();\n+            }\n+            \/*\n+             * With large NST counts, a client that quickly closes after\n+             * TLS Finished completes can cause SocketExceptions such as:\n+             * Windows servers read-side throwing SocketException:\n+             *   \"An established connection was aborted by the software in\n+             *    your host machine\", which relates to error WSAECONNABORTED.\n+             * A SocketException caused by a \"broken pipe\" has been observed on\n+             * other systems.\n+             * These are very unlikely situations when client and server are on\n+             * different machines.\n+             *\n+             * RFC 8446 does not put requirements when an NST needs to be\n+             * sent, but it should be sent very soon after TLS Finished for\n+             * clients that will quickly resume to create more sessions.\n+             * TLS 1.3 is different from TLS 1.2, there is more data the client\n+             * should be aware of\n+             *\/\n+\n+            \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n+            \/\/\n+            \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n+            \/\/ of this post-handshake message will indicate the FINISHED\n+            \/\/ handshake status.  It is not needed to have a follow-on\n+            \/\/ SSLEngine.wrap() any longer.\n+            if (hc.conContext.needHandshakeFinishedStatus) {\n+                hc.conContext.needHandshakeFinishedStatus = false;\n@@ -411,1 +418,16 @@\n-            NewSessionTicketMessage nstm = null;\n+            \/\/ clean the post handshake context\n+            hc.conContext.finishPostHandshake();\n+\n+            \/\/ The message has been delivered.\n+            return null;\n+        }\n+\n+        private NewSessionTicketMessage generateNST(HandshakeContext hc,\n+            SSLSessionContextImpl sessionCache) throws IOException {\n+\n+            NewSessionTicketMessage nstm;\n+            SessionId newId = new SessionId(true,\n+                hc.sslContext.getSecureRandom());\n+\n+            \/\/ construct the PSK and handshake message\n+            byte[] nonce = hc.handshakeSession.incrTicketNonceCounter();\n@@ -414,2 +436,4 @@\n-                    new SSLSessionImpl(hc.handshakeSession, newId);\n-            sessionCopy.setPreSharedKey(psk);\n+                new SSLSessionImpl(hc.handshakeSession, newId);\n+            sessionCopy.setPreSharedKey(derivePreSharedKey(\n+                hc.negotiatedCipherSuite.hashAlg,\n+                hc.handshakeSession.getResumptionMasterSecret(), nonce));\n@@ -422,1 +446,1 @@\n-                        sessionTimeoutSeconds,\n+                        sessionCache.getSessionTimeout(),\n@@ -424,1 +448,1 @@\n-                        nonceArr,\n+                        nonce,\n@@ -431,2 +455,1 @@\n-                        SSLLogger.fine(\n-                            \"Produced NewSessionTicket stateless \" +\n+                        SSLLogger.fine(\"Produced NewSessionTicket stateless \" +\n@@ -436,0 +459,1 @@\n+                return nstm;\n@@ -441,3 +465,4 @@\n-                nstm = new T13NewSessionTicketMessage(hc, sessionTimeoutSeconds,\n-                        hc.sslContext.getSecureRandom(), nonceArr,\n-                        newId.getId());\n+                nstm = new T13NewSessionTicketMessage(hc,\n+                    sessionCache.getSessionTimeout(),\n+                    hc.sslContext.getSecureRandom(), nonce,\n+                    newId.getId());\n@@ -445,3 +470,2 @@\n-                    SSLLogger.fine(\n-                            \"Produced NewSessionTicket post-handshake message\",\n-                            nstm);\n+                    SSLLogger.fine(\"Produced NewSessionTicket \" +\n+                        \"post-handshake message\", nstm);\n@@ -456,0 +480,1 @@\n+                return nstm;\n@@ -458,15 +483,2 @@\n-            \/\/ Output the handshake message.\n-            if (nstm != null) {\n-                \/\/ should never be null\n-                nstm.write(hc.handshakeOutput);\n-                hc.handshakeOutput.flush();\n-\n-                \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n-                \/\/\n-                \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n-                \/\/ of this post-handshake message will indicate the FINISHED\n-                \/\/ handshake status.  It is not needed to have a follow-on\n-                \/\/ SSLEngine.wrap() any longer.\n-                if (hc.conContext.needHandshakeFinishedStatus) {\n-                    hc.conContext.needHandshakeFinishedStatus = false;\n-                }\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"No NewSessionTicket created\");\n@@ -475,4 +487,0 @@\n-            \/\/ clean the post handshake context\n-            hc.conContext.finishPostHandshake();\n-\n-            \/\/ The message has been delivered.\n@@ -500,2 +508,3 @@\n-            \/\/ Is this session resumable?\n-            if (!shc.handshakeSession.isRejoinable()) {\n+            \/\/ Are new tickets allowed?  If so, is this session resumable?\n+            if (SSLConfiguration.serverNewSessionTicketCount == 0 ||\n+                !shc.handshakeSession.isRejoinable()) {\n@@ -581,1 +590,0 @@\n-                sessionCache.remove(hc.handshakeSession.getSessionId());\n@@ -622,1 +630,6 @@\n-            sessionCache.put(sessionCopy);\n+            sessionCache.put(sessionCopy, sessionCopy.isPSK());\n+\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"MultiNST PSK (Server): \" +\n+                    Utilities.toHexString(Arrays.copyOf(nstm.ticket, 16)));\n+            }\n@@ -629,0 +642,1 @@\n+    \/* TLS 1.2 spec does not specify multiple NST behavior.*\/\n@@ -677,2 +691,1 @@\n-                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" +\n-                        nstm.toString());\n+                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" + nstm);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NewSessionTicket.java","additions":93,"deletions":80,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -702,1 +702,1 @@\n-            sessionCache.remove(chc.resumingSession.getSessionId());\n+            sessionCache.remove(chc.resumingSession.getSessionId(), true);\n@@ -707,0 +707,2 @@\n+                SSLLogger.fine(\n+                    \"MultiNST PSK (Client): \" + Utilities.toHexString(Arrays.copyOf(chc.pskIdentity, 16)));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,0 +124,5 @@\n+    \/\/ Number of NewSessionTickets that will be sent by the server.\n+    static final int serverNewSessionTicketCount;\n+    \/\/ Default for NewSessionTickets\n+    static final int SERVER_NST_DEFAULT = 1;\n+\n@@ -185,1 +190,1 @@\n-                \"jdk.tls.client.maxInboundCertificateChainLength\");\n+            \"jdk.tls.client.maxInboundCertificateChainLength\");\n@@ -194,0 +199,27 @@\n+\n+        \/*\n+         * jdk.tls.server.newSessionTicketCount system property\n+         * Sets the number of NewSessionTickets sent to a TLS 1.3 resumption\n+         * client.  The value must be between 0 and 10.  Default is defined by\n+         * SERVER_NST_DEFAULT.\n+         *\/\n+        Integer nstServerCount = GetIntegerAction.privilegedGetProperty(\n+            \"jdk.tls.server.newSessionTicketCount\");\n+        if (nstServerCount == null || nstServerCount < 0 ||\n+            nstServerCount > 10) {\n+            serverNewSessionTicketCount = SERVER_NST_DEFAULT;\n+            if (nstServerCount != null && SSLLogger.isOn &&\n+                SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount defaults to \" +\n+                        SERVER_NST_DEFAULT + \" as the property was not \" +\n+                        \"between 0 and 10\");\n+            }\n+        } else {\n+            serverNewSessionTicketCount = nstServerCount;\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount set to \" +\n+                        serverNewSessionTicketCount);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -419,5 +419,6 @@\n-        if ((conContext.handshakeContext == null) &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            conContext.handshakeContext == null &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineImpl.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+    private static final int DEFAULT_MAX_QUEUE_SIZE = 10;\n@@ -90,2 +91,0 @@\n-        sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n-        sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -93,0 +92,2 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -95,1 +96,1 @@\n-            \/\/ but doesn't necessarily has to be a true random number.\n+            \/\/ but doesn't necessarily have to be a true random number.\n@@ -98,0 +99,3 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryQueue(cacheLimit, timeout,\n+                DEFAULT_MAX_QUEUE_SIZE);\n@@ -280,0 +284,10 @@\n+        put(s, false);\n+    }\n+\n+    \/**\n+     * Put an entry in the cache\n+     * @param s SSLSessionImpl entry to be stored\n+     * @param canQueue True if multiple entries may exist under one\n+     *                 session entry.\n+     *\/\n+    void put(SSLSessionImpl s, boolean canQueue) {\n@@ -285,1 +299,1 @@\n-                getKey(s.getPeerHost(), s.getPeerPort()), s);\n+                getKey(s.getPeerHost(), s.getPeerPort()), s, canQueue);\n@@ -293,0 +307,3 @@\n+        remove(key, false);\n+    }\n+    void remove(SessionId key, boolean isClient) {\n@@ -296,1 +313,3 @@\n-            sessionHostPortCache.remove(\n+            \/\/ A client keeps the cache entry for queued NST resumption.\n+            if (!isClient) {\n+                sessionHostPortCache.remove(\n@@ -298,0 +317,1 @@\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import java.util.Enumeration;\n@@ -135,1 +134,5 @@\n-    private BigInteger ticketNonceCounter = BigInteger.ONE;\n+    private byte ticketNonceCounter = 1;\n+\n+    \/\/ This boolean is true when a new set of NewSessionTickets are needed after\n+    \/\/ the initial ones sent after the handshake.\n+    boolean updateNST = false;\n@@ -495,1 +498,1 @@\n-                buf.get(b, 0 , i);\n+                buf.get(b, 0, i);\n@@ -504,2 +507,7 @@\n-                this.pskIdentity = new byte[buf.get()];\n-                buf.get(pskIdentity);\n+                i = buf.get();\n+                if (i > 0) {\n+                    this.pskIdentity = new byte[buf.get()];\n+                    buf.get(pskIdentity);\n+                } else {\n+                    this.pskIdentity = null;\n+                }\n@@ -718,4 +726,2 @@\n-    BigInteger incrTicketNonceCounter() {\n-        BigInteger result = ticketNonceCounter;\n-        ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);\n-        return result;\n+    byte[] incrTicketNonceCounter() {\n+        return new byte[] {ticketNonceCounter++};\n@@ -725,1 +731,1 @@\n-        return (ticketNonceCounter.compareTo(BigInteger.ZERO) > 0);\n+        return (ticketNonceCounter > 0);\n@@ -784,0 +790,4 @@\n+    public boolean isPSK() {\n+        return (pskIdentity != null && pskIdentity.length > 0);\n+    }\n+\n@@ -1233,1 +1243,0 @@\n-    boolean updateNST;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1324,1 +1324,0 @@\n-                conContext.conSession.updateNST = false;\n@@ -1559,6 +1558,7 @@\n-        if (!conContext.sslConfig.isClientMode &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                conContext.handshakeContext == null &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            !conContext.sslConfig.isClientMode &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            conContext.handshakeContext == null &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n@@ -1568,0 +1568,1 @@\n+            conContext.conSession.updateNST = false;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1792,1 +1792,2 @@\n-        if (System.console() == null) {\n+        Console console = System.console();\n+        if (console == null || !console.isTerminal()) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import javax.net.ssl.SSLSession;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n@@ -29,1 +32,2 @@\n-import java.lang.ref.*;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -58,1 +62,1 @@\n- * value using e.g. java -ms64M -mx128M foo.Test\n+ * value using e.g. java -Xms64M -Xmx128M foo.Test\n@@ -93,0 +97,9 @@\n+    \/**\n+     * Add V to the cache with the option to use a QueueCacheEntry if the\n+     * cache is configured for it.  If the cache is not configured for a queue,\n+     * V will silently add the entry directly.\n+     *\/\n+    public void put(K key, V value, boolean canQueue) {\n+        put(key, value);\n+    }\n+\n@@ -140,0 +153,5 @@\n+    public static <K,V> Cache<K,V> newSoftMemoryQueue(int size, int timeout,\n+        int maxQueueSize) {\n+        return new MemoryCache<>(true, size, timeout, maxQueueSize);\n+    }\n+\n@@ -251,3 +269,1 @@\n-    private static final float LOAD_FACTOR = 0.75f;\n-\n-    \/\/ XXXX\n+    \/\/ Debugging\n@@ -258,0 +274,1 @@\n+    final private int maxQueueSize;\n@@ -266,1 +283,1 @@\n-        this(soft, maxSize, 0);\n+        this(soft, maxSize, 0, 0);\n@@ -270,0 +287,4 @@\n+        this(soft, maxSize, lifetime, 0);\n+    }\n+\n+    public MemoryCache(boolean soft, int maxSize, int lifetime, int qSize) {\n@@ -271,0 +292,1 @@\n+        this.maxQueueSize = qSize;\n@@ -272,1 +294,1 @@\n-        if (soft)\n+        if (soft) {\n@@ -274,1 +296,1 @@\n-        else\n+        } else {\n@@ -276,2 +298,4 @@\n-\n-        cacheMap = new LinkedHashMap<>(1, LOAD_FACTOR, true);\n+        }\n+        \/\/ LinkedHashMap is needed for its access order.  0.75f load factor is\n+        \/\/ default.\n+        cacheMap = new LinkedHashMap<>(1, 0.75f, true);\n@@ -341,0 +365,4 @@\n+                \/\/ If this is a queue, check for some expired entries\n+                if (entry instanceof QueueCacheEntry<K,V> qe) {\n+                    qe.getQueue().removeIf(e -> !e.isValid(time));\n+                }\n@@ -370,1 +398,20 @@\n-    public synchronized void put(K key, V value) {\n+    public void put(K key, V value) {\n+        put(key, value, false);\n+    }\n+\n+    \/**\n+     * This puts an entry into the cacheMap.\n+     *\n+     * If canQueue is true, V will be added using a QueueCacheEntry which\n+     * is added to cacheMap.  If false, V is added to the cacheMap directly.\n+     * The caller must keep a consistent canQueue value, mixing them can\n+     * result in a queue being replaced with a single entry.\n+     *\n+     * This method is synchronized to avoid multiple QueueCacheEntry\n+     * overwriting the same key.\n+     *\n+     * @param key key to the cacheMap\n+     * @param value value to be stored\n+     * @param canQueue can the value be put into a QueueCacheEntry\n+     *\/\n+    public synchronized void put(K key, V value, boolean canQueue) {\n@@ -372,2 +419,2 @@\n-        long expirationTime = (lifetime == 0) ? 0 :\n-                                        System.currentTimeMillis() + lifetime;\n+        long expirationTime =\n+            (lifetime == 0) ? 0 : System.currentTimeMillis() + lifetime;\n@@ -378,4 +425,27 @@\n-        CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n-        if (oldEntry != null) {\n-            oldEntry.invalidate();\n-            return;\n+        if (maxQueueSize == 0 || !canQueue) {\n+            CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n+            if (oldEntry != null) {\n+                oldEntry.invalidate();\n+            }\n+        } else {\n+            CacheEntry<K, V> entry = cacheMap.get(key);\n+            switch (entry) {\n+                case QueueCacheEntry<K, V> qe -> {\n+                    qe.putValue(newEntry);\n+                    if (DEBUG) {\n+                        System.out.println(\"QueueCacheEntry= \" + qe);\n+                        final AtomicInteger i = new AtomicInteger(1);\n+                        qe.queue.stream().forEach(e ->\n+                            System.out.println(i.getAndIncrement() + \"= \" + e));\n+                    }\n+                }\n+                case null, default ->\n+                    cacheMap.put(key, new QueueCacheEntry<>(key, newEntry,\n+                        expirationTime, maxQueueSize));\n+            }\n+\n+            if (DEBUG) {\n+                System.out.println(\"Cache entry added: key=\" +\n+                    key.toString() + \", class=\" +\n+                    (entry != null ? entry.getClass().getName() : null));\n+            }\n@@ -404,2 +474,3 @@\n-        long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n-        if (!entry.isValid(time)) {\n+\n+        if (lifetime > 0 && !entry.isValid(System.currentTimeMillis())) {\n+            cacheMap.remove(key);\n@@ -409,1 +480,0 @@\n-            cacheMap.remove(key);\n@@ -412,0 +482,9 @@\n+\n+        \/\/ If the value is a queue, return a queue entry.\n+        if (entry instanceof QueueCacheEntry<K, V> qe) {\n+            V result = qe.getValue(lifetime);\n+            if (qe.isEmpty()) {\n+                removeImpl(key);\n+            }\n+            return result;\n+        }\n@@ -417,0 +496,4 @@\n+        removeImpl(key);\n+    }\n+\n+    private void removeImpl(Object key) {\n@@ -422,1 +505,0 @@\n-\n@@ -553,3 +635,2 @@\n-    private static class SoftCacheEntry<K,V>\n-            extends SoftReference<V>\n-            implements CacheEntry<K,V> {\n+    private static class SoftCacheEntry<K,V> extends SoftReference<V>\n+        implements CacheEntry<K,V> {\n@@ -592,0 +673,7 @@\n+\n+        @Override\n+        public String toString() {\n+            if (get() instanceof SSLSession se)\n+                return HexFormat.of().formatHex(se.getId());\n+            return super.toString();\n+        }\n@@ -594,1 +682,104 @@\n-}\n+    \/**\n+     * This CacheEntry<K,V> type allows multiple V entries to be stored in\n+     * one key in the cacheMap.\n+     *\n+     * This implementation is need for TLS clients that receive multiple\n+     * PSKs or NewSessionTickets for server resumption.\n+     *\/\n+    private static class QueueCacheEntry<K,V> implements CacheEntry<K,V> {\n+\n+        \/\/ Limit the number of queue entries.\n+        private final int MAXQUEUESIZE;\n+\n+        final boolean DEBUG = false;\n+        private K key;\n+        private long expirationTime;\n+        final Queue<CacheEntry<K,V>> queue = new ConcurrentLinkedQueue<>();\n+\n+        QueueCacheEntry(K key, CacheEntry<K,V> entry, long expirationTime,\n+            int maxSize) {\n+            this.key = key;\n+            this.expirationTime = expirationTime;\n+            this.MAXQUEUESIZE = maxSize;\n+            queue.add(entry);\n+        }\n+\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        public V getValue() {\n+            return getValue(0);\n+        }\n+\n+        public V getValue(long lifetime) {\n+            long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n+            do {\n+                var entry = queue.poll();\n+                if (entry == null) {\n+                    return null;\n+                }\n+                if (entry.isValid(time)) {\n+                    return entry.getValue();\n+                }\n+                entry.invalidate();\n+            } while (!queue.isEmpty());\n+\n+            return null;\n+        }\n+\n+        public long getExpirationTime() {\n+            return expirationTime;\n+        }\n+\n+        public void setExpirationTime(long time) {\n+            expirationTime = time;\n+        }\n+\n+        public void putValue(CacheEntry<K,V> entry) {\n+            if (DEBUG) {\n+                System.out.println(\"Added to queue (size=\" + queue.size() +\n+                    \"): \" + entry.getKey().toString() + \",  \" + entry);\n+            }\n+            \/\/ Update the cache entry's expiration time to the latest entry.\n+            \/\/ The getValue() calls will remove expired tickets.\n+            expirationTime = entry.getExpirationTime();\n+            \/\/ Limit the number of queue entries, removing the oldest.\n+            if (queue.size() >= MAXQUEUESIZE) {\n+                queue.remove();\n+            }\n+            queue.add(entry);\n+        }\n+\n+        public boolean isValid(long currentTime) {\n+            boolean valid = (currentTime <= expirationTime) && !queue.isEmpty();\n+            if (!valid) {\n+                invalidate();\n+            }\n+            return valid;\n+        }\n+\n+        public boolean isValid() {\n+            return isValid(System.currentTimeMillis());\n+        }\n+\n+        public void invalidate() {\n+            clear();\n+            key = null;\n+            expirationTime = -1;\n+        }\n+\n+        public void clear() {\n+            queue.forEach(CacheEntry::invalidate);\n+            queue.clear();\n+        }\n+\n+        public boolean isEmpty() {\n+            return queue.isEmpty();\n+        }\n+\n+        public Queue<CacheEntry<K,V>> getQueue() {\n+            return queue;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Cache.java","additions":217,"deletions":26,"binary":false,"changes":243,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,16 @@\n+    },\n+\n+    \/**\n+     * Distrust TLS Server certificates anchored by an Entrust root CA and\n+     * issued after October 31, 2024. If enabled, this policy is currently\n+     * enforced by the PKIX and SunX509 TrustManager implementations\n+     * of the SunJSSE provider implementation.\n+     *\/\n+    ENTRUST_TLS {\n+        void checkDistrust(String variant, X509Certificate[] chain)\n+                           throws ValidatorException {\n+            if (!variant.equals(Validator.VAR_TLS_SERVER)) {\n+                return;\n+            }\n+            EntrustTLSPolicy.checkDistrust(chain);\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/validator\/CADistrustPolicy.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.validator;\n+\n+import java.security.cert.X509Certificate;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import sun.security.util.Debug;\n+import sun.security.x509.X509CertImpl;\n+\n+\/**\n+ * This class checks if Entrust issued TLS Server certificates should be\n+ * restricted.\n+ *\/\n+final class EntrustTLSPolicy {\n+\n+    private static final Debug debug = Debug.getInstance(\"certpath\");\n+\n+    \/\/ SHA-256 certificate fingerprints of distrusted roots\n+    private static final Set<String> FINGERPRINTS = Set.of(\n+        \/\/ cacerts alias: entrustevca\n+        \/\/ DN: CN=Entrust Root Certification Authority,\n+        \/\/     OU=(c) 2006 Entrust, Inc.,\n+        \/\/     OU=www.entrust.net\/CPS is incorporated by reference,\n+        \/\/     O=Entrust, Inc., C=US\n+        \"73C176434F1BC6D5ADF45B0E76E727287C8DE57616C1E6E6141A2B2CBC7D8E4C\",\n+        \/\/ cacerts alias: entrustrootcaec1\n+        \/\/ DN: CN=Entrust Root Certification Authority - EC1,\n+        \/\/     OU=(c) 2012 Entrust, Inc. - for authorized use only,\n+        \/\/     OU=See www.entrust.net\/legal-terms, O=Entrust, Inc., C=US\n+        \"02ED0EB28C14DA45165C566791700D6451D7FB56F0B2AB1D3B8EB070E56EDFF5\",\n+        \/\/ cacerts alias: entrustrootcag2\n+        \/\/ DN: CN=Entrust Root Certification Authority - G2,\n+        \/\/     OU=(c) 2009 Entrust, Inc. - for authorized use only,\n+        \/\/     OU=See www.entrust.net\/legal-terms, O=Entrust, Inc., C=US\n+        \"43DF5774B03E7FEF5FE40D931A7BEDF1BB2E6B42738C4E6D3841103D3AA7F339\",\n+        \/\/ cacerts alias: entrustrootcag4\n+        \/\/ DN: CN=Entrust Root Certification Authority - G4\n+        \/\/     OU=(c) 2015 Entrust, Inc. - for authorized use only,\n+        \/\/     OU=See www.entrust.net\/legal-terms, O=Entrust, Inc., C=US,\n+        \"DB3517D1F6732A2D5AB97C533EC70779EE3270A62FB4AC4238372460E6F01E88\",\n+        \/\/ cacerts alias: entrust2048ca\n+        \/\/ DN: CN=Entrust.net Certification Authority (2048),\n+        \/\/     OU=(c) 1999 Entrust.net Limited,\n+        \/\/     OU=www.entrust.net\/CPS_2048 incorp. by ref. (limits liab.),\n+        \/\/     O=Entrust.net\n+        \"6DC47172E01CBCB0BF62580D895FE2B8AC9AD4F873801E0C10B9C837D21EB177\",\n+        \/\/ cacerts alias: affirmtrustcommercialca\n+        \/\/ DN: CN=AffirmTrust Commercial, O=AffirmTrust, C=US\n+        \"0376AB1D54C5F9803CE4B2E201A0EE7EEF7B57B636E8A93C9B8D4860C96F5FA7\",\n+        \/\/ cacerts alias: affirmtrustnetworkingca\n+        \/\/ DN: CN=AffirmTrust Networking, O=AffirmTrust, C=US\n+        \"0A81EC5A929777F145904AF38D5D509F66B5E2C58FCDB531058B0E17F3F0B41B\",\n+        \/\/ cacerts alias: affirmtrustpremiumca\n+        \/\/ DN: CN=AffirmTrust Premium, O=AffirmTrust, C=US\n+        \"70A73F7F376B60074248904534B11482D5BF0E698ECC498DF52577EBF2E93B9A\",\n+        \/\/ cacerts alias: affirmtrustpremiumeccca\n+        \/\/ DN: CN=AffirmTrust Premium ECC, O=AffirmTrust, C=US\n+        \"BD71FDF6DA97E4CF62D1647ADD2581B07D79ADF8397EB4ECBA9C5E8488821423\"\n+    );\n+\n+    \/\/ Any TLS Server certificate that is anchored by one of the Entrust\n+    \/\/ roots above and is issued after this date will be distrusted.\n+    private static final LocalDate OCTOBER_31_2024 =\n+        LocalDate.of(2024, Month.OCTOBER, 31);\n+\n+    \/**\n+     * This method assumes the eeCert is a TLS Server Cert and chains back to\n+     * the anchor.\n+     *\n+     * @param chain the end-entity's certificate chain. The end entity cert\n+     *              is at index 0, the trust anchor at index n-1.\n+     * @throws ValidatorException if the certificate is distrusted\n+     *\/\n+    static void checkDistrust(X509Certificate[] chain)\n+                              throws ValidatorException {\n+        X509Certificate anchor = chain[chain.length-1];\n+        String fp = fingerprint(anchor);\n+        if (fp == null) {\n+            throw new ValidatorException(\"Cannot generate fingerprint for \"\n+                + \"trust anchor of TLS server certificate\");\n+        }\n+        if (FINGERPRINTS.contains(fp)) {\n+            Date notBefore = chain[0].getNotBefore();\n+            LocalDate ldNotBefore = LocalDate.ofInstant(notBefore.toInstant(),\n+                                                        ZoneOffset.UTC);\n+            \/\/ reject if certificate is issued after October 31, 2024\n+            checkNotBefore(ldNotBefore, OCTOBER_31_2024, anchor);\n+        }\n+    }\n+\n+    private static String fingerprint(X509Certificate cert) {\n+        return X509CertImpl.getFingerprint(\"SHA-256\", cert, debug);\n+    }\n+\n+    private static void checkNotBefore(LocalDate notBeforeDate,\n+            LocalDate distrustDate, X509Certificate anchor)\n+            throws ValidatorException {\n+        if (notBeforeDate.isAfter(distrustDate)) {\n+            throw new ValidatorException\n+                (\"TLS Server certificate issued after \" + distrustDate +\n+                 \" and anchored by a distrusted legacy Entrust root CA: \"\n+                 + anchor.getSubjectX500Principal(),\n+                 ValidatorException.T_UNTRUSTED_CERT, anchor);\n+        }\n+    }\n+\n+    private EntrustTLSPolicy() {}\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/validator\/EntrustTLSPolicy.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.function.UnaryOperator;\n@@ -94,4 +93,0 @@\n-    \/\/ Interned BaseLocale cache\n-    private static final ReferencedKeySet<BaseLocale> CACHE =\n-            ReferencedKeySet.create(true, ReferencedKeySet.concurrentHashMapSupplier());\n-\n@@ -166,13 +161,3 @@\n-        return CACHE.intern(new BaseLocale(language, script, region, variant),\n-                \/\/ Avoid lambdas since this may be on the bootstrap path in many locales\n-                INTERNER);\n-    }\n-\n-    public static final UnaryOperator<BaseLocale> INTERNER = new UnaryOperator<>() {\n-        @Override\n-        public BaseLocale apply(BaseLocale b) {\n-            return new BaseLocale(\n-                    LocaleUtils.toLowerString(b.language).intern(),\n-                    LocaleUtils.toTitleString(b.script).intern(),\n-                    LocaleUtils.toUpperString(b.region).intern(),\n-                    b.variant.intern());\n+        class InterningCache { \/\/ TODO: StableValue\n+            private static final ReferencedKeySet<BaseLocale> CACHE =\n+                    ReferencedKeySet.create(true, ReferencedKeySet.concurrentHashMapSupplier());\n@@ -180,1 +165,6 @@\n-    };\n+        return InterningCache.CACHE.intern(new BaseLocale(\n+                language.intern(), \/\/ guaranteed to be lower-case\n+                LocaleUtils.toTitleString(script).intern(),\n+                region.intern(), \/\/ guaranteed to be upper-case\n+                variant.intern()));\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1333,0 +1333,3 @@\n+#   ENTRUST_TLS : Distrust TLS Server certificates anchored by\n+#   an Entrust root CA and issued after October 31, 2024.\n+#\n@@ -1344,1 +1347,1 @@\n-jdk.security.caDistrustPolicies=SYMANTEC_TLS\n+jdk.security.caDistrustPolicies=SYMANTEC_TLS,ENTRUST_TLS\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -555,8 +555,32 @@\n-Methods that provide native access are restricted, and by default their\n-use causes warnings.\n-This option allows code in the specified modules to use restricted\n-methods without warnings.\n-\\f[I]module\\f[R] can be \\f[V]ALL-UNNAMED\\f[R] to indicate code on the\n-class path.\n-When this option is present, any use of restricted methods by code\n-outside the specified modules causes an\n+Native access can occur as a result of calling a method that is either\n+\\f[B]restricted\\f[R] [https:\/\/openjdk.org\/jeps\/454#Safety], or\n+\\f[V]native\\f[R].\n+This option allows code in the specified modules to perform native\n+access.\n+Native access occurring in a module that has not been explicitly enabled\n+is deemed \\f[I]illegal\\f[R].\n+.RS\n+.PP\n+\\f[I]module\\f[R] can be a module name, or \\f[V]ALL-UNNAMED\\f[R] to\n+indicate code on the class path.\n+.RE\n+.TP\n+-\\f[V]--illegal-native-access=\\f[R]\\f[I]parameter\\f[R]\n+This option specifies a mode for how illegal native access is handled:\n+.RS\n+.RS\n+.PP\n+\\f[B]Note:\\f[R] This option will be removed in a future release.\n+.RE\n+.IP \\[bu] 2\n+\\f[V]allow\\f[R]: This mode allows illegal native access in all modules,\n+without any warings.\n+.IP \\[bu] 2\n+\\f[V]warn\\f[R]: This mode is identical to \\f[V]allow\\f[R] except that a\n+warning message is issued for the first illegal native access found in a\n+module.\n+This mode is the default for the current JDK but will change in a future\n+release.\n+.IP \\[bu] 2\n+\\f[V]deny\\f[R]: This mode disables illegal native access.\n+That is, any illegal native access causes an\n@@ -564,0 +588,6 @@\n+This mode will become the default in a future release.\n+.PP\n+To verify that your application is ready for a future version of the\n+JDK, run it with \\f[V]--illegal-native-access=deny\\f[R] along with any\n+necessary \\f[V]--enable-native-access\\f[R] options.\n+.RE\n@@ -4798,1 +4828,1 @@\n-\\f[V]-Xlog:gc=trace:file=gctrace.txt:uptimemillis,pids:filecount=5,filesize=1024\\f[R]\n+\\f[V]-Xlog:gc=trace:file=gctrace.txt:uptimemillis,pid:filecount=5,filesize=1024\\f[R]\n","filename":"src\/java.base\/share\/man\/java.1","additions":39,"deletions":9,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -778,0 +778,6 @@\n+\n+    \/* Large UTF8 Support *\/\n+\n+    jlong (JNICALL *GetStringUTFLengthAsLong)\n+      (JNIEnv *env, jstring str);\n+\n@@ -1626,0 +1632,3 @@\n+    jlong GetStringUTFLengthAsLong(jstring str) {\n+        return functions->GetStringUTFLengthAsLong(this,str);\n+    }\n@@ -1996,0 +2005,1 @@\n+#define JNI_VERSION_24  0x00180000\n","filename":"src\/java.base\/share\/native\/include\/jni.h","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -116,0 +116,3 @@\n+\/\/ This is defined in link_type.c due to linking restraints\n+jboolean JLI_IsStaticallyLinked();\n+\n","filename":"src\/java.base\/share\/native\/libjli\/jli_util.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+\n+\/\/ This is in a separate file since it will need to be compiled to two different\n+\/\/ object files, depending on if we are going to build a static or a dynamic\n+\/\/ library.\n+\n+jboolean JLI_IsStaticallyLinked(void) {\n+#ifdef STATIC_BUILD\n+  return JNI_TRUE;\n+#else\n+  return JNI_FALSE;\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libjli\/link_type.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-    outputConsumedID = (*env)->GetFieldID(env, cls, \"outputConsumed\", \"I\");\n@@ -54,0 +53,1 @@\n+    outputConsumedID = (*env)->GetFieldID(env, cls, \"outputConsumed\", \"I\");\n","filename":"src\/java.base\/share\/native\/libzip\/Inflater.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-    private long st_dev;    \/\/ ID of device\n-    private long st_ino;    \/\/ Inode number\n+    private final long st_dev;    \/\/ ID of device\n+    private final long st_ino;    \/\/ Inode number\n@@ -39,1 +39,4 @@\n-    private FileKey() { }\n+    private FileKey(long st_dev, long st_ino) {\n+        this.st_dev = st_dev;\n+        this.st_ino = st_ino;\n+    }\n@@ -42,3 +45,3 @@\n-        FileKey fk = new FileKey();\n-        fk.init(fd);\n-        return fk;\n+        long finfo[] = new long[2];\n+        init(fd, finfo);\n+        return new FileKey(finfo[0], finfo[1]);\n@@ -62,2 +65,2 @@\n-    private native void init(FileDescriptor fd) throws IOException;\n-    private static native void initIDs();\n+    private static native void init(FileDescriptor fd, long[] finfo)\n+        throws IOException;\n@@ -66,1 +69,1 @@\n-        initIDs();\n+        IOUtil.load();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileKey.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -531,1 +531,1 @@\n-        JNU_ThrowByNameWithLastError(env,\n+        JNU_ThrowByNameWithMessageAndLastError(env,\n@@ -664,2 +664,0 @@\n-    char fn[32];\n-    char exePath[PATH_MAX];\n@@ -668,1 +666,0 @@\n-    int ret;\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessHandleImpl_unix.c","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-static char *isFileIdentical(char* buf, size_t size, char *pathname);\n-\n@@ -62,4 +60,0 @@\n-#if defined(_AIX)\n-static const char *ETC_ENVIRONMENT_FILE = \"\/etc\/environment\";\n-#endif\n-\n@@ -67,0 +61,1 @@\n+static char *isFileIdentical(char* buf, size_t size, char *pathname);\n@@ -359,0 +354,1 @@\n+static const char *ETC_ENVIRONMENT_FILE = \"\/etc\/environment\";\n","filename":"src\/java.base\/unix\/native\/libjava\/TimeZone_md.c","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,8 +45,1 @@\n-\n-#if (__STDC_VERSION__ >= 199901L)\n-  #include <stdbool.h>\n-#else\n-  #define bool int\n-  #define true 1\n-  #define false 0\n-#endif\n+#include <stdbool.h>\n","filename":"src\/java.base\/unix\/native\/libjsig\/jsig.c","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,3 +43,2 @@\n-JNIEXPORT jboolean JNICALL\n-Java_java_nio_MappedMemoryUtils_isLoaded0(JNIEnv *env, jobject obj, jlong address,\n-                                         jlong len, jlong numPages)\n+jboolean JNICALL MappedMemoryUtils_isLoaded0(JNIEnv *env, jobject obj, jlong address,\n+                                             jlong len, jlong numPages)\n@@ -83,2 +82,1 @@\n-JNIEXPORT void JNICALL\n-Java_java_nio_MappedMemoryUtils_load0(JNIEnv *env, jobject obj, jlong address,\n+void JNICALL MappedMemoryUtils_load0(JNIEnv *env, jobject obj, jlong address,\n@@ -94,3 +92,2 @@\n-JNIEXPORT void JNICALL\n-Java_java_nio_MappedMemoryUtils_unload0(JNIEnv *env, jobject obj, jlong address,\n-                                     jlong len)\n+void JNICALL MappedMemoryUtils_unload0(JNIEnv *env, jobject obj, jlong address,\n+                                       jlong len)\n@@ -105,2 +102,1 @@\n-JNIEXPORT void JNICALL\n-Java_java_nio_MappedMemoryUtils_force0(JNIEnv *env, jobject obj, jobject fdo,\n+void JNICALL MappedMemoryUtils_force0(JNIEnv *env, jobject obj, jobject fdo,\n@@ -115,0 +111,16 @@\n+\n+#define FD \"Ljava\/io\/FileDescriptor;\"\n+\n+static JNINativeMethod methods[] = {\n+    {\"isLoaded0\", \"(JJJ)Z\",             (void *)&MappedMemoryUtils_isLoaded0},\n+    {\"load0\",     \"(JJ)V\",              (void *)&MappedMemoryUtils_load0},\n+    {\"unload0\",   \"(JJ)V\",              (void *)&MappedMemoryUtils_unload0},\n+    {\"force0\",    \"(\" FD \"JJ)V\",        (void *)&MappedMemoryUtils_force0},\n+};\n+\n+JNIEXPORT void JNICALL\n+Java_java_nio_MappedMemoryUtils_registerNatives(JNIEnv *env, jclass cls)\n+{\n+    (*env)->RegisterNatives(env, cls,\n+                            methods, sizeof(methods)\/sizeof(methods[0]));\n+}\n","filename":"src\/java.base\/unix\/native\/libnio\/MappedMemoryUtils.c","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -33,12 +33,0 @@\n-static jfieldID key_st_dev;    \/* id for FileKey.st_dev *\/\n-static jfieldID key_st_ino;    \/* id for FileKey.st_ino *\/\n-\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileKey_initIDs(JNIEnv *env, jclass clazz)\n-{\n-    CHECK_NULL(key_st_dev = (*env)->GetFieldID(env, clazz, \"st_dev\", \"J\"));\n-    CHECK_NULL(key_st_ino = (*env)->GetFieldID(env, clazz, \"st_ino\", \"J\"));\n-}\n-\n-\n@@ -46,1 +34,2 @@\n-Java_sun_nio_ch_FileKey_init(JNIEnv *env, jobject this, jobject fdo)\n+Java_sun_nio_ch_FileKey_init(JNIEnv* env, jclass clazz, jobject fdo,\n+    jlongArray finfo)\n@@ -50,0 +39,1 @@\n+    jlong deviceAndInode[2];\n@@ -51,1 +41,2 @@\n-    RESTARTABLE(fstat(fdval(env, fdo), &fbuf), res);\n+    int fd = fdval(env, fdo);\n+    RESTARTABLE(fstat(fd, &fbuf), res);\n@@ -55,2 +46,3 @@\n-        (*env)->SetLongField(env, this, key_st_dev, (jlong)fbuf.st_dev);\n-        (*env)->SetLongField(env, this, key_st_ino, (jlong)fbuf.st_ino);\n+        deviceAndInode[0] = (jlong)fbuf.st_dev;\n+        deviceAndInode[1] = (jlong)fbuf.st_ino;\n+        (*env)->SetLongArrayRegion(env, finfo, 0, 2, deviceAndInode);\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileKey.c","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -136,3 +136,4 @@\n-#ifndef STATX_ALL\n-#define STATX_ALL (STATX_BTIME | STATX_BASIC_STATS)\n-#endif\n+\/\/\n+\/\/ STATX_ALL is deprecated; use a different name to avoid confusion.\n+\/\/\n+#define LOCAL_STATX_ALL (STATX_BASIC_STATS | STATX_BTIME)\n@@ -257,0 +258,17 @@\n+#if defined(__linux__) && defined(__arm__)\n+\/**\n+ * Lookup functions with time_t parameter. Try to use 64 bit symbol\n+ * if sizeof(time_t) exceeds 32 bit.\n+ *\/\n+static void* lookup_time_t_function(const char* symbol, const char* symbol64) {\n+    void *func_ptr = NULL;\n+    if (sizeof(time_t) > 4) {\n+        func_ptr = dlsym(RTLD_DEFAULT, symbol64);\n+    }\n+    if (func_ptr == NULL) {\n+        return dlsym(RTLD_DEFAULT, symbol);\n+    }\n+    return func_ptr;\n+}\n+#endif\n+\n@@ -354,0 +372,8 @@\n+#if defined(__linux__) && defined(__arm__)\n+    my_futimesat_func = (futimesat_func*) lookup_time_t_function(\"futimesat\",\n+        \"__futimesat64\");\n+    my_lutimes_func = (lutimes_func*) lookup_time_t_function(\"lutimes\",\n+        \"__lutimes64\");\n+    my_futimens_func = (futimens_func*) lookup_time_t_function(\"futimens\",\n+        \"__futimens64\");\n+#else\n@@ -359,0 +385,1 @@\n+#endif\n@@ -596,2 +623,13 @@\n-    (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec, (jlong)buf->stx_btime.tv_sec);\n-    (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec, (jlong)buf->stx_btime.tv_nsec);\n+    if ((buf->stx_mask & STATX_BTIME) != 0) {\n+        \/\/  Birth time was filled in so use it\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec,\n+                             (jlong)buf->stx_btime.tv_sec);\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec,\n+                             (jlong)buf->stx_btime.tv_nsec);\n+    } else {\n+        \/\/  Birth time was not filled in: fall back to last modification time\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec,\n+                             (jlong)buf->stx_mtime.tv_sec);\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec,\n+                             (jlong)buf->stx_mtime.tv_nsec);\n+    }\n@@ -651,1 +689,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n@@ -683,1 +721,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n@@ -714,1 +752,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n@@ -747,1 +785,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":47,"deletions":9,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -493,1 +493,8 @@\n-        return canonicalize0(path);\n+        String canonicalPath = canonicalize0(path);\n+        String finalPath = null;\n+        try {\n+            finalPath = getFinalPath(canonicalPath);\n+        } catch (IOException ignored) {\n+            finalPath = canonicalPath;\n+        }\n+        return finalPath;\n@@ -499,0 +506,7 @@\n+    private String getFinalPath(String path) throws IOException {\n+        return getFinalPath0(path);\n+    }\n+\n+    private native String getFinalPath0(String path)\n+            throws IOException;\n+\n","filename":"src\/java.base\/windows\/classes\/java\/io\/WinNTFileSystem.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,3 +36,3 @@\n-    private int dwVolumeSerialNumber;\n-    private int nFileIndexHigh;\n-    private int nFileIndexLow;\n+    private final int dwVolumeSerialNumber;\n+    private final int nFileIndexHigh;\n+    private final int nFileIndexLow;\n@@ -40,1 +40,6 @@\n-    private FileKey() { }\n+    private FileKey(int dwVolumeSerialNumber, int nFileIndexHigh,\n+        int nFileIndexLow) {\n+        this.dwVolumeSerialNumber = dwVolumeSerialNumber;\n+        this.nFileIndexHigh = nFileIndexHigh;\n+        this.nFileIndexLow = nFileIndexLow;\n+    }\n@@ -43,3 +48,3 @@\n-        FileKey fk = new FileKey();\n-        fk.init(fd);\n-        return fk;\n+        int finfo[] = new int[3];\n+        init(fd, finfo);\n+        return new FileKey(finfo[0], finfo[1], finfo[2]);\n@@ -63,2 +68,2 @@\n-    private native void init(FileDescriptor fd) throws IOException;\n-    private static native void initIDs();\n+    private static native void init(FileDescriptor fd, int[] finfo)\n+        throws IOException;\n@@ -68,1 +73,0 @@\n-        initIDs();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/FileKey.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,6 +49,0 @@\n-\/**\n- * GetFinalPathNameByHandle is available on Windows Vista and newer\n- *\/\n-typedef BOOL (WINAPI* GetFinalPathNameByHandleProc) (HANDLE, LPWSTR, DWORD, DWORD);\n-static GetFinalPathNameByHandleProc GetFinalPathNameByHandle_func;\n-\n@@ -58,1 +52,0 @@\n-    HMODULE handle;\n@@ -65,9 +58,0 @@\n-\n-    \/\/ GetFinalPathNameByHandle requires Windows Vista or newer\n-    if (GetModuleHandleExW((GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |\n-                            GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT),\n-                           (LPCWSTR)&CreateFileW, &handle) != 0)\n-    {\n-        GetFinalPathNameByHandle_func = (GetFinalPathNameByHandleProc)\n-            GetProcAddress(handle, \"GetFinalPathNameByHandleW\");\n-    }\n@@ -91,4 +75,0 @@\n-    \/* Need Windows Vista or newer to get the final path *\/\n-    if (GetFinalPathNameByHandle_func == NULL)\n-        return NULL;\n-\n@@ -112,1 +92,1 @@\n-        DWORD len = (*GetFinalPathNameByHandle_func)(h, result, MAX_PATH, 0);\n+        DWORD len = GetFinalPathNameByHandleW(h, result, MAX_PATH, 0);\n@@ -118,1 +98,1 @@\n-                len = (*GetFinalPathNameByHandle_func)(h, result, len, 0);\n+                len = GetFinalPathNameByHandleW(h, result, len, 0);\n@@ -354,0 +334,19 @@\n+JNIEXPORT jstring JNICALL\n+Java_java_io_WinNTFileSystem_getFinalPath0(JNIEnv* env, jobject this, jstring pathname) {\n+    jstring rv = NULL;\n+\n+    WITH_UNICODE_STRING(env, pathname, path) {\n+        WCHAR* finalPath = getFinalPath(env, path);\n+        if (finalPath != NULL) {\n+            rv = (*env)->NewString(env, finalPath, (jsize)wcslen(finalPath));\n+            free(finalPath);\n+        }\n+    } END_UNICODE_STRING(env, path);\n+\n+    if (rv == NULL && !(*env)->ExceptionCheck(env)) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"Bad pathname\");\n+    }\n+\n+    return rv;\n+}\n+\n","filename":"src\/java.base\/windows\/native\/libjava\/WinNTFileSystem_md.c","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -331,1 +331,1 @@\n-        _snprintf(cptr, MAX_PATH, \"\\\"%s\\\" %s\", argv[0], cmdline);\n+        snprintf(cptr, MAX_PATH, \"\\\"%s\\\" %s\", argv[0], cmdline);\n","filename":"src\/java.base\/windows\/native\/libjli\/cmdtoargs.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,2 @@\n-JNIEXPORT jboolean JNICALL\n-Java_java_nio_MappedMemoryUtils_isLoaded0(JNIEnv *env, jobject obj, jlong address,\n-                                         jlong len, jlong numPages)\n+jboolean JNICALL MappedMemoryUtils_isLoaded0(JNIEnv *env, jobject obj, jlong address,\n+                                             jlong len, jlong numPages)\n@@ -46,2 +45,1 @@\n-JNIEXPORT void JNICALL\n-Java_java_nio_MappedMemoryUtils_load0(JNIEnv *env, jobject obj, jlong address,\n+void JNICALL MappedMemoryUtils_load0(JNIEnv *env, jobject obj, jlong address,\n@@ -53,3 +51,2 @@\n-JNIEXPORT void JNICALL\n-Java_java_nio_MappedMemoryUtils_unload0(JNIEnv *env, jobject obj, jlong address,\n-                                     jlong len)\n+void JNICALL MappedMemoryUtils_unload0(JNIEnv *env, jobject obj, jlong address,\n+                                       jlong len)\n@@ -60,2 +57,1 @@\n-JNIEXPORT void JNICALL\n-Java_java_nio_MappedMemoryUtils_force0(JNIEnv *env, jobject obj, jobject fdo,\n+void JNICALL MappedMemoryUtils_force0(JNIEnv *env, jobject obj, jobject fdo,\n@@ -109,0 +105,16 @@\n+\n+#define FD \"Ljava\/io\/FileDescriptor;\"\n+\n+static JNINativeMethod methods[] = {\n+    {\"isLoaded0\", \"(JJJ)Z\",             (void *)&MappedMemoryUtils_isLoaded0},\n+    {\"load0\",     \"(JJ)V\",              (void *)&MappedMemoryUtils_load0},\n+    {\"unload0\",   \"(JJ)V\",              (void *)&MappedMemoryUtils_unload0},\n+    {\"force0\",    \"(\" FD \"JJ)V\",        (void *)&MappedMemoryUtils_force0},\n+};\n+\n+JNIEXPORT void JNICALL\n+Java_java_nio_MappedMemoryUtils_registerNatives(JNIEnv *env, jclass cls)\n+{\n+    (*env)->RegisterNatives(env, cls,\n+                            methods, sizeof(methods)\/sizeof(methods[0]));\n+}\n","filename":"src\/java.base\/windows\/native\/libnio\/MappedMemoryUtils.c","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,14 +33,0 @@\n-static jfieldID key_volumeSN;    \/* id for FileKey.dwVolumeSerialNumber *\/\n-static jfieldID key_indexHigh;   \/* id for FileKey.nFileIndexHigh *\/\n-static jfieldID key_indexLow;    \/* id for FileKey.nFileIndexLow *\/\n-\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileKey_initIDs(JNIEnv *env, jclass clazz)\n-{\n-    CHECK_NULL(key_volumeSN = (*env)->GetFieldID(env, clazz, \"dwVolumeSerialNumber\", \"I\"));\n-    CHECK_NULL(key_indexHigh = (*env)->GetFieldID(env, clazz, \"nFileIndexHigh\", \"I\"));\n-    CHECK_NULL(key_indexLow = (*env)->GetFieldID(env, clazz, \"nFileIndexLow\", \"I\"));\n-}\n-\n-\n@@ -48,1 +34,1 @@\n-Java_sun_nio_ch_FileKey_init(JNIEnv *env, jobject this, jobject fdo)\n+Java_sun_nio_ch_FileKey_init(JNIEnv *env, jclass clazz, jobject fdo, jintArray finfo)\n@@ -50,1 +36,1 @@\n-    HANDLE fileHandle = (HANDLE)(handleval(env, fdo));\n+    HANDLE fileHandle = (HANDLE)handleval(env, fdo);\n@@ -53,0 +39,1 @@\n+    jint info[3];\n@@ -56,3 +43,4 @@\n-        (*env)->SetIntField(env, this, key_volumeSN, fileInfo.dwVolumeSerialNumber);\n-        (*env)->SetIntField(env, this, key_indexHigh, fileInfo.nFileIndexHigh);\n-        (*env)->SetIntField(env, this, key_indexLow, fileInfo.nFileIndexLow);\n+        info[0] = (jint)fileInfo.dwVolumeSerialNumber;\n+        info[1] = (jint)fileInfo.nFileIndexHigh;\n+        info[2] = (jint)fileInfo.nFileIndexLow;\n+        (*env)->SetIntArrayRegion(env, finfo, 0, 3, info);\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileKey.c","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import javax.tools.JavaFileManager;\n@@ -31,1 +30,0 @@\n-import javax.lang.model.element.TypeElement;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Filer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-import java.util.Collections;\n-import java.util.Set;\n-import java.util.HashSet;\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-import java.lang.annotation.AnnotationTypeMismatchException;\n-import java.lang.annotation.IncompleteAnnotationException;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Element.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-     * @jls 14.3 Local Class Declarations\n+     * @jls 14.3 Local Class and Interface Declarations\n@@ -114,1 +114,1 @@\n-     * @jls 14.3 Local Class Declarations\n+     * @jls 14.3 Local Class and Interface Declarations\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/NestingKind.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/VariableElement.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,9 @@\n- * block.  However, the interfaces can model some structures only\n- * appearing inside method bodies, such as local variables and\n- * anonymous classes.\n+ * block. Concretely, there is no model of any abstract syntax tree\n+ * (AST) structure of a Java program.  However, the interfaces can\n+ * model some structures only appearing inside method bodies, such as\n+ * {@linkplain ElementKind#LOCAL_VARIABLE local variables},\n+ * {@linkplain NestingKind#ANONYMOUS anonymous classes}, and\n+ * {@linkplain ElementKind#EXCEPTION_PARAMETER exception parameters}.\n+ * Therefore, these interfaces can be used by an AST API to model the\n+ * declarations found in the method bodies of Java compilation units\n+ * (JLS {@jls 7.3}).\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/package-info.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @jls 3.10.7 The Null Literal\n+ * @jls 3.10.8 The Null Literal\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/NullType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-import javax.lang.model.util.Types;\n-\n@@ -76,1 +74,1 @@\n-     * @jls 18.1.3. Bounds\n+     * @jls 18.1.3 Bounds\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/TypeVariable.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import javax.lang.model.element.*;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/TypeVisitor.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractAnnotationValueVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,3 +32,0 @@\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.ElementVisitor;\n-import javax.lang.model.element.RecordComponentElement;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractElementVisitorPreview.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import javax.lang.model.type.*;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitor9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner14.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner7.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.util.List;\n-import java.util.ArrayList;\n@@ -35,2 +33,0 @@\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScannerPreview.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleAnnotationValueVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor7.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,3 +32,0 @@\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.ElementVisitor;\n-import javax.lang.model.element.RecordComponentElement;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitorPreview.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import javax.lang.model.type.TypeVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.type.TypeVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor7.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import javax.lang.model.type.IntersectionType;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/TypeKindVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.lang.annotation.Annotation;\n-import java.lang.annotation.AnnotationTypeMismatchException;\n-import java.lang.annotation.IncompleteAnnotationException;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Types.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,2 +64,0 @@\n-    private static final Object FLAVOR_MAP_KEY = new Object();\n-\n","filename":"src\/java.datatransfer\/share\/classes\/java\/awt\/datatransfer\/SystemFlavorMap.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -496,3 +496,0 @@\n-    char **mclr;\n-    int  mccr = 0;\n-    char *dsr;\n","filename":"src\/java.desktop\/aix\/native\/libawt_xawt\/awt\/awt_InputMethod.c","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/eio\/FileManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaFileView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -391,1 +391,3 @@\n-            \"ctrl shift DOWN\", \"selectLastRowExtendSelection\"\n+            \"ctrl shift DOWN\", \"selectLastRowExtendSelection\",\n+            \"ctrl shift RIGHT\", \"selectLastColumnExtendSelection\",\n+            \"ctrl shift LEFT\", \"selectFirstColumnExtendSelection\"\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaKeyBindings.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaLookAndFeel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaMenuBarUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaNativeResources.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,24 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.beans.*;\n-import java.util.*;\n-\n-import javax.swing.*;\n+import java.awt.Adjustable;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseMotionListener;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.BoundedRangeModel;\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.JScrollBar;\n+import javax.swing.LookAndFeel;\n@@ -35,5 +53,13 @@\n-import javax.swing.event.*;\n-import javax.swing.plaf.*;\n-\n-import apple.laf.*;\n-import apple.laf.JRSUIConstants.*;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.ScrollBarUI;\n+\n+import apple.laf.JRSUIStateFactory;\n+import apple.laf.JRSUIConstants.Hit;\n+import apple.laf.JRSUIConstants.NothingToScroll;\n+import apple.laf.JRSUIConstants.Orientation;\n+import apple.laf.JRSUIConstants.ScrollBarHit;\n+import apple.laf.JRSUIConstants.ScrollBarPart;\n+import apple.laf.JRSUIConstants.ShowArrows;\n+import apple.laf.JRSUIConstants.State;\n@@ -41,0 +67,1 @@\n+import apple.laf.JRSUIUtils;\n@@ -530,0 +557,15 @@\n+            Component parent = fScrollBar.getParent();\n+            do {\n+                if (parent instanceof JFrame par) {\n+                    if (!par.isEnabled()) {\n+                        ((Timer)e.getSource()).stop();\n+                        fScrollBar.setValueIsAdjusting(false);\n+                        return;\n+                    }\n+                    break;\n+                } else {\n+                    if (parent != null) {\n+                        parent = parent.getParent();\n+                    }\n+                }\n+            } while (parent != null);\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaScrollBarUI.java","additions":54,"deletions":12,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/ScreenMenu.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/awt\/PlatformGraphicsInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CAccessibility.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/LWCToolkit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,1 @@\n+    BOOL isApplicationOwner = NO;\n@@ -122,1 +123,4 @@\n-        if ([NSApp isKindOfClass:[NSApplicationAWT class]]) shouldInstall = YES;\n+        if ([NSApp isKindOfClass:[NSApplicationAWT class]]) {\n+            shouldInstall = YES;\n+            isApplicationOwner = YES;\n+        }\n@@ -125,1 +129,5 @@\n-    if (!shouldInstall) return nil;\n+    if (!shouldInstall) {\n+        [ThreadUtilities setApplicationOwner:NO];\n+        return nil;\n+    }\n+    [ThreadUtilities setApplicationOwner:isApplicationOwner];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/ApplicationDelegate.m","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,0 +134,1 @@\n++ (void)setApplicationOwner:(BOOL)owner;\n","filename":"src\/java.desktop\/macosx\/native\/libosxapp\/ThreadUtilities.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+static BOOL isNSApplicationOwner = NO;\n@@ -62,0 +63,4 @@\n++ (void)setApplicationOwner:(BOOL)owner {\n+    isNSApplicationOwner = owner;\n+}\n+\n@@ -64,2 +69,7 @@\n-    if (appKitEnv == NULL) {\n-        attachCurrentThread((void **)&appKitEnv);\n+    if (isNSApplicationOwner) {\n+        if (appKitEnv == NULL) {\n+            attachCurrentThread((void **)&appKitEnv);\n+        }\n+        return appKitEnv;\n+    } else {\n+        return [ThreadUtilities getJNIEnvUncached];\n@@ -67,1 +77,0 @@\n-    return appKitEnv;\n","filename":"src\/java.desktop\/macosx\/native\/libosxapp\/ThreadUtilities.m","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGImageReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGImageWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1061,1 +1061,1 @@\n-                     \"ctrl shift RIGHT\", \"selectNextColumnExtendSelection\",\n+                     \"ctrl shift RIGHT\", \"selectLastColumnExtendSelection\",\n@@ -1069,1 +1069,1 @@\n-                      \"ctrl shift LEFT\", \"selectPreviousColumnExtendSelection\",\n+                      \"ctrl shift LEFT\", \"selectFirstColumnExtendSelection\",\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKLookAndFeel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -891,5 +891,1 @@\n-        GTKStockIcon stockIcon = null;\n-        synchronized (ICONS_MAP) {\n-            stockIcon = ICONS_MAP.get(key);\n-        }\n-\n+        GTKStockIcon stockIcon = ICONS_MAP.get(key);\n@@ -1182,7 +1178,7 @@\n-        ICONS_MAP = new HashMap<String, GTKStockIcon>();\n-        ICONS_MAP.put(\"FileChooser.cancelIcon\", new GTKStockIcon(\"gtk-cancel\", 4));\n-        ICONS_MAP.put(\"FileChooser.okIcon\",     new GTKStockIcon(\"gtk-ok\",     4));\n-        ICONS_MAP.put(\"OptionPane.yesIcon\", new GTKStockIcon(\"gtk-yes\", 4));\n-        ICONS_MAP.put(\"OptionPane.noIcon\", new GTKStockIcon(\"gtk-no\", 4));\n-        ICONS_MAP.put(\"OptionPane.cancelIcon\", new GTKStockIcon(\"gtk-cancel\", 4));\n-        ICONS_MAP.put(\"OptionPane.okIcon\", new GTKStockIcon(\"gtk-ok\", 4));\n+        Map<String,GTKStockIcon> iconsMap = new HashMap<>();\n+        iconsMap.put(\"FileChooser.cancelIcon\", new GTKStockIcon(\"gtk-cancel\", 4));\n+        iconsMap.put(\"FileChooser.okIcon\",     new GTKStockIcon(\"gtk-ok\",     4));\n+        iconsMap.put(\"OptionPane.yesIcon\", new GTKStockIcon(\"gtk-yes\", 4));\n+        iconsMap.put(\"OptionPane.noIcon\", new GTKStockIcon(\"gtk-no\", 4));\n+        iconsMap.put(\"OptionPane.cancelIcon\", new GTKStockIcon(\"gtk-cancel\", 4));\n+        iconsMap.put(\"OptionPane.okIcon\", new GTKStockIcon(\"gtk-ok\", 4));\n@@ -1194,4 +1190,4 @@\n-            ICONS_MAP.put(\"OptionPane.errorIcon\", new GTKStockIcon(\"dialog-error\", 6));\n-            ICONS_MAP.put(\"OptionPane.informationIcon\", new GTKStockIcon(\"dialog-information\", 6));\n-            ICONS_MAP.put(\"OptionPane.warningIcon\", new GTKStockIcon(\"dialog-warning\", 6));\n-            ICONS_MAP.put(\"OptionPane.questionIcon\", new GTKStockIcon(\"dialog-question\", 6));\n+            iconsMap.put(\"OptionPane.errorIcon\", new GTKStockIcon(\"dialog-error\", 6));\n+            iconsMap.put(\"OptionPane.informationIcon\", new GTKStockIcon(\"dialog-information\", 6));\n+            iconsMap.put(\"OptionPane.warningIcon\", new GTKStockIcon(\"dialog-warning\", 6));\n+            iconsMap.put(\"OptionPane.questionIcon\", new GTKStockIcon(\"dialog-question\", 6));\n@@ -1199,4 +1195,4 @@\n-            ICONS_MAP.put(\"OptionPane.errorIcon\", new GTKStockIcon(\"gtk-dialog-error\", 6));\n-            ICONS_MAP.put(\"OptionPane.informationIcon\", new GTKStockIcon(\"gtk-dialog-info\", 6));\n-            ICONS_MAP.put(\"OptionPane.warningIcon\", new GTKStockIcon(\"gtk-dialog-warning\", 6));\n-            ICONS_MAP.put(\"OptionPane.questionIcon\", new GTKStockIcon(\"gtk-dialog-question\", 6));\n+            iconsMap.put(\"OptionPane.errorIcon\", new GTKStockIcon(\"gtk-dialog-error\", 6));\n+            iconsMap.put(\"OptionPane.informationIcon\", new GTKStockIcon(\"gtk-dialog-info\", 6));\n+            iconsMap.put(\"OptionPane.warningIcon\", new GTKStockIcon(\"gtk-dialog-warning\", 6));\n+            iconsMap.put(\"OptionPane.questionIcon\", new GTKStockIcon(\"gtk-dialog-question\", 6));\n@@ -1204,0 +1200,1 @@\n+        ICONS_MAP = Collections.unmodifiableMap(iconsMap);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKStyle.java","additions":17,"deletions":20,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/Platform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/SplashScreen.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1378,1 +1378,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Toolkit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/event\/NativeLibLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/ColorModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import javax.swing.event.*;\n+import javax.swing.event.ChangeListener;\n@@ -43,1 +43,1 @@\n- * must greater than or equal to <code>minimum<\/code>, and <code>maximum<\/code>\n+ * must be greater than or equal to <code>minimum<\/code>, and <code>maximum<\/code>\n@@ -231,1 +231,1 @@\n-     * This method sets all of the model's data with a single method call.\n+     * This method sets all the model's data with a single method call.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/BoundedRangeModel.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -730,0 +730,2 @@\n+            \/\/ The above margin has vastly larger horizontal values when\n+            \/\/ compared to other look and feels that don't rely on these values\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicLookAndFeel.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import javax.swing.JFrame;\n@@ -1611,0 +1612,19 @@\n+            \/\/ If frame is disabled and timer is started in mousePressed\n+            \/\/ and mouseReleased is not called, then timer will not be stopped\n+            \/\/ Stop the timer if frame is disabled\n+            Component parent = scrollbar.getParent();\n+            do {\n+                if (parent instanceof JFrame par) {\n+                    if (!par.isEnabled()) {\n+                        ((Timer)e.getSource()).stop();\n+                        buttonListener.handledEvent = false;\n+                        scrollbar.setValueIsAdjusting(false);\n+                        return;\n+                    }\n+                    break;\n+                } else {\n+                    if (parent != null) {\n+                        parent = parent.getParent();\n+                    }\n+                }\n+            } while (parent != null);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicScrollBarUI.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -397,1 +397,4 @@\n-     * divider is contained in changes. Will create the\n+     * divider is contained in changes.\n+     * If a particular L&amp;F supports this Swing\n+     * \"SplitPane.supportsOneTouchButtons\" property\n+     * it will create the\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSplitPaneDivider.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,7 @@\n-import java.awt.*;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Frame;\n+import java.awt.Insets;\n+import java.awt.Toolkit;\n+import java.awt.Window;\n@@ -31,6 +37,0 @@\n-import javax.swing.plaf.*;\n-import javax.swing.*;\n-import javax.swing.plaf.basic.*;\n-import javax.swing.text.DefaultEditorKit;\n-\n-import java.awt.Color;\n@@ -39,1 +39,0 @@\n-\n@@ -42,1 +41,27 @@\n-import sun.awt.*;\n+import javax.swing.ButtonModel;\n+import javax.swing.DefaultButtonModel;\n+import javax.swing.Icon;\n+import javax.swing.ImageIcon;\n+import javax.swing.JComponent;\n+import javax.swing.JDialog;\n+import javax.swing.JFrame;\n+import javax.swing.JRootPane;\n+import javax.swing.JTextField;\n+import javax.swing.JToggleButton;\n+import javax.swing.LayoutStyle;\n+import javax.swing.LookAndFeel;\n+import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.plaf.BorderUIResource;\n+import javax.swing.plaf.ColorUIResource;\n+import javax.swing.plaf.FontUIResource;\n+import javax.swing.plaf.InsetsUIResource;\n+import javax.swing.plaf.UIResource;\n+import javax.swing.plaf.basic.BasicLookAndFeel;\n+import javax.swing.text.DefaultEditorKit;\n+\n+import sun.awt.AppContext;\n+import sun.awt.OSInfo;\n+import sun.awt.SunToolkit;\n@@ -45,2 +70,0 @@\n-import static javax.swing.UIDefaults.LazyValue;\n-\n@@ -50,0 +73,2 @@\n+import static javax.swing.UIDefaults.LazyValue;\n+\n@@ -785,0 +810,2 @@\n+            \/\/ Button default margin is (2, 14, 2, 14), defined in\n+            \/\/ BasicLookAndFeel via \"Button.margin\" UI property.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalLookAndFeel.java","additions":39,"deletions":12,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-    margin-rigth: 0;\n+    margin-right: 0;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/default.css","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/NativeLibLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/ImagingLib.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/JPEGImageDecoder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/NativeLibLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontManagerNativeLibrary.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/Disposer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMS.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,5 +29,0 @@\n-#ifdef _MSC_VER\n-# ifndef snprintf\n-#       define snprintf _snprintf\n-# endif\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/splashscreen_impl.c","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/CUPSPrinter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-    int i = 0;\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/CUPSfuncs.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-    int i, j, k, cmapsize, nfree, depth, bpp;\n+    int i, k, cmapsize, nfree, depth, bpp;\n@@ -881,1 +881,0 @@\n-    jobject cspaceL;\n@@ -1036,1 +1035,0 @@\n-        jlong pData;\n@@ -1236,5 +1234,4 @@\n-    int i, pixel;\n-    for (i = 0; i < num_colors; i++)\n-        pixel = alloc_col (awt_display, awtData->awt_cmap, red (rgbColors [i]),\n-                           green (rgbColors [i]), blue (rgbColors [i]), -1,\n-                           awtData);\n+    for (int i = 0; i < num_colors; i++)\n+        alloc_col (awt_display, awtData->awt_cmap, red (rgbColors [i]),\n+                   green (rgbColors [i]), blue (rgbColors [i]), -1,\n+                   awtData);\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/X11Color.c","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -103,1 +103,0 @@\n-    jboolean ret;\n@@ -137,1 +136,1 @@\n-    int i, pos, slen, nPaths, numDirs;\n+    int i, pos, slen, nPaths;\n@@ -536,1 +535,0 @@\n-    FcInitLoadConfigFuncType FcInitLoadConfig;\n@@ -546,1 +544,0 @@\n-    FcConfig *fontconfig;\n@@ -550,4 +547,1 @@\n-    FcStrList *strList;\n-    FcChar8 *str;\n-    int i, f, found, len=0;\n-    char **fontPath;\n+    int i, f, found;\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/fontpath.c","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-static Atom psAtom = 0;\n-static Atom fullNameAtom = 0;\n@@ -130,1 +128,0 @@\n-    JNIEnv *env;\n@@ -133,0 +130,1 @@\n+    JNIEnv *env;\n@@ -271,1 +269,1 @@\n-    unsigned char *srcRow, *dstRow, *dstByte;\n+    unsigned char *srcRow, *dstRow;\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11FontScaler_md.c","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -574,1 +574,0 @@\n-    jobject pointArray;\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11Renderer.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -885,1 +885,1 @@\n-        int x, y, w, h;\n+        int x, y;\n@@ -888,2 +888,0 @@\n-        w = pRasInfo->bounds.x2 - x;\n-        h = pRasInfo->bounds.y2 - y;\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11SurfaceData.c","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-    int scan, screen;\n+    int screen;\n@@ -239,2 +239,0 @@\n-    scan = theImage->bytes_per_line;\n-\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11TextRenderer_md.c","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,7 +119,1 @@\n-#ifndef STATIC_BUILD\n-    \/* Get address of this library and the directory containing it. *\/\n-    dladdr((void *)AWT_OnLoad, &dlinfo);\n-    realpath((char *)dlinfo.dli_fname, buf);\n-    len = strlen(buf);\n-    p = strrchr(buf, '\/');\n-#endif\n+\n@@ -132,1 +126,1 @@\n-        tk = LWAWT_PATH;\n+    tk = LWAWT_PATH;\n@@ -134,2 +128,1 @@\n-        tk = XAWT_PATH;\n-#endif\n+    tk = XAWT_PATH;\n@@ -137,1 +130,0 @@\n-#ifndef MACOSX\n@@ -143,4 +135,6 @@\n-#ifndef STATIC_BUILD\n-    \/* Calculate library name to load *\/\n-    strncpy(p, tk, MAXPATHLEN-len-1);\n-#endif\n+    if (!JVM_IsStaticallyLinked()) {\n+        \/* Get address of this library and the directory containing it. *\/\n+        dladdr((void *)AWT_OnLoad, &dlinfo);\n+        realpath((char *)dlinfo.dli_fname, buf);\n+        len = strlen(buf);\n+        p = strrchr(buf, '\/');\n@@ -148,6 +142,11 @@\n-#ifndef STATIC_BUILD\n-    jstring jbuf = JNU_NewStringPlatform(env, buf);\n-    CHECK_EXCEPTION_FATAL(env, \"Could not allocate library name\");\n-    JNU_CallStaticMethodByName(env, NULL, \"java\/lang\/System\", \"load\",\n-                               \"(Ljava\/lang\/String;)V\",\n-                               jbuf);\n+        \/* Calculate library name to load *\/\n+        strncpy(p, tk, MAXPATHLEN-len-1);\n+\n+        jstring jbuf = JNU_NewStringPlatform(env, buf);\n+        CHECK_EXCEPTION_FATAL(env, \"Could not allocate library name\");\n+        JNU_CallStaticMethodByName(env, NULL, \"java\/lang\/System\", \"load\",\n+                                   \"(Ljava\/lang\/String;)V\",\n+                                   jbuf);\n+\n+        awtHandle = dlopen(buf, RTLD_LAZY | RTLD_GLOBAL);\n+    }\n@@ -155,2 +154,0 @@\n-    awtHandle = dlopen(buf, RTLD_LAZY | RTLD_GLOBAL);\n-#endif\n","filename":"src\/java.desktop\/unix\/native\/libawt\/awt\/awt_LoadLibrary.c","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -307,1 +307,0 @@\n-    char errmsg[128];\n@@ -725,1 +724,0 @@\n-    int i;\n@@ -875,1 +873,0 @@\n-    int a, b, c;\n@@ -1157,1 +1154,1 @@\n-    int i, n;\n+    int i;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/awt_GraphicsEnv.c","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -796,2 +796,0 @@\n-    int                 count=0 ;\n-\n@@ -826,2 +824,0 @@\n-                count++;\n-\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/multiVis.c","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-    Atom type, atom, actual_type;\n+    Atom atom, actual_type;\n@@ -254,2 +254,0 @@\n-    XSizeHints sizeHints;\n-\n@@ -743,1 +741,0 @@\n-    int rc;\n@@ -747,1 +744,1 @@\n-    rc = pthread_create(&thr, &attr, SplashScreenThread, (void *) splash);\n+    pthread_create(&thr, &attr, SplashScreenThread, (void *) splash);\n","filename":"src\/java.desktop\/unix\/native\/libsplashscreen\/splashscreen_sys.c","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/PlatformGraphicsInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WToolkit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/windows\/classes\/sun\/print\/PrintServiceLookupProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-    _snprintf(assertMsg, ASSERT_MSG_SIZE, AssertFmt, expr, file, line, lastError, msgBuffer);\n+    snprintf(assertMsg, ASSERT_MSG_SIZE, AssertFmt, expr, file, line, lastError, msgBuffer);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Debug.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/java.instrument\/share\/classes\/sun\/instrument\/InstrumentationImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,0 @@\n- * <blockquote>\n@@ -133,1 +132,0 @@\n- * <\/blockquote>\n@@ -1023,1 +1021,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/ManagementFactory.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID is not constant\n@@ -45,28 +44,1 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = -2212731951078526753L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = -1081892073854801359L;\n-\n-    private static final long serialVersionUID;\n-    static {\n-        boolean compat = false;\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK: exception means no compat with 1.0, too bad\n-        }\n-        if (compat)\n-            serialVersionUID = oldSerialVersionUID;\n-        else\n-            serialVersionUID = newSerialVersionUID;\n-    }\n+    private static final long serialVersionUID = -1081892073854801359L;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/ClassAttributeValueExp.java","additions":2,"deletions":30,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID not constant\n@@ -46,24 +45,1 @@\n-    \/* Serial version *\/\n-    private static final long serialVersionUID;\n-    static {\n-        \/* For complicated reasons, the serialVersionUID changed\n-           between JMX 1.0 and JMX 1.1, even though JMX 1.1 did not\n-           have compatibility code for this class.  So the\n-           serialization produced by this class with JMX 1.2 and\n-           jmx.serial.form=1.0 is not the same as that produced by\n-           this class with JMX 1.1 and jmx.serial.form=1.0.  However,\n-           the serialization without that property is the same, and\n-           that is the only form required by JMX 1.2.\n-        *\/\n-        long uid = 8644704819898565848L;\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            if (\"1.0\".equals(form))\n-                uid = 7043855487133450673L;\n-        } catch (Exception e) {\n-            \/\/ OK: exception means no compat with 1.0, too bad\n-        }\n-        serialVersionUID = uid;\n-    }\n+    private static final long serialVersionUID = 8644704819898565848L;\n","filename":"src\/java.management\/share\/classes\/javax\/management\/MBeanAttributeInfo.java","additions":2,"deletions":26,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,0 @@\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID is not constant\n@@ -59,37 +58,1 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = 1716977971058914352L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = -7516092053498031989L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-        new ObjectStreamField(\"message\", String.class),\n-        new ObjectStreamField(\"sequenceNumber\", Long.TYPE),\n-        new ObjectStreamField(\"source\", Object.class),\n-        new ObjectStreamField(\"sourceObjectName\", ObjectName.class),\n-        new ObjectStreamField(\"timeStamp\", Long.TYPE),\n-        new ObjectStreamField(\"type\", String.class),\n-        new ObjectStreamField(\"userData\", Object.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n-    {\n-        new ObjectStreamField(\"message\", String.class),\n-        new ObjectStreamField(\"sequenceNumber\", Long.TYPE),\n-        new ObjectStreamField(\"source\", Object.class),\n-        new ObjectStreamField(\"timeStamp\", Long.TYPE),\n-        new ObjectStreamField(\"type\", String.class),\n-        new ObjectStreamField(\"userData\", Object.class)\n-    };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n+    private static final long serialVersionUID = -7516092053498031989L;\n@@ -111,22 +74,9 @@\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK: exception means no compat with 1.0, too bad\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n-\n+    private static final ObjectStreamField[] serialPersistentFields =\n+    {\n+        new ObjectStreamField(\"message\", String.class),\n+        new ObjectStreamField(\"sequenceNumber\", Long.TYPE),\n+        new ObjectStreamField(\"source\", Object.class),\n+        new ObjectStreamField(\"timeStamp\", Long.TYPE),\n+        new ObjectStreamField(\"type\", String.class),\n+        new ObjectStreamField(\"userData\", Object.class)\n+    };\n@@ -381,16 +331,1 @@\n-        if (compat) {\n-            \/\/ Serializes this instance in the old serial form\n-            \/\/\n-            ObjectOutputStream.PutField fields = out.putFields();\n-            fields.put(\"type\", type);\n-            fields.put(\"sequenceNumber\", sequenceNumber);\n-            fields.put(\"timeStamp\", timeStamp);\n-            fields.put(\"userData\", userData);\n-            fields.put(\"message\", message);\n-            fields.put(\"source\", source);\n-            out.writeFields();\n-        } else {\n-            \/\/ Serializes this instance in the new serial form\n-            \/\/\n-            out.defaultWriteObject();\n-        }\n+      out.defaultWriteObject();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/Notification.java","additions":12,"deletions":77,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,0 @@\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID not constant\n@@ -51,29 +50,1 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = -6227876276058904000L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = -4679739485102359104L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-        new ObjectStreamField(\"longVal\", Long.TYPE),\n-        new ObjectStreamField(\"doubleVal\", Double.TYPE),\n-        new ObjectStreamField(\"valIsLong\", Boolean.TYPE)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n-    {\n-        new ObjectStreamField(\"val\", Number.class)\n-    };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n-\n+    private static final long serialVersionUID = -4679739485102359104L;\n@@ -85,1 +56,3 @@\n-    private static final ObjectStreamField[] serialPersistentFields;\n+    private static final ObjectStreamField[] serialPersistentFields = {\n+        new ObjectStreamField(\"val\", Number.class)\n+    };\n@@ -88,22 +61,0 @@\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK: exception means no compat with 1.0, too bad\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n-\n-\n@@ -192,38 +143,1 @@\n-      if (compat)\n-      {\n-        \/\/ Read an object serialized in the old serial form\n-        \/\/\n-        double doubleVal;\n-        long longVal;\n-        boolean isLong;\n-        ObjectInputStream.GetField fields = in.readFields();\n-        doubleVal = fields.get(\"doubleVal\", (double)0);\n-        if (fields.defaulted(\"doubleVal\"))\n-        {\n-          throw new NullPointerException(\"doubleVal\");\n-        }\n-        longVal = fields.get(\"longVal\", (long)0);\n-        if (fields.defaulted(\"longVal\"))\n-        {\n-          throw new NullPointerException(\"longVal\");\n-        }\n-        isLong = fields.get(\"valIsLong\", false);\n-        if (fields.defaulted(\"valIsLong\"))\n-        {\n-          throw new NullPointerException(\"valIsLong\");\n-        }\n-        if (isLong)\n-        {\n-          this.val = longVal;\n-        }\n-        else\n-        {\n-          this.val = doubleVal;\n-        }\n-      }\n-      else\n-      {\n-        \/\/ Read an object serialized in the new serial form\n-        \/\/\n-        in.defaultReadObject();\n-      }\n+      in.defaultReadObject();\n@@ -238,16 +152,1 @@\n-      if (compat)\n-      {\n-        \/\/ Serializes this instance in the old serial form\n-        \/\/\n-        ObjectOutputStream.PutField fields = out.putFields();\n-        fields.put(\"doubleVal\", doubleValue());\n-        fields.put(\"longVal\", longValue());\n-        fields.put(\"valIsLong\", isLong());\n-        out.writeFields();\n-      }\n-      else\n-      {\n-        \/\/ Serializes this instance in the new serial form\n-        \/\/\n-        out.defaultWriteObject();\n-      }\n+      out.defaultWriteObject();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/NumericValueExp.java","additions":7,"deletions":108,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,1 +225,0 @@\n-@SuppressWarnings(\"serial\") \/\/ don't complain serialVersionUID not constant\n@@ -297,51 +296,1 @@\n-    \/\/ Serialization compatibility stuff -------------------->\n-\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = -5467795090068647408L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = 1081892073854801359L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-        new ObjectStreamField(\"domain\", String.class),\n-        new ObjectStreamField(\"propertyList\", Hashtable.class),\n-        new ObjectStreamField(\"propertyListString\", String.class),\n-        new ObjectStreamField(\"canonicalName\", String.class),\n-        new ObjectStreamField(\"pattern\", Boolean.TYPE),\n-        new ObjectStreamField(\"propertyPattern\", Boolean.TYPE)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields = { };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK: exception means no compat with 1.0, too bad\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-\n-    \/\/\n-    \/\/ Serialization compatibility stuff <==============================\n+    private static final long serialVersionUID = 1081892073854801359L;\n@@ -1091,54 +1040,15 @@\n-     * @serialData <ul>\n-     *               <li>In the current serial form (value of property\n-     *                   <code>jmx.serial.form<\/code> differs from\n-     *                   <code>1.0<\/code>): the string\n-     *                   &quot;&lt;domain&gt;:&lt;properties&gt;&lt;wild&gt;&quot;,\n-     *                   where: <ul>\n-     *                            <li>&lt;domain&gt; represents the domain part\n-     *                                of the {@link ObjectName}<\/li>\n-     *                            <li>&lt;properties&gt; represents the list of\n-     *                                properties, as returned by\n-     *                                {@link #getKeyPropertyListString}\n-     *                            <li>&lt;wild&gt; is empty if not\n-     *                                <code>isPropertyPattern<\/code>, or\n-     *                                is the character \"<code>*<\/code>\" if\n-     *                                <code>isPropertyPattern<\/code>\n-     *                                and &lt;properties&gt; is empty, or\n-     *                                is \"<code>,*<\/code>\" if\n-     *                                <code>isPropertyPattern<\/code> and\n-     *                                &lt;properties&gt; is not empty.\n-     *                            <\/li>\n-     *                          <\/ul>\n-     *                   The intent is that this string could be supplied\n-     *                   to the {@link #ObjectName(String)} constructor to\n-     *                   produce an equivalent {@link ObjectName}.\n-     *               <\/li>\n-     *               <li>In the old serial form (value of property\n-     *                   <code>jmx.serial.form<\/code> is\n-     *                   <code>1.0<\/code>): &lt;domain&gt; &lt;propertyList&gt;\n-     *                   &lt;propertyListString&gt; &lt;canonicalName&gt;\n-     *                   &lt;pattern&gt; &lt;propertyPattern&gt;,\n-     *                   where: <ul>\n-     *                            <li>&lt;domain&gt; represents the domain part\n-     *                                of the {@link ObjectName}<\/li>\n-     *                            <li>&lt;propertyList&gt; is the\n-     *                                {@link Hashtable} that contains all the\n-     *                                pairs (key,value) for this\n-     *                                {@link ObjectName}<\/li>\n-     *                            <li>&lt;propertyListString&gt; is the\n-     *                                {@link String} representation of the\n-     *                                list of properties in any order (not\n-     *                                mandatorily a canonical representation)\n-     *                                <\/li>\n-     *                            <li>&lt;canonicalName&gt; is the\n-     *                                {@link String} containing this\n-     *                                {@link ObjectName}'s canonical name<\/li>\n-     *                            <li>&lt;pattern&gt; is a boolean which is\n-     *                                <code>true<\/code> if this\n-     *                                {@link ObjectName} contains a pattern<\/li>\n-     *                            <li>&lt;propertyPattern&gt; is a boolean which\n-     *                                is <code>true<\/code> if this\n-     *                                {@link ObjectName} contains a pattern in\n-     *                                the list of properties<\/li>\n-     *                          <\/ul>\n-     *               <\/li>\n+     * @serialData The string &quot;&lt;domain&gt;:&lt;properties&gt;&lt;wild&gt;&quot;, where:\n+     *             <ul>\n+     *               <li>&lt;domain&gt; represents the domain part\n+     *                   of the {@link ObjectName}<\/li>\n+     *               <li>&lt;properties&gt; represents the list of\n+     *                   properties, as returned by\n+     *                   {@link #getKeyPropertyListString}<\/li>\n+     *               <li>&lt;wild&gt; is empty if not\n+     *                   <code>isPropertyPattern<\/code>, or\n+     *                   is the character \"<code>*<\/code>\" if\n+     *                   <code>isPropertyPattern<\/code>\n+     *                   and &lt;properties&gt; is empty, or\n+     *                   is \"<code>,*<\/code>\" if\n+     *                   <code>isPropertyPattern<\/code> and\n+     *                   &lt;properties&gt; is not empty.<\/li>\n@@ -1146,0 +1056,3 @@\n+     *             The intent is that this string could be supplied\n+     *             to the {@link #ObjectName(String)} constructor to\n+     *             produce an equivalent {@link ObjectName}.\n@@ -1151,24 +1064,2 @@\n-        if (compat) {\n-            \/\/ Read an object serialized in the old serial form\n-            \/\/\n-            \/\/in.defaultReadObject();\n-            final ObjectInputStream.GetField fields = in.readFields();\n-            String propListString =\n-                    (String)fields.get(\"propertyListString\", \"\");\n-\n-            \/\/ 6616825: take care of property patterns\n-            final boolean propPattern =\n-                    fields.get(\"propertyPattern\" , false);\n-            if (propPattern) {\n-                propListString =\n-                        (propListString.length()==0?\"*\":(propListString+\",*\"));\n-            }\n-\n-            cn = (String)fields.get(\"domain\", \"default\")+\n-                \":\"+ propListString;\n-        } else {\n-            \/\/ Read an object serialized in the new serial form\n-            \/\/\n-            in.defaultReadObject();\n-            cn = (String)in.readObject();\n-        }\n+        in.defaultReadObject();\n+        cn = (String)in.readObject();\n@@ -1186,54 +1077,15 @@\n-     * @serialData <ul>\n-     *               <li>In the current serial form (value of property\n-     *                   <code>jmx.serial.form<\/code> differs from\n-     *                   <code>1.0<\/code>): the string\n-     *                   &quot;&lt;domain&gt;:&lt;properties&gt;&lt;wild&gt;&quot;,\n-     *                   where: <ul>\n-     *                            <li>&lt;domain&gt; represents the domain part\n-     *                                of the {@link ObjectName}<\/li>\n-     *                            <li>&lt;properties&gt; represents the list of\n-     *                                properties, as returned by\n-     *                                {@link #getKeyPropertyListString}\n-     *                            <li>&lt;wild&gt; is empty if not\n-     *                                <code>isPropertyPattern<\/code>, or\n-     *                                is the character \"<code>*<\/code>\" if\n-     *                                this <code>isPropertyPattern<\/code>\n-     *                                and &lt;properties&gt; is empty, or\n-     *                                is \"<code>,*<\/code>\" if\n-     *                                <code>isPropertyPattern<\/code> and\n-     *                                &lt;properties&gt; is not empty.\n-     *                            <\/li>\n-     *                          <\/ul>\n-     *                   The intent is that this string could be supplied\n-     *                   to the {@link #ObjectName(String)} constructor to\n-     *                   produce an equivalent {@link ObjectName}.\n-     *               <\/li>\n-     *               <li>In the old serial form (value of property\n-     *                   <code>jmx.serial.form<\/code> is\n-     *                   <code>1.0<\/code>): &lt;domain&gt; &lt;propertyList&gt;\n-     *                   &lt;propertyListString&gt; &lt;canonicalName&gt;\n-     *                   &lt;pattern&gt; &lt;propertyPattern&gt;,\n-     *                   where: <ul>\n-     *                            <li>&lt;domain&gt; represents the domain part\n-     *                                of the {@link ObjectName}<\/li>\n-     *                            <li>&lt;propertyList&gt; is the\n-     *                                {@link Hashtable} that contains all the\n-     *                                pairs (key,value) for this\n-     *                                {@link ObjectName}<\/li>\n-     *                            <li>&lt;propertyListString&gt; is the\n-     *                                {@link String} representation of the\n-     *                                list of properties in any order (not\n-     *                                mandatorily a canonical representation)\n-     *                                <\/li>\n-     *                            <li>&lt;canonicalName&gt; is the\n-     *                                {@link String} containing this\n-     *                                {@link ObjectName}'s canonical name<\/li>\n-     *                            <li>&lt;pattern&gt; is a boolean which is\n-     *                                <code>true<\/code> if this\n-     *                                {@link ObjectName} contains a pattern<\/li>\n-     *                            <li>&lt;propertyPattern&gt; is a boolean which\n-     *                                is <code>true<\/code> if this\n-     *                                {@link ObjectName} contains a pattern in\n-     *                                the list of properties<\/li>\n-     *                          <\/ul>\n-     *               <\/li>\n+     * @serialData The string &quot;&lt;domain&gt;:&lt;properties&gt;&lt;wild&gt;&quot;, where:\n+     *             <ul>\n+     *               <li>&lt;domain&gt; represents the domain part\n+     *                   of the {@link ObjectName}<\/li>\n+     *               <li>&lt;properties&gt; represents the list of\n+     *                   properties, as returned by\n+     *                   {@link #getKeyPropertyListString}<\/li>\n+     *               <li>&lt;wild&gt; is empty if not\n+     *                   <code>isPropertyPattern<\/code>, or\n+     *                   is the character \"<code>*<\/code>\" if\n+     *                   this <code>isPropertyPattern<\/code>\n+     *                   and &lt;properties&gt; is empty, or\n+     *                   is \"<code>,*<\/code>\" if\n+     *                   <code>isPropertyPattern<\/code> and\n+     *                   &lt;properties&gt; is not empty.<\/li>\n@@ -1241,0 +1093,3 @@\n+     *             The intent is that this string could be supplied\n+     *             to the {@link #ObjectName(String)} constructor to\n+     *             produce an equivalent {@link ObjectName}.\n@@ -1245,20 +1100,2 @@\n-      if (compat)\n-      {\n-        \/\/ Serializes this instance in the old serial form\n-        \/\/ Read CR 6441274 before making any changes to this code\n-        ObjectOutputStream.PutField fields = out.putFields();\n-        fields.put(\"domain\", _canonicalName.substring(0, getDomainLength()));\n-        fields.put(\"propertyList\", getKeyPropertyList());\n-        fields.put(\"propertyListString\", getKeyPropertyListString());\n-        fields.put(\"canonicalName\", _canonicalName);\n-        fields.put(\"pattern\", (_compressed_storage & (DOMAIN_PATTERN | PROPLIST_PATTERN)) != 0);\n-        fields.put(\"propertyPattern\", isPropertyListPattern());\n-        out.writeFields();\n-      }\n-      else\n-      {\n-        \/\/ Serializes this instance in the new serial form\n-        \/\/\n-        out.defaultWriteObject();\n-        out.writeObject(getSerializedNameString());\n-      }\n+      out.defaultWriteObject();\n+      out.writeObject(getSerializedNameString());\n","filename":"src\/java.management\/share\/classes\/javax\/management\/ObjectName.java","additions":42,"deletions":205,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,0 @@\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID not constant\n@@ -89,27 +88,1 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = 8071560848919417985L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = -6292969195866300415L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"descriptor\", HashMap.class),\n-      new ObjectStreamField(\"currClass\", String.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"descriptor\", HashMap.class)\n-    };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n+    private static final long serialVersionUID = -6292969195866300415L;\n@@ -119,28 +92,4 @@\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static final String serialForm;\n-    static {\n-        serialForm = getForm();\n-        boolean compat = \"1.0\".equals(serialForm);  \/\/ serialForm may be null\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private static String getForm() {\n-        String form = null;\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            return  AccessController.doPrivileged(act);\n-        } catch (Exception e) {\n-            \/\/ OK: No compat with 1.0\n-            return null;\n-        }\n-    }\n-\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n+    private static final ObjectStreamField[] serialPersistentFields =\n+    {\n+      new ObjectStreamField(\"descriptor\", HashMap.class)\n+    };\n@@ -1289,11 +1238,0 @@\n-    \/* If you set jmx.serial.form to \"1.2.0\" or \"1.2.1\", then we are\n-       bug-compatible with those versions.  Specifically, field names\n-       are forced to lower-case before being written.  This\n-       contradicts the spec, which, though it does not mention\n-       serialization explicitly, does say that the case of field names\n-       is preserved.  But in 1.2.0 and 1.2.1, this requirement was not\n-       met.  Instead, field names in the descriptor map were forced to\n-       lower case.  Those versions expect this to have happened to a\n-       descriptor they deserialize and e.g. getFieldValue will not\n-       find a field whose name is spelt with a different case.\n-    *\/\n@@ -1302,3 +1240,0 @@\n-        boolean compat = \"1.0\".equals(serialForm);\n-        if (compat)\n-            fields.put(\"currClass\", currClass);\n@@ -1318,9 +1253,1 @@\n-        final HashMap<String, Object> descriptor;\n-        if (compat || \"1.2.0\".equals(serialForm) ||\n-                \"1.2.1\".equals(serialForm)) {\n-            descriptor = new HashMap<>();\n-            for (Map.Entry<String, Object> entry : startMap.entrySet())\n-                descriptor.put(entry.getKey().toLowerCase(), entry.getValue());\n-        } else\n-            descriptor = new HashMap<>(startMap);\n-\n+        final HashMap<String, Object> descriptor = new HashMap<>(startMap);\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/DescriptorSupport.java","additions":7,"deletions":80,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID not constant\n@@ -52,28 +51,1 @@\n-\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = 3711724570458346634L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = 1190536278266811217L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"msgStr\", String.class),\n-      new ObjectStreamField(\"relatedExcept\", Exception.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"exception\", Exception.class)\n-    };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n+    private static final long serialVersionUID = 1190536278266811217L;\n@@ -83,21 +55,4 @@\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK: No compat with 1.0\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n+    private static final ObjectStreamField[] serialPersistentFields =\n+    {\n+      new ObjectStreamField(\"exception\", Exception.class)\n+    };\n@@ -159,17 +114,1 @@\n-      if (compat)\n-      {\n-        \/\/ Read an object serialized in the old serial form\n-        \/\/\n-        ObjectInputStream.GetField fields = in.readFields();\n-        exception = (Exception) fields.get(\"relatedExcept\", null);\n-        if (fields.defaulted(\"relatedExcept\"))\n-        {\n-          throw new NullPointerException(\"relatedExcept\");\n-        }\n-      }\n-      else\n-      {\n-        \/\/ Read an object serialized in the new serial form\n-        \/\/\n-        in.defaultReadObject();\n-      }\n+      in.defaultReadObject();\n@@ -184,15 +123,1 @@\n-      if (compat)\n-      {\n-        \/\/ Serializes this instance in the old serial form\n-        \/\/\n-        ObjectOutputStream.PutField fields = out.putFields();\n-        fields.put(\"relatedExcept\", exception);\n-        fields.put(\"msgStr\", ((exception != null)?exception.getMessage():\"\"));\n-        out.writeFields();\n-      }\n-      else\n-      {\n-        \/\/ Serializes this instance in the new serial form\n-        \/\/\n-        out.defaultWriteObject();\n-      }\n+      out.defaultWriteObject();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/InvalidTargetObjectTypeException.java","additions":8,"deletions":83,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,0 @@\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID is not constant\n@@ -124,52 +123,9 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = 7098036920755973145L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = 6181543027787327345L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"attrDescriptor\", Descriptor.class),\n-      new ObjectStreamField(\"currClass\", String.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"attrDescriptor\", Descriptor.class)\n-    };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n-    \/**\n-     * @serialField attrDescriptor Descriptor The {@link Descriptor}\n-     * containing the metadata corresponding to this attribute\n-     *\/\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK: No compat with 1.0\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n+        private static final long serialVersionUID = 6181543027787327345L;\n+        \/**\n+         * @serialField attrDescriptor Descriptor The {@link Descriptor}\n+         * containing the metadata corresponding to this attribute\n+         *\/\n+        private static final ObjectStreamField[] serialPersistentFields =\n+        {\n+            new ObjectStreamField(\"attrDescriptor\", Descriptor.class)\n+        };\n@@ -511,15 +467,1 @@\n-      if (compat)\n-      {\n-        \/\/ Serializes this instance in the old serial form\n-        \/\/\n-        ObjectOutputStream.PutField fields = out.putFields();\n-        fields.put(\"attrDescriptor\", attrDescriptor);\n-        fields.put(\"currClass\", currClass);\n-        out.writeFields();\n-      }\n-      else\n-      {\n-        \/\/ Serializes this instance in the new serial form\n-        \/\/\n-        out.defaultWriteObject();\n-      }\n+      out.defaultWriteObject();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/ModelMBeanAttributeInfo.java","additions":11,"deletions":69,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,2 +92,0 @@\n-\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID is not constant\n@@ -98,51 +96,8 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = -4440125391095574518L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = 3862947819818064362L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"consDescriptor\", Descriptor.class),\n-      new ObjectStreamField(\"currClass\", String.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"consDescriptor\", Descriptor.class)\n-    };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n-    \/**\n-     * @serialField consDescriptor Descriptor The {@link Descriptor} containing the metadata for this instance\n-     *\/\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK: No compat with 1.0\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n+        private static final long serialVersionUID = 3862947819818064362L;\n+        \/**\n+         * @serialField consDescriptor Descriptor The {@link Descriptor} containing the metadata for this instance\n+         *\/\n+        private static final ObjectStreamField[] serialPersistentFields =\n+        {\n+          new ObjectStreamField(\"consDescriptor\", Descriptor.class)\n+        };\n@@ -467,15 +422,1 @@\n-      if (compat)\n-      {\n-        \/\/ Serializes this instance in the old serial form\n-        \/\/\n-        ObjectOutputStream.PutField fields = out.putFields();\n-        fields.put(\"consDescriptor\", consDescriptor);\n-        fields.put(\"currClass\", currClass);\n-        out.writeFields();\n-      }\n-      else\n-      {\n-        \/\/ Serializes this instance in the new serial form\n-        \/\/\n-        out.defaultWriteObject();\n-      }\n+      out.defaultWriteObject();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/ModelMBeanConstructorInfo.java","additions":10,"deletions":69,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,0 @@\n-@SuppressWarnings(\"serial\")\n@@ -87,35 +86,1 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = -3944083498453227709L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = -1935722590756516193L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-        new ObjectStreamField(\"modelMBeanDescriptor\", Descriptor.class),\n-                new ObjectStreamField(\"mmbAttributes\", MBeanAttributeInfo[].class),\n-                new ObjectStreamField(\"mmbConstructors\", MBeanConstructorInfo[].class),\n-                new ObjectStreamField(\"mmbNotifications\", MBeanNotificationInfo[].class),\n-                new ObjectStreamField(\"mmbOperations\", MBeanOperationInfo[].class),\n-                new ObjectStreamField(\"currClass\", String.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n-    {\n-        new ObjectStreamField(\"modelMBeanDescriptor\", Descriptor.class),\n-                new ObjectStreamField(\"modelMBeanAttributes\", MBeanAttributeInfo[].class),\n-                new ObjectStreamField(\"modelMBeanConstructors\", MBeanConstructorInfo[].class),\n-                new ObjectStreamField(\"modelMBeanNotifications\", MBeanNotificationInfo[].class),\n-                new ObjectStreamField(\"modelMBeanOperations\", MBeanOperationInfo[].class)\n-    };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n+    private static final long serialVersionUID = -1935722590756516193L;\n@@ -138,21 +103,8 @@\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK: No compat with 1.0\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n+    private static final ObjectStreamField[] serialPersistentFields =\n+    {\n+        new ObjectStreamField(\"modelMBeanDescriptor\", Descriptor.class),\n+                new ObjectStreamField(\"modelMBeanAttributes\", MBeanAttributeInfo[].class),\n+                new ObjectStreamField(\"modelMBeanConstructors\", MBeanConstructorInfo[].class),\n+                new ObjectStreamField(\"modelMBeanNotifications\", MBeanNotificationInfo[].class),\n+                new ObjectStreamField(\"modelMBeanOperations\", MBeanOperationInfo[].class)\n+    };\n@@ -960,34 +912,2 @@\n-        if (compat) {\n-            \/\/ Read an object serialized in the old serial form\n-            \/\/\n-            ObjectInputStream.GetField fields = in.readFields();\n-            modelMBeanDescriptor =\n-                    (Descriptor) fields.get(\"modelMBeanDescriptor\", null);\n-            if (fields.defaulted(\"modelMBeanDescriptor\")) {\n-                throw new NullPointerException(\"modelMBeanDescriptor\");\n-            }\n-            modelMBeanAttributes =\n-                    (MBeanAttributeInfo[]) fields.get(\"mmbAttributes\", null);\n-            if (fields.defaulted(\"mmbAttributes\")) {\n-                throw new NullPointerException(\"mmbAttributes\");\n-            }\n-            modelMBeanConstructors =\n-                    (MBeanConstructorInfo[]) fields.get(\"mmbConstructors\", null);\n-            if (fields.defaulted(\"mmbConstructors\")) {\n-                throw new NullPointerException(\"mmbConstructors\");\n-            }\n-            modelMBeanNotifications =\n-                    (MBeanNotificationInfo[]) fields.get(\"mmbNotifications\", null);\n-            if (fields.defaulted(\"mmbNotifications\")) {\n-                throw new NullPointerException(\"mmbNotifications\");\n-            }\n-            modelMBeanOperations =\n-                    (MBeanOperationInfo[]) fields.get(\"mmbOperations\", null);\n-            if (fields.defaulted(\"mmbOperations\")) {\n-                throw new NullPointerException(\"mmbOperations\");\n-            }\n-        } else {\n-            \/\/ Read an object serialized in the new serial form\n-            \/\/\n-            in.defaultReadObject();\n-        }\n+\n+        in.defaultReadObject();\n@@ -1002,16 +922,1 @@\n-        if (compat) {\n-            \/\/ Serializes this instance in the old serial form\n-            \/\/\n-            ObjectOutputStream.PutField fields = out.putFields();\n-            fields.put(\"modelMBeanDescriptor\", modelMBeanDescriptor);\n-            fields.put(\"mmbAttributes\", modelMBeanAttributes);\n-            fields.put(\"mmbConstructors\", modelMBeanConstructors);\n-            fields.put(\"mmbNotifications\", modelMBeanNotifications);\n-            fields.put(\"mmbOperations\", modelMBeanOperations);\n-            fields.put(\"currClass\", currClass);\n-            out.writeFields();\n-        } else {\n-            \/\/ Serializes this instance in the new serial form\n-            \/\/\n-            out.defaultWriteObject();\n-        }\n+        out.defaultWriteObject();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/ModelMBeanInfoSupport.java","additions":13,"deletions":108,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,2 +99,0 @@\n-\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID is not constant\n@@ -105,27 +103,1 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form\n-    \/\/ depends on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = -5211564525059047097L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = -7445681389570207141L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"notificationDescriptor\", Descriptor.class),\n-      new ObjectStreamField(\"currClass\", String.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"notificationDescriptor\", Descriptor.class)\n-    };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n+    private static final long serialVersionUID = -7445681389570207141L;\n@@ -136,21 +108,4 @@\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK: No compat with 1.0\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n+    private static final ObjectStreamField[] serialPersistentFields =\n+    {\n+      new ObjectStreamField(\"notificationDescriptor\", Descriptor.class)\n+    };\n@@ -401,12 +356,1 @@\n-        if (compat) {\n-            \/\/ Serializes this instance in the old serial form\n-            \/\/\n-            ObjectOutputStream.PutField fields = out.putFields();\n-            fields.put(\"notificationDescriptor\", notificationDescriptor);\n-            fields.put(\"currClass\", currClass);\n-            out.writeFields();\n-        } else {\n-            \/\/ Serializes this instance in the new serial form\n-            \/\/\n-            out.defaultWriteObject();\n-        }\n+        out.defaultWriteObject();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/ModelMBeanNotificationInfo.java","additions":7,"deletions":63,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,2 +111,0 @@\n-\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID is not constant\n@@ -117,52 +115,9 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = 9087646304346171239L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = 6532732096650090465L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"operationDescriptor\", Descriptor.class),\n-      new ObjectStreamField(\"currClass\", String.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"operationDescriptor\", Descriptor.class)\n-    };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n-    \/**\n-     * @serialField operationDescriptor Descriptor The descriptor\n-     * containing the appropriate metadata for this instance\n-     *\/\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK: No compat with 1.0\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n+        private static final long serialVersionUID = 6532732096650090465L;\n+        \/**\n+         * @serialField operationDescriptor Descriptor The descriptor\n+         * containing the appropriate metadata for this instance\n+         *\/\n+        private static final ObjectStreamField[] serialPersistentFields =\n+        {\n+          new ObjectStreamField(\"operationDescriptor\", Descriptor.class)\n+        };\n@@ -518,13 +473,0 @@\n-      if (compat)\n-      {\n-        \/\/ Serializes this instance in the old serial form\n-        \/\/\n-        ObjectOutputStream.PutField fields = out.putFields();\n-        fields.put(\"operationDescriptor\", operationDescriptor);\n-        fields.put(\"currClass\", currClass);\n-        out.writeFields();\n-      }\n-      else\n-      {\n-        \/\/ Serializes this instance in the new serial form\n-        \/\/\n@@ -532,1 +474,0 @@\n-      }\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/ModelMBeanOperationInfo.java","additions":10,"deletions":69,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID not constant\n@@ -56,44 +55,1 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = -7780049316655891976L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = 3176664577895105181L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"msgStr\", String.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-  private static final ObjectStreamField[] newSerialPersistentFields = { };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK: No compat with 1.0\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n+    private static final long serialVersionUID = 3176664577895105181L;\n@@ -144,14 +100,1 @@\n-      if (compat)\n-      {\n-        \/\/ Serializes this instance in the old serial form\n-        \/\/\n-        ObjectOutputStream.PutField fields = out.putFields();\n-        fields.put(\"msgStr\", getMessage());\n-        out.writeFields();\n-      }\n-      else\n-      {\n-        \/\/ Serializes this instance in the new serial form\n-        \/\/\n-        out.defaultWriteObject();\n-      }\n+      out.defaultWriteObject();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/XMLParseException.java","additions":3,"deletions":60,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,0 @@\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID must be constant\n@@ -63,28 +62,1 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = 6001782699077323605L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = 2605900539589789736L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"mySelectObjNameList\", Vector.class),\n-      new ObjectStreamField(\"myDeselectObjNameList\", Vector.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"selectedNames\", List.class),\n-      new ObjectStreamField(\"deselectedNames\", List.class)\n-    };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n+    private static final long serialVersionUID = 2605900539589789736L;\n@@ -105,21 +77,5 @@\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK : Too bad, no compat with 1.0\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n+    private static final ObjectStreamField[] serialPersistentFields =\n+    {\n+      new ObjectStreamField(\"selectedNames\", List.class),\n+      new ObjectStreamField(\"deselectedNames\", List.class)\n+    };\n@@ -408,22 +364,1 @@\n-      if (compat)\n-      {\n-        \/\/ Read an object serialized in the old serial form\n-        \/\/\n-        ObjectInputStream.GetField fields = in.readFields();\n-        selectedNames = cast(fields.get(\"mySelectObjNameList\", null));\n-        if (fields.defaulted(\"mySelectObjNameList\"))\n-        {\n-          throw new NullPointerException(\"mySelectObjNameList\");\n-        }\n-        deselectedNames = cast(fields.get(\"myDeselectObjNameList\", null));\n-        if (fields.defaulted(\"myDeselectObjNameList\"))\n-        {\n-          throw new NullPointerException(\"myDeselectObjNameList\");\n-        }\n-      }\n-      else\n-      {\n-        \/\/ Read an object serialized in the new serial form\n-        \/\/\n-        in.defaultReadObject();\n-      }\n+      in.defaultReadObject();\n@@ -438,15 +373,1 @@\n-      if (compat)\n-      {\n-        \/\/ Serializes this instance in the old serial form\n-        \/\/\n-        ObjectOutputStream.PutField fields = out.putFields();\n-        fields.put(\"mySelectObjNameList\", selectedNames);\n-        fields.put(\"myDeselectObjNameList\", deselectedNames);\n-        out.writeFields();\n-      }\n-      else\n-      {\n-        \/\/ Serializes this instance in the new serial form\n-        \/\/\n-        out.defaultWriteObject();\n-      }\n+      out.defaultWriteObject();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/relation\/MBeanServerNotificationFilter.java","additions":9,"deletions":88,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,0 @@\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID not constant\n@@ -63,38 +62,1 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = -2126464566505527147L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = -6871117877523310399L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-        new ObjectStreamField(\"myNewRoleValue\", ArrayList.class),\n-        new ObjectStreamField(\"myOldRoleValue\", ArrayList.class),\n-        new ObjectStreamField(\"myRelId\", String.class),\n-        new ObjectStreamField(\"myRelObjName\", ObjectName.class),\n-        new ObjectStreamField(\"myRelTypeName\", String.class),\n-        new ObjectStreamField(\"myRoleName\", String.class),\n-        new ObjectStreamField(\"myUnregMBeanList\", ArrayList.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n-    {\n-        new ObjectStreamField(\"newRoleValue\", List.class),\n-        new ObjectStreamField(\"oldRoleValue\", List.class),\n-        new ObjectStreamField(\"relationId\", String.class),\n-        new ObjectStreamField(\"relationObjName\", ObjectName.class),\n-        new ObjectStreamField(\"relationTypeName\", String.class),\n-        new ObjectStreamField(\"roleName\", String.class),\n-        new ObjectStreamField(\"unregisterMBeanList\", List.class)\n-    };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n+    private static final long serialVersionUID = -6871117877523310399L;\n@@ -118,21 +80,10 @@\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK : Too bad, no compat with 1.0\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n+    private static final ObjectStreamField[] serialPersistentFields =\n+    {\n+        new ObjectStreamField(\"newRoleValue\", List.class),\n+        new ObjectStreamField(\"oldRoleValue\", List.class),\n+        new ObjectStreamField(\"relationId\", String.class),\n+        new ObjectStreamField(\"relationObjName\", ObjectName.class),\n+        new ObjectStreamField(\"relationTypeName\", String.class),\n+        new ObjectStreamField(\"roleName\", String.class),\n+        new ObjectStreamField(\"unregisterMBeanList\", List.class)\n+    };\n@@ -544,4 +495,3 @@\n-        if (compat) {\n-            tmpRelationId = (String)fields.get(\"myRelId\", null);\n-            tmpRelationTypeName = (String)fields.get(\"myRelTypeName\", null);\n-            tmpRoleName = (String)fields.get(\"myRoleName\", null);\n+        tmpRelationId = (String)fields.get(\"relationId\", null);\n+        tmpRelationTypeName = (String)fields.get(\"relationTypeName\", null);\n+        tmpRoleName = (String)fields.get(\"roleName\", null);\n@@ -549,15 +499,4 @@\n-            tmpRelationObjName = (ObjectName)fields.get(\"myRelObjName\", null);\n-            tmpNewRoleValue = cast(fields.get(\"myNewRoleValue\", null));\n-            tmpOldRoleValue = cast(fields.get(\"myOldRoleValue\", null));\n-            tmpUnregMBeanList = cast(fields.get(\"myUnregMBeanList\", null));\n-        }\n-        else {\n-            tmpRelationId = (String)fields.get(\"relationId\", null);\n-            tmpRelationTypeName = (String)fields.get(\"relationTypeName\", null);\n-            tmpRoleName = (String)fields.get(\"roleName\", null);\n-\n-            tmpRelationObjName = (ObjectName)fields.get(\"relationObjName\", null);\n-            tmpNewRoleValue = cast(fields.get(\"newRoleValue\", null));\n-            tmpOldRoleValue = cast(fields.get(\"oldRoleValue\", null));\n-            tmpUnregMBeanList = cast(fields.get(\"unregisterMBeanList\", null));\n-        }\n+        tmpRelationObjName = (ObjectName)fields.get(\"relationObjName\", null);\n+        tmpNewRoleValue = cast(fields.get(\"newRoleValue\", null));\n+        tmpOldRoleValue = cast(fields.get(\"oldRoleValue\", null));\n+        tmpUnregMBeanList = cast(fields.get(\"unregisterMBeanList\", null));\n@@ -594,20 +533,1 @@\n-      if (compat)\n-      {\n-        \/\/ Serializes this instance in the old serial form\n-        \/\/\n-        ObjectOutputStream.PutField fields = out.putFields();\n-        fields.put(\"myNewRoleValue\", newRoleValue);\n-        fields.put(\"myOldRoleValue\", oldRoleValue);\n-        fields.put(\"myRelId\", relationId);\n-        fields.put(\"myRelObjName\", relationObjName);\n-        fields.put(\"myRelTypeName\", relationTypeName);\n-        fields.put(\"myRoleName\",roleName);\n-        fields.put(\"myUnregMBeanList\", unregisterMBeanList);\n-        out.writeFields();\n-      }\n-      else\n-      {\n-        \/\/ Serializes this instance in the new serial form\n-        \/\/\n-        out.defaultWriteObject();\n-      }\n+      out.defaultWriteObject();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/relation\/RelationNotification.java","additions":20,"deletions":100,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID not constant\n@@ -69,30 +68,1 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = -8179019472410837190L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = 4611072955724144607L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"myTypeName\", String.class),\n-      new ObjectStreamField(\"myRoleName2InfoMap\", HashMap.class),\n-      new ObjectStreamField(\"myIsInRelServFlg\", boolean.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"typeName\", String.class),\n-      new ObjectStreamField(\"roleName2InfoMap\", Map.class),\n-      new ObjectStreamField(\"isInRelationService\", boolean.class)\n-    };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n+    private static final long serialVersionUID = 4611072955724144607L;\n@@ -106,21 +76,6 @@\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK : Too bad, no compat with 1.0\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n+    private static final ObjectStreamField[] serialPersistentFields =\n+    {\n+      new ObjectStreamField(\"typeName\", String.class),\n+      new ObjectStreamField(\"roleName2InfoMap\", Map.class),\n+      new ObjectStreamField(\"isInRelationService\", boolean.class)\n+    };\n@@ -424,27 +379,1 @@\n-      if (compat)\n-      {\n-        \/\/ Read an object serialized in the old serial form\n-        \/\/\n-        ObjectInputStream.GetField fields = in.readFields();\n-        typeName = (String) fields.get(\"myTypeName\", null);\n-        if (fields.defaulted(\"myTypeName\"))\n-        {\n-          throw new NullPointerException(\"myTypeName\");\n-        }\n-        roleName2InfoMap = cast(fields.get(\"myRoleName2InfoMap\", null));\n-        if (fields.defaulted(\"myRoleName2InfoMap\"))\n-        {\n-          throw new NullPointerException(\"myRoleName2InfoMap\");\n-        }\n-        isInRelationService = fields.get(\"myIsInRelServFlg\", false);\n-        if (fields.defaulted(\"myIsInRelServFlg\"))\n-        {\n-          throw new NullPointerException(\"myIsInRelServFlg\");\n-        }\n-      }\n-      else\n-      {\n-        \/\/ Read an object serialized in the new serial form\n-        \/\/\n-        in.defaultReadObject();\n-      }\n+      in.defaultReadObject();\n@@ -459,16 +388,1 @@\n-      if (compat)\n-      {\n-        \/\/ Serializes this instance in the old serial form\n-        \/\/\n-        ObjectOutputStream.PutField fields = out.putFields();\n-        fields.put(\"myTypeName\", typeName);\n-        fields.put(\"myRoleName2InfoMap\", roleName2InfoMap);\n-        fields.put(\"myIsInRelServFlg\", isInRelationService);\n-        out.writeFields();\n-      }\n-      else\n-      {\n-        \/\/ Serializes this instance in the new serial form\n-        \/\/\n-        out.defaultWriteObject();\n-      }\n+      out.defaultWriteObject();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/relation\/RelationTypeSupport.java","additions":10,"deletions":96,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,0 @@\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID not constant\n@@ -57,28 +56,1 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = -1959486389343113026L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = -279985518429862552L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"myName\", String.class),\n-      new ObjectStreamField(\"myObjNameList\", ArrayList.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"name\", String.class),\n-      new ObjectStreamField(\"objectNameList\", List.class)\n-    };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n+    private static final long serialVersionUID = -279985518429862552L;\n@@ -89,21 +61,5 @@\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK : Too bad, no compat with 1.0\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n+    private static final ObjectStreamField[] serialPersistentFields =\n+    {\n+      new ObjectStreamField(\"name\", String.class),\n+      new ObjectStreamField(\"objectNameList\", List.class)\n+    };\n@@ -293,22 +249,1 @@\n-      if (compat)\n-      {\n-        \/\/ Read an object serialized in the old serial form\n-        \/\/\n-        ObjectInputStream.GetField fields = in.readFields();\n-        name = (String) fields.get(\"myName\", null);\n-        if (fields.defaulted(\"myName\"))\n-        {\n-          throw new NullPointerException(\"myName\");\n-        }\n-        objectNameList = cast(fields.get(\"myObjNameList\", null));\n-        if (fields.defaulted(\"myObjNameList\"))\n-        {\n-          throw new NullPointerException(\"myObjNameList\");\n-        }\n-      }\n-      else\n-      {\n-        \/\/ Read an object serialized in the new serial form\n-        \/\/\n-        in.defaultReadObject();\n-      }\n+      in.defaultReadObject();\n@@ -323,15 +258,1 @@\n-      if (compat)\n-      {\n-        \/\/ Serializes this instance in the old serial form\n-        \/\/\n-        ObjectOutputStream.PutField fields = out.putFields();\n-        fields.put(\"myName\", name);\n-        fields.put(\"myObjNameList\", objectNameList);\n-        out.writeFields();\n-      }\n-      else\n-      {\n-        \/\/ Serializes this instance in the new serial form\n-        \/\/\n-        out.defaultWriteObject();\n-      }\n+      out.defaultWriteObject();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/relation\/Role.java","additions":9,"deletions":88,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID not constant\n@@ -52,38 +51,1 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = 7227256952085334351L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = 2504952983494636987L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"myName\", String.class),\n-      new ObjectStreamField(\"myIsReadableFlg\", boolean.class),\n-      new ObjectStreamField(\"myIsWritableFlg\", boolean.class),\n-      new ObjectStreamField(\"myDescription\", String.class),\n-      new ObjectStreamField(\"myMinDegree\", int.class),\n-      new ObjectStreamField(\"myMaxDegree\", int.class),\n-      new ObjectStreamField(\"myRefMBeanClassName\", String.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"name\", String.class),\n-      new ObjectStreamField(\"isReadable\", boolean.class),\n-      new ObjectStreamField(\"isWritable\", boolean.class),\n-      new ObjectStreamField(\"description\", String.class),\n-      new ObjectStreamField(\"minDegree\", int.class),\n-      new ObjectStreamField(\"maxDegree\", int.class),\n-      new ObjectStreamField(\"referencedMBeanClassName\", String.class)\n-    };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n+    private static final long serialVersionUID = 2504952983494636987L;\n@@ -99,21 +61,10 @@\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK : Too bad, no compat with 1.0\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n+    private static final ObjectStreamField[] serialPersistentFields =\n+    {\n+      new ObjectStreamField(\"name\", String.class),\n+      new ObjectStreamField(\"isReadable\", boolean.class),\n+      new ObjectStreamField(\"isWritable\", boolean.class),\n+      new ObjectStreamField(\"description\", String.class),\n+      new ObjectStreamField(\"minDegree\", int.class),\n+      new ObjectStreamField(\"maxDegree\", int.class),\n+      new ObjectStreamField(\"referencedMBeanClassName\", String.class)\n+    };\n@@ -533,47 +484,1 @@\n-      if (compat)\n-      {\n-        \/\/ Read an object serialized in the old serial form\n-        \/\/\n-        ObjectInputStream.GetField fields = in.readFields();\n-        name = (String) fields.get(\"myName\", null);\n-        if (fields.defaulted(\"myName\"))\n-        {\n-          throw new NullPointerException(\"myName\");\n-        }\n-        isReadable = fields.get(\"myIsReadableFlg\", false);\n-        if (fields.defaulted(\"myIsReadableFlg\"))\n-        {\n-          throw new NullPointerException(\"myIsReadableFlg\");\n-        }\n-        isWritable = fields.get(\"myIsWritableFlg\", false);\n-        if (fields.defaulted(\"myIsWritableFlg\"))\n-        {\n-          throw new NullPointerException(\"myIsWritableFlg\");\n-        }\n-        description = (String) fields.get(\"myDescription\", null);\n-        if (fields.defaulted(\"myDescription\"))\n-        {\n-          throw new NullPointerException(\"myDescription\");\n-        }\n-        minDegree = fields.get(\"myMinDegree\", 0);\n-        if (fields.defaulted(\"myMinDegree\"))\n-        {\n-          throw new NullPointerException(\"myMinDegree\");\n-        }\n-        maxDegree = fields.get(\"myMaxDegree\", 0);\n-        if (fields.defaulted(\"myMaxDegree\"))\n-        {\n-          throw new NullPointerException(\"myMaxDegree\");\n-        }\n-        referencedMBeanClassName = (String) fields.get(\"myRefMBeanClassName\", null);\n-        if (fields.defaulted(\"myRefMBeanClassName\"))\n-        {\n-          throw new NullPointerException(\"myRefMBeanClassName\");\n-        }\n-      }\n-      else\n-      {\n-        \/\/ Read an object serialized in the new serial form\n-        \/\/\n-        in.defaultReadObject();\n-      }\n+      in.defaultReadObject();\n@@ -588,20 +493,1 @@\n-      if (compat)\n-      {\n-        \/\/ Serializes this instance in the old serial form\n-        \/\/\n-        ObjectOutputStream.PutField fields = out.putFields();\n-        fields.put(\"myName\", name);\n-        fields.put(\"myIsReadableFlg\", isReadable);\n-        fields.put(\"myIsWritableFlg\", isWritable);\n-        fields.put(\"myDescription\", description);\n-        fields.put(\"myMinDegree\", minDegree);\n-        fields.put(\"myMaxDegree\", maxDegree);\n-        fields.put(\"myRefMBeanClassName\", referencedMBeanClassName);\n-        out.writeFields();\n-      }\n-      else\n-      {\n-        \/\/ Serializes this instance in the new serial form\n-        \/\/\n-        out.defaultWriteObject();\n-      }\n+      out.defaultWriteObject();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/relation\/RoleInfo.java","additions":14,"deletions":128,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-@SuppressWarnings(\"serial\")\n@@ -50,28 +49,1 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = 3786616013762091099L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = -6304063118040985512L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"myRoleList\", RoleList.class),\n-      new ObjectStreamField(\"myRoleUnresList\", RoleUnresolvedList.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"roleList\", RoleList.class),\n-      new ObjectStreamField(\"unresolvedRoleList\", RoleUnresolvedList.class)\n-    };\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n+    private static final long serialVersionUID = -6304063118040985512L;\n@@ -82,21 +54,5 @@\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK : Too bad, no compat with 1.0\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n+    private static final ObjectStreamField[] serialPersistentFields =\n+    {\n+      new ObjectStreamField(\"roleList\", RoleList.class),\n+      new ObjectStreamField(\"unresolvedRoleList\", RoleUnresolvedList.class)\n+    };\n@@ -209,22 +165,1 @@\n-      if (compat)\n-      {\n-        \/\/ Read an object serialized in the old serial form\n-        \/\/\n-        ObjectInputStream.GetField fields = in.readFields();\n-        roleList = (RoleList) fields.get(\"myRoleList\", null);\n-        if (fields.defaulted(\"myRoleList\"))\n-        {\n-          throw new NullPointerException(\"myRoleList\");\n-        }\n-        unresolvedRoleList = (RoleUnresolvedList) fields.get(\"myRoleUnresList\", null);\n-        if (fields.defaulted(\"myRoleUnresList\"))\n-        {\n-          throw new NullPointerException(\"myRoleUnresList\");\n-        }\n-      }\n-      else\n-      {\n-        \/\/ Read an object serialized in the new serial form\n-        \/\/\n-        in.defaultReadObject();\n-      }\n+      in.defaultReadObject();\n@@ -239,15 +174,1 @@\n-      if (compat)\n-      {\n-        \/\/ Serializes this instance in the old serial form\n-        \/\/\n-        ObjectOutputStream.PutField fields = out.putFields();\n-        fields.put(\"myRoleList\", roleList);\n-        fields.put(\"myRoleUnresList\", unresolvedRoleList);\n-        out.writeFields();\n-      }\n-      else\n-      {\n-        \/\/ Serializes this instance in the new serial form\n-        \/\/\n-        out.defaultWriteObject();\n-      }\n+      out.defaultWriteObject();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/relation\/RoleResult.java","additions":9,"deletions":88,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n-@SuppressWarnings(\"serial\")  \/\/ serialVersionUID not constant\n@@ -58,22 +57,6 @@\n-    \/\/ Serialization compatibility stuff:\n-    \/\/ Two serial forms are supported in this class. The selected form depends\n-    \/\/ on system property \"jmx.serial.form\":\n-    \/\/  - \"1.0\" for JMX 1.0\n-    \/\/  - any other value for JMX 1.1 and higher\n-    \/\/\n-    \/\/ Serial version for old serial form\n-    private static final long oldSerialVersionUID = -9026457686611660144L;\n-    \/\/\n-    \/\/ Serial version for new serial form\n-    private static final long newSerialVersionUID = -48350262537070138L;\n-    \/\/\n-    \/\/ Serializable fields in old serial form\n-    private static final ObjectStreamField[] oldSerialPersistentFields =\n-    {\n-      new ObjectStreamField(\"myRoleName\", String.class),\n-      new ObjectStreamField(\"myRoleValue\", ArrayList.class),\n-      new ObjectStreamField(\"myPbType\", int.class)\n-    };\n-    \/\/\n-    \/\/ Serializable fields in new serial form\n-    private static final ObjectStreamField[] newSerialPersistentFields =\n+    private static final long serialVersionUID = -48350262537070138L;\n+    \/** @serialField roleName String Role name\n+     *  @serialField roleValue List Role value ({@link List} of {@link ObjectName} objects)\n+     *  @serialField problemType int Problem type\n+     *\/\n+    private static final ObjectStreamField[] serialPersistentFields =\n@@ -85,28 +68,0 @@\n-    \/\/\n-    \/\/ Actual serial version and serial form\n-    private static final long serialVersionUID;\n-    \/** @serialField roleName String Role name\n-     *  @serialField roleValue List Role value ({@link List} of {@link ObjectName} objects)\n-     *  @serialField problemType int Problem type\n-     *\/\n-    private static final ObjectStreamField[] serialPersistentFields;\n-    private static boolean compat = false;\n-    static {\n-        try {\n-            GetPropertyAction act = new GetPropertyAction(\"jmx.serial.form\");\n-            @SuppressWarnings(\"removal\")\n-            String form = AccessController.doPrivileged(act);\n-            compat = (form != null && form.equals(\"1.0\"));\n-        } catch (Exception e) {\n-            \/\/ OK : Too bad, no compat with 1.0\n-        }\n-        if (compat) {\n-            serialPersistentFields = oldSerialPersistentFields;\n-            serialVersionUID = oldSerialVersionUID;\n-        } else {\n-            serialPersistentFields = newSerialPersistentFields;\n-            serialVersionUID = newSerialVersionUID;\n-        }\n-    }\n-    \/\/\n-    \/\/ END Serialization compatibility stuff\n@@ -307,27 +262,1 @@\n-      if (compat)\n-      {\n-        \/\/ Read an object serialized in the old serial form\n-        \/\/\n-        ObjectInputStream.GetField fields = in.readFields();\n-        roleName = (String) fields.get(\"myRoleName\", null);\n-        if (fields.defaulted(\"myRoleName\"))\n-        {\n-          throw new NullPointerException(\"myRoleName\");\n-        }\n-        roleValue = cast(fields.get(\"myRoleValue\", null));\n-        if (fields.defaulted(\"myRoleValue\"))\n-        {\n-          throw new NullPointerException(\"myRoleValue\");\n-        }\n-        problemType = fields.get(\"myPbType\", 0);\n-        if (fields.defaulted(\"myPbType\"))\n-        {\n-          throw new NullPointerException(\"myPbType\");\n-        }\n-      }\n-      else\n-      {\n-        \/\/ Read an object serialized in the new serial form\n-        \/\/\n-        in.defaultReadObject();\n-      }\n+      in.defaultReadObject();\n@@ -342,16 +271,1 @@\n-      if (compat)\n-      {\n-        \/\/ Serializes this instance in the old serial form\n-        \/\/\n-        ObjectOutputStream.PutField fields = out.putFields();\n-        fields.put(\"myRoleName\", roleName);\n-        fields.put(\"myRoleValue\", roleValue);\n-        fields.put(\"myPbType\", problemType);\n-        out.writeFields();\n-      }\n-      else\n-      {\n-        \/\/ Serializes this instance in the new serial form\n-        \/\/\n-        out.defaultWriteObject();\n-      }\n+      out.defaultWriteObject();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/relation\/RoleUnresolved.java","additions":9,"deletions":95,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import jdk.internal.net.http.common.Log;\n@@ -495,1 +496,1 @@\n-    private void removeFromPool(HttpConnection c) {\n+    private boolean removeFromPool(HttpConnection c) {\n@@ -498,1 +499,1 @@\n-            removeFromPool(c, plainPool);\n+            return removeFromPool(c, plainPool);\n@@ -501,1 +502,1 @@\n-            removeFromPool(c, sslPool);\n+            return removeFromPool(c, sslPool);\n@@ -527,1 +528,1 @@\n-    void cleanup(HttpConnection c, Throwable error) {\n+    void cleanup(HttpConnection c, long pendingData, Throwable error) {\n@@ -532,0 +533,1 @@\n+        boolean removed;\n@@ -533,1 +535,1 @@\n-            removeFromPool(c);\n+            removed = removeFromPool(c);\n@@ -538,1 +540,18 @@\n-        c.close();\n+        if (!removed && pendingData != 0) {\n+            \/\/ this should not happen; the cleanup may have consumed\n+            \/\/ some data that wasn't supposed to be consumed, so\n+            \/\/ the only thing we can do is log it and close the\n+            \/\/ connection.\n+            if (Log.errors()) {\n+                Log.logError(\"WARNING: CleanupTrigger triggered for\" +\n+                        \" a connection not found in the pool: closing {0}\", c.dbgString());\n+            }\n+            if (debug.on()) {\n+                debug.log(\"WARNING: CleanupTrigger triggered for\" +\n+                        \" a connection not found in the pool: closing %s\", c.dbgString());\n+            }\n+            Throwable cause = new IOException(\"Unexpected cleanup triggered for non pooled connection\", error);\n+            c.close(cause);\n+        } else {\n+            c.close();\n+        }\n@@ -552,0 +571,1 @@\n+        private volatile boolean dropped;\n@@ -559,1 +579,1 @@\n-        private void triggerCleanup(Throwable error) {\n+        private void triggerCleanup(long pendingData, Throwable error) {\n@@ -561,1 +581,4 @@\n-            cleanup(connection, error);\n+            if (debug.on()) {\n+                debug.log(\"Cleanup triggered for %s: pendingData:%s error:%s\", this, pendingData, error);\n+            }\n+            cleanup(connection, pendingData, error);\n@@ -569,0 +592,1 @@\n+            if (dropped || done) return;\n@@ -572,1 +596,1 @@\n-        public void onError(Throwable error) { triggerCleanup(error); }\n+        public void onError(Throwable error) { triggerCleanup(0, error); }\n@@ -574,1 +598,1 @@\n-        public void onComplete() { triggerCleanup(null); }\n+        public void onComplete() { triggerCleanup(0, null); }\n@@ -577,1 +601,1 @@\n-            triggerCleanup(new IOException(\"Data received while in pool\"));\n+            triggerCleanup(Utils.remaining(item), new IOException(\"Data received while in pool\"));\n@@ -589,0 +613,5 @@\n+\n+        @Override\n+        public void dropSubscription() {\n+            dropped = true;\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ConnectionPool.java","additions":41,"deletions":12,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n@@ -456,0 +458,7 @@\n+\n+        long responseTimeoutMillis = 5000;\n+        if (request.timeout().isPresent()) {\n+            final long timeoutMillis = request.timeout().get().toMillis();\n+            responseTimeoutMillis = Math.min(responseTimeoutMillis, timeoutMillis);\n+        }\n+\n@@ -457,0 +466,1 @@\n+                .completeOnTimeout(null, responseTimeoutMillis, TimeUnit.MILLISECONDS)\n@@ -458,24 +468,39 @@\n-            Log.logResponse(r1::toString);\n-            int rcode = r1.statusCode();\n-            if (rcode == 100) {\n-                Log.logTrace(\"Received 100-Continue: sending body\");\n-                if (debug.on()) debug.log(\"Received 100-Continue for %s\", r1);\n-                CompletableFuture<Response> cf =\n-                        exchImpl.sendBodyAsync()\n-                                .thenCompose(exIm -> exIm.getResponseAsync(parentExecutor));\n-                cf = wrapForUpgrade(cf);\n-                cf = wrapForLog(cf);\n-                return cf;\n-            } else {\n-                Log.logTrace(\"Expectation failed: Received {0}\",\n-                        rcode);\n-                if (debug.on()) debug.log(\"Expect-Continue failed (%d) for: %s\", rcode, r1);\n-                if (upgrading && rcode == 101) {\n-                    IOException failed = new IOException(\n-                            \"Unable to handle 101 while waiting for 100\");\n-                    return MinimalFuture.failedFuture(failed);\n-                }\n-                exchImpl.expectContinueFailed(rcode);\n-                return MinimalFuture.completedFuture(r1);\n-            }\n-        });\n+                    \/\/ The response will only be null if there was a timeout\n+                    \/\/ send body regardless\n+                    if (r1 == null) {\n+                        if (debug.on())\n+                            debug.log(\"Setting ExpectTimeoutRaised and sending request body\");\n+                        exchImpl.setExpectTimeoutRaised();\n+                        CompletableFuture<Response> cf =\n+                                exchImpl.sendBodyAsync()\n+                                        .thenCompose(exIm -> exIm.getResponseAsync(parentExecutor));\n+                        cf = wrapForUpgrade(cf);\n+                        cf = wrapForLog(cf);\n+                        return cf;\n+                    }\n+\n+                    Log.logResponse(r1::toString);\n+                    int rcode = r1.statusCode();\n+                    if (rcode == 100) {\n+                        Log.logTrace(\"Received 100-Continue: sending body\");\n+                        if (debug.on())\n+                            debug.log(\"Received 100-Continue for %s\", r1);\n+                        CompletableFuture<Response> cf =\n+                                exchImpl.sendBodyAsync()\n+                                        .thenCompose(exIm -> exIm.getResponseAsync(parentExecutor));\n+                        cf = wrapForUpgrade(cf);\n+                        cf = wrapForLog(cf);\n+                        return cf;\n+                    } else {\n+                        Log.logTrace(\"Expectation failed: Received {0}\", rcode);\n+                        if (debug.on())\n+                            debug.log(\"Expect-Continue failed (%d) for: %s\", rcode, r1);\n+                        if (upgrading && rcode == 101) {\n+                            IOException failed = new IOException(\n+                                    \"Unable to handle 101 while waiting for 100\");\n+                            return MinimalFuture.failedFuture(failed);\n+                        }\n+                        exchImpl.expectContinueFailed(rcode);\n+                        return MinimalFuture.completedFuture(r1);\n+                    }\n+                });\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":50,"deletions":25,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+    private volatile boolean expectTimeoutRaised;\n+\n@@ -74,0 +76,8 @@\n+    final void setExpectTimeoutRaised() {\n+        expectTimeoutRaised = true;\n+    }\n+\n+    final boolean expectTimeoutRaised() {\n+        return expectTimeoutRaised;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.concurrent.ConcurrentLinkedQueue;\n@@ -560,1 +561,1 @@\n-        AtomicReference<ReadSubscription> pendingSubscription = new AtomicReference<>();\n+        ConcurrentLinkedQueue<ReadSubscription> pendingSubscriptions = new ConcurrentLinkedQueue<>();\n@@ -568,4 +569,2 @@\n-            ReadSubscription target = new ReadSubscription(subscriptionImpl, sub);\n-            ReadSubscription previous = pendingSubscription.getAndSet(target);\n-\n-            if (previous != null && previous != target) {\n+            ReadSubscription previous;\n+            while ((previous = pendingSubscriptions.poll()) != null) {\n@@ -576,0 +575,2 @@\n+                \/\/ make sure no data will be routed to the old subscriber.\n+                previous.stopReading();\n@@ -583,0 +584,2 @@\n+            ReadSubscription target = new ReadSubscription(subscriptionImpl, sub);\n+            pendingSubscriptions.offer(target);\n@@ -584,1 +587,1 @@\n-            if (debug.on()) debug.log(\"read publisher got subscriber\");\n+            if (debug.on()) debug.log(\"read publisher got new subscriber: \" + s);\n@@ -609,0 +612,1 @@\n+            private volatile boolean stopped;\n@@ -626,1 +630,2 @@\n-                if (!cancelled) {\n+                if (!cancelled && !stopped) {\n+                    \/\/ should be safe to not synchronize here.\n@@ -630,1 +635,1 @@\n-                        debug.log(\"subscription cancelled, ignoring request %d\", n);\n+                        debug.log(\"subscription stopped or cancelled, ignoring request %d\", n);\n@@ -664,0 +669,26 @@\n+\n+            \/**\n+             * Called when switching subscriber on the {@link InternalReadSubscription}.\n+             * This subscriber is the old subscriber. Demand on the internal\n+             * subscription will be reset and reading will be paused until the\n+             * new subscriber is subscribed.\n+             * This should ensure that no data is routed to this subscriber\n+             * until the new subscriber is subscribed.\n+             *\/\n+            synchronized void stopReading() {\n+                stopped = true;\n+                impl.demand.reset();\n+            }\n+\n+            synchronized boolean tryDecrementDemand() {\n+                if (stopped) return false;\n+                return impl.demand.tryDecrement();\n+            }\n+\n+            synchronized boolean isStopped() {\n+                return stopped;\n+            }\n+\n+            synchronized void increaseDemand(long n) {\n+                if (!stopped) impl.demand.increase(n);\n+            }\n@@ -838,1 +869,1 @@\n-                        if (demand.tryDecrement()) {\n+                        if (current.tryDecrementDemand()) {\n@@ -884,2 +915,4 @@\n-                                    demand.increase(1);\n-                                    resumeReadEvent();\n+                                    if (!current.isStopped()) {\n+                                        current.increaseDemand(1);\n+                                        resumeReadEvent();\n+                                    }\n@@ -925,4 +958,6 @@\n-                ReadSubscription pending = pendingSubscription.getAndSet(null);\n-                if (pending == null) return false;\n-                if (debug.on())\n-                    debug.log(\"handling pending subscription for %s\",\n+                ReadSubscription pending;\n+                boolean subscribed = false;\n+                while ((pending = pendingSubscriptions.poll()) != null) {\n+                    subscribed = true;\n+                    if (debug.on())\n+                        debug.log(\"handling pending subscription for %s\",\n@@ -930,15 +965,8 @@\n-                ReadSubscription current = subscription;\n-                if (current != null && current != pending && !completed) {\n-                    current.subscriber.dropSubscription();\n-                }\n-                if (debug.on()) debug.log(\"read demand reset to 0\");\n-                subscriptionImpl.demand.reset(); \/\/ subscriber will increase demand if it needs to.\n-                pending.errorRef.compareAndSet(null, errorRef.get());\n-                if (!readScheduler.isStopped()) {\n-                    subscription = pending;\n-                } else {\n-                    if (debug.on()) debug.log(\"socket tube is already stopped\");\n-                }\n-                if (debug.on()) debug.log(\"calling onSubscribe\");\n-                pending.signalOnSubscribe();\n-                if (completed) {\n+                    ReadSubscription current = subscription;\n+                    if (current != null && current != pending && !completed) {\n+                        debug.log(\"dropping pending subscription for current %s\",\n+                                current.subscriber);\n+                        current.subscriber.dropSubscription();\n+                    }\n+                    if (debug.on()) debug.log(\"read demand reset to 0\");\n+                    subscriptionImpl.demand.reset(); \/\/ subscriber will increase demand if it needs to.\n@@ -946,1 +974,11 @@\n-                    pending.signalCompletion();\n+                    if (!readScheduler.isStopped()) {\n+                        subscription = pending;\n+                    } else {\n+                        if (debug.on()) debug.log(\"socket tube is already stopped\");\n+                    }\n+                    if (debug.on()) debug.log(\"calling onSubscribe on \" + pending.subscriber);\n+                    pending.signalOnSubscribe();\n+                    if (completed) {\n+                        pending.errorRef.compareAndSet(null, errorRef.get());\n+                        pending.signalCompletion();\n+                    }\n@@ -948,1 +986,1 @@\n-                return true;\n+                return subscribed;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/SocketTube.java","additions":71,"deletions":33,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -1203,2 +1203,7 @@\n-                \/\/ it will be already completed.\n-                cf = response_cfs.remove(0);\n+                \/\/ it will be already completed, unless the expect continue\n+                \/\/ timeout fired\n+                cf = response_cfs.get(0);\n+                if (cf.isDone()) {\n+                    cf = response_cfs.remove(0);\n+                }\n+\n@@ -1207,1 +1212,2 @@\n-                assert cf.isDone() : \"Removing uncompleted response: could cause code to hang!\";\n+                assert cf.isDone() || request.expectContinue && expectTimeoutRaised()\n+                        : \"Removing uncompleted response: could cause code to hang!\";\n@@ -1242,1 +1248,1 @@\n-                if (!cf.isDone()) {\n+                if (!cf.isDone() && !expectTimeoutRaised()) {\n@@ -1250,0 +1256,8 @@\n+                } else if (expectTimeoutRaised()) {\n+                    Log.logTrace(\"Completing response (streamid={0}): {1}\",\n+                            streamid, cf);\n+                    if (debug.on())\n+                        debug.log(\"Completing responseCF(%d) with response headers\", i);\n+                    \/\/ The Request will be removed in getResponseAsync()\n+                    cf.complete(resp);\n+                    return;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,0 +183,4 @@\n+            @Override\n+            public String toString() {\n+                return \"TubeSubscriberWrapper(\"+delegate.toString()+\")\";\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/FlowTube.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,691 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.net.http.hpack;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-\n-import static java.lang.String.format;\n-\n-\/**\n- * Huffman coding table.\n- *\n- * <p> Instances of this class are safe for use by multiple threads.\n- *\n- * @since 9\n- *\/\n-public final class NaiveHuffman {\n-\n-    \/\/ TODO: check if reset is done in both reader and writer\n-\n-    static final class Reader implements Huffman.Reader {\n-\n-        private Node curr; \/\/ position in the trie\n-        private int len;   \/\/ length of the path from the root to 'curr'\n-        private int p;     \/\/ byte probe\n-\n-        {\n-            reset();\n-        }\n-\n-        @Override\n-        public void read(ByteBuffer source,\n-                         Appendable destination,\n-                         boolean isLast) throws IOException {\n-            read(source, destination, true, isLast);\n-        }\n-\n-        \/\/ Takes 'isLast' rather than returns whether the reading is done or\n-        \/\/ not, for more informative exceptions.\n-        void read(ByteBuffer source,\n-                  Appendable destination,\n-                  boolean reportEOS, \/* reportEOS is exposed for tests *\/\n-                  boolean isLast) throws IOException {\n-            Node c = curr;\n-            int l = len;\n-            \/*\n-               Since ByteBuffer is itself stateful, its position is\n-               remembered here NOT as a part of Reader's state,\n-               but to set it back in the case of a failure\n-             *\/\n-            int pos = source.position();\n-\n-            while (source.hasRemaining()) {\n-                int d = source.get();\n-                for (; p != 0; p >>= 1) {\n-                    c = c.getChild(p & d);\n-                    l++;\n-                    if (c.isLeaf()) {\n-                        if (reportEOS && c.isEOSPath) {\n-                            throw new IOException(\"Encountered EOS\");\n-                        }\n-                        char ch;\n-                        try {\n-                            ch = c.getChar();\n-                        } catch (IllegalStateException e) {\n-                            source.position(pos); \/\/ do we need this?\n-                            throw new IOException(e);\n-                        }\n-                        try {\n-                            destination.append(ch);\n-                        } catch (IOException e) {\n-                            source.position(pos); \/\/ do we need this?\n-                            throw e;\n-                        }\n-                        c = INSTANCE.root;\n-                        l = 0;\n-                    }\n-                    curr = c;\n-                    len = l;\n-                }\n-                resetProbe();\n-                pos++;\n-            }\n-            if (!isLast) {\n-                return; \/\/ it's too early to jump to any conclusions, let's wait\n-            }\n-            if (c.isLeaf()) {\n-                return; \/\/ it's perfectly ok, no extra padding bits\n-            }\n-            if (c.isEOSPath && len <= 7) {\n-                return; \/\/ it's ok, some extra padding bits\n-            }\n-            if (c.isEOSPath) {\n-                throw new IOException(\n-                        \"Padding is too long (len=\" + len + \") \" +\n-                                \"or unexpected end of data\");\n-            }\n-            throw new IOException(\n-                    \"Not a EOS prefix padding or unexpected end of data\");\n-        }\n-\n-        @Override\n-        public void reset() {\n-            curr = INSTANCE.root;\n-            len = 0;\n-            resetProbe();\n-        }\n-\n-        private void resetProbe() {\n-            p = 0x80;\n-        }\n-    }\n-\n-    static final class Writer implements Huffman.Writer {\n-\n-        private int pos;       \/\/ position in 'source'\n-        private int avail = 8; \/\/ number of least significant bits available in 'curr'\n-        private int curr;      \/\/ next byte to put to the destination\n-        private int rem;       \/\/ number of least significant bits in 'code' yet to be processed\n-        private int code;      \/\/ current code being written\n-\n-        private CharSequence source;\n-        private int end;\n-\n-        @Override\n-        public Writer from(CharSequence input, int start, int end) {\n-            if (start < 0 || end < 0 || end > input.length() || start > end) {\n-                throw new IndexOutOfBoundsException(\n-                        String.format(\"input.length()=%s, start=%s, end=%s\",\n-                                      input.length(), start, end));\n-            }\n-            pos = start;\n-            this.end = end;\n-            this.source = input;\n-            return this;\n-        }\n-\n-        @Override\n-        public boolean write(ByteBuffer destination) {\n-            for (; pos < end; pos++) {\n-                if (rem == 0) {\n-                    Code desc = INSTANCE.codeOf(source.charAt(pos));\n-                    rem = desc.length;\n-                    code = desc.code;\n-                }\n-                while (rem > 0) {\n-                    if (rem < avail) {\n-                        curr |= (code << (avail - rem));\n-                        avail -= rem;\n-                        rem = 0;\n-                    } else {\n-                        int c = (curr | (code >>> (rem - avail)));\n-                        if (destination.hasRemaining()) {\n-                            destination.put((byte) c);\n-                        } else {\n-                            return false;\n-                        }\n-                        curr = c;\n-                        code <<= (32 - rem + avail);  \/\/ throw written bits off the cliff (is this Sparta?)\n-                        code >>>= (32 - rem + avail); \/\/ return to the position\n-                        rem -= avail;\n-                        curr = 0;\n-                        avail = 8;\n-                    }\n-                }\n-            }\n-\n-            if (avail < 8) { \/\/ have to pad\n-                if (destination.hasRemaining()) {\n-                    destination.put((byte) (curr | (INSTANCE.EOS.code >>> (INSTANCE.EOS.length - avail))));\n-                    avail = 8;\n-                } else {\n-                    return false;\n-                }\n-            }\n-\n-            return true;\n-        }\n-\n-        @Override\n-        public Writer reset() {\n-            source = null;\n-            end = -1;\n-            pos = -1;\n-            avail = 8;\n-            curr = 0;\n-            code = 0;\n-            return this;\n-        }\n-\n-        @Override\n-        public int lengthOf(CharSequence value, int start, int end) {\n-            return INSTANCE.lengthOf(value, start, end);\n-        }\n-    }\n-\n-    \/**\n-     * Shared instance.\n-     *\/\n-    public static final NaiveHuffman INSTANCE = new NaiveHuffman();\n-\n-    private final Code EOS = new Code(0x3fffffff, 30);\n-    private final Code[] codes = new Code[257];\n-    private final Node root = new Node() {\n-        @Override\n-        public String toString() { return \"root\"; }\n-    };\n-\n-    \/\/ TODO: consider builder and immutable trie\n-    private NaiveHuffman() {\n-        \/\/ @formatter:off\n-        addChar(0,   0x1ff8,     13);\n-        addChar(1,   0x7fffd8,   23);\n-        addChar(2,   0xfffffe2,  28);\n-        addChar(3,   0xfffffe3,  28);\n-        addChar(4,   0xfffffe4,  28);\n-        addChar(5,   0xfffffe5,  28);\n-        addChar(6,   0xfffffe6,  28);\n-        addChar(7,   0xfffffe7,  28);\n-        addChar(8,   0xfffffe8,  28);\n-        addChar(9,   0xffffea,   24);\n-        addChar(10,  0x3ffffffc, 30);\n-        addChar(11,  0xfffffe9,  28);\n-        addChar(12,  0xfffffea,  28);\n-        addChar(13,  0x3ffffffd, 30);\n-        addChar(14,  0xfffffeb,  28);\n-        addChar(15,  0xfffffec,  28);\n-        addChar(16,  0xfffffed,  28);\n-        addChar(17,  0xfffffee,  28);\n-        addChar(18,  0xfffffef,  28);\n-        addChar(19,  0xffffff0,  28);\n-        addChar(20,  0xffffff1,  28);\n-        addChar(21,  0xffffff2,  28);\n-        addChar(22,  0x3ffffffe, 30);\n-        addChar(23,  0xffffff3,  28);\n-        addChar(24,  0xffffff4,  28);\n-        addChar(25,  0xffffff5,  28);\n-        addChar(26,  0xffffff6,  28);\n-        addChar(27,  0xffffff7,  28);\n-        addChar(28,  0xffffff8,  28);\n-        addChar(29,  0xffffff9,  28);\n-        addChar(30,  0xffffffa,  28);\n-        addChar(31,  0xffffffb,  28);\n-        addChar(32,  0x14,        6);\n-        addChar(33,  0x3f8,      10);\n-        addChar(34,  0x3f9,      10);\n-        addChar(35,  0xffa,      12);\n-        addChar(36,  0x1ff9,     13);\n-        addChar(37,  0x15,        6);\n-        addChar(38,  0xf8,        8);\n-        addChar(39,  0x7fa,      11);\n-        addChar(40,  0x3fa,      10);\n-        addChar(41,  0x3fb,      10);\n-        addChar(42,  0xf9,        8);\n-        addChar(43,  0x7fb,      11);\n-        addChar(44,  0xfa,        8);\n-        addChar(45,  0x16,        6);\n-        addChar(46,  0x17,        6);\n-        addChar(47,  0x18,        6);\n-        addChar(48,  0x0,         5);\n-        addChar(49,  0x1,         5);\n-        addChar(50,  0x2,         5);\n-        addChar(51,  0x19,        6);\n-        addChar(52,  0x1a,        6);\n-        addChar(53,  0x1b,        6);\n-        addChar(54,  0x1c,        6);\n-        addChar(55,  0x1d,        6);\n-        addChar(56,  0x1e,        6);\n-        addChar(57,  0x1f,        6);\n-        addChar(58,  0x5c,        7);\n-        addChar(59,  0xfb,        8);\n-        addChar(60,  0x7ffc,     15);\n-        addChar(61,  0x20,        6);\n-        addChar(62,  0xffb,      12);\n-        addChar(63,  0x3fc,      10);\n-        addChar(64,  0x1ffa,     13);\n-        addChar(65,  0x21,        6);\n-        addChar(66,  0x5d,        7);\n-        addChar(67,  0x5e,        7);\n-        addChar(68,  0x5f,        7);\n-        addChar(69,  0x60,        7);\n-        addChar(70,  0x61,        7);\n-        addChar(71,  0x62,        7);\n-        addChar(72,  0x63,        7);\n-        addChar(73,  0x64,        7);\n-        addChar(74,  0x65,        7);\n-        addChar(75,  0x66,        7);\n-        addChar(76,  0x67,        7);\n-        addChar(77,  0x68,        7);\n-        addChar(78,  0x69,        7);\n-        addChar(79,  0x6a,        7);\n-        addChar(80,  0x6b,        7);\n-        addChar(81,  0x6c,        7);\n-        addChar(82,  0x6d,        7);\n-        addChar(83,  0x6e,        7);\n-        addChar(84,  0x6f,        7);\n-        addChar(85,  0x70,        7);\n-        addChar(86,  0x71,        7);\n-        addChar(87,  0x72,        7);\n-        addChar(88,  0xfc,        8);\n-        addChar(89,  0x73,        7);\n-        addChar(90,  0xfd,        8);\n-        addChar(91,  0x1ffb,     13);\n-        addChar(92,  0x7fff0,    19);\n-        addChar(93,  0x1ffc,     13);\n-        addChar(94,  0x3ffc,     14);\n-        addChar(95,  0x22,        6);\n-        addChar(96,  0x7ffd,     15);\n-        addChar(97,  0x3,         5);\n-        addChar(98,  0x23,        6);\n-        addChar(99,  0x4,         5);\n-        addChar(100, 0x24,        6);\n-        addChar(101, 0x5,         5);\n-        addChar(102, 0x25,        6);\n-        addChar(103, 0x26,        6);\n-        addChar(104, 0x27,        6);\n-        addChar(105, 0x6,         5);\n-        addChar(106, 0x74,        7);\n-        addChar(107, 0x75,        7);\n-        addChar(108, 0x28,        6);\n-        addChar(109, 0x29,        6);\n-        addChar(110, 0x2a,        6);\n-        addChar(111, 0x7,         5);\n-        addChar(112, 0x2b,        6);\n-        addChar(113, 0x76,        7);\n-        addChar(114, 0x2c,        6);\n-        addChar(115, 0x8,         5);\n-        addChar(116, 0x9,         5);\n-        addChar(117, 0x2d,        6);\n-        addChar(118, 0x77,        7);\n-        addChar(119, 0x78,        7);\n-        addChar(120, 0x79,        7);\n-        addChar(121, 0x7a,        7);\n-        addChar(122, 0x7b,        7);\n-        addChar(123, 0x7ffe,     15);\n-        addChar(124, 0x7fc,      11);\n-        addChar(125, 0x3ffd,     14);\n-        addChar(126, 0x1ffd,     13);\n-        addChar(127, 0xffffffc,  28);\n-        addChar(128, 0xfffe6,    20);\n-        addChar(129, 0x3fffd2,   22);\n-        addChar(130, 0xfffe7,    20);\n-        addChar(131, 0xfffe8,    20);\n-        addChar(132, 0x3fffd3,   22);\n-        addChar(133, 0x3fffd4,   22);\n-        addChar(134, 0x3fffd5,   22);\n-        addChar(135, 0x7fffd9,   23);\n-        addChar(136, 0x3fffd6,   22);\n-        addChar(137, 0x7fffda,   23);\n-        addChar(138, 0x7fffdb,   23);\n-        addChar(139, 0x7fffdc,   23);\n-        addChar(140, 0x7fffdd,   23);\n-        addChar(141, 0x7fffde,   23);\n-        addChar(142, 0xffffeb,   24);\n-        addChar(143, 0x7fffdf,   23);\n-        addChar(144, 0xffffec,   24);\n-        addChar(145, 0xffffed,   24);\n-        addChar(146, 0x3fffd7,   22);\n-        addChar(147, 0x7fffe0,   23);\n-        addChar(148, 0xffffee,   24);\n-        addChar(149, 0x7fffe1,   23);\n-        addChar(150, 0x7fffe2,   23);\n-        addChar(151, 0x7fffe3,   23);\n-        addChar(152, 0x7fffe4,   23);\n-        addChar(153, 0x1fffdc,   21);\n-        addChar(154, 0x3fffd8,   22);\n-        addChar(155, 0x7fffe5,   23);\n-        addChar(156, 0x3fffd9,   22);\n-        addChar(157, 0x7fffe6,   23);\n-        addChar(158, 0x7fffe7,   23);\n-        addChar(159, 0xffffef,   24);\n-        addChar(160, 0x3fffda,   22);\n-        addChar(161, 0x1fffdd,   21);\n-        addChar(162, 0xfffe9,    20);\n-        addChar(163, 0x3fffdb,   22);\n-        addChar(164, 0x3fffdc,   22);\n-        addChar(165, 0x7fffe8,   23);\n-        addChar(166, 0x7fffe9,   23);\n-        addChar(167, 0x1fffde,   21);\n-        addChar(168, 0x7fffea,   23);\n-        addChar(169, 0x3fffdd,   22);\n-        addChar(170, 0x3fffde,   22);\n-        addChar(171, 0xfffff0,   24);\n-        addChar(172, 0x1fffdf,   21);\n-        addChar(173, 0x3fffdf,   22);\n-        addChar(174, 0x7fffeb,   23);\n-        addChar(175, 0x7fffec,   23);\n-        addChar(176, 0x1fffe0,   21);\n-        addChar(177, 0x1fffe1,   21);\n-        addChar(178, 0x3fffe0,   22);\n-        addChar(179, 0x1fffe2,   21);\n-        addChar(180, 0x7fffed,   23);\n-        addChar(181, 0x3fffe1,   22);\n-        addChar(182, 0x7fffee,   23);\n-        addChar(183, 0x7fffef,   23);\n-        addChar(184, 0xfffea,    20);\n-        addChar(185, 0x3fffe2,   22);\n-        addChar(186, 0x3fffe3,   22);\n-        addChar(187, 0x3fffe4,   22);\n-        addChar(188, 0x7ffff0,   23);\n-        addChar(189, 0x3fffe5,   22);\n-        addChar(190, 0x3fffe6,   22);\n-        addChar(191, 0x7ffff1,   23);\n-        addChar(192, 0x3ffffe0,  26);\n-        addChar(193, 0x3ffffe1,  26);\n-        addChar(194, 0xfffeb,    20);\n-        addChar(195, 0x7fff1,    19);\n-        addChar(196, 0x3fffe7,   22);\n-        addChar(197, 0x7ffff2,   23);\n-        addChar(198, 0x3fffe8,   22);\n-        addChar(199, 0x1ffffec,  25);\n-        addChar(200, 0x3ffffe2,  26);\n-        addChar(201, 0x3ffffe3,  26);\n-        addChar(202, 0x3ffffe4,  26);\n-        addChar(203, 0x7ffffde,  27);\n-        addChar(204, 0x7ffffdf,  27);\n-        addChar(205, 0x3ffffe5,  26);\n-        addChar(206, 0xfffff1,   24);\n-        addChar(207, 0x1ffffed,  25);\n-        addChar(208, 0x7fff2,    19);\n-        addChar(209, 0x1fffe3,   21);\n-        addChar(210, 0x3ffffe6,  26);\n-        addChar(211, 0x7ffffe0,  27);\n-        addChar(212, 0x7ffffe1,  27);\n-        addChar(213, 0x3ffffe7,  26);\n-        addChar(214, 0x7ffffe2,  27);\n-        addChar(215, 0xfffff2,   24);\n-        addChar(216, 0x1fffe4,   21);\n-        addChar(217, 0x1fffe5,   21);\n-        addChar(218, 0x3ffffe8,  26);\n-        addChar(219, 0x3ffffe9,  26);\n-        addChar(220, 0xffffffd,  28);\n-        addChar(221, 0x7ffffe3,  27);\n-        addChar(222, 0x7ffffe4,  27);\n-        addChar(223, 0x7ffffe5,  27);\n-        addChar(224, 0xfffec,    20);\n-        addChar(225, 0xfffff3,   24);\n-        addChar(226, 0xfffed,    20);\n-        addChar(227, 0x1fffe6,   21);\n-        addChar(228, 0x3fffe9,   22);\n-        addChar(229, 0x1fffe7,   21);\n-        addChar(230, 0x1fffe8,   21);\n-        addChar(231, 0x7ffff3,   23);\n-        addChar(232, 0x3fffea,   22);\n-        addChar(233, 0x3fffeb,   22);\n-        addChar(234, 0x1ffffee,  25);\n-        addChar(235, 0x1ffffef,  25);\n-        addChar(236, 0xfffff4,   24);\n-        addChar(237, 0xfffff5,   24);\n-        addChar(238, 0x3ffffea,  26);\n-        addChar(239, 0x7ffff4,   23);\n-        addChar(240, 0x3ffffeb,  26);\n-        addChar(241, 0x7ffffe6,  27);\n-        addChar(242, 0x3ffffec,  26);\n-        addChar(243, 0x3ffffed,  26);\n-        addChar(244, 0x7ffffe7,  27);\n-        addChar(245, 0x7ffffe8,  27);\n-        addChar(246, 0x7ffffe9,  27);\n-        addChar(247, 0x7ffffea,  27);\n-        addChar(248, 0x7ffffeb,  27);\n-        addChar(249, 0xffffffe,  28);\n-        addChar(250, 0x7ffffec,  27);\n-        addChar(251, 0x7ffffed,  27);\n-        addChar(252, 0x7ffffee,  27);\n-        addChar(253, 0x7ffffef,  27);\n-        addChar(254, 0x7fffff0,  27);\n-        addChar(255, 0x3ffffee,  26);\n-        addEOS (256, EOS.code,   EOS.length);\n-        \/\/ @formatter:on\n-    }\n-\n-\n-    \/**\n-     * Calculates the number of bytes required to represent the given {@code\n-     * CharSequence} with the Huffman coding.\n-     *\n-     * @param value\n-     *         characters\n-     *\n-     * @return number of bytes\n-     *\n-     * @throws NullPointerException\n-     *         if the value is null\n-     *\/\n-    public int lengthOf(CharSequence value) {\n-        return lengthOf(value, 0, value.length());\n-    }\n-\n-    \/**\n-     * Calculates the number of bytes required to represent a subsequence of the\n-     * given {@code CharSequence} with the Huffman coding.\n-     *\n-     * @param value\n-     *         characters\n-     * @param start\n-     *         the start index, inclusive\n-     * @param end\n-     *         the end index, exclusive\n-     *\n-     * @return number of bytes\n-     *\n-     * @throws NullPointerException\n-     *         if the value is null\n-     * @throws IndexOutOfBoundsException\n-     *         if any invocation of {@code value.charAt(i)}, where\n-     *         {@code start <= i < end} would throw an IndexOutOfBoundsException\n-     *\/\n-    public int lengthOf(CharSequence value, int start, int end) {\n-        int len = 0;\n-        for (int i = start; i < end; i++) {\n-            char c = value.charAt(i);\n-            len += INSTANCE.codeOf(c).length;\n-        }\n-        \/\/ Integer division with ceiling, assumption:\n-        assert (len \/ 8 + (len % 8 != 0 ? 1 : 0)) == (len + 7) \/ 8 : len;\n-        return (len + 7) \/ 8;\n-    }\n-\n-    private void addChar(int c, int code, int bitLength) {\n-        addLeaf(c, code, bitLength, false);\n-        codes[c] = new Code(code, bitLength);\n-    }\n-\n-    private void addEOS(int c, int code, int bitLength) {\n-        addLeaf(c, code, bitLength, true);\n-        codes[c] = new Code(code, bitLength);\n-    }\n-\n-    private void addLeaf(int c, int code, int bitLength, boolean isEOS) {\n-        if (bitLength < 1) {\n-            throw new IllegalArgumentException(\"bitLength < 1\");\n-        }\n-        Node curr = root;\n-        for (int p = 1 << bitLength - 1; p != 0 && !curr.isLeaf(); p = p >> 1) {\n-            curr.isEOSPath |= isEOS; \/\/ If it's already true, it can't become false\n-            curr = curr.addChildIfAbsent(p & code);\n-        }\n-        curr.isEOSPath |= isEOS; \/\/ The last one needs to have this property as well\n-        if (curr.isLeaf()) {\n-            throw new IllegalStateException(\"Specified code is already taken\");\n-        }\n-        curr.setChar((char) c);\n-    }\n-\n-    private Code codeOf(char c) {\n-        if (c > 255) {\n-            throw new IllegalArgumentException(\"char=\" + ((int) c));\n-        }\n-        return codes[c];\n-    }\n-\n-    \/\/\n-    \/\/ For debugging\/testing purposes\n-    \/\/\n-    Node getRoot() {\n-        return root;\n-    }\n-\n-    \/\/\n-    \/\/ Guarantees:\n-    \/\/\n-    \/\/  if (isLeaf() == true) => getChar() is a legal call\n-    \/\/  if (isLeaf() == false) => getChild(i) is a legal call (though it can\n-    \/\/                                                           return null)\n-    \/\/\n-    static class Node {\n-\n-        Node left;\n-        Node right;\n-        boolean isEOSPath;\n-\n-        boolean charIsSet;\n-        char c;\n-\n-        Node getChild(int selector) {\n-            if (isLeaf()) {\n-                throw new IllegalStateException(\"This is a leaf node\");\n-            }\n-            Node result = selector == 0 ? left : right;\n-            if (result == null) {\n-                throw new IllegalStateException(format(\n-                        \"Node doesn't have a child (selector=%s)\", selector));\n-            }\n-            return result;\n-        }\n-\n-        boolean isLeaf() {\n-            return charIsSet;\n-        }\n-\n-        char getChar() {\n-            if (!isLeaf()) {\n-                throw new IllegalStateException(\"This node is not a leaf node\");\n-            }\n-            return c;\n-        }\n-\n-        void setChar(char c) {\n-            if (charIsSet) {\n-                throw new IllegalStateException(\n-                        \"This node has been taken already\");\n-            }\n-            if (left != null || right != null) {\n-                throw new IllegalStateException(\"The node cannot be made \"\n-                                                        + \"a leaf as it's already has a child\");\n-            }\n-            this.c = c;\n-            charIsSet = true;\n-        }\n-\n-        Node addChildIfAbsent(int i) {\n-            if (charIsSet) {\n-                throw new IllegalStateException(\"The node cannot have a child \"\n-                                                        + \"as it's already a leaf node\");\n-            }\n-            Node child;\n-            if (i == 0) {\n-                if ((child = left) == null) {\n-                    child = left = new Node();\n-                }\n-            } else {\n-                if ((child = right) == null) {\n-                    child = right = new Node();\n-                }\n-            }\n-            return child;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            if (isLeaf()) {\n-                if (isEOSPath) {\n-                    return \"EOS\";\n-                } else {\n-                    return format(\"char: (%3s) '%s'\", (int) c, c);\n-                }\n-            }\n-            return \"\/\\\\\";\n-        }\n-    }\n-\n-    \/\/ TODO: value-based class?\n-    \/\/ FIXME: can we re-use Node instead of this class?\n-    private static final class Code {\n-\n-        final int code;\n-        final int length;\n-\n-        private Code(int code, int length) {\n-            this.code = code;\n-            this.length = length;\n-        }\n-\n-        public int getCode() {\n-            return code;\n-        }\n-\n-        public int getLength() {\n-            return length;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            long p = 1 << length;\n-            return Long.toBinaryString(code + p).substring(1)\n-                    + \", length=\" + length;\n-        }\n-    }\n-}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/hpack\/NaiveHuffman.java","additions":0,"deletions":691,"binary":false,"changes":691,"status":"deleted"},{"patch":"@@ -85,1 +85,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.prefs\/macosx\/classes\/java\/util\/prefs\/MacOSXPreferencesFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.prefs\/unix\/classes\/java\/util\/prefs\/FileSystemPreferences.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.prefs\/windows\/classes\/java\/util\/prefs\/WindowsPreferences.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/GC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/wrapper\/SunNativeProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -527,1 +527,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/Credentials.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/SCDynamicStoreConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-     * @param cbh The non-null CallbackHanlder object for callbacks\n+     * @param cbh The non-null CallbackHandler object for callbacks\n","filename":"src\/java.security.sasl\/share\/classes\/com\/sun\/security\/sasl\/digest\/DigestMD5Client.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.smartcardio\/unix\/classes\/sun\/security\/smartcardio\/PlatformPCSC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.smartcardio\/windows\/classes\/sun\/security\/smartcardio\/PlatformPCSC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.accessibility\/windows\/classes\/com\/sun\/java\/accessibility\/internal\/AccessBridge.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1529,2 +1529,2 @@\n-        ::_snprintf(text, sizeof(text), \"%d of %d\", (int)messageNumber,\n-                                                    (int) messageCount);\n+        ::snprintf(text, sizeof(text), \"%d of %d\", (int)messageNumber,\n+                                                   (int) messageCount);\n","filename":"src\/jdk.accessibility\/windows\/native\/jaccessinspector\/jaccessinspector.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/aix\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/macosx\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/AttachProviderImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,2 @@\n- * @jls 8.9 Enum Types\n- * @jls 8.10 Record Types\n+ * @jls 8.9 Enum Classes\n+ * @jls 8.10 Record Classes\n@@ -49,1 +49,1 @@\n- * @jls 9.6 Annotation Types\n+ * @jls 9.6 Annotation Interfaces\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ClassTree.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @jls 15.20.2 Type Comparison Operator instanceof\n+ * @jls 15.20.2 The instanceof Operator\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/InstanceOfTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @jls 15.28 Constant Expressions\n+ * @jls 15.29 Constant Expressions\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/LiteralTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- * @jls 9.6.1 Annotation Type Elements\n+ * @jls 9.6.1 Annotation Interface Elements\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/MethodTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+ * @jls 8.1.3 Inner Classes and Enclosing Instances\n@@ -45,1 +46,0 @@\n- * @jls 8.5.1 Static Member Type Declarations\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ModifiersTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @jls 14 Blocks and Statements\n+ * @jls 14 Blocks, Statements, and Patterns\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/StatementTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @jls 15.29 Switch Expressions\n+ * @jls 15.28 {@code switch} Expressions\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/SwitchExpressionTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @jls 14.4 Local Variable Declaration Statements\n+ * @jls 14.4 Local Variable Declarations\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/VariableTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2341,1 +2341,1 @@\n-        private ErrorType(Type originalType, TypeSymbol tsym,\n+        public ErrorType(Type originalType, TypeSymbol tsym,\n@@ -2396,4 +2396,0 @@\n-        public List<Type> allparams()            { return List.nil(); }\n-        @DefinedBy(Api.LANGUAGE_MODEL)\n-        public List<Type> getTypeArguments()     { return List.nil(); }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5084,0 +5084,8 @@\n+        } else if (clazztype.hasTag(ERROR)) {\n+            ErrorType parameterizedErroneous =\n+                    new ErrorType(clazztype.getOriginalType(),\n+                                  clazztype.tsym,\n+                                  clazztype.getMetadata());\n+\n+            parameterizedErroneous.typarams_field = actuals;\n+            owntype = parameterizedErroneous;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -830,1 +830,1 @@\n-            boolean genericPatternsExpanded = false;\n+            boolean useHashes = true;\n@@ -836,1 +836,1 @@\n-                    updatedPatterns = reduceNestedPatterns(updatedPatterns);\n+                    updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes);\n@@ -843,1 +843,1 @@\n-                    if (!repeat && !genericPatternsExpanded) {\n+                    if (!repeat) {\n@@ -845,1 +845,1 @@\n-                        \/\/class B extends S1, S2\n+                        \/\/class B permits S1, S2\n@@ -847,1 +847,1 @@\n-                        \/\/this should be joined to R(B, S2),\n+                        \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n@@ -849,5 +849,8 @@\n-                        \/\/attempt to once expand all types to their transitive permitted types,\n-                        \/\/on all depth of nesting:\n-                        updatedPatterns = expandGenericPatterns(updatedPatterns);\n-                        genericPatternsExpanded = true;\n-                        repeat = !updatedPatterns.equals(patterns);\n+                        \/\/disable the use of hashing, and use subtyping in\n+                        \/\/reduceNestedPatterns to handle situations like this:\n+                        repeat = useHashes;\n+                        useHashes = false;\n+                    } else {\n+                        \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n+                        \/\/is enabled, as the hashing speeds up the process significantly:\n+                        useHashes = true;\n@@ -1026,0 +1029,6 @@\n+         *\n+         * useHashes: when true, patterns will be subject to exact equivalence;\n+         *            when false, two binding patterns will be considered equivalent\n+         *            if one of them is more generic than the other one;\n+         *            when false, the processing will be significantly slower,\n+         *            as pattern hashes cannot be used to speed up the matching process\n@@ -1027,1 +1036,2 @@\n-        private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns) {\n+        private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns,\n+                                                             boolean useHashes) {\n@@ -1052,1 +1062,1 @@\n-                    var groupByHashes =\n+                    var groupEquivalenceCandidates =\n@@ -1057,2 +1067,2 @@\n-                             .collect(groupingBy(pd -> pd.hashCode(mismatchingCandidateFin)));\n-                    for (var candidates : groupByHashes.values()) {\n+                             .collect(groupingBy(pd -> useHashes ? pd.hashCode(mismatchingCandidateFin) : 0));\n+                    for (var candidates : groupEquivalenceCandidates.values()) {\n@@ -1079,3 +1089,12 @@\n-                                        if (i != mismatchingCandidate &&\n-                                            !rpOne.nested[i].equals(rpOther.nested[i])) {\n-                                            continue NEXT_PATTERN;\n+                                        if (i != mismatchingCandidate) {\n+                                            if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n+                                                if (useHashes ||\n+                                                    \/\/when not using hashes,\n+                                                    \/\/check if rpOne.nested[i] is\n+                                                    \/\/a subtype of rpOther.nested[i]:\n+                                                    !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n+                                                    !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n+                                                    !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n+                                                    continue NEXT_PATTERN;\n+                                                }\n+                                            }\n@@ -1089,1 +1108,1 @@\n-                            var updatedPatterns = reduceNestedPatterns(nestedPatterns);\n+                            var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes);\n@@ -1096,1 +1115,3 @@\n-                                current.removeAll(join);\n+                                if (useHashes) {\n+                                    current.removeAll(join);\n+                                }\n@@ -1172,34 +1193,0 @@\n-        private Set<PatternDescription> expandGenericPatterns(Set<PatternDescription> patterns) {\n-            var newPatterns = new HashSet<PatternDescription>(patterns);\n-            boolean modified;\n-            do {\n-                modified = false;\n-                for (PatternDescription pd : patterns) {\n-                    if (pd instanceof RecordPattern rpOne) {\n-                        for (int i = 0; i < rpOne.nested.length; i++) {\n-                            Set<PatternDescription> toExpand = Set.of(rpOne.nested[i]);\n-                            Set<PatternDescription> expanded = expandGenericPatterns(toExpand);\n-                            if (expanded != toExpand) {\n-                                expanded.removeAll(toExpand);\n-                                for (PatternDescription exp : expanded) {\n-                                    PatternDescription[] newNested = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                                    newNested[i] = exp;\n-                                    modified |= newPatterns.add(new RecordPattern(rpOne.recordType(), rpOne.fullComponentTypes(), newNested));\n-                                }\n-                            }\n-                        }\n-                    } else if (pd instanceof BindingPattern bp) {\n-                        Set<Symbol> permittedSymbols = allPermittedSubTypes(bp.type.tsym, cs -> true);\n-\n-                        if (!permittedSymbols.isEmpty()) {\n-                            for (Symbol permitted : permittedSymbols) {\n-                                \/\/TODO infer.instantiatePatternType(selectorType, csym); (?)\n-                                modified |= newPatterns.add(new BindingPattern(permitted.type));\n-                            }\n-                        }\n-                    }\n-                }\n-            } while (modified);\n-            return newPatterns;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":40,"deletions":53,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -221,0 +221,6 @@\n+    \/**\n+     * A table to hold the access flags of the method parameters,\n+     * for all parameters including synthetic and mandated ones.\n+     *\/\n+    int[] allParameterAccessFlags;\n+\n@@ -1149,0 +1155,1 @@\n+                        allParameterAccessFlags = new int[numEntries];\n@@ -1151,0 +1158,1 @@\n+                        int allParamIndex = 0;\n@@ -1155,0 +1163,1 @@\n+                            allParameterAccessFlags[allParamIndex++] = flags;\n@@ -1596,1 +1605,10 @@\n-            throw badClassFile(\"bad.runtime.invisible.param.annotations\", meth);\n+            \/\/the RuntimeVisibleParameterAnnotations and RuntimeInvisibleParameterAnnotations\n+            \/\/provide annotations for a different number of parameters, ignore:\n+            if (lintClassfile) {\n+                log.warning(LintCategory.CLASSFILE, Warnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n+            }\n+            for (int pnum = 0; pnum < numParameters; pnum++) {\n+                readAnnotations();\n+            }\n+            parameterAnnotations = null;\n+            return ;\n@@ -2626,1 +2644,2 @@\n-        Type type = poolReader.getType(nextChar());\n+        Type descriptorType = poolReader.getType(nextChar());\n+        Type type = descriptorType;\n@@ -2643,0 +2662,1 @@\n+        boolean forceLocal = false;\n@@ -2650,1 +2670,2 @@\n-            boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);\n+            boolean local = forceLocal =\n+                    !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);\n@@ -2671,0 +2692,1 @@\n+        adjustParameterAnnotations(m, descriptorType, forceLocal);\n@@ -2798,3 +2820,2 @@\n-        if (parameterAnnotations != null && parameterAnnotations.length != annotationIndex) {\n-            throw badClassFile(\"bad.runtime.invisible.param.annotations\", sym);\n-        }\n+        Assert.check(parameterAnnotations == null ||\n+                     parameterAnnotations.length == annotationIndex);\n@@ -2806,0 +2827,1 @@\n+        allParameterAccessFlags = null;\n@@ -2809,0 +2831,124 @@\n+    void adjustParameterAnnotations(MethodSymbol sym, Type methodDescriptor,\n+                                    boolean forceLocal) {\n+        if (parameterAnnotations == null) {\n+            return ;\n+        }\n+\n+        \/\/the specification for Runtime(In)VisibleParameterAnnotations does not\n+        \/\/enforce any mapping between the method parameters and the recorded\n+        \/\/parameter annotation. Attempt a number of heuristics to adjust the\n+        \/\/adjust parameterAnnotations to the percieved number of parameters:\n+\n+        int methodParameterCount = sym.type.getParameterTypes().size();\n+\n+        if (methodParameterCount == parameterAnnotations.length) {\n+            \/\/we've got exactly as many parameter annotations as are parameters\n+            \/\/of the method (after considering a possible Signature attribute),\n+            \/\/no need to do anything. the parameter creation code will use\n+            \/\/the 1-1 mapping to restore the annotations:\n+            return ;\n+        }\n+\n+        if (allParameterAccessFlags != null) {\n+            \/\/MethodParameters attribute present, use it:\n+\n+            \/\/count the number of non-synthetic and non-mandatory parameters:\n+            int realParameters = 0;\n+\n+            for (int i = 0; i < allParameterAccessFlags.length; i++) {\n+                if ((allParameterAccessFlags[i] & (SYNTHETIC | MANDATED)) == 0) {\n+                    realParameters++;\n+                }\n+            }\n+\n+            int methodDescriptorParameterCount = methodDescriptor.getParameterTypes().size();\n+\n+            if (realParameters == parameterAnnotations.length &&\n+                allParameterAccessFlags.length == methodDescriptorParameterCount) {\n+                \/\/if we have parameter annotations for each non-synthetic\/mandatory parameter,\n+                \/\/and if Signature was not present, expand the parameterAnnotations to cover\n+                \/\/all the method descriptor's parameters:\n+                if (sym.type == methodDescriptor) {\n+                    ParameterAnnotations[] newParameterAnnotations =\n+                            new ParameterAnnotations[methodParameterCount];\n+                    int srcIndex = 0;\n+\n+                    for (int i = 0; i < methodParameterCount; i++) {\n+                        if ((allParameterAccessFlags[i] & (SYNTHETIC | MANDATED)) == 0) {\n+                            newParameterAnnotations[i] = parameterAnnotations[srcIndex++];\n+                        }\n+                    }\n+\n+                    parameterAnnotations = newParameterAnnotations;\n+                } else {\n+                    dropParameterAnnotations();\n+                }\n+            } else if (realParameters == methodParameterCount &&\n+                       methodDescriptorParameterCount == parameterAnnotations.length &&\n+                       allParameterAccessFlags.length == methodDescriptorParameterCount) {\n+                \/\/if there are as many parameter annotations as parameters in\n+                \/\/the method descriptor, and as many real parameters as parameters\n+                \/\/in the method's type (after accounting for Signature), shrink\n+                \/\/the parameterAnnotations to only cover the parameters from\n+                \/\/the method's type:\n+                ParameterAnnotations[] newParameterAnnotations =\n+                        new ParameterAnnotations[methodParameterCount];\n+                int targetIndex = 0;\n+\n+                for (int i = 0; i < parameterAnnotations.length; i++) {\n+                    if ((allParameterAccessFlags[i] & (SYNTHETIC | MANDATED)) == 0) {\n+                        newParameterAnnotations[targetIndex++] = parameterAnnotations[i];\n+                    }\n+                }\n+\n+                parameterAnnotations = newParameterAnnotations;\n+            } else {\n+                dropParameterAnnotations();\n+            }\n+            return ;\n+        }\n+\n+        if (!sym.isConstructor()) {\n+            \/\/if the number of parameter annotations and the number of parameters\n+            \/\/don't match, we don't have any heuristics to map one to the other\n+            \/\/unless the method is a constructor:\n+            dropParameterAnnotations();\n+            return ;\n+        }\n+\n+        if (sym.owner.isEnum()) {\n+            if (methodParameterCount == parameterAnnotations.length + 2 &&\n+                sym.type == methodDescriptor) {\n+                \/\/handle constructors of enum types without the Signature attribute -\n+                \/\/there are the two synthetic parameters (name and ordinal) in the\n+                \/\/constructor, but there may be only parameter annotations for the\n+                \/\/real non-synthetic parameters:\n+                ParameterAnnotations[] newParameterAnnotations = new ParameterAnnotations[parameterAnnotations.length + 2];\n+                System.arraycopy(parameterAnnotations, 0, newParameterAnnotations, 2, parameterAnnotations.length);\n+                parameterAnnotations = newParameterAnnotations;\n+                return ;\n+            }\n+        } else if (sym.owner.isDirectlyOrIndirectlyLocal() || forceLocal) {\n+            \/\/local class may capture the enclosing instance (as the first parameter),\n+            \/\/and local variables (as trailing parameters)\n+            \/\/if there are less parameter annotations than parameters, put the existing\n+            \/\/ones starting with offset:\n+            if (methodParameterCount > parameterAnnotations.length &&\n+                sym.type == methodDescriptor) {\n+                ParameterAnnotations[] newParameterAnnotations = new ParameterAnnotations[methodParameterCount];\n+                System.arraycopy(parameterAnnotations, 0, newParameterAnnotations, 1, parameterAnnotations.length);\n+                parameterAnnotations = newParameterAnnotations;\n+                return ;\n+            }\n+        }\n+\n+        \/\/no heuristics worked, drop the annotations:\n+        dropParameterAnnotations();\n+    }\n+\n+    private void dropParameterAnnotations() {\n+        parameterAnnotations = null;\n+        if (lintClassfile) {\n+            log.warning(LintCategory.CLASSFILE, Warnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":152,"deletions":6,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import com.sun.tools.javac.parser.VirtualParser.VirtualScanner;\n@@ -459,0 +460,4 @@\n+        return syntaxError(pos, errs, errorKey, false);\n+    }\n+\n+    private JCErroneous syntaxError(int pos, List<? extends JCTree> errs, Error errorKey, boolean noEofError) {\n@@ -461,1 +466,1 @@\n-        reportSyntaxError(err, errorKey);\n+        reportSyntaxError(err, errorKey, noEofError);\n@@ -488,0 +493,4 @@\n+        reportSyntaxError(diagPos, errorKey, false);\n+    }\n+\n+    private void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey, boolean noEofError) {\n@@ -490,1 +499,1 @@\n-            if (token.kind == EOF) {\n+            if (token.kind == EOF && !noEofError) {\n@@ -4095,0 +4104,7 @@\n+                } else if (isDefiniteStatementStartToken()) {\n+                    int startPos = token.pos;\n+                    List<JCStatement> statements = blockStatement();\n+                    defs.append(syntaxError(startPos,\n+                                            statements,\n+                                            Errors.StatementNotExpected,\n+                                            true));\n@@ -4327,0 +4343,3 @@\n+            } else if (Feature.IMPLICIT_CLASSES.allowedInSource(source) &&\n+                       (!preview.isPreview(Feature.IMPLICIT_CLASSES) || preview.isEnabled())) {\n+                error = Errors.ClassMethodOrFieldExpected;\n@@ -4909,0 +4928,6 @@\n+        } else if (token.kind == LPAREN && type.hasTag(IDENT)) {\n+            log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n+\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    false, true, false, dc));\n@@ -5022,0 +5047,1 @@\n+            boolean unclosedParameterList;\n@@ -5024,0 +5050,1 @@\n+                unclosedParameterList = token.pos == endPosTable.errorEndPos;\n@@ -5029,0 +5056,2 @@\n+            } else {\n+                unclosedParameterList = false;\n@@ -5042,0 +5071,1 @@\n+                    accept(SEMI);\n@@ -5044,0 +5074,1 @@\n+                    accept(SEMI, tk -> Errors.Expected2(LBRACE, SEMI));\n@@ -5045,1 +5076,0 @@\n-                accept(SEMI);\n@@ -5048,2 +5078,5 @@\n-                    skip(false, true, false, false);\n-                    if (token.kind == LBRACE) {\n+                    \/\/ look if there is a probable missing opening brace,\n+                    \/\/ and if yes, parse as a block\n+                    boolean parseAsBlock = openingBraceMissing(unclosedParameterList);\n+\n+                    if (parseAsBlock) {\n@@ -5066,0 +5099,78 @@\n+    \/**\n+     * After seeing a method header, and not seeing an opening left brace,\n+     * attempt to estimate if acting as if the left brace was present and\n+     * parsing the upcoming code will get better results than not parsing\n+     * the code as a block.\n+     *\n+     * The estimate is as follows:\n+     * - tokens are skipped until member, statement or identifier is found,\n+     * - then, if there is a left brace, parse as a block,\n+     * - otherwise, if the head was broken, do not parse as a block,\n+     * - otherwise, look at the next token and:\n+     *   - if it definitelly starts a statement, parse as a block,\n+     *   - otherwise, if it is a closing\/right brace, count opening and closing\n+     *     braces in the rest of the file, to see if imaginarily \"adding\" an opening\n+     *     brace would lead to a balanced count - if yes, parse as a block,\n+     *   - otherwise, speculatively parse the following code as a block, and if\n+     *     it contains statements that cannot be members, parse as a block,\n+     *   - otherwise, don't parse as a block.\n+     *\n+     * @param unclosedParameterList whether there was a serious problem in the\n+     *                              parameters list\n+     * @return true if and only if the following code should be parsed as a block.\n+     *\/\n+    private boolean openingBraceMissing(boolean unclosedParameterList) {\n+        skip(false, true, !unclosedParameterList, !unclosedParameterList);\n+\n+        if (token.kind == LBRACE) {\n+            return true;\n+        } else if (unclosedParameterList) {\n+            return false;\n+        } else {\n+            return switch (token.kind) {\n+                \/\/definitelly sees a statement:\n+                case CASE, DEFAULT, IF, FOR, WHILE, DO, TRY, SWITCH,\n+                    RETURN, THROW, BREAK, CONTINUE, ELSE, FINALLY,\n+                    CATCH, THIS, SUPER, NEW -> true;\n+                case RBRACE -> {\n+                    \/\/check if adding an opening brace would balance out\n+                    \/\/the opening and closing braces:\n+                    int braceBalance = 1;\n+                    VirtualScanner virtualScanner = new VirtualScanner(S);\n+\n+                    virtualScanner.nextToken();\n+\n+                    while (virtualScanner.token().kind != TokenKind.EOF) {\n+                        switch (virtualScanner.token().kind) {\n+                            case LBRACE -> braceBalance++;\n+                            case RBRACE -> braceBalance--;\n+                        }\n+                        virtualScanner.nextToken();\n+                    }\n+\n+                    yield braceBalance == 0;\n+                }\n+                default -> {\n+                    \/\/speculatively try to parse as a block, and check\n+                    \/\/if the result would suggest there is a block\n+                    \/\/e.g.: it contains a statement that is not\n+                    \/\/a member declaration\n+                    JavacParser speculative = new VirtualParser(this);\n+                    JCBlock speculativeResult =\n+                            speculative.block();\n+                    if (!speculativeResult.stats.isEmpty()) {\n+                        JCStatement last = speculativeResult.stats.last();\n+                        yield !speculativeResult.stats.stream().allMatch(s -> s.hasTag(VARDEF) ||\n+                                s.hasTag(CLASSDEF) ||\n+                                s.hasTag(BLOCK) ||\n+                                s == last) ||\n+                            !(last instanceof JCExpressionStatement exprStatement &&\n+                            exprStatement.expr.hasTag(ERRONEOUS));\n+                    } else {\n+                        yield false;\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":116,"deletions":5,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -1622,0 +1622,3 @@\n+compiler.err.class.method.or.field.expected=\\\n+    class, interface, annotation type, enum, record, method or field expected\n+\n@@ -2547,2 +2550,11 @@\n-compiler.misc.bad.runtime.invisible.param.annotations=\\\n-    bad RuntimeInvisibleParameterAnnotations attribute: {0}\n+# 0: file name\n+compiler.warn.runtime.visible.invisible.param.annotations.mismatch=\\\n+    the length of parameters in RuntimeVisibleParameterAnnotations attribute and \\\n+    RuntimeInvisibleParameterAnnotations attribute in: {0} \\\n+    do not match, ignoring both attributes\n+\n+# 0: file name\n+compiler.warn.runtime.invisible.parameter.annotations=\\\n+    the RuntimeVisibleParameterAnnotations and RuntimeInvisibleParameterAnnotations attributes \\\n+    in: {0} \\\n+    cannot be mapped to the method''s parameters\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -465,12 +465,0 @@\n-class name java\/nio\/HeapByteBuffer\n-method name hashCode descriptor ()I flags 1\n-\n-class name java\/nio\/HeapByteBufferR\n-method name hashCode descriptor ()I flags 1\n-\n-class name java\/nio\/HeapCharBuffer\n-method name hashCode descriptor ()I flags 1\n-\n-class name java\/nio\/HeapCharBufferR\n-method name hashCode descriptor ()I flags 1\n-\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.base-N.sym.txt","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-        _snprintf(errorMessage, sizeof(errorMessage), \"Symbol not found: %s\", functionName);\n+        snprintf(errorMessage, sizeof(errorMessage), \"Symbol not found: %s\", functionName);\n","filename":"src\/jdk.crypto.cryptoki\/windows\/native\/libj2pkcs11\/j2secmod_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/SunMSCAPI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-<li>attaching to a remote \"debug server\"\n+<li>attaching to a remote \"debug server\" (deprecated)\n@@ -26,0 +26,1 @@\n+<p><strong>WARNING: <b>jhsdb debugd<\/b> is deprecated and will be removed in a future release.<\/strong><\/p>\n","filename":"src\/jdk.hotspot.agent\/doc\/index.html","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+    <p><strong>WARNING: <b>jhsdb debugd<\/b> is deprecated and will be removed in a future release.<\/strong><\/p>\n","filename":"src\/jdk.hotspot.agent\/doc\/transported_core.html","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -322,1 +322,1 @@\n-    THROW_NEW_DEBUGGER_EXCEPTION(\"Can't attach to the core file\");\n+    THROW_NEW_DEBUGGER_EXCEPTION(\"Can't attach to the core file. For more information, export LIBSAPROC_DEBUG=1 and try again.\");\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/LinuxDebuggerLocal.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1149,1 +1149,1 @@\n-    THROW_NEW_DEBUGGER_EXCEPTION(\"Can't attach to the core file\");\n+    THROW_NEW_DEBUGGER_EXCEPTION(\"Can't attach to the core file. For more information, export LIBSAPROC_DEBUG=1 and try again.\");\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/MacosxDebuggerLocal.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+@Deprecated(since=\"24\", forRemoval=true)\n@@ -45,0 +46,1 @@\n+    System.err.println(\"WARNING: DebugServer is deprecated and will be removed in a future release.\");\n@@ -48,0 +50,1 @@\n+  @SuppressWarnings(\"removal\")\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/DebugServer.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -207,0 +207,1 @@\n+    @Deprecated(since=\"24\", forRemoval=true)\n@@ -227,0 +228,1 @@\n+    @Deprecated(since=\"24\", forRemoval=true)\n@@ -234,0 +236,1 @@\n+    @Deprecated(since=\"24\", forRemoval=true)\n@@ -244,0 +247,1 @@\n+    @Deprecated(since=\"24\", forRemoval=true)\n@@ -269,0 +273,1 @@\n+    @Deprecated(since=\"24\", forRemoval=true)\n@@ -279,0 +284,1 @@\n+    @Deprecated(since=\"24\", forRemoval=true)\n@@ -286,0 +292,1 @@\n+    @Deprecated(since=\"24\", forRemoval=true)\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HotSpotAgent.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-        System.out.println(\"    debugd --help\\tto get more information\");\n+        System.out.println(\"    debugd --help\\tto get more information (deprecated)\");\n@@ -74,0 +74,3 @@\n+        if (canConnectToRemote) {\n+            System.out.println(\"    The --connect option is deprecated and will be removed in a future release.\");\n+        }\n@@ -79,1 +82,0 @@\n-            System.out.println(\"    The --connect option can be set to connect to a debug server (debugd).\");\n@@ -94,0 +96,1 @@\n+        System.out.println(\"WARNING: debugd is deprecated and will be removed in a future release.\");\n@@ -216,0 +219,1 @@\n+            System.err.println(\"WARNING: --connect is deprecated and will be removed in a future release.\");\n@@ -364,0 +368,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -365,0 +370,2 @@\n+        System.err.println(\"WARNING: debugd is deprecated and will be removed in a future release.\");\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/SALauncher.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -146,0 +146,2 @@\n+  public boolean isUpcallStub()         { return false; }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeBlob.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,1 @@\n+    virtualConstructor.addMapping(\"UpcallStub\", UpcallStub.class);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeCache.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.code;\n+\n+import java.util.*;\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.types.*;\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+public class UpcallStub extends RuntimeBlob {\n+\n+  private static CIntegerField frameDataOffsetField;\n+  private static AddressField lastJavaFPField;\n+  private static AddressField lastJavaSPField;\n+  private static AddressField lastJavaPCField;\n+\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+  }\n+\n+  private static void initialize(TypeDataBase db) {\n+    Type type = db.lookupType(\"UpcallStub\");\n+    frameDataOffsetField = type.getCIntegerField(\"_frame_data_offset\");\n+\n+    Type anchorType = db.lookupType(\"JavaFrameAnchor\");\n+    lastJavaSPField = anchorType.getAddressField(\"_last_Java_sp\");\n+    lastJavaPCField = anchorType.getAddressField(\"_last_Java_pc\");\n+\n+    try {\n+      lastJavaFPField = anchorType.getAddressField(\"_last_Java_fp\");\n+    } catch (Exception e) {\n+      \/\/ Some platforms (e.g. PPC64) does not have this field.\n+      lastJavaFPField = null;\n+    }\n+  }\n+\n+  public UpcallStub(Address addr) {\n+    super(addr);\n+  }\n+\n+  protected Address getJavaFrameAnchor(Frame frame) {\n+    var frameDataOffset = frameDataOffsetField.getValue(addr);\n+    var frameDataAddr = frame.getUnextendedSP().addOffsetTo(frameDataOffset);\n+    var frameData = VMObjectFactory.newObject(FrameData.class, frameDataAddr);\n+    return frameData.getJavaFrameAnchor();\n+  }\n+\n+  public Address getLastJavaSP(Frame frame) {\n+    return lastJavaSPField.getValue(getJavaFrameAnchor(frame));\n+  }\n+\n+  public Address getLastJavaFP(Frame frame) {\n+    return lastJavaFPField == null ? null : lastJavaFPField.getValue(getJavaFrameAnchor(frame));\n+  }\n+\n+  public Address getLastJavaPC(Frame frame) {\n+    return lastJavaPCField.getValue(getJavaFrameAnchor(frame));\n+  }\n+\n+  public boolean isUpcallStub() {\n+    return true;\n+  }\n+\n+  public static class FrameData extends VMObject {\n+\n+    private static AddressField jfaField;\n+\n+    static {\n+      VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+    }\n+\n+    private static void initialize(TypeDataBase db) {\n+      Type type = db.lookupType(\"UpcallStub::FrameData\");\n+      jfaField = type.getAddressField(\"jfa\");\n+    }\n+\n+    public FrameData(Address addr) {\n+      super(addr);\n+    }\n+\n+    public Address getJavaFrameAnchor() {\n+      return addr.addOffsetTo(jfaField.getOffset());\n+    }\n+\n+  }\n+\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/UpcallStub.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -65,0 +65,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdDebuggerLocal.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/LinuxDebuggerLocal.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgDebuggerLocal.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,4 +59,0 @@\n-  \/\/ Klass* flags\n-  public boolean hasFinalizer         () { return (flags & JVM_ACC_HAS_FINALIZER          ) != 0; }\n-  public boolean isCloneable          () { return (flags & JVM_ACC_IS_CLONEABLE           ) != 0; }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/AccessFlags.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,2 +233,0 @@\n-  public boolean hasFinalizer()             { return getAccessFlagsObj().hasFinalizer(); }\n-  public boolean isCloneable()              { return getAccessFlagsObj().isCloneable(); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Klass.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -159,0 +159,10 @@\n+    if (VM.getVM().getCommandLineFlag(\"UseObjectMonitorTable\").getBool()) {\n+      Iterator it = ObjectSynchronizer.objectMonitorIterator();\n+      while (it != null && it.hasNext()) {\n+        ObjectMonitor mon = (ObjectMonitor)it.next();\n+        if (getAddress().equals(mon.object())) {\n+          return mon;\n+        }\n+      }\n+      return null;\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    displacedHeaderField = type.getCIntegerField(\"_displaced_header\");\n+    displacedHeaderField = type.getCIntegerField(\"_metadata\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/BasicLock.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,6 +106,0 @@\n-    \/\/ Klass* flags\n-    \/\/ True if klass has a non-empty finalize() method\n-    public static final long JVM_ACC_HAS_FINALIZER            = 0x40000000;\n-    \/\/ True if klass supports the Clonable interface\n-    public static final long JVM_ACC_IS_CLONEABLE             = 0x80000000;\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ClassConstants.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-    sun.jvm.hotspot.types.Field f = type.getField(\"_header\");\n-    headerFieldOffset = f.getOffset();\n+    sun.jvm.hotspot.types.Field f = type.getField(\"_metadata\");\n+    metadataFieldOffset = f.getOffset();\n@@ -68,1 +68,1 @@\n-    return new Mark(addr.addOffsetTo(headerFieldOffset));\n+    return new Mark(addr.addOffsetTo(metadataFieldOffset));\n@@ -117,1 +117,1 @@\n-  private static long          headerFieldOffset;\n+  private static long          metadataFieldOffset;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectMonitor.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+      if (VM.getVM().getCommandLineFlag(\"UseObjectMonitorTable\").getBool()) {\n+        return mark.hash();\n+      }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectSynchronizer.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,1 +295,1 @@\n-      return senderForCompiledFrame(map, cb);\n+      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n@@ -330,0 +330,28 @@\n+  private Frame senderForUpcallStub(AARCH64RegisterMap map, UpcallStub stub) {\n+    if (DEBUG) {\n+      System.out.println(\"senderForUpcallStub\");\n+    }\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map != null, \"map must be set\");\n+    }\n+\n+    var lastJavaFP = stub.getLastJavaFP(this);\n+    var lastJavaSP = stub.getLastJavaSP(this);\n+    var lastJavaPC = stub.getLastJavaPC(this);\n+\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(lastJavaSP.greaterThan(getSP()), \"must be above this frame on stack\");\n+    }\n+    AARCH64Frame fr;\n+    if (lastJavaPC != null) {\n+      fr = new AARCH64Frame(lastJavaSP, lastJavaFP, lastJavaPC);\n+    } else {\n+      fr = new AARCH64Frame(lastJavaSP, lastJavaFP);\n+    }\n+    map.clear();\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map.getIncludeArgumentOops(), \"should be set by clear\");\n+    }\n+    return fr;\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/aarch64\/AARCH64Frame.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -282,1 +282,1 @@\n-      return senderForCompiledFrame(map, cb);\n+      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n@@ -317,0 +317,28 @@\n+  private Frame senderForUpcallStub(PPC64RegisterMap map, UpcallStub stub) {\n+    if (DEBUG) {\n+      System.out.println(\"senderForUpcallStub\");\n+    }\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map != null, \"map must be set\");\n+    }\n+\n+    var lastJavaFP = stub.getLastJavaFP(this); \/\/ This will be null\n+    var lastJavaSP = stub.getLastJavaSP(this);\n+    var lastJavaPC = stub.getLastJavaPC(this);\n+\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(lastJavaSP.greaterThan(getSP()), \"must be above this frame on stack\");\n+    }\n+    PPC64Frame fr;\n+    if (lastJavaPC != null) {\n+      fr = new PPC64Frame(lastJavaSP, lastJavaFP, lastJavaPC);\n+    } else {\n+      fr = new PPC64Frame(lastJavaSP, lastJavaFP);\n+    }\n+    map.clear();\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map.getIncludeArgumentOops(), \"should be set by clear\");\n+    }\n+    return fr;\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ppc64\/PPC64Frame.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -287,1 +287,1 @@\n-      return senderForCompiledFrame(map, cb);\n+      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n@@ -322,0 +322,28 @@\n+  private Frame senderForUpcallStub(RISCV64RegisterMap map, UpcallStub stub) {\n+    if (DEBUG) {\n+      System.out.println(\"senderForUpcallStub\");\n+    }\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map != null, \"map must be set\");\n+    }\n+\n+    var lastJavaFP = stub.getLastJavaFP(this);\n+    var lastJavaSP = stub.getLastJavaSP(this);\n+    var lastJavaPC = stub.getLastJavaPC(this);\n+\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(lastJavaSP.greaterThan(getSP()), \"must be above this frame on stack\");\n+    }\n+    RISCV64Frame fr;\n+    if (lastJavaPC != null) {\n+      fr = new RISCV64Frame(lastJavaSP, lastJavaFP, lastJavaPC);\n+    } else {\n+      fr = new RISCV64Frame(lastJavaSP, lastJavaFP);\n+    }\n+    map.clear();\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map.getIncludeArgumentOops(), \"should be set by clear\");\n+    }\n+    return fr;\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/riscv64\/RISCV64Frame.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -292,1 +292,1 @@\n-      return senderForCompiledFrame(map, cb);\n+      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n@@ -323,0 +323,28 @@\n+    }\n+    return fr;\n+  }\n+\n+  private Frame senderForUpcallStub(X86RegisterMap map, UpcallStub stub) {\n+    if (DEBUG) {\n+      System.out.println(\"senderForUpcallStub\");\n+    }\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map != null, \"map must be set\");\n+    }\n+\n+    var lastJavaFP = stub.getLastJavaFP(this);\n+    var lastJavaSP = stub.getLastJavaSP(this);\n+    var lastJavaPC = stub.getLastJavaPC(this);\n+\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(lastJavaSP.greaterThan(getSP()), \"must be above this frame on stack\");\n+    }\n+    X86Frame fr;\n+    if (lastJavaPC != null) {\n+      fr = new X86Frame(lastJavaSP, lastJavaFP, lastJavaPC);\n+    } else {\n+      fr = new X86Frame(lastJavaSP, lastJavaFP);\n+    }\n+    map.clear();\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(map.getIncludeArgumentOops(), \"should be set by clear\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/x86\/X86Frame.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,6 +36,0 @@\n-\/\/ Disable CRT security warning against _snprintf\n-#pragma warning (disable : 4996)\n-\n-#define snprintf  _snprintf\n-#define vsnprintf _vsnprintf\n-\n","filename":"src\/jdk.hotspot.agent\/share\/native\/libsaproc\/sadis.c","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -402,2 +402,5 @@\n-  ptrIDebugSymbols->SetImagePath(imagePath);\n-  ptrIDebugSymbols->SetSymbolPath(symbolPath);\n+  COM_VERIFY_OK_(ptrIDebugSymbols->SetImagePath(imagePath),\n+                 \"Windbg Error: SetImagePath failed!\", false);\n+  COM_VERIFY_OK_(ptrIDebugSymbols->SetSymbolPath(symbolPath),\n+                 \"Windbg Error: SetSymbolPath failed!\", false);\n+\n@@ -832,0 +835,2 @@\n+#define SYMBOL_BUFSIZE 512\n+\n@@ -855,0 +860,13 @@\n+\n+  \/\/ See JDK-8311993: WinDbg intermittently returns offset of \"module!class::`vftable'\" symbol\n+  \/\/ when requested for decorated \"class\" or \"class*\" (i.e. \"??_7class@@6B@\"\/\"??_7class*@@6B@\").\n+  \/\/ As a workaround check if returned symbol contains requested symbol.\n+  ULONG64 disp = 0L;\n+  char buf[SYMBOL_BUFSIZE];\n+  memset(buf, 0, sizeof(buf));\n+  if (ptrIDebugSymbols->GetNameByOffset(offset, buf, sizeof(buf), 0, &disp) == S_OK) {\n+    if (strstr(buf, name) == nullptr) {\n+      return (jlong)0;\n+    }\n+  }\n+\n@@ -858,1 +876,0 @@\n-#define SYMBOL_BUFSIZE 512\n","filename":"src\/jdk.hotspot.agent\/windows\/native\/libsaproc\/sawindbg.cpp","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -515,1 +515,1 @@\n-                     return (long)Double.doubleToLongBits(vecarr[ix]);\n+                     return (long)Double.doubleToRawLongBits(vecarr[ix]);\n@@ -532,1 +532,1 @@\n-                                this, i, (long)Double.doubleToLongBits(e),\n+                                this, i, (long)Double.doubleToRawLongBits(e),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -517,1 +517,1 @@\n-                     return (long)Double.doubleToLongBits(vecarr[ix]);\n+                     return (long)Double.doubleToRawLongBits(vecarr[ix]);\n@@ -536,1 +536,1 @@\n-                                this, i, (long)Double.doubleToLongBits(e),\n+                                this, i, (long)Double.doubleToRawLongBits(e),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -521,1 +521,1 @@\n-                     return (long)Double.doubleToLongBits(vecarr[ix]);\n+                     return (long)Double.doubleToRawLongBits(vecarr[ix]);\n@@ -544,1 +544,1 @@\n-                                this, i, (long)Double.doubleToLongBits(e),\n+                                this, i, (long)Double.doubleToRawLongBits(e),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -514,1 +514,1 @@\n-                     return (long)Double.doubleToLongBits(vecarr[ix]);\n+                     return (long)Double.doubleToRawLongBits(vecarr[ix]);\n@@ -530,1 +530,1 @@\n-                                this, i, (long)Double.doubleToLongBits(e),\n+                                this, i, (long)Double.doubleToRawLongBits(e),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -513,1 +513,1 @@\n-                     return (long)Double.doubleToLongBits(vecarr[ix]);\n+                     return (long)Double.doubleToRawLongBits(vecarr[ix]);\n@@ -529,1 +529,1 @@\n-                                this, i, (long)Double.doubleToLongBits(e),\n+                                this, i, (long)Double.doubleToRawLongBits(e),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -517,1 +517,1 @@\n-                     return (long)Float.floatToIntBits(vecarr[ix]);\n+                     return (long)Float.floatToRawIntBits(vecarr[ix]);\n@@ -536,1 +536,1 @@\n-                                this, i, (long)Float.floatToIntBits(e),\n+                                this, i, (long)Float.floatToRawIntBits(e),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -521,1 +521,1 @@\n-                     return (long)Float.floatToIntBits(vecarr[ix]);\n+                     return (long)Float.floatToRawIntBits(vecarr[ix]);\n@@ -544,1 +544,1 @@\n-                                this, i, (long)Float.floatToIntBits(e),\n+                                this, i, (long)Float.floatToRawIntBits(e),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -529,1 +529,1 @@\n-                     return (long)Float.floatToIntBits(vecarr[ix]);\n+                     return (long)Float.floatToRawIntBits(vecarr[ix]);\n@@ -560,1 +560,1 @@\n-                                this, i, (long)Float.floatToIntBits(e),\n+                                this, i, (long)Float.floatToRawIntBits(e),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -515,1 +515,1 @@\n-                     return (long)Float.floatToIntBits(vecarr[ix]);\n+                     return (long)Float.floatToRawIntBits(vecarr[ix]);\n@@ -532,1 +532,1 @@\n-                                this, i, (long)Float.floatToIntBits(e),\n+                                this, i, (long)Float.floatToRawIntBits(e),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -513,1 +513,1 @@\n-                     return (long)Float.floatToIntBits(vecarr[ix]);\n+                     return (long)Float.floatToRawIntBits(vecarr[ix]);\n@@ -529,1 +529,1 @@\n-                                this, i, (long)Float.floatToIntBits(e),\n+                                this, i, (long)Float.floatToRawIntBits(e),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -564,1 +564,1 @@\n-                     return (long)$Type$.$type$To$Bitstype$Bits(vecarr[ix]);\n+                     return (long)$Type$.$type$ToRaw$Bitstype$Bits(vecarr[ix]);\n@@ -610,1 +610,1 @@\n-                                this, i, (long)$Type$.$type$To$Bitstype$Bits(e),\n+                                this, i, (long)$Type$.$type$ToRaw$Bitstype$Bits(e),\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,0 +173,5 @@\n+    public int getMiscFlags() {\n+        HotSpotVMConfig config = config();\n+        return UNSAFE.getInt(getKlassPointer() + config.klassMiscFlagsOffset);\n+    }\n+\n@@ -376,1 +381,1 @@\n-        return (getAccessFlags() & config().jvmAccHasFinalizer) != 0;\n+        return (getMiscFlags() & config().jvmAccHasFinalizer) != 0;\n@@ -1113,1 +1118,1 @@\n-        return (getAccessFlags() & config().jvmAccIsCloneableFast) != 0;\n+        return (getMiscFlags() & config().jvmAccIsCloneableFast) != 0;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+    final int klassMiscFlagsOffset = getFieldOffset(\"Klass::_misc_flags._flags\", Integer.class, \"u1\");\n@@ -116,1 +117,1 @@\n-    final int jvmAccHasFinalizer = getConstant(\"JVM_ACC_HAS_FINALIZER\", Integer.class);\n+    final int jvmAccHasFinalizer = getConstant(\"KlassFlags::_misc_has_finalizer\", Integer.class);\n@@ -119,1 +120,1 @@\n-    final int jvmAccIsCloneableFast = getConstant(\"JVM_ACC_IS_CLONEABLE_FAST\", Integer.class);\n+    final int jvmAccIsCloneableFast = getConstant(\"KlassFlags::_misc_is_cloneable_fast\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -254,1 +254,1 @@\n-    public synchronized boolean run(String args[]) {\n+    public synchronized boolean run(String[] args) {\n@@ -369,5 +369,3 @@\n-                    InputStream in = new FileInputStream(FileDescriptor.in);\n-                    try {\n-                        list(new BufferedInputStream(in), files);\n-                    } finally {\n-                        in.close();\n+                    try (InputStream in = new FileInputStream(FileDescriptor.in);\n+                         BufferedInputStream bis = new BufferedInputStream(in)) {\n+                        list(bis, files);\n@@ -389,1 +387,1 @@\n-                if (fname != null && files != null) {\n+                if (fname != null) {\n@@ -392,9 +390,3 @@\n-                    InputStream in = (fname == null)\n-                        ? new FileInputStream(FileDescriptor.in)\n-                        : new FileInputStream(fname);\n-                    try {\n-                        if (!extract(new BufferedInputStream(in), files) && fname != null) {\n-                            extract(fname, files);\n-                        }\n-                    } finally {\n-                        in.close();\n+                    try (InputStream in = new FileInputStream(FileDescriptor.in);\n+                         BufferedInputStream bis = new BufferedInputStream(in)) {\n+                        extract(bis, files);\n@@ -506,1 +498,1 @@\n-    boolean parseArgs(String args[]) {\n+    boolean parseArgs(String[] args) {\n@@ -938,4 +930,0 @@\n-        ZipInputStream zis = new ZipInputStream(in);\n-        ZipOutputStream zos = new JarOutputStream(out);\n-        ZipEntry e = null;\n-        boolean foundManifest = false;\n@@ -943,0 +931,2 @@\n+        try (ZipInputStream zis = new ZipInputStream(in);\n+            ZipOutputStream zos = new JarOutputStream(out)) {\n@@ -944,11 +934,12 @@\n-        \/\/ All actual entries added\/updated\/existing, in the jar file (excl manifest\n-        \/\/ and module-info.class ).\n-        Set<String> jentries = new HashSet<>();\n-\n-        if (jarIndex != null) {\n-            addIndex(jarIndex, zos);\n-        }\n-\n-        \/\/ put the old entries first, replace if necessary\n-        while ((e = zis.getNextEntry()) != null) {\n-            String name = e.getName();\n+            if (jarIndex != null) {\n+                addIndex(jarIndex, zos);\n+            }\n+            ZipEntry e = null;\n+            boolean foundManifest = false;\n+            \/\/ All actual entries added\/updated\/existing, in the jar file (excl manifest\n+            \/\/ and module-info.class ).\n+            Set<String> jentries = new HashSet<>();\n+\n+            \/\/ put the old entries first, replace if necessary\n+            while ((e = zis.getNextEntry()) != null) {\n+                String name = e.getName();\n@@ -956,2 +947,2 @@\n-            boolean isManifestEntry = equalsIgnoreCase(name, MANIFEST_NAME);\n-            boolean isModuleInfoEntry = isModuleInfoEntry(name);\n+                boolean isManifestEntry = equalsIgnoreCase(name, MANIFEST_NAME);\n+                boolean isModuleInfoEntry = isModuleInfoEntry(name);\n@@ -959,4 +950,4 @@\n-            if ((jarIndex != null && equalsIgnoreCase(name, INDEX_NAME))\n-                || (Mflag && isManifestEntry)) {\n-                continue;\n-            } else if (isManifestEntry && ((newManifest != null) ||\n+                if ((jarIndex != null && equalsIgnoreCase(name, INDEX_NAME))\n+                        || (Mflag && isManifestEntry)) {\n+                    continue;\n+                } else if (isManifestEntry && ((newManifest != null) ||\n@@ -964,8 +955,9 @@\n-                foundManifest = true;\n-                if (newManifest != null) {\n-                    \/\/ Don't read from the newManifest InputStream, as we\n-                    \/\/ might need it below, and we can't re-read the same data\n-                    \/\/ twice.\n-                    try (FileInputStream fis = new FileInputStream(mname)) {\n-                        if (isAmbiguousMainClass(new Manifest(fis))) {\n-                            return false;\n+                    foundManifest = true;\n+                    if (newManifest != null) {\n+                        \/\/ Don't read from the newManifest InputStream, as we\n+                        \/\/ might need it below, and we can't re-read the same data\n+                        \/\/ twice.\n+                        try (FileInputStream fis = new FileInputStream(mname)) {\n+                            if (isAmbiguousMainClass(new Manifest(fis))) {\n+                                return false;\n+                            }\n@@ -974,23 +966,34 @@\n-                }\n-                \/\/ Update the manifest.\n-                Manifest old = new Manifest(zis);\n-                if (newManifest != null) {\n-                    old.read(newManifest);\n-                }\n-                if (!updateManifest(old, zos)) {\n-                    return false;\n-                }\n-            } else if (moduleInfos != null && isModuleInfoEntry) {\n-                moduleInfos.putIfAbsent(name, new StreamedModuleInfoEntry(name, zis.readAllBytes(), e.getLastModifiedTime()));\n-            } else {\n-                boolean isDir = e.isDirectory();\n-                if (!entryMap.containsKey(name)) { \/\/ copy the old stuff\n-                    \/\/ do our own compression\n-                    ZipEntry e2 = new ZipEntry(name);\n-                    e2.setMethod(e.getMethod());\n-                    setZipEntryTime(e2, e.getTime());\n-                    e2.setComment(e.getComment());\n-                    e2.setExtra(e.getExtra());\n-                    if (e.getMethod() == ZipEntry.STORED) {\n-                        e2.setSize(e.getSize());\n-                        e2.setCrc(e.getCrc());\n+                    \/\/ Update the manifest.\n+                    Manifest old = new Manifest(zis);\n+                    if (newManifest != null) {\n+                        old.read(newManifest);\n+                    }\n+                    if (!updateManifest(old, zos)) {\n+                        return false;\n+                    }\n+                } else if (moduleInfos != null && isModuleInfoEntry) {\n+                    moduleInfos.putIfAbsent(name, new StreamedModuleInfoEntry(name, zis.readAllBytes(), e.getLastModifiedTime()));\n+                } else {\n+                    boolean isDir = e.isDirectory();\n+                    if (!entryMap.containsKey(name)) { \/\/ copy the old stuff\n+                        \/\/ do our own compression\n+                        ZipEntry e2 = new ZipEntry(name);\n+                        e2.setMethod(e.getMethod());\n+                        setZipEntryTime(e2, e.getTime());\n+                        e2.setComment(e.getComment());\n+                        e2.setExtra(e.getExtra());\n+                        if (e.getMethod() == ZipEntry.STORED) {\n+                            e2.setSize(e.getSize());\n+                            e2.setCrc(e.getCrc());\n+                        }\n+                        zos.putNextEntry(e2);\n+                        copy(zis, zos);\n+                    } else { \/\/ replace with the new files\n+                        Entry ent = entryMap.get(name);\n+                        addFile(zos, ent);\n+                        entryMap.remove(name);\n+                        entries.remove(ent);\n+                        isDir = ent.isDir;\n+                    }\n+                    if (!isDir) {\n+                        jentries.add(name);\n@@ -998,11 +1001,0 @@\n-                    zos.putNextEntry(e2);\n-                    copy(zis, zos);\n-                } else { \/\/ replace with the new files\n-                    Entry ent = entryMap.get(name);\n-                    addFile(zos, ent);\n-                    entryMap.remove(name);\n-                    entries.remove(ent);\n-                    isDir = ent.isDir;\n-                }\n-                if (!isDir) {\n-                    jentries.add(name);\n@@ -1011,1 +1003,0 @@\n-        }\n@@ -1013,5 +1004,6 @@\n-        \/\/ add the remaining new files\n-        for (Entry entry : entries) {\n-            addFile(zos, entry);\n-            if (!entry.isDir) {\n-                jentries.add(entry.name);\n+            \/\/ add the remaining new files\n+            for (Entry entry : entries) {\n+                addFile(zos, entry);\n+                if (!entry.isDir) {\n+                    jentries.add(entry.name);\n+                }\n@@ -1019,7 +1011,11 @@\n-        }\n-        if (!foundManifest) {\n-            if (newManifest != null) {\n-                Manifest m = new Manifest(newManifest);\n-                updateOk = !isAmbiguousMainClass(m);\n-                if (updateOk) {\n-                    if (!updateManifest(m, zos)) {\n+            if (!foundManifest) {\n+                if (newManifest != null) {\n+                    Manifest m = new Manifest(newManifest);\n+                    updateOk = !isAmbiguousMainClass(m);\n+                    if (updateOk) {\n+                        if (!updateManifest(m, zos)) {\n+                            updateOk = false;\n+                        }\n+                    }\n+                } else if (ename != null) {\n+                    if (!updateManifest(new Manifest(), zos)) {\n@@ -1029,2 +1025,11 @@\n-            } else if (ename != null) {\n-                if (!updateManifest(new Manifest(), zos)) {\n+            }\n+            if (updateOk) {\n+                if (moduleInfos != null && !moduleInfos.isEmpty()) {\n+                    Set<String> pkgs = new HashSet<>();\n+                    jentries.forEach(je -> addPackageIfNamed(pkgs, je));\n+                    addExtendedModuleAttributes(moduleInfos, pkgs);\n+                    updateOk = checkModuleInfo(moduleInfos.get(MODULE_INFO), jentries);\n+                    updateModuleInfo(moduleInfos, zos);\n+                    \/\/ TODO: check manifest main classes, etc\n+                } else if (moduleVersion != null || modulesToHash != null) {\n+                    error(getMsg(\"error.module.options.without.info\"));\n@@ -1035,15 +1040,0 @@\n-        if (updateOk) {\n-            if (moduleInfos != null && !moduleInfos.isEmpty()) {\n-                Set<String> pkgs = new HashSet<>();\n-                jentries.forEach( je -> addPackageIfNamed(pkgs, je));\n-                addExtendedModuleAttributes(moduleInfos, pkgs);\n-                updateOk = checkModuleInfo(moduleInfos.get(MODULE_INFO), jentries);\n-                updateModuleInfo(moduleInfos, zos);\n-                \/\/ TODO: check manifest main classes, etc\n-            } else if (moduleVersion != null || modulesToHash != null) {\n-                error(getMsg(\"error.module.options.without.info\"));\n-                updateOk = false;\n-            }\n-        }\n-        zis.close();\n-        zos.close();\n@@ -1377,3 +1367,0 @@\n-     *\n-     * @return whether entries were found and successfully extracted\n-     * (indicating this was a zip file without \"leading garbage\")\n@@ -1381,1 +1368,1 @@\n-    boolean extract(InputStream in, String files[]) throws IOException {\n+    void extract(InputStream in, String[] files) throws IOException {\n@@ -1384,3 +1371,0 @@\n-        \/\/ Set of all directory entries specified in archive.  Disallows\n-        \/\/ null entries.  Disallows all entries if using pre-6.0 behavior.\n-        boolean entriesFound = false;\n@@ -1389,1 +1373,0 @@\n-            entriesFound = true;\n@@ -1408,2 +1391,0 @@\n-\n-        return entriesFound;\n@@ -1415,14 +1396,16 @@\n-    void extract(String fname, String files[]) throws IOException {\n-        ZipFile zf = new ZipFile(fname);\n-        Set<ZipEntry> dirs = newDirSet();\n-        Enumeration<? extends ZipEntry> zes = zf.entries();\n-        while (zes.hasMoreElements()) {\n-            ZipEntry e = zes.nextElement();\n-            if (files == null) {\n-                dirs.add(extractFile(zf.getInputStream(e), e));\n-            } else {\n-                String name = e.getName();\n-                for (String file : files) {\n-                    if (name.startsWith(file)) {\n-                        dirs.add(extractFile(zf.getInputStream(e), e));\n-                        break;\n+    void extract(String fname, String[] files) throws IOException {\n+        final Set<ZipEntry> dirs;\n+        try (ZipFile zf = new ZipFile(fname)) {\n+            dirs = newDirSet();\n+            Enumeration<? extends ZipEntry> zes = zf.entries();\n+            while (zes.hasMoreElements()) {\n+                ZipEntry e = zes.nextElement();\n+                if (files == null) {\n+                    dirs.add(extractFile(zf.getInputStream(e), e));\n+                } else {\n+                    String name = e.getName();\n+                    for (String file : files) {\n+                        if (name.startsWith(file)) {\n+                            dirs.add(extractFile(zf.getInputStream(e), e));\n+                            break;\n+                        }\n@@ -1433,1 +1416,0 @@\n-        zf.close();\n@@ -1508,1 +1490,1 @@\n-    void list(InputStream in, String files[]) throws IOException {\n+    void list(InputStream in, String[] files) throws IOException {\n@@ -1526,5 +1508,6 @@\n-    void list(String fname, String files[]) throws IOException {\n-        ZipFile zf = new ZipFile(fname);\n-        Enumeration<? extends ZipEntry> zes = zf.entries();\n-        while (zes.hasMoreElements()) {\n-            printEntry(zes.nextElement(), files);\n+    void list(String fname, String[] files) throws IOException {\n+        try (ZipFile zf = new ZipFile(fname)) {\n+            Enumeration<? extends ZipEntry> zes = zf.entries();\n+            while (zes.hasMoreElements()) {\n+                printEntry(zes.nextElement(), files);\n+            }\n@@ -1532,1 +1515,0 @@\n-        zf.close();\n@@ -1575,4 +1557,2 @@\n-        JarFile rf = new JarFile(jar.replace('\/', File.separatorChar));\n-\n-        if (rf != null) {\n-            Manifest man = rf.getManifest();\n+        try (JarFile jarFile = new JarFile(jar.replace('\/', File.separatorChar))) {\n+            Manifest man = jarFile.getManifest();\n@@ -1599,1 +1579,0 @@\n-        rf.close();\n@@ -1706,1 +1685,1 @@\n-    public static void main(String args[]) {\n+    public static void main(String[] args) {\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":128,"deletions":149,"binary":false,"changes":277,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-            content.add(new HtmlTree(HtmlTag.WBR));\n+            content.add(HtmlTree.WBR());\n@@ -147,1 +147,1 @@\n-            target.add(new HtmlTree(HtmlTag.BR));\n+            target.add(HtmlTree.BR());\n@@ -236,1 +236,1 @@\n-            target.add(new HtmlTree(HtmlTag.WBR));\n+            target.add(HtmlTree.WBR());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractExecutableMemberWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -454,1 +454,1 @@\n-        var code = new HtmlTree(HtmlTag.CODE);\n+        var code = HtmlTree.CODE();\n@@ -673,1 +673,1 @@\n-        return new HtmlTree(HtmlTag.CODE);\n+        return HtmlTree.CODE();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractMemberWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-            var ul = new HtmlTree(HtmlTag.UL);\n+            var ul = HtmlTree.UL();\n@@ -84,2 +84,1 @@\n-                var li = new HtmlTree(HtmlTag.LI);\n-                li.setStyle(HtmlStyles.circle);\n+                var li = HtmlTree.LI(HtmlStyles.circle);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractTreeWriter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -426,1 +426,1 @@\n-        headingContent.add(new HtmlTree(HtmlTag.BR));\n+        headingContent.add(HtmlTree.BR());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassUseWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-        c.add(new HtmlTree(HtmlTag.HR));\n+        c.add(HtmlTree.HR());\n@@ -464,1 +464,1 @@\n-                    content.add(\",\").add(new HtmlTree(HtmlTag.WBR));\n+                    content.add(\",\").add(HtmlTree.WBR());\n@@ -692,5 +692,3 @@\n-            var dl = HtmlTree.DL(HtmlStyles.notes);\n-            dl.add(HtmlTree.DT(contents.functionalInterface));\n-            var dd = new HtmlTree(HtmlTag.DD);\n-            dd.add(contents.functionalInterfaceMessage);\n-            dl.add(dd);\n+            var dl = HtmlTree.DL(HtmlStyles.notes)\n+                .add(HtmlTree.DT(contents.functionalInterface))\n+                .add(HtmlTree.DD(contents.functionalInterfaceMessage));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriter.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -417,1 +417,1 @@\n-        var code = new HtmlTree(HtmlTag.CODE)\n+        var code = HtmlTree.CODE()\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstantsSummaryWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-            var code = new HtmlTree(HtmlTag.CODE);\n+            var code = HtmlTree.CODE();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstructorWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-                .add(new HtmlTree(HtmlTag.HR))\n+                .add(HtmlTree.HR())\n@@ -110,1 +110,1 @@\n-                .add(new HtmlTree(HtmlTag.HR))\n+                .add(HtmlTree.HR())\n@@ -112,1 +112,1 @@\n-                .add(new HtmlTree(HtmlTag.HR))\n+                .add(HtmlTree.HR())\n@@ -258,1 +258,1 @@\n-                .add(new HtmlTree(HtmlTag.BR))\n+                .add(HtmlTree.BR())\n@@ -268,1 +268,1 @@\n-                .add(new HtmlTree(HtmlTag.BR))\n+                .add(HtmlTree.BR())\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HelpWriter.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -688,1 +688,1 @@\n-                    .add(new HtmlTree(HtmlTag.HR))\n+                    .add(HtmlTree.HR())\n@@ -2408,1 +2408,1 @@\n-        var body = new HtmlTree(HtmlTag.BODY).setStyle(getBodyStyle());\n+        var body = HtmlTree.BODY(getBodyStyle());\n@@ -2604,1 +2604,1 @@\n-                                   new HtmlTree(HtmlTag.EM).add(featureName),\n+                                   HtmlTree.EM(featureName),\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import jdk.javadoc.internal.html.HtmlId;\n@@ -299,1 +300,1 @@\n-                DocPath filename = getPath(linkInfo);\n+                DocPath fileName = getPath(linkInfo);\n@@ -302,17 +303,3 @@\n-                                filename.fragment(linkInfo.getFragment()),\n-                                label,\n-                                linkInfo.getStyle(),\n-                                title));\n-                        Content spacer = Text.EMPTY;\n-                        if (flags.contains(ElementFlag.PREVIEW)) {\n-                            link.add(HtmlTree.SUP(m_writer.links.createLink(\n-                                    filename.fragment(m_writer.htmlIds.forPreviewSection(previewTarget).name()),\n-                                    m_writer.contents.previewMark)));\n-                            spacer = Entity.NO_BREAK_SPACE;\n-                        }\n-                        if (flags.contains(ElementFlag.RESTRICTED)) {\n-                            link.add(spacer);\n-                            link.add(HtmlTree.SUP(m_writer.links.createLink(\n-                                    filename.fragment(m_writer.htmlIds.forRestrictedSection(restrictedTarget).name()),\n-                                    m_writer.contents.restrictedMark)));\n-                        }\n+                                fileName.fragment(linkInfo.getFragment()),\n+                                label, linkInfo.getStyle(), title));\n+                        addSuperscript(link, flags, fileName, null, previewTarget, restrictedTarget);\n@@ -328,17 +315,1 @@\n-                Content spacer = Text.EMPTY;\n-                if (flags.contains(ElementFlag.PREVIEW)) {\n-                    link.add(HtmlTree.SUP(m_writer.getCrossClassLink(\n-                        typeElement,\n-                        m_writer.htmlIds.forPreviewSection(previewTarget).name(),\n-                        m_writer.contents.previewMark,\n-                        null, false)));\n-                    spacer = Entity.NO_BREAK_SPACE;\n-                }\n-                if (flags.contains(ElementFlag.RESTRICTED)) {\n-                    link.add(spacer);\n-                    link.add(HtmlTree.SUP(m_writer.getCrossClassLink(\n-                            typeElement,\n-                            m_writer.htmlIds.forRestrictedSection(restrictedTarget).name(),\n-                            m_writer.contents.restrictedMark,\n-                            null, false)));\n-                }\n+                addSuperscript(link, flags, null, typeElement, previewTarget, restrictedTarget);\n@@ -350,0 +321,17 @@\n+        addSuperscript(link, flags, null, null, previewTarget, restrictedTarget);\n+        return link;\n+    }\n+\n+    \/**\n+     * Adds PREVIEW and RESTRICTED superscript labels. Depending on the parameter values,\n+     * labels will be formatted as local or external links or plain text.\n+     *\n+     * @param content the content to add to\n+     * @param flags the flags\n+     * @param fileName file name to link to, or null if no local link target\n+     * @param typeElement external type to link to, or null if no external link\n+     * @param previewTarget preview link target element\n+     * @param restrictedTarget restricted link target element\n+     *\/\n+    private void addSuperscript(Content content, Set<ElementFlag> flags, DocPath fileName, TypeElement typeElement,\n+                                Element previewTarget, ExecutableElement restrictedTarget) {\n@@ -352,1 +340,3 @@\n-            link.add(HtmlTree.SUP(m_writer.contents.previewMark));\n+            content.add(HtmlTree.SUP(getSuperscript(fileName, typeElement,\n+                    m_writer.htmlIds.forPreviewSection(previewTarget),\n+                    m_writer.contents.previewMark)));\n@@ -356,2 +346,23 @@\n-            link.add(spacer);\n-            link.add(HtmlTree.SUP(m_writer.contents.restrictedMark));\n+            content.add(spacer);\n+            content.add(HtmlTree.SUP(getSuperscript(fileName, typeElement,\n+                    m_writer.htmlIds.forRestrictedSection(restrictedTarget),\n+                    m_writer.contents.restrictedMark)));\n+        }\n+    }\n+\n+    \/**\n+     * Returns PREVIEW or RESTRICTED superscript as either local or external link or as plain text.\n+     *\n+     * @param fileName local file name to link to, or null if no local link target\n+     * @param typeElement external type to link to, or null if no external link\n+     * @param id the id fragment to link to\n+     * @param label the label content\n+     * @return superscript content\n+     *\/\n+    private Content getSuperscript(DocPath fileName, TypeElement typeElement, HtmlId id, Content label) {\n+        if (fileName != null) {\n+            return m_writer.links.createLink(fileName.fragment(id.name()), label);\n+        } else if (typeElement != null) {\n+            return (m_writer.getCrossClassLink(typeElement, id.name(), label, null, false));\n+        } else {\n+            return label;\n@@ -359,1 +370,0 @@\n-        return link;\n@@ -388,1 +398,1 @@\n-                links.add(new HtmlTree(HtmlTag.WBR));\n+                links.add(HtmlTree.WBR());\n@@ -395,1 +405,1 @@\n-                    links.add(new HtmlTree(HtmlTag.WBR));\n+                    links.add(HtmlTree.WBR());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkFactory.java","additions":51,"deletions":41,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        var metaRefresh = new HtmlTree(HtmlTag.META)\n+        var metaRefresh = HtmlTree.of(HtmlTag.META)\n@@ -106,3 +106,2 @@\n-        var body = new HtmlTree(HtmlTag.BODY).setStyle(HtmlStyles.indexRedirectPage);\n-        var main = HtmlTree.MAIN(bodyContent);\n-        body.add(main);\n+        var body = HtmlTree.BODY(HtmlStyles.indexRedirectPage)\n+                .add(HtmlTree.MAIN(bodyContent));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/IndexRedirectWriter.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-        var dd = new HtmlTree(HtmlTag.DD);\n+        var dd = HtmlTree.DD();\n@@ -264,1 +264,1 @@\n-        var dd = new HtmlTree(HtmlTag.DD);\n+        var dd = HtmlTree.DD();\n@@ -351,1 +351,1 @@\n-        content.add(new HtmlTree(HtmlTag.BR));\n+        content.add(HtmlTree.BR());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/IndexWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-        moduleContent.add(new HtmlTree(HtmlTag.HR));\n+        moduleContent.add(HtmlTree.HR());\n@@ -828,1 +828,1 @@\n-                desc.add(new HtmlTree(HtmlTag.BR));\n+                desc.add(HtmlTree.BR());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ModuleWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -519,1 +519,1 @@\n-        var navContent = new HtmlTree(HtmlTag.DIV);\n+        var navContent = HtmlTree.DIV(HtmlStyles.navContent);\n@@ -525,2 +525,2 @@\n-        navContent.setStyle(HtmlStyles.navContent).add(HtmlTree.DIV(HtmlStyles.navMenuButton,\n-                        new HtmlTree(HtmlTag.BUTTON).setId(HtmlIds.NAVBAR_TOGGLE_BUTTON)\n+        navContent.add(HtmlTree.DIV(HtmlStyles.navMenuButton,\n+                        HtmlTree.BUTTON(HtmlIds.NAVBAR_TOGGLE_BUTTON)\n@@ -538,3 +538,1 @@\n-        var navList = new HtmlTree(HtmlTag.UL)\n-                .setId(HtmlIds.NAVBAR_TOP_FIRSTROW)\n-                .setStyle(HtmlStyles.navList)\n+        var navList = HtmlTree.UL(HtmlIds.NAVBAR_TOP_FIRSTROW, HtmlStyles.navList)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Navigation.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-        headingContent.add(new HtmlTree(HtmlTag.BR));\n+        headingContent.add(HtmlTree.BR());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageUseWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-        packageContent.add(new HtmlTree(HtmlTag.HR));\n+        packageContent.add(HtmlTree.HR());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,2 +100,2 @@\n-                        .add(new HtmlTree(HtmlTag.BUTTON)\n-                                .add(new HtmlTree(HtmlTag.IMG)\n+                        .add(HtmlTree.BUTTON(HtmlId.of(\"page-search-copy\"))\n+                                .add(HtmlTree.of(HtmlTag.IMG)\n@@ -108,2 +108,1 @@\n-                                .put(HtmlAttr.ARIA_LABEL, copyUrlText)\n-                                .setId(HtmlId.of(\"page-search-copy\")))\n+                                .put(HtmlAttr.ARIA_LABEL, copyUrlText))\n@@ -113,5 +112,3 @@\n-                .add(new HtmlTree(HtmlTag.P)\n-                        .setId(HtmlId.of(\"page-search-notify\"))\n-                        .add(contents.getContent(\"doclet.search.loading\")))\n-                .add(HtmlTree.DIV(new HtmlTree(HtmlTag.DIV)\n-                                .setId(HtmlId.of(\"result-container\"))\n+                .add(HtmlTree.P(contents.getContent(\"doclet.search.loading\"))\n+                        .setId(HtmlId.of(\"page-search-notify\")))\n+                .add(HtmlTree.DIV(HtmlTree.DIV(HtmlId.of(\"result-container\"))\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SearchWriter.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        return new HtmlTree(HtmlTag.LI).setStyle(HtmlStyles.blockList);\n+        return HtmlTree.LI(HtmlStyles.blockList);\n@@ -79,1 +79,0 @@\n-        var pre = new HtmlTree(HtmlTag.PRE);\n@@ -82,3 +81,4 @@\n-        pre.add(fieldContent);\n-        pre.add(\" \");\n-        pre.add(fieldName);\n+        var pre = HtmlTree.PRE()\n+                .add(fieldContent)\n+                .add(\" \")\n+                .add(fieldName);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SerialFieldWriter.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        return new HtmlTree(HtmlTag.LI);\n+        return HtmlTree.LI();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SerialMethodWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -572,1 +572,1 @@\n-                target.add(new HtmlTree(HtmlTag.WBR))\n+                target.add(HtmlTree.WBR())\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Signatures.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-            var pre = new HtmlTree(HtmlTag.PRE);\n+            var pre = HtmlTree.PRE();\n@@ -249,1 +249,1 @@\n-        return new HtmlTree(HtmlTag.BODY).setStyle(HtmlStyles.sourcePage);\n+        return HtmlTree.BODY(HtmlStyles.sourcePage);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SourceToHTMLConverter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -364,1 +364,1 @@\n-            main = new HtmlTree(HtmlTag.DIV).setId(id);\n+            main = HtmlTree.DIV(id);\n@@ -406,2 +406,1 @@\n-            var tabpanel = new HtmlTree(HtmlTag.DIV)\n-                    .setId(HtmlIds.forTabPanel(id))\n+            var tabpanel = HtmlTree.DIV(HtmlIds.forTabPanel(id))\n@@ -419,2 +418,1 @@\n-        var tab = new HtmlTree(HtmlTag.BUTTON)\n-                .setId(tabId)\n+        var tab = HtmlTree.BUTTON(tabId)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Table.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        content.add(new HtmlTree(HtmlTag.BUTTON).addStyle(HtmlStyles.hideSidebar)\n+        content.add(HtmlTree.BUTTON(HtmlStyles.hideSidebar)\n@@ -107,1 +107,1 @@\n-        content.add(new HtmlTree(HtmlTag.BUTTON).addStyle(HtmlStyles.showSidebar)\n+        content.add(HtmlTree.BUTTON(HtmlStyles.showSidebar)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TableOfContents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -275,3 +275,3 @@\n-        var head = new HtmlTree(HtmlTag.HEAD);\n-        head.add(getGeneratedBy(showTimestamp, generatedDate));\n-        head.add(HtmlTree.TITLE(title));\n+        var head = HtmlTree.of(HtmlTag.HEAD)\n+            .add(getGeneratedBy(showTimestamp, generatedDate))\n+            .add(HtmlTree.TITLE(title));\n@@ -303,3 +303,3 @@\n-            var link = new HtmlTree(HtmlTag.LINK);\n-            link.put(HtmlAttr.REL, \"canonical\");\n-            link.put(HtmlAttr.HREF, canonicalLink.getPath());\n+            var link = HtmlTree.of(HtmlTag.LINK)\n+                .put(HtmlAttr.REL, \"canonical\")\n+                .put(HtmlAttr.HREF, canonicalLink.getPath());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Head.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-    function handleResize(e) {\n+    new ResizeObserver((entries) => {\n@@ -478,3 +478,1 @@\n-    }\n-    window.addEventListener(\"orientationchange\", handleResize);\n-    window.addEventListener(\"resize\", handleResize);\n+    }).observe(document.body);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js.template","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -481,1 +481,2 @@\n-    Recursively copy doc-file subdirectories\n+    Enables deep copying of 'doc-files' directories. Subdirectories and all\\n\\\n+    contents are recursively copied to the destination\n@@ -518,1 +519,1 @@\n-    Include footer text for each page\n+    This option is no longer supported and reports a warning\n@@ -556,1 +557,1 @@\n-    Exclude any doc-files subdirectories with given name.\\n\\\n+    Exclude any 'doc-files' subdirectories with given name.\\n\\\n@@ -617,1 +618,1 @@\n-    Generate warning about @serial tag\n+    Reports compile-time warnings for missing '@serial' tags\n@@ -632,1 +633,1 @@\n-    Specify single argument custom tags\n+    Specifies a custom tag with a single argument\n@@ -657,1 +658,2 @@\n-    Include file that help link links to\n+    Specifies a file containing the text that will be displayed when the\\n\\\n+    help link in the navigation bar is clicked\n@@ -694,1 +696,2 @@\n-    Allow JavaScript in options and comments\n+    Allow JavaScript in documentation comments, and options\\n\\\n+    whose value is html-code\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+                    .skipPreview(isPlain)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LinkTaglet.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-        var pre = new HtmlTree(HtmlTag.PRE).setStyle(HtmlStyles.snippet);\n+        var pre = HtmlTree.PRE(HtmlStyles.snippet);\n@@ -131,1 +131,1 @@\n-        var code = new HtmlTree(HtmlTag.CODE)\n+        var code = HtmlTree.CODE()\n@@ -200,1 +200,1 @@\n-                new HtmlTree(HtmlTag.BUTTON)\n+                HtmlTree.of(HtmlTag.BUTTON)\n@@ -203,1 +203,1 @@\n-                        .add(new HtmlTree(HtmlTag.IMG)\n+                        .add(HtmlTree.of(HtmlTag.IMG)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SnippetTaglet.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,1 +86,11 @@\n-    public HtmlTree(HtmlTag tag) {\n+    public static HtmlTree of(HtmlTag tag) {\n+        return new HtmlTree(tag);\n+    }\n+\n+    \/**\n+     * Creates an {@code HTMLTree} object representing an HTML element\n+     * with the given name.\n+     *\n+     * @param tag the name\n+     *\/\n+    HtmlTree(HtmlTag tag) {\n@@ -368,0 +378,40 @@\n+    \/**\n+     * Creates an HTML {@code BODY} element with the given style.\n+     *\n+     * @param style the style\n+     * @return the element\n+     *\/\n+    public static HtmlTree BODY(HtmlStyle style) {\n+        return new HtmlTree(HtmlTag.BODY)\n+                .setStyle(style);\n+    }\n+\n+    private static final HtmlTree BR_INSTANCE = unmodifiableTree(HtmlTag.BR);\n+\n+    \/**\n+     * {@return an HTML {@code BR} element}\n+     *\/\n+    public static HtmlTree BR() {\n+        return BR_INSTANCE;\n+    }\n+\n+    \/**\n+     * Creates an HTML {@code BUTTON} element with the given id.\n+     *\n+     * @param id the id\n+     * @return the element\n+     *\/\n+    public static HtmlTree BUTTON(HtmlId id) {\n+        return new HtmlTree(HtmlTag.BUTTON).setId(id);\n+    }\n+\n+    \/**\n+     * Creates an HTML {@code BUTTON} element with the given style.\n+     *\n+     * @param style the style\n+     * @return the element\n+     *\/\n+    public static HtmlTree BUTTON(HtmlStyle style) {\n+        return new HtmlTree(HtmlTag.BUTTON).setStyle(style);\n+    }\n+\n@@ -379,0 +429,9 @@\n+    \/**\n+     * Creates an empty HTML {@code CODE} element.\n+     *\n+     * @return the element\n+     *\/\n+    public static HtmlTree CODE() {\n+        return new HtmlTree(HtmlTag.CODE);\n+    }\n+\n@@ -390,0 +449,9 @@\n+    \/**\n+     * Creates an empty HTML {@code DD} element.\n+     *\n+     * @return the element\n+     *\/\n+    public static HtmlTree DD() {\n+        return new HtmlTree(HtmlTag.DD);\n+    }\n+\n@@ -421,1 +489,1 @@\n-     * Creates an HTML {@code DL} element with the given style.\n+     * Creates an HTML {@code DIV} element with the given id.\n@@ -423,1 +491,1 @@\n-     * @param style the style\n+     * @param id the id\n@@ -426,16 +494,3 @@\n-    public static HtmlTree DL(HtmlStyle style) {\n-        return new HtmlTree(HtmlTag.DL)\n-                .setStyle(style);\n-    }\n-\n-    \/**\n-     * Creates an HTML {@code DL} element with the given style and content.\n-     *\n-     * @param style the style\n-     * @param body  the content\n-     * @return the element\n-     *\/\n-    public static HtmlTree DL(HtmlStyle style, Content body) {\n-        return new HtmlTree(HtmlTag.DL)\n-                .setStyle(style)\n-                .add(body);\n+    public static HtmlTree DIV(HtmlId id) {\n+        return new HtmlTree(HtmlTag.DIV)\n+                .setId(id);\n@@ -479,0 +534,24 @@\n+    \/**\n+     * Creates an HTML {@code DL} element with the given style.\n+     *\n+     * @param style the style\n+     * @return the element\n+     *\/\n+    public static HtmlTree DL(HtmlStyle style) {\n+        return new HtmlTree(HtmlTag.DL)\n+                .setStyle(style);\n+    }\n+\n+    \/**\n+     * Creates an HTML {@code DL} element with the given style and content.\n+     *\n+     * @param style the style\n+     * @param body  the content\n+     * @return the element\n+     *\/\n+    public static HtmlTree DL(HtmlStyle style, Content body) {\n+        return new HtmlTree(HtmlTag.DL)\n+                .setStyle(style)\n+                .add(body);\n+    }\n+\n@@ -490,0 +569,11 @@\n+    \/**\n+     * Creates an HTML {@code EM} element with the given content.\n+     *\n+     * @param body content for the element\n+     * @return the element\n+     *\/\n+    public static HtmlTree EM(String body) {\n+        return new HtmlTree(HtmlTag.EM)\n+                .add(body);\n+    }\n+\n@@ -576,0 +666,9 @@\n+    private static final HtmlTree HR_INSTANCE = unmodifiableTree(HtmlTag.HR);\n+\n+    \/**\n+     * {@return an HTML {@code HR} element}\n+     *\/\n+    public static HtmlTree HR() {\n+        return HR_INSTANCE;\n+    }\n+\n@@ -633,0 +732,21 @@\n+    \/**\n+     * Creates an empty HTML {@code LI} element.\n+     *\n+     * @return the element\n+     *\/\n+    public static HtmlTree LI() {\n+        return new HtmlTree(HtmlTag.LI);\n+    }\n+\n+\n+    \/**\n+     * Creates an HTML {@code LI} element with the given style.\n+     *\n+     * @param style the style\n+     * @return the element\n+     *\/\n+    public static HtmlTree LI(HtmlStyle style) {\n+        return new HtmlTree(HtmlTag.LI)\n+                .setStyle(style);\n+    }\n+\n@@ -779,0 +899,19 @@\n+    \/**\n+     * Creates an empty HTML {@code PRE} element.\n+     *\n+     * @return the element\n+     *\/\n+    public static HtmlTree PRE() {\n+        return new HtmlTree(HtmlTag.PRE);\n+    }\n+\n+    \/**\n+     * Creates an HTML {@code PRE} element with the given style\n+     *\n+     * @param style  the style\n+     * @return the element\n+     *\/\n+    public static HtmlTree PRE(HtmlStyle style) {\n+        return new HtmlTree(HtmlTag.PRE).setStyle(style);\n+    }\n+\n@@ -974,0 +1113,9 @@\n+    \/**\n+     * Creates an empty HTML {@code UL} element.\n+     *\n+     * @return the element\n+     *\/\n+    public static HtmlTree UL() {\n+        return new HtmlTree(HtmlTag.UL);\n+    }\n+\n@@ -985,0 +1133,13 @@\n+    \/**\n+     * Creates an HTML {@code UL} element with the given id and style.\n+     *\n+     * @param id the id\n+     * @param style the style\n+     * @return the element\n+     *\/\n+    public static HtmlTree UL(HtmlId id, HtmlStyle style) {\n+        return new HtmlTree(HtmlTag.UL)\n+                .setId(id)\n+                .setStyle(style);\n+    }\n+\n@@ -1018,0 +1179,9 @@\n+    private static final HtmlTree WBR_INSTANCE = unmodifiableTree(HtmlTag.WBR);\n+\n+    \/**\n+     * {@return an HTML {@code WBR} element}\n+     *\/\n+    public static HtmlTree WBR() {\n+        return WBR_INSTANCE;\n+    }\n+\n@@ -1155,0 +1325,13 @@\n+\n+    private static HtmlTree unmodifiableTree(HtmlTag tag) {\n+        return new HtmlTree(tag) {\n+            @Override\n+            public HtmlTree add(Content c) {\n+                throw new UnsupportedOperationException(this.tag + \" add\");\n+            }\n+            @Override\n+            public HtmlTree put(HtmlAttr attrName, String attrValue) {\n+                throw new UnsupportedOperationException(this.tag + \" put\");\n+            }\n+        };\n+    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/html\/HtmlTree.java","additions":202,"deletions":19,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -681,1 +681,1 @@\n-         * the {@code --help-extended} option and its aliases.\n+         * the {@code --help-extra} option and its aliases.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    Specifies which members (fields, methods, etc.) will be\\n\\\n+    Specifies which members (fields, methods, or constructors) will be\\n\\\n@@ -90,1 +90,1 @@\n-    Specifies which module's packages will be documented. Possible\\n\\\n+    Specifies which module packages will be documented. Possible\\n\\\n@@ -100,1 +100,1 @@\n-    <value>\n+    (transitive|all)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-        write(annot, true);\n+        write(annot.annotation(), true);\n@@ -104,1 +104,1 @@\n-        write(annot, resolveIndices);\n+        write(annot.annotation(), resolveIndices);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AnnotationWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-                    print(\" \" + instr.typeKind().typeName());\n+                    print(\" \" + instr.typeKind().upperBound().displayName());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/CodeWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,0 +126,2 @@\n+                } else {\n+                    p = Packet.fromByteArray(b);\n@@ -127,1 +129,0 @@\n-                p = Packet.fromByteArray(b);\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/TargetVM.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+    @SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jdi\/windows\/classes\/com\/sun\/tools\/jdi\/SharedMemoryTransportService.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,3 @@\n-    cmdQueueLock = debugMonitorCreate(\"JDWP Command Queue Lock\");\n+    if (cmdQueueLock == NULL) {\n+      cmdQueueLock = debugMonitorCreate(\"JDWP Command Queue Lock\");\n+    }\n@@ -193,1 +195,0 @@\n-    debugMonitorDestroy(cmdQueueLock);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugLoop.c","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"jvm.h\"\n@@ -124,1 +125,5 @@\n-#ifndef STATIC_BUILD\n+\n+    if (JVM_IsStaticallyLinked()) {\n+        return (dbgsysLoadLibrary(NULL, buf, sizeof(buf)));\n+    }\n+\n@@ -148,3 +153,0 @@\n-#else\n-    return (dbgsysLoadLibrary(NULL, buf, sizeof(buf)));\n-#endif\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/transport.c","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-        size_t result_len = (size_t)_snprintf(buffer, buflen, \"%s\\\\%s.dll\", path, fname);\n+        size_t result_len = (size_t) snprintf(buffer, buflen, \"%s\\\\%s.dll\", path, fname);\n","filename":"src\/jdk.jdwp.agent\/windows\/native\/libjdwp\/linker_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,5 +37,0 @@\n-\/* Needed on Windows because names seem to be hidden in stdio.h. *\/\n-\n-#define snprintf        _snprintf\n-#define vsnprintf       _vsnprintf\n-\n","filename":"src\/jdk.jdwp.agent\/windows\/native\/libjdwp\/util_md.h","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.Objects;\n@@ -88,4 +89,1 @@\n-                stream.close();\n-                currentChunk.release();\n-                stream = null;\n-                currentChunk = null;\n+                closeStream();\n@@ -100,1 +98,30 @@\n-    public void close() throws IOException {\n+    public int read(byte[] buf, int off, int len) throws IOException {\n+        Objects.checkFromIndexSize(off, len, buf.length);\n+        if (len == 0) {\n+            return 0;\n+        }\n+\n+        int totalRead = 0;\n+        while (len > 0) {\n+            if (stream == null) {\n+                closeChunk();\n+                if (!nextStream()) {\n+                    return totalRead > 0 ? totalRead : -1;\n+                }\n+            }\n+            int read = stream.read(buf, off, len);\n+            if (read > -1) {\n+                totalRead += read;\n+                len -= read;\n+                if (len == 0) {\n+                    return totalRead;\n+                }\n+                off += read;\n+            } else {\n+                closeStream();\n+            }\n+        }\n+        return totalRead;\n+    }\n+\n+    private void closeStream() throws IOException {\n@@ -105,1 +132,5 @@\n-        while (currentChunk != null) {\n+        closeChunk();\n+    }\n+\n+    private void closeChunk() {\n+        if (currentChunk != null) {\n@@ -108,0 +139,8 @@\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        closeStream();\n+        while (currentChunk != null) {\n+            closeChunk();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ChunkInputStream.java","additions":46,"deletions":7,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-                    delegate.combine(Collections.unmodifiableSet(values));\n+                    return delegate.combine(Collections.unmodifiableSet(values));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Control.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -565,1 +565,1 @@\n-        blockCodeBuilder.loadConstant(Opcode.LDC2_W, eventTypeId);\n+        blockCodeBuilder.loadConstant(eventTypeId);\n@@ -679,1 +679,1 @@\n-        blockCodeBuilder.loadConstant(Opcode.LDC2_W, eventTypeId);\n+        blockCodeBuilder.loadConstant(eventTypeId);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -660,1 +660,1 @@\n-        target.setInternalDuration(Duration.between(startTime, endTime));\n+        target.setInternalDuration(startTime.until(endTime));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.vm.Continuation;\n@@ -32,2 +33,2 @@\n-    public static final int MAX_LIMIT = 128; \/* 0 MAX means disabled *\/\n-\n+    public static final int MAX_LIMIT = 131072; \/* 0 MAX means disabled *\/\n+    private static final int PRECACHE_THRESHOLD = 128;\n@@ -74,9 +75,35 @@\n-    \/* synchronized because of writing the string to the JVM. *\/\n-    private static synchronized long storeString(String s) {\n-        Long lsid = cache.get(s);\n-        long internalSid;\n-        if (lsid != null) {\n-            internalSid = lsid.longValue();\n-            if (isCurrentGeneration(internalSid)) {\n-                \/\/ Someone already updated the cache.\n-                return externalSid(internalSid);\n+    \/* Explicitly pin a virtual thread before acquiring the string pool monitor\n+     * because migrating the EventWriter onto another carrier thread is impossible.\n+     *\/\n+    private static long storeString(String s, boolean pinVirtualThread) {\n+        if (pinVirtualThread) {\n+            assert(Thread.currentThread().isVirtual());\n+            Continuation.pin();\n+        }\n+        try {\n+            \/* synchronized because of writing the string to the JVM. *\/\n+            synchronized (StringPool.class) {\n+                Long lsid = cache.get(s);\n+                long internalSid;\n+                if (lsid != null) {\n+                    internalSid = lsid.longValue();\n+                    if (isCurrentGeneration(internalSid)) {\n+                        \/\/ Someone already updated the cache.\n+                        return externalSid(internalSid);\n+                    }\n+                    internalSid = updateInternalSid(internalSid);\n+                } else {\n+                    \/\/ Not yet added or the cache was cleared.\n+                    internalSid = nextInternalSid();\n+                    currentSizeUTF16 += s.length();\n+                }\n+                long extSid = externalSid(internalSid);\n+                \/\/ Write the string to the JVM before publishing to the cache.\n+                JVM.addStringConstant(extSid, s);\n+                cache.put(s, internalSid);\n+                return extSid;\n+            }\n+        } finally {\n+            if (pinVirtualThread) {\n+                assert(Thread.currentThread().isVirtual());\n+                Continuation.unpin();\n@@ -84,5 +111,0 @@\n-            internalSid = updateInternalSid(internalSid);\n-        } else {\n-            \/\/ Not yet added or the cache was cleared.\n-            internalSid = nextInternalSid();\n-            currentSizeUTF16 += s.length();\n@@ -90,5 +112,0 @@\n-        long extSid = externalSid(internalSid);\n-        \/\/ Write the string to the JVM before publishing to the cache.\n-        JVM.addStringConstant(extSid, s);\n-        cache.put(s, internalSid);\n-        return extSid;\n@@ -98,1 +115,1 @@\n-    private static long ensureCurrentGeneration(String s, Long lsid) {\n+    private static long ensureCurrentGeneration(String s, Long lsid, boolean pinVirtualThread) {\n@@ -100,1 +117,1 @@\n-        return isCurrentGeneration(internalSid) ? externalSid(internalSid) : storeString(s);\n+        return isCurrentGeneration(internalSid) ? externalSid(internalSid) : storeString(s, pinVirtualThread);\n@@ -112,1 +129,1 @@\n-    public static long addString(String s) {\n+    public static long addString(String s, boolean pinVirtualThread) {\n@@ -115,1 +132,1 @@\n-            return ensureCurrentGeneration(s, lsid);\n+            return ensureCurrentGeneration(s, lsid, pinVirtualThread);\n@@ -117,1 +134,1 @@\n-        if (!preCache(s)) {\n+        if (s.length() <= PRECACHE_THRESHOLD && !preCache(s)) {\n@@ -123,1 +140,1 @@\n-            reset();\n+            reset(pinVirtualThread);\n@@ -125,1 +142,1 @@\n-        return storeString(s);\n+        return storeString(s, pinVirtualThread);\n@@ -146,3 +163,16 @@\n-    private static synchronized void reset() {\n-        cache.clear();\n-        currentSizeUTF16 = 0;\n+    private static void reset(boolean pinVirtualThread) {\n+        if (pinVirtualThread) {\n+            assert(Thread.currentThread().isVirtual());\n+            Continuation.pin();\n+        }\n+        try {\n+            synchronized (StringPool.class) {\n+                cache.clear();\n+                currentSizeUTF16 = 0;\n+            }\n+        } finally {\n+            if (pinVirtualThread) {\n+                assert(Thread.currentThread().isVirtual());\n+                Continuation.unpin();\n+            }\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/StringPool.java","additions":62,"deletions":32,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+    private boolean pinVirtualThread;\n@@ -147,1 +148,1 @@\n-            long l = StringPool.addString(s);\n+            long l = StringPool.addString(s, pinVirtualThread);\n@@ -299,1 +300,1 @@\n-    private EventWriter(long startPos, long maxPos, long threadID, boolean valid, boolean excluded) {\n+    private EventWriter(long startPos, long maxPos, long threadID, boolean valid, boolean pinVirtualThread, boolean excluded) {\n@@ -304,0 +305,1 @@\n+        this.pinVirtualThread = pinVirtualThread;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventWriter.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -475,1 +475,1 @@\n-            return Duration.between(first, last);\n+            return first.until(last);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Function.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-            Duration d = Duration.between(current.start(), next.start());\n+            Duration d = current.start().until(next.start());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/StopWatch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1565,1 +1565,1 @@\n-                   .newarray(TypeKind.ByteType);\n+                   .newarray(TypeKind.BYTE);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/ExecutableRebrander.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExeBundler.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WindowsRegistry.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-         * @jls 7.6 Top Level Type Declarations\n+         * @jls 7.6 Top Level Class and Interface Declarations\n@@ -244,1 +244,1 @@\n-         * @jls 8.9 Enum Types\n+         * @jls 8.9 Enum Classes\n@@ -251,1 +251,1 @@\n-         * @jls 8.10 Record Types\n+         * @jls 8.10 Record Classes\n@@ -260,1 +260,1 @@\n-         * @jls 9.6 Annotation Types\n+         * @jls 9.6 Annotation Interfaces\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/Snippet.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-                    return true;\n+                    return false;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/ExecutionControlForwarder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -73,0 +74,2 @@\n+    private static final int SHUTDOWN_TIMEOUT = 1; \/\/1 second\n+\n@@ -270,0 +273,14 @@\n+\n+        Process remoteProcess;\n+\n+        synchronized (this) {\n+            remoteProcess = this.process;\n+        }\n+\n+        if (remoteProcess != null) {\n+            try {\n+                remoteProcess.waitFor(SHUTDOWN_TIMEOUT, TimeUnit.SECONDS);\n+            } catch (InterruptedException ex) {\n+                debug(ex, \"waitFor remote\");\n+            }\n+        }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiDefaultExecutionControl.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.management.agent\/unix\/classes\/jdk\/internal\/agent\/FileSystemImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.management.agent\/windows\/classes\/jdk\/internal\/agent\/FileSystemImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+ *\n+ * @since 1.6\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/HotSpotDiagnosticMXBean.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-     * Returns the \"recent cpu usage\" for the whole system. This value is a\n+     * Returns the \"recent CPU usage\" for the whole system. This value is a\n@@ -137,3 +137,9 @@\n-     * during the recent period being observed. All values between 0.0 and\n-     * 1.0 are possible depending of the activities going on in the system.\n-     * If the system recent cpu usage is not available, the method returns a\n+     * during the recent period being observed.\n+     *\n+     * The recent period of observation is implementation-specific, and\n+     * typically relates to the duration since the last call made to this\n+     * method, or {@link #getCpuLoad()}. For the very first invocation, the\n+     * recent period of observation is undefined.\n+     *\n+     * All values between 0.0 and 1.0 are possible dependent on the activities\n+     * going on. If the recent CPU usage is not available, the method returns a\n@@ -145,0 +151,3 @@\n+     * @apiNote Callers should be aware of the possibility of other callers\n+     * affecting the observation period and the result.\n+     *\n@@ -156,1 +165,1 @@\n-     * Returns the \"recent cpu usage\" for the operating environment. This value\n+     * Returns the \"recent CPU usage\" for the operating environment. This value\n@@ -160,3 +169,9 @@\n-     * during the recent period being observed. All values between 0.0 and\n-     * 1.0 are possible depending of the activities going on.\n-     * If the recent cpu usage is not available, the method returns a\n+     * during the recent period being observed.\n+     *\n+     * The recent period of observation is implementation-specific, and\n+     * typically relates to the duration since the last call made to this\n+     * method, or {@link #getSystemCpuLoad()}. For the very first invocation,\n+     * the recent period of observation is undefined.\n+     *\n+     * All values between 0.0 and 1.0 are possible dependent on the activities\n+     * going on. If the recent CPU usage is not available, the method returns a\n@@ -165,0 +180,3 @@\n+     * @apiNote Callers should be aware of the possibility of other callers\n+     * affecting the observation period and the result.\n+     *\n@@ -172,1 +190,1 @@\n-     * Returns the \"recent cpu usage\" for the Java Virtual Machine process.\n+     * Returns the \"recent CPU usage\" for the Java Virtual Machine process.\n@@ -178,4 +196,14 @@\n-     * the application threads as well as the JVM internal threads. All values\n-     * between 0.0 and 1.0 are possible depending of the activities going on\n-     * in the JVM process and the whole system. If the Java Virtual Machine\n-     * recent CPU usage is not available, the method returns a negative value.\n+     * the application threads as well as the JVM internal threads.\n+     *\n+     * The recent period of observation is implementation-specific, and\n+     * typically relates to the duration since the last call made to this\n+     * method. For the very first invocation, the recent period of observation\n+     * is undefined.\n+     *\n+     * All values between 0.0 and 1.0 are possible dependent on the activities\n+     * going on in the JVM process and the whole system. If the Java Virtual\n+     * Machine recent CPU usage is not available, the method returns a negative\n+     * value.\n+     *\n+     * @apiNote Callers should be aware of the possibility of other callers\n+     * affecting the observation period and the result.\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/OperatingSystemMXBean.java","additions":41,"deletions":13,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/Flag.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import jdk.management.VirtualThreadSchedulerMXBean;\n@@ -47,1 +48,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n@@ -166,0 +167,35 @@\n+        \/**\n+         * VirtualThreadSchedulerMXBean.\n+         *\/\n+        initMBeanList.add(new PlatformComponent<VirtualThreadSchedulerMXBean>() {\n+            private final Set<Class<? extends VirtualThreadSchedulerMXBean>> mbeanInterfaces =\n+                    Set.of(VirtualThreadSchedulerMXBean.class);\n+            private final Set<String> mbeanInterfaceNames =\n+                    Set.of(VirtualThreadSchedulerMXBean.class.getName());\n+            private VirtualThreadSchedulerMXBean impl;\n+\n+            @Override\n+            public Set<Class<? extends VirtualThreadSchedulerMXBean>> mbeanInterfaces() {\n+                return mbeanInterfaces;\n+            }\n+\n+            @Override\n+            public Set<String> mbeanInterfaceNames() {\n+                return mbeanInterfaceNames;\n+            }\n+\n+            @Override\n+            public String getObjectNamePattern() {\n+                return \"jdk.management:type=VirtualThreadScheduler\";\n+            }\n+\n+            @Override\n+            public Map<String, VirtualThreadSchedulerMXBean> nameToMBeanMap() {\n+                VirtualThreadSchedulerMXBean impl = this.impl;\n+                if (impl == null) {\n+                    this.impl = impl = VirtualThreadSchedulerImpls.create();\n+                }\n+                return Map.of(\"jdk.management:type=VirtualThreadScheduler\", impl);\n+            }\n+        });\n+\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/PlatformMBeanProviderImpl.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.management.internal;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ForkJoinPool;\n+import javax.management.ObjectName;\n+import jdk.management.VirtualThreadSchedulerMXBean;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.vm.ContinuationSupport;\n+import sun.management.Util;\n+\n+\/**\n+ * Provides the implementation of the management interface for the JDK's default virtual\n+ * thread scheduler.\n+ *\/\n+public class VirtualThreadSchedulerImpls {\n+    private VirtualThreadSchedulerImpls() {\n+    }\n+\n+    public static VirtualThreadSchedulerMXBean create() {\n+        if (ContinuationSupport.isSupported()) {\n+            return new VirtualThreadSchedulerImpl();\n+        } else {\n+            return new BoundVirtualThreadSchedulerImpl();\n+        }\n+    }\n+\n+    \/**\n+     * Base implementation of VirtualThreadSchedulerMXBean.\n+     *\/\n+    private abstract static class BaseVirtualThreadSchedulerImpl\n+            implements VirtualThreadSchedulerMXBean {\n+\n+        abstract void implSetParallelism(int size);\n+\n+        @Override\n+        public final void setParallelism(int size) {\n+            Util.checkControlAccess();\n+            implSetParallelism(size);\n+        }\n+\n+        @Override\n+        public final ObjectName getObjectName() {\n+            return Util.newObjectName(\"jdk.management:type=VirtualThreadScheduler\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var sb = new StringBuilder(\"[parallelism=\");\n+            sb.append(getParallelism());\n+            append(sb, \"size\", getPoolSize());\n+            append(sb, \"mounted\", getMountedVirtualThreadCount());\n+            append(sb, \"queued\", getQueuedVirtualThreadCount());\n+            sb.append(']');\n+            return sb.toString();\n+        }\n+\n+        private void append(StringBuilder sb, String name, long value) {\n+            sb.append(\", \").append(name).append('=');\n+            if (value >= 0) {\n+                sb.append(value);\n+            } else {\n+                sb.append(\"<unavailable>\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Implementation of VirtualThreadSchedulerMXBean when virtual threads are\n+     * implemented with continuations + scheduler.\n+     *\/\n+    private static final class VirtualThreadSchedulerImpl extends BaseVirtualThreadSchedulerImpl {\n+        \/**\n+         * Holder class for scheduler.\n+         *\/\n+        private static class Scheduler {\n+            private static final Executor scheduler =\n+                SharedSecrets.getJavaLangAccess().virtualThreadDefaultScheduler();\n+            static Executor instance() {\n+                return scheduler;\n+            }\n+        }\n+\n+        @Override\n+        public int getParallelism() {\n+            if (Scheduler.instance() instanceof ForkJoinPool pool) {\n+                return pool.getParallelism();\n+            }\n+            throw new InternalError();  \/\/ should not get here\n+        }\n+\n+        @Override\n+        void implSetParallelism(int size) {\n+            if (Scheduler.instance() instanceof ForkJoinPool pool) {\n+                pool.setParallelism(size);\n+                if (pool.getPoolSize() < size) {\n+                    \/\/ FJ worker thread creation is on-demand\n+                    Thread.startVirtualThread(() -> { });\n+                }\n+\n+                return;\n+            }\n+            throw new UnsupportedOperationException();  \/\/ should not get here\n+        }\n+\n+        @Override\n+        public int getPoolSize() {\n+            if (Scheduler.instance() instanceof ForkJoinPool pool) {\n+                return pool.getPoolSize();\n+            }\n+            return -1;  \/\/ should not get here\n+        }\n+\n+        @Override\n+        public int getMountedVirtualThreadCount() {\n+            if (Scheduler.instance() instanceof ForkJoinPool pool) {\n+                return pool.getActiveThreadCount();\n+            }\n+            return -1;  \/\/ should not get here\n+        }\n+\n+        @Override\n+        public long getQueuedVirtualThreadCount() {\n+            if (Scheduler.instance() instanceof ForkJoinPool pool) {\n+                return pool.getQueuedTaskCount() + pool.getQueuedSubmissionCount();\n+            }\n+            return -1L;  \/\/ should not get here\n+        }\n+    }\n+\n+    \/**\n+     * Implementation of VirtualThreadSchedulerMXBean when virtual threads are backed\n+     * by platform threads.\n+     *\/\n+    private static final class BoundVirtualThreadSchedulerImpl extends BaseVirtualThreadSchedulerImpl {\n+        @Override\n+        public int getParallelism() {\n+            return Integer.MAX_VALUE;\n+        }\n+\n+        @Override\n+        void implSetParallelism(int size) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public int getPoolSize() {\n+            return -1;\n+        }\n+\n+        @Override\n+        public int getMountedVirtualThreadCount() {\n+            return -1;\n+        }\n+\n+        @Override\n+        public long getQueuedVirtualThreadCount() {\n+            return -1L;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/VirtualThreadSchedulerImpls.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,2 @@\n- * This package contains the JDK's extension to\n- * the standard implementation of the\n- * {@link java.lang.management} API and also defines the management\n+ * This package contains JDK extensions to the standard implementation of\n+ * the {@link java.lang.management} API and also defines the management\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/package-info.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.management;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.PlatformManagedObject;\n+import java.util.concurrent.ForkJoinPool;\n+import javax.management.MBeanServer;\n+import javax.management.ObjectName;\n+\n+\/**\n+ * Management interface for the JDK's {@linkplain Thread##virtual-threads virtual thread}\n+ * scheduler.\n+ *\n+ * <p> {@code VirtualThreadSchedulerMXBean} supports monitoring of the virtual thread\n+ * scheduler's target parallelism, the {@linkplain Thread##platform-threads platform threads}\n+ * used by the scheduler, and the number of virtual threads queued to the scheduler. It\n+ * also supports dynamically changing the scheduler's target parallelism.\n+ *\n+ * <p> The management interface is registered with the platform {@link MBeanServer\n+ * MBeanServer}. The {@link ObjectName ObjectName} that uniquely identifies the management\n+ * interface within the {@code MBeanServer} is: \"jdk.management:type=VirtualThreadScheduler\".\n+ *\n+ * <p> Direct access to the MXBean interface can be obtained with\n+ * {@link ManagementFactory#getPlatformMXBean(Class)}.\n+ *\n+ * @since 24\n+ *\/\n+public interface VirtualThreadSchedulerMXBean extends PlatformManagedObject {\n+\n+    \/**\n+     * {@return the scheduler's target parallelism}\n+     *\n+     * @see ForkJoinPool#getParallelism()\n+     *\/\n+    int getParallelism();\n+\n+    \/**\n+     * Sets the scheduler's target parallelism.\n+     *\n+     * <p> Increasing the target parallelism allows the scheduler to use more platform\n+     * threads to <i>carry<\/i> virtual threads if required. Decreasing the target parallelism\n+     * reduces the number of threads that the scheduler may use to carry virtual threads.\n+     *\n+     * @apiNote If virtual threads are mounting and unmounting frequently then downward\n+     * adjustment of the target parallelism will likely come into effect quickly.\n+     *\n+     * @implNote The JDK's virtual thread scheduler is a {@link ForkJoinPool}. Target\n+     * parallelism defaults to the number of {@linkplain Runtime#availableProcessors()\n+     * available processors}. The minimum target parallelism is 1, the maximum target\n+     * parallelism is 32767.\n+     *\n+     * @param size the target parallelism level\n+     * @throws IllegalArgumentException if size is less than the minimum, or\n+     *         greater than the maximum, supported by the scheduler\n+     * @throws UnsupportedOperationException if changing the target\n+     *         parallelism is not suppored by the scheduler\n+     *\n+     * @see ForkJoinPool#setParallelism(int)\n+     *\/\n+    void setParallelism(int size);\n+\n+    \/**\n+     * {@return the current number of platform threads that the scheduler has started\n+     * but have not terminated; {@code -1} if not known}\n+     *\n+     * <p> The count includes the platform threads that are currently <i>carrying<\/i>\n+     * virtual threads and the platform threads that are not currently carrying virtual\n+     * threads. The thread count may be greater than the scheduler's target parallelism.\n+     *\n+     * @implNote The JDK's virtual thread scheduler is a {@link ForkJoinPool}. The pool\n+     * size is the {@linkplain ForkJoinPool#getPoolSize() number of worker threads}.\n+     *\/\n+    int getPoolSize();\n+\n+    \/**\n+     * {@return an estimate of the number of virtual threads that are currently\n+     * <i>mounted<\/i> by the scheduler; {@code -1} if not known}\n+     *\n+     * <p> The number of mounted virtual threads is equal to the number of platform\n+     * threads carrying virtual threads.\n+     *\n+     * @implNote This method may overestimate the number of virtual threads that are mounted.\n+     *\/\n+    int getMountedVirtualThreadCount();\n+\n+    \/**\n+     * {@return an estimate of the number of virtual threads that are queued to\n+     * the scheduler to start or continue execution; {@code -1} if not known}\n+     *\n+     * @implNote This method may overestimate the number of virtual threads that are\n+     * queued to execute.\n+     *\/\n+    long getQueuedVirtualThreadCount();\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.management\/share\/classes\/jdk\/management\/VirtualThreadSchedulerMXBean.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * This package contains JDK extensions to the standard implementation of the\n+ * {@link java.lang.management} API.\n+ *\n+ * @since 24\n+ *\/\n+\n+package jdk.management;\n\\ No newline at end of file\n","filename":"src\/jdk.management\/share\/classes\/jdk\/management\/package-info.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import java.lang.management.ManagementFactory;\n+\n@@ -29,0 +31,7 @@\n+ * <p> This module contains the JDK's extensions to the standard implementation\n+ * of the {@link java.lang.management} API and also defines the management\n+ * interfaces for some other components of the platform.\n+ *\n+ * <p> All platform MBeans are registered in the <em>platform MBeanServer<\/em>\n+ * which can be obtained with {@link ManagementFactory#getPlatformMBeanServer}.\n+ *\n@@ -36,0 +45,1 @@\n+    exports jdk.management;\n","filename":"src\/jdk.management\/share\/classes\/module-info.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -439,7 +439,7 @@\n-        _snprintf(fullCounterPath,\n-                  fullCounterPathLen,\n-                  PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n-                  objectName,\n-                  imageName,\n-                  instance,\n-                  counterName);\n+        snprintf(fullCounterPath,\n+                 fullCounterPathLen,\n+                 PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n+                 objectName,\n+                 imageName,\n+                 instance,\n+                 counterName);\n@@ -475,6 +475,6 @@\n-            _snprintf(fullCounterPath,\n-                      fullCounterPathLen,\n-                      OBJECT_WITH_INSTANCES_COUNTER_FMT,\n-                      objectName,\n-                      instance,\n-                      counterName);\n+            snprintf(fullCounterPath,\n+                     fullCounterPathLen,\n+                     OBJECT_WITH_INSTANCES_COUNTER_FMT,\n+                     objectName,\n+                     instance,\n+                     counterName);\n@@ -482,5 +482,5 @@\n-            _snprintf(fullCounterPath,\n-                      fullCounterPathLen,\n-                      OBJECT_COUNTER_FMT,\n-                      objectName,\n-                      counterName);\n+            snprintf(fullCounterPath,\n+                     fullCounterPathLen,\n+                     OBJECT_COUNTER_FMT,\n+                     objectName,\n+                     counterName);\n@@ -722,4 +722,4 @@\n-            _snprintf(fullIDProcessCounterPath,\n-                      MAX_PATH,\n-                      pdhIDProcessCounterFmt,\n-                      index);\n+            snprintf(fullIDProcessCounterPath,\n+                     MAX_PATH,\n+                     pdhIDProcessCounterFmt,\n+                     index);\n@@ -1062,7 +1062,7 @@\n-    _snprintf(pdhIDProcessCounterFmt,\n-              pdhIDProcessCounterFmtLen,\n-              PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n-              pdhLocalizedProcessObject,\n-              pdhProcessImageName,\n-              \"%d\",\n-              pdhLocalizedIDProcessCounter);\n+    snprintf(pdhIDProcessCounterFmt,\n+             pdhIDProcessCounterFmtLen,\n+             PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n+             pdhLocalizedProcessObject,\n+             pdhProcessImageName,\n+             \"%d\",\n+             pdhLocalizedIDProcessCounter);\n","filename":"src\/jdk.management\/windows\/native\/libmanagement_ext\/OperatingSystemImpl.c","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/aix\/classes\/jdk\/net\/AIXSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/linux\/classes\/jdk\/net\/LinuxSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/macosx\/classes\/jdk\/net\/MacOSXSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/windows\/classes\/jdk\/net\/WindowsSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1097,1 +1097,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpNet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-\n+    @SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/module\/NTSystem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    @SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/module\/UnixSystem.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include <stdbool.h>\n@@ -67,5 +68,0 @@\n-#ifndef bool\n-#define bool int\n-#define true 1\n-#define false 0\n-#endif \/*bool*\/\n","filename":"src\/utils\/hsdis\/binutils\/hsdis-binutils.c","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-      FLAG_SET_ERGO(MaxNewSize, 80 * M);\n+      FLAG_SET_ERGO(MaxNewSize, 50 * M);\n@@ -162,0 +162,3 @@\n+\/\/ Tests require at least 128M of MaxHeap\n+\/\/ otherwise ergonomic is different and generation sizes might be changed.\n+\n@@ -166,0 +169,3 @@\n+  if (MaxHeapSize < 128 * M) {\n+      return;\n+  }\n@@ -178,0 +184,3 @@\n+  if (MaxHeapSize < 128 * M) {\n+    return;\n+  }\n@@ -190,2 +199,2 @@\n-  TestGenCollectorPolicy::SetNewSizeCmd setter_large(80 * M);\n-  TestGenCollectorPolicy::CheckYoungInitial checker_large(80 * M);\n+  TestGenCollectorPolicy::SetNewSizeCmd setter_large(50 * M);\n+  TestGenCollectorPolicy::CheckYoungInitial checker_large(50 * M);\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_collectorPolicy.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-    page.reset(ZPageAge::eden, ZPageResetType::Allocation);\n+    page.reset(ZPageAge::eden);\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zForwarding.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    cld->metaspace_non_null()->deallocate(p, sz, in_class_space);\n+    cld->metaspace_non_null()->deallocate(p, sz);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspace_misc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  EXPECT_TRUE(si.is_invalid());\n+  EXPECT_TRUE(NCSS::is_invalid(si));\n@@ -60,1 +60,1 @@\n-      EXPECT_FALSE(NCSS::StackIndex::equals(si_arr[i],si_arr[j]));\n+      EXPECT_FALSE(NCSS::equals(si_arr[i],si_arr[j]));\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_nativecallstackstorage.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  char* subsystem_path() override {\n+  const char* subsystem_path() override {\n@@ -473,0 +473,84 @@\n+TEST(cgroupTest, cgroupv2_is_hierarchy_walk_needed) {\n+  bool controller_read_only = false; \/\/ value irrelevant;\n+  CgroupV2Controller* test = new CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                    (char*)\"\/\" \/* cgroup_path *\/,\n+                                                    controller_read_only);\n+  EXPECT_FALSE(test->needs_hierarchy_adjustment());\n+  test = new CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                (char*)\"\/bar\" \/* cgroup_path *\/,\n+                                controller_read_only);\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+  test = new CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\/b\",\n+                                (char*)\"\/a\/b\" \/* cgroup_path *\/,\n+                                controller_read_only);\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+\n+  CgroupCpuController* test2 = new CgroupV2CpuController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                                            (char*)\"\/\" \/* cgroup_path *\/,\n+                                                                            controller_read_only));\n+  EXPECT_FALSE(test2->needs_hierarchy_adjustment());\n+  test2 = new CgroupV2CpuController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                       (char*)\"\/bar\" \/* cgroup_path *\/,\n+                                                       controller_read_only));\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+  test2 = new CgroupV2CpuController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\/b\",\n+                                                       (char*)\"\/a\/b\" \/* cgroup_path *\/,\n+                                                       controller_read_only));\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+\n+  CgroupMemoryController* test3 = new CgroupV2MemoryController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                                                  (char*)\"\/\" \/* cgroup_path *\/,\n+                                                                                  controller_read_only));\n+  EXPECT_FALSE(test3->needs_hierarchy_adjustment());\n+  test3 = new CgroupV2MemoryController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                          (char*)\"\/bar\" \/* cgroup_path *\/,\n+                                                          controller_read_only));\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+  test3 = new CgroupV2MemoryController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\/b\",\n+                                                          (char*)\"\/a\/b\" \/* cgroup_path *\/,\n+                                                          controller_read_only));\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+}\n+\n+TEST(cgroupTest, cgroupv1_is_hierarchy_walk_needed) {\n+  bool controller_read_only = true; \/\/ shouldn't matter;\n+  CgroupV1Controller* test = new CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                    (char*)\"\/sys\/fs\/cgroup\/memory\" \/* mount_path *\/,\n+                                                    controller_read_only);\n+  test->set_subsystem_path((char*)\"\/a\/b\/c\");\n+  EXPECT_FALSE(test->needs_hierarchy_adjustment());\n+  test->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+  test = new CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                (char*)\"\/\"\/* mount_path *\/,\n+                                controller_read_only);\n+  test->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+\n+  CgroupCpuController* test2 = new CgroupV1CpuController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                                            (char*)\"\/sys\/fs\/cgroup\/memory\" \/* mount_path *\/,\n+                                                                            controller_read_only));\n+  static_cast<CgroupV1CpuController*>(test2)->set_subsystem_path((char*)\"\/a\/b\/c\");\n+  EXPECT_FALSE(test2->needs_hierarchy_adjustment());\n+  static_cast<CgroupV1CpuController*>(test2)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+  test2 = new CgroupV1CpuController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                       (char*)\"\/\"\/* mount_path *\/,\n+                                                       controller_read_only));\n+  static_cast<CgroupV1CpuController*>(test2)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+\n+  CgroupMemoryController* test3 = new CgroupV1MemoryController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                                                  (char*)\"\/sys\/fs\/cgroup\/memory\" \/* mount_path *\/,\n+                                                                                  controller_read_only));\n+  static_cast<CgroupV1MemoryController*>(test3)->set_subsystem_path((char*)\"\/a\/b\/c\");\n+  EXPECT_FALSE(test3->needs_hierarchy_adjustment());\n+  static_cast<CgroupV1MemoryController*>(test3)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+  test3 = new CgroupV1MemoryController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                          (char*)\"\/\"\/* mount_path *\/,\n+                                                          controller_read_only));\n+  static_cast<CgroupV1MemoryController*>(test3)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":85,"deletions":1,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- uint cache_line_size = VM_Version::L1_data_cache_line_size();\n+  uint cache_line_size = VM_Version::L1_data_cache_line_size();\n@@ -32,9 +32,1 @@\n- if (cache_line_size != 0) {\n-   \/\/ We were able to determine the L1 data cache line size so\n-   \/\/ do some cache line specific sanity checks\n-   EXPECT_EQ((size_t) 0, sizeof (PaddedEnd<ObjectMonitor>) % cache_line_size)\n-        << \"PaddedEnd<ObjectMonitor> size is not a \"\n-        << \"multiple of a cache line which permits false sharing. \"\n-        << \"sizeof(PaddedEnd<ObjectMonitor>) = \"\n-        << sizeof (PaddedEnd<ObjectMonitor>)\n-        << \"; cache_line_size = \" << cache_line_size;\n+  if (cache_line_size != 0) {\n@@ -42,2 +34,10 @@\n-   EXPECT_GE((size_t) in_bytes(ObjectMonitor::owner_offset()), cache_line_size)\n-        << \"the _header and _owner fields are closer \"\n+    EXPECT_EQ(in_bytes(ObjectMonitor::metadata_offset()), 0)\n+        << \"_metadata at a non 0 offset. metadata_offset = \"\n+        << in_bytes(ObjectMonitor::metadata_offset());\n+\n+    EXPECT_GE((size_t) in_bytes(ObjectMonitor::owner_offset()), cache_line_size)\n+        << \"the _metadata and _owner fields are closer \"\n+        << \"than a cache line which permits false sharing.\";\n+\n+    EXPECT_GE((size_t) in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), cache_line_size)\n+        << \"the _owner and _recursions fields are closer \"\n","filename":"test\/hotspot\/gtest\/runtime\/test_objectMonitor.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -181,0 +181,10 @@\n+\/\/ version with a highlighted pc location\n+static void do_test_print_hex_dump_highlighted(const_address from, const_address to, int unitsize, int bytes_per_line,\n+                                   const_address logical_start, const char* expected, const_address highlight) {\n+  char buf[2048];\n+  buf[0] = '\\0';\n+  stringStream ss(buf, sizeof(buf));\n+  os::print_hex_dump(&ss, from, to, unitsize, \/* print_ascii=*\/true, bytes_per_line, logical_start, highlight);\n+  EXPECT_STREQ(buf, expected);\n+}\n+\n@@ -200,0 +210,18 @@\n+#define PAT_HL_1A \"=>\" ADDRESS1 \":   ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\\n\" \\\n+              \"  \" ADDRESS2 \":   ff ff e0 dc 23 00 6a 64 6b 2f 69 6e 74 65 72 6e 61 6c 2f 6c 6f 61 64 65 72 2f 4e 61 74 69 76 65   \" ASCII_1 \"\\n\" \\\n+              \"  \" ADDRESS3 \":   4c 69 62 72 61 72 69 65 73 00 00 00 00 00 00 00                                                   \" ASCII_2 \"\\n\"\n+\n+#define PAT_HL_1B \"  \" ADDRESS1 \":   ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\\n\" \\\n+              \"=>\" ADDRESS2 \":   ff ff e0 dc 23 00 6a 64 6b 2f 69 6e 74 65 72 6e 61 6c 2f 6c 6f 61 64 65 72 2f 4e 61 74 69 76 65   \" ASCII_1 \"\\n\" \\\n+              \"  \" ADDRESS3 \":   4c 69 62 72 61 72 69 65 73 00 00 00 00 00 00 00                                                   \" ASCII_2 \"\\n\"\n+\n+#ifdef VM_LITTLE_ENDIAN\n+#define PAT_HL_1C \"  \" ADDRESS1 \":   ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????\\n\" \\\n+              \"=>\" ADDRESS2 \":   ffff dce0 0023 646a 2f6b 6e69 6574 6e72 6c61 6c2f 616f 6564 2f72 614e 6974 6576   \" ASCII_1 \"\\n\" \\\n+              \"  \" ADDRESS3 \":   694c 7262 7261 6569 0073 0000 0000 0000                                           \" ASCII_2 \"\\n\"\n+#else\n+#define PAT_HL_1C \"  \" ADDRESS1 \":   ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????\\n\" \\\n+              \"=>\" ADDRESS2 \":   ffff e0dc 2300 6a64 6b2f 696e 7465 726e 616c 2f6c 6f61 6465 722f 4e61 7469 7665   \" ASCII_1 \"\\n\" \\\n+              \"  \" ADDRESS3 \":   4c69 6272 6172 6965 7300 0000 0000 0000                                           \" ASCII_2 \"\\n\"\n+#endif\n+\n@@ -255,0 +283,6 @@\n+  \/\/ print with highlighted address\n+  do_test_print_hex_dump_highlighted(from, to, 1, 32, logical_start, PAT_HL_1A, from+5);\n+  do_test_print_hex_dump_highlighted(from, to, 1, 32, logical_start, PAT_HL_1B, from+32);\n+  do_test_print_hex_dump_highlighted(from, to, 1, 32, logical_start, PAT_HL_1B, from+60);\n+  do_test_print_hex_dump_highlighted(from, to, 2, 32, logical_start, PAT_HL_1C, from+60);\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,5 +32,0 @@\n-vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\/TestDescription.java#id0            8205957 generic-all\n-vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\/TestDescription.java#logging        8205957 generic-all\n-vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java#id0     8205957 generic-all\n-vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java#logging 8205957 generic-all\n-\n@@ -59,0 +54,2 @@\n+\n+runtime\/condy\/escapeAnalysis\/TestEscapeCondy.java 8339694 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+serviceability\/sa\/TestJhsdbJstackUpcall.java                  8307393   generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-generational-zgc.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+compiler\/c2\/irTests\/TestIfMinMax.java 8339220 linux-s390x\n@@ -76,2 +77,0 @@\n-compiler\/startup\/StartupOutput.java 8326615 generic-x64\n-\n@@ -118,1 +117,0 @@\n-runtime\/ErrorHandling\/TestDwarf.java#checkDecoder 8305489 linux-all\n@@ -123,1 +121,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+    systemd.support \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,9 +49,0 @@\n-    public static long lseed = 1;\n-    public static int iseed = 2;\n-    public static short sseed = 3;\n-    public static byte bseed = 4;\n-    public static long lres = lseed;\n-    public static int ires = iseed;\n-    public static short sres = sseed;\n-    public static byte bres = bseed;\n-\n@@ -62,1 +53,1 @@\n-        private static final long data;\n+        private static final long lseed = 1;\n@@ -72,1 +63,0 @@\n-            lres += UNSAFE.getLongUnaligned(BYTES, 1030);\n@@ -74,2 +64,1 @@\n-            UNSAFE.putLongUnaligned(BYTES, 127, lres);\n-            lres += UNSAFE.getLongUnaligned(BYTES, 127);\n+            UNSAFE.putLongUnaligned(BYTES, 127, rawdata+lseed);\n@@ -77,2 +66,1 @@\n-            UNSAFE.putLongUnaligned(BYTES, 1096, lres);\n-            data = UNSAFE.getLongUnaligned(BYTES, 1096);\n+            UNSAFE.putLongUnaligned(BYTES, 1096, rawdata-lseed);\n@@ -87,1 +75,1 @@\n-        private static final int data;\n+        private static final int iseed = 2;\n@@ -96,1 +84,0 @@\n-            ires += UNSAFE.getIntUnaligned(BYTES, 274);\n@@ -98,2 +85,1 @@\n-            UNSAFE.putIntUnaligned(BYTES, 255, ires);\n-            ires += UNSAFE.getIntUnaligned(BYTES, 255);\n+            UNSAFE.putIntUnaligned(BYTES, 255, rawdata + iseed);\n@@ -101,2 +87,1 @@\n-            UNSAFE.putIntUnaligned(BYTES, 528, ires);\n-            data = UNSAFE.getIntUnaligned(BYTES, 528);\n+            UNSAFE.putIntUnaligned(BYTES, 528, rawdata - iseed);\n@@ -111,1 +96,1 @@\n-        private static final short data;\n+        private static final short sseed = 3;\n@@ -120,1 +105,0 @@\n-            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 257));\n@@ -122,2 +106,1 @@\n-            UNSAFE.putShortUnaligned(BYTES, 253, sres);\n-            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 253));\n+            UNSAFE.putShortUnaligned(BYTES, 253, (short) (rawdata + sseed));\n@@ -125,2 +108,1 @@\n-            UNSAFE.putShortUnaligned(BYTES, 272, sres);\n-            data = UNSAFE.getShortUnaligned(BYTES, 272);\n+            UNSAFE.putShortUnaligned(BYTES, 272, (short) (rawdata - sseed));\n@@ -135,1 +117,1 @@\n-        private static final byte data;\n+        private static final byte bseed = 4;\n@@ -144,1 +126,0 @@\n-            bres = (byte) (bres + UNSAFE.getByte(BYTES, 272));\n@@ -146,2 +127,1 @@\n-            UNSAFE.putByte(BYTES, 53, bres);\n-            bres = (byte) (bres + UNSAFE.getByte(BYTES, 53));\n+            UNSAFE.putByte(BYTES, 53, (byte) (rawdata + bseed));\n@@ -149,2 +129,1 @@\n-            UNSAFE.putByte(BYTES, 1027, bres);\n-            data = UNSAFE.getByte(BYTES, 1027);\n+            UNSAFE.putByte(BYTES, 1027, (byte) (rawdata - bseed));\n@@ -157,1 +136,3 @@\n-        Asserts.assertEquals(ta.data, (ta.rawdata + lseed) * 2, \"putUnaligned long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLongUnaligned(ta.BYTES, 1030), ta.rawdata, \"putUnaligned long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLongUnaligned(ta.BYTES, 127), ta.rawdata + ta.lseed, \"putUnaligned long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLongUnaligned(ta.BYTES, 1096), ta.rawdata - ta.lseed, \"putUnaligned long failed!\");\n@@ -160,1 +141,3 @@\n-        Asserts.assertEquals(tb.data, (tb.rawdata + iseed) * 2, \"putUnaligned int failed!\");\n+        Asserts.assertEquals(UNSAFE.getIntUnaligned(tb.BYTES, 274), tb.rawdata, \"putUnaligned int failed!\");\n+        Asserts.assertEquals(UNSAFE.getIntUnaligned(tb.BYTES, 255), tb.rawdata + tb.iseed, \"putUnaligned int failed!\");\n+        Asserts.assertEquals(UNSAFE.getIntUnaligned(tb.BYTES, 528), tb.rawdata - tb.iseed, \"putUnaligned int failed!\");\n@@ -163,1 +146,3 @@\n-        Asserts.assertEquals(tc.data, (short) (((short) (tc.rawdata + sseed)) * 2), \"putUnaligned short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShortUnaligned(tc.BYTES, 257), tc.rawdata, \"putUnaligned short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShortUnaligned(tc.BYTES, 253), (short) (tc.rawdata + tc.sseed), \"putUnaligned short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShortUnaligned(tc.BYTES, 272), (short) (tc.rawdata - tc.sseed), \"putUnaligned short failed!\");\n@@ -166,1 +151,3 @@\n-        Asserts.assertEquals(td.data, (byte) (((byte) (td.rawdata + bseed)) * 2), \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(td.BYTES, 272), td.rawdata, \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(td.BYTES, 53), (byte) (td.rawdata + td.bseed), \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(td.BYTES, 1027), (byte) (td.rawdata - td.bseed), \"put byte failed!\");\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUnalignedAccess.java","additions":24,"deletions":37,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.gvn;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Random;\n+\n+\/**\n+ * @test\n+ * @bug 8327381\n+ * @summary Refactor boolean node tautology transformations\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.TestBoolNodeGVN\n+ *\/\n+public class TestBoolNodeGVN {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+        testCorrectness();\n+    }\n+\n+    \/**\n+     * Test changing ((x & m) u<= m) or ((m & x) u<= m) to always true, same with ((x & m) u< m+1) and ((m & x) u< m+1)\n+     * The test is only applicable to x64, aarch64 and riscv64 for having <code>Integer.compareUnsigned<\/code>\n+     * intrinsified.\n+     *\/\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase1(int x, int m) {\n+        return !(Integer.compareUnsigned((x & m), m) > 0); \/\/ assert in inversions to generates the pattern looking for\n+    }\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase2(int x, int m) {\n+        return !(Integer.compareUnsigned((m & x), m) > 0);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase3(int x, int m) {\n+        return Integer.compareUnsigned((x & m), m + 1) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase4(int x, int m) {\n+        return Integer.compareUnsigned((m & x), m + 1) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase1(int x, int m) {\n+        return !(Integer.compareUnsigned((x & m), m - 1) > 0);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase2(int x, int m) {\n+        return !(Integer.compareUnsigned((m & x), m - 1) > 0);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase3(int x, int m) {\n+        return Integer.compareUnsigned((x & m), m + 2) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase4(int x, int m) {\n+        return Integer.compareUnsigned((m & x), m + 2) < 0;\n+    }\n+\n+    private static void testCorrectness() {\n+        int[] values = {\n+                0, 1, 5, 8, 16, 42, 100, new Random().nextInt(0, Integer.MAX_VALUE), Integer.MAX_VALUE\n+        };\n+\n+        for (int x : values) {\n+            for (int m : values) {\n+                if (!testShouldReplaceCpmUCase1(x, m) |\n+                    !testShouldReplaceCpmUCase2(x, m) |\n+                    !testShouldReplaceCpmUCase3(x, m) |\n+                    !testShouldReplaceCpmUCase4(x, m)) {\n+                    throw new RuntimeException(\"Bad result for x = \" + x + \" and m = \" + m + \", expected always true\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBoolNodeGVN.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -30,1 +30,2 @@\n- * @bug 8297384\n+ * @bug 8297384 8335444\n+ * @key randomness\n@@ -41,1 +42,1 @@\n-    @Run(test = { \"test1\", \"test2\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\", \"test10\" })\n@@ -50,0 +51,4 @@\n+        assertResult(10, 20);\n+        assertResult(10, -20);\n+        assertResult(-10, 20);\n+        assertResult(-10, -20);\n@@ -51,0 +56,1 @@\n+        assertResult(b, a);\n@@ -59,0 +65,8 @@\n+        Asserts.assertEQ((a & 15) >= 0, test3(a, b));\n+        Asserts.assertEQ((a & 15) > 15, test4(a, b));\n+        Asserts.assertEQ((a & (b >>> 1)) >= 0, test5(a, b));\n+        Asserts.assertEQ((a & (b >>> 30)) > 3, test6(a, b));\n+        Asserts.assertEQ(((byte)a & -8) >= -128, test7(a, b));\n+        Asserts.assertEQ(((byte)a & -8) <= 127, test8(a, b));\n+        Asserts.assertEQ(((a & 255) & (char)b) > 255, test9(a, b));\n+        Asserts.assertEQ((((a & 1) - 3) & ((b & 2) - 10)) > -8, test10(a, b));\n@@ -77,0 +91,56 @@\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & 15 => [0, 15]\n+    public boolean test3(int a, int b) {\n+        return (a & 15) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & 15 => [0, 15]\n+    public boolean test4(int a, int b) {\n+        return (a & 15) > 15;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & [0, int_max] => [0, int_max]\n+    public boolean test5(int a, int b) {\n+        return (a & (b >>> 1)) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & [0, 3] => [0, 3]\n+    public boolean test6(int a, int b) {\n+        return (a & (b >>> 30)) > 3;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks [-128, 127] & -8 => [-128, 127]\n+    public boolean test7(int a, int b) {\n+        return ((byte)a & -8) >= -128;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks [-128, 127] & -8 => [-128, 127]\n+    public boolean test8(int a, int b) {\n+        return ((byte)a & -8) <= 127;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks that [0, 255] & [0, 65535] => [0, 255]\n+    public boolean test9(int a, int b) {\n+        return ((a & 255) & (char)b) > 255;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks that [-3, -2] & [-10, -8] => [-16, -8]\n+    public boolean test10(int a, int b) {\n+        return (((a & 1) - 3) & ((b & 2) - 10)) > -8;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AndINodeIdealizationTests.java","additions":72,"deletions":2,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * @bug 8322589\n+ * @bug 8322589 8335444\n+ * @key randomness\n@@ -41,1 +42,1 @@\n-    @Run(test = { \"test1\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\" })\n@@ -50,0 +51,4 @@\n+        assertResult(10, 20);\n+        assertResult(10, -20);\n+        assertResult(-10, 20);\n+        assertResult(-10, -20);\n@@ -51,0 +56,1 @@\n+        assertResult(b, a);\n@@ -58,0 +64,8 @@\n+        Asserts.assertEQ((a & 15) >= 0, test2(a, b));\n+        Asserts.assertEQ((a & 15) > 15, test3(a, b));\n+        Asserts.assertEQ((a & (b >>> 1)) >= 0, test4(a, b));\n+        Asserts.assertEQ((a & (b >>> 62)) > 3, test5(a, b));\n+        Asserts.assertEQ(((byte)a & -8L) >= -128, test6(a, b));\n+        Asserts.assertEQ(((byte)a & -8L) <= 127, test7(a, b));\n+        Asserts.assertEQ(((a & 255) & (char)b) > 255, test8(a, b));\n+        Asserts.assertEQ((((a & 1) - 3) & ((b & 2) - 10)) > -8, test9(a, b));\n@@ -68,0 +82,56 @@\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & 15 => [0, 15]\n+    public boolean test2(long a, long b) {\n+        return (a & 15) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & 15 => [0, 15]\n+    public boolean test3(long a, long b) {\n+        return (a & 15) > 15;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & [0, long_max] => [0, long_max]\n+    public boolean test4(long a, long b) {\n+        return (a & (b >>> 1)) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & [0, 3] => [0, 3]\n+    public boolean test5(long a, long b) {\n+        return (a & (b >>> 62)) > 3;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks [-128, 127] & -8 => [-128, 127]\n+    public boolean test6(long a, long b) {\n+        return ((byte)a & -8L) >= -128;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks [-128, 127] & -8 => [-128, 127]\n+    public boolean test7(long a, long b) {\n+        return ((byte)a & -8L) <= 127;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks that [0, 255] & [0, 65535] => [0, 255]\n+    public boolean test8(long a, long b) {\n+        return ((a & 255) & (char)b) > 255;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks that [-3, -2] & [-10, -8] => [-16, -8]\n+    public boolean test9(long a, long b) {\n+        return (((a & 1) - 3) & ((b & 2) - 10)) > -8;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AndLNodeIdealizationTests.java","additions":72,"deletions":2,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * bug 8336860\n+ * @summary Verify codegen for CMoveL with constants 0 and 1\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.CMoveLConstants\n+ *\/\n+public class CMoveLConstants {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_CMOVEL_IMM01, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    public static long testSigned(int a, int b) {\n+        return a > b ? 1L : 0L;\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_CMOVEL_IMM01U, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    public static long testUnsigned(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0 ? 1L : 0L;\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_CMOVEL_IMM01UCF, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    public static long testFloat(float a, float b) {\n+        return a > b ? 1L : 0L;\n+    }\n+\n+    @DontCompile\n+    public void assertResults(int a, int b) {\n+        Asserts.assertEQ(a > b ? 1L : 0L, testSigned(a, b));\n+        Asserts.assertEQ(Integer.compareUnsigned(a, b) > 0 ? 1L : 0L, testUnsigned(a, b));\n+        Asserts.assertEQ((float) a > (float) b ? 1L : 0L, testFloat(a, b));\n+    }\n+\n+    @Run(test = {\"testSigned\", \"testUnsigned\", \"testFloat\"})\n+    public void runMethod() {\n+        assertResults(10, 20);\n+        assertResults(20, 10);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/CMoveLConstants.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2024 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests.scalarReplacement;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8333334\n+ * @summary Tests that dead barrier control flows do not affect the scalar replacement.\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.gc.G1\n+ * @run driver compiler.c2.irTests.scalarReplacement.ScalarReplacementWithGCBarrierTests\n+ *\/\n+public class ScalarReplacementWithGCBarrierTests {\n+    static class List {\n+        public Node head;\n+\n+        public void push(int value) {\n+            Node n = new Node();\n+            n.value = value;\n+            n.next = head;\n+            head = n;\n+        }\n+\n+        @ForceInline\n+        public Iter iter() {\n+            Iter iter = new Iter();\n+            iter.list = this;\n+            iter.n = head;\n+            iter.sum = 0;\n+            return iter;\n+        }\n+    }\n+\n+    static class Node {\n+        public int value;\n+        public Node next;\n+    }\n+\n+    static class Iter {\n+        public List list;\n+        public Node n;\n+        public Integer sum;\n+\n+        @ForceInline\n+        public boolean next() {\n+            int lastSum = sum;\n+            while (sum - lastSum < 1000) {\n+                while (n != null && n.value < 30) n = n.next;\n+                if (n == null) return false;\n+                sum += n.value;\n+                n = n.next;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private static final int SIZE = 1000;\n+\n+    public static void main(String[] args) {\n+        \/\/ Must use G1 GC to ensure there is a pre-barrier\n+        \/\/ before the first field write.\n+        TestFramework.runWithFlags(\"-XX:+UseG1GC\");\n+    }\n+\n+    @Run(test = \"testScalarReplacementWithGCBarrier\")\n+    private void runner() {\n+        List list = new List();\n+        for (int i = 0; i < SIZE; i++) {\n+            list.push(i);\n+        }\n+        testScalarReplacementWithGCBarrier(list);\n+    }\n+\n+    \/\/ Allocation of `Iter iter` should be eliminated by scalar replacement, and\n+    \/\/ the allocation of `Integer sum` can not be eliminated, so there should be\n+    \/\/ 1 allocation after allocations and locks elimination.\n+    \/\/\n+    \/\/ Before the patch of JDK-8333334, both allocations of `Iter` and `Integer`\n+    \/\/ could not be eliminated.\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.ALLOC, \"1\" })\n+    @IR(phase = { CompilePhase.INCREMENTAL_BOXING_INLINE }, counts = { IRNode.ALLOC, \"2\" })\n+    @IR(phase = { CompilePhase.ITER_GVN_AFTER_ELIMINATION }, counts = { IRNode.ALLOC, \"1\" })\n+    private int testScalarReplacementWithGCBarrier(List list) {\n+        Iter iter = list.iter();\n+        while (true) {\n+            while (iter.next()) {}\n+            if (list.head == null) break;\n+            list.head = list.head.next;\n+            iter.n = list.head;\n+        }\n+        return iter.sum;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/ScalarReplacementWithGCBarrierTests.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimArrayTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimArrayTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final int[] EMPTY_INTEGER = new int[] { 0 };\n+    static final int[] FULL_INTEGER = new int[] { 42 };\n+\n+    static class Carrier {\n+        @Stable\n+        int[] field;\n+\n+        @ForceInline\n+        public Carrier(int initLevel) {\n+            switch (initLevel) {\n+                case 0:\n+                    \/\/ Do nothing.\n+                    break;\n+                case 1:\n+                    field = EMPTY_INTEGER;\n+                    break;\n+                case 2:\n+                    field = FULL_INTEGER;\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown level\");\n+            }\n+        }\n+\n+        @ForceInline\n+        public void initEmpty() {\n+            field = EMPTY_INTEGER;\n+        }\n+\n+        @ForceInline\n+        public void initFull() {\n+            field = FULL_INTEGER;\n+        }\n+\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(0);\n+    static final Carrier INIT_EMPTY_CARRIER = new Carrier(1);\n+    static final Carrier INIT_FULL_CARRIER = new Carrier(2);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        int[] is = BLANK_CARRIER.field;\n+        if (is != null) {\n+            return is[0];\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testPartialFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        int[] is = INIT_EMPTY_CARRIER.field;\n+        if (is != null) {\n+            return is[0];\n+        }\n+        return 0;\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        int[] is = INIT_FULL_CARRIER.field;\n+        if (is != null) {\n+            return is[0];\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorEmptyInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(2);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodEmptyInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_EMPTY_CARRIER.initEmpty();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodFullInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_FULL_CARRIER.initFull();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimArrayTest.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimFinalTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimFinalTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static class Carrier {\n+        @Stable\n+        final int field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            field = init ? 42 : 0;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for final fields.\n+        return BLANK_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        return INIT_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Single header+final barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Single header+final barrier.\n+        return new Carrier(true);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimFinalTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimPlainTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimPlainTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static class Carrier {\n+        @Stable\n+        int field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = 42;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = 42;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        return BLANK_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        return INIT_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodInit() {\n+        \/\/ Primitive inits have no membars.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimPlainTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimVolatileTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimVolatileTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static class Carrier {\n+        @Stable\n+        volatile int field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = 42;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = 42;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ Barriers expected for volatile fields.\n+        return BLANK_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        return INIT_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Expect only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Volatile barriers expected.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static void testMethodInit() {\n+        \/\/ Volatile barriers expected.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimVolatileTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefArrayTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefArrayTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer[] EMPTY_INTEGER = new Integer[] { null };\n+    static final Integer[] FULL_INTEGER = new Integer[] { 42 };\n+\n+    static class Carrier {\n+        @Stable\n+        Integer[] field;\n+\n+        @ForceInline\n+        public Carrier(int initLevel) {\n+            switch (initLevel) {\n+                case 0:\n+                    \/\/ Do nothing.\n+                    break;\n+                case 1:\n+                    field = EMPTY_INTEGER;\n+                    break;\n+                case 2:\n+                    field = FULL_INTEGER;\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown level\");\n+            }\n+        }\n+\n+        @ForceInline\n+        public void initEmpty() {\n+            field = EMPTY_INTEGER;\n+        }\n+\n+        @ForceInline\n+        public void initFull() {\n+            field = FULL_INTEGER;\n+        }\n+\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(0);\n+    static final Carrier INIT_EMPTY_CARRIER = new Carrier(1);\n+    static final Carrier INIT_FULL_CARRIER = new Carrier(2);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer[] is = BLANK_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testPartialFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer[] is = INIT_EMPTY_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer[] is = INIT_FULL_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorEmptyInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(2);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodEmptyInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_EMPTY_CARRIER.initEmpty();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodFullInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_FULL_CARRIER.initFull();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefArrayTest.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefFinalTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefFinalTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer INTEGER = 42;\n+\n+    static class Carrier {\n+        @Stable\n+        final Integer field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            field = init ? INTEGER : null;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer i = BLANK_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer i = INIT_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorInit() {\n+        \/\/ Only the header+final barrier.\n+        return new Carrier(true);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefFinalTest.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefPlainTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefPlainTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer INTEGER = 42;\n+\n+    static class Carrier {\n+        @Stable\n+        Integer field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = INTEGER;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = INTEGER;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer i = BLANK_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer i = INIT_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefPlainTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefVolatileTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefVolatileTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer INTEGER = 42;\n+\n+    static class Carrier {\n+        @Stable\n+        volatile Integer field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = INTEGER;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = INTEGER;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ Barriers are expected for volatile field.\n+        Integer i = BLANK_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer i = INIT_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Volatile writes, expect more barriers.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static void testMethodInit() {\n+        \/\/ Barriers are expected for volatile fields.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefVolatileTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Pass values on stack.\n+ * @requires os.arch == \"riscv64\"\n+ * @run main\/native compiler.calls.TestManyArgs\n+ *\/\n+\n+package compiler.calls;\n+\n+public class TestManyArgs {\n+    static {\n+        System.loadLibrary(\"TestManyArgs\");\n+    }\n+\n+    native static void scramblestack();\n+\n+    native static int checkargs(int arg0, short arg1, byte arg2,\n+                                int arg3, short arg4, byte arg5,\n+                                int arg6, short arg7, byte arg8,\n+                                int arg9, short arg10, byte arg11);\n+\n+    static int compiledbridge(int arg0, short arg1, byte arg2,\n+                              int arg3, short arg4, byte arg5,\n+                              int arg6, short arg7, byte arg8,\n+                              int arg9, short arg10, byte arg11) {\n+        return checkargs(arg0, arg1, arg2, arg3, arg4, arg5,\n+                         arg6, arg7, arg8, arg9, arg10, arg11);\n+    }\n+\n+    static public void main(String[] args) {\n+        scramblestack();\n+        for (int i = 0; i < 20000; i++) {\n+            int res = compiledbridge((int)0xf, (short)0xf, (byte)0xf,\n+                                     (int)0xf, (short)0xf, (byte)0xf,\n+                                     (int)0xf, (short)0xf, (byte)0xf,\n+                                     (int)0xf, (short)0xf, (byte)0xf);\n+            if (res != 0) {\n+                throw new RuntimeException(\"Test failed\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/TestManyArgs.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+\n+#ifdef riscv64\n+\/* RV64 ABI pass all integers as 64-bit, in registers or on stack\n+ * As compiler may choose to load smaller width than 64-bit if passed on stack,\n+ * this test may not find any bugs.\n+ * Therefore we trick the compiler todo 64-bit loads,\n+ * by saying these args are jlongs.\n+ *\/\n+JNIEXPORT jint JNICALL Java_compiler_calls_TestManyArgs_checkargs(JNIEnv* env, jclass jclazz,\n+                                                                  jlong arg0, jlong arg1, jlong arg2,\n+                                                                  jlong arg3, jlong arg4, jlong arg5,\n+                                                                  jlong arg6, jlong arg7, jlong arg8,\n+                                                                  jlong arg9, jlong arg10, jlong arg11)\n+#else\n+JNIEXPORT jint JNICALL Java_compiler_calls_TestManyArgs_checkargs(JNIEnv* env, jclass jclazz,\n+                                                                  jint arg0, jshort arg1, jbyte arg2,\n+                                                                  jint arg3, jshort arg4, jbyte arg5,\n+                                                                  jint arg6, jshort arg7, jbyte arg8,\n+                                                                  jint arg9, jshort arg10, jbyte arg11)\n+#endif\n+{\n+    if (arg0 != 0xf) return 1;\n+    if (arg1 != 0xf) return 1;\n+    if (arg2 != 0xf) return 1;\n+    if (arg3 != 0xf) return 1;\n+    if (arg4 != 0xf) return 1;\n+    if (arg5 != 0xf) return 1;\n+    if (arg6 != 0xf) return 1;\n+    if (arg7 != 0xf) return 1;\n+    if (arg8 != 0xf) return 1;\n+    if (arg9 != 0xf) return 1;\n+    if (arg10 != 0xf) return 1;\n+    if (arg11 != 0xf) return 1;\n+    return 0;\n+}\n+\n+JNIEXPORT\n+void JNICALL Java_compiler_calls_TestManyArgs_scramblestack(JNIEnv* env, jclass jclazz)\n+{\n+    volatile char stack[12*8];\n+    for (unsigned int i = 0; i < sizeof(stack); i++) {\n+        stack[i] = (char)0xff;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/libTestManyArgs.c","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,2 +190,11 @@\n-        \/\/ minimum size: CodeCacheMinimumUseSpace DEBUG_ONLY(* 3)\n-        long minSize = (Platform.isDebugBuild() ? 3 : 1) * minUseSpace;\n+        long nMethodSizeLimit = WHITE_BOX.getIntxVMFlag(\"NMethodSizeLimit\");\n+        long codeEntryAlignment = WHITE_BOX.getIntxVMFlag(\"CodeEntryAlignment\");\n+        long c1MinCodeCacheSize = 11 * nMethodSizeLimit \/ 10;\n+        long c2MinCodeCacheSize = 2048 \/* PhaseOutput::MAX_inst_size *\/ +\n+                                  128 \/* PhaseOutput::MAX_stubs_size *\/ +\n+                                  4 * 1024 \/* initial_const_capacity *\/ +\n+                                  2 * Math.max(64, codeEntryAlignment) \/* 2 * CodeSection::end_slop() *\/ +\n+                                  2 * 128 \/* sizeof(relocInfo) * PhaseOutput::MAX_locs_size *\/;\n+        \/\/ minimum size: CompilerConfig::min_code_cache_size =\n+        \/\/ CodeCacheMinimumUseSpace DEBUG_ONLY(* 3) + Compiler::code_buffer_size() + C2Compiler::initial_code_buffer_size())\n+        long minSize = minUseSpace * (Platform.isDebugBuild() ? 3 : 1) + c1MinCodeCacheSize + c2MinCodeCacheSize;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckSegmentedCodeCache.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-        beforeMatchingNameRegex(CMP_U, \"CmpU\");\n+        beforeMatchingNameRegex(CMP_U, \"CmpU\\\\b\");\n@@ -2236,0 +2236,15 @@\n+    public static final String X86_CMOVEL_IMM01 = PREFIX + \"X86_CMOVEL_IMM01\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_CMOVEL_IMM01, \"cmovL_imm_01\");\n+    }\n+\n+    public static final String X86_CMOVEL_IMM01U = PREFIX + \"X86_CMOVEL_IMM01U\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_CMOVEL_IMM01U, \"cmovL_imm_01U\");\n+    }\n+\n+    public static final String X86_CMOVEL_IMM01UCF = PREFIX + \"X86_CMOVEL_IMM01UCF\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_CMOVEL_IMM01UCF, \"cmovL_imm_01UCF\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+super public class LongCountedLoopInInfiniteLoop\n+{\n+  public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+  {\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+  }\n+  Method test:\"()V\"\n+    stack 3 locals 3\n+  {\n+        \/\/ #1 = 0;\n+        iconst_0;\n+        istore_1;\n+\n+    LOOPa:\n+        \/\/ if #1 >= 10: goto END\n+        iload_1;\n+        bipush    10;\n+        if_icmpge    END;\n+\n+        \/\/ if #1 > 1: goto LOOPc\n+        iload_1;\n+        iconst_1;\n+        if_icmpgt    LOOPc;\n+\n+        \/\/ #2 = 0;\n+        iconst_0;\n+        istore_2;\n+\n+    LOOPb:\n+        \/\/ if #2 > 2: goto LOOPa\n+        iload_2;\n+        iconst_2;\n+        if_icmpgt    LOOPa;\n+\n+        \/\/ #2 ++\n+        iinc    2, 1;\n+\n+        goto    LOOPb;\n+\n+    LOOPc:\n+        \/\/ #1 ++\n+        iinc    1, 1;\n+\n+        goto    LOOPa;\n+\n+    END:\n+        return;\n+    \n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/LongCountedLoopInInfiniteLoop.jasm","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+super public class MoveStoreAfterInfiniteLoop\n+{\n+  static Field a:I;\n+  static Field b:I;\n+  static Field c:S;\n+\n+  public Method \"<init>\":\"()V\"\n+\tstack 1 locals 1\n+  {\n+\t\taload_0;\n+\t\tinvokespecial\tMethod java\/lang\/Object.\"<init>\":\"()V\";\n+\t\treturn;\n+  }\n+\n+public static Method test:\"()V\"\n+    stack 3 locals 3\n+  {\n+    LTOP:\n+        iconst_0;\n+        istore_1;\n+\n+    LOUTER:\n+        iload_1;\n+        bipush    10;\n+        if_icmpge    LTOP;\n+\n+        getstatic    Field c:\"S\";\n+        putstatic    Field a:\"I\";\n+\n+        iconst_0;\n+        istore_2;\n+\n+    LINNER:\n+        iload_2;\n+        iconst_2;\n+        if_icmpge    LBOTTOM;\n+\n+        getstatic    Field b:\"I\";\n+        i2s;\n+        putstatic    Field c:\"S\";\n+\n+        iinc    2, 1;\n+\n+        goto    LINNER;\n+\n+    LBOTTOM:\n+        iinc    1, 1;\n+\n+        goto    LOUTER;\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/MoveStoreAfterInfiniteLoop.jasm","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336478\n+ * @summary C2: assert(!n->as_Loop()->is_loop_nest_inner_loop() || _loop_opts_cnt == 0) failed: should have been turned into a counted loop\n+ * @compile LongCountedLoopInInfiniteLoop.jasm\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -Xcomp -XX:PerMethodTrapLimit=0 -XX:PerMethodSpecTrapLimit=0\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:StressLongCountedLoop=2000000\n+ *                   -XX:CompileCommand=compileonly,TestLongCountedLoopInInfiniteLoop::test TestLongCountedLoopInInfiniteLoop\n+ *\/\n+\n+public class TestLongCountedLoopInInfiniteLoop {\n+    public static void main(String[] args) {\n+        LongCountedLoopInInfiniteLoop obj = new LongCountedLoopInInfiniteLoop();\n+        test(false, obj);\n+    }\n+\n+    private static void test(boolean flag, LongCountedLoopInInfiniteLoop obj) {\n+        if (flag) {\n+            obj.test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestLongCountedLoopInInfiniteLoop.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8338100\n+ * @summary C2: assert(!n_loop->is_member(get_loop(lca))) failed: control must not be back in the loop\n+ * @compile MoveStoreAfterInfiniteLoop.jasm\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestMoveStoreAfterInfiniteLoop::test\n+ *                   -XX:CompileCommand=inline,MoveStoreAfterInfiniteLoop::test TestMoveStoreAfterInfiniteLoop\n+ *\/\n+\n+public class TestMoveStoreAfterInfiniteLoop {\n+    public static void main(String[] args) {\n+        new MoveStoreAfterInfiniteLoop();\n+        test(false);\n+    }\n+\n+    private static void test(boolean flag) {\n+        if (flag) {\n+            MoveStoreAfterInfiniteLoop.test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestMoveStoreAfterInfiniteLoop.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336830\n+ * @summary C2: assert(get_loop(lca)->_nest < n_loop->_nest || lca->in(0)->is_NeverBranch()) failed: must not be moved into inner loop\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:CompileCommand=compileonly,TestSunkNodeInInfiniteLoop::* -Xcomp TestSunkNodeInInfiniteLoop\n+ *\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+\n+public class TestSunkNodeInInfiniteLoop {\n+    public static void main(String[] args) throws InterruptedException {\n+        byte[] a = new byte[1];\n+        Thread thread = new Thread(() -> test(a));\n+        thread.setDaemon(true);\n+        thread.start();\n+        Thread.sleep(Utils.adjustTimeout(4000));\n+    }\n+\n+    static void test(byte[] a) {\n+        \/\/ L0:\n+        while(true) {\n+            int i1 = a.length;\n+            \/\/ L3:\n+            while(true) {\n+                int i2 = 0;\n+                if ((i1--) <= 0) { break; \/* ifle L0 *\/}\n+                a[i2++] = -1;\n+                \/\/ goto L3\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestSunkNodeInInfiniteLoop.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-* @bug 8299259\n+* @bug 8299259 8336729\n@@ -38,1 +38,1 @@\n-* @bug 8299259\n+* @bug 8299259 8336729\n@@ -46,0 +46,22 @@\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @bug 8336729\n+ * @requires vm.compiler2.enabled\n+ * @summary Test various cases of divisions\/modulo which should not be split through iv phis.\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:LoopUnrollLimit=0 -XX:+StressGCM -XX:StressSeed=3434\n+ *                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivisionThroughPhi::*\n+ *                   compiler.splitif.TestSplitDivisionThroughPhi\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @bug 8336729\n+ * @requires vm.compiler2.enabled\n+ * @summary Test various cases of divisions\/modulo which should not be split through iv phis.\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:LoopUnrollLimit=0 -XX:+StressGCM\n+ *                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivisionThroughPhi::*\n+ *                   compiler.splitif.TestSplitDivisionThroughPhi\n+ *\/\n+\n@@ -64,0 +86,2 @@\n+            testPushDivLThruPhiForOuterLongLoop();\n+            testPushModLThruPhiForOuterLongLoop();\n@@ -81,0 +105,21 @@\n+    \/\/ Fixed with JDK-8336729.\n+    static void testPushDivLThruPhiForOuterLongLoop() {\n+        \/\/ This loop is first transformed into a LongCountedLoop in the first loop opts phase.\n+        \/\/ In the second loop opts phase, the LongCountedLoop is split into an inner and an outer loop. Both get the\n+        \/\/ same iv phi type which is [2..10]. Only the inner loop is transformed into a CountedLoopNode while the outer\n+        \/\/ loop is still a LoopNode. We run into the same problem as described in testPushDivIThruPhi() when splitting\n+        \/\/ the DivL node through the long iv phi of the outer LoopNode.\n+        \/\/ The fix for JDK-8299259 only prevents this splitting for CountedLoopNodes. We now extend it to LoopNodes\n+        \/\/ in general.\n+        for (long i = 10; i > 1; i -= 2) {\n+            lFld = 10 \/ i;\n+        }\n+    }\n+\n+    \/\/ Same as testPushDivLThruPhiForOuterLongLoop() but for ModL.\n+    static void testPushModLThruPhiForOuterLongLoop() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            iFld = 10 % i;\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/splitif\/TestSplitDivisionThroughPhi.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,3 +75,2 @@\n-    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n-        counts = {IRNode.AND_VB, \">0\"})\n-    @IR(applyIfCPUFeatureAnd = {\"avx512f\", \"false\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        phase = CompilePhase.BEFORE_MACRO_EXPANSION,\n@@ -78,2 +78,0 @@\n-    @IR(applyIfCPUFeature = {\"avx512f\", \"true\"},\n-        counts = {IRNode.MACRO_LOGIC_V, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicBooleanOpTest.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class HelloSystemd {\n+    public static void main(String args[]) {\n+        System.out.println(\"Hello Systemd\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/systemd\/HelloSystemd.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.containers.systemd.SystemdRunOptions;\n+import jdk.test.lib.containers.systemd.SystemdTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.whitebox.WhiteBox;\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @bug 8322420 8217338\n+ * @summary Memory\/CPU awareness test for JDK-under-test inside a systemd slice.\n+ * @requires systemd.support\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.platform\n+ * @build HelloSystemd jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar whitebox.jar jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:whitebox.jar -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI SystemdMemoryAwarenessTest\n+ *\/\n+public class SystemdMemoryAwarenessTest {\n+\n+    private static final int MB = 1024 * 1024;\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+    private static final String TEST_SLICE_NAME = SystemdMemoryAwarenessTest.class.getSimpleName() + \"HS\";\n+\n+    public static void main(String[] args) throws Exception {\n+       testHelloSystemd();\n+    }\n+\n+    private static void testHelloSystemd() throws Exception {\n+        SystemdRunOptions opts = SystemdTestUtils.newOpts(\"HelloSystemd\");\n+        \/\/ 1 GB memory, but the limit in the lower hierarchy is 512M\n+        opts.memoryLimit(\"1024M\");\n+        int expectedMemLimit = 512;\n+        \/\/ expected detected limit we test for, 512MB\n+        opts.sliceDMemoryLimit(String.format(\"%dM\", expectedMemLimit));\n+        int physicalCpus = wb.hostCPUs();\n+        if (physicalCpus < 2) {\n+           System.err.println(\"WARNING: host system only has \" + physicalCpus + \" cpus. Expected >= 2\");\n+           System.err.println(\"The active_processor_count assertion will trivially pass.\");\n+        }\n+        \/\/ Use a CPU core limit of 1 for best coverage\n+        int coreLimit = 1;\n+        System.out.println(\"DEBUG: Running test with a CPU limit of \" + coreLimit);\n+        opts.cpuLimit(String.format(\"%d%%\", coreLimit * 100));\n+        opts.sliceName(TEST_SLICE_NAME);\n+\n+        OutputAnalyzer out = SystemdTestUtils.buildAndRunSystemdJava(opts);\n+        out.shouldHaveExitValue(0)\n+           .shouldContain(\"Hello Systemd\")\n+           .shouldContain(String.format(\"Memory Limit is: %d\", (expectedMemLimit * MB)));\n+        try {\n+            out.shouldContain(\"OSContainer::active_processor_count: \" + coreLimit);\n+        } catch (RuntimeException e) {\n+            \/\/ CPU delegation needs to be enabled when run as user on cg v2\n+            if (SystemdTestUtils.RUN_AS_USER) {\n+                String hint = \"When run as user on cg v2 cpu delegation needs to be configured!\";\n+                throw new SkippedException(hint);\n+            }\n+            throw e;\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/systemd\/SystemdMemoryAwarenessTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -1,211 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test id=default\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ShenandoahHumongousThreshold=90 -XX:ShenandoahGCHeuristics=aggressive\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ShenandoahHumongousThreshold=90 -XX:ShenandoahGCHeuristics=aggressive\n- *                   TestHumongousThreshold\n- *\/\n-\n-\/*\n- * @test id=16b\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @requires vm.bits == \"64\"\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\/\n-\n-\/*\n- * @test id=generational\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\/\n-\n-\/*\n- * @test id=generational-16b\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @requires vm.bits == \"64\"\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\/\n-\n-import java.util.Random;\n-import jdk.test.lib.Utils;\n-\n-public class TestHumongousThreshold {\n-\n-    static final long TARGET_MB = Long.getLong(\"target\", 20_000); \/\/ 20 Gb allocation\n-\n-    static volatile Object sink;\n-\n-    public static void main(String[] args) throws Exception {\n-        final int min = 0;\n-        final int max = 384 * 1024;\n-        long count = TARGET_MB * 1024 * 1024 \/ (16 + 4 * (min + (max - min) \/ 2));\n-\n-        Random r = Utils.getRandomInstance();\n-        for (long c = 0; c < count; c++) {\n-            sink = new int[min + r.nextInt(max - min)];\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestHumongousThreshold.java","additions":0,"deletions":211,"binary":false,"changes":211,"status":"deleted"},{"patch":"@@ -147,1 +147,1 @@\n- * @run main\/othervm\/timeout=300 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=240 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSieveObjects.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test that Shenandoah humongous threshold args are checked\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver TestHumongousThresholdArgs\n- *\/\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class TestHumongousThresholdArgs {\n-    public static void main(String[] args) throws Exception {\n-        {\n-            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx128m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    \"-version\");\n-            output.shouldHaveExitValue(0);\n-        }\n-\n-        int[] valid = new int[] {1, 10, 50, 90, 100};\n-        int[] invalid = new int[] {-100, -1, 0, 101, 1000};\n-\n-        for (int v : valid) {\n-            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx128m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    \"-XX:ShenandoahHumongousThreshold=\" + v,\n-                    \"-version\");\n-            output.shouldHaveExitValue(0);\n-        }\n-\n-        for (int v : invalid) {\n-            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx128m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    \"-XX:ShenandoahHumongousThreshold=\" + v,\n-                    \"-version\");\n-            output.shouldHaveExitValue(1);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestHumongousThresholdArgs.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-    public static final int JNI_VERSION_21 = 0x00150000;\n+    public static final int JNI_VERSION_24 = 0x00180000;\n@@ -35,1 +35,1 @@\n-        if (res != JNI_VERSION_21) {\n+        if (res != JNI_VERSION_24) {\n","filename":"test\/hotspot\/jtreg\/native_sanity\/JniVersion.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- *        -mx8G\n+ *        -Xmx8G\n","filename":"test\/hotspot\/jtreg\/resourcehogs\/compiler\/intrinsics\/string\/TestStringIntrinsics2LargeArray.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,0 +73,3 @@\n+        if (Platform.isLinux()) {\n+            deprecated.add(new String[] { \"UseLinuxPosixThreadCPUClocks\", \"true\" });\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @test id=checkDecoder\n+ * @test\n@@ -33,9 +33,1 @@\n- * @run main\/native\/othervm -Xbootclasspath\/a:. -XX:-CreateCoredumpOnCrash -DcheckDecoder=true TestDwarf\n- *\/\n-\n-\/*\n- * @test id=dontCheckDecoder\n- * @library \/ \/test\/lib\n- * @requires vm.debug == true & vm.flagless & vm.compMode != \"Xint\" & os.family == \"linux\" & !vm.graal.enabled & vm.gc.G1\n- * @modules java.base\/jdk.internal.misc\n- * @run main\/native\/othervm -Xbootclasspath\/a:. -XX:-CreateCoredumpOnCrash -DcheckDecoder=false TestDwarf\n+ * @run main\/native\/othervm -Xbootclasspath\/a:. -XX:-CreateCoredumpOnCrash TestDwarf\n@@ -66,2 +58,0 @@\n-    static boolean checkDecoder = Boolean.getBoolean(\"checkDecoder\");\n-\n@@ -130,1 +120,1 @@\n-    \/\/ The full pattern accepts lines like:\n+    \/\/ A full pattern could check for lines like:\n@@ -132,1 +122,2 @@\n-    \/\/ but if the decoder is not available we only get\n+    \/\/ but the decoder is not reliably working at the moment (see JDK-8305489). We therefore use a pattern that only\n+    \/\/ checks that lines have the following structure with source information:\n@@ -134,1 +125,0 @@\n-    private static final String FULL_PATTERN =\"[CV][\\\\s\\\\t]+\\\\[([a-zA-Z0-9_.]+)\\\\+0x.+][\\\\s\\\\t]+.*\\\\+0x.+[\\\\s\\\\t]+\\\\([a-zA-Z0-9_.]+\\\\.[a-z]+:[1-9][0-9]*\\\\)\";\n@@ -152,1 +142,1 @@\n-            Pattern pattern = Pattern.compile(checkDecoder ? FULL_PATTERN : NO_DECODER_PATTERN);\n+            Pattern pattern = Pattern.compile(NO_DECODER_PATTERN);\n@@ -205,8 +195,0 @@\n-            \/\/ Symbols were fine so check if we expected decoder output and didn't find it.\n-            if (checkDecoder) {\n-                pattern = Pattern.compile(NO_DECODER_PATTERN);\n-                matcher = pattern.matcher(line);\n-                if (matcher.find()) {\n-                    Asserts.fail(\"Could not find decoded method signature in \\\"\" + line + \"\\\"\");\n-                }\n-            }\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestDwarf.java","additions":6,"deletions":24,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=NormalDeflation\n+ * @summary A collection of small tests using synchronized, wait, notify to try\n+ *          and achieve good cheap coverage of UseObjectMonitorTable.\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+UseObjectMonitorTable\n+ *                   UseObjectMonitorTableTest\n+ *\/\n+\n+\/**\n+ * @test id=ExtremeDeflation\n+ * @summary Run the same tests but with deflation running constantly.\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:GuaranteedAsyncDeflationInterval=1\n+ *                   -XX:+UseObjectMonitorTable\n+ *                   UseObjectMonitorTableTest\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+\n+import java.lang.Runnable;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.Random;\n+import java.util.stream.Stream;\n+\n+public class UseObjectMonitorTableTest {\n+    static final ThreadFactory TF = Executors.defaultThreadFactory();\n+\n+    static class WaitNotifyTest implements Runnable {\n+        static final int ITERATIONS = 10_000;\n+        static final int THREADS = 10;\n+        final WaitNotifySyncChannel startLatchChannel = new WaitNotifySyncChannel();\n+        final WaitNotifySyncChannel endLatchChannel = new WaitNotifySyncChannel();\n+        int count = 0;\n+\n+        static class WaitNotifyCountDownLatch {\n+            int latch;\n+            WaitNotifyCountDownLatch(int count) {\n+                latch = count;\n+            }\n+            synchronized void await() {\n+                while (latch != 0) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        throw new RuntimeException(\"WaitNotifyTest: Unexpected interrupt\", e);\n+                    }\n+                }\n+            }\n+            synchronized void countDown() {\n+                if (latch != 0) {\n+                    latch--;\n+                    if (latch == 0) {\n+                        notifyAll();\n+                    }\n+                }\n+            }\n+        }\n+        static class WaitNotifySyncChannel extends WaitNotifyCountDownLatch {\n+            WaitNotifyCountDownLatch object;\n+            WaitNotifySyncChannel() { super(0); }\n+            synchronized void send(WaitNotifyCountDownLatch object, int count) {\n+                await();\n+                latch = count;\n+                this.object = object;\n+                notifyAll();\n+            }\n+            synchronized WaitNotifyCountDownLatch receive() {\n+                while (latch == 0) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        throw new RuntimeException(\"WaitNotifyTest: Unexpected interrupt\", e);\n+                    }\n+                }\n+                countDown();\n+                return object;\n+            }\n+        }\n+        synchronized int getCount() {\n+            return count;\n+        }\n+        synchronized void increment() {\n+            count++;\n+        }\n+        public void run() {\n+            System.out.println(\"WaitNotifyTest started.\");\n+            for (int t = 0; t < THREADS; t++) {\n+                TF.newThread(() -> {\n+                    for (int i = 0; i < ITERATIONS; i++) {\n+                        startLatchChannel.receive().await();\n+                        increment();\n+                        endLatchChannel.receive().countDown();\n+                    }\n+                }).start();\n+            }\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                WaitNotifyCountDownLatch startLatch = new WaitNotifyCountDownLatch(1);\n+                WaitNotifyCountDownLatch endLatch = new WaitNotifyCountDownLatch(THREADS);\n+                int count = getCount();\n+                if (count != i * THREADS) {\n+                    throw new RuntimeException(\"WaitNotifyTest: Invalid Count \" + count +\n+                                               \" pre-iteration \" + i);\n+                }\n+                startLatchChannel.send(startLatch, 10);\n+                startLatch.countDown();\n+                endLatchChannel.send(endLatch, 10);\n+                endLatch.await();\n+            }\n+            int count = getCount();\n+            if (count != ITERATIONS * THREADS) {\n+                throw new RuntimeException(\"WaitNotifyTest: Invalid Count \" + count);\n+            }\n+            System.out.println(\"WaitNotifyTest passed.\");\n+        }\n+    }\n+\n+    static class RandomDepthTest implements Runnable {\n+        static final int THREADS = 10;\n+        static final int ITERATIONS = 10_000;\n+        static final int MAX_DEPTH = 20;\n+        static final int MAX_RECURSION_COUNT = 10;\n+        static final double RECURSION_CHANCE = .25;\n+        final Random random = Utils.getRandomInstance();\n+        final Locker lockers[] = new Locker[MAX_DEPTH];\n+        final CyclicBarrier syncBarrier = new CyclicBarrier(THREADS + 1);\n+        int count = 0;\n+\n+        class Locker {\n+            final int depth;\n+            Locker(int depth) {\n+                this.depth = depth;\n+            }\n+            synchronized int getCount() {\n+                if (depth == MAX_DEPTH) {\n+                    return count;\n+                }\n+                return lockers[depth].getCount();\n+            }\n+            synchronized void increment(int recursion_count) {\n+                if (recursion_count != MAX_RECURSION_COUNT &&\n+                    random.nextDouble() < RECURSION_CHANCE) {\n+                    this.increment(recursion_count + 1);\n+                    return;\n+                }\n+                if (depth == MAX_DEPTH) {\n+                    count++;\n+                    return;\n+                }\n+                lockers[depth + random.nextInt(MAX_DEPTH - depth)].increment(recursion_count);\n+            }\n+            synchronized Locker create() {\n+                if (depth != MAX_DEPTH) {\n+                    lockers[depth] = (new Locker(depth + 1)).create();\n+                }\n+                return this;\n+            }\n+        }\n+        int getCount() {\n+            return lockers[0].getCount();\n+        }\n+        void increment() {\n+            lockers[random.nextInt(MAX_DEPTH)].increment(0);\n+        }\n+        void create() {\n+            lockers[0] = (new Locker(1)).create();\n+        }\n+        void syncPoint() {\n+            try {\n+                syncBarrier.await();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"RandomDepthTest: Unexpected interrupt\", e);\n+            } catch (BrokenBarrierException e) {\n+                throw new RuntimeException(\"RandomDepthTest: Unexpected broken barrier\", e);\n+            }\n+        }\n+        public void run() {\n+            System.out.println(\"RandomDepthTest started.\");\n+            for (int t = 0; t < THREADS; t++) {\n+                TF.newThread(() -> {\n+                    syncPoint();\n+                    for (int i = 0; i < ITERATIONS; i++) {\n+                        increment();\n+                    }\n+                    syncPoint();\n+                }).start();\n+            }\n+            create();\n+            syncPoint();\n+            syncPoint();\n+            int count = getCount();\n+            if (count != THREADS * ITERATIONS) {\n+                throw new RuntimeException(\"RandomDepthTest: Invalid Count \" + count);\n+            }\n+            System.out.println(\"RandomDepthTest passed.\");\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        Stream.of(\n+            TF.newThread(new WaitNotifyTest()),\n+            TF.newThread(new RandomDepthTest())\n+        ).map(t -> {\n+            t.start();\n+            return t;\n+        }).forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"UseObjectMonitorTableTest: Unexpected interrupt\", e);\n+            }\n+        });\n+\n+        System.out.println(\"UseObjectMonitorTableTest passed.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/UseObjectMonitorTableTest.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -55,1 +55,2 @@\n-        CDSTestUtils.createArchiveAndCheck(opts);\n+        CDSTestUtils.createArchiveAndCheck(opts)\n+                    .shouldContain(\"Skipping java\/lang\/invoke\/BoundMethodHandle$Species_LLLL because it is dynamically generated\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/StaticArchiveWithLambda.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -119,2 +119,3 @@\n-                                     \"|(java.lang.OutOfMemoryError: Java heap space)\" +\n-                                     \"|(Initial heap size set to a larger value than the maximum heap size))\";\n+                                     \"|(Initial heap size set to a larger value than the maximum heap size)\" +\n+                                     \"|(java.lang.OutOfMemoryError)\" +\n+                                     \"|(Error: A JNI error has occurred, please check your installation and try again))\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestParallelGCWithCDS.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8293650\n+ * @requires vm.cds\n+ * @requires vm.bits == 64\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.gc.G1\n+ * @requires vm.gc == null\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/Hello.java\n+ * @run driver TestShenandoahWithCDS\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestShenandoahWithCDS {\n+    public final static String HELLO = \"Hello World\";\n+    static String helloJar;\n+\n+    public static void main(String... args) throws Exception {\n+        helloJar = JarBuilder.build(\"hello\", \"Hello\");\n+\n+        \/\/ Run with the variety of region sizes, and combinations\n+        \/\/ of G1\/Shenandoah at dump\/exec times. \"-1\" means to use G1.\n+        final int[] regionSizes = { -1, 256, 512, 1024, 2048 };\n+\n+        for (int dumpRegionSize : regionSizes) {\n+            for (int execRegionSize : regionSizes) {\n+                test(dumpRegionSize, execRegionSize);\n+            }\n+        }\n+    }\n+\n+    static void test(int dumpRegionSize, int execRegionSize) throws Exception {\n+        String exp = \"-XX:+UnlockExperimentalVMOptions\";\n+        String optDumpGC = (dumpRegionSize != -1) ? \"-XX:+UseShenandoahGC\" : \"-XX:+UseG1GC\";\n+        String optExecGC = (execRegionSize != -1) ? \"-XX:+UseShenandoahGC\" : \"-XX:+UseG1GC\";\n+        String optDumpRegionSize = (dumpRegionSize != -1) ? \"-XX:ShenandoahRegionSize=\" + dumpRegionSize + \"K\" : exp;\n+        String optExecRegionSize = (execRegionSize != -1) ? \"-XX:ShenandoahRegionSize=\" + execRegionSize + \"K\" : exp;\n+        OutputAnalyzer out;\n+\n+        System.out.println(\"0. Dump with \" + optDumpGC + \" and \" + optDumpRegionSize);\n+        out = TestCommon.dump(helloJar,\n+                              new String[] {\"Hello\"},\n+                              exp,\n+                              \"-Xmx1g\",\n+                              optDumpGC,\n+                              optDumpRegionSize,\n+                              \"-Xlog:cds\");\n+        out.shouldContain(\"Dumping shared data to file:\");\n+        out.shouldHaveExitValue(0);\n+\n+        System.out.println(\"1. Exec with \" + optExecGC + \" and \" + optExecRegionSize);\n+        out = TestCommon.exec(helloJar,\n+                              exp,\n+                              \"-Xmx1g\",\n+                              optExecGC,\n+                              optExecRegionSize,\n+                              \"-Xlog:cds\",\n+                              \"Hello\");\n+        out.shouldContain(HELLO);\n+        out.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestShenandoahWithCDS.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jvmti\/dumpingWithAgent\/DumpingWithJavaAgent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @requires vm.flagless\n@@ -45,1 +44,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"CondyUsesIndyBSM\");\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\"CondyUsesIndyBSM\");\n@@ -53,1 +52,1 @@\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"IndyUsesCondyBSM\");\n+        pb = ProcessTools.createTestJavaProcessBuilder(\"IndyUsesCondyBSM\");\n","filename":"test\/hotspot\/jtreg\/runtime\/condy\/BadBSMUseTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This test generates an extended NullPointerException inside a method with\n+ * a condy ldc. We add two ldc instructions and a pop around the real null\n+ * value to stress the stack handling of the NPE message generator.\n+ *\/\n+class CondyExtendedNullPointer\n+\tversion 55:0\n+{\n+\n+static Field nullObject:\"Ljava\/lang\/Object;\";\n+\n+public static Method condy:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)I\"\n+\tstack 1 locals 3\n+{\n+\t\tbipush\t123;\n+\t\tireturn;\n+}\n+\n+public static Method main:\"([Ljava\/lang\/String;)V\"\n+\tstack 3 locals 1\n+{\n+\t\tldc\tDynamic REF_invokeStatic:CondyExtendedNullPointer.condy:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)I\":I:\"I\";\n+\t\tgetstatic\tField nullObject:\"Ljava\/lang\/Object;\";\n+\t\tldc\tDynamic REF_invokeStatic:CondyExtendedNullPointer.condy:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)I\":I:\"I\";\n+\t\tpop;\n+\t\tinvokevirtual   Method java\/lang\/Object.notify:\"()V\";\n+\t\treturn;\n+}\n+\n+} \/\/ end Class CondyExtendedNullPointer\n","filename":"test\/hotspot\/jtreg\/runtime\/condy\/CondyExtendedNullPointer.jasm","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8339488\n+ * @summary Test extended NullPointerException message in method with CONSTANT_Dynamic.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @compile CondyExtendedNullPointer.jasm\n+ * @run driver CondyExtendedNullPointerTest\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class CondyExtendedNullPointerTest {\n+    public static void main(String args[]) throws Throwable {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\"-Xverify:all\",\n+                                                                             \"CondyExtendedNullPointer\");\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        oa.shouldContain(\"Cannot invoke \\\"Object.notify()\\\" because \\\"CondyExtendedNullPointer.nullObject\\\" is null\");\n+        oa.shouldHaveExitValue(1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/condy\/CondyExtendedNullPointerTest.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @requires vm.flagless\n@@ -45,1 +44,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xverify:all\",\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\"-Xverify:all\",\n@@ -53,1 +52,1 @@\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xverify:all\",\n+        pb = ProcessTools.createTestJavaProcessBuilder(\"-Xverify:all\",\n@@ -62,1 +61,1 @@\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xverify:all\",\n+        pb = ProcessTools.createTestJavaProcessBuilder(\"-Xverify:all\",\n","filename":"test\/hotspot\/jtreg\/runtime\/condy\/CondyLDCTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @requires vm.flagless\n@@ -41,1 +40,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xverify:all\",\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\"-Xverify:all\",\n","filename":"test\/hotspot\/jtreg\/runtime\/condy\/CondyNewInvokeSpecialTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @requires vm.flagless\n@@ -46,1 +45,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n","filename":"test\/hotspot\/jtreg\/runtime\/condy\/escapeAnalysis\/TestEscapeCondy.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @requires vm.flagless\n@@ -41,1 +40,1 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"Example\");\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\"Example\");\n@@ -55,1 +54,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/condy\/staticInit\/TestInitException.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8056900\n+ * @bug 8056900 8338888\n@@ -31,1 +31,1 @@\n- * @run main\/native NoClassDefFoundErrorTest\n+ * @run main\/native\/othervm -Xlog:exceptions=info NoClassDefFoundErrorTest\n@@ -39,0 +39,1 @@\n+    \/\/ Use the specified name\n@@ -41,0 +42,5 @@\n+    \/\/ Use a name longer than a Java string - returns false\n+    \/\/ if native allocation failed.\n+    static native boolean tryCallDefineClass();\n+    static native boolean tryCallFindClass();\n+\n@@ -57,1 +63,1 @@\n-        \/\/ Test JVM_DefineClass() with long name.\n+        System.out.println(\"Test JVM_DefineClass() with long name\");\n@@ -67,1 +73,1 @@\n-        \/\/ Test JNI_DefineClass() with long name.\n+        System.out.println(\"Test JNI_DefineClass() with long name\");\n@@ -77,1 +83,1 @@\n-        \/\/ Test JNI_FindClass() with long name.\n+        System.out.println(\"Test JNI_FindClass() with long name\");\n@@ -80,1 +86,1 @@\n-            throw new RuntimeException(\"DefineClass did not throw expected NoClassDefFoundError\");\n+            throw new RuntimeException(\"FindClass did not throw expected NoClassDefFoundError\");\n@@ -87,1 +93,1 @@\n-        \/\/ Test JNI_FindClass() with null name.\n+        System.out.println(\"Test JNI_FindClass() with null name\");\n@@ -96,0 +102,26 @@\n+\n+        System.out.println(\"Test JNI_DefineClass() with giant name\");\n+        try {\n+            if (tryCallDefineClass()) {\n+                throw new RuntimeException(\"DefineClass did not throw expected NoClassDefFoundError\");\n+            } else {\n+                System.out.println(\"Test skipped due to native allocation failure\");\n+            }\n+        } catch (NoClassDefFoundError e) {\n+            if (!e.getMessage().contains(\"Class name exceeds maximum length of \")) {\n+                throw new RuntimeException(\"Wrong NoClassDefFoundError: \" + e.getMessage());\n+            }\n+        }\n+\n+        System.out.println(\"Test JNI_FindClass() with giant name\");\n+        try {\n+            if (tryCallFindClass()) {\n+                throw new RuntimeException(\"FindClass did not throw expected NoClassDefFoundError\");\n+            } else {\n+                System.out.println(\"Test skipped due to native allocation failure\");\n+            }\n+        } catch (NoClassDefFoundError e) {\n+            if (!e.getMessage().contains(\"Class name exceeds maximum length of \")) {\n+                throw new RuntimeException(\"Wrong NoClassDefFoundError: \" + e.getMessage());\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/NoClassDefFoundError\/NoClassDefFoundErrorTest.java","additions":40,"deletions":8,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,4 @@\n+#include <limits.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n@@ -45,0 +49,31 @@\n+static char* giant_string() {\n+    size_t len = ((size_t)INT_MAX) + 3;\n+    char* c_name = malloc(len * sizeof(char));\n+    if (c_name != NULL) {\n+        memset(c_name, 'Y', len - 1);\n+        c_name[len - 1] = '\\0';\n+    }\n+    return c_name;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NoClassDefFoundErrorTest_tryCallDefineClass(JNIEnv *env, jclass klass) {\n+    char* c_name = giant_string();\n+    if (c_name != NULL) {\n+        (*env)->DefineClass(env, c_name, NULL, NULL, 0);\n+        free(c_name);\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NoClassDefFoundErrorTest_tryCallFindClass(JNIEnv *env, jclass klass) {\n+    char* c_name = giant_string();\n+    if (c_name != NULL) {\n+        jclass cls = (*env)->FindClass(env, c_name);\n+        free(c_name);\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/NoClassDefFoundError\/libNoClassDefFoundErrorTest.c","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class LastJsr\n+{\n+    public static Method test:\"()V\"\n+    stack 100 locals 100\n+    {\n+        return;\n+    LABEL:\n+        nop;\n+        jsr LABEL; \/\/ bci=2. Compute bci + length(jsr) -> bci = 5 accessed, out of bounds.\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/LastJsr.jasm","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class LastJsrReachable\n+{\n+    public static Method test:\"()V\"\n+    stack 100 locals 100\n+    {\n+        goto LB2;\n+    LABEL:\n+        return;\n+    LB2:\n+        nop;\n+        jsr LABEL;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/LastJsrReachable.jasm","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335664 8338924\n+ * @summary Ensure a program that ends with a JSR does not crash\n+ * @library \/test\/lib\n+ * @compile LastJsr.jasm\n+ * @compile LastJsrReachable.jasm\n+ * @run main\/othervm -Xbatch LastJsrTest\n+ *\/\n+\n+public class LastJsrTest {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 1000; ++i) {\n+            LastJsr.test();\n+            LastJsrReachable.test();\n+        }\n+        System.out.println(\"PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/LastJsrTest.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -52,0 +52,1 @@\n+                                                                 \"--enable-native-access=ALL-UNNAMED\",\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestCheckedReleaseArrayElements.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8328877\n+ * @summary Test warning for GetStringUTFLength and functionality of GetStringUTFLengthAsLong\n+ * @requires vm.bits == 64\n+ * @library \/test\/lib\n+ * @modules java.management\n+ * @run main\/native TestLargeUTF8Length launch\n+ *\/\n+\n+import java.util.Arrays;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestLargeUTF8Length {\n+\n+    static {\n+        System.loadLibrary(\"TestLargeUTF8Length\");\n+    }\n+\n+    static native void checkUTF8Length(String s, long utf8Length);\n+\n+    static void test() {\n+        int length = Integer.MAX_VALUE\/2 + 1;\n+        char character = (char)0XD1; \/\/ N with tilde\n+        long utf8Length = 2L * length;\n+        char[] chrs = new char[length];\n+        Arrays.fill(chrs, character);\n+        String s = new String(chrs);\n+        checkUTF8Length(s, utf8Length);\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        if (args == null || args.length == 0) {\n+            test();\n+            return;\n+        }\n+\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(\"-Xms9G\",\n+                                                         \"-Xmx9G\",\n+                                                         \"-Xcheck:jni\",\n+                                                         \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n+                                                         \"TestLargeUTF8Length\");\n+        String warning = \"WARNING: large String with modified UTF-8 length .*\" +\n+                         \"is reporting a reduced length of .* - use GetStringUTFLengthAsLong instead\";\n+        oa.shouldHaveExitValue(0);\n+        oa.stdoutShouldMatch(warning);\n+        oa.reportDiagnosticSummary();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestLargeUTF8Length.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+#include <limits.h>\n+#include <stdio.h>\n+\n+JNIEXPORT void JNICALL\n+Java_TestLargeUTF8Length_checkUTF8Length(JNIEnv *env, jclass clz,\n+                                         jstring str, jlong expected_length) {\n+\n+  jlong utf8_length;\n+\n+  \/\/ First get truncated length to generate warning\n+  utf8_length = (*env)->GetStringUTFLength(env, str);\n+\n+  if (utf8_length != INT_MAX - 1) {\n+    printf(\"Error: expected length of %d, but got %lld\\n\", INT_MAX - 1,\n+           (long long) utf8_length);\n+    (*env)->FatalError(env, \"Unexpected truncated length\");\n+  }\n+\n+  \/\/ Now get true length\n+  utf8_length = (*env)->GetStringUTFLengthAsLong(env, str);\n+\n+  if (utf8_length != expected_length ) {\n+    printf(\"Error: expected length of %lld, but got %lld\\n\",\n+           (long long) expected_length, (long long) utf8_length);\n+    (*env)->FatalError(env, \"Unexpected true length\");\n+  }\n+\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/libTestLargeUTF8Length.c","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -41,1 +41,1 @@\n-        output.shouldContain(\"inflate(has_locker):\");\n+        output.shouldContain(\"inflate:\");\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/MonitorInflationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,6 +91,12 @@\n-            Throwable targetException = ite.getTargetException();\n-            if (targetException instanceof OutOfMemoryError) {\n-                System.out.println(\"OutOfMemoryError thrown as expected.\");\n-                System.out.println(\"Test passed.\");\n-            } else {\n-                throw new RuntimeException(\"Unexpected InvocationTargetException: \" + targetException);\n+            \/\/ We may not directly get OOME but it could have caused\n+            \/\/ secondary exceptions, so walk the chain of exceptions\n+            \/\/ and see if there is an OOME somewhere.\n+            for (Throwable cause = ite.getTargetException();\n+                 cause != null;\n+                 cause = cause.getCause()) {\n+                if (cause instanceof OutOfMemoryError) {\n+                    System.out.println(\"OutOfMemoryError thrown as expected.\");\n+                    ite.printStackTrace(System.out);\n+                    System.out.println(\"Test passed.\");\n+                    return;\n+                }\n@@ -98,0 +104,3 @@\n+\n+            throw new RuntimeException(\"Unexpected InvocationTargetException: \",\n+                                       ite.getTargetException());\n@@ -99,1 +108,1 @@\n-            throw new RuntimeException(\"Unexpected exception: \" + exception);\n+            throw new RuntimeException(\"Unexpected exception: \", exception);\n","filename":"test\/hotspot\/jtreg\/runtime\/reflect\/ReflectOutOfMemoryError.java","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"jvmti_common.hpp\"\n@@ -38,0 +39,3 @@\n+\/\/ JVMTI_ERROR_WRONG_PHASE guard\n+static jrawMonitorID event_mon = nullptr;\n+static bool is_vm_dead = false;\n@@ -250,1 +254,1 @@\n-\/* Process a CLASS_LOAD or aClassPrepare event. *\/\n+\/* Process a CLASS_LOAD or a ClassPrepare event. *\/\n@@ -257,0 +261,5 @@\n+  RawMonitorLocker locker(jvmti, jni, event_mon);\n+  if (is_vm_dead) {\n+    return;\n+  }\n+\n@@ -259,1 +268,1 @@\n-  CHECK_JVMTI_ERROR(jni, err, \"ClassLoad event: Error in JVMTI GetClassSignature\");\n+  CHECK_JVMTI_ERROR(jni, err, \"ClassLoad\/ClassPrepare event: Error in JVMTI GetClassSignature\");\n@@ -304,0 +313,8 @@\n+static void JNICALL\n+VMDeath(jvmtiEnv *jvmti, JNIEnv* jni) {\n+  RawMonitorLocker locker(jvmti, jni, event_mon);\n+\n+  LOG0(\"VMDeath\\n\");\n+  is_vm_dead = true;\n+}\n+\n@@ -316,0 +333,7 @@\n+  err = jvmti->CreateRawMonitor(\"Event Monitor\", &event_mon);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG1(\"Agent_OnLoad: CreateRawMonitor failed: %d\\n\", err);\n+    failed = true;\n+    return JNI_ERR;\n+  }\n+\n@@ -321,0 +345,1 @@\n+  callbacks.VMDeath = &VMDeath;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HiddenClass\/libHiddenClassSigTest.cpp","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"jvmti_common.hpp\"\n@@ -29,0 +30,5 @@\n+static jvmtiEnv *jvmti = nullptr;\n+\/\/ JVMTI_ERROR_WRONG_PHASE guard\n+static jrawMonitorID event_mon = nullptr;\n+static bool is_vm_dead = false;\n+\n@@ -38,0 +44,5 @@\n+  RawMonitorLocker locker(jvmti, jni, event_mon);\n+  if (is_vm_dead) {\n+    return;\n+  }\n+\n@@ -44,1 +55,1 @@\n-  printf(\"VMObjectAlloc called for %s\\n\", signature);\n+  LOG(\"VMObjectAlloc called for %s\\n\", signature);\n@@ -51,0 +62,7 @@\n+static void JNICALL\n+VMDeath(jvmtiEnv *jvmti, JNIEnv* jni) {\n+  RawMonitorLocker locker(jvmti, jni, event_mon);\n+\n+  LOG(\"VMDeath\\n\");\n+  is_vm_dead = true;\n+}\n@@ -59,1 +77,0 @@\n-  jvmtiEnv *jvmti;\n@@ -68,0 +85,6 @@\n+  err = jvmti->CreateRawMonitor(\"Event Monitor\", &event_mon);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent_OnLoad: CreateRawMonitor failed: %d\\n\", err);\n+    return JNI_ERR;\n+  }\n+\n@@ -70,0 +93,1 @@\n+  callbacks.VMDeath = &VMDeath;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/VMObjectAlloc\/libVMObjectAlloc.cpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @modules java.base\/java.lang:+open\n+ * @modules jdk.management\n@@ -36,1 +36,1 @@\n- * @modules java.base\/java.lang:+open\n+ * @modules jdk.management\n@@ -45,1 +45,1 @@\n-import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadRunner;   \/\/ ensureParallelism requires jdk.management\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetThreadState\/GetThreadStateTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @modules java.base\/java.lang:+open\n+ * @modules jdk.management\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadEventTest\/VThreadEventTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.util.concurrent.CountDownLatch;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+\n+public class LingeredAppWithFFMUpcall extends LingeredApp {\n+\n+    public static final String THREAD_NAME = \"Upcall thread\";\n+\n+    private static final Object lockObj = new Object();\n+\n+    private static final CountDownLatch signal = new CountDownLatch(1);\n+\n+    static {\n+        System.loadLibrary(\"upcall\");\n+    }\n+\n+    public static void upcall() {\n+        signal.countDown();\n+        synchronized(lockObj) {\n+        }\n+    }\n+\n+    public static long createFunctionPointerForUpcall() throws NoSuchMethodException, IllegalAccessException {\n+        var mh = MethodHandles.lookup()\n+                              .findStatic(LingeredAppWithFFMUpcall.class, \"upcall\", MethodType.methodType(void.class));\n+        var stub = Linker.nativeLinker()\n+                         .upcallStub(mh, FunctionDescriptor.ofVoid(), Arena.global());\n+        return stub.address();\n+    }\n+\n+    public static native void callJNI(long upcallAddr);\n+\n+    public static void main(String[] args) {\n+        try {\n+            long upcallAddr = createFunctionPointerForUpcall();\n+            var upcallThread = new Thread(() -> callJNI(upcallAddr), THREAD_NAME);\n+            synchronized(lockObj) {\n+                upcallThread.start();\n+                signal.await();\n+                LingeredApp.main(args);\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/LingeredAppWithFFMUpcall.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.SA.SATestUtils;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @bug 8339307\n+ * @requires vm.hasSA\n+ * @library \/test\/lib\n+ * @run driver TestJhsdbJstackUpcall\n+ *\/\n+public class TestJhsdbJstackUpcall {\n+\n+    private static void runJstack(LingeredApp app) throws Exception {\n+        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"jhsdb\");\n+        launcher.addVMArgs(Utils.getTestJavaOpts());\n+        launcher.addToolArg(\"jstack\");\n+        launcher.addToolArg(\"--pid\");\n+        launcher.addToolArg(Long.toString(app.getPid()));\n+\n+        ProcessBuilder pb = SATestUtils.createProcessBuilder(launcher);\n+        Process jhsdb = pb.start();\n+        OutputAnalyzer out = new OutputAnalyzer(jhsdb);\n+\n+        jhsdb.waitFor();\n+\n+        System.out.println(out.getStdout());\n+        System.err.println(out.getStderr());\n+\n+        out.shouldContain(LingeredAppWithFFMUpcall.THREAD_NAME);\n+        out.shouldContain(\"LingeredAppWithFFMUpcall.upcall()\");\n+        out.shouldContain(\"jdk.internal.foreign.abi.UpcallStub\");\n+        out.shouldContain(\"LingeredAppWithFFMUpcall.callJNI\");\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        SATestUtils.skipIfCannotAttach(); \/\/ throws SkippedException if attach not expected to work.\n+        LingeredApp app = null;\n+\n+        try {\n+            \/\/ Needed for LingeredAppWithFFMUpcall to be able to resolve native library.\n+            String libPath = System.getProperty(\"java.library.path\");\n+            String[] vmArgs = (libPath != null)\n+                ? Utils.prependTestJavaOpts(\"-Djava.library.path=\" + libPath)\n+                : Utils.getTestJavaOpts();\n+\n+            app = new LingeredAppWithFFMUpcall();\n+            LingeredApp.startAppExactJvmOpts(app, vmArgs);\n+            System.out.println(\"Started LingeredAppWithFFMUpcall with pid \" + app.getPid());\n+            runJstack(app);\n+            System.out.println(\"Test Completed\");\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            throw e;\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackUpcall.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+typedef void (*upcall_func)(void);\n+\n+JNIEXPORT void JNICALL\n+Java_LingeredAppWithFFMUpcall_callJNI(JNIEnv *env, jclass cls, jlong upcallAddr) {\n+  upcall_func upcall = (upcall_func)upcallAddr;\n+  upcall();\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/libupcall.c","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,7 +26,0 @@\n-import jdk.test.lib.util.Pair;\n-import jdk.test.lib.jittester.factories.IRNodeBuilder;\n-import jdk.test.lib.jittester.types.TypeKlass;\n-import jdk.test.lib.jittester.utils.FixedTrees;\n-import jdk.test.lib.jittester.utils.OptionResolver;\n-import jdk.test.lib.jittester.utils.OptionResolver.Option;\n-import jdk.test.lib.jittester.utils.PseudoRandom;\n@@ -42,51 +35,0 @@\n-    private static Pair<IRNode, IRNode> generateIRTree(String name) {\n-        ProductionLimiter.resetTimer();\n-        SymbolTable.removeAll();\n-        TypeList.removeAll();\n-\n-        IRNodeBuilder builder = new IRNodeBuilder()\n-                .setPrefix(name)\n-                .setName(name)\n-                .setLevel(0);\n-\n-        Long complexityLimit = ProductionParams.complexityLimit.value();\n-        IRNode privateClasses = null;\n-        if (!ProductionParams.disableClasses.value()) {\n-            long privateClassComlexity = (long) (complexityLimit * PseudoRandom.random());\n-            try {\n-                privateClasses = builder.setComplexityLimit(privateClassComlexity)\n-                        .getClassDefinitionBlockFactory()\n-                        .produce();\n-            } catch (ProductionFailedException ex) {\n-                ex.printStackTrace(System.out);\n-            }\n-        }\n-        long mainClassComplexity = (long) (complexityLimit * PseudoRandom.random());\n-        IRNode mainClass = null;\n-        try {\n-            mainClass = builder.setComplexityLimit(mainClassComplexity)\n-                    .getMainKlassFactory()\n-                    .produce();\n-            TypeKlass aClass = new TypeKlass(name);\n-            mainClass.getChild(1).addChild(FixedTrees.generateMainOrExecuteMethod(aClass, true));\n-            mainClass.getChild(1).addChild(FixedTrees.generateMainOrExecuteMethod(aClass, false));\n-        } catch (ProductionFailedException ex) {\n-            ex.printStackTrace(System.out);\n-        }\n-        return new Pair<>(mainClass, privateClasses);\n-    }\n-\n-    private static void initializeTestGenerator(String[] params) {\n-        OptionResolver parser = new OptionResolver();\n-        Option<String> propertyFileOpt = parser.addStringOption('p', \"property-file\",\n-                \"conf\/default.properties\", \"File to read properties from\");\n-        ProductionParams.register(parser);\n-        parser.parse(params, propertyFileOpt);\n-        PseudoRandom.reset(ProductionParams.seed.value());\n-        TypesParser.parseTypesAndMethods(ProductionParams.classesFile.value(),\n-                ProductionParams.excludeMethodsFile.value());\n-        if (ProductionParams.specificSeed.isSet()) {\n-            PseudoRandom.setCurrentSeed(ProductionParams.specificSeed.value());\n-        }\n-    }\n-\n@@ -112,1 +54,3 @@\n-        initializeTestGenerator(args);\n+        ProductionParams.initializeFromCmdline(args);\n+        IRTreeGenerator.initializeWithProductionParams();\n+\n@@ -124,1 +68,1 @@\n-                Pair<IRNode, IRNode> irTree = generateIRTree(name);\n+                var test = IRTreeGenerator.generateIRTree(name);\n@@ -132,1 +76,1 @@\n-                        generator.accept(irTree.first, irTree.second);\n+                        generator.accept(test);\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/Automatic.java","additions":6,"deletions":62,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,4 @@\n-    public void accept(IRNode mainClass, IRNode privateClasses) {\n-        generateClassFiles(mainClass, privateClasses);\n-        generateSeparateJtregHeader(mainClass);\n+    public void accept(IRTreeGenerator.Test test) {\n+        IRNode mainClass = test.mainClass();\n+        generateClassFiles(mainClass, test.privateClasses());\n+        generateSeparateJtregHeader(test.seed(), mainClass);\n@@ -57,1 +58,1 @@\n-    private void generateSeparateJtregHeader(IRNode mainClass) {\n+    private void generateSeparateJtregHeader(long seed, IRNode mainClass) {\n@@ -59,1 +60,1 @@\n-        writeFile(generatorDir, mainClassName + \".java\", getJtregHeader(mainClassName));\n+        writeFile(generatorDir, mainClassName + \".java\", getJtregHeader(mainClassName, seed));\n@@ -97,0 +98,13 @@\n+\n+    public static void main(String[] args) throws Exception {\n+        ProductionParams.initializeFromCmdline(args);\n+        IRTreeGenerator.initializeWithProductionParams();\n+\n+        ByteCodeGenerator generator = new ByteCodeGenerator();\n+\n+        for (String mainClass : ProductionParams.mainClassNames.value()) {\n+            var test = IRTreeGenerator.generateIRTree(mainClass);\n+            generator.generateClassFiles(test.mainClass(), test.privateClasses());\n+            generator.generateSeparateJtregHeader(test.seed(), test.mainClass());\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/ByteCodeGenerator.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.jittester;\n+\n+import jdk.test.lib.jittester.factories.IRNodeBuilder;\n+import jdk.test.lib.jittester.types.TypeKlass;\n+import jdk.test.lib.jittester.utils.FixedTrees;\n+import jdk.test.lib.jittester.utils.PseudoRandom;\n+\n+\/**\n+ * Generates IR trees for fuzzy test classes.\n+ *\/\n+public class IRTreeGenerator {\n+\n+    \/**\n+     * Generated Test - main and private classes trees along with random seed used for generation.\n+     *\/\n+    public record Test (long seed, IRNode mainClass, IRNode privateClasses) {};\n+\n+    \/**\n+     * Generates IR trees for main and private classes.\n+     *\n+     * @param name main class name\n+     * @return a pair (main class; private classes)\n+     *\/\n+    public static Test generateIRTree(String name) {\n+        long seed = PseudoRandom.getCurrentSeed();\n+        ProductionLimiter.resetTimer();\n+        \/\/NB: SymbolTable is a widely-used singleton, hence all the locking.\n+        SymbolTable.removeAll();\n+        TypeList.removeAll();\n+\n+        IRNodeBuilder builder = new IRNodeBuilder()\n+                .setPrefix(name)\n+                .setName(name)\n+                .setLevel(0);\n+\n+        Long complexityLimit = ProductionParams.complexityLimit.value();\n+        IRNode privateClasses = null;\n+        if (!ProductionParams.disableClasses.value()) {\n+            long privateClassComlexity = (long) (complexityLimit * PseudoRandom.random());\n+            try {\n+                privateClasses = builder.setComplexityLimit(privateClassComlexity)\n+                        .getClassDefinitionBlockFactory()\n+                        .produce();\n+            } catch (ProductionFailedException ex) {\n+                ex.printStackTrace(System.out);\n+            }\n+        }\n+        long mainClassComplexity = (long) (complexityLimit * PseudoRandom.random());\n+        IRNode mainClass = null;\n+        try {\n+            mainClass = builder.setComplexityLimit(mainClassComplexity)\n+                    .getMainKlassFactory()\n+                    .produce();\n+            TypeKlass aClass = new TypeKlass(name);\n+            mainClass.getChild(1).addChild(FixedTrees.generateMainOrExecuteMethod(aClass, true));\n+            mainClass.getChild(1).addChild(FixedTrees.generateMainOrExecuteMethod(aClass, false));\n+        } catch (ProductionFailedException ex) {\n+            ex.printStackTrace(System.out);\n+        }\n+        return new Test(seed, mainClass, privateClasses);\n+    }\n+\n+    \/**\n+     * Initializes the generator from ProductionParams static class.\n+     *\/\n+    public static void initializeWithProductionParams() {\n+        TypesParser.parseTypesAndMethods(ProductionParams.classesFile.value(),\n+                ProductionParams.excludeMethodsFile.value());\n+        if (ProductionParams.specificSeed.isSet()) {\n+            PseudoRandom.setCurrentSeed(ProductionParams.specificSeed.value());\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/IRTreeGenerator.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -45,1 +45,2 @@\n-    public void accept(IRNode mainClass, IRNode privateClasses) {\n+    public void accept(IRTreeGenerator.Test test) {\n+        IRNode mainClass = test.mainClass();\n@@ -47,1 +48,1 @@\n-        generateSources(mainClass, privateClasses);\n+        generateSources(test.seed(), mainClass, test.privateClasses());\n@@ -53,1 +54,1 @@\n-    private void generateSources(IRNode mainClass, IRNode privateClasses) {\n+    private void generateSources(long seed, IRNode mainClass, IRNode privateClasses) {\n@@ -57,1 +58,1 @@\n-        code.append(getJtregHeader(mainClassName));\n+        code.append(getJtregHeader(mainClassName, seed));\n@@ -82,1 +83,1 @@\n-    private static String[] generatePrerunAction(String mainClassName) {\n+    protected static String[] generatePrerunAction(String mainClassName) {\n@@ -85,0 +86,12 @@\n+\n+    public static void main(String[] args) throws Exception {\n+        ProductionParams.initializeFromCmdline(args);\n+        IRTreeGenerator.initializeWithProductionParams();\n+\n+        JavaCodeGenerator generator = new JavaCodeGenerator();\n+\n+        for (String mainClass : ProductionParams.mainClassNames.value()) {\n+            var test = IRTreeGenerator.generateIRTree(mainClass);\n+            generator.generateSources(test.seed(), test.mainClass(), test.privateClasses());\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/JavaCodeGenerator.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import java.util.List;\n+\n@@ -28,0 +30,1 @@\n+import jdk.test.lib.jittester.utils.PseudoRandom;\n@@ -31,0 +34,1 @@\n+    public static Option<List<String>> mainClassNames = null;\n@@ -75,0 +79,1 @@\n+    public static Option<String> tempDir = null;\n@@ -84,0 +89,1 @@\n+        mainClassNames = optionResolver.addRepeatingOption('k', \"main-class\", \"\", \"Main class name\");\n@@ -127,0 +133,1 @@\n+        tempDir = optionResolver.addStringOption(\"temp-dir\", \".\", \"Temp dir path\");\n@@ -135,0 +142,14 @@\n+\n+    \/**\n+     * Initializes from the given command-line args\n+     *\n+     * @param args command-line arguments to use for initialization\n+     *\/\n+    public static void initializeFromCmdline(String[] args) {\n+        OptionResolver parser = new OptionResolver();\n+        Option<String> propertyFileOpt = parser.addStringOption('p', \"property-file\",\n+                \"conf\/default.properties\", \"File to read properties from\");\n+        ProductionParams.register(parser);\n+        parser.parse(args, propertyFileOpt);\n+        PseudoRandom.reset(ProductionParams.seed.value());\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/ProductionParams.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n@@ -37,1 +37,0 @@\n-import jdk.test.lib.jittester.utils.PseudoRandom;\n@@ -39,1 +38,1 @@\n-public abstract class TestsGenerator implements BiConsumer<IRNode, IRNode> {\n+public abstract class TestsGenerator implements Consumer<IRTreeGenerator.Test> {\n@@ -124,1 +123,1 @@\n-    protected String getJtregHeader(String mainClassName) {\n+    protected String getJtregHeader(String mainClassName, long seed) {\n@@ -126,1 +125,1 @@\n-                + \", specificSeed = '\" + PseudoRandom.getCurrentSeed() + \"'\";\n+                + \", specificSeed = '\" + seed + \"'\";\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/TestsGenerator.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,0 +159,6 @@\n+    public Option<List<String>> addRepeatingOption(Character key, String name, String defaultValue, String description) {\n+        final Option<List<String>> option = new RepeatingOption(key, name, defaultValue, description);\n+        register(option);\n+        return option;\n+    }\n+\n@@ -267,0 +273,14 @@\n+    private class RepeatingOption extends Option<List<String>> {\n+        List<String> accumulated = new ArrayList<String>();\n+\n+        RepeatingOption(Character s, String l, String v, String d) {\n+            super(s, l, List.of(v), d);\n+        }\n+\n+        @Override\n+        public List<String> parseFromString(String arg) {\n+            accumulated.add(arg);\n+            return accumulated;\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/utils\/OptionResolver.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- *      -XX:MaxMetaspaceSize=20m\n+ *      -XX:MaxMetaspaceSize=10m\n@@ -55,1 +55,1 @@\n- * It tries to allocate all available metespace (loads new classes and keeps\n+ * It tries to allocate all available metaspace (loads new classes and keeps\n@@ -90,1 +90,1 @@\n-        whoAmI = name;\n+        whoAmI = \"%\" + name + \"%\";\n@@ -101,1 +101,1 @@\n-        System.out.println(\"%\" + whoAmI + \"% \" + message);\n+        System.out.println(whoAmI + message);\n@@ -105,1 +105,1 @@\n-        throw new TestFault(\"%\" + whoAmI + \"% \" + message);\n+        throw new TestFault(whoAmI + message);\n@@ -109,1 +109,1 @@\n-        throw new TestFault(\"%\" + whoAmI + \"% \" + message, t);\n+        throw new TestFault(whoAmI + message, t);\n@@ -119,1 +119,1 @@\n-                System.out.println(\"Not applicalbe, Compressed Class Space is required\");\n+                System.out.println(\"Not applicable, Compressed Class Space is required\");\n@@ -124,1 +124,1 @@\n-            log(\"Bootstrapping string concatenation for \" + whoAmI );\n+            log(\"Bootstrapping string concatenation\");\n@@ -153,1 +153,11 @@\n-                throwFault(\"Hmm, we ran out metaspace. Metaspace error is still excpected here \" + error, error);\n+                throwFault(\"Hmm, we ran out metaspace. Metaspace error is still expected here \" + error, error);\n+            }\n+        } catch(BootstrapMethodError bsme) {\n+            Throwable cause = bsme.getCause();\n+            if (cause instanceof OutOfMemoryError) {\n+                OutOfMemoryError error = (OutOfMemoryError)cause;\n+                if (!isMetaspaceError(error)) {\n+                    throwFault(\"Hmm, we got BootstrapMethodError. Metaspace error is still expected as the cause \" + error, bsme);\n+                }\n+            } else {\n+                throwFault(\"We should be out of metaspace but got \" + cause, bsme);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/shrink_grow\/ShrinkGrowTest\/ShrinkGrowTest.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+            e.printStackTrace(System.out);\n@@ -173,0 +174,1 @@\n+                          e.printStackTrace(System.out);\n@@ -186,0 +188,1 @@\n+                          e.printStackTrace(System.out);\n@@ -214,0 +217,1 @@\n+            e.printStackTrace(System.out);\n@@ -217,0 +221,1 @@\n+            e.printStackTrace(System.out);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequestManager\/threadStartRequests\/thrstartreq002.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import jdk.test.lib.thread.TestThreadFactory;\n+\n@@ -61,1 +63,1 @@\n-        clrfldw001b t_b = new clrfldw001b();\n+        Thread t_b = TestThreadFactory.newThread(new clrfldw001b());\n@@ -94,1 +96,1 @@\n-class clrfldw001b extends Thread {\n+class clrfldw001b implements Runnable {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClearFieldAccessWatch\/clrfldw001.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import jdk.test.lib.thread.TestThreadFactory;\n+\n@@ -61,1 +63,1 @@\n-        clrfmodw001b t_b = new clrfmodw001b();\n+        Thread t_b = TestThreadFactory.newThread(new clrfmodw001b());\n@@ -94,1 +96,1 @@\n-class clrfmodw001b extends Thread {\n+class clrfmodw001b implements Runnable {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClearFieldModificationWatch\/clrfmodw001.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import jdk.test.lib.thread.TestThreadFactory;\n+\n@@ -65,1 +67,1 @@\n-        setfldw001b t_b = new setfldw001b();\n+        Thread t_b = TestThreadFactory.newThread(new setfldw001b());\n@@ -114,1 +116,1 @@\n-class setfldw001b extends Thread {\n+class setfldw001b implements Runnable  {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw001.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import jdk.test.lib.thread.TestThreadFactory;\n+\n@@ -65,1 +67,1 @@\n-        setfmodw001b t_b = new setfmodw001b();\n+        Thread t_b = TestThreadFactory.newThread(new setfmodw001b());\n@@ -114,1 +116,1 @@\n-class setfmodw001b extends Thread {\n+class setfmodw001b implements Runnable  {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,8 +50,0 @@\n-\n-\/*\n- * @test id=logging\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:setfmodw001 -XX:TraceJVMTI=ec+,+ioe,+s -Xlog:jvmti=trace:file=vm.%p.log nsk.jvmti.SetFieldModificationWatch.setfmodw001\n- *\/\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -668,1 +668,0 @@\n-        expectedMethods.add(\"jdk.internal.event.ThreadSleepEvent.isTurnedOn\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/share\/ThreadController.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-                \"jdk.internal.event.ThreadSleepEvent.isTurnedOn\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/share\/thread\/SleepingThread.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -154,1 +154,0 @@\n-                \"jdk.internal.event.ThreadSleepEvent.isTurnedOn\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace001.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java 8005021,8332158 macosx-all,linux-x64\n+java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java 8005021 macosx-all\n@@ -473,3 +473,0 @@\n-# This test fails on macOS 14\n-java\/awt\/Choice\/SelectNewItemTest\/SelectNewItemTest.java 8324782 macosx-all\n-\n@@ -746,0 +743,1 @@\n+jdk\/jfr\/event\/compiler\/TestCodeSweeper.java                     8338127 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+    systemd.support \\\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -265,0 +265,1 @@\n+    jdk\/management \\\n@@ -290,0 +291,1 @@\n+    jdk\/management\/VirtualThreadSchedulerMXBean \\\n","filename":"test\/jdk\/TEST.groups","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,5 @@\n+\n+            \/\/ Read the first character of output to make sure we've waited until the\n+            \/\/ debuggee is ready. This will be the debug agent's \"Listening...\" message.\n+            char firstChar = (char)is.read();\n+\n@@ -95,2 +100,2 @@\n-            System.out.println(\"Deuggee output:\");\n-            System.out.println(out.getOutput());\n+            System.out.println(\"Debuggee output:\");\n+            System.out.println(firstChar + out.getOutput());\n","filename":"test\/jdk\/com\/sun\/jdi\/DataDumpTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+import com.sun.jdi.Bootstrap;\n+import com.sun.jdi.VirtualMachine;\n+import com.sun.jdi.connect.AttachingConnector;\n+import com.sun.jdi.connect.Connector;\n+import com.sun.jdi.connect.IllegalConnectorArgumentsException;\n+\n+\/**\n+ * @test\n+ * @bug 8338708\n+ * @summary Stress test for reattaching to a debuggee\n+ * @library \/test\/lib\n+ * @modules jdk.jdi\n+ * @run driver ProcessAttachTest\n+ *\/\n+\n+class ReattachStressTestTarg {\n+    public static void main(String args[]) throws Exception {\n+        System.out.println(\"Debuggee started\");\n+        while (true) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+}\n+\n+public class ReattachStressTest {\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"Test 1: Debuggee start with suspend=n\");\n+        runTest(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n\");\n+\n+        System.out.println(\"Test 2: Debuggee start with suspend=y\");\n+        runTest(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y\");\n+    }\n+\n+    private static void runTest(String jdwpArg) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                jdwpArg,\n+                \"ReattachStressTestTarg\");\n+        Process p = null;\n+        try {\n+            p = pb.start();\n+\n+            \/\/ Read the first character of output to make sure we've waited until the\n+            \/\/ debuggee is ready. This will be the debug agent's \"Listening...\" message.\n+            InputStream is = p.getInputStream();\n+            is.read();\n+\n+            \/\/ Attach a debugger\n+            tryDebug(p.pid(), is);\n+        } finally {\n+            p.destroyForcibly();\n+        }\n+    }\n+\n+    private static void tryDebug(long pid, InputStream is) throws IOException,\n+            IllegalConnectorArgumentsException {\n+        \/\/ Get the ProcessAttachingConnector, which can attach using the pid of the debuggee.\n+        AttachingConnector ac = Bootstrap.virtualMachineManager().attachingConnectors()\n+                .stream()\n+                .filter(c -> c.name().equals(\"com.sun.jdi.ProcessAttach\"))\n+                .findFirst()\n+                .orElseThrow(() -> new RuntimeException(\"Unable to locate ProcessAttachingConnector\"));\n+\n+        \/\/ Set the connector's \"pid\" argument to the pid of the debuggee.\n+        Map<String, Connector.Argument> args = ac.defaultArguments();\n+        Connector.StringArgument arg = (Connector.StringArgument)args.get(\"pid\");\n+        arg.setValue(\"\" + pid);\n+\n+        \/\/ Loop that will repeatedly attach and detach from the same debuggee.\n+        for (int i = 0; i < 500; i++) {\n+            System.out.println(i + \": Debugger is attaching to: \" + pid + \" ...\");\n+\n+            \/\/ Attach to the debuggee.\n+            VirtualMachine vm = ac.attach(args);\n+\n+            \/\/ Drain remaining \"Listening...\" output.  Otherwise too much\n+            \/\/ output will buffer up and the debuggee may block until it is cleared.\n+            while (is.available() > 0) {\n+                is.read();\n+            }\n+\n+            \/\/ We've attached. Do some things that will send JDWP commands.\n+            System.out.println(\"Attached!\");\n+            System.out.println(\"JVM name: \" + vm.name());\n+            System.out.println(\"Num threads: \" + vm.allThreads().size());\n+\n+            \/\/ We're all done with this debugger connection.\n+            vm.dispose();\n+\n+            \/\/ Wait for first char of next \"Listening...\" output.\n+            is.read();\n+        }\n+        System.out.println(\"Debugger done.\");\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/ReattachStressTest.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,3 @@\n- * @comment Don't allow -Xcomp or -Xint as they impact memory useage and number of iterations\n- * @requires (vm.compMode == \"Xmixed\")\n+ * @comment Don't allow -Xcomp or -Xint as they impact memory useage and number of iterations.\n+ *          Require compressed oops because not doing so increases memory usage.\n+ * @requires (vm.compMode == \"Xmixed\") & vm.opt.final.UseCompressedOops\n","filename":"test\/jdk\/com\/sun\/jdi\/ThreadMemoryLeakTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+import java.io.File;\n+import java.io.IOException;\n+\n+import javax.imageio.ImageIO;\n@@ -45,2 +49,5 @@\n-    private static BufferedImage imageAfterChecked;\n-    private static volatile boolean checkmarkFound = false;\n+    private static volatile Point point;\n+    private static boolean checkmarkFound = false;\n+    private static final int TOLERANCE = 5;\n+    private static final int COLOR_CHECK_THRESHOLD = 8;\n+    private static int colorCounter = 0;\n@@ -51,0 +58,1 @@\n+\n@@ -53,1 +61,1 @@\n-                frame = new Frame(\"ComboBox checker scaling test\");\n+                frame = new Frame(\"CheckBox checker scaling test\");\n@@ -57,0 +65,1 @@\n+                frame.setLocationRelativeTo(null);\n@@ -63,9 +72,10 @@\n-            EventQueue.invokeAndWait(() -> {\n-                Point point = checkbox.getLocationOnScreen();\n-                Rectangle rect = new Rectangle(point.x + 5, point.y + 7, 8, 8);\n-                imageAfterChecked = robot.createScreenCapture(rect);\n-\n-                check: {\n-                    for (int i = 0; i < imageAfterChecked.getHeight(); i++) {\n-                        for (int j = 0; j < imageAfterChecked.getWidth(); j++) {\n-                            if (Color.black.getRGB() == imageAfterChecked.getRGB(i, j)) {\n+            EventQueue.invokeAndWait(() -> point = checkbox.getLocationOnScreen());\n+            Rectangle rect = new Rectangle(point.x + 5, point.y + 7, 8, 8);\n+            BufferedImage imageAfterChecked = robot.createScreenCapture(rect);\n+            check:\n+            {\n+                for (int i = 0; i < imageAfterChecked.getHeight(); i++) {\n+                    for (int j = 0; j < imageAfterChecked.getWidth(); j++) {\n+                        Color pixelColor = new Color(imageAfterChecked.getRGB(i, j));\n+                        if (compareColor(pixelColor)) {\n+                            if (++colorCounter >= COLOR_CHECK_THRESHOLD) {\n@@ -76,0 +86,1 @@\n+\n@@ -78,1 +89,1 @@\n-            });\n+            }\n@@ -81,0 +92,6 @@\n+                try {\n+                    ImageIO.write(imageAfterChecked, \"png\",\n+                            new File(\"imageAfterChecked.png\"));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n@@ -92,0 +109,6 @@\n+\n+    private static boolean compareColor(Color c) {\n+        return Math.abs(Color.black.getRed() - c.getRed()) < TOLERANCE &&\n+                Math.abs(Color.black.getGreen() - c.getGreen()) < TOLERANCE &&\n+                Math.abs(Color.black.getBlue() - c.getBlue()) < TOLERANCE;\n+    }\n","filename":"test\/jdk\/java\/awt\/Checkbox\/CheckboxCheckerScalingTest.java","additions":36,"deletions":13,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n-  @test\n-  @bug 4902933 8197810\n-  @summary Test that selecting the current item doesnot send an ItemEvent\n-  @key headful\n-  @run main SelectCurrentItemTest\n-*\/\n-\n-import java.awt.Choice;\n-import java.awt.Robot;\n-import java.awt.Frame;\n-import java.awt.BorderLayout;\n-import java.awt.AWTException;\n-import java.awt.Point;\n-import java.awt.Dimension;\n-import java.awt.event.InputEvent;\n-import java.awt.event.ItemListener;\n-import java.awt.event.WindowListener;\n-import java.awt.event.ItemEvent;\n-import java.awt.event.WindowEvent;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-\n-public class SelectCurrentItemTest implements ItemListener, WindowListener {\n-    \/\/Declare things used in the test, like buttons and labels here\n-    private Frame frame;\n-    private Choice theChoice;\n-    private Robot robot;\n-\n-    private CountDownLatch latch = new CountDownLatch(1);\n-    private volatile boolean passed = true;\n-\n-    private void init()\n-    {\n-        try {\n-            robot = new Robot();\n-            robot.setAutoDelay(500);\n-        } catch (AWTException e) {\n-            throw new RuntimeException(\"Unable to create Robot. Test fails.\");\n-        }\n-\n-        frame = new Frame(\"SelectCurrentItemTest\");\n-        frame.setLayout(new BorderLayout());\n-        theChoice = new Choice();\n-        for (int i = 0; i < 10; i++) {\n-            theChoice.add(new String(\"Choice Item \" + i));\n-        }\n-        theChoice.addItemListener(this);\n-        frame.add(theChoice);\n-        frame.addWindowListener(this);\n-\n-        frame.setLocation(1,20);\n-        robot.mouseMove(10, 30);\n-        frame.pack();\n-        frame.setVisible(true);\n-    }\n-\n-    public static void main(String... args) {\n-        SelectCurrentItemTest test = new SelectCurrentItemTest();\n-        test.init();\n-        try {\n-            test.latch.await(12000, TimeUnit.MILLISECONDS);\n-        } catch (InterruptedException e) {}\n-        test.robot.waitForIdle();\n-\n-        try {\n-            if (!test.passed) {\n-                throw new RuntimeException(\"TEST FAILED.\");\n-            }\n-        } finally {\n-            test.frame.dispose();\n-        }\n-    }\n-\n-    private void run() {\n-        try {Thread.sleep(1000);} catch (InterruptedException e){}\n-        \/\/ get loc of Choice on screen\n-        Point loc = theChoice.getLocationOnScreen();\n-        \/\/ get bounds of Choice\n-        Dimension size = theChoice.getSize();\n-        robot.mouseMove(loc.x + size.width - 10, loc.y + size.height \/ 2);\n-\n-        robot.setAutoDelay(250);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-\n-        robot.delay(1000);\n-\n-        robot.mouseMove(loc.x + size.width \/ 2, loc.y + size.height);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-        robot.waitForIdle();\n-        latch.countDown();\n-    }\n-\n-    @Override public void itemStateChanged(ItemEvent e) {\n-        System.out.println(\"ItemEvent received.  Test fails\");\n-        passed = false;\n-    }\n-\n-    @Override public void windowOpened(WindowEvent e) {\n-        System.out.println(\"windowActivated()\");\n-        (new Thread(this::run)).start();\n-    }\n-\n-    @Override public void windowActivated(WindowEvent e) {}\n-    @Override public void windowDeactivated(WindowEvent e) {}\n-    @Override public void windowClosed(WindowEvent e) {}\n-    @Override public void windowClosing(WindowEvent e) {}\n-    @Override public void windowIconified(WindowEvent e) {}\n-    @Override public void windowDeiconified(WindowEvent e) {}\n-}\n","filename":"test\/jdk\/java\/awt\/Choice\/SelectCurrentItemTest\/SelectCurrentItemTest.java","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.BorderLayout;\n+import java.awt.Choice;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\/*\n+ * @test\n+ * @bug 4902933 8197810\n+ * @summary Test that selecting the current item does not send an ItemEvent\n+ * @key headful\n+ * @run main SelectCurrentItemTest\n+*\/\n+public class SelectCurrentItemTest\n+        extends WindowAdapter\n+        implements ItemListener {\n+    private static Frame frame;\n+    private static Choice choice;\n+\n+    private final Robot robot;\n+\n+    private final CountDownLatch windowOpened = new CountDownLatch(1);\n+    private final CountDownLatch mouseClicked = new CountDownLatch(1);\n+\n+    protected final CountDownLatch itemStateChanged = new CountDownLatch(1);\n+\n+    protected SelectCurrentItemTest() throws AWTException {\n+        robot = new Robot();\n+        robot.setAutoDelay(250);\n+    }\n+\n+    private void createUI() {\n+        frame = new Frame(getClass().getName());\n+        frame.setLayout(new BorderLayout());\n+\n+        choice = new Choice();\n+        for (int i = 0; i < 10; i++) {\n+            choice.add(\"Choice Item \" + i);\n+        }\n+        choice.addItemListener(this);\n+        choice.addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseClicked(MouseEvent e) {\n+                System.out.println(\"mouseClicked()\");\n+                mouseClicked.countDown();\n+            }\n+        });\n+\n+        frame.add(choice, BorderLayout.CENTER);\n+\n+        frame.addWindowListener(this);\n+\n+        frame.setLocationRelativeTo(null);\n+        frame.setResizable(false);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    protected final void runTest()\n+            throws InterruptedException, InvocationTargetException {\n+        try {\n+           doTest();\n+        } finally {\n+            EventQueue.invokeAndWait(this::dispose);\n+        }\n+    }\n+\n+    private void doTest()\n+            throws InterruptedException, InvocationTargetException {\n+        EventQueue.invokeAndWait(this::createUI);\n+\n+        if (!windowOpened.await(2, TimeUnit.SECONDS)) {\n+            throw new RuntimeException(\"Frame is not open in time\");\n+        }\n+        robot.waitForIdle();\n+\n+        final int initialIndex = getSelectedIndex();\n+\n+        final Rectangle choiceRect = getChoiceRect();\n+\n+        \/\/ Open the choice popup\n+        robot.mouseMove(choiceRect.x + choiceRect.width - 10,\n+                        choiceRect.y + choiceRect.height \/ 2);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        if (!mouseClicked.await(500, TimeUnit.MILLISECONDS)) {\n+            throw new RuntimeException(\"Mouse is not clicked in time\");\n+        }\n+        robot.waitForIdle();\n+\n+        \/\/ Click an item in the choice popup\n+        final Point pt = getClickLocation(choiceRect);\n+        robot.mouseMove(pt.x, pt.y);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        robot.waitForIdle();\n+\n+        checkItemStateChanged();\n+\n+        final int currentIndex = getSelectedIndex();\n+        System.out.println(\"initialIndex = \" + initialIndex);\n+        System.out.println(\"currentIndex = \" + currentIndex);\n+        checkSelectedIndex(initialIndex, currentIndex);\n+    }\n+\n+    protected void checkItemStateChanged() throws InterruptedException {\n+        if (itemStateChanged.await(500, TimeUnit.MILLISECONDS)) {\n+            throw new RuntimeException(\"ItemEvent is received but unexpected\");\n+        }\n+    }\n+\n+    protected void checkSelectedIndex(final int initialIndex,\n+                                      final int currentIndex) {\n+        if (initialIndex != currentIndex) {\n+            throw new RuntimeException(\"Selected index in Choice should not change\");\n+        }\n+    }\n+\n+    \/**\n+     * {@return the location for clicking choice popup to select an item}\n+     * @param choiceRect the bounds of the Choice component\n+     *\/\n+    protected Point getClickLocation(final Rectangle choiceRect) {\n+        \/\/ Click on the first item in the popup, it's the selected item\n+        return new Point(choiceRect.x + choiceRect.width \/ 2,\n+                         choiceRect.y + choiceRect.height + 3);\n+    }\n+\n+    private int getSelectedIndex()\n+            throws InterruptedException, InvocationTargetException {\n+        AtomicInteger index = new AtomicInteger();\n+        EventQueue.invokeAndWait(() -> index.set(choice.getSelectedIndex()));\n+        return index.get();\n+    }\n+\n+    private Rectangle getChoiceRect()\n+            throws InterruptedException, InvocationTargetException {\n+        AtomicReference<Rectangle> rect = new AtomicReference<>();\n+        EventQueue.invokeAndWait(\n+                () -> rect.set(new Rectangle(choice.getLocationOnScreen(),\n+                                             choice.getSize())));\n+        return rect.get();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new SelectCurrentItemTest().runTest();\n+    }\n+\n+    private void dispose() {\n+        if (frame != null) {\n+            frame.dispose();\n+        }\n+    }\n+\n+    @Override\n+    public final void itemStateChanged(ItemEvent e) {\n+        System.out.println(\"itemStateChanged: \" + e);\n+        itemStateChanged.countDown();\n+    }\n+\n+    @Override\n+    public final void windowOpened(WindowEvent e) {\n+        System.out.println(\"windowActivated()\");\n+        windowOpened.countDown();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/SelectItem\/SelectCurrentItemTest.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * @test\n+ * @bug 8215921\n+ * @summary Test that selecting a different item does send an ItemEvent\n+ * @key headful\n+ * @run main SelectNewItemTest\n+*\/\n+public final class SelectNewItemTest\n+        extends SelectCurrentItemTest {\n+\n+    private SelectNewItemTest() throws AWTException {\n+        super();\n+    }\n+\n+    @Override\n+    protected void checkItemStateChanged() throws InterruptedException {\n+        if (!itemStateChanged.await(500, TimeUnit.MILLISECONDS)) {\n+            throw new RuntimeException(\"ItemEvent is not received\");\n+        }\n+    }\n+\n+    @Override\n+    protected void checkSelectedIndex(final int initialIndex,\n+                                      final int currentIndex) {\n+        if (initialIndex == currentIndex) {\n+            throw new RuntimeException(\"Selected index in Choice should've changed\");\n+        }\n+    }\n+\n+    @Override\n+    protected Point getClickLocation(final Rectangle choiceRect) {\n+        \/\/ Click a different item the popup, not the first one\n+        return new Point(choiceRect.x + choiceRect.width \/ 2,\n+                         choiceRect.y + choiceRect.height * 3);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new SelectNewItemTest().runTest();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/SelectItem\/SelectNewItemTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -1,180 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n-  @test\n-  @bug 8215921\n-  @summary Test that selecting a different item does send an ItemEvent\n-  @key headful\n-  @run main SelectNewItemTest\n-*\/\n-\n-import java.awt.Choice;\n-import java.awt.Robot;\n-import java.awt.Frame;\n-import java.awt.BorderLayout;\n-import java.awt.AWTException;\n-import java.awt.Point;\n-import java.awt.Dimension;\n-import java.awt.event.InputEvent;\n-import java.awt.event.ItemListener;\n-import java.awt.event.WindowListener;\n-import java.awt.event.ItemEvent;\n-import java.awt.event.WindowEvent;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-\n-public class SelectNewItemTest implements ItemListener, WindowListener {\n-    \/\/Declare things used in the test, like buttons and labels here\n-    private Frame frame;\n-    private Choice theChoice;\n-    private Robot robot;\n-\n-    private CountDownLatch latch = new CountDownLatch(1);\n-    private volatile boolean passed = false;\n-\n-    private void init()\n-    {\n-        try {\n-            robot = new Robot();\n-            robot.setAutoDelay(500);\n-        } catch (AWTException e) {\n-            throw new RuntimeException(\"Unable to create Robot. Test fails.\");\n-        }\n-\n-        frame = new Frame(\"SelectNewItemTest\");\n-        frame.setLayout(new BorderLayout());\n-        theChoice = new Choice();\n-        for (int i = 0; i < 10; i++) {\n-            theChoice.add(new String(\"Choice Item \" + i));\n-        }\n-        theChoice.addItemListener(this);\n-        frame.add(theChoice);\n-        frame.addWindowListener(this);\n-\n-        frame.setLocation(1,20);\n-        frame.setSize(200, 50);\n-        robot.mouseMove(10, 30);\n-        frame.pack();\n-        frame.setVisible(true);\n-    }\n-\n-    public static void main(String... args) {\n-        SelectNewItemTest test = new SelectNewItemTest();\n-        test.init();\n-        try {\n-            test.latch.await(12000, TimeUnit.MILLISECONDS);\n-        } catch (InterruptedException e) {}\n-        test.robot.waitForIdle();\n-\n-        try {\n-            if (!test.passed) {\n-                throw new RuntimeException(\"TEST FAILED.\");\n-            }\n-        } finally {\n-            test.frame.dispose();\n-        }\n-    }\n-\n-    private void run() {\n-        try {\n-            Thread.sleep(1000);\n-\n-            Point loc = theChoice.getLocationOnScreen();\n-            int selectedIndex = theChoice.getSelectedIndex();\n-            Dimension size = theChoice.getSize();\n-\n-            robot.mouseMove(loc.x + size.width - 10, loc.y + size.height \/ 2);\n-\n-            robot.setAutoDelay(250);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-\n-            robot.delay(1000);\n-\n-            \/\/make sure that the mouse moves to a different item, so that\n-            \/\/itemStateChanged is called.\n-            robot.mouseMove(loc.x + size.width \/ 2, loc.y + 3 * size.height);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.waitForIdle();\n-\n-            if (selectedIndex == theChoice.getSelectedIndex())\n-                throw new RuntimeException(\"Test case failed - expected to select\" +\n-                \" a different item than \" + selectedIndex);\n-\n-            selectedIndex = theChoice.getSelectedIndex();\n-            \/\/now click on the same item and make sure that item event is\n-            \/\/not generated.\n-            robot.delay(1000);\n-            robot.mouseMove(loc.x + size.width - 10, loc.y + size.height \/ 2);\n-\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            \/\/Make sure that the popup menu scrolls back to show the index from\n-            \/\/beginning, so that the second mouse click happens on the previously\n-            \/\/selected item.\n-            \/\/For example, on windows, it automatically scrolls the list to show\n-            \/\/the currently selected item just below the choice, which can\n-            \/\/throw off the test.\n-            if (System.getProperty(\"os.name\").toLowerCase().startsWith(\"win\")) {\n-                robot.mouseWheel(-100);\n-            }\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-\n-            robot.delay(1000);\n-            robot.mouseMove(loc.x + size.width \/ 2, loc.y + 3 * size.height);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.waitForIdle();\n-\n-            if (selectedIndex != theChoice.getSelectedIndex())\n-                throw new RuntimeException(\"Test failed. Expected to select the same item \" +\n-                \"located at: \" + selectedIndex + \" but got an item selected at: \" + theChoice.getSelectedIndex());\n-        } catch(InterruptedException e) {\n-            throw new RuntimeException(e.getCause());\n-        } finally {\n-            latch.countDown();\n-        }\n-    }\n-\n-    @Override public void itemStateChanged(ItemEvent e) {\n-        if (!passed) {\n-            System.out.println(\"ItemEvent received.  Test passes\");\n-            passed = true;\n-        } else {\n-            System.out.println(\"ItemEvent received for second click. Test fails\");\n-            passed = false;\n-        }\n-    }\n-\n-    @Override public void windowOpened(WindowEvent e) {\n-        System.out.println(\"windowActivated()\");\n-        (new Thread(this::run)).start();\n-    }\n-\n-    @Override public void windowActivated(WindowEvent e) {}\n-    @Override public void windowDeactivated(WindowEvent e) {}\n-    @Override public void windowClosed(WindowEvent e) {}\n-    @Override public void windowClosing(WindowEvent e) {}\n-    @Override public void windowIconified(WindowEvent e) {}\n-    @Override public void windowDeiconified(WindowEvent e) {}\n-}\n","filename":"test\/jdk\/java\/awt\/Choice\/SelectNewItemTest\/SelectNewItemTest.java","additions":0,"deletions":180,"binary":false,"changes":180,"status":"deleted"},{"patch":"@@ -53,1 +53,1 @@\n-    private static final int OFFSET = 2;\n+    private static final int OFFSET = 5;\n","filename":"test\/jdk\/java\/awt\/Frame\/MaximizeUndecoratedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+ * @library \/test\/lib\n+ * @build   jdk.test.lib.Platform\n@@ -33,3 +35,8 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.*;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+import jdk.test.lib.Platform;\n@@ -44,0 +51,3 @@\n+        if (Platform.isOnWayland()) {\n+            return;\n+        }\n","filename":"test\/jdk\/java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-  @run main\/othervm -mx128m OwnedWindowsLeak\n+  @run main\/othervm -Xmx128m OwnedWindowsLeak\n","filename":"test\/jdk\/java\/awt\/Window\/OwnedWindowsLeak\/OwnedWindowsLeak.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @run main\/othervm -mx32M UnloadClassBeanInfo\n+ * @run main\/othervm -Xmx32M UnloadClassBeanInfo\n","filename":"test\/jdk\/java\/beans\/Introspector\/8159696\/UnloadClassBeanInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n- * @author Sergey Malenkov\n- * @run main\/othervm -ms16m -mx16m Test5102804\n+ * @run main\/othervm -Xms16m -Xmx16m Test5102804\n","filename":"test\/jdk\/java\/beans\/Introspector\/Test5102804.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,1 @@\n- * @author Sergey Malenkov\n- * @run main\/othervm -mx16m Test8027905\n+ * @run main\/othervm -Xmx16m Test8027905\n","filename":"test\/jdk\/java\/beans\/Introspector\/Test8027905.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n- * @author Mark Davidson\n- * @run main\/othervm -ms16m -mx16m Test4646747\n+ * @run main\/othervm -Xms16m -Xmx16m Test4646747\n","filename":"test\/jdk\/java\/beans\/XMLEncoder\/Test4646747.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -122,0 +122,24 @@\n+    static final MemoryLayout A_VALUE = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"b\")\n+                    .withTargetLayout(ValueLayout.JAVA_INT)\n+    );\n+\n+    static final VarHandle a_value = A_VALUE.varHandle(\n+            PathElement.groupElement(\"b\"), PathElement.dereferenceElement());\n+\n+    @Test\n+    public void testDerefValue() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            \/\/ init structs\n+            MemorySegment a = arena.allocate(A);\n+            MemorySegment b = arena.allocate(ValueLayout.JAVA_INT);\n+            \/\/ init struct fields\n+            a.set(ValueLayout.ADDRESS, 0, b);\n+            b.set(ValueLayout.JAVA_INT, 0, 42);\n+            \/\/ dereference\n+            int val = (int) a_value.get(a, 0L);\n+            assertEquals(val, 42);\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test MemorySegment::fill\n+ * @run junit TestFill\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestFill {\n+\n+    \/\/ Make sure negative values are treated as expected\n+    private static final byte VALUE = -71;\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testFill(int len) {\n+        int offset = 16;\n+        int expandedLen = offset + MAX_SIZE + offset;\n+\n+        \/\/ Make sure fill only affects the intended region XXXXXX\n+        \/\/\n+        \/\/ ................XXXXXX................\n+        \/\/ |    offset     | len |    offset     |\n+\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(expandedLen);\n+            var slice = segment.asSlice(offset, len);\n+            slice.fill(VALUE);\n+\n+            var expected = new byte[expandedLen];\n+            Arrays.fill(expected, offset, offset + len, VALUE);\n+\n+            \/\/ This checks the actual fill region as well as potential under and overflows\n+            assertArrayEquals(expected, segment.toArray(ValueLayout.JAVA_BYTE));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"values\")\n+    void testValues(int value) {\n+        int size = 0b1111;\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(size);\n+            segment.fill((byte) value);\n+            assertTrue(segment.elements(ValueLayout.JAVA_BYTE)\n+                    .map(s -> s.get(ValueLayout.JAVA_BYTE, 0))\n+                    .allMatch(v -> v == value), \"Failed to fill with value \" + value);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testReadOnly(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(10).asReadOnly();\n+            assertThrows(IllegalArgumentException.class, () -> segment.fill(VALUE));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testConfinement(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(10);\n+            AtomicReference<RuntimeException> ex = new AtomicReference<>();\n+            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n+                try {\n+                    segment.fill(VALUE);\n+                } catch (RuntimeException e) {\n+                    ex.set(e);\n+                }\n+            });\n+            future.join();\n+            assertInstanceOf(WrongThreadException.class, ex.get());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testScope(int len) {\n+        var arena = Arena.ofConfined();\n+        var segment = arena.allocate(len);\n+        arena.close();\n+        assertThrows(IllegalStateException.class, () -> segment.fill(VALUE));\n+    }\n+\n+    private static final int MAX_SIZE = 1 << 10;\n+\n+    private static Stream<Arguments> sizes() {\n+        return IntStream.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 23, 32, 63, 128, 256, 511, MAX_SIZE)\n+                .boxed()\n+                .map(Arguments::of);\n+    }\n+\n+    private static Stream<Arguments> values() {\n+        return IntStream.rangeClosed(Byte.MIN_VALUE, Byte.MAX_VALUE)\n+                .boxed()\n+                .map(Arguments::of);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestFill.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -335,0 +335,8 @@\n+    @Test(dataProvider = \"testLayouts\", expectedExceptions = ArithmeticException.class)\n+    public void testOffsetHandleOverflow(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                         long expectedByteOffset) throws Throwable {\n+        MethodHandle byteOffsetHandle = layout.byteOffsetHandle(pathElements);\n+        byteOffsetHandle = byteOffsetHandle.asSpreader(long[].class, indexes.length);\n+        byteOffsetHandle.invoke(Long.MAX_VALUE, indexes);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.flavor != \"zero\"\n+ * @modules java.base\/jdk.internal.vm.annotation java.base\/jdk.internal.misc\n+ * @key randomness\n+ * @run testng\/othervm TestMappedHandshake\n+ * @run testng\/othervm -Xint TestMappedHandshake\n+ * @run testng\/othervm -XX:TieredStopAtLevel=1 TestMappedHandshake\n+ * @run testng\/othervm -XX:-TieredCompilation TestMappedHandshake\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestMappedHandshake {\n+\n+    static final int SEGMENT_SIZE = 1_000_000;\n+    static final int ACCESS_START_DELAY_MILLIS = 100;\n+    static final int POST_ACCESS_DELAY_MILLIS = 1;\n+    static final int TIMED_RUN_TIME_SECONDS = 10;\n+    static final int MAX_EXECUTOR_WAIT_SECONDS = 20;\n+\n+    static final int NUM_ACCESSORS = 5;\n+\n+    static final Path tempPath;\n+\n+    static {\n+        try {\n+            File file = File.createTempFile(\"buffer\", \"txt\");\n+            file.deleteOnExit();\n+            tempPath = file.toPath();\n+            Files.write(file.toPath(), new byte[SEGMENT_SIZE], StandardOpenOption.WRITE);\n+\n+        } catch (IOException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    @Test\n+    public void testHandshake() throws InterruptedException, IOException {\n+        try (FileChannel fileChannel = FileChannel.open(tempPath, StandardOpenOption.READ, StandardOpenOption.WRITE) ;\n+             Arena arena = Arena.ofShared()) {\n+            MemorySegment segment = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0L, SEGMENT_SIZE, arena);\n+            ExecutorService accessExecutor = Executors.newFixedThreadPool(NUM_ACCESSORS + 1);\n+            \/\/ start handshaker\n+            accessExecutor.execute(new Handshaker());\n+            Thread.sleep(ACCESS_START_DELAY_MILLIS);\n+            \/\/ start accessors\n+            for (int i = 0 ; i < NUM_ACCESSORS ; i++) {\n+                accessExecutor.execute(new MappedSegmentAccessor(segment));\n+            }\n+\n+            accessExecutor.shutdown();\n+            assertTrue(accessExecutor.awaitTermination(MAX_EXECUTOR_WAIT_SECONDS, TimeUnit.SECONDS));\n+        }\n+    }\n+\n+    static abstract class TimedAction implements Runnable {\n+        @Override\n+        public void run() {\n+            long start = System.currentTimeMillis();\n+            while (true) {\n+                try {\n+                    doAction();\n+                } catch (Throwable ex) {\n+                    \/\/ ignore\n+                } finally {\n+                    long elapsed = System.currentTimeMillis() - start;\n+                    if (elapsed > TIMED_RUN_TIME_SECONDS * 1000) {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        abstract void doAction() throws Throwable;\n+    }\n+\n+    static class MappedSegmentAccessor extends TimedAction {\n+\n+        final MemorySegment segment;\n+\n+        MappedSegmentAccessor(MemorySegment segment) {\n+            this.segment = segment;\n+        }\n+\n+        @Override\n+        void doAction() throws Throwable {\n+            segment.load();\n+            Thread.sleep(POST_ACCESS_DELAY_MILLIS);\n+            segment.isLoaded();\n+            Thread.sleep(POST_ACCESS_DELAY_MILLIS);\n+            segment.unload();\n+            Thread.sleep(POST_ACCESS_DELAY_MILLIS);\n+            segment.force();\n+        }\n+    }\n+\n+    static class Handshaker extends TimedAction {\n+\n+        @Override\n+        public void doAction() {\n+            Arena.ofShared().close();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMappedHandshake.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -91,1 +91,5 @@\n-            RestrictedMethod.of(ModuleLayer.Controller.class, \"enableNativeAccess\", ModuleLayer.Controller.class, Module.class)\n+            RestrictedMethod.of(ModuleLayer.Controller.class, \"enableNativeAccess\", ModuleLayer.Controller.class, Module.class),\n+            RestrictedMethod.of(System.class, \"load\", void.class, String.class),\n+            RestrictedMethod.of(System.class, \"loadLibrary\", void.class, String.class),\n+            RestrictedMethod.of(Runtime.class, \"load\", void.class, String.class),\n+            RestrictedMethod.of(Runtime.class, \"loadLibrary\", void.class, String.class)\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -79,0 +78,88 @@\n+    @Test(dataProvider = \"conjunctSegments\")\n+    public void testCopy5ArgInvariants(MemorySegment src, MemorySegment dst) {\n+        assertThrows(IndexOutOfBoundsException.class, () -> MemorySegment.copy(src, 0, dst, 0, -1));\n+        assertThrows(IndexOutOfBoundsException.class, () -> MemorySegment.copy(src, -1, dst, 0, src.byteSize()));\n+        assertThrows(IndexOutOfBoundsException.class, () -> MemorySegment.copy(src, 0, dst, -1, src.byteSize()));\n+        assertThrows(IndexOutOfBoundsException.class, () -> MemorySegment.copy(src, 1, dst, 0, src.byteSize()));\n+        assertThrows(IndexOutOfBoundsException.class, () -> MemorySegment.copy(src, 0, dst, 1, src.byteSize()));\n+    }\n+\n+    @Test(dataProvider = \"conjunctSegments\")\n+    public void testConjunctCopy7ArgRight(MemorySegment src, MemorySegment dst) {\n+        testConjunctCopy(src, 0, dst, 1, CopyOp.of7Arg());\n+    }\n+\n+    @Test(dataProvider = \"conjunctSegments\")\n+    public void testConjunctCopy5ArgRight(MemorySegment src, MemorySegment dst) {\n+        testConjunctCopy(src, 0, dst, 1, CopyOp.of5Arg());\n+    }\n+\n+    @Test(dataProvider = \"conjunctSegments\")\n+    public void testConjunctCopy7ArgLeft(MemorySegment src, MemorySegment dst) {\n+        testConjunctCopy(src, 1, dst, 0, CopyOp.of7Arg());\n+    }\n+\n+    @Test(dataProvider = \"conjunctSegments\")\n+    public void testConjunctCopy5ArgLeft(MemorySegment src, MemorySegment dst) {\n+        testConjunctCopy(src, 1, dst, 0, CopyOp.of5Arg());\n+    }\n+\n+    void testConjunctCopy(MemorySegment src, long srcOffset, MemorySegment dst, long dstOffset, CopyOp op) {\n+        if (src.byteSize() < 4 || src.address() != dst.address()) {\n+            \/\/ Only test larger segments where the skew is zero\n+            return;\n+        }\n+\n+        try (var arena = Arena.ofConfined()) {\n+            \/\/ Create a disjoint segment for expected behavior\n+            MemorySegment disjoint = arena.allocate(dst.byteSize());\n+            disjoint.copyFrom(src);\n+            op.copy(src, srcOffset, disjoint, dstOffset, 3);\n+            byte[] expected = disjoint.toArray(JAVA_BYTE);\n+\n+            \/\/ Do a conjoint copy\n+            op.copy(src, srcOffset, dst, dstOffset, 3);\n+            byte[] actual = dst.toArray(JAVA_BYTE);\n+\n+            assertEquals(actual, expected);\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    interface CopyOp {\n+        void copy(MemorySegment src, long srcOffset, MemorySegment dst, long dstOffset, long bytes);\n+\n+        static CopyOp of5Arg() {\n+            return MemorySegment::copy;\n+        }\n+\n+        static CopyOp of7Arg() {\n+            return (MemorySegment src, long srcOffset, MemorySegment dst, long dstOffset, long bytes) ->\n+                    MemorySegment.copy(src, JAVA_BYTE, srcOffset, dst, JAVA_BYTE, dstOffset, bytes);\n+        }\n+\n+    }\n+\n+    @Test(dataProvider = \"segmentKinds\")\n+    public void testByteCopySizes(SegmentKind kind1, SegmentKind kind2) {\n+\n+        record Offsets(int src, int dst){}\n+\n+        for (Offsets offsets : List.of(new Offsets(3, 7), new Offsets(7, 3))) {\n+            for (int size = 0; size < 513; size++) {\n+                MemorySegment src = kind1.makeSegment(size + offsets.src());\n+                MemorySegment dst = kind2.makeSegment(size + offsets.dst());\n+                \/\/prepare source slice\n+                for (int i = 0; i < size; i++) {\n+                    src.set(JAVA_BYTE, i + offsets.src(), (byte) i);\n+                }\n+                \/\/perform copy\n+                MemorySegment.copy(src, offsets.src(), dst, offsets.dst(), size);\n+                \/\/check that copy actually worked\n+                for (int i = 0; i < size; i++) {\n+                    assertEquals(dst.get(JAVA_BYTE, i + offsets.dst()), (byte) i);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -280,0 +367,22 @@\n+    @DataProvider\n+    static Object[][] conjunctSegments() {\n+        List<Object[]> cases = new ArrayList<>();\n+        for (SegmentKind kind : SegmentKind.values()) {\n+            \/\/ Different paths might be taken in the implementation depending on the\n+            \/\/ size, type, and address of the underlying segments.\n+            for (int len : new int[]{0, 1, 7, 512}) {\n+                for (int offset : new int[]{-1, 0, 1}) {\n+                    MemorySegment segment = kind.makeSegment(len + 2);\n+                    MemorySegment src = segment.asSlice(1 + offset, len);\n+                    MemorySegment dst = segment.asSlice(1, len);\n+                    for (int i = 0; i < len; i++) {\n+                        src.set(JAVA_BYTE, i, (byte) i);\n+                    }\n+                    \/\/ src = 0, 1, ... , len-1\n+                    cases.add(new Object[]{src, dst});\n+                }\n+            }\n+        }\n+        return cases.toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":111,"deletions":2,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+ *        panama_jni_load_module\/*\n+ *        panama_jni_def_module\/*\n+ *        panama_jni_use_module\/*\n+ *\n@@ -65,1 +69,0 @@\n-                { \"panama_enable_native_access_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--enable-native-access=ALL-UNNAMED\"} },\n@@ -70,1 +73,1 @@\n-                { \"panama_comma_separated_enable_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--enable-native-access=java.base,ALL-UNNAMED\"} },\n+                { \"panama_comma_separated_enable_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--enable-native-access=panama_jni_load_module,panama_jni_def_module,ALL-UNNAMED\"} },\n@@ -75,1 +78,6 @@\n-                { \"panama_enable_native_access_warn_jni\", PANAMA_JNI, successWithWarning(\"ALL-UNNAMED\"), new String[]{} },\n+                { \"panama_enable_native_access_warn_jni\", PANAMA_JNI, successWithWarnings(\"panama_jni_load_module\", \"panama_jni_def_module\", \"ALL-UNNAMED\"), new String[]{} },\n+\n+                { \"panama_enable_native_access_allow\", PANAMA_MAIN, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n+                { \"panama_enable_native_access_allow_reflection\", PANAMA_REFLECTION, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n+                { \"panama_enable_native_access_allow_invoke\", PANAMA_INVOKE, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n+                { \"panama_enable_native_access_allow_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n@@ -79,0 +87,1 @@\n+                { \"panama_allow_unnamed_module_native_access\", UNNAMED, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n@@ -134,1 +143,1 @@\n-        run(\"panama_enable_native_access_warn_unknown_module\", PANAMA_MAIN,\n+        run(\"panama_deny_bad_unknown_module\", PANAMA_MAIN,\n@@ -136,2 +145,2 @@\n-                \"--enable-native-access=BAD\");\n-        run(\"panama_no_all_module_path_blanket_native_access\", PANAMA_MAIN,\n+                \"--illegal-native-access=deny\", \"--enable-native-access=BAD\");\n+        run(\"panama_deny_bad_all_module_path_module\", PANAMA_MAIN,\n@@ -139,1 +148,27 @@\n-                \"--enable-native-access=ALL-MODULE-PATH\" );\n+                \"--illegal-native-access=deny\", \"--enable-native-access=ALL-MODULE-PATH\" );\n+        run(\"panama_deny_no_module_main\", PANAMA_MAIN,\n+                failWithError(\"module panama_module\"),\n+                \"--illegal-native-access=deny\");\n+        run(\"panama_deny_no_module_invoke\", PANAMA_INVOKE,\n+                failWithError(\"module panama_module\"),\n+                \"--illegal-native-access=deny\");\n+        run(\"panama_deny_no_module_reflection\", PANAMA_REFLECTION,\n+                failWithError(\"module panama_module\"),\n+                \"--illegal-native-access=deny\");\n+        run(\"panama_deny_no_module_jni\", PANAMA_JNI,\n+                failWithError(\"module panama_jni_load_module\"),\n+                \"--illegal-native-access=deny\");\n+    }\n+\n+    public void testDetailedWarningMessage() throws Exception {\n+        run(\"panama_enable_native_access_warn_jni\", PANAMA_JNI,\n+                success()\n+                        \/\/ call to System::loadLibrary from panama_jni_load_module\n+                        .expect(\"WARNING: A restricted method in java.lang.System has been called\")\n+                        .expect(\"WARNING: java.lang.System::loadLibrary has been called by org.openjdk.jni.PanamaMainJNI in module panama_jni_load_module\")\n+                        \/\/ JNI native method binding in panama_jni_def_module\n+                        .expect(\"WARNING: A native method in org.openjdk.jni.def.PanamaJNIDef has been bound\")\n+                        .expect(\"WARNING: org.openjdk.jni.def.PanamaJNIDef::nativeLinker0 is declared in module panama_jni_def_module\")\n+                        \/\/ upcall to Linker::downcallHandle from JNI code\n+                        .expect(\"WARNING: A restricted method in java.lang.foreign.Linker has been called\")\n+                        .expect(\"WARNING: java.lang.foreign.Linker::downcallHandle has been called by code in an unnamed module\"));\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccess.java","additions":42,"deletions":7,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-    static final String PANAMA_JNI_CLS = \"org.openjdk.foreigntest.PanamaMainJNI\";\n-    static final String PANAMA_JNI = \"panama_module\/\" + PANAMA_JNI_CLS;\n+    static final String PANAMA_JNI_CLS = \"org.openjdk.jni.PanamaMainJNI\";\n+    static final String PANAMA_JNI = \"panama_jni_load_module\/\" + PANAMA_JNI_CLS;\n@@ -102,0 +102,8 @@\n+    static Result successWithWarnings(String... moduleNames) {\n+        Result result = success();\n+        for (String moduleName : moduleNames) {\n+            result = result.expect(\"WARNING\").expect(\"--enable-native-access=\" + moduleName);\n+        }\n+        return result;\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessBase.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        String errMsg = \"Illegal native access from: module panama_module\";\n+        String errMsg = \"Illegal native access from module panama_module\";\n@@ -76,0 +76,1 @@\n+        list.add(\"--illegal-native-access=deny\");\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessDynamic.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module panama_jni_def_module {\n+    exports org.openjdk.jni.def;\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_def_module\/module-info.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jni.def;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+\n+public class PanamaJNIDef {\n+\n+    public static native void nativeLinker0(Linker linker, FunctionDescriptor desc, Linker.Option[] options);\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_def_module\/org\/openjdk\/jni\/def\/PanamaJNIDef.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -50,1 +50,1 @@\n-    Java_org_openjdk_foreigntest_PanamaMainJNI_nativeLinker0(JNIEnv *env, jclass cls, jobject linker, jobject desc, jobjectArray opts) {\n+    Java_org_openjdk_jni_def_PanamaJNIDef_nativeLinker0(JNIEnv *env, jclass cls, jobject linker, jobject desc, jobjectArray opts) {\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_def_module\/org\/openjdk\/jni\/def\/libLinkerInvokerModule.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/libLinkerInvokerModule.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module panama_jni_load_module {\n+    exports org.openjdk.jni;\n+    requires panama_jni_use_module;\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_load_module\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jni;\n+\n+import org.openjdk.jni.use.PanamaJNIUse;\n+\n+public class PanamaMainJNI {\n+\n+    public static void main(String[] args) {\n+        System.loadLibrary(\"LinkerInvokerModule\");\n+        PanamaJNIUse.run();\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_load_module\/org\/openjdk\/jni\/PanamaMainJNI.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module panama_jni_use_module {\n+    exports org.openjdk.jni.use;\n+    requires panama_jni_def_module;\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_use_module\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jni.use;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+\n+import org.openjdk.jni.def.PanamaJNIDef;\n+\n+public class PanamaJNIUse {\n+    public static void run() {\n+        testDirectAccessCLinker();\n+    }\n+\n+    public static void testDirectAccessCLinker() {\n+        System.out.println(\"Trying to get downcall handle\");\n+        PanamaJNIDef.nativeLinker0(Linker.nativeLinker(), FunctionDescriptor.ofVoid(), new Linker.Option[0]);\n+        System.out.println(\"Got downcall handle\");\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_use_module\/org\/openjdk\/jni\/use\/PanamaJNIUse.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -1,23 +0,0 @@\n-package org.openjdk.foreigntest;\n-\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-\n-public class PanamaMainJNI {\n-\n-    static {\n-        System.loadLibrary(\"LinkerInvokerModule\");\n-    }\n-\n-    public static void main(String[] args) {\n-        testDirectAccessCLinker();\n-    }\n-\n-    public static void testDirectAccessCLinker() {\n-        System.out.println(\"Trying to get downcall handle\");\n-        nativeLinker0(Linker.nativeLinker(), FunctionDescriptor.ofVoid(), new Linker.Option[0]);\n-        System.out.println(\"Got downcall handle\");\n-    }\n-\n-    static native void nativeLinker0(Linker linker, FunctionDescriptor desc, Linker.Option[] options);\n-}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainJNI.java","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm --enable-native-access=invoker_module\n+ * @run testng\/othervm --illegal-native-access=deny --enable-native-access=invoker_module\n","filename":"test\/jdk\/java\/foreign\/handles\/Driver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+        addDefaultMapping(Runtime.class, Runtime.getRuntime());\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,0 +74,12 @@\n+                    { MethodHandles.lookup().findStatic(System.class, \"load\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"System::load\" },\n+                    { MethodHandles.lookup().findStatic(System.class, \"loadLibrary\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"System::loadLibrary\" },\n+                    { MethodHandles.lookup().findVirtual(Runtime.class, \"load\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"Runtime::load\" },\n+                    { MethodHandles.lookup().findVirtual(Runtime.class, \"loadLibrary\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"Runtime::loadLibrary\" }\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestLargeStub\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED TestLargeStub\n@@ -31,1 +31,4 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -36,0 +39,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -38,0 +42,2 @@\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n@@ -40,0 +46,3 @@\n+    private static final int DOWNCALL_AVAILABLE_SLOTS = 248;\n+    private static final int UPCALL_AVAILABLE_SLOTS = 250;\n+\n@@ -45,2 +54,3 @@\n-    @Test\n-    public void testDowncall() {\n+    @ParameterizedTest\n+    @MethodSource(\"layouts\")\n+    public void testDowncall(ValueLayout layout, int numSlots) {\n@@ -50,1 +60,1 @@\n-                        Stream.generate(() -> C_DOUBLE).limit(124).toArray(MemoryLayout[]::new)),\n+                        Stream.generate(() -> layout).limit(DOWNCALL_AVAILABLE_SLOTS \/ numSlots).toArray(MemoryLayout[]::new)),\n@@ -65,2 +75,3 @@\n-    @Test\n-    public void testUpcall() {\n+    @ParameterizedTest\n+    @MethodSource(\"layouts\")\n+    public void testUpcall(ValueLayout layout, int numSlots) {\n@@ -70,1 +81,10 @@\n-                        Stream.generate(() -> C_DOUBLE).limit(125).toArray(MemoryLayout[]::new)));\n+                        Stream.generate(() -> layout).limit(UPCALL_AVAILABLE_SLOTS \/ numSlots).toArray(MemoryLayout[]::new)));\n+    }\n+\n+    private static Stream<Arguments> layouts() {\n+        return Stream.of(\n+            arguments(C_INT, 1),\n+            arguments(C_LONG_LONG, 2),\n+            arguments(C_FLOAT, 1),\n+            arguments(C_DOUBLE, 2)\n+        );\n","filename":"test\/jdk\/java\/foreign\/largestub\/TestLargeStub.java","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4899022\n+ * @bug 4899022 8003887\n@@ -32,0 +32,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -36,0 +38,2 @@\n+import org.junit.jupiter.api.Assumptions;\n+import org.junit.jupiter.api.BeforeAll;\n@@ -125,0 +129,84 @@\n+\n+    \/\/ Create a File with the given pathname and return the File as a Path\n+    private static Path createFile(String pathname) throws IOException {\n+        File file = new File(pathname);\n+        file.deleteOnExit();\n+        return file.toPath();\n+    }\n+\n+    private static boolean supportsLinks = true;\n+    private static String linkMessage;\n+\n+    private static Path link;\n+    private static Path sublink;\n+    private static Path subsub;\n+\n+    @BeforeAll\n+    static void createSymlinks() throws IOException {\n+        final String DIR     = \"dir\";\n+        final String SUBDIR  = \"subdir\";\n+        final String TARGET  = \"target.txt\";\n+        final String LINK    = \"link\";\n+        final String SUBLINK = \"sublink\";\n+        final String FILE    = \"file.txt\";\n+\n+        \/\/ Create directories dir\/subdir\n+        Path dir = createFile(DIR);\n+        Path subdir = createFile(dir.resolve(SUBDIR).toString());\n+        Files.createDirectories(subdir);\n+\n+        \/\/ Create file dir\/subdir\/target.txt\n+        Path target = createFile(subdir.resolve(TARGET).toString());\n+        Files.createFile(target);\n+\n+        \/\/ Create symbolic link link -> dir\n+        link = createFile(Path.of(LINK).toString());\n+        try {\n+            Files.createSymbolicLink(link, dir);\n+        } catch (UnsupportedOperationException | IOException x) {\n+            if (OS.WINDOWS.isCurrentOs()) {\n+                supportsLinks = false;\n+                linkMessage = \"\\\"\" + x.getMessage() + \"\\\"\";\n+                return;\n+            } else {\n+                throw x;\n+            }\n+        }\n+\n+        sublink = createFile(Path.of(DIR, SUBDIR, SUBLINK).toString());\n+        Path file = createFile(Path.of(DIR, SUBDIR, FILE).toString());\n+        Files.createFile(file);\n+\n+        \/\/ Create symbolic link dir\/subdir\/sublink -> file.txt\n+        Files.createSymbolicLink(sublink, Path.of(FILE));\n+        sublink.toFile().deleteOnExit();\n+\n+        subsub = createFile(Path.of(LINK, SUBDIR, SUBLINK).toString());\n+    }\n+\n+    @Test\n+    void linkToDir() throws IOException {\n+        Assumptions.assumeTrue(supportsLinks, linkMessage);\n+\n+        \/\/ Check link evaluates to dir\n+        assertEquals(link.toRealPath().toString(),\n+                     link.toFile().getCanonicalPath());\n+    }\n+\n+    @Test\n+    void linkToFile() throws IOException {\n+        Assumptions.assumeTrue(supportsLinks, linkMessage);\n+\n+        \/\/ Check sublink evaluates to file.txt\n+        assertEquals(sublink.toRealPath().toString(),\n+                     sublink.toFile().getCanonicalPath());\n+    }\n+\n+    @Test\n+    void linkToFileInSubdir() throws IOException {\n+        Assumptions.assumeTrue(supportsLinks, linkMessage);\n+\n+        \/\/ Check link\/subdir\/sublink evaluates to dir\/subdir\/file.txt\n+        assertEquals(subsub.toRealPath().toString(),\n+                     subsub.toFile().getCanonicalPath());\n+    }\n","filename":"test\/jdk\/java\/io\/File\/GetCanonicalPath.java","additions":90,"deletions":2,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.access\n+ * @summary test latin1 String countNonZeroAscii\n+ * @run main\/othervm -XX:+CompactStrings CountNonZeroAscii\n+ * @run main\/othervm -XX:-CompactStrings CountNonZeroAscii\n+ *\/\n+public class CountNonZeroAscii {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    public static void main(String [] args) {\n+        byte[] bytes = new byte[1000];\n+\n+        Arrays.fill(bytes, (byte) 'A');\n+        String s = new String(bytes, StandardCharsets.ISO_8859_1);\n+        assertEquals(bytes.length, JLA.countNonZeroAscii(s));\n+\n+        for (int i = 0; i < bytes.length; i++) {\n+            for (int j = Byte.MIN_VALUE; j <= 0; j++) {\n+                bytes[i] = (byte) j;\n+                s = new String(bytes, StandardCharsets.ISO_8859_1);\n+                assertEquals(i, JLA.countNonZeroAscii(s));\n+            }\n+            bytes[i] = (byte) 'A';\n+        }\n+    }\n+\n+    static void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected \" + expected + \" but got \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/CountNonZeroAscii.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.StringBuilder;\n+\n+import java.lang.invoke.*;\n+import java.lang.management.ManagementFactory;\n+\n+\/**\n+ * @test\n+ * @summary Test whether the hidden class unloading of StringConcatFactory works\n+ *\n+ * @requires vm.flagless\n+ * @run main\/othervm -Xmx8M -Xms8M -Xverify:all HiddenClassUnloading\n+ * @run main\/othervm -Xmx8M -Xms8M -Xverify:all -XX:-CompactStrings HiddenClassUnloading\n+ *\/\n+public class HiddenClassUnloading {\n+    public static void main(String[] args) throws Throwable {\n+        var lookup = MethodHandles.lookup();\n+        var types  = new Class<?>[] {\n+                int.class, long.class, double.class, float.class, char.class, boolean.class, String.class,\n+        };\n+\n+        long initUnloadedClassCount = ManagementFactory.getClassLoadingMXBean().getUnloadedClassCount();\n+\n+        for (int i = 0; i < 12000; i++) {\n+            int radix = types.length;\n+            String str = Integer.toString(i, radix);\n+            int length = str.length();\n+            var ptypes = new Class[length];\n+            for (int j = 0; j < length; j++) {\n+                int index = Integer.parseInt(str.substring(j, j + 1), radix);\n+                ptypes[j] = types[index];\n+            }\n+            StringConcatFactory.makeConcatWithConstants(\n+                    lookup,\n+                    \"concat\",\n+                    MethodType.methodType(String.class, ptypes),\n+                    \"\\1\".repeat(length), \/\/ recipe\n+                    new Object[0]\n+            );\n+        }\n+\n+        long unloadedClassCount = ManagementFactory.getClassLoadingMXBean().getUnloadedClassCount();\n+        if (initUnloadedClassCount == unloadedClassCount) {\n+            throw new RuntimeException(\"unloadedClassCount is zero\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/concat\/HiddenClassUnloading.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @bug 8335362\n+ * @summary Test virtual thread usage with big stackChunks\n+ * @requires vm.continuations\n+ * @run junit\/othervm BigStackChunk\n+ *\/\n+\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class BigStackChunk {\n+\n+    void recurse(int cnt, ReentrantLock rlock) {\n+        int i1 = cnt;\n+        int i2 = i1 + 1;\n+        int i3 = i2 + 1;\n+        int i4 = i3 + 1;\n+        int i5 = i4 + 1;\n+        int i6 = i5 + 1;\n+        int i7 = i6 + 1;\n+        long ll = 2 * (long)i1;\n+        float ff = ll + 1.2f;\n+        double dd = ff + 1.3D;\n+\n+        if (cnt > 0) {\n+            recurse(cnt - 1, rlock);\n+        } else {\n+            rlock.lock();\n+            rlock.unlock();\n+        }\n+    }\n+\n+    @Test\n+    void bigStackChunkTest() throws Exception {\n+        int VTHREAD_CNT = Runtime.getRuntime().availableProcessors();\n+        ReentrantLock rlock = new ReentrantLock();\n+        Thread[] vthreads = new Thread[VTHREAD_CNT];\n+\n+        rlock.lock();\n+        for (int i = 0; i < VTHREAD_CNT; i++) {\n+            vthreads[i] = Thread.ofVirtual().start(() -> {\n+                \/\/ Set up things so that half of the carriers will commit lots of\n+                \/\/ pages in the stack while running the mounted vthread and half\n+                \/\/ will just commit very few ones.\n+                if (Math.random() < 0.5) {\n+                    recurse(300, rlock);\n+                } else {\n+                    recurse(1, rlock);\n+                }\n+            });\n+        }\n+        await(vthreads[0], Thread.State.WAITING);\n+        \/\/ Now we expect that some vthread that recursed a lot is mounted on\n+        \/\/ a carrier that previously run a vthread that didn't recurse at all.\n+        rlock.unlock();\n+\n+        for (int i = 0; i < VTHREAD_CNT; i++) {\n+            vthreads[i].join();\n+        }\n+    }\n+\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n+        Thread.State state = thread.getState();\n+        while (state != expectedState) {\n+            assertTrue(state != Thread.State.TERMINATED, \"Thread has terminated\");\n+            Thread.sleep(10);\n+            state = thread.getState();\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/BigStackChunk.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @modules jdk.jfr java.base\/java.lang:+open\n+ * @modules jdk.jfr java.base\/java.lang:+open jdk.management\n@@ -53,1 +53,1 @@\n-import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadRunner;   \/\/ ensureParallelism requires jdk.management\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/JfrEvents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @modules java.base\/java.lang:+open\n+ * @modules java.base\/java.lang:+open jdk.management\n@@ -46,1 +46,1 @@\n-import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadRunner;   \/\/ ensureParallelism requires jdk.management\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorEnterExit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @modules java.base\/java.lang:+open\n+ * @modules java.base\/java.lang:+open jdk.management\n@@ -49,2 +49,1 @@\n-import jdk.test.lib.thread.VThreadRunner;\n-import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadRunner;   \/\/ ensureParallelism requires jdk.management\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorWaitNotify.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @modules java.base\/java.lang:+open\n+ * @modules java.base\/java.lang:+open jdk.management\n@@ -36,1 +36,1 @@\n- * @modules java.base\/java.lang:+open\n+ * @modules java.base\/java.lang:+open jdk.management\n@@ -65,1 +65,1 @@\n-import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadRunner;   \/\/ ensureParallelism requires jdk.management\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @modules java.base\/java.lang:+open java.base\/jdk.internal.event\n+ * @modules java.base\/java.lang:+open java.base\/jdk.internal.event jdk.management\n@@ -39,1 +39,1 @@\n-import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadRunner;   \/\/ ensureParallelism requires jdk.management\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/VirtualThreadPinnedEventThrows.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @modules java.base\/java.lang:+open\n+ * @modules jdk.management\n@@ -37,1 +37,1 @@\n- * @modules java.base\/java.lang:+open\n+ * @modules jdk.management\n@@ -45,1 +45,1 @@\n-import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadRunner;   \/\/ ensureParallelism requires jdk.management\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenBlocking.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @modules java.base\/java.lang:+open\n+ * @modules jdk.management\n@@ -37,1 +37,1 @@\n- * @modules java.base\/java.lang:+open\n+ * @modules jdk.management\n@@ -45,1 +45,1 @@\n-import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadRunner;   \/\/ ensureParallelism requires jdk.management\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenPinned.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-       int ret = ConstantUtils.skipOverFieldSignature(\"(V)V\", 1, 4, false);\n+       int ret = ConstantUtils.skipOverFieldSignature(\"(V)V\", 1, 4);\n","filename":"test\/jdk\/java\/lang\/constant\/boottest\/java.base\/jdk\/internal\/constant\/ConstantUtilsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import java.nio.file.FileStore;\n@@ -50,0 +51,1 @@\n+import org.testng.SkipException;\n@@ -210,2 +212,7 @@\n-        if (!Files.getFileStore(Paths.get(\".\"))\n-                  .supportsFileAttributeView(PosixFileAttributeView.class)) {\n+        FileStore fs;\n+        try {\n+            fs = Files.getFileStore(Paths.get(\".\"));\n+        } catch (IOException e) {\n+            throw new SkipException(\"WARNING: IOException occurred: \" + e + \", Skipping testDumpDirNotWritable test.\");\n+        }\n+        if (!fs.supportsFileAttributeView(PosixFileAttributeView.class)) {\n@@ -213,6 +220,1 @@\n-            \/\/ We would like to skip the test with a cause with\n-            \/\/     throw new SkipException(\"Posix not supported\");\n-            \/\/ but jtreg will report failure so we just pass the test\n-            \/\/ which we can look at if jtreg changed its behavior\n-            System.out.println(\"WARNING: POSIX is not supported. Skipping testDumpDirNotWritable test.\");\n-            return;\n+            throw new SkipException(\"WARNING: POSIX is not supported. Skipping testDumpDirNotWritable test.\");\n@@ -230,2 +232,1 @@\n-                System.out.println(\"WARNING: The dump directory is writeable. Skipping testDumpDirNotWritable test.\");\n-                return;\n+                throw new SkipException(\"WARNING: The dump directory is writeable. Skipping testDumpDirNotWritable test.\");\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LogGeneratedClassesTest.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8338139\n+ * @summary Basic unit test of ClassLoadingMXBean.set\/isVerbose() when\n+ *          related unified logging is enabled.\n+ *\n+ * @run main\/othervm -Xlog:class+load=trace:file=vm.log TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=debug:file=vm.log TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=info:file=vm.log TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:class+load=trace TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=debug TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=info TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=warning TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=error TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=off TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:class+load*=trace TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=debug TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=warning TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=error TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=off TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=trace TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=debug TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=info TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=warning TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=error TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=off TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:all=trace:file=vm.log TestVerboseClassLoading false\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ClassLoadingMXBean;\n+\n+public class TestVerboseClassLoading {\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassLoadingMXBean mxBean = ManagementFactory.getClassLoadingMXBean();\n+        boolean expected = Boolean.parseBoolean(args[0]);\n+        boolean initial = mxBean.isVerbose();\n+        if (expected != initial) {\n+            throw new Error(\"Initial verbosity setting was unexpectedly \" + initial);\n+        }\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+        mxBean.setVerbose(true);\n+        if (!mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still disabled\");\n+        }\n+        \/\/ Turn off again as a double-check and also to avoid excessive logging\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/management\/ClassLoadingMXBean\/TestVerboseClassLoading.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8338139\n+ * @summary Basic unit test of TestVerboseMemory.set\/isVerbose() when\n+ *          related unified logging is enabled.\n+ *\n+ * @run main\/othervm -Xlog:gc=trace:file=vm.log TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=debug:file=vm.log TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=info:file=vm.log TestVerboseMemory false\n+ *\n+ * @run main\/othervm -Xlog:gc=off TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=error TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=warning TestVerboseMemory false\n+ *\n+ * @run main\/othervm -Xlog:gc=info TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc=trace TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc=debug TestVerboseMemory true\n+ *\n+ * @run main\/othervm -Xlog:gc*=info TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc*=debug TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc*=trace TestVerboseMemory true\n+ *\n+ * @run main\/othervm -Xlog:gc=info,gc+init=off TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc=off,gc+init=info TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc,gc+init TestVerboseMemory true\n+ *\n+ * @run main\/othervm -Xlog:all=trace:file=vm.log TestVerboseMemory false\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+public class TestVerboseMemory {\n+\n+    public static void main(String[] args) throws Exception {\n+        MemoryMXBean mxBean = ManagementFactory.getMemoryMXBean();\n+        boolean expected = Boolean.parseBoolean(args[0]);\n+        boolean initial = mxBean.isVerbose();\n+        if (expected != initial) {\n+            throw new Error(\"Initial verbosity setting was unexpectedly \" + initial);\n+        }\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+        mxBean.setVerbose(true);\n+        if (!mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still disabled\");\n+        }\n+        \/\/ Turn off again as a double-check and also to avoid excessive logging\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/TestVerboseMemory.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @modules java.base\/java.lang:+open java.management\n+ * @modules java.management jdk.management\n@@ -39,1 +39,1 @@\n- * @modules java.base\/java.lang:+open java.management\n+ * @modules java.management jdk.management\n@@ -51,1 +51,1 @@\n-import jdk.test.lib.thread.VThreadRunner;\n+import jdk.test.lib.thread.VThreadRunner;   \/\/ ensureParallelism requires jdk.management\n","filename":"test\/jdk\/java\/lang\/management\/ThreadMXBean\/VirtualThreadDeadlocks.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,1 @@\n- * @run main\/othervm -ms16m -mx16m Pin\n- * @author Peter Jones\n- * @author Mark Reinhold\n+ * @run main\/othervm -Xms16m -Xmx16m Pin\n","filename":"test\/jdk\/java\/lang\/ref\/SoftReference\/Pin.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+\n+import jdk.test.lib.util.JarUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+\/*\n+ * @test\n+ * @bug 8338445\n+ * @summary verify that the jdk.internal.loader.URLClassPath closes the JarFile\n+ *          instances that it no longer uses for loading\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.util.JarUtils\n+ * @comment This test expects MalformedURLException for some specific URLs.\n+ *          We use othervm to prevent interference from other tests which\n+ *          might have installed custom URLStreamHandler(s)\n+ * @run junit\/othervm JarLoaderCloseTest\n+ *\/\n+public class JarLoaderCloseTest {\n+\n+    private static final String RESOURCE_NAME = \"foo-bar.txt\";\n+    private static final String RESOURCE_CONTENT = \"Hello world\";\n+    private static final Path TEST_SCRATCH_DIR = Path.of(\".\");\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        \/\/ create a file which will be added to the JAR file that gets tested\n+        Files.writeString(TEST_SCRATCH_DIR.resolve(RESOURCE_NAME), RESOURCE_CONTENT);\n+    }\n+\n+    \/*\n+     * Creates a JAR file with a manifest which has a Class-Path entry value with malformed URLs.\n+     * Then uses a URLClassLoader backed by the JAR file in its classpath, loads some resource,\n+     * closes the URLClassLoader and then expects that the underlying JAR file can be deleted\n+     * from the filesystem.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"C:\\\\foo\\\\bar\\\\hello\/world.jar lib2.jar\",\n+            \"C:\/hello\/world\/foo.jar\",\n+            \"lib4.jar C:\\\\bar\\\\foo\\\\world\/hello.jar\"\n+    })\n+    public void testMalformedClassPathEntry(final String classPathValue) throws Exception {\n+        final Manifest manifest = createManifestWithClassPath(classPathValue);\n+        final Path jar = Files.createTempFile(TEST_SCRATCH_DIR, \"8338445\", \".jar\");\n+        \/\/ create the JAR file with the given manifest and an arbitrary file\n+        JarUtils.createJarFile(jar, manifest, TEST_SCRATCH_DIR, Path.of(RESOURCE_NAME));\n+        System.out.println(\"created jar at \" + jar + \" with manifest:\");\n+        manifest.write(System.out);\n+        final URL[] urlClassPath = new URL[]{jar.toUri().toURL()};\n+        \/\/ Create a URLClassLoader backed by the JAR file and load a non-existent resource just to\n+        \/\/ exercise the URLClassPath code of loading the jar and parsing the Class-Path entry.\n+        \/\/ Then close the classloader. After the classloader is closed\n+        \/\/ issue a delete on the underlying JAR file on the filesystem. The delete is expected\n+        \/\/ to succeed.\n+        try (final URLClassLoader cl = new URLClassLoader(urlClassPath)) {\n+            try (final InputStream is = cl.getResourceAsStream(\"non-existent.txt\")) {\n+                assertNull(is, \"unexpectedly found a resource in classpath \"\n+                        + Arrays.toString(urlClassPath));\n+            }\n+        }\n+        \/\/ now delete the JAR file and verify the delete worked\n+        Files.delete(jar);\n+        assertFalse(Files.exists(jar), jar + \" exists even after being deleted\");\n+    }\n+\n+    \/*\n+     * Creates a JAR file with a manifest which has a Class-Path entry value with URLs\n+     * that are parsable but point to files that don't exist on the filesystem.\n+     * Then uses a URLClassLoader backed by the JAR file in its classpath, loads some resource,\n+     * closes the URLClassLoader and then expects that the underlying JAR file can be deleted\n+     * from the filesystem.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/home\/me\/hello\/world.jar lib9.jar\",\n+            \"lib10.jar\"\n+    })\n+    public void testParsableClassPathEntry(final String classPathValue) throws Exception {\n+        final Manifest manifest = createManifestWithClassPath(classPathValue);\n+        final Path jar = Files.createTempFile(TEST_SCRATCH_DIR, \"8338445\", \".jar\");\n+        \/\/ create the JAR file with the given manifest and an arbitrary file\n+        JarUtils.createJarFile(jar, manifest, TEST_SCRATCH_DIR, Path.of(RESOURCE_NAME));\n+        System.out.println(\"created jar at \" + jar + \" with manifest:\");\n+        manifest.write(System.out);\n+        final URL[] urlClassPath = new URL[]{jar.toUri().toURL()};\n+        \/\/ Create a URLClassLoader backed by the JAR file and load a resource\n+        \/\/ and verify the resource contents.\n+        \/\/ Then close the classloader. After the classloader is closed\n+        \/\/ issue a delete on the underlying JAR file on the filesystem. The delete is expected\n+        \/\/ to succeed.\n+        try (final URLClassLoader cl = new URLClassLoader(urlClassPath)) {\n+            try (final InputStream is = cl.getResourceAsStream(RESOURCE_NAME)) {\n+                assertNotNull(is, RESOURCE_NAME + \" not located by classloader in classpath \"\n+                        + Arrays.toString(urlClassPath));\n+                final String content = new String(is.readAllBytes(), US_ASCII);\n+                assertEquals(RESOURCE_CONTENT, content, \"unexpected content in \" + RESOURCE_NAME);\n+            }\n+        }\n+        \/\/ now delete the JAR file and verify the delete worked\n+        Files.delete(jar);\n+        assertFalse(Files.exists(jar), jar + \" exists even after being deleted\");\n+    }\n+\n+    private static Manifest createManifestWithClassPath(final String classPathValue) {\n+        final Manifest manifest = new Manifest();\n+        final Attributes mainAttributes = manifest.getMainAttributes();\n+        mainAttributes.putValue(\"Manifest-Version\", \"1.0\");\n+        mainAttributes.putValue(\"Class-Path\", classPathValue);\n+        return manifest;\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/URLClassLoader\/JarLoaderCloseTest.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -115,0 +116,1 @@\n+    static final AtomicInteger requestCount = new AtomicInteger();\n@@ -247,1 +249,1 @@\n-    public void testNoStalls(String uri, boolean sameClient)\n+    public void testNoStalls(String rootUri, boolean sameClient)\n@@ -249,0 +251,1 @@\n+        if (!FAILURES.isEmpty()) return;\n@@ -250,1 +253,1 @@\n-        out.printf(\"%ntestNoStalls(%s, %b)%n\", uri, sameClient);\n+        out.printf(\"%ntestNoStalls(%s, %b)%n\", rootUri, sameClient);\n@@ -255,0 +258,2 @@\n+            String uri = rootUri + \"\/\" + requestCount.incrementAndGet();\n+            out.printf(\"\\tsending request %s%n\", uri);\n@@ -334,0 +339,4 @@\n+        if (!FAILURES.isEmpty()) {\n+            out.printf(\"%s: skipping test - previous failure detected%n\", name);\n+            return;\n+        }\n@@ -344,1 +353,1 @@\n-    private <T,U> void testDependent(String uri, boolean sameClient,\n+    private <T,U> void testDependent(String rootUri, boolean sameClient,\n@@ -357,0 +366,2 @@\n+            String uri = rootUri + \"\/\" + requestCount.incrementAndGet();\n+            out.printf(\"\\tsending request %s%n\", uri);\n@@ -366,1 +377,7 @@\n-            assert subscriberType == SubscriberType.LAZZY || !responseCF.isDone();\n+            \/\/ The body of the main response can be received before the body\n+            \/\/ of the push promise handlers are received.\n+            \/\/ The body of the main response doesn't stall, so the cf of\n+            \/\/ the main response may be done here even for EAGER subscribers.\n+            \/\/ We cannot make any assumption on the state of the main response\n+            \/\/ cf here, so the only thing we can do is to call the finisher\n+            \/\/ which will wait for them all.\n","filename":"test\/jdk\/java\/net\/httpclient\/DependentPromiseActionsTest.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n- * @bug 8087112\n+ * @bug 8087112 8336655 8338569\n","filename":"test\/jdk\/java\/net\/httpclient\/DigestEchoClient.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,2 +88,2 @@\n-    URI getUri, postUri, hangUri;\n-    URI h2postUri, h2hangUri, h2endStreamUri, h2warmupURI;\n+    URI getUri, postUri, forcePostUri, hangUri;\n+    URI h2postUri, h2forcePostUri, h2hangUri, h2endStreamUri, h2warmupURI;\n@@ -100,0 +100,1 @@\n+                { forcePostUri, 200, false, HTTP_1_1 },\n@@ -102,0 +103,1 @@\n+                { h2forcePostUri, 200, false, HTTP_2 },\n@@ -130,1 +132,1 @@\n-            verifyRequest(expectedStatusCode, resp, exceptionally, testThrowable);\n+            verifyRequest(uri.getPath(), expectedStatusCode, resp, exceptionally, testThrowable);\n@@ -140,0 +142,1 @@\n+        http1TestServer.addHandler(new ForcePostHandler(), \"\/http1\/forcePost\");\n@@ -142,0 +145,1 @@\n+        forcePostUri = URI.create(\"http:\/\/\" + http1TestServer.serverAuthority() + \"\/http1\/forcePost\");\n@@ -152,0 +156,1 @@\n+        http2TestServer.addHandler(new ForcePostHandler().toHttp2Handler(), \"\/http2\/forcePost\");\n@@ -157,0 +162,1 @@\n+        h2forcePostUri = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/forcePost\");\n@@ -160,3 +166,3 @@\n-        out.printf(\"HTTP\/1.1 server listening at: %s\", http1TestServer.serverAuthority());\n-        out.printf(\"HTTP\/1.1 hang server listening at: %s\", hangUri.getRawAuthority());\n-        out.printf(\"HTTP\/2 clear server listening at: %s\", http2TestServer.serverAuthority());\n+        out.printf(\"HTTP\/1.1 server listening at: %s %n\", http1TestServer.serverAuthority());\n+        out.printf(\"HTTP\/1.1 hang server listening at: %s %n\", hangUri.getRawAuthority());\n+        out.printf(\"HTTP\/2 clear server listening at: %s %n\", http2TestServer.serverAuthority());\n@@ -210,0 +216,12 @@\n+    static class ForcePostHandler implements HttpTestHandler {\n+        @Override\n+        public void handle(HttpTestExchange exchange) throws IOException {\n+            try (InputStream is = exchange.getRequestBody()) {\n+                err.println(\"Server reading body inside the force Post\");\n+                is.readAllBytes();\n+                err.println(\"Server send 200 (length=0) in the force post\");\n+                exchange.sendResponseHeaders(200, 0);\n+            }\n+        }\n+    }\n+\n@@ -340,1 +358,4 @@\n-    private void verifyRequest(int expectedStatusCode, HttpResponse<String> resp, boolean exceptionally, Throwable testThrowable) {\n+    private void verifyRequest(String path, int expectedStatusCode, HttpResponse<String> resp, boolean exceptionally, Throwable testThrowable) {\n+        if (!exceptionally) {\n+            err.printf(\"Response code %s received for path %s %n\", resp.statusCode(), path);\n+        }\n@@ -342,1 +363,1 @@\n-            err.println(testThrowable);\n+            err.println(\"Finished exceptionally Test throwable: \" + testThrowable);\n@@ -348,1 +369,1 @@\n-            err.println(\"Request completed successfully\");\n+            err.println(\"Request completed successfully for path \" + path);\n","filename":"test\/jdk\/java\/net\/httpclient\/ExpectContinueTest.java","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,0 +198,3 @@\n+        boolean proxyInClosed;  \/\/ only accessed from synchronized block\n+        boolean proxyOutClosed; \/\/ only accessed from synchronized block\n+\n@@ -597,3 +600,1 @@\n-                    closing = true;\n-                    serverSocket.close();\n-                    clientSocket.close();\n+                    closeClientIn();\n@@ -618,3 +619,1 @@\n-                    closing = true;\n-                    serverSocket.close();\n-                    clientSocket.close();\n+                    closeClientOut();\n@@ -644,0 +643,22 @@\n+        synchronized void closeClientIn() throws IOException {\n+            closing = true;\n+            proxyInClosed = true;\n+            clientSocket.shutdownInput();\n+            serverSocket.shutdownOutput();\n+            if (proxyOutClosed) {\n+                serverSocket.close();\n+                clientSocket.close();\n+            }\n+        }\n+\n+        synchronized void closeClientOut() throws IOException {\n+            closing = true;\n+            proxyOutClosed = true;\n+            serverSocket.shutdownInput();\n+            clientSocket.shutdownOutput();\n+            if (proxyInClosed) {\n+                serverSocket.close();\n+                clientSocket.close();\n+            }\n+        }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/ProxyServer.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,1 +213,1 @@\n-            if (client.awaitTermination(Duration.ofMillis(2000))) {\n+            if (client.awaitTermination(Duration.ofMillis(2500))) {\n@@ -215,0 +215,1 @@\n+                assertTrue(client.isTerminated());\n@@ -216,1 +217,5 @@\n-                throw new AssertionError(\"client still running\");\n+                client = null;\n+                var error = TRACKER.check(500);\n+                if (error != null) throw error;\n+                throw new AssertionError(\"client was still running, but exited after further delay: \"\n+                        + \"timeout should be adjusted\");\n@@ -218,1 +223,0 @@\n-            assertTrue(client.isTerminated());\n@@ -275,1 +279,1 @@\n-            if (client.awaitTermination(Duration.ofMillis(2000))) {\n+            if (client.awaitTermination(Duration.ofMillis(2500))) {\n@@ -277,0 +281,1 @@\n+                assertTrue(client.isTerminated());\n@@ -278,1 +283,5 @@\n-                throw new AssertionError(\"client still running\");\n+                client = null;\n+                var error = TRACKER.check(500);\n+                if (error != null) throw error;\n+                throw new AssertionError(\"client was still running, but exited after further delay: \"\n+                        + \"timeout should be adjusted\");\n@@ -280,1 +289,0 @@\n-            assertTrue(client.isTerminated());\n","filename":"test\/jdk\/java\/net\/httpclient\/ShutdownNow.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8087112 8178699\n+ * @bug 8087112 8178699 8338569\n@@ -57,0 +57,2 @@\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n@@ -575,2 +577,1 @@\n-        URI uri = new URI(target);\n-        HttpRequest request = HttpRequest.newBuilder().uri(uri).GET().build();\n+        AtomicInteger count = new AtomicInteger();\n@@ -579,0 +580,3 @@\n+            URI uri = new URI(target+\"?get-sync;count=\"+count.incrementAndGet());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder().uri(uri).GET().build();\n@@ -587,4 +591,1 @@\n-        request = HttpRequest.newBuilder()\n-                .uri(uri)\n-                .POST(BodyPublishers.ofFile(requestBody))\n-                .build();\n+\n@@ -593,0 +594,6 @@\n+            URI uri = new URI(target+\"?post-async;count=\"+count.incrementAndGet());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder()\n+                    .uri(uri)\n+                    .POST(BodyPublishers.ofFile(requestBody))\n+                    .build();\n@@ -613,1 +620,0 @@\n-        request = HttpRequest.newBuilder(uri).GET().build();\n@@ -615,0 +621,1 @@\n+        Set<String> inFlight = ConcurrentHashMap.newKeySet();\n@@ -616,0 +623,4 @@\n+            URI uri = new URI(target+\"?get-async;count=\"+count.incrementAndGet());\n+            inFlight.add(uri.getQuery());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder(uri).GET().build();\n@@ -618,0 +629,2 @@\n+                      inFlight.remove(uri.getQuery());\n+                      System.out.println(\"Got response for: \" + uri);\n@@ -633,0 +646,4 @@\n+            URI uri = new URI(target+\"?get-async-next;count=\"+count.incrementAndGet());\n+            inFlight.add(uri.getQuery());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder(uri).GET().build();\n@@ -635,0 +652,3 @@\n+                      inFlight.remove(uri.getQuery());\n+                      System.out.println(\"Got response for: \" + uri);\n+                      System.out.println(\"In flight: \" + inFlight);\n@@ -642,0 +662,2 @@\n+        System.out.println(\"Waiting: In flight: \" + inFlight);\n+        System.out.println(\"Queue size: \" + q.size());\n@@ -645,0 +667,2 @@\n+            System.out.println(\"Waiting: In flight: \" + inFlight);\n+            System.out.println(\"Queue size: \" + q.size());\n","filename":"test\/jdk\/java\/net\/httpclient\/SmokeTest.java","additions":33,"deletions":9,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm -mx16M Chew\n+ * @run main\/othervm -Xmx16M Chew\n","filename":"test\/jdk\/java\/nio\/Buffer\/Chew.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import static jdk.test.lib.NetworkConfiguration.isSameInterface;\n@@ -298,2 +299,2 @@\n-        assertTrue(s.getNetworkInterface().equals(ni));\n-        assertTrue(s.getOption(IP_MULTICAST_IF).equals(ni));\n+        assertTrue(isSameInterface(s.getNetworkInterface(), ni));\n+        assertTrue(isSameInterface(s.getOption(IP_MULTICAST_IF), ni));\n@@ -318,2 +319,2 @@\n-        assertTrue(s.getOption(IP_MULTICAST_IF).equals(ni));\n-        assertTrue(s.getNetworkInterface().equals(ni));\n+        assertTrue(isSameInterface(s.getOption(IP_MULTICAST_IF), ni));\n+        assertTrue(isSameInterface(s.getNetworkInterface(), ni));\n@@ -415,1 +416,2 @@\n-        byte[] message = \"hello\".getBytes(\"UTF-8\");\n+        String msg = \"AdaptorMulticasting:  \" + System.nanoTime();\n+        byte[] message = msg.getBytes(\"UTF-8\");\n@@ -424,2 +426,16 @@\n-        p = new DatagramPacket(new byte[1024], 100);\n-        s.receive(p);\n+        while (true) {\n+            p = new DatagramPacket(new byte[1024], 100);\n+            s.receive(p);\n+            if (p.getPort() == s.getLocalPort()) {\n+                String str = new String(p.getData(), p.getOffset(), p.getLength(), \"UTF-8\");\n+                if (Arrays.equals(p.getData(), p.getOffset(), p.getLength(), message, 0, message.length)) {\n+                    System.out.format(\"Got expected message \\\"%s\\\" from %s%n\", str, p.getSocketAddress());\n+                    break;\n+                }\n+                System.out.println(\"Unexpected message received. Expected: \" + msg);\n+                System.out.println(\"Received message doesn't match - skipping: \" + str);\n+            } else {\n+                System.out.println(\"Unexpected message received. Expected message from: \" + s.getLocalAddress());\n+                System.out.println(\"Received message sender doesn't match - skipping: \" + p.getSocketAddress());\n+            }\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/AdaptorMulticasting.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.net.BindException;\n@@ -49,0 +50,1 @@\n+import java.util.function.Predicate;\n@@ -57,0 +59,32 @@\n+    interface RetryableTest<T extends Exception> {\n+        public void runTest() throws T;\n+    }\n+\n+    \/\/ retry the given lambda (RetryableTest) if an exception\n+    \/\/ that satisfies the predicate (retryOn) is caught.\n+    <T extends Exception> void testWithRetry(RetryableTest<T> test,\n+                                             Predicate<Throwable> retryOn,\n+                                             int max) throws T {\n+        for (int i=0; i < max; i++) {\n+            try {\n+                test.runTest();\n+                break;\n+            } catch (Throwable t) {\n+                if (i < max -1 && retryOn.test(t)) {\n+                    System.out.println(\"Got \" + t + \"; will retry\");\n+                } else throw t;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * When calling {@link DatagramChannel#disconnect()} a {@link BindException}\n+     * may occur. In which case we want to retry the test.\n+     *\/\n+    class BindExceptionOnDisconnect extends BindException {\n+        BindExceptionOnDisconnect(BindException x) {\n+            super(x.getMessage());\n+            initCause(x);\n+        }\n+    }\n+\n@@ -64,11 +98,3 @@\n-        try (DatagramChannel dc = DatagramChannel.open()) {\n-            System.out.println(\"Test with default\");\n-            dc.bind(new InetSocketAddress(lb, 0));\n-            test(dc);\n-            test(dc);\n-        }\n-\n-        \/\/ test with IPv6 socket\n-        if (IPSupport.hasIPv6()) {\n-            System.out.println(\"Test with IPv6 socket\");\n-            try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET6)) {\n+        System.out.println(\"Test with default\");\n+        testWithRetry(() -> {\n+            try (DatagramChannel dc = DatagramChannel.open()) {\n@@ -79,0 +105,12 @@\n+        }, BindExceptionOnDisconnect.class::isInstance, 5);\n+\n+        \/\/ test with IPv6 socket\n+        if (IPSupport.hasIPv6()) {\n+            System.out.println(\"Test with IPv6 socket\");\n+            testWithRetry(() -> {\n+                try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET6)) {\n+                    dc.bind(new InetSocketAddress(lb, 0));\n+                    test(dc);\n+                    test(dc);\n+                }\n+            }, BindExceptionOnDisconnect.class::isInstance, 5);\n@@ -84,5 +122,7 @@\n-            try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET)) {\n-                dc.bind(new InetSocketAddress(lb, 0));\n-                test(dc);\n-                test(dc);\n-            }\n+            testWithRetry(() -> {\n+                try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET)) {\n+                    dc.bind(new InetSocketAddress(lb, 0));\n+                    test(dc);\n+                    test(dc);\n+                }\n+            }, BindExceptionOnDisconnect.class::isInstance, 5);\n@@ -92,0 +132,1 @@\n+\n@@ -114,1 +155,5 @@\n-            dc.disconnect();\n+            try {\n+                dc.disconnect();\n+            } catch (BindException x) {\n+                throw new BindExceptionOnDisconnect(x);\n+            }\n@@ -137,1 +182,5 @@\n-        dc.disconnect();\n+        try {\n+            dc.disconnect();\n+        } catch (BindException x) {\n+            throw new BindExceptionOnDisconnect(x);\n+        }\n@@ -171,1 +220,5 @@\n-            dc.disconnect();\n+            try {\n+                dc.disconnect();\n+            } catch (BindException x) {\n+                throw new BindExceptionOnDisconnect(x);\n+            }\n@@ -213,1 +266,5 @@\n-            dc.disconnect();\n+            try {\n+                dc.disconnect();\n+            } catch (BindException x) {\n+                throw new BindExceptionOnDisconnect(x);\n+            }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/AfterDisconnect.java","additions":78,"deletions":21,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform Connect\n@@ -41,0 +43,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -117,0 +121,11 @@\n+                \/\/ When connecting an unbound datagram channel, the underlying\n+                \/\/ socket will first be bound to the wildcard address. On macOS,\n+                \/\/ the system may allocate the same port on which another socket\n+                \/\/ is already bound with a more specific address. This may prevent\n+                \/\/ datagrams directed at the connected socket to reach it.\n+                \/\/ To avoid this, when on macOS, we preemptively bind `dc` to the\n+                \/\/ specific address instead of letting it bind to the wildcard.\n+                if (Platform.isOSX()) {\n+                    dc.bind(new InetSocketAddress(((InetSocketAddress)connectSocketAddress).getAddress(), 0));\n+                    err.println(\"Initiator bound to: \" + connectSocketAddress);\n+                }\n@@ -120,0 +135,1 @@\n+                assert !connectSocketAddress.equals(dc.getLocalAddress());\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Connect.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- *     sender address\n+ *     sender address.\n@@ -66,0 +66,1 @@\n+            System.out.println(\"\\nReader bound to: \" + reader.getLocalAddress());\n@@ -78,0 +79,1 @@\n+            System.out.println(\"\\nSender bound to: \" + sender.getLocalAddress());\n@@ -100,0 +102,5 @@\n+            System.out.println(\"Sender bound to: \" + local);\n+            if (((InetSocketAddress)local).getPort() == remotePort) {\n+                System.out.println(\"testSend: Sender and reader have same port: skipping\");\n+                return;\n+            }\n@@ -108,0 +115,2 @@\n+                System.out.format(\"testSend: reader waiting to receive at: %s%n\",\n+                        reader.getLocalAddress());\n@@ -141,0 +150,5 @@\n+            System.out.println(\"Reader bound to: \" + remote);\n+            if (((InetSocketAddress)local).getPort() == ((InetSocketAddress)remote).getPort()) {\n+                System.out.println(\"testReceive: Sender and reader have same port: skipping\");\n+                return;\n+            }\n@@ -146,0 +160,2 @@\n+                System.out.format(\"testReceive: reader waiting to receive at: %s%n\",\n+                        reader.getLocalAddress());\n@@ -168,1 +184,6 @@\n-            return Optional.ofNullable(NetworkInterface.getByInetAddress(ia));\n+            NetworkInterface nif = NetworkInterface.getByInetAddress(ia);\n+            if (nif != null) {\n+                System.out.format(\"Selecting interface %s[%d]%n\\twith addresses:%n\\t%s%n\",\n+                    nif.getDisplayName(), nif.getIndex(), nif.inetAddresses().toList());\n+            }\n+            return Optional.ofNullable(nif);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/ManySourcesAndTargets.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,1 @@\n+            long elapsed = 0;\n@@ -104,0 +105,1 @@\n+                long start = System.nanoTime();\n@@ -105,0 +107,3 @@\n+                long waited = (System.nanoTime() - start) \/ 1000_000;\n+                elapsed += waited;\n+                buf.clear();\n@@ -110,1 +115,6 @@\n-                        throw new RuntimeException(\"Expected message not received\");\n+                        if (elapsed > 4800) {\n+                            throw new RuntimeException(\"Expected message not received\");\n+                        } else {\n+                            sel.selectedKeys().clear();\n+                            continue;\n+                        }\n@@ -126,2 +136,2 @@\n-                    System.out.format(\"Received message from %s (id=0x%x)\\n\",\n-                            sender, receivedId);\n+                    System.out.format(\"Received message from %s (id=0x%x, length=%s)\\n\",\n+                            sender, receivedId, bytes.length);\n@@ -145,1 +155,0 @@\n-                buf.rewind();\n@@ -163,0 +172,2 @@\n+        System.out.format(\"With interface=%s[%s]%n\\twith bound addresses:%n\\t%s%n\",\n+                nif.getDisplayName(), nif.getIndex(), nif.inetAddresses().toList());\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/MulticastSendReceiveTests.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- *     the channel's socket to be bound to a local address\n+ *     the channel's socket to be bound to a local address.\n+ * @run main\/othervm NotBound\n@@ -34,0 +35,3 @@\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -37,0 +41,2 @@\n+    static final CountDownLatch received = new CountDownLatch(1);\n+\n@@ -40,0 +46,1 @@\n+        System.out.println(\"Bound to: \" + dc.getLocalAddress());\n@@ -54,0 +61,1 @@\n+                    System.out.format(\"receiver bound to: %s%n\", local);\n@@ -55,10 +63,35 @@\n-                    \/\/ send message to channel to wakeup receiver\n-                    DatagramChannel sender = DatagramChannel.open();\n-                    try {\n-                        ByteBuffer bb = ByteBuffer.wrap(\"hello\".getBytes());\n-                        InetAddress lh = InetAddress.getLocalHost();\n-                        SocketAddress target =\n-                            new InetSocketAddress(lh, local.getPort());\n-                        sender.send(bb, target);\n-                    } finally {\n-                        sender.close();\n+                    boolean isAnyLocal = local.getAddress().isAnyLocalAddress();\n+                    int maxAttempts = 5;\n+                    int localPort = 0;\n+                    List<InetAddress> llh = isAnyLocal\n+                            ? List.of(InetAddress.getLocalHost(), InetAddress.getLoopbackAddress())\n+                            : List.of(local.getAddress());\n+                    SocketAddress target = null;\n+                    for (int i = 0 ; i < maxAttempts ; i++) {\n+                        InetAddress lh = llh.get(i % llh.size());\n+                        target = new InetSocketAddress(lh, local.getPort());\n+                        \/\/ send message to channel to wakeup receiver\n+                        try (DatagramChannel sender = DatagramChannel.open()) {\n+                            ByteBuffer bb = ByteBuffer.wrap(\"NotBound: hello\".getBytes());\n+                            sender.send(bb, target);\n+                            System.out.format(\"Woke up receiver: sent datagram to %s from %s%n\",\n+                                    target, sender.getLocalAddress());\n+                            localPort = ((InetSocketAddress)sender.getLocalAddress()).getPort();\n+                        }\n+                        if (received.await(250, TimeUnit.MILLISECONDS)) {\n+                            \/\/ The datagram has been received: no need to continue\n+                            \/\/ sending\n+                            break;\n+                        }\n+                        \/\/ if sender port and destination port were identical, which\n+                        \/\/ could happen on some systems, the receiver might not receive\n+                        \/\/ the datagram. So in that case we try again, bailing out if\n+                        \/\/ we had to retry too many times\n+                        if (localPort == local.getPort()) {\n+                            System.out.println(\"Local port and peer port are identical. Retrying...\");\n+                        } else {\n+                            System.out.println(\"Datagram not received after 250ms. Retrying...\");\n+                        }\n+                    }\n+                    if (localPort == local.getPort()) {\n+                        System.out.println(\"Couldn't find a port to send to \" + target);\n@@ -66,1 +99,0 @@\n-\n@@ -80,4 +112,4 @@\n-            DatagramChannel peer = DatagramChannel.open()\n-                .bind(new InetSocketAddress(0));\n-            int peerPort = ((InetSocketAddress)(peer.getLocalAddress())).getPort();\n-            try {\n+            System.out.println(\"Check that connect() binds the socket\");\n+            try (DatagramChannel peer = DatagramChannel.open()) {\n+                peer.bind(new InetSocketAddress(0));\n+                int peerPort = ((InetSocketAddress)(peer.getLocalAddress())).getPort();\n@@ -86,2 +118,0 @@\n-            } finally {\n-                peer.close();\n@@ -96,1 +126,2 @@\n-            ByteBuffer bb = ByteBuffer.wrap(\"ignore this\".getBytes());\n+            System.out.println(\"Check that send() binds the socket\");\n+            ByteBuffer bb = ByteBuffer.wrap(\"NotBound: ignore this\".getBytes());\n@@ -108,0 +139,1 @@\n+            System.out.println(\"Check that blocking receive() binds the socket\");\n@@ -111,0 +143,1 @@\n+            received.countDown();\n@@ -121,0 +154,1 @@\n+            System.out.println(\"Check that non-blocking receive() binds the socket\");\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/NotBound.java","additions":54,"deletions":20,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,3 @@\n-            System.out.format(\"Send message -> group %s (id=0x%x)\\n\",\n-                    group.getHostAddress(), id);\n+            System.out.format(\"Send message -> group [%s]:%d (id=0x%x) nif:%s[%s]%n\",\n+                    group.getHostAddress(), port, id, nif.getDisplayName(), nif.getIndex());\n+            System.out.format(\"bound address before send: %s%n\", dc.getLocalAddress());\n@@ -77,0 +78,1 @@\n+            System.out.format(\"bound address after send: %s%n\", dc.getLocalAddress());\n@@ -100,0 +102,1 @@\n+            long elapsed = 0;\n@@ -102,0 +105,1 @@\n+                long start = System.nanoTime();\n@@ -103,0 +107,3 @@\n+                long waited = (System.nanoTime() - start) \/ 1000_000;\n+                elapsed += waited;\n+                buf.clear();\n@@ -108,1 +115,7 @@\n-                        throw new RuntimeException(\"Expected message not received\");\n+                        if (elapsed > 4800) {\n+                            throw new RuntimeException(\"Expected message not received\");\n+                        } else {\n+                            sel.selectedKeys().clear();\n+                            \/\/ We haven't waited long enough,\n+                            continue;\n+                        }\n@@ -124,2 +137,2 @@\n-                    System.out.format(\"Received message from %s (id=0x%x)\\n\",\n-                            sender, receivedId);\n+                    System.out.format(\"Received message from %s (id=0x%x, length=%s)\\n\",\n+                            sender, receivedId, bytes.length);\n@@ -143,1 +156,0 @@\n-                buf.rewind();\n@@ -158,0 +170,2 @@\n+        System.out.format(\"With interface=%s[%s]%n\\twith bound addresses:%n\\t%s%n\",\n+                nif.getDisplayName(), nif.getIndex(), nif.inetAddresses().toList());\n@@ -159,4 +173,4 @@\n-        DatagramChannel dc1 = (family == UNSPEC) ?\n-            DatagramChannel.open() : DatagramChannel.open(family);\n-        DatagramChannel dc2 = (family == UNSPEC) ?\n-            DatagramChannel.open() : DatagramChannel.open(family);\n+        try (DatagramChannel dc1 = (family == UNSPEC) ?\n+                DatagramChannel.open() : DatagramChannel.open(family);\n+            DatagramChannel dc2 = (family == UNSPEC) ?\n+                DatagramChannel.open() : DatagramChannel.open(family)) {\n@@ -164,1 +178,0 @@\n-        try {\n@@ -187,1 +200,0 @@\n-            receiveDatagram(dc1, \"dc1\", false, id);\n@@ -189,4 +201,1 @@\n-\n-        } finally {\n-            dc1.close();\n-            dc2.close();\n+            receiveDatagram(dc1, \"dc1\", false, id);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Promiscuous.java","additions":26,"deletions":17,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,6 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ *        jdk.test.lib.Platform\n+ *        ReceiveISA\n+ * @run main\/othervm ReceiveISA\n+ *\n@@ -34,0 +40,3 @@\n+\n+import jdk.test.lib.Platform;\n+\n@@ -47,1 +56,5 @@\n-            dc3.socket().bind((SocketAddress) null); \/\/ bind server to any port\n+            InetAddress lh = InetAddress.getLocalHost();\n+            InetSocketAddress dest = Platform.isOSX()\n+                    ? new InetSocketAddress(lh, 0)\n+                    : null;\n+            dc3.socket().bind(dest); \/\/ bind server to any port\n@@ -50,1 +63,0 @@\n-            InetAddress lh = InetAddress.getLocalHost();\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/ReceiveISA.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-    static final int MAX_TRIES = 3;\n-    static final String GREETINGS_MESSAGE = \"Greetings from SelectWhenRefused!\";\n+    static final int MAX_TRIES = 10;\n+    static final String GREETINGS_MESSAGE = System.nanoTime() + \": Greetings from SelectWhenRefused!\";\n@@ -52,0 +52,1 @@\n+        System.err.println(\"Refuser is: \" + refuser);\n@@ -53,1 +54,29 @@\n-        DatagramChannel dc = DatagramChannel.open().bind(new InetSocketAddress(0));\n+        DatagramChannel dc = null;\n+        for (int i=0; i < MAX_TRIES; i++) {\n+            dc = DatagramChannel.open();\n+            try {\n+                dc.bind(new InetSocketAddress(0));\n+            } catch (Throwable t) {\n+                dc.close();\n+                throw t;\n+            }\n+\n+            \/\/ check the port assigned to dc\n+            if (((InetSocketAddress)dc.getLocalAddress()).getPort() != port) {\n+                \/\/ We got a good port. Do not retry\n+                break;\n+            }\n+\n+            \/\/ We bound to the same port that the refuser is using, This will not\n+            \/\/ work. Retry binding if possible.\n+            if (i < MAX_TRIES - 1) {\n+                \/\/ we will retry...\n+                System.err.format(\"Refuser port has been reused by dc: %s, retrying...%n\",\n+                        dc.getLocalAddress());\n+            } else {\n+                \/\/ that was the last attempt... Skip the test\n+                System.err.format(\"Skipping test: refuser port has been reused by dc: %s%n\",\n+                        dc.getLocalAddress());\n+                return;\n+            }\n+        }\n@@ -55,0 +84,1 @@\n+        assert dc != null;\n@@ -91,1 +121,1 @@\n-            System.out.println(\"Skipping test: refuser port has been reused: \" + e);\n+            System.err.println(\"Skipping test: refuser port has been reused: \" + e);\n@@ -122,1 +152,3 @@\n-            DatagramChannel.open().bind(refuser).close();\n+            try (DatagramChannel dc2 = DatagramChannel.open()) {\n+                dc2.bind(refuser);\n+            }\n@@ -154,1 +186,1 @@\n-                    System.out.format(\"received %s at %s from %s%n\", message, dc.getLocalAddress(), sa);\n+                    System.err.format(\"received %s at %s from %s%n\", message, dc.getLocalAddress(), sa);\n@@ -169,1 +201,3 @@\n-                DatagramChannel.open().bind(refuser).close();\n+                try (DatagramChannel dc2 = DatagramChannel.open()) {\n+                    dc2.bind(refuser);\n+                }\n@@ -172,1 +206,1 @@\n-                System.out.println(\"Got expected PortUnreachableException \" + pue);\n+                System.err.println(\"Got expected PortUnreachableException \" + pue);\n@@ -218,1 +252,1 @@\n-        System.out.format(\"Received %d keys%n\", selectedKeys.size());\n+        System.err.format(\"Received %d keys%n\", selectedKeys.size());\n@@ -222,1 +256,1 @@\n-                System.out.println(\"Invalid or unreadable key: \" + key);\n+                System.err.println(\"Invalid or unreadable key: \" + key);\n@@ -227,1 +261,1 @@\n-                System.out.println(\"Attempting to read datagram from key: \" + key);\n+                System.err.println(\"Attempting to read datagram from key: \" + key);\n@@ -237,1 +271,1 @@\n-                    System.out.format(\"received %s at %s from %s%n\", message, datagramChannel.getLocalAddress(), sa);\n+                    System.err.format(\"received %s at %s from %s%n\", message, datagramChannel.getLocalAddress(), sa);\n@@ -246,1 +280,1 @@\n-                System.out.println(\"Unable to read from datagram \" + io);\n+                System.err.println(\"Unable to read from datagram \" + io);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/SelectWhenRefused.java","additions":47,"deletions":13,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import org.testng.Assert;\n@@ -49,0 +50,1 @@\n+import java.net.SocketAddress;\n@@ -142,1 +144,3 @@\n-                sender.bind(null);\n+                sender.bind(new InetSocketAddress(host, 0));\n+                System.out.format(\"testSendReceiveMaxSize: sender: %s -> receiver: %s%n\",\n+                        sender.getLocalAddress(), receiver.getLocalAddress());\n@@ -153,1 +157,12 @@\n-                receiver.receive(receiveBuf);\n+                SocketAddress src;\n+                int count = 0;\n+                do {\n+                    receiveBuf.clear();\n+                    src = receiver.receive(receiveBuf);\n+                    if (sender.getLocalAddress().equals(src)) break;\n+                    System.out.println(\"step1: received unexpected datagram from: \" + src);\n+                    System.out.println(\"\\texpected: \" + sender.getLocalAddress());\n+                    if (++count > 10) {\n+                        throw new AssertionError(\"too many unexpected messages\");\n+                    }\n+                } while (true);\n@@ -170,1 +185,11 @@\n-                receiver.receive(receiveBuf);\n+                count = 0;\n+                do {\n+                    receiveBuf.clear();\n+                    src = receiver.receive(receiveBuf);\n+                    if (sender.getLocalAddress().equals(src)) break;\n+                    System.out.println(\"step1: received unexpected datagram from: \" + src);\n+                    System.out.println(\"\\texpected: \" + sender.getLocalAddress());\n+                    if (++count > 10) {\n+                        throw new AssertionError(\"too many unexpected messages\");\n+                    }\n+                } while (true);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/SendReceiveMaxSize.java","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform Sender\n+ * @run main Sender\n@@ -39,0 +42,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -49,2 +54,2 @@\n-        Server server = new Server();\n-        Client client = new Client(server.port());\n+        try (Server server = new Server()) {\n+            Client client = new Client(server.port());\n@@ -52,2 +57,2 @@\n-        Thread serverThread = new Thread(server);\n-        serverThread.start();\n+            Thread serverThread = new Thread(server);\n+            serverThread.start();\n@@ -55,2 +60,2 @@\n-        Thread clientThread = new Thread(client);\n-        clientThread.start();\n+            Thread clientThread = new Thread(client);\n+            clientThread.start();\n@@ -58,2 +63,2 @@\n-        serverThread.join();\n-        clientThread.join();\n+            serverThread.join();\n+            clientThread.join();\n@@ -61,2 +66,3 @@\n-        server.throwException();\n-        client.throwException();\n+            server.throwException();\n+            client.throwException();\n+        }\n@@ -67,1 +73,1 @@\n-        Exception e = null;\n+        volatile Exception e = null;\n@@ -79,2 +85,1 @@\n-            try {\n-                DatagramChannel dc = DatagramChannel.open();\n+            try (DatagramChannel dc = DatagramChannel.open()) {\n@@ -87,0 +92,4 @@\n+                if (Platform.isOSX()) {\n+                    \/\/ avoid binding on wildcard on macOS\n+                    dc.bind(new InetSocketAddress(address, 0));\n+                }\n@@ -96,1 +105,1 @@\n-    public static class Server implements Runnable {\n+    public static class Server implements Runnable, AutoCloseable {\n@@ -98,1 +107,1 @@\n-        Exception e = null;\n+        volatile Exception e = null;\n@@ -101,1 +110,5 @@\n-            dc = DatagramChannel.open().bind(new InetSocketAddress(0));\n+            \/\/ avoid binding to wildcard address on macOS\n+            InetSocketAddress lo = Platform.isOSX()\n+                    ? new InetSocketAddress(InetAddress.getLocalHost(), 0)\n+                    : new InetSocketAddress(0);\n+            dc = DatagramChannel.open().bind(lo);\n@@ -152,0 +165,5 @@\n+\n+        @Override\n+        public void close() throws IOException {\n+            dc.close();\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Sender.java","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import static jdk.test.lib.Utils.runAndCheckException;\n+\n+import java.lang.Override;\n@@ -27,0 +30,1 @@\n+import java.util.List;\n@@ -31,1 +35,2 @@\n- * @bug 7004967\n+ * @library \/test\/lib\n+ * @bug 7004967 8329754\n@@ -34,0 +39,1 @@\n+\n@@ -38,6 +44,10 @@\n-        try {\n-            NoSync.test(SecureRandom.getInstance(\"S2\", p), 5, 5);\n-            throw new Exception(\"Failed\");\n-        } catch (RuntimeException re) {\n-            \/\/ Good\n-        }\n+        NoSync.test(SecureRandom.getInstance(\"AliasS1\", p), 5, 5);\n+\n+        runAndCheckException(\n+                () -> NoSync.test(SecureRandom.getInstance(\"S2\", p), 5, 5),\n+                RuntimeException.class);\n+\n+        runAndCheckException(\n+                () -> NoSync.test(SecureRandom.getInstance(\"AliasS2\", p), 5, 5),\n+                RuntimeException.class);\n+\n@@ -45,6 +55,9 @@\n-        try {\n-            NoSync.test(SecureRandom.getInstance(\"S4\", p), 5, 5);\n-            throw new Exception(\"Failed\");\n-        } catch (RuntimeException re) {\n-            \/\/ Good\n-        }\n+        NoSync.test(SecureRandom.getInstance(\"AliasS3\", p), 5, 5);\n+\n+        runAndCheckException(\n+                () -> NoSync.test(SecureRandom.getInstance(\"S4\", p), 5, 5),\n+                RuntimeException.class);\n+\n+        runAndCheckException(\n+                () -> NoSync.test(SecureRandom.getInstance(\"AliasS4\", p), 5, 5),\n+                RuntimeException.class);\n@@ -61,0 +74,3 @@\n+            \/\/ Good. Alias of S1, should pass because S1 is not marked as ThreadSafe\n+            put(\"Alg.alias.SecureRandom.AliasS1\", \"S1\");\n+\n@@ -65,0 +81,3 @@\n+            \/\/Bad. Alias of S2, should fail because S2 is marked as ThreadSafe\n+            put(\"alg.Alias.SecureRandom.AliasS2\", \"S2\");\n+\n@@ -67,1 +86,1 @@\n-                    S.class.getName(), null, null));\n+                    S.class.getName(), List.of(\"AliasS3\"), null));\n@@ -71,1 +90,1 @@\n-                    S.class.getName(), null, Map.of(\"ThreadSafe\", \"true\")));\n+                    S.class.getName(), List.of(\"AliasS4\"), Map.of(\"ThreadSafe\", \"true\")));\n@@ -77,1 +96,2 @@\n-        @java.lang.Override\n+\n+        @Override\n@@ -83,0 +103,1 @@\n+\n","filename":"test\/jdk\/java\/security\/SecureRandom\/ThreadSafe.java","additions":38,"deletions":17,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8177552 8217721 8222756 8295372 8306116 8319990\n+ * @bug 8177552 8217721 8222756 8295372 8306116 8319990 8338690\n@@ -63,0 +63,3 @@\n+    private static final NumberFormat FORMAT_IT_LONG = NumberFormat\n+            .getCompactNumberInstance(Locale.ITALIAN, NumberFormat.Style.LONG);\n+\n@@ -92,0 +95,7 @@\n+\n+    private static final NumberFormat FORMAT_PL_LONG = NumberFormat\n+            .getCompactNumberInstance(Locale.of(\"pl\"), NumberFormat.Style.LONG);\n+\n+    private static final NumberFormat FORMAT_FR_LONG = NumberFormat\n+            .getCompactNumberInstance(Locale.FRENCH, NumberFormat.Style.LONG);\n+\n@@ -362,0 +372,6 @@\n+\n+            \/\/ 8338690\n+            {FORMAT_PL_LONG, 5_000, \"5 tysi\\u0119cy\"},\n+            {FORMAT_PL_LONG, 4_949, \"5 tysi\\u0119cy\"},\n+            {FORMAT_FR_LONG, 1_949, \"2 mille\"},\n+            {FORMAT_IT_LONG, 1_949, \"2 mila\"},\n@@ -469,0 +485,4 @@\n+                \/\/ 8338690\n+                {FORMAT_PL_LONG, \"5 tysi\\u0119cy\", 5_000L, Long.class},\n+                {FORMAT_FR_LONG, \"2 mille\", 2_000L, Long.class},\n+                {FORMAT_IT_LONG, \"2 mila\", 2_000L, Long.class},\n@@ -517,0 +537,4 @@\n+            \/\/ 8338690\n+            {FORMAT_PL_LONG, \"5 tysice\", 5L},\n+            {FORMAT_FR_LONG, \"2 millier\", 2L},\n+            {FORMAT_IT_LONG, \"2 mille\", 2L},\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestCompactNumber.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * @bug 8023367 8037106\n+ * @bug 8023367 8037106 8325679\n","filename":"test\/jdk\/java\/util\/List\/ListDefaults.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,4 +25,6 @@\n-   @bug 4028605 4109069 4234207 4401122\n-   @summary Make sure ZipInputStream\/InflaterInputStream.available() will\n-            return 0 after EOF has reached and 1 otherwise.\n-   *\/\n+ * @bug 4028605 4109069 4234207 4401122 8339154\n+ * @summary Verify that ZipInputStream, InflaterInputStream, ZipFileInputStream,\n+ *          ZipFileInflaterInputStream.available() return values according\n+ *          to their specification or long-standing behavior\n+ * @run junit Available\n+ *\/\n@@ -30,0 +32,5 @@\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -32,0 +39,3 @@\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -34,0 +44,3 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n@@ -36,6 +49,2 @@\n-    public static void main(String[] args) throws Exception {\n-        \/\/ 4028605 4109069 4234207\n-        test1();\n-        \/\/ test 4401122\n-        test2();\n-    }\n+    \/\/ ZIP file produced in this test\n+    private final Path zip = Path.of(\"available.jar\");\n@@ -43,2 +52,9 @@\n-    private static void test1() throws Exception {\n-        File f = new File(System.getProperty(\"test.src\", \".\"), \"input.jar\");\n+    \/**\n+     * Create the ZIP file used in this test, containing\n+     * one deflated and one stored entry.\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @BeforeEach\n+    public void setup() throws IOException {\n+        byte[] contents = \"contents\".repeat(10).getBytes(StandardCharsets.UTF_8);\n@@ -46,7 +62,4 @@\n-        \/\/ test ZipInputStream\n-        try (FileInputStream fis = new FileInputStream(f);\n-             ZipInputStream z = new ZipInputStream(fis))\n-        {\n-            z.getNextEntry();\n-            tryAvail(z);\n-        }\n+        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n+            \/\/ First entry uses DEFLATE method\n+            zo.putNextEntry(new ZipEntry(\"deflated.txt\"));\n+            zo.write(contents);\n@@ -54,3 +67,9 @@\n-        \/\/ test InflaterInputStream\n-        try (ZipFile zfile = new ZipFile(f)) {\n-            tryAvail(zfile.getInputStream(zfile.getEntry(\"Available.java\")));\n+            \/\/ Second entry uses STORED method\n+            ZipEntry stored = new ZipEntry(\"stored.txt\");\n+            stored.setMethod(ZipEntry.STORED);\n+            stored.setSize(contents.length);\n+            CRC32 crc32 = new CRC32();\n+            crc32.update(contents);\n+            stored.setCrc(crc32.getValue());\n+            zo.putNextEntry(stored);\n+            zo.write(contents);\n@@ -60,3 +79,32 @@\n-    static void tryAvail(InputStream in) throws Exception {\n-        byte[] buf = new byte[1024];\n-        int n;\n+    \/**\n+     * Delete the ZIP file created by this test\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Verify that ZipInputStream.available() returns 0 after EOF or\n+     * closeEntry, otherwise 1, as specified in the API description.\n+     * This tests 4028605 4109069 4234207\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @Test\n+    public void testZipInputStream() throws IOException {\n+        try (InputStream in = Files.newInputStream(zip)) {\n+            ZipInputStream z = new ZipInputStream(in);\n+            z.getNextEntry();\n+            assertEquals(1, z.available());\n+            z.read();\n+            assertEquals(1, z.available());\n+            z.transferTo(OutputStream.nullOutputStream());\n+            assertEquals(0, z.available(),\n+                    \"ZipInputStream.available() should return 0 after EOF\");\n+\n+            z.close();\n+            assertThrows(IOException.class, () -> z.available(),\n+                    \"Expected an IOException when calling available on a closed stream\");\n+        }\n@@ -64,3 +112,6 @@\n-        while ((n = in.read(buf)) != -1);\n-        if (in.available() != 0) {\n-            throw new Exception(\"available should return 0 after EOF\");\n+        try (InputStream in = Files.newInputStream(zip);\n+             ZipInputStream z = new ZipInputStream(in)) {\n+            z.getNextEntry();\n+            z.closeEntry();\n+            assertEquals(0, z.available(),\n+                    \"ZipInputStream.available() should return 0 after closeEntry\");\n@@ -70,5 +121,15 @@\n-    \/\/ To reproduce 4401122\n-    private static void test2() throws Exception {\n-        File f = new File(System.getProperty(\"test.src\", \".\"), \"input.jar\");\n-        try (ZipFile zf = new ZipFile(f)) {\n-            InputStream in = zf.getInputStream(zf.getEntry(\"Available.java\"));\n+    \/**\n+     * Verify that ZipFileInputStream|ZipFileInflaterInputStream.available()\n+     * return the number of remaining uncompressed bytes.\n+     *\n+     * This verifies unspecified, but long-standing behavior. See 4401122.\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = { \"stored.txt\", \"deflated.txt\" })\n+    public void testZipFileStreamsRemainingBytes(String entryName) throws IOException {\n+        try (ZipFile zfile = new ZipFile(zip.toFile())) {\n+            ZipEntry entry = zfile.getEntry(entryName);\n+            \/\/ Could be ZipFileInputStream or ZipFileInflaterInputStream\n+            InputStream in = zfile.getInputStream(entry);\n@@ -77,4 +138,7 @@\n-            in.read();\n-            if (in.available() != initialAvailable - 1)\n-                throw new RuntimeException(\"Available not decremented.\");\n-            for(int j=0; j<initialAvailable-1; j++)\n+\n+            \/\/ Initally, the number of remaining uncompressed bytes is the entry size\n+            assertEquals(entry.getSize(), initialAvailable);\n+\n+            \/\/ Read all bytes one by one\n+            for (int i = initialAvailable; i > 0; i--) {\n+                \/\/ Reading a single byte should decrement available by 1\n@@ -82,2 +146,7 @@\n-            if (in.available() != 0)\n-                throw new RuntimeException();\n+                assertEquals(i - 1, in.available(), \"Available not decremented\");\n+            }\n+\n+            \/\/ No remaining uncompressed bytes\n+            assertEquals(0, in.available());\n+\n+            \/\/ available() should still return 0 after close\n@@ -85,2 +154,1 @@\n-            if (in.available() != 0)\n-                throw new RuntimeException();\n+            assertEquals(0, in.available());\n@@ -89,1 +157,0 @@\n-\n","filename":"test\/jdk\/java\/util\/zip\/Available.java","additions":110,"deletions":43,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 4615343\n- * @summary Check that ZipError is thrown instead of InternalError when\n- * iterating entries of an invalid zip file\n- *\/\n-\n-import java.io.*;\n-import java.util.*;\n-import java.util.zip.*;\n-\n-public class TestZipError {\n-    public static void realMain(String[] args) throws Throwable {\n-        \/\/ Causing a ZipError is hard, especially on non-Windows systems.  See\n-        \/\/ comments below.\n-        String osName = System.getProperty(\"os.name\");\n-        if (!System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n-            return;\n-        }\n-\n-        String fileName = \"error4615343.zip\";\n-        File f = new File(fileName);\n-        f.delete();\n-        ZipOutputStream zos;\n-        ZipEntry ze;\n-\n-        \/\/ Create a zip file with two entries.\n-        zos = new ZipOutputStream(new FileOutputStream(f));\n-        ze = new ZipEntry(\"one\");\n-        zos.putNextEntry(ze);\n-        zos.write(\"hello\".getBytes());\n-        zos.closeEntry();\n-        ze = new ZipEntry(\"two\");\n-        zos.putNextEntry(ze);\n-        zos.write(\"world\".getBytes());\n-        zos.closeEntry();\n-        zos.close();\n-\n-        \/\/ Open the ZipFile.  This will read the zip file's central\n-        \/\/ directory into in-memory data structures.\n-        ZipFile zf = new ZipFile(fileName);\n-\n-        \/\/ Delete the file; of course this does not change the in-memory data\n-        \/\/ structures that represent the central directory!\n-        f.delete();\n-\n-        \/\/ Re-create zip file, with different entries than earlier.  However,\n-        \/\/ recall that we have in-memory information about the central\n-        \/\/ directory of the file at its previous state.\n-        zos = new ZipOutputStream(new FileOutputStream(f));\n-        ze = new ZipEntry(\"uno\");\n-        zos.putNextEntry(ze);\n-        zos.write(\"hola\".getBytes());\n-        zos.closeEntry();\n-        zos.close();\n-\n-        \/\/ Iterate zip file's contents.  On Windows, this will result in a\n-        \/\/ ZipError, because the data in the file differs from the in-memory\n-        \/\/ central directory information we read earlier.\n-        Enumeration<? extends ZipEntry> entries = zf.entries();\n-        try {\n-            while (entries.hasMoreElements()) {\n-                ze = entries.nextElement();\n-                zf.getInputStream(ze).readAllBytes();\n-            }\n-            fail(\"Did not get expected exception\");\n-        } catch (ZipException e) {\n-            pass();\n-        } catch (InternalError e) {\n-            fail(\"Caught InternalError instead of expected ZipError\");\n-        } catch (Throwable t) {\n-            unexpected(t);\n-        } finally {\n-            zf.close();\n-            f.delete();\n-        }\n-    }\n-\n-    \/\/--------------------- Infrastructure ---------------------------\n-    static volatile int passed = 0, failed = 0;\n-    static void pass() {passed++;}\n-    static void fail() {failed++; Thread.dumpStack();}\n-    static void fail(String msg) {System.out.println(msg); fail();}\n-    static void unexpected(Throwable t) {failed++; t.printStackTrace();}\n-    static void check(boolean cond) {if (cond) pass(); else fail();}\n-    static void equal(Object x, Object y) {\n-        if (x == null ? y == null : x.equals(y)) pass();\n-        else fail(x + \" not equal to \" + y);}\n-    public static void main(String[] args) throws Throwable {\n-        try {realMain(args);} catch (Throwable t) {unexpected(t);}\n-        System.out.println(\"\\nPassed = \" + passed + \" failed = \" + failed);\n-        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n-}\n","filename":"test\/jdk\/java\/util\/zip\/TestZipError.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8334165\n+ * @summary Test that jmx.serial.form is not recognised.\n+ *\n+ * @run main\/othervm -Djmx.serial.form=1.0 SerialCompatRemovedTest\n+ * @run main\/othervm SerialCompatRemovedTest\n+ *\/\n+\n+import java.io.*;\n+import java.util.*;\n+import javax.management.ObjectName;\n+\n+public class SerialCompatRemovedTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        ObjectStreamClass osc = ObjectStreamClass.lookup(ObjectName.class);\n+        \/\/ Serial form has no fields, uses writeObject, so we should never see\n+        \/\/ non-zero field count here:\n+        if (osc.getFields().length != 0) {\n+            throw new Exception(\"ObjectName using old serial form?: fields: \" +\n+                    Arrays.asList(osc.getFields()));\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/management\/ObjectName\/SerialCompatRemovedTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -1,263 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6211220 6616825\n- * @summary Test that jmx.serial.form=1.0 works for ObjectName\n- * @author Eamonn McManus, Daniel Fuchs\n- *\n- * @run clean SerialCompatTest\n- * @run build SerialCompatTest\n- * @run main\/othervm -Djdk.jmx.mbeans.allowNonPublic=true -Djmx.serial.form=1.0 SerialCompatTest\n- *\/\n-\n-import java.io.*;\n-import java.util.*;\n-import javax.management.ObjectName;\n-\n-public class SerialCompatTest {\n-\n-    public static void check6211220() throws Exception {\n-\n-        ObjectName on = new ObjectName(\"a:b=c\");\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        ObjectOutputStream oos = new ObjectOutputStream(bos);\n-        oos.writeObject(on);\n-        oos.close();\n-        byte[] bytes = bos.toByteArray();\n-        ByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n-        ObjectInputStream ois = new ObjectInputStream(bis);\n-        ObjectName on1 = (ObjectName) ois.readObject();\n-\n-        \/\/ if the bug is present, these will get NullPointerException\n-        for (int i = 0; i <= 11; i++) {\n-            String msg = \"6211220 case(\" + i + \")\";\n-            try {\n-                switch (i) {\n-                    case 0:\n-                        check(msg, on1.getDomain().equals(\"a\"));\n-                        break;\n-                    case 1:\n-                        check(msg, on1.getCanonicalName().equals(\"a:b=c\"));\n-                        break;\n-                    case 2:\n-                        check(msg, on1.getKeyPropertyListString()\n-                                .equals(\"b=c\"));\n-                        break;\n-                    case 3:\n-                        check(msg, on1.getCanonicalKeyPropertyListString()\n-                                .equals(\"b=c\"));\n-                        break;\n-                    case 4:\n-                        check(msg, on1.getKeyProperty(\"b\").equals(\"c\"));\n-                        break;\n-                    case 5:\n-                        check(msg, on1.getKeyPropertyList()\n-                                .equals(Collections.singletonMap(\"b\", \"c\")));\n-                        break;\n-                    case 6:\n-                        check(msg, !on1.isDomainPattern());\n-                        break;\n-                    case 7:\n-                        check(msg, !on1.isPattern());\n-                        break;\n-                    case 8:\n-                        check(msg, !on1.isPropertyPattern());\n-                        break;\n-                    case 9:\n-                        check(msg, on1.equals(on));\n-                        break;\n-                    case 10:\n-                        check(msg, on.equals(on1));\n-                        break;\n-                    case 11:\n-                        check(msg, on1.apply(on));\n-                        break;\n-                    default:\n-                        throw new Exception(msg + \": Test incorrect\");\n-                }\n-            } catch (Exception e) {\n-                System.out.println(msg + \": Test failed with exception:\");\n-                e.printStackTrace(System.out);\n-                failed = true;\n-            }\n-        }\n-\n-        if (failed) {\n-            throw new Exception(\"Some tests for 6211220 failed\");\n-        } else {\n-            System.out.println(\"All tests for 6211220 passed\");\n-        }\n-    }\n-\n-    static void checkName(String testname, ObjectName on)\n-            throws Exception {\n-        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-        ObjectOutputStream oos = new ObjectOutputStream(bos);\n-        oos.writeObject(on);\n-        oos.close();\n-        byte[] bytes = bos.toByteArray();\n-        ByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n-        ObjectInputStream ois = new ObjectInputStream(bis);\n-        ObjectName on1 = (ObjectName) ois.readObject();\n-        \/\/ if the bug is present, these will get NullPointerException\n-        for (int i = 0; i <= 11; i++) {\n-            String msg = testname + \" case(\" + i + \")\";\n-            try {\n-                switch (i) {\n-                    case 0:\n-                        check(msg, on1.getDomain().equals(on.getDomain()));\n-                        break;\n-                    case 1:\n-                        check(msg, on1.getCanonicalName().\n-                                equals(on.getCanonicalName()));\n-                        break;\n-                    case 2:\n-                        check(msg, on1.getKeyPropertyListString().\n-                                equals(on.getKeyPropertyListString()));\n-                        break;\n-                    case 3:\n-                        check(msg, on1.getCanonicalKeyPropertyListString().\n-                                equals(on.getCanonicalKeyPropertyListString()));\n-                        break;\n-                    case 4:\n-                        for (Object ko : on1.getKeyPropertyList().keySet()) {\n-                            final String key = (String) ko;\n-                            check(msg, on1.getKeyProperty(key).\n-                                    equals(on.getKeyProperty(key)));\n-                        }\n-                        for (Object ko : on.getKeyPropertyList().keySet()) {\n-                            final String key = (String) ko;\n-                            check(msg, on1.getKeyProperty(key).\n-                                    equals(on.getKeyProperty(key)));\n-                        }\n-                    case 5:\n-                        check(msg, on1.getKeyPropertyList()\n-                                .equals(on.getKeyPropertyList()));\n-                        break;\n-                    case 6:\n-                        check(msg, on1.isDomainPattern()==on.isDomainPattern());\n-                        break;\n-                    case 7:\n-                        check(msg, on1.isPattern() == on.isPattern());\n-                        break;\n-                    case 8:\n-                        check(msg,\n-                              on1.isPropertyPattern()==on.isPropertyPattern());\n-                        break;\n-                    case 9:\n-                        check(msg, on1.equals(on));\n-                        break;\n-                    case 10:\n-                        check(msg, on.equals(on1));\n-                        break;\n-                    case 11:\n-                        if (!on.isPattern()) {\n-                            check(msg, on1.apply(on));\n-                        }\n-                        break;\n-                    default:\n-                        throw new Exception(\"Test incorrect: case: \" + i);\n-                }\n-            } catch (Exception e) {\n-                System.out.println(\"Test (\" + i + \") failed with exception:\");\n-                e.printStackTrace(System.out);\n-                failed = true;\n-            }\n-        }\n-\n-    }\n-    private static String[] names6616825 = {\n-        \"a:b=c\", \"a:b=c,*\", \"*:*\", \":*\", \":b=c\", \":b=c,*\",\n-        \"a:*,b=c\", \":*\", \":*,b=c\", \"*x?:k=\\\"x\\\\*z\\\"\", \"*x?:k=\\\"x\\\\*z\\\",*\",\n-        \"*x?:*,k=\\\"x\\\\*z\\\"\", \"*x?:k=\\\"x\\\\*z\\\",*,b=c\"\n-    };\n-\n-    static void check6616825() throws Exception {\n-        System.out.println(\"Testing 616825\");\n-        for (String n : names6616825) {\n-            final ObjectName on;\n-            try {\n-                on = new ObjectName(n);\n-            } catch (Exception x) {\n-                failed = true;\n-                System.out.println(\"Unexpected failure for 6616825 [\" + n +\n-                        \"]: \" + x);\n-                x.printStackTrace(System.out);\n-                continue;\n-            }\n-            try {\n-                checkName(\"616825 \" + n, on);\n-            } catch (Exception x) {\n-                failed = true;\n-                System.out.println(\"6616825 failed for [\" + n + \"]: \" + x);\n-                x.printStackTrace(System.out);\n-            }\n-        }\n-\n-        if (failed) {\n-            throw new Exception(\"Some tests for 6616825 failed\");\n-        } else {\n-            System.out.println(\"All tests for 6616825 passed\");\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        \/* Check that we really are in jmx.serial.form=1.0 mode.\n-        The property is frozen the first time the ObjectName class\n-        is referenced so checking that it is set to the correct\n-        value now is not enough.  *\/\n-        ObjectStreamClass osc = ObjectStreamClass.lookup(ObjectName.class);\n-        if (osc.getFields().length != 6) {\n-            throw new Exception(\"Not using old serial form: fields: \" +\n-                    Arrays.asList(osc.getFields()));\n-        \/\/ new serial form has no fields, uses writeObject\n-        }\n-\n-        try {\n-            check6211220();\n-        } catch (Exception x) {\n-            System.err.println(x.getMessage());\n-        }\n-        try {\n-            check6616825();\n-        } catch (Exception x) {\n-            System.err.println(x.getMessage());\n-        }\n-\n-        if (failed) {\n-            throw new Exception(\"Some tests failed\");\n-        } else {\n-            System.out.println(\"All tests passed\");\n-        }\n-    }\n-\n-    private static void check(String msg, boolean condition) {\n-        if (!condition) {\n-            new Throwable(\"Test failed \" + msg).printStackTrace(System.out);\n-            failed = true;\n-        }\n-    }\n-    private static boolean failed;\n-}\n","filename":"test\/jdk\/javax\/management\/ObjectName\/SerialCompatTest.java","additions":0,"deletions":263,"binary":false,"changes":263,"status":"deleted"},{"patch":"@@ -42,1 +42,2 @@\n-        TLSBase.Client client1 = new TLSBase.Client(true, false);\n+        TLSBase.Client client = new TLSBase.Client(true, false);\n+        client.connect();\n@@ -44,2 +45,3 @@\n-        server.getSession(client1).getSessionContext();\n-        server.done();\n+        \/\/ Close must be called to gather all the exceptions thrown\n+        client.close();\n+        server.close();\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CertMsgCheck.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+        client1.connect();\n@@ -69,0 +70,1 @@\n+        client2.connect();\n@@ -76,1 +78,0 @@\n-        server.done();\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CheckSessionContext.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n@@ -55,0 +57,1 @@\n+        private InetAddress listenInterface = InetAddress.getLoopbackAddress();\n@@ -60,0 +63,9 @@\n+        public InetAddress getListenInterface() {\n+            return listenInterface;\n+        }\n+\n+        public Builder setListenInterface(InetAddress listenInterface) {\n+            this.listenInterface = listenInterface;\n+            return this;\n+        }\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/interop\/AbstractServer.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import java.net.InetAddress;\n@@ -56,1 +57,2 @@\n-                = (SSLServerSocket) serverFactory.createServerSocket(builder.getPort());\n+                = (SSLServerSocket) serverFactory.createServerSocket(builder.getPort(),\n+                    0, builder.getListenInterface());\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/interop\/JdkServer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -32,1 +33,0 @@\n-import java.util.Arrays;\n@@ -35,0 +35,3 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n@@ -42,1 +45,1 @@\n- * Server.done() must be called or the server will never exit and hang the test.\n+ * Server.close() must be called so the server will exit and end threading.\n@@ -55,1 +58,1 @@\n-    static String pathToStores = \"..\/etc\";\n+    static String pathToStores = \"javax\/net\/ssl\/etc\";\n@@ -60,0 +63,3 @@\n+    static final String TESTROOT =\n+        System.getProperty(\"test.root\", \"..\/..\/..\/..\");\n+\n@@ -64,1 +70,1 @@\n-    String name;\n+    public String name;\n@@ -67,6 +73,4 @@\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n+\n+        String keyFilename = TESTROOT +  \"\/\" + pathToStores + \"\/\" + keyStoreFile;\n+        String trustFilename = TESTROOT + \"\/\" + pathToStores + \"\/\" +\n+            trustStoreFile;\n@@ -81,5 +85,4 @@\n-        BufferedReader reader = new BufferedReader(\n-            new InputStreamReader(sock.getInputStream()));\n-        String s = reader.readLine();\n-        System.err.println(\"(read) \" + name + \": \" + s);\n-        return s.getBytes();\n+        BufferedInputStream is = new BufferedInputStream(sock.getInputStream());\n+        byte[] b = is.readNBytes(5);\n+        System.err.println(\"(read) \" + Thread.currentThread().getName() + \": \" + new String(b));\n+        return b;\n@@ -90,5 +93,2 @@\n-        PrintWriter out = new PrintWriter(\n-            new OutputStreamWriter(sock.getOutputStream()));\n-        out.println(new String(data));\n-        out.flush();\n-        System.err.println(\"(write)\" + name + \": \" + new String(data));\n+        sock.getOutputStream().write(data);\n+        System.err.println(\"(write)\" + Thread.currentThread().getName() + \": \" + new String(data));\n@@ -100,1 +100,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") +\n@@ -116,1 +116,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") +\n@@ -153,0 +153,5 @@\n+        ExecutorService threadPool = Executors.newFixedThreadPool(1,\n+            r -> {\n+                Thread t = Executors.defaultThreadFactory().newThread(r);\n+                return t;\n+            });\n@@ -163,0 +168,1 @@\n+                ssock.setReuseAddress(true);\n@@ -165,0 +171,1 @@\n+                System.out.println(\"Server Port: \" + serverPort);\n@@ -174,11 +181,2 @@\n-                        System.err.println(\"Server ready on port \" +\n-                            serverPort);\n-                        SSLSocket c = (SSLSocket)ssock.accept();\n-                        clientMap.put(c.getPort(), c);\n-                        try {\n-                            write(c, read(c));\n-                        } catch (Exception e) {\n-                            System.out.println(\"Caught \" + e.getMessage());\n-                            e.printStackTrace();\n-                            exceptionList.add(e);\n-                        }\n+                        SSLSocket sock = (SSLSocket)ssock.accept();\n+                        threadPool.submit(new ServerThread(sock));\n@@ -189,0 +187,2 @@\n+                } finally {\n+                    threadPool.close();\n@@ -194,3 +194,2 @@\n-        Server() {\n-            this(new ServerBuilder());\n-        }\n+        class ServerThread extends Thread {\n+            SSLSocket sock;\n@@ -198,42 +197,4 @@\n-        \/**\n-         * @param km - true for an empty key manager\n-         * @param tm - true for an empty trust manager\n-         *\/\n-        Server(boolean km, boolean tm) {\n-            super();\n-            name = \"server\";\n-            try {\n-                sslContext = SSLContext.getInstance(\"TLS\");\n-                sslContext.init(TLSBase.getKeyManager(km),\n-                    TLSBase.getTrustManager(tm), null);\n-                fac = sslContext.getServerSocketFactory();\n-                ssock = (SSLServerSocket) fac.createServerSocket(0);\n-                ssock.setNeedClientAuth(true);\n-                serverPort = ssock.getLocalPort();\n-            } catch (Exception e) {\n-                System.err.println(\"Failure during server initialization\");\n-                e.printStackTrace();\n-            }\n-\n-                \/\/ Thread to allow multiple clients to connect\n-                t = new Thread(() -> {\n-                    try {\n-                        while (true) {\n-                            System.err.println(\"Server ready on port \" +\n-                                serverPort);\n-                            SSLSocket c = (SSLSocket)ssock.accept();\n-                            clientMap.put(c.getPort(), c);\n-                            try {\n-                                write(c, read(c));\n-                            } catch (Exception e) {\n-                                System.out.println(\"Caught \" + e.getMessage());\n-                                e.printStackTrace();\n-                                exceptionList.add(e);\n-                            }\n-                        }\n-                    } catch (Exception ex) {\n-                        System.err.println(\"Server Down\");\n-                        ex.printStackTrace();\n-                    }\n-                });\n-                t.start();\n+            ServerThread(SSLSocket s) {\n+                this.sock = s;\n+                System.err.println(\"ServerThread(\"+sock.getPort()+\")\");\n+                clientMap.put(sock.getPort(), sock);\n@@ -242,17 +203,8 @@\n-        \/\/ Exit test to quit the test.  This must be called at the end of the\n-        \/\/ test or the test will never end.\n-        void done() {\n-            try {\n-                t.join(5000);\n-                ssock.close();\n-            } catch (Exception e) {\n-                System.err.println(e.getMessage());\n-                e.printStackTrace();\n-            }\n-        }\n-\n-        \/\/ Read from the client\n-        byte[] read(Client client) throws Exception {\n-            SSLSocket s = clientMap.get(Integer.valueOf(client.getPort()));\n-            if (s == null) {\n-                System.err.println(\"No socket found, port \" + client.getPort());\n+            public void run() {\n+                try {\n+                    write(sock, read(sock));\n+                } catch (Exception e) {\n+                    System.out.println(\"Caught \" + e.getMessage());\n+                    e.printStackTrace();\n+                    exceptionList.add(e);\n+                }\n@@ -260,1 +212,0 @@\n-            return read(s);\n@@ -263,3 +214,2 @@\n-        \/\/ Write to the client\n-        void write(Client client, byte[] data) throws Exception {\n-            write(clientMap.get(client.getPort()), data);\n+        Server() {\n+            this(new ServerBuilder());\n@@ -268,5 +218,7 @@\n-        \/\/ Server writes to the client, then reads from the client.\n-        \/\/ Return true if the read & write data match, false if not.\n-        boolean writeRead(Client client, String s) throws Exception{\n-            write(client, s.getBytes());\n-            return (Arrays.compare(s.getBytes(), client.read()) == 0);\n+        public SSLSession getSession(Client client) throws Exception {\n+            System.err.println(\"getSession(\"+client.getPort()+\")\");\n+            SSLSocket clientSocket = clientMap.get(client.getPort());\n+            if (clientSocket == null) {\n+                throw new Exception(\"Server can't find client socket\");\n+            }\n+            return clientSocket.getSession();\n@@ -275,4 +227,7 @@\n-        \/\/ Get the SSLSession from the server side socket\n-        SSLSession getSession(Client c) {\n-            SSLSocket s = clientMap.get(Integer.valueOf(c.getPort()));\n-            return s.getSession();\n+        void close(Client client) {\n+            try {\n+                System.err.println(\"close(\"+client.getPort()+\")\");\n+                clientMap.remove(client.getPort()).close();\n+            } catch (Exception e) {\n+                ;\n+            }\n@@ -280,5 +235,7 @@\n-\n-        \/\/ Close client socket\n-        void close(Client c) throws IOException {\n-            SSLSocket s = clientMap.get(Integer.valueOf(c.getPort()));\n-            s.close();\n+        void close() throws InterruptedException {\n+            clientMap.values().stream().forEach(s -> {\n+                try {\n+                    s.close();\n+                } catch (IOException e) {}\n+            });\n+            threadPool.awaitTermination(500, TimeUnit.MILLISECONDS);\n@@ -315,1 +272,1 @@\n-     * Client side will establish a connection from the constructor and wait.\n+     * Client side will establish a SSLContext instance.\n@@ -319,1 +276,1 @@\n-        SSLSocket sock;\n+        public SSLSocket socket;\n@@ -333,5 +290,0 @@\n-            connect();\n-        }\n-\n-        \/\/ Connect to server.  Maybe runnable in the future\n-        public SSLSocket connect() {\n@@ -341,7 +293,1 @@\n-                sock = (SSLSocket)sslContext.getSocketFactory().createSocket();\n-                sock.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), serverPort));\n-                System.err.println(\"Client connected using port \" +\n-                        sock.getLocalPort());\n-                name = \"client(\" + sock.toString() + \")\";\n-                write(\"Hello\");\n-                read();\n+                socket = createSocket();\n@@ -351,1 +297,0 @@\n-            return sock;\n@@ -354,3 +299,3 @@\n-        \/\/ Read from the client socket\n-        byte[] read() throws Exception {\n-            return read(sock);\n+        Client(Client cl) {\n+            sslContext = cl.sslContext;\n+            socket = createSocket();\n@@ -359,3 +304,7 @@\n-        \/\/ Write to the client socket\n-        void write(byte[] data) throws Exception {\n-            write(sock, data);\n+        public SSLSocket createSocket() {\n+            try {\n+                return (SSLSocket) sslContext.getSocketFactory().createSocket();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            return null;\n@@ -363,2 +312,12 @@\n-        void write(String s) throws Exception {\n-            write(sock, s.getBytes());\n+\n+        public SSLSocket connect() {\n+            try {\n+                socket.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), serverPort));\n+                System.err.println(\"Client (\" + Thread.currentThread().getName() + \") connected using port \" +\n+                    socket.getLocalPort() + \" to \" + socket.getPort());\n+                writeRead();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+                return null;\n+            }\n+            return socket;\n@@ -367,5 +326,9 @@\n-        \/\/ Client writes to the server, then reads from the server.\n-        \/\/ Return true if the read & write data match, false if not.\n-        boolean writeRead(Server server, String s) throws Exception {\n-            write(s.getBytes());\n-            return (Arrays.compare(s.getBytes(), server.read(this)) == 0);\n+        public SSLSession getSession() {\n+            return socket.getSession();\n+        }\n+        public void close() {\n+            try {\n+                socket.close();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n@@ -374,3 +337,2 @@\n-        \/\/ Get port from the socket\n-        int getPort() {\n-            return sock.getLocalPort();\n+        public int getPort() {\n+            return socket.getLocalPort();\n@@ -379,3 +341,8 @@\n-        \/\/ Close socket\n-        void close() throws IOException {\n-            sock.close();\n+        private SSLSocket writeRead() {\n+            try {\n+                write(socket, \"Hello\".getBytes(StandardCharsets.ISO_8859_1));\n+                read(socket);\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            return socket;\n@@ -383,0 +350,1 @@\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/TLSBase.java","additions":115,"deletions":147,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main\/timeout=60\/othervm -mx32m FlushCustomClassLoader\n+ * @run main\/timeout=60\/othervm -Xmx32m FlushCustomClassLoader\n","filename":"test\/jdk\/javax\/print\/PrintServiceLookup\/FlushCustomClassLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @run main\/othervm -mx128m AudioContentHandlers\n+ * @run main\/othervm -Xmx128m AudioContentHandlers\n","filename":"test\/jdk\/javax\/sound\/sampled\/Clip\/AudioContentHandlers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,352 @@\n+\/*\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.Raster;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.imageio.ImageIO;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 8338103\n+ * @key headful\n+ * @summary Verifies that the OpenGL pipeline does not create artifacts\n+ * with swing components after window is zoomed to maximum size and then\n+ * resized back to normal. The test case simulates this operation using\n+ * a JButton. A file image of the component will be saved before and after\n+ * the window resize if the test fails. The test passes if both the button\n+ * images are the same.\n+ * @run main\/othervm -Dsun.java2d.opengl=true -Dsun.java2d.opengl.fbobject=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.opengl=true -Dsun.java2d.opengl.fbobject=true SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.opengl=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"windows\")\n+ * @run main\/othervm -Dsun.java2d.d3d=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.d3d=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"linux\")\n+ * @run main\/othervm -Dsun.java2d.xrender=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.xrender=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @run main\/othervm -Dsun.java2d.metal=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.metal=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+public class SwingButtonResizeTestWithOpenGL {\n+    private static Robot robot;\n+    private static CountDownLatch focusGainedLatch;\n+    private JFrame frame;\n+    private JButton button;\n+\n+    public SwingButtonResizeTestWithOpenGL() {\n+\n+        try {\n+            SwingUtilities.invokeAndWait(() -> createGUI());\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Problems creating GUI\");\n+        }\n+    }\n+\n+    private void createGUI() {\n+        frame = new JFrame(\"SwingButtonResizeTestWithOpenGL\");\n+        button = new JButton(\"Button A\");\n+        frame.setLocation(200, 200);\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        button.setPreferredSize(new Dimension(300, 300));\n+        button.setFocusPainted(false);\n+        button.addFocusListener(new FocusAdapter() {\n+            public void focusGained(FocusEvent fe) {\n+                focusGainedLatch.countDown();\n+            }\n+        });\n+        frame.getContentPane().setLayout(new FlowLayout());\n+        frame.getContentPane().add(button);\n+        frame.pack();\n+        frame.setVisible(true);\n+        frame.toFront();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        focusGainedLatch = new CountDownLatch(1);\n+        SwingButtonResizeTestWithOpenGL test =\n+                new SwingButtonResizeTestWithOpenGL();\n+        test.runTest();\n+    }\n+\n+    public void runTest() throws Exception {\n+        BufferedImage bimage1;\n+        BufferedImage bimage2;\n+\n+        try {\n+            robot = new Robot();\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            if (focusGainedLatch.await(3, TimeUnit.SECONDS)) {\n+                System.out.println(\"Button focus gained...\");\n+            } else {\n+                System.out.println(\"Button focus not gained...\");\n+                throw new RuntimeException(\n+                        \"Can't gain focus on button even after waiting \" +\n+                        \"too long..\");\n+            }\n+\n+            System.out.println(\"Getting initial button image..image1\");\n+            bimage1 = getButtonImage();\n+\n+            \/\/ some platforms may not support maximize frame\n+            if (frame.getToolkit().isFrameStateSupported(\n+                    JFrame.MAXIMIZED_BOTH)) {\n+                \/\/ maximize frame from normal size\n+                frame.setExtendedState(JFrame.MAXIMIZED_BOTH);\n+                System.out.println(\"Frame is maximized\");\n+                robot.waitForIdle();\n+                robot.delay(100);\n+\n+                if (frame.getToolkit().isFrameStateSupported(JFrame.NORMAL)) {\n+                    System.out.println(\"Frame is back to normal\");\n+                    \/\/ resize from maximum size to normal\n+                    frame.setExtendedState(JFrame.NORMAL);\n+                    robot.waitForIdle();\n+                    robot.delay(100);\n+                    \/\/ capture image of JButton after resize\n+                    System.out.println(\n+                            \"Getting image of JButton after resize..image2\");\n+                    bimage2 = getButtonImage();\n+\n+                    \/\/ compare button images from before and after frame resize\n+                    DiffImage di = new DiffImage(bimage1.getWidth(),\n+                                                 bimage1.getHeight());\n+                    System.out.println(\n+                            \"Taking the diff of two images, image1 and image2\");\n+                    if (!di.compare(bimage1, bimage2)) {\n+                        throw new RuntimeException(\n+                                \"Button renderings are different after window \"\n+                                + \"resize, num of Diff Pixels=\"\n+                                + di.getNumDiffPixels());\n+                    } else {\n+                        System.out.println(\"Test passed...\");\n+                    }\n+\n+                } else {\n+                    System.out.println(\n+                            \"Test skipped: JFrame.NORMAL resize is \" +\n+                            \"not supported\");\n+                }\n+\n+            } else {\n+                System.out.println(\n+                        \"Test skipped: JFrame.MAXIMIZED_BOTH resize is \" +\n+                        \"not supported\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> disposeFrame());\n+        }\n+    }\n+\n+    \/\/ Capture button rendering as a BufferedImage\n+    private BufferedImage getButtonImage() {\n+        try {\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            AtomicReference<Point> buttonLocRef = new AtomicReference<>();\n+            SwingUtilities.invokeAndWait(\n+                    () -> buttonLocRef.set(button.getLocationOnScreen()));\n+            Point buttonLoc = buttonLocRef.get();\n+            System.out.println(\"Button loc: \" + buttonLoc);\n+            return robot.createScreenCapture(\n+                    new Rectangle(buttonLoc.x, buttonLoc.y, button.getWidth(),\n+                                  button.getHeight()));\n+        } catch (Exception e) {\n+            throw new RuntimeException(\n+                    \"Problems capturing button image from Robot\", e);\n+        }\n+    }\n+\n+    private void disposeFrame() {\n+        if(frame != null) {\n+            frame.dispose();\n+        }\n+    }\n+\n+    \/\/ Save BufferedImage to PNG file\n+    private void saveButtonImage(BufferedImage image, File file) {\n+        if (image != null) {\n+            try {\n+                System.out.println(\n+                        \"Saving button image to \" + file.getAbsolutePath());\n+                ImageIO.write(image, \"PNG\", file);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Could not write image file\");\n+            }\n+        } else {\n+            throw new RuntimeException(\"BufferedImage was set to null\");\n+        }\n+    }\n+\n+    private class DiffImage extends BufferedImage {\n+\n+        public boolean diff = false;\n+        public int nDiff = -1;\n+\n+        Color bgColor;\n+\n+        int threshold = 0;\n+\n+        public DiffImage(int w, int h) {\n+            super(w, h, BufferedImage.TYPE_INT_ARGB);\n+            bgColor = Color.LIGHT_GRAY;\n+        }\n+\n+        public int getNumDiffPixels() {\n+            return nDiff;\n+        }\n+\n+        public boolean compare(BufferedImage img1, BufferedImage img2)\n+                throws IOException {\n+\n+            int minx1 = img1.getMinX();\n+            int minx2 = img2.getMinX();\n+            int miny1 = img1.getMinY();\n+            int miny2 = img2.getMinY();\n+\n+            int w1 = img1.getWidth();\n+            int w2 = img2.getWidth();\n+            int h1 = img1.getHeight();\n+            int h2 = img2.getHeight();\n+\n+            if ((minx1 != minx2) || (miny1 != miny2) || (w1 != w2)\n+                || (h1 != h2)) {\n+                \/\/ image sizes are different\n+                throw new RuntimeException(\n+                        \"img1: <\" + minx1 + \",\" + miny1 + \",\" + w1 + \"x\" + h1\n+                        + \">\" + \" img2: \" + minx2 + \",\" + miny2 + \",\" + w2 + \"x\"\n+                        + h2 + \">\" + \" are different sizes\");\n+            }\n+            \/\/ Get the actual data behind the images\n+            Raster ras1 = img1.getData();\n+            Raster ras2 = img2.getData();\n+\n+            ColorModel cm1 = img1.getColorModel();\n+            ColorModel cm2 = img2.getColorModel();\n+\n+            int r1, r2;  \/\/ red\n+            int g1, g2;  \/\/ green\n+            int b1, b2;  \/\/ blue\n+\n+            Object o1 = null;\n+            Object o2 = null;\n+            nDiff = 0;\n+            for (int x = minx1; x < (minx1 + w1); x++) {\n+                for (int y = miny1; y < (miny1 + h1); y++) {\n+                    \/\/ Causes rasters to allocate data\n+                    o1 = ras1.getDataElements(x, y, o1);\n+                    \/\/ and we reuse the data on every loop\n+                    o2 = ras2.getDataElements(x, y, o2);\n+\n+                    r1 = cm1.getRed(o1);\n+                    r2 = cm2.getRed(o2);\n+                    g1 = cm1.getGreen(o1);\n+                    g2 = cm2.getGreen(o2);\n+                    b1 = cm1.getBlue(o1);\n+                    b2 = cm2.getBlue(o2);\n+\n+                    int redAbs = Math.abs(r1 - r2);\n+                    int greenAbs = Math.abs(g1 - g2);\n+                    int blueAbs = Math.abs(b1 - b2);\n+                    if ((redAbs > threshold)\n+                        || (greenAbs > threshold)\n+                        || (blueAbs > threshold)) {\n+                        \/\/ pixel is different\n+                        setDiffPixel(x, y, redAbs, greenAbs, blueAbs);\n+                        nDiff++;\n+                    } else {\n+                        setSamePixel(x, y);\n+                    }\n+\n+                }\n+            }\n+            if (nDiff != 0) {\n+                ImageIO.write(this, \"png\",\n+                              new File(\"diffImage.png\"));\n+                saveButtonImage(img1, new File(\"image1.png\"));\n+                saveButtonImage(img2, new File(\"image2.png\"));\n+            }\n+            return nDiff == 0;\n+        }\n+\n+        void setDiffPixel(int x, int y, int r, int g, int b) {\n+            diff = true;\n+            setPixelValue(x, y, 255, r, g, b);\n+        }\n+\n+        void setSamePixel(int x, int y) {\n+            if (bgColor != null) {\n+                setPixelValue(x, y, 255, bgColor.getRed(),\n+                              bgColor.getGreen(),\n+                              bgColor.getBlue());\n+            } else {\n+                setPixelValue(x, y, 255, Color.black.getRed(),\n+                              Color.black.getGreen(), Color.black.getBlue());\n+            }\n+        }\n+\n+        void setPixelValue(int x, int y, int a, int r, int g, int b) {\n+            \/\/ setRGB uses BufferedImage.TYPE_INT_ARGB format\n+            int pixel =\n+                    ((a & 0xff) << 24) + ((r & 0xff) << 16) + ((g & 0xff) << 8)\n+                    + ((b & 0xff));\n+            setRGB(x, y, pixel);\n+        }\n+\n+    }\n+\n+}\n+\n+\n","filename":"test\/jdk\/javax\/swing\/JButton\/SwingButtonResizeTestWithOpenGL.java","additions":352,"deletions":0,"binary":false,"changes":352,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm\/timeout=1000 -mx128m TwentyThousandTest\n+ * @run main\/othervm\/timeout=1000 -Xmx128m TwentyThousandTest\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/6396844\/TwentyThousandTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,11 @@\n- * @author Alexey Ivanov\n+ * @requires os.family != \"linux\"\n+ * @modules java.desktop\/sun.swing\n+ * @run main bug8080628\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8080628\n+ * @key headful\n+ * @summary No mnemonics on Open and Save buttons in JFileChooser.\n+ * @requires os.family == \"linux\"\n@@ -84,0 +94,1 @@\n+                    System.out.println(\"Unsupported L&F: \" + info.getClassName());\n@@ -86,0 +97,1 @@\n+                System.out.println(\"Testing L&F: \" + info.getClassName());\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/8080628\/bug8080628.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run main\/othervm -mx128m bug6464022\n+ * @run main\/othervm -Xmx128m bug6464022\n","filename":"test\/jdk\/javax\/swing\/JOptionPane\/6464022\/bug6464022.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6318027\n+ * @key headful\n+ * @summary  Verifies BasicScrollBarUI disables timer when enclosing frame is disabled\n+ * @run main DisableFrameFromScrollBar\n+ *\/\n+\n+import java.awt.FlowLayout;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.AdjustmentEvent;\n+import java.awt.event.AdjustmentListener;\n+import java.awt.event.InputEvent;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JScrollBar;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+\n+public class DisableFrameFromScrollBar {\n+\n+    private static JFrame frame;\n+    private static JScrollBar bar;\n+    private static int oldValue;\n+    private static volatile boolean doCheck;\n+    private static volatile boolean isAdjusting;\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported LAF: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void createUI() {\n+        frame = new JFrame(DisableFrameFromScrollBar.class.getName());\n+        bar = new JScrollBar();\n+        bar.getModel().addChangeListener(new DisableChangeListener(frame));\n+        frame.getContentPane().setLayout(new FlowLayout());\n+        frame.add(bar);\n+\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setSize(150, 150);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo laf : UIManager.getInstalledLookAndFeels()) {\n+            System.out.println(\"Testing LAF : \" + laf.getClassName());\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            try {\n+                SwingUtilities.invokeAndWait(() -> {\n+                    setLookAndFeel(laf);\n+                    createUI();\n+                });\n+\n+                robot.waitForIdle();\n+                robot.delay(1000);\n+                Point point = getClickPoint();\n+                robot.mouseMove(point.x, point.y);\n+                robot.waitForIdle();\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+                SwingUtilities.invokeAndWait(() -> {\n+                    oldValue = bar.getValue();\n+                    bar.addAdjustmentListener(new AdjustmentListener() {\n+                        public void adjustmentValueChanged(AdjustmentEvent e) {\n+                            int curValue = e.getValue();\n+                            int extent = bar.getMaximum() - bar.getVisibleAmount();\n+                            if (curValue < extent && curValue != oldValue) {\n+                                oldValue = curValue;\n+                                isAdjusting = true;\n+                            } else {\n+                                doCheck = true;\n+                                isAdjusting = false;\n+                            }\n+                        }\n+                    });\n+                });\n+                do {\n+                    Thread.sleep(200);\n+                } while (isAdjusting && !doCheck);\n+                if (bar.getValue() == (bar.getMaximum() - bar.getVisibleAmount())) {\n+                    throw new RuntimeException(\"ScrollBar didn't disable timer\");\n+                }\n+            } finally {\n+                SwingUtilities.invokeAndWait(() -> {\n+                    if (frame != null) {\n+                       frame.dispose();\n+                    }\n+               });\n+            }\n+        }\n+    }\n+\n+    private static Point getClickPoint() throws Exception {\n+        final Point[] result = new Point[1];\n+\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+\n+            @Override\n+            public void run() {\n+                Point p = bar.getLocationOnScreen();\n+                Rectangle rect = bar.getBounds();\n+                result[0] = new Point((int) (p.x + rect.width \/ 2),\n+                        (int) (p.y + rect.height - 10));\n+            }\n+        });\n+\n+        return result[0];\n+\n+    }\n+\n+    public static class DisableChangeListener implements ChangeListener {\n+        private final JFrame m_frame;\n+        private boolean m_done;\n+\n+        public DisableChangeListener(JFrame p_frame) {\n+            m_frame = p_frame;\n+        }\n+\n+        public void stateChanged(ChangeEvent p_e) {\n+            if (!m_done) {\n+                m_frame.setEnabled(false);\n+                Thread t = new Thread(new Enabler(m_frame));\n+                t.start();\n+                m_done = true;\n+            }\n+        }\n+    }\n+\n+    public static class Enabler implements Runnable {\n+        private JFrame m_frame;\n+\n+        Enabler(JFrame p_frame) {\n+            m_frame = p_frame;\n+        }\n+\n+        public void run() {\n+            try {\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            m_frame.setEnabled(true);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JScrollBar\/DisableFrameFromScrollBar.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n- * @bug 4112270 8264102\n+ * @bug 4112270 8264102 8329756\n@@ -181,1 +181,1 @@\n-                 and verifying each key combinations against the spec defined.\n+                 and verify each key combination against the spec defined.\n@@ -273,1 +273,1 @@\n-                FN+Up Arrow\/FN+Down Arrow - Deselect current selection;\n+                fn+Up\/Down Arrow - Deselect current selection;\n@@ -276,4 +276,1 @@\n-                Control-FN+Up Arrow\/FN+Down Arrow - Deselect current selection;\n-                                                    move focus and view to\n-                                                    first\/last cell in current row\n-                F2 - Allows editing in a cell containing information without\n+                fn - Allows editing in a cell containing information without\n@@ -283,2 +280,1 @@\n-                Ctrl+A, Ctrl+\/ - Select All\n-                Ctrl+\\\\ - Deselect all\n+                Cmd+A - Select All\n@@ -287,4 +283,3 @@\n-                FN-Shift Up\/Down Arrow -  Extend selection to top\/bottom of column\n-                Shift-PageUp\/PageDown - Extend selection up\/down one view and scroll\n-                                        table\n-                                \"\"\";\n+                Ctrl-Shift Up\/Down Arrow -  Extend selection to top\/bottom of row\n+                Ctrl-Shift Left\/Right Arrow -  Extend selection to first\/last of column\n+                \"\"\";\n","filename":"test\/jdk\/javax\/swing\/JTable\/KeyBoardNavigation.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main\/othervm -mx128m bug6795356\n+ * @run main\/othervm -Xmx128m bug6795356\n","filename":"test\/jdk\/javax\/swing\/UIDefaults\/6795356\/bug6795356.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/timeout=60\/othervm -mx32m TestTitledBorderLeak\n+ * @run main\/timeout=60\/othervm -Xmx32m TestTitledBorderLeak\n","filename":"test\/jdk\/javax\/swing\/border\/TestTitledBorderLeak.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JTable;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+\/*\n+ * @test\n+ * @bug 8338041\n+ * @key headful\n+ * @summary Verify that Ctrl Shift RIGHT\/LEFT key extends columns till\n+ * Last\/First Columns in JTable\n+ * @requires (os.family == \"linux\")\n+ * @run main JTableCtrlShiftRightLeftKeyTest\n+ *\/\n+\n+public class JTableCtrlShiftRightLeftKeyTest {\n+    private static JFrame frame;\n+    private static JTable table;\n+    private static volatile Point tableLoc;\n+    private static volatile Rectangle cellRect;\n+    private static volatile int[] selectedColumnAfterKeyPress;\n+    private static Robot robot;\n+    private static final int SELECTED_COLUMN = 2;\n+\n+    public static void main(String[] args) throws Exception {\n+        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\");\n+        robot = new Robot();\n+        robot.setAutoDelay(50);\n+        try {\n+            SwingUtilities.invokeAndWait(JTableCtrlShiftRightLeftKeyTest::createAndShowUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                tableLoc = table.getLocationOnScreen();\n+                cellRect = table.getCellRect(0, SELECTED_COLUMN, true);\n+            });\n+\n+            robot.mouseMove(tableLoc.x + cellRect.x + cellRect.width \/ 2,\n+                    tableLoc.y + cellRect.y + cellRect.height \/ 2);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            testCtrlShift(KeyEvent.VK_RIGHT, SELECTED_COLUMN,\n+                    table.getColumnCount() - 1, \"RIGHT\");\n+\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            testCtrlShift(KeyEvent.VK_LEFT, 0,\n+                    SELECTED_COLUMN, \"LEFT\");\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            System.out.println(\"Test Passed!\");\n+\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void testCtrlShift(int keySelected, int startCellCheck,\n+                                      int endCellCheck, String key) throws Exception {\n+        robot.keyPress(KeyEvent.VK_SHIFT);\n+        robot.keyPress(KeyEvent.VK_CONTROL);\n+        robot.keyPress(keySelected);\n+        robot.keyRelease(keySelected);\n+        robot.keyRelease(KeyEvent.VK_SHIFT);\n+        robot.keyRelease(KeyEvent.VK_CONTROL);\n+        robot.waitForIdle();\n+        robot.delay(100);\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            selectedColumnAfterKeyPress = table.getSelectedColumns();\n+        });\n+\n+        if (selectedColumnAfterKeyPress[0] != startCellCheck ||\n+                selectedColumnAfterKeyPress[selectedColumnAfterKeyPress.length - 1] !=\n+                        endCellCheck) {\n+            System.out.println(\"Selected Columns: \");\n+            for (int columnsSelected : selectedColumnAfterKeyPress) {\n+                System.out.println(columnsSelected);\n+            }\n+            String failureMsg = \"Test Failure. Failed to select cells for Ctrl\" +\n+                    \" Shift \" + key + \" selection\";\n+            throw new RuntimeException(failureMsg);\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        frame = new JFrame(\"Test Ctrl Shift RIGHT\/LEFT Key Press\");\n+        table = new JTable(2, 5);\n+        table.setColumnSelectionAllowed(true);\n+        frame.getContentPane().add(table);\n+\n+        frame.setSize(200, 200);\n+        frame.setLocationRelativeTo(null);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/gtk\/JTableCtrlShiftRightLeftKeyTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-     * test should provide reasonable heap size via -mx option.\n+     * test should provide reasonable heap size via -Xmx option.\n","filename":"test\/jdk\/javax\/swing\/regtesthelpers\/Util.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-                    codeB.loadConstant(i.opcode(), val);\n+                    codeB.loadConstant(val);\n","filename":"test\/jdk\/jdk\/classfile\/AdaptCodeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,4 +88,4 @@\n-                                    builder.allocateLocal(TypeKind.ReferenceType);\n-                                    builder.allocateLocal(TypeKind.LongType);\n-                                    builder.allocateLocal(TypeKind.IntType);\n-                                    builder.allocateLocal(TypeKind.DoubleType);\n+                                    builder.allocateLocal(TypeKind.REFERENCE);\n+                                    builder.allocateLocal(TypeKind.LONG);\n+                                    builder.allocateLocal(TypeKind.INT);\n+                                    builder.allocateLocal(TypeKind.DOUBLE);\n@@ -327,1 +327,1 @@\n-                                                    storeStack.push(StoreInstruction.of(TypeKind.ReferenceType, slot++));\n+                                                    storeStack.push(StoreInstruction.of(TypeKind.REFERENCE, slot++));\n","filename":"test\/jdk\/jdk\/classfile\/AdvancedTransformationsTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-                                assertEquals(nai.typeKind(), TypeKind.DoubleType);\n+                                assertEquals(nai.typeKind(), TypeKind.DOUBLE);\n","filename":"test\/jdk\/jdk\/classfile\/ArrayTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -262,3 +262,3 @@\n-                              int slot1 = xb.allocateLocal(TypeKind.IntType);\n-                              int slot2 = xb.allocateLocal(TypeKind.LongType);\n-                              int slot3 = xb.allocateLocal(TypeKind.IntType);\n+                              int slot1 = xb.allocateLocal(TypeKind.INT);\n+                              int slot2 = xb.allocateLocal(TypeKind.LONG);\n+                              int slot3 = xb.allocateLocal(TypeKind.INT);\n@@ -280,3 +280,3 @@\n-                                  int slot1 = bb.allocateLocal(TypeKind.IntType);\n-                                  int slot2 = bb.allocateLocal(TypeKind.LongType);\n-                                  int slot3 = bb.allocateLocal(TypeKind.IntType);\n+                                  int slot1 = bb.allocateLocal(TypeKind.INT);\n+                                  int slot2 = bb.allocateLocal(TypeKind.LONG);\n+                                  int slot3 = bb.allocateLocal(TypeKind.INT);\n@@ -288,1 +288,1 @@\n-                              int slot4 = xb.allocateLocal(TypeKind.IntType);\n+                              int slot4 = xb.allocateLocal(TypeKind.INT);\n@@ -302,3 +302,3 @@\n-                                                int slot1 = bb.allocateLocal(TypeKind.IntType);\n-                                                int slot2 = bb.allocateLocal(TypeKind.LongType);\n-                                                int slot3 = bb.allocateLocal(TypeKind.IntType);\n+                                                int slot1 = bb.allocateLocal(TypeKind.INT);\n+                                                int slot2 = bb.allocateLocal(TypeKind.LONG);\n+                                                int slot3 = bb.allocateLocal(TypeKind.INT);\n@@ -311,1 +311,1 @@\n-                                                int slot1 = bb.allocateLocal(TypeKind.IntType);\n+                                                int slot1 = bb.allocateLocal(TypeKind.INT);\n@@ -315,1 +315,1 @@\n-                              int slot4 = xb.allocateLocal(TypeKind.IntType);\n+                              int slot4 = xb.allocateLocal(TypeKind.INT);\n@@ -338,1 +338,1 @@\n-                var i = cob.allocateLocal(TypeKind.IntType);\n+                var i = cob.allocateLocal(TypeKind.INT);\n@@ -376,2 +376,2 @@\n-                    int d = cob.allocateLocal(TypeKind.IntType);\n-                    int e = cob.allocateLocal(TypeKind.IntType);\n+                    int d = cob.allocateLocal(TypeKind.INT);\n+                    int e = cob.allocateLocal(TypeKind.INT);\n","filename":"test\/jdk\/jdk\/classfile\/BuilderBlockTest.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-                            int stringSlot = xb.allocateLocal(TypeKind.ReferenceType);\n+                            int stringSlot = xb.allocateLocal(TypeKind.REFERENCE);\n@@ -221,1 +221,1 @@\n-                            int stringSlot = xb.allocateLocal(TypeKind.ReferenceType);\n+                            int stringSlot = xb.allocateLocal(TypeKind.REFERENCE);\n@@ -226,1 +226,1 @@\n-                                int intSlot = tb.allocateLocal(TypeKind.IntType);\n+                                int intSlot = tb.allocateLocal(TypeKind.INT);\n@@ -243,1 +243,1 @@\n-                                    int doubleSlot = tb.allocateLocal(TypeKind.DoubleType);\n+                                    int doubleSlot = tb.allocateLocal(TypeKind.DOUBLE);\n@@ -253,1 +253,1 @@\n-                                    int refSlot = tb.allocateLocal(TypeKind.ReferenceType);\n+                                    int refSlot = tb.allocateLocal(TypeKind.REFERENCE);\n@@ -284,1 +284,1 @@\n-                            int stringSlot = xb.allocateLocal(TypeKind.ReferenceType);\n+                            int stringSlot = xb.allocateLocal(TypeKind.REFERENCE);\n","filename":"test\/jdk\/jdk\/classfile\/BuilderTryCatchTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-                                                  ClassDesc.of(\"Boo\"), List.of()))))))\n+                                                  Annotation.of(ClassDesc.of(\"Boo\"), List.of())))))))\n@@ -104,1 +104,1 @@\n-                                                ClassDesc.of(\"Boo\"), List.of())));\n+                                                Annotation.of(ClassDesc.of(\"Boo\"), List.of()))));\n@@ -119,1 +119,1 @@\n-                                          ClassDesc.of(\"Fee\"), List.of(AnnotationElement.ofBoolean(\"yes\", false)))))\n+                                          Annotation.of(ClassDesc.of(\"Fee\"), List.of(AnnotationElement.ofBoolean(\"yes\", false))))))\n","filename":"test\/jdk\/jdk\/classfile\/ClassPrinterTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304031 8338406\n+ * @summary Testing handling of various constant descriptors in ClassFile API.\n+ * @run junit ConstantDescSymbolsTest\n+ *\/\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.function.Supplier;\n+import java.lang.classfile.ClassFile;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class ConstantDescSymbolsTest {\n+\n+    \/\/ Testing that primitive class descs are encoded properly as loadable constants.\n+    @Test\n+    void testPrimitiveClassDesc() throws Throwable {\n+        ClassDesc ape = ClassDesc.of(\"Ape\");\n+        var lookup = MethodHandles.lookup();\n+        Class<?> a = lookup.defineClass(ClassFile.of().build(ape, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow());\n+            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> {\n+                cob.loadConstant(CD_int);\n+                cob.areturn();\n+            });\n+            clb.withMethodBody(\"get2\", MethodTypeDesc.of(CD_Class), ACC_PUBLIC, cob -> {\n+                Assertions.assertThrows(IllegalArgumentException.class, () -> cob.constantPool().classEntry(CD_long));\n+                var t = cob.constantPool().loadableConstantEntry(CD_long);\n+                cob.ldc(t);\n+                cob.areturn();\n+            });\n+        }));\n+        Supplier<?> t = (Supplier<?>) lookup.findConstructor(a, MethodType.methodType(void.class))\n+                .asType(MethodType.methodType(Supplier.class))\n+                .invokeExact();\n+        assertSame(int.class, t.get());\n+    }\n+\n+    \/\/ Tests that condy symbols with non-static-method bootstraps are using the right lookup descriptor.\n+    @Test\n+    void testConstantDynamicNonStaticBootstrapMethod() throws Throwable {\n+        record CondyBoot(MethodHandles.Lookup lookup, String name, Class<?> type) {}\n+        var bootClass = CondyBoot.class.describeConstable().orElseThrow();\n+        var bootMhDesc = MethodHandleDesc.ofConstructor(bootClass, CD_MethodHandles_Lookup, CD_String, CD_Class);\n+        var condyDesc = DynamicConstantDesc.of(bootMhDesc);\n+\n+        var targetCd = ClassDesc.of(\"Bat\");\n+        var lookup = MethodHandles.lookup();\n+        Class<?> a = lookup.defineClass(ClassFile.of().build(targetCd, clb -> {\n+            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow())\n+                    .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> cob\n+                            .aload(0).invokespecial(CD_Object, INIT_NAME, MTD_void).return_())\n+                    .withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> cob\n+                            .loadConstant(condyDesc).areturn());\n+        }));\n+        @SuppressWarnings(\"unchecked\")\n+        Supplier<CondyBoot> t = (Supplier<CondyBoot>) lookup.findConstructor(a, MethodType.methodType(void.class))\n+                .asType(MethodType.methodType(Supplier.class)).invokeExact();\n+        var cb = t.get();\n+        assertEquals(MethodHandles.Lookup.ORIGINAL, cb.lookup.lookupModes() & MethodHandles.Lookup.ORIGINAL);\n+        assertSame(a, cb.lookup.lookupClass());\n+        assertEquals(DEFAULT_NAME, cb.name);\n+        assertEquals(CondyBoot.class, cb.type);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ConstantDescSymbolsTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -67,3 +67,3 @@\n-                                  c0.loadConstant(LDC, \"string0\")\n-                                    .loadConstant(LDC, \"string131\")\n-                                    .loadConstant(LDC, \"string50\")\n+                                  c0.ldc(\"string0\")\n+                                    .ldc(\"string131\")\n+                                    .ldc(\"string50\")\n","filename":"test\/jdk\/jdk\/classfile\/LDCTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @bug 8339368\n@@ -30,4 +31,0 @@\n-\n-import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n-import static java.lang.classfile.ClassFile.ACC_STATIC;\n-import static java.lang.constant.ConstantDescs.*;\n@@ -35,2 +32,0 @@\n-import java.util.List;\n-\n@@ -44,2 +39,2 @@\n-import static org.junit.jupiter.api.Assertions.*;\n-import org.junit.jupiter.api.Test;\n+import java.lang.classfile.instruction.*;\n+import java.util.List;\n@@ -47,7 +42,1 @@\n-import java.lang.classfile.instruction.ConstantInstruction;\n-import java.lang.classfile.instruction.StoreInstruction;\n-import java.lang.classfile.instruction.BranchInstruction;\n-import java.lang.classfile.instruction.LoadInstruction;\n-import java.lang.classfile.instruction.OperatorInstruction;\n-import java.lang.classfile.instruction.FieldInstruction;\n-import java.lang.classfile.instruction.InvokeInstruction;\n+import org.junit.jupiter.api.Test;\n@@ -55,0 +44,4 @@\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.classfile.Opcode.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -59,1 +52,1 @@\n-import static java.lang.classfile.Opcode.*;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -159,0 +152,32 @@\n+\n+    @Test\n+    void testJava5ClassWriteRead() {\n+        MethodModel mm = ClassFile.of().parse(ClassFile.of().build(ClassDesc.of(\"MyClass\"), clb -> clb\n+                .withVersion(ClassFile.JAVA_5_VERSION, 0)\n+                .withMethodBody(\"switches\", MTD_void, ACC_STATIC, cob -> {\n+                    Label l1 = cob.newLabel(), l2 = cob.newLabel(), l3 = cob.newLabel(), l4 = cob.newLabel();\n+                    cob.iconst_0()\n+                       .tableswitch(l1, List.of(SwitchCase.of(0, l2)))\n+                       .labelBinding(l1)\n+                       .nop()\n+                       .labelBinding(l2)\n+                       .iconst_0()\n+                       .lookupswitch(l3, List.of(SwitchCase.of(0, l4)))\n+                       .labelBinding(l3)\n+                       .nop()\n+                       .labelBinding(l4)\n+                       .return_();\n+                }))).methods().getFirst();\n+        var it = mm.code().orElseThrow().iterator();\n+        while (!(it.next() instanceof ConstantInstruction));\n+        assertTrue(it.next() instanceof TableSwitchInstruction tsi\n+                   && it.next() instanceof LabelTarget lt1 && lt1.label().equals(tsi.defaultTarget())\n+                   && it.next() instanceof NopInstruction\n+                   && it.next() instanceof LabelTarget lt2 && lt2.label().equals(tsi.cases().getFirst().target())\n+                   && it.next() instanceof ConstantInstruction\n+                   && it.next() instanceof LookupSwitchInstruction lsi\n+                   && it.next() instanceof LabelTarget lt3 && lt3.label().equals(lsi.defaultTarget())\n+                   && it.next() instanceof NopInstruction\n+                   && it.next() instanceof LabelTarget lt4 && lt4.label().equals(lsi.cases().getFirst().target()),\n+                () -> mm.code().get().elementList().toString());\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/OneToOneTest.java","additions":41,"deletions":16,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @summary Testing ClassFile constant instruction opcodes.\n+ * @summary Testing ClassFile constant instruction argument validation.\n@@ -29,4 +29,2 @@\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDesc;\n-import static java.lang.constant.ConstantDescs.CD_void;\n-import java.lang.constant.MethodTypeDesc;\n+import java.lang.classfile.instruction.ConstantInstruction;\n+import org.junit.jupiter.api.Test;\n@@ -34,5 +32,0 @@\n-import java.lang.reflect.AccessFlag;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.Opcode;\n-import org.junit.jupiter.api.*;\n-import static org.junit.jupiter.api.DynamicTest.dynamicTest;\n@@ -41,1 +34,0 @@\n-import java.util.stream.Stream;\n@@ -43,85 +35,15 @@\n-public class OpcodesValidationTest {\n-\n-    record Case(Opcode opcode, Object constant) {}\n-\n-    static Stream<Case> positiveCases() {\n-        return Stream.of(\n-            new Case(ACONST_NULL, null),\n-            new Case(SIPUSH, (int)Short.MIN_VALUE),\n-            new Case(SIPUSH, (int)Short.MAX_VALUE),\n-            new Case(BIPUSH, (int)Byte.MIN_VALUE),\n-            new Case(BIPUSH, (int)Byte.MAX_VALUE),\n-            new Case(ICONST_M1, -1),\n-            new Case(ICONST_0, 0),\n-            new Case(ICONST_1, 1),\n-            new Case(ICONST_2, 2),\n-            new Case(ICONST_3, 3),\n-            new Case(ICONST_4, 4),\n-            new Case(ICONST_5, 5),\n-            new Case(LCONST_0, 0l),\n-            new Case(LCONST_0, 0),\n-            new Case(LCONST_1, 1l),\n-            new Case(LCONST_1, 1),\n-            new Case(FCONST_0, 0.0f),\n-            new Case(FCONST_1, 1.0f),\n-            new Case(FCONST_2, 2.0f),\n-            new Case(DCONST_0, 0.0d),\n-            new Case(DCONST_1, 1.0d)\n-        );\n-    }\n-\n-    static Stream<Case> negativeCases() {\n-        return Stream.of(\n-            new Case(ACONST_NULL, 0),\n-            new Case(SIPUSH, (int)Short.MIN_VALUE - 1),\n-            new Case(SIPUSH, (int)Short.MAX_VALUE + 1),\n-            new Case(BIPUSH, (int)Byte.MIN_VALUE - 1),\n-            new Case(BIPUSH, (int)Byte.MAX_VALUE + 1),\n-            new Case(ICONST_M1, -1l),\n-            new Case(ICONST_0, 0l),\n-            new Case(ICONST_1, 1l),\n-            new Case(ICONST_2, 2l),\n-            new Case(ICONST_3, 3l),\n-            new Case(ICONST_4, 4l),\n-            new Case(ICONST_5, 5l),\n-            new Case(LCONST_0, null),\n-            new Case(LCONST_0, 1l),\n-            new Case(LCONST_1, 1.0d),\n-            new Case(LCONST_1, 0),\n-            new Case(FCONST_0, 0.0d),\n-            new Case(FCONST_1, 1.01f),\n-            new Case(FCONST_2, 2),\n-            new Case(DCONST_0, 0.0f),\n-            new Case(DCONST_1, 1.0f),\n-            new Case(DCONST_1, 1)\n-        );\n-    }\n-\n-    @TestFactory\n-    Stream<DynamicTest> testPositiveCases() {\n-        return positiveCases().map(c -> dynamicTest(c.toString(), () -> testPositiveCase(c.opcode, c.constant)));\n-    }\n-\n-    private void testPositiveCase(Opcode opcode, Object constant) {\n-        ClassFile.of().build(ClassDesc.of(\"MyClass\"),\n-                        cb -> cb.withFlags(AccessFlag.PUBLIC)\n-                                .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0,\n-                                      mb -> mb.withCode(\n-                                              codeb -> codeb.loadConstant(opcode, (ConstantDesc) constant))));\n-    }\n-\n-\n-    @TestFactory\n-    Stream<DynamicTest> testNegativeCases() {\n-        return negativeCases().map(c -> dynamicTest(\n-            c.toString(),\n-            () -> assertThrows(IllegalArgumentException.class, () -> testNegativeCase(c.opcode, c.constant))\n-        ));\n-    }\n-\n-    private void testNegativeCase(Opcode opcode, Object constant) {\n-        ClassFile.of().build(ClassDesc.of(\"MyClass\"),\n-                        cb -> cb.withFlags(AccessFlag.PUBLIC)\n-                                .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0,\n-                        mb -> mb .withCode(\n-                                codeb -> codeb.loadConstant(opcode, (ConstantDesc)constant))));\n+class OpcodesValidationTest {\n+\n+    @Test\n+    void testArgumentConstant() {\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, 0));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MIN_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MAX_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, 0));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MIN_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MAX_VALUE));\n+\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int)Short.MIN_VALUE - 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int)Short.MAX_VALUE + 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int)Byte.MIN_VALUE - 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int)Byte.MAX_VALUE + 1));\n","filename":"test\/jdk\/jdk\/classfile\/OpcodesValidationTest.java","additions":19,"deletions":97,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8304031\n- * @summary Testing that primitive class descs are encoded properly as loadable constants.\n- * @run junit PrimitiveClassConstantTest\n- *\/\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.function.Supplier;\n-import java.lang.classfile.ClassFile;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import static java.lang.constant.ConstantDescs.CD_Class;\n-import static java.lang.constant.ConstantDescs.CD_Object;\n-import static java.lang.constant.ConstantDescs.CD_int;\n-import static java.lang.constant.ConstantDescs.CD_long;\n-import static java.lang.constant.ConstantDescs.INIT_NAME;\n-import static java.lang.constant.ConstantDescs.MTD_void;\n-import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n-\n-public final class PrimitiveClassConstantTest {\n-\n-    @Test\n-    public void test() throws Throwable {\n-        ClassDesc ape = ClassDesc.of(\"Ape\");\n-        var lookup = MethodHandles.lookup();\n-        Class<?> a = lookup.defineClass(ClassFile.of().build(ape, clb -> {\n-            clb.withSuperclass(CD_Object);\n-            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow());\n-            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n-                cob.aload(0);\n-                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n-                cob.return_();\n-            });\n-            clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> {\n-                cob.loadConstant(CD_int);\n-                cob.areturn();\n-            });\n-            clb.withMethodBody(\"get2\", MethodTypeDesc.of(CD_Class), ACC_PUBLIC, cob -> {\n-                Assertions.assertThrows(IllegalArgumentException.class, () -> cob.constantPool().classEntry(CD_long));\n-                var t = cob.constantPool().loadableConstantEntry(CD_long);\n-                cob.ldc(t);\n-                cob.areturn();\n-            });\n-        }));\n-        Supplier<?> t = (Supplier<?>) lookup.findConstructor(a, MethodType.methodType(void.class))\n-                .asType(MethodType.methodType(Supplier.class))\n-                .invokeExact();\n-        Assertions.assertSame(int.class, t.get());\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/classfile\/PrimitiveClassConstantTest.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8305990 8320222 8320618 8335475\n+ * @bug 8305990 8320222 8320618 8335475 8338623 8338661\n@@ -34,0 +34,2 @@\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n@@ -35,0 +37,4 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -39,0 +45,1 @@\n+import java.util.List;\n@@ -43,1 +50,0 @@\n-import static java.lang.constant.ConstantDescs.MTD_void;\n@@ -47,5 +53,1 @@\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.reflect.AccessFlag;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -344,0 +346,53 @@\n+\n+    private static final MethodTypeDesc MTD_int = MethodTypeDesc.of(CD_int);\n+    private static final MethodTypeDesc MTD_int_String = MethodTypeDesc.of(CD_int, CD_String);\n+\n+    @ParameterizedTest\n+    @EnumSource(ClassFile.StackMapsOption.class)\n+    void testInvocationCounters(ClassFile.StackMapsOption option) {\n+        var cf = ClassFile.of(option);\n+        var cd = ClassDesc.of(\"Test\");\n+        var bytes = cf.build(cd, clb -> clb\n+            .withMethodBody(\"a\", MTD_int_String, ACC_STATIC, cob -> cob\n+                    .aload(0)\n+                    .invokevirtual(CD_String, \"hashCode\", MTD_int)\n+                    .ireturn())\n+            .withMethodBody(\"b\", MTD_int, 0, cob -> cob\n+                    .aload(0)\n+                    .invokevirtual(cd, \"hashCode\", MTD_int)\n+                    .ireturn())\n+        );\n+\n+        var cm = ClassFile.of().parse(bytes);\n+        for (var method : cm.methods()) {\n+            var code = method.findAttribute(Attributes.code()).orElseThrow();\n+            assertEquals(1, code.maxLocals());\n+            assertEquals(1, code.maxStack());\n+        }\n+    }\n+\n+    @Test\n+    void testDeadCodeCountersWithCustomSMTA() {\n+        ClassDesc bar = ClassDesc.of(\"Bar\");\n+        byte[] bytes = ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS).build(bar, clb -> clb\n+                .withMethodBody(\n+                        \"foo\", MethodTypeDesc.of(ConstantDescs.CD_long), ACC_STATIC, cob -> {\n+                            cob.lconst_0().lreturn();\n+                            Label f2 = cob.newBoundLabel();\n+                            cob.lstore(0);\n+                            Label f3 = cob.newBoundLabel();\n+                            cob.lload(0).lreturn().with(\n+                                    StackMapTableAttribute.of(List.of(\n+                                    StackMapFrameInfo.of(f2,\n+                                            List.of(),\n+                                            List.of(StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_LONG)),\n+                                    StackMapFrameInfo.of(f3,\n+                                            List.of(StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_LONG),\n+                                            List.of()))));\n+                        }\n+                ));\n+        assertEmpty(ClassFile.of().verify(bytes));\n+        var code = (CodeAttribute) ClassFile.of().parse(bytes).methods().getFirst().code().orElseThrow();\n+        assertEquals(2, code.maxLocals());\n+        assertEquals(2, code.maxStack());\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":62,"deletions":7,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-                var stackTracker = CodeStackTracker.of(DoubleType, FloatType); \/\/initial stack tracker pre-set\n+                var stackTracker = CodeStackTracker.of(DOUBLE, FLOAT); \/\/initial stack tracker pre-set\n@@ -50,1 +50,1 @@\n-                    assertIterableEquals(stackTracker.stack().get(), List.of(DoubleType, FloatType));\n+                    assertIterableEquals(stackTracker.stack().get(), List.of(DOUBLE, FLOAT));\n@@ -52,1 +52,1 @@\n-                    assertIterableEquals(stackTracker.stack().get(), List.of(ReferenceType, DoubleType, FloatType));\n+                    assertIterableEquals(stackTracker.stack().get(), List.of(REFERENCE, DOUBLE, FLOAT));\n@@ -54,1 +54,1 @@\n-                    assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                    assertIterableEquals(stackTracker.stack().get(), List.of(LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -56,1 +56,1 @@\n-                        assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -58,1 +58,1 @@\n-                        assertIterableEquals(stackTracker.stack().get(), List.of(IntType, LongType, ReferenceType, DoubleType, FloatType));\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(INT, LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -60,1 +60,1 @@\n-                            assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                            assertIterableEquals(stackTracker.stack().get(), List.of(LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -62,1 +62,1 @@\n-                            assertIterableEquals(stackTracker.stack().get(), List.of(ReferenceType, LongType, ReferenceType, DoubleType, FloatType));\n+                            assertIterableEquals(stackTracker.stack().get(), List.of(REFERENCE, LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -66,1 +66,1 @@\n-                        assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -70,1 +70,1 @@\n-                        assertIterableEquals(stackTracker.stack().get(), List.of(ReferenceType));\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(REFERENCE));\n","filename":"test\/jdk\/jdk\/classfile\/StackTrackerTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,0 @@\n-import static java.lang.classfile.Opcode.INVOKESPECIAL;\n-import static java.lang.classfile.TypeKind.VoidType;\n","filename":"test\/jdk\/jdk\/classfile\/TempConstantPoolBuilderTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8336010 8336588\n+ * @bug 8335935 8336588\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-import static java.lang.classfile.TypeKind.VoidType;\n","filename":"test\/jdk\/jdk\/classfile\/Utf8EntryTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Opcode;\n@@ -30,0 +32,5 @@\n+import java.lang.invoke.MethodHandles;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+\n+import jdk.internal.classfile.impl.RawBytecodeHelper;\n@@ -79,0 +86,17 @@\n+\n+    @Test\n+    void testOpcodeLengthTable() {\n+        var lengths = new byte[0x100];\n+        Arrays.fill(lengths, (byte) -1);\n+        for (var op : Opcode.values()) {\n+            if (!op.isWide()) {\n+                lengths[op.bytecode()] = (byte) op.sizeIfFixed();\n+            } else {\n+                \/\/ Wide pseudo-opcodes have double the length as normal variants\n+                \/\/ Must match logic in checkSpecialInstruction()\n+                assertEquals(op.sizeIfFixed(), lengths[op.bytecode() & 0xFF] * 2, op + \" size\");\n+            }\n+        }\n+\n+        assertArrayEquals(lengths, RawBytecodeHelper.LENGTHS);\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -523,1 +523,1 @@\n-                        new ConstantPoolEntryRecord.CpClassRecord(\"[\" + cins.typeKind().descriptor()).hashCode() + 1;\n+                        new ConstantPoolEntryRecord.CpClassRecord(\"[\" + cins.typeKind().upperBound().descriptorString()).hashCode() + 1;\n@@ -831,1 +831,1 @@\n-                    AnnotationRecord.ofAnnotation(ann));\n+                    AnnotationRecord.ofAnnotation(ann.annotation()));\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/ClassRecord.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-                cb.loadConstant(im.opcode(), im.constantValue());\n+                cb.loadConstant(im.constantValue());\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/InstructionModelToCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -182,2 +182,1 @@\n-                        ta.classSymbol(),\n-                        ta.elements().stream().map(ae -> AnnotationElement.of(ae.name().stringValue(), transformAnnotationValue(ae.value()))).toList())).toArray(TypeAnnotation[]::new);\n+                        transformAnnotation(ta.annotation()))).toArray(TypeAnnotation[]::new);\n@@ -223,8 +222,8 @@\n-                        case ByteType -> cob.baload();\n-                        case ShortType -> cob.saload();\n-                        case IntType -> cob.iaload();\n-                        case FloatType -> cob.faload();\n-                        case LongType -> cob.laload();\n-                        case DoubleType -> cob.daload();\n-                        case ReferenceType -> cob.aaload();\n-                        case CharType -> cob.caload();\n+                        case BYTE -> cob.baload();\n+                        case SHORT -> cob.saload();\n+                        case INT -> cob.iaload();\n+                        case FLOAT -> cob.faload();\n+                        case LONG -> cob.laload();\n+                        case DOUBLE -> cob.daload();\n+                        case REFERENCE -> cob.aaload();\n+                        case CHAR -> cob.caload();\n@@ -236,8 +235,8 @@\n-                        case ByteType -> cob.bastore();\n-                        case ShortType -> cob.sastore();\n-                        case IntType -> cob.iastore();\n-                        case FloatType -> cob.fastore();\n-                        case LongType -> cob.lastore();\n-                        case DoubleType -> cob.dastore();\n-                        case ReferenceType -> cob.aastore();\n-                        case CharType -> cob.castore();\n+                        case BYTE -> cob.bastore();\n+                        case SHORT -> cob.sastore();\n+                        case INT -> cob.iastore();\n+                        case FLOAT -> cob.fastore();\n+                        case LONG -> cob.lastore();\n+                        case DOUBLE -> cob.dastore();\n+                        case REFERENCE -> cob.aastore();\n+                        case CHAR -> cob.castore();\n@@ -308,1 +307,1 @@\n-                        case DoubleType -> {\n+                        case DOUBLE -> {\n@@ -310,3 +309,3 @@\n-                                case FloatType -> cob.d2f();\n-                                case IntType -> cob.d2i();\n-                                case LongType -> cob.d2l();\n+                                case FLOAT -> cob.d2f();\n+                                case INT -> cob.d2i();\n+                                case LONG -> cob.d2l();\n@@ -316,1 +315,1 @@\n-                        case FloatType -> {\n+                        case FLOAT -> {\n@@ -318,3 +317,3 @@\n-                                case DoubleType -> cob.f2d();\n-                                case IntType -> cob.f2i();\n-                                case LongType -> cob.f2l();\n+                                case DOUBLE -> cob.f2d();\n+                                case INT -> cob.f2i();\n+                                case LONG -> cob.f2l();\n@@ -324,1 +323,1 @@\n-                        case IntType -> {\n+                        case INT -> {\n@@ -326,6 +325,6 @@\n-                                case ByteType -> cob.i2b();\n-                                case CharType -> cob.i2c();\n-                                case DoubleType -> cob.i2d();\n-                                case FloatType -> cob.i2f();\n-                                case LongType -> cob.i2l();\n-                                case ShortType -> cob.i2s();\n+                                case BYTE -> cob.i2b();\n+                                case CHAR -> cob.i2c();\n+                                case DOUBLE -> cob.i2d();\n+                                case FLOAT -> cob.i2f();\n+                                case LONG -> cob.i2l();\n+                                case SHORT -> cob.i2s();\n@@ -335,1 +334,1 @@\n-                        case LongType -> {\n+                        case LONG -> {\n@@ -337,3 +336,3 @@\n-                                case DoubleType -> cob.l2d();\n-                                case FloatType -> cob.l2f();\n-                                case IntType -> cob.l2i();\n+                                case DOUBLE -> cob.l2d();\n+                                case FLOAT -> cob.l2f();\n+                                case INT -> cob.l2i();\n@@ -414,5 +413,5 @@\n-                        case IntType -> cob.iload(i.slot());\n-                        case FloatType -> cob.fload(i.slot());\n-                        case LongType -> cob.lload(i.slot());\n-                        case DoubleType -> cob.dload(i.slot());\n-                        case ReferenceType -> cob.aload(i.slot());\n+                        case INT -> cob.iload(i.slot());\n+                        case FLOAT -> cob.fload(i.slot());\n+                        case LONG -> cob.lload(i.slot());\n+                        case DOUBLE -> cob.dload(i.slot());\n+                        case REFERENCE -> cob.aload(i.slot());\n@@ -424,5 +423,5 @@\n-                        case IntType -> cob.istore(i.slot());\n-                        case FloatType -> cob.fstore(i.slot());\n-                        case LongType -> cob.lstore(i.slot());\n-                        case DoubleType -> cob.dstore(i.slot());\n-                        case ReferenceType -> cob.astore(i.slot());\n+                        case INT -> cob.istore(i.slot());\n+                        case FLOAT -> cob.fstore(i.slot());\n+                        case LONG -> cob.lstore(i.slot());\n+                        case DOUBLE -> cob.dstore(i.slot());\n+                        case REFERENCE -> cob.astore(i.slot());\n@@ -519,6 +518,6 @@\n-                        case IntType -> cob.ireturn();\n-                        case FloatType -> cob.freturn();\n-                        case LongType -> cob.lreturn();\n-                        case DoubleType -> cob.dreturn();\n-                        case ReferenceType -> cob.areturn();\n-                        case VoidType -> cob.return_();\n+                        case INT -> cob.ireturn();\n+                        case FLOAT -> cob.freturn();\n+                        case LONG -> cob.lreturn();\n+                        case DOUBLE -> cob.dreturn();\n+                        case REFERENCE -> cob.areturn();\n+                        case VOID -> cob.return_();\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":52,"deletions":53,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(byte[] r, byte[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -234,19 +242,0 @@\n-    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -707,15 +696,0 @@\n-    interface FBinArrayOp {\n-        byte apply(byte[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(byte[] r, byte[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1215,4 +1189,0 @@\n-    static byte get(byte[] a, int i) {\n-        return (byte) a[i];\n-    }\n-\n@@ -3751,2 +3721,2 @@\n-    @Test(dataProvider = \"byteUnaryOpProvider\")\n-    static void withByte128VectorTests(IntFunction<byte []> fa) {\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void withByte128VectorTests(IntFunction<byte []> fa, IntFunction<byte []> fb) {\n@@ -3754,0 +3724,1 @@\n+        byte[] b = fb.apply(SPECIES.length());\n@@ -3759,1 +3730,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3764,3 +3737,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (byte)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4701,1 +4672,1 @@\n-        assertArraysEquals(r, a, Byte128VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(byte[] r, byte[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -234,19 +242,0 @@\n-    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -707,15 +696,0 @@\n-    interface FBinArrayOp {\n-        byte apply(byte[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(byte[] r, byte[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1215,4 +1189,0 @@\n-    static byte get(byte[] a, int i) {\n-        return (byte) a[i];\n-    }\n-\n@@ -3751,2 +3721,2 @@\n-    @Test(dataProvider = \"byteUnaryOpProvider\")\n-    static void withByte256VectorTests(IntFunction<byte []> fa) {\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void withByte256VectorTests(IntFunction<byte []> fa, IntFunction<byte []> fb) {\n@@ -3754,0 +3724,1 @@\n+        byte[] b = fb.apply(SPECIES.length());\n@@ -3759,1 +3730,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3764,3 +3737,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (byte)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4701,1 +4672,1 @@\n-        assertArraysEquals(r, a, Byte256VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(byte[] r, byte[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -234,19 +242,0 @@\n-    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -707,15 +696,0 @@\n-    interface FBinArrayOp {\n-        byte apply(byte[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(byte[] r, byte[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1215,4 +1189,0 @@\n-    static byte get(byte[] a, int i) {\n-        return (byte) a[i];\n-    }\n-\n@@ -3751,2 +3721,2 @@\n-    @Test(dataProvider = \"byteUnaryOpProvider\")\n-    static void withByte512VectorTests(IntFunction<byte []> fa) {\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void withByte512VectorTests(IntFunction<byte []> fa, IntFunction<byte []> fb) {\n@@ -3754,0 +3724,1 @@\n+        byte[] b = fb.apply(SPECIES.length());\n@@ -3759,1 +3730,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3764,3 +3737,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (byte)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4701,1 +4672,1 @@\n-        assertArraysEquals(r, a, Byte512VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(byte[] r, byte[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -234,19 +242,0 @@\n-    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -707,15 +696,0 @@\n-    interface FBinArrayOp {\n-        byte apply(byte[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(byte[] r, byte[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1215,4 +1189,0 @@\n-    static byte get(byte[] a, int i) {\n-        return (byte) a[i];\n-    }\n-\n@@ -3751,2 +3721,2 @@\n-    @Test(dataProvider = \"byteUnaryOpProvider\")\n-    static void withByte64VectorTests(IntFunction<byte []> fa) {\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void withByte64VectorTests(IntFunction<byte []> fa, IntFunction<byte []> fb) {\n@@ -3754,0 +3724,1 @@\n+        byte[] b = fb.apply(SPECIES.length());\n@@ -3759,1 +3730,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3764,3 +3737,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (byte)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4701,1 +4672,1 @@\n-        assertArraysEquals(r, a, Byte64VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -75,0 +75,8 @@\n+    static void assertArraysStrictlyEquals(byte[] r, byte[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -239,19 +247,0 @@\n-    static void assertInsertArraysEquals(byte[] r, byte[] a, byte element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -712,15 +701,0 @@\n-    interface FBinArrayOp {\n-        byte apply(byte[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(byte[] r, byte[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1220,4 +1194,0 @@\n-    static byte get(byte[] a, int i) {\n-        return (byte) a[i];\n-    }\n-\n@@ -3756,2 +3726,2 @@\n-    @Test(dataProvider = \"byteUnaryOpProvider\")\n-    static void withByteMaxVectorTests(IntFunction<byte []> fa) {\n+    @Test(dataProvider = \"byteBinaryOpProvider\")\n+    static void withByteMaxVectorTests(IntFunction<byte []> fa, IntFunction<byte []> fb) {\n@@ -3759,0 +3729,1 @@\n+        byte[] b = fb.apply(SPECIES.length());\n@@ -3764,1 +3735,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (byte)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3769,3 +3742,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (byte)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4706,1 +4677,1 @@\n-        assertArraysEquals(r, a, ByteMaxVectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -74,0 +74,10 @@\n+    static void assertArraysStrictlyEquals(double[] r, double[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            long ir = Double.doubleToRawLongBits(r[i]);\n+            long ia = Double.doubleToRawLongBits(a[i]);\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n@@ -251,19 +261,0 @@\n-    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -798,15 +789,0 @@\n-    interface FBinArrayOp {\n-        double apply(double[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(double[] r, double[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1359,20 +1335,10 @@\n-        switch(i % 7) {\n-            case 0:\n-                return Double.MAX_VALUE;\n-            case 1:\n-                return Double.MIN_VALUE;\n-            case 2:\n-                return Double.NEGATIVE_INFINITY;\n-            case 3:\n-                return Double.POSITIVE_INFINITY;\n-            case 4:\n-                return Double.NaN;\n-            case 5:\n-                return (double)0.0;\n-            default:\n-                return (double)-0.0;\n-        }\n-    }\n-\n-    static double get(double[] a, int i) {\n-        return (double) a[i];\n+        return switch(i % 8) {\n+            case 0  -> Double.MAX_VALUE;\n+            case 1  -> Double.MIN_VALUE;\n+            case 2  -> Double.NEGATIVE_INFINITY;\n+            case 3  -> Double.POSITIVE_INFINITY;\n+            case 4  -> Double.NaN;\n+            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);\n+            case 6  -> (double)0.0;\n+            default -> (double)-0.0;\n+        };\n@@ -2605,2 +2571,2 @@\n-    @Test(dataProvider = \"doubleUnaryOpProvider\")\n-    static void withDouble128VectorTests(IntFunction<double []> fa) {\n+    @Test(dataProvider = \"doubleBinaryOpProvider\")\n+    static void withDouble128VectorTests(IntFunction<double []> fa, IntFunction<double []> fb) {\n@@ -2608,0 +2574,1 @@\n+        double[] b = fb.apply(SPECIES.length());\n@@ -2613,1 +2580,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -2618,3 +2587,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (double)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -3510,1 +3477,1 @@\n-        assertArraysEquals(r, a, Double128VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":28,"deletions":61,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -74,0 +74,10 @@\n+    static void assertArraysStrictlyEquals(double[] r, double[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            long ir = Double.doubleToRawLongBits(r[i]);\n+            long ia = Double.doubleToRawLongBits(a[i]);\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n@@ -251,19 +261,0 @@\n-    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -798,15 +789,0 @@\n-    interface FBinArrayOp {\n-        double apply(double[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(double[] r, double[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1359,20 +1335,10 @@\n-        switch(i % 7) {\n-            case 0:\n-                return Double.MAX_VALUE;\n-            case 1:\n-                return Double.MIN_VALUE;\n-            case 2:\n-                return Double.NEGATIVE_INFINITY;\n-            case 3:\n-                return Double.POSITIVE_INFINITY;\n-            case 4:\n-                return Double.NaN;\n-            case 5:\n-                return (double)0.0;\n-            default:\n-                return (double)-0.0;\n-        }\n-    }\n-\n-    static double get(double[] a, int i) {\n-        return (double) a[i];\n+        return switch(i % 8) {\n+            case 0  -> Double.MAX_VALUE;\n+            case 1  -> Double.MIN_VALUE;\n+            case 2  -> Double.NEGATIVE_INFINITY;\n+            case 3  -> Double.POSITIVE_INFINITY;\n+            case 4  -> Double.NaN;\n+            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);\n+            case 6  -> (double)0.0;\n+            default -> (double)-0.0;\n+        };\n@@ -2605,2 +2571,2 @@\n-    @Test(dataProvider = \"doubleUnaryOpProvider\")\n-    static void withDouble256VectorTests(IntFunction<double []> fa) {\n+    @Test(dataProvider = \"doubleBinaryOpProvider\")\n+    static void withDouble256VectorTests(IntFunction<double []> fa, IntFunction<double []> fb) {\n@@ -2608,0 +2574,1 @@\n+        double[] b = fb.apply(SPECIES.length());\n@@ -2613,1 +2580,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -2618,3 +2587,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (double)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -3510,1 +3477,1 @@\n-        assertArraysEquals(r, a, Double256VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":28,"deletions":61,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -74,0 +74,10 @@\n+    static void assertArraysStrictlyEquals(double[] r, double[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            long ir = Double.doubleToRawLongBits(r[i]);\n+            long ia = Double.doubleToRawLongBits(a[i]);\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n@@ -251,19 +261,0 @@\n-    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -798,15 +789,0 @@\n-    interface FBinArrayOp {\n-        double apply(double[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(double[] r, double[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1359,20 +1335,10 @@\n-        switch(i % 7) {\n-            case 0:\n-                return Double.MAX_VALUE;\n-            case 1:\n-                return Double.MIN_VALUE;\n-            case 2:\n-                return Double.NEGATIVE_INFINITY;\n-            case 3:\n-                return Double.POSITIVE_INFINITY;\n-            case 4:\n-                return Double.NaN;\n-            case 5:\n-                return (double)0.0;\n-            default:\n-                return (double)-0.0;\n-        }\n-    }\n-\n-    static double get(double[] a, int i) {\n-        return (double) a[i];\n+        return switch(i % 8) {\n+            case 0  -> Double.MAX_VALUE;\n+            case 1  -> Double.MIN_VALUE;\n+            case 2  -> Double.NEGATIVE_INFINITY;\n+            case 3  -> Double.POSITIVE_INFINITY;\n+            case 4  -> Double.NaN;\n+            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);\n+            case 6  -> (double)0.0;\n+            default -> (double)-0.0;\n+        };\n@@ -2605,2 +2571,2 @@\n-    @Test(dataProvider = \"doubleUnaryOpProvider\")\n-    static void withDouble512VectorTests(IntFunction<double []> fa) {\n+    @Test(dataProvider = \"doubleBinaryOpProvider\")\n+    static void withDouble512VectorTests(IntFunction<double []> fa, IntFunction<double []> fb) {\n@@ -2608,0 +2574,1 @@\n+        double[] b = fb.apply(SPECIES.length());\n@@ -2613,1 +2580,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -2618,3 +2587,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (double)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -3510,1 +3477,1 @@\n-        assertArraysEquals(r, a, Double512VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":28,"deletions":61,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -74,0 +74,10 @@\n+    static void assertArraysStrictlyEquals(double[] r, double[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            long ir = Double.doubleToRawLongBits(r[i]);\n+            long ia = Double.doubleToRawLongBits(a[i]);\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n@@ -251,19 +261,0 @@\n-    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -798,15 +789,0 @@\n-    interface FBinArrayOp {\n-        double apply(double[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(double[] r, double[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1359,20 +1335,10 @@\n-        switch(i % 7) {\n-            case 0:\n-                return Double.MAX_VALUE;\n-            case 1:\n-                return Double.MIN_VALUE;\n-            case 2:\n-                return Double.NEGATIVE_INFINITY;\n-            case 3:\n-                return Double.POSITIVE_INFINITY;\n-            case 4:\n-                return Double.NaN;\n-            case 5:\n-                return (double)0.0;\n-            default:\n-                return (double)-0.0;\n-        }\n-    }\n-\n-    static double get(double[] a, int i) {\n-        return (double) a[i];\n+        return switch(i % 8) {\n+            case 0  -> Double.MAX_VALUE;\n+            case 1  -> Double.MIN_VALUE;\n+            case 2  -> Double.NEGATIVE_INFINITY;\n+            case 3  -> Double.POSITIVE_INFINITY;\n+            case 4  -> Double.NaN;\n+            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);\n+            case 6  -> (double)0.0;\n+            default -> (double)-0.0;\n+        };\n@@ -2605,2 +2571,2 @@\n-    @Test(dataProvider = \"doubleUnaryOpProvider\")\n-    static void withDouble64VectorTests(IntFunction<double []> fa) {\n+    @Test(dataProvider = \"doubleBinaryOpProvider\")\n+    static void withDouble64VectorTests(IntFunction<double []> fa, IntFunction<double []> fb) {\n@@ -2608,0 +2574,1 @@\n+        double[] b = fb.apply(SPECIES.length());\n@@ -2613,1 +2580,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -2618,3 +2587,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (double)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -3510,1 +3477,1 @@\n-        assertArraysEquals(r, a, Double64VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":28,"deletions":61,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -79,0 +79,10 @@\n+    static void assertArraysStrictlyEquals(double[] r, double[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            long ir = Double.doubleToRawLongBits(r[i]);\n+            long ia = Double.doubleToRawLongBits(a[i]);\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n@@ -256,19 +266,0 @@\n-    static void assertInsertArraysEquals(double[] r, double[] a, double element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -803,15 +794,0 @@\n-    interface FBinArrayOp {\n-        double apply(double[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(double[] r, double[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1364,20 +1340,10 @@\n-        switch(i % 7) {\n-            case 0:\n-                return Double.MAX_VALUE;\n-            case 1:\n-                return Double.MIN_VALUE;\n-            case 2:\n-                return Double.NEGATIVE_INFINITY;\n-            case 3:\n-                return Double.POSITIVE_INFINITY;\n-            case 4:\n-                return Double.NaN;\n-            case 5:\n-                return (double)0.0;\n-            default:\n-                return (double)-0.0;\n-        }\n-    }\n-\n-    static double get(double[] a, int i) {\n-        return (double) a[i];\n+        return switch(i % 8) {\n+            case 0  -> Double.MAX_VALUE;\n+            case 1  -> Double.MIN_VALUE;\n+            case 2  -> Double.NEGATIVE_INFINITY;\n+            case 3  -> Double.POSITIVE_INFINITY;\n+            case 4  -> Double.NaN;\n+            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);\n+            case 6  -> (double)0.0;\n+            default -> (double)-0.0;\n+        };\n@@ -2610,2 +2576,2 @@\n-    @Test(dataProvider = \"doubleUnaryOpProvider\")\n-    static void withDoubleMaxVectorTests(IntFunction<double []> fa) {\n+    @Test(dataProvider = \"doubleBinaryOpProvider\")\n+    static void withDoubleMaxVectorTests(IntFunction<double []> fa, IntFunction<double []> fb) {\n@@ -2613,0 +2579,1 @@\n+        double[] b = fb.apply(SPECIES.length());\n@@ -2618,1 +2585,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (double)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -2623,3 +2592,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (double)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -3515,1 +3482,1 @@\n-        assertArraysEquals(r, a, DoubleMaxVectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":28,"deletions":61,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -74,0 +74,10 @@\n+    static void assertArraysStrictlyEquals(float[] r, float[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            int ir = Float.floatToRawIntBits(r[i]);\n+            int ia = Float.floatToRawIntBits(a[i]);\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %08X, actual = %08X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n@@ -251,19 +261,0 @@\n-    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -798,15 +789,0 @@\n-    interface FBinArrayOp {\n-        float apply(float[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(float[] r, float[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1370,20 +1346,10 @@\n-        switch(i % 7) {\n-            case 0:\n-                return Float.MAX_VALUE;\n-            case 1:\n-                return Float.MIN_VALUE;\n-            case 2:\n-                return Float.NEGATIVE_INFINITY;\n-            case 3:\n-                return Float.POSITIVE_INFINITY;\n-            case 4:\n-                return Float.NaN;\n-            case 5:\n-                return (float)0.0;\n-            default:\n-                return (float)-0.0;\n-        }\n-    }\n-\n-    static float get(float[] a, int i) {\n-        return (float) a[i];\n+        return switch(i % 8) {\n+            case 0  -> Float.MAX_VALUE;\n+            case 1  -> Float.MIN_VALUE;\n+            case 2  -> Float.NEGATIVE_INFINITY;\n+            case 3  -> Float.POSITIVE_INFINITY;\n+            case 4  -> Float.NaN;\n+            case 5  -> Float.intBitsToFloat(0x7F812345);\n+            case 6  -> (float)0.0;\n+            default -> (float)-0.0;\n+        };\n@@ -2616,2 +2582,2 @@\n-    @Test(dataProvider = \"floatUnaryOpProvider\")\n-    static void withFloat128VectorTests(IntFunction<float []> fa) {\n+    @Test(dataProvider = \"floatBinaryOpProvider\")\n+    static void withFloat128VectorTests(IntFunction<float []> fa, IntFunction<float []> fb) {\n@@ -2619,0 +2585,1 @@\n+        float[] b = fb.apply(SPECIES.length());\n@@ -2624,1 +2591,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -2629,3 +2598,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (float)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -3521,1 +3488,1 @@\n-        assertArraysEquals(r, a, Float128VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":28,"deletions":61,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -74,0 +74,10 @@\n+    static void assertArraysStrictlyEquals(float[] r, float[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            int ir = Float.floatToRawIntBits(r[i]);\n+            int ia = Float.floatToRawIntBits(a[i]);\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %08X, actual = %08X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n@@ -251,19 +261,0 @@\n-    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -798,15 +789,0 @@\n-    interface FBinArrayOp {\n-        float apply(float[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(float[] r, float[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1370,20 +1346,10 @@\n-        switch(i % 7) {\n-            case 0:\n-                return Float.MAX_VALUE;\n-            case 1:\n-                return Float.MIN_VALUE;\n-            case 2:\n-                return Float.NEGATIVE_INFINITY;\n-            case 3:\n-                return Float.POSITIVE_INFINITY;\n-            case 4:\n-                return Float.NaN;\n-            case 5:\n-                return (float)0.0;\n-            default:\n-                return (float)-0.0;\n-        }\n-    }\n-\n-    static float get(float[] a, int i) {\n-        return (float) a[i];\n+        return switch(i % 8) {\n+            case 0  -> Float.MAX_VALUE;\n+            case 1  -> Float.MIN_VALUE;\n+            case 2  -> Float.NEGATIVE_INFINITY;\n+            case 3  -> Float.POSITIVE_INFINITY;\n+            case 4  -> Float.NaN;\n+            case 5  -> Float.intBitsToFloat(0x7F812345);\n+            case 6  -> (float)0.0;\n+            default -> (float)-0.0;\n+        };\n@@ -2616,2 +2582,2 @@\n-    @Test(dataProvider = \"floatUnaryOpProvider\")\n-    static void withFloat256VectorTests(IntFunction<float []> fa) {\n+    @Test(dataProvider = \"floatBinaryOpProvider\")\n+    static void withFloat256VectorTests(IntFunction<float []> fa, IntFunction<float []> fb) {\n@@ -2619,0 +2585,1 @@\n+        float[] b = fb.apply(SPECIES.length());\n@@ -2624,1 +2591,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -2629,3 +2598,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (float)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -3521,1 +3488,1 @@\n-        assertArraysEquals(r, a, Float256VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":28,"deletions":61,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -74,0 +74,10 @@\n+    static void assertArraysStrictlyEquals(float[] r, float[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            int ir = Float.floatToRawIntBits(r[i]);\n+            int ia = Float.floatToRawIntBits(a[i]);\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %08X, actual = %08X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n@@ -251,19 +261,0 @@\n-    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -798,15 +789,0 @@\n-    interface FBinArrayOp {\n-        float apply(float[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(float[] r, float[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1370,20 +1346,10 @@\n-        switch(i % 7) {\n-            case 0:\n-                return Float.MAX_VALUE;\n-            case 1:\n-                return Float.MIN_VALUE;\n-            case 2:\n-                return Float.NEGATIVE_INFINITY;\n-            case 3:\n-                return Float.POSITIVE_INFINITY;\n-            case 4:\n-                return Float.NaN;\n-            case 5:\n-                return (float)0.0;\n-            default:\n-                return (float)-0.0;\n-        }\n-    }\n-\n-    static float get(float[] a, int i) {\n-        return (float) a[i];\n+        return switch(i % 8) {\n+            case 0  -> Float.MAX_VALUE;\n+            case 1  -> Float.MIN_VALUE;\n+            case 2  -> Float.NEGATIVE_INFINITY;\n+            case 3  -> Float.POSITIVE_INFINITY;\n+            case 4  -> Float.NaN;\n+            case 5  -> Float.intBitsToFloat(0x7F812345);\n+            case 6  -> (float)0.0;\n+            default -> (float)-0.0;\n+        };\n@@ -2616,2 +2582,2 @@\n-    @Test(dataProvider = \"floatUnaryOpProvider\")\n-    static void withFloat512VectorTests(IntFunction<float []> fa) {\n+    @Test(dataProvider = \"floatBinaryOpProvider\")\n+    static void withFloat512VectorTests(IntFunction<float []> fa, IntFunction<float []> fb) {\n@@ -2619,0 +2585,1 @@\n+        float[] b = fb.apply(SPECIES.length());\n@@ -2624,1 +2591,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -2629,3 +2598,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (float)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -3521,1 +3488,1 @@\n-        assertArraysEquals(r, a, Float512VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":28,"deletions":61,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -74,0 +74,10 @@\n+    static void assertArraysStrictlyEquals(float[] r, float[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            int ir = Float.floatToRawIntBits(r[i]);\n+            int ia = Float.floatToRawIntBits(a[i]);\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %08X, actual = %08X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n@@ -251,19 +261,0 @@\n-    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -798,15 +789,0 @@\n-    interface FBinArrayOp {\n-        float apply(float[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(float[] r, float[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1370,20 +1346,10 @@\n-        switch(i % 7) {\n-            case 0:\n-                return Float.MAX_VALUE;\n-            case 1:\n-                return Float.MIN_VALUE;\n-            case 2:\n-                return Float.NEGATIVE_INFINITY;\n-            case 3:\n-                return Float.POSITIVE_INFINITY;\n-            case 4:\n-                return Float.NaN;\n-            case 5:\n-                return (float)0.0;\n-            default:\n-                return (float)-0.0;\n-        }\n-    }\n-\n-    static float get(float[] a, int i) {\n-        return (float) a[i];\n+        return switch(i % 8) {\n+            case 0  -> Float.MAX_VALUE;\n+            case 1  -> Float.MIN_VALUE;\n+            case 2  -> Float.NEGATIVE_INFINITY;\n+            case 3  -> Float.POSITIVE_INFINITY;\n+            case 4  -> Float.NaN;\n+            case 5  -> Float.intBitsToFloat(0x7F812345);\n+            case 6  -> (float)0.0;\n+            default -> (float)-0.0;\n+        };\n@@ -2616,2 +2582,2 @@\n-    @Test(dataProvider = \"floatUnaryOpProvider\")\n-    static void withFloat64VectorTests(IntFunction<float []> fa) {\n+    @Test(dataProvider = \"floatBinaryOpProvider\")\n+    static void withFloat64VectorTests(IntFunction<float []> fa, IntFunction<float []> fb) {\n@@ -2619,0 +2585,1 @@\n+        float[] b = fb.apply(SPECIES.length());\n@@ -2624,1 +2591,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -2629,3 +2598,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (float)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -3521,1 +3488,1 @@\n-        assertArraysEquals(r, a, Float64VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":28,"deletions":61,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -79,0 +79,10 @@\n+    static void assertArraysStrictlyEquals(float[] r, float[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            int ir = Float.floatToRawIntBits(r[i]);\n+            int ia = Float.floatToRawIntBits(a[i]);\n+            if (ir != ia) {\n+                Assert.fail(String.format(\"at index #%d, expected = %08X, actual = %08X\", i, ia, ir));\n+            }\n+        }\n+    }\n+\n@@ -256,19 +266,0 @@\n-    static void assertInsertArraysEquals(float[] r, float[] a, float element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -803,15 +794,0 @@\n-    interface FBinArrayOp {\n-        float apply(float[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(float[] r, float[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1375,20 +1351,10 @@\n-        switch(i % 7) {\n-            case 0:\n-                return Float.MAX_VALUE;\n-            case 1:\n-                return Float.MIN_VALUE;\n-            case 2:\n-                return Float.NEGATIVE_INFINITY;\n-            case 3:\n-                return Float.POSITIVE_INFINITY;\n-            case 4:\n-                return Float.NaN;\n-            case 5:\n-                return (float)0.0;\n-            default:\n-                return (float)-0.0;\n-        }\n-    }\n-\n-    static float get(float[] a, int i) {\n-        return (float) a[i];\n+        return switch(i % 8) {\n+            case 0  -> Float.MAX_VALUE;\n+            case 1  -> Float.MIN_VALUE;\n+            case 2  -> Float.NEGATIVE_INFINITY;\n+            case 3  -> Float.POSITIVE_INFINITY;\n+            case 4  -> Float.NaN;\n+            case 5  -> Float.intBitsToFloat(0x7F812345);\n+            case 6  -> (float)0.0;\n+            default -> (float)-0.0;\n+        };\n@@ -2621,2 +2587,2 @@\n-    @Test(dataProvider = \"floatUnaryOpProvider\")\n-    static void withFloatMaxVectorTests(IntFunction<float []> fa) {\n+    @Test(dataProvider = \"floatBinaryOpProvider\")\n+    static void withFloatMaxVectorTests(IntFunction<float []> fa, IntFunction<float []> fb) {\n@@ -2624,0 +2590,1 @@\n+        float[] b = fb.apply(SPECIES.length());\n@@ -2629,1 +2596,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (float)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -2634,3 +2603,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (float)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -3526,1 +3493,1 @@\n-        assertArraysEquals(r, a, FloatMaxVectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":28,"deletions":61,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(int[] r, int[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -234,19 +242,0 @@\n-    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -707,15 +696,0 @@\n-    interface FBinArrayOp {\n-        int apply(int[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(int[] r, int[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1175,4 +1149,0 @@\n-    static int get(int[] a, int i) {\n-        return (int) a[i];\n-    }\n-\n@@ -3795,2 +3765,2 @@\n-    @Test(dataProvider = \"intUnaryOpProvider\")\n-    static void withInt128VectorTests(IntFunction<int []> fa) {\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void withInt128VectorTests(IntFunction<int []> fa, IntFunction<int []> fb) {\n@@ -3798,0 +3768,1 @@\n+        int[] b = fb.apply(SPECIES.length());\n@@ -3803,1 +3774,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3808,3 +3781,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (int)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4745,1 +4716,1 @@\n-        assertArraysEquals(r, a, Int128VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(int[] r, int[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -234,19 +242,0 @@\n-    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -707,15 +696,0 @@\n-    interface FBinArrayOp {\n-        int apply(int[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(int[] r, int[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1175,4 +1149,0 @@\n-    static int get(int[] a, int i) {\n-        return (int) a[i];\n-    }\n-\n@@ -3795,2 +3765,2 @@\n-    @Test(dataProvider = \"intUnaryOpProvider\")\n-    static void withInt256VectorTests(IntFunction<int []> fa) {\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void withInt256VectorTests(IntFunction<int []> fa, IntFunction<int []> fb) {\n@@ -3798,0 +3768,1 @@\n+        int[] b = fb.apply(SPECIES.length());\n@@ -3803,1 +3774,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3808,3 +3781,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (int)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4745,1 +4716,1 @@\n-        assertArraysEquals(r, a, Int256VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(int[] r, int[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -234,19 +242,0 @@\n-    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -707,15 +696,0 @@\n-    interface FBinArrayOp {\n-        int apply(int[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(int[] r, int[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1175,4 +1149,0 @@\n-    static int get(int[] a, int i) {\n-        return (int) a[i];\n-    }\n-\n@@ -3795,2 +3765,2 @@\n-    @Test(dataProvider = \"intUnaryOpProvider\")\n-    static void withInt512VectorTests(IntFunction<int []> fa) {\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void withInt512VectorTests(IntFunction<int []> fa, IntFunction<int []> fb) {\n@@ -3798,0 +3768,1 @@\n+        int[] b = fb.apply(SPECIES.length());\n@@ -3803,1 +3774,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3808,3 +3781,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (int)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4745,1 +4716,1 @@\n-        assertArraysEquals(r, a, Int512VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(int[] r, int[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -234,19 +242,0 @@\n-    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -707,15 +696,0 @@\n-    interface FBinArrayOp {\n-        int apply(int[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(int[] r, int[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1175,4 +1149,0 @@\n-    static int get(int[] a, int i) {\n-        return (int) a[i];\n-    }\n-\n@@ -3795,2 +3765,2 @@\n-    @Test(dataProvider = \"intUnaryOpProvider\")\n-    static void withInt64VectorTests(IntFunction<int []> fa) {\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void withInt64VectorTests(IntFunction<int []> fa, IntFunction<int []> fb) {\n@@ -3798,0 +3768,1 @@\n+        int[] b = fb.apply(SPECIES.length());\n@@ -3803,1 +3774,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3808,3 +3781,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (int)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4745,1 +4716,1 @@\n-        assertArraysEquals(r, a, Int64VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -75,0 +75,8 @@\n+    static void assertArraysStrictlyEquals(int[] r, int[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -239,19 +247,0 @@\n-    static void assertInsertArraysEquals(int[] r, int[] a, int element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -712,15 +701,0 @@\n-    interface FBinArrayOp {\n-        int apply(int[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(int[] r, int[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1180,4 +1154,0 @@\n-    static int get(int[] a, int i) {\n-        return (int) a[i];\n-    }\n-\n@@ -3800,2 +3770,2 @@\n-    @Test(dataProvider = \"intUnaryOpProvider\")\n-    static void withIntMaxVectorTests(IntFunction<int []> fa) {\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void withIntMaxVectorTests(IntFunction<int []> fa, IntFunction<int []> fb) {\n@@ -3803,0 +3773,1 @@\n+        int[] b = fb.apply(SPECIES.length());\n@@ -3808,1 +3779,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (int)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3813,3 +3786,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (int)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4750,1 +4721,1 @@\n-        assertArraysEquals(r, a, IntMaxVectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(long[] r, long[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -191,19 +199,0 @@\n-    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -664,15 +653,0 @@\n-    interface FBinArrayOp {\n-        long apply(long[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(long[] r, long[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1202,4 +1176,0 @@\n-    static long get(long[] a, int i) {\n-        return (long) a[i];\n-    }\n-\n@@ -3817,2 +3787,2 @@\n-    @Test(dataProvider = \"longUnaryOpProvider\")\n-    static void withLong128VectorTests(IntFunction<long []> fa) {\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void withLong128VectorTests(IntFunction<long []> fa, IntFunction<long []> fb) {\n@@ -3820,0 +3790,1 @@\n+        long[] b = fb.apply(SPECIES.length());\n@@ -3825,1 +3796,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3830,3 +3803,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (long)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4697,1 +4668,1 @@\n-        assertArraysEquals(r, a, Long128VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(long[] r, long[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -191,19 +199,0 @@\n-    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -664,15 +653,0 @@\n-    interface FBinArrayOp {\n-        long apply(long[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(long[] r, long[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1202,4 +1176,0 @@\n-    static long get(long[] a, int i) {\n-        return (long) a[i];\n-    }\n-\n@@ -3817,2 +3787,2 @@\n-    @Test(dataProvider = \"longUnaryOpProvider\")\n-    static void withLong256VectorTests(IntFunction<long []> fa) {\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void withLong256VectorTests(IntFunction<long []> fa, IntFunction<long []> fb) {\n@@ -3820,0 +3790,1 @@\n+        long[] b = fb.apply(SPECIES.length());\n@@ -3825,1 +3796,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3830,3 +3803,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (long)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4697,1 +4668,1 @@\n-        assertArraysEquals(r, a, Long256VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(long[] r, long[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -191,19 +199,0 @@\n-    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -664,15 +653,0 @@\n-    interface FBinArrayOp {\n-        long apply(long[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(long[] r, long[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1202,4 +1176,0 @@\n-    static long get(long[] a, int i) {\n-        return (long) a[i];\n-    }\n-\n@@ -3817,2 +3787,2 @@\n-    @Test(dataProvider = \"longUnaryOpProvider\")\n-    static void withLong512VectorTests(IntFunction<long []> fa) {\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void withLong512VectorTests(IntFunction<long []> fa, IntFunction<long []> fb) {\n@@ -3820,0 +3790,1 @@\n+        long[] b = fb.apply(SPECIES.length());\n@@ -3825,1 +3796,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3830,3 +3803,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (long)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4697,1 +4668,1 @@\n-        assertArraysEquals(r, a, Long512VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(long[] r, long[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -191,19 +199,0 @@\n-    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -664,15 +653,0 @@\n-    interface FBinArrayOp {\n-        long apply(long[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(long[] r, long[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1202,4 +1176,0 @@\n-    static long get(long[] a, int i) {\n-        return (long) a[i];\n-    }\n-\n@@ -3817,2 +3787,2 @@\n-    @Test(dataProvider = \"longUnaryOpProvider\")\n-    static void withLong64VectorTests(IntFunction<long []> fa) {\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void withLong64VectorTests(IntFunction<long []> fa, IntFunction<long []> fb) {\n@@ -3820,0 +3790,1 @@\n+        long[] b = fb.apply(SPECIES.length());\n@@ -3825,1 +3796,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3830,3 +3803,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (long)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4697,1 +4668,1 @@\n-        assertArraysEquals(r, a, Long64VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -75,0 +75,8 @@\n+    static void assertArraysStrictlyEquals(long[] r, long[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -196,19 +204,0 @@\n-    static void assertInsertArraysEquals(long[] r, long[] a, long element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -669,15 +658,0 @@\n-    interface FBinArrayOp {\n-        long apply(long[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(long[] r, long[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1207,4 +1181,0 @@\n-    static long get(long[] a, int i) {\n-        return (long) a[i];\n-    }\n-\n@@ -3822,2 +3792,2 @@\n-    @Test(dataProvider = \"longUnaryOpProvider\")\n-    static void withLongMaxVectorTests(IntFunction<long []> fa) {\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void withLongMaxVectorTests(IntFunction<long []> fa, IntFunction<long []> fb) {\n@@ -3825,0 +3795,1 @@\n+        long[] b = fb.apply(SPECIES.length());\n@@ -3830,1 +3801,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (long)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3835,3 +3808,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (long)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4702,1 +4673,1 @@\n-        assertArraysEquals(r, a, LongMaxVectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(short[] r, short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -234,19 +242,0 @@\n-    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -707,15 +696,0 @@\n-    interface FBinArrayOp {\n-        short apply(short[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1205,4 +1179,0 @@\n-    static short get(short[] a, int i) {\n-        return (short) a[i];\n-    }\n-\n@@ -3742,2 +3712,2 @@\n-    @Test(dataProvider = \"shortUnaryOpProvider\")\n-    static void withShort128VectorTests(IntFunction<short []> fa) {\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void withShort128VectorTests(IntFunction<short []> fa, IntFunction<short []> fb) {\n@@ -3745,0 +3715,1 @@\n+        short[] b = fb.apply(SPECIES.length());\n@@ -3750,1 +3721,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3755,3 +3728,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (short)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4692,1 +4663,1 @@\n-        assertArraysEquals(r, a, Short128VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(short[] r, short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -234,19 +242,0 @@\n-    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -707,15 +696,0 @@\n-    interface FBinArrayOp {\n-        short apply(short[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1205,4 +1179,0 @@\n-    static short get(short[] a, int i) {\n-        return (short) a[i];\n-    }\n-\n@@ -3742,2 +3712,2 @@\n-    @Test(dataProvider = \"shortUnaryOpProvider\")\n-    static void withShort256VectorTests(IntFunction<short []> fa) {\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void withShort256VectorTests(IntFunction<short []> fa, IntFunction<short []> fb) {\n@@ -3745,0 +3715,1 @@\n+        short[] b = fb.apply(SPECIES.length());\n@@ -3750,1 +3721,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3755,3 +3728,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (short)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4692,1 +4663,1 @@\n-        assertArraysEquals(r, a, Short256VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(short[] r, short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -234,19 +242,0 @@\n-    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -707,15 +696,0 @@\n-    interface FBinArrayOp {\n-        short apply(short[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1205,4 +1179,0 @@\n-    static short get(short[] a, int i) {\n-        return (short) a[i];\n-    }\n-\n@@ -3742,2 +3712,2 @@\n-    @Test(dataProvider = \"shortUnaryOpProvider\")\n-    static void withShort512VectorTests(IntFunction<short []> fa) {\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void withShort512VectorTests(IntFunction<short []> fa, IntFunction<short []> fb) {\n@@ -3745,0 +3715,1 @@\n+        short[] b = fb.apply(SPECIES.length());\n@@ -3750,1 +3721,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3755,3 +3728,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (short)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4692,1 +4663,1 @@\n-        assertArraysEquals(r, a, Short512VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -70,0 +70,8 @@\n+    static void assertArraysStrictlyEquals(short[] r, short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -234,19 +242,0 @@\n-    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -707,15 +696,0 @@\n-    interface FBinArrayOp {\n-        short apply(short[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1205,4 +1179,0 @@\n-    static short get(short[] a, int i) {\n-        return (short) a[i];\n-    }\n-\n@@ -3742,2 +3712,2 @@\n-    @Test(dataProvider = \"shortUnaryOpProvider\")\n-    static void withShort64VectorTests(IntFunction<short []> fa) {\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void withShort64VectorTests(IntFunction<short []> fa, IntFunction<short []> fb) {\n@@ -3745,0 +3715,1 @@\n+        short[] b = fb.apply(SPECIES.length());\n@@ -3750,1 +3721,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3755,3 +3728,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (short)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4692,1 +4663,1 @@\n-        assertArraysEquals(r, a, Short64VectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -75,0 +75,8 @@\n+    static void assertArraysStrictlyEquals(short[] r, short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+        }\n+    }\n+\n@@ -239,19 +247,0 @@\n-    static void assertInsertArraysEquals(short[] r, short[] a, short element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -712,15 +701,0 @@\n-    interface FBinArrayOp {\n-        short apply(short[] a, int b);\n-    }\n-\n-    static void assertArraysEquals(short[] r, short[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1210,4 +1184,0 @@\n-    static short get(short[] a, int i) {\n-        return (short) a[i];\n-    }\n-\n@@ -3747,2 +3717,2 @@\n-    @Test(dataProvider = \"shortUnaryOpProvider\")\n-    static void withShortMaxVectorTests(IntFunction<short []> fa) {\n+    @Test(dataProvider = \"shortBinaryOpProvider\")\n+    static void withShortMaxVectorTests(IntFunction<short []> fa, IntFunction<short []> fb) {\n@@ -3750,0 +3720,1 @@\n+        short[] b = fb.apply(SPECIES.length());\n@@ -3755,1 +3726,3 @@\n-                av.withLane((j++ & (SPECIES.length()-1)), (short)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n@@ -3760,3 +3733,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, (short)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n@@ -4697,1 +4668,1 @@\n-        assertArraysEquals(r, a, ShortMaxVectorTests::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":16,"deletions":45,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+        $type$[] b = fb.apply(SPECIES.length());\n@@ -7,1 +8,3 @@\n-                av.withLane((j++ \\& (SPECIES.length()-1)), ($type$)(65535+i)).intoArray(r, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) \\& (SPECIES.length() - 1);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-With-Op.template","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-        assertArraysEquals(r, a, $vectorteststype$::get);\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Get-op.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n-    @Test(dataProvider = \"$type$UnaryOpProvider\")\n-    static void with$vectorteststype$(IntFunction<$type$ []> fa) {\n+    @Test(dataProvider = \"$type$BinaryOpProvider\")\n+    static void with$vectorteststype$(IntFunction<$type$ []> fa, IntFunction<$type$ []> fb) {\n@@ -6,3 +6,1 @@\n-        for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n-            assertInsertArraysEquals(r, a, ($type$)(65535+i), (j++ & (SPECIES.length()-1)), i , i + SPECIES.length());\n-        }\n+        assertArraysStrictlyEquals(r, a);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-With-Op.template","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -108,0 +108,20 @@\n+    static void assertArraysStrictlyEquals($type$[] r, $type$[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+#if[FP]\n+            $bitstype$ ir = $Wideboxtype$.$type$ToRaw$Bitstype$Bits(r[i]);\n+            $bitstype$ ia = $Wideboxtype$.$type$ToRaw$Bitstype$Bits(a[i]);\n+            if (ir != ia) {\n+#if[Float]\n+                Assert.fail(String.format(\"at index #%d, expected = %08X, actual = %08X\", i, ia, ir));\n+#else[Float]\n+                Assert.fail(String.format(\"at index #%d, expected = %016X, actual = %016X\", i, ia, ir));\n+#end[Float]\n+            }\n+#else[FP]\n+            if (r[i] != a[i]) {\n+                Assert.fail(\"at index #\" + i + \", expected = \" + a[i] + \", actual = \" + r[i]);\n+            }\n+#end[FP]\n+        }\n+    }\n+\n@@ -317,19 +337,0 @@\n-    static void assertInsertArraysEquals($type$[] r, $type$[] a, $type$ element, int index, int start, int end) {\n-        int i = start;\n-        try {\n-            for (; i < end; i += 1) {\n-                if(i%SPECIES.length() == index) {\n-                    Assert.assertEquals(r[i], element);\n-                } else {\n-                    Assert.assertEquals(r[i], a[i]);\n-                }\n-            }\n-        } catch (AssertionError e) {\n-            if (i%SPECIES.length() == index) {\n-                Assert.assertEquals(r[i], element, \"at index #\" + i);\n-            } else {\n-                Assert.assertEquals(r[i], a[i], \"at index #\" + i);\n-            }\n-        }\n-    }\n-\n@@ -866,15 +867,0 @@\n-    interface FBinArrayOp {\n-        $type$ apply($type$[] a, int b);\n-    }\n-\n-    static void assertArraysEquals($type$[] r, $type$[] a, FBinArrayOp f) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], f.apply(a, i));\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], f.apply(a,i), \"at index #\" + i);\n-        }\n-    }\n-\n@@ -1475,16 +1461,14 @@\n-        switch(i % 7) {\n-            case 0:\n-                return $Wideboxtype$.MAX_VALUE;\n-            case 1:\n-                return $Wideboxtype$.MIN_VALUE;\n-            case 2:\n-                return $Wideboxtype$.NEGATIVE_INFINITY;\n-            case 3:\n-                return $Wideboxtype$.POSITIVE_INFINITY;\n-            case 4:\n-                return $Wideboxtype$.NaN;\n-            case 5:\n-                return ($type$)0.0;\n-            default:\n-                return ($type$)-0.0;\n-        }\n+        return switch(i % 8) {\n+            case 0  -> $Wideboxtype$.MAX_VALUE;\n+            case 1  -> $Wideboxtype$.MIN_VALUE;\n+            case 2  -> $Wideboxtype$.NEGATIVE_INFINITY;\n+            case 3  -> $Wideboxtype$.POSITIVE_INFINITY;\n+            case 4  -> $Wideboxtype$.NaN;\n+#if[Float]\n+            case 5  -> Float.intBitsToFloat(0x7F812345);\n+#else[Float]\n+            case 5  -> Double.longBitsToDouble(0x7FF123456789ABCDL);\n+#end[Float]\n+            case 6  -> ($type$)0.0;\n+            default -> ($type$)-0.0;\n+        };\n@@ -1507,4 +1491,0 @@\n-    static $type$ get($type$[] a, int i) {\n-        return ($type$) a[i];\n-    }\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":34,"deletions":54,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Palantir Technologies, Inc. and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestChunkInputStreamBulkRead\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.api.consumer.TestChunkInputStreamBulkRead\n+ *\/\n+package jdk.jfr.api.consumer;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import jdk.jfr.Recording;\n+import jdk.test.lib.Asserts;\n+\n+public class TestChunkInputStreamBulkRead {\n+\n+    public static void main(String[] args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+            try (Recording s = new Recording()) {\n+                s.start();\n+                s.stop();\n+            }\n+            r.stop();\n+            try (InputStream stream = r.getStream(null, null);\n+                 ByteArrayOutputStream output = new ByteArrayOutputStream()) {\n+                long read = stream.transferTo(output);\n+                System.out.printf(\"Read %d bytes from JFR stream%n\", read);\n+                Asserts.assertEquals(r.getSize(), read);\n+\n+                byte[] actual = output.toByteArray();\n+                Asserts.assertEqualsByteArray(r.getStream(null, null).readAllBytes(), actual);\n+\n+                Path dumpFile = Paths.get(\"recording.jfr\").toAbsolutePath().normalize();\n+                r.dump(dumpFile);\n+                System.out.printf(\"Dumped recording to %s (%d bytes)%n\", dumpFile, Files.size(dumpFile));\n+                Asserts.assertEqualsByteArray(Files.readAllBytes(dumpFile), actual);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/TestChunkInputStreamBulkRead.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-            Asserts.assertEquals(re.getDuration(), Duration.between(re.getStartTime(), re.getEndTime()));\n+            Asserts.assertEquals(re.getDuration(), re.getStartTime().until(re.getEndTime()));\n@@ -114,1 +114,1 @@\n-            Asserts.assertEquals(re.getDuration(), Duration.between(re.getStartTime(), re.getEndTime()));\n+            Asserts.assertEquals(re.getDuration(), re.getStartTime().until(re.getEndTime()));\n","filename":"test\/jdk\/jdk\/jfr\/api\/event\/TestGetDuration.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-        Duration s = Duration.between(offset, t);\n+        Duration s = offset.until(t);\n","filename":"test\/jdk\/jdk\/jfr\/api\/recording\/misc\/TestGetStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-        long durationMillis = Duration.between(afterStart, r.getStopTime()).toMillis();\n+        long durationMillis = afterStart.until(r.getStopTime()).toMillis();\n","filename":"test\/jdk\/jdk\/jfr\/api\/recording\/options\/TestDuration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-        Duration measuredDuration = Duration.between(start, stop);\n+        Duration measuredDuration = start.until(stop);\n","filename":"test\/jdk\/jdk\/jfr\/api\/recording\/state\/TestStateDuration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-        long millis = Duration.between(start, started).toMillis();\n+        long millis = start.until(started).toMillis();\n","filename":"test\/jdk\/jdk\/jfr\/api\/recording\/state\/TestStateScheduleStart.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,1 @@\n+        assertEquals(2, makeCombineControl());\n@@ -97,0 +98,28 @@\n+    private static int makeCombineControl() throws Exception {\n+        try (Recording r1 = new Recording()) {\n+            r1.enable(HTTPPostEvent.class).with(\"uriFilter\", \"https:\/\/www.example.com\/list\");\n+            r1.start();\n+\n+            try (Recording r2 = new Recording()) {\n+                r2.enable(HTTPPostEvent.class).with(\"uriFilter\", \"https:\/\/www.example.com\/get\");\n+                r2.start();\n+\n+                HTTPPostEvent e1 = new HTTPPostEvent();\n+                e1.uri = \"https:\/\/www.example.com\/list\";\n+                e1.commit();\n+\n+                HTTPPostEvent e2 = new HTTPPostEvent();\n+                e2.uri = \"https:\/\/www.example.com\/get\";\n+                e2.commit();\n+\n+                HTTPPostEvent e3 = new HTTPPostEvent();\n+                e3.uri = \"https:\/\/www.example.com\/put\";\n+                e3.commit();\n+            }\n+\n+            r1.stop();\n+\n+            return Events.fromRecording(r1).size();\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/api\/settings\/TestFilterEvents.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Collections;\n@@ -33,2 +32,1 @@\n-import jdk.jfr.Event;\n-import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.Recording;\n@@ -44,1 +42,1 @@\n- * Test for events: jdk.CodeCacheFull jdk.CompilationFailure\n+ * Test for events: vm\/code_cache\/full vm\/compiler\/failure\n@@ -63,2 +61,0 @@\n-    static class ProvocationEvent extends Event {\n-    }\n@@ -70,2 +66,2 @@\n-    private static final String EVENT_CODE_CACHE_FULL = EventNames.CodeCacheFull;\n-    private static final String EVENT_COMPILATION_FAILURE = EventNames.CompilationFailure;\n+    private static final String pathFull = EventNames.CodeCacheFull;\n+    private static final String pathFailure = EventNames.CompilationFailure;\n@@ -84,24 +80,7 @@\n-        List<RecordedEvent> events = Collections.synchronizedList(new ArrayList<>());\n-        try (RecordingStream rs = new RecordingStream()) {\n-            rs.setReuse(false);\n-            rs.enable(EVENT_CODE_CACHE_FULL);\n-            rs.enable(EVENT_COMPILATION_FAILURE);\n-            rs.onEvent(EVENT_CODE_CACHE_FULL, events::add);\n-            rs.onEvent(EVENT_COMPILATION_FAILURE, events::add);\n-            rs.onEvent(ProvocationEvent.class.getName(), e -> {\n-                if (!events.isEmpty()) {\n-                    rs.close();\n-                    return;\n-                }\n-                \/\/ Retry if CodeCacheFull or CompilationFailure events weren't provoked\n-                try {\n-                    provokeEvents();\n-                } catch (Exception ex) {\n-                    ex.printStackTrace();\n-                    rs.close();\n-                }\n-            });\n-            rs.startAsync();\n-            provokeEvents();\n-            rs.awaitTermination();\n-        }\n+\n+        Recording r = new Recording();\n+        r.enable(pathFull);\n+        r.enable(pathFailure);\n+        r.start();\n+        provokeEvents();\n+        r.stop();\n@@ -111,0 +90,2 @@\n+\n+        List<RecordedEvent> events = Events.fromRecording(r);\n@@ -112,1 +93,1 @@\n-        for (RecordedEvent event : new ArrayList<>(events)) {\n+        for (RecordedEvent event : events) {\n@@ -114,1 +95,1 @@\n-            case EVENT_CODE_CACHE_FULL:\n+            case pathFull:\n@@ -118,1 +99,1 @@\n-            case EVENT_COMPILATION_FAILURE:\n+            case pathFailure:\n@@ -137,2 +118,0 @@\n-        System.out.println(\"provokeEvents()\");\n-        ProvocationEvent provocationEvent = new ProvocationEvent();\n@@ -183,1 +162,0 @@\n-        provocationEvent.commit();\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCodeSweeper.java","additions":16,"deletions":38,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-                    while ((Duration.between(start, Instant.now()).compareTo(runTime) < 0) ||\n+                    while ((start.until(Instant.now()).compareTo(runTime) < 0) ||\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestThreadCpuTimeEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+\n+\/**\n+ * @test\n+ * @summary Verify that duplicate longer strings doesn't take up unneccessary space\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.jvm.TestLongStringsInPool\n+ *\/\n+public class TestLongStringsInPool {\n+    private static class StringEvent extends Event {\n+        String message;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Create two recordings; first has only one large\n+        \/\/ string, second has several occurences of the same\n+        \/\/ string. With long strings (>128 chars) being pooled,\n+        \/\/ the two recording should be roughly the same size.\n+        final int numEvents = 10;\n+        final String longString = generateString();\n+        final int strLen = longString.length();\n+        final StringEvent event = new StringEvent();\n+        event.message = longString;\n+\n+        Recording firstRec = new Recording();\n+        firstRec.start();\n+        \/\/ commit events with empty message (both recordings\n+        \/\/ will have the same number of events)\n+        for (int i = 0; i < numEvents - 1; i++) {\n+            event.message = \"\";\n+            event.commit();\n+        }\n+        \/\/ commit 1 event with a long string\n+        event.message = longString;\n+        event.commit();\n+\n+        firstRec.stop();\n+        Path rec1 = Paths.get(\".\", \"rec1.jfr\");\n+        firstRec.dump(rec1);\n+        firstRec.close();\n+\n+\n+        Recording secondRec = new Recording();\n+        secondRec.start();\n+        \/\/ commit events with the same long string\n+        for (int i = 0; i < numEvents - 1; i++) {\n+          event.message = longString;\n+          event.commit();\n+        }\n+        \/\/ commit 1 event with a long string\n+        event.message = longString;\n+        event.commit();\n+\n+        secondRec.stop();\n+        Path rec2 = Paths.get(\".\", \"rec2.jfr\");\n+        secondRec.dump(rec2);\n+        secondRec.close();\n+\n+        \/\/ the files aren't exactly the same size, but rec2 should\n+        \/\/ not take up space for all strings if they're pooled correctly\n+        long maxAllowedDiff = (numEvents - 1) * strLen;\n+        long diff = Math.abs(Files.size(rec2) - Files.size(rec1));\n+\n+        Asserts.assertTrue(diff <= maxAllowedDiff, \"Size difference between recordings is too large: \"+ diff +\" > \" + maxAllowedDiff);\n+        Asserts.assertFalse(RecordingFile.readAllEvents(rec1).isEmpty(), \"No events found in recording 1\");\n+        Asserts.assertFalse(RecordingFile.readAllEvents(rec2).isEmpty(), \"No events found in recording 2\");\n+        Asserts.assertEquals(RecordingFile.readAllEvents(rec1).size(), RecordingFile.readAllEvents(rec2).size(), \"The recordings don't have the same number of events\");\n+    }\n+\n+    \/**\n+     * Generate a string of 256 chars length.\n+     * @return\n+     *\/\n+    private static String generateString() {\n+        final StringBuilder builder = new StringBuilder();\n+        for (int i = 0; i < 32; i++) {\n+            builder.append(\"abcdefgh\");\n+        }\n+        return builder.toString();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestLongStringsInPool.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.threading;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ThreadFactory;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedThread;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8338417\n+ * @summary Tests pinning of virtual threads when the JFR string pool monitor is contended.\n+ * @key jfr\n+ * @requires vm.hasJFR & vm.continuations\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.threading.TestStringPoolVirtualThreadPinning\n+ *\/\n+public class TestStringPoolVirtualThreadPinning {\n+\n+    private static final int VIRTUAL_THREAD_COUNT = 100_000;\n+    private static final int STARTER_THREADS = 10;\n+\n+    @Name(\"test.Tester\")\n+    private static class TestEvent extends Event {\n+        private String eventString = Thread.currentThread().getName();\n+    }\n+\n+    \/*\n+     * During event commit, the thread is in a critical section because it has loaded a carrier thread local event writer object.\n+     * For virtual threads, a contended monitor, such as a synchronized block, is a point where a thread could become unmounted.\n+     * A monitor guards the JFR string pool, but because of the event writer, remounting a virtual thread onto another carrier is impossible.\n+     *\n+     * The test provokes JFR string pool monitor contention to exercise explicit pin constructs to ensure the pinning of virtual threads.\n+    *\/\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+\n+            ThreadFactory factory = Thread.ofVirtual().factory();\n+            CompletableFuture<?>[] c = new CompletableFuture[STARTER_THREADS];\n+            for (int j = 0; j < STARTER_THREADS; j++) {\n+                c[j] = CompletableFuture.runAsync(() -> {\n+                    for (int i = 0; i < VIRTUAL_THREAD_COUNT \/ STARTER_THREADS; i++) {\n+                        try {\n+                            Thread vt = factory.newThread(TestStringPoolVirtualThreadPinning::emitEvent);\n+                            \/\/ For an event field string to be placed in the JFR string pool, it must exceed 16 characters.\n+                            \/\/ We use the virtual thread name as the event field string so we can verify the result as a 1-1 mapping.\n+                            vt.setName(\"VirtualTestThread-\" + i);\n+                            vt.start();\n+                            vt.join();\n+                        } catch (InterruptedException ie) {\n+                            ie.printStackTrace();\n+                        }\n+                    }\n+                });\n+            }\n+            for (int j = 0; j < STARTER_THREADS; j++) {\n+                c[j].get();\n+            }\n+\n+            r.stop();\n+            Path p = Utils.createTempFile(\"test\", \".jfr\");\n+            r.dump(p);\n+            List<RecordedEvent> events = RecordingFile.readAllEvents(p);\n+            Asserts.assertEquals(events.size(), VIRTUAL_THREAD_COUNT, \"Expected \" + VIRTUAL_THREAD_COUNT + \" events\");\n+            for (RecordedEvent e : events) {\n+                RecordedThread t = e.getThread();\n+                Asserts.assertNotNull(t);\n+                Asserts.assertTrue(t.isVirtual());\n+                Asserts.assertEquals(e.getString(\"eventString\"), t.getJavaName());\n+            }\n+        }\n+    }\n+\n+    private static void emitEvent() {\n+        TestEvent t = new TestEvent();\n+        t.commit();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestStringPoolVirtualThreadPinning.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8338890\n+ * @summary Basic test for jdk.management.VirtualThreadSchedulerMXBean\n+ * @requires vm.continuations\n+ * @modules jdk.management\n+ * @library \/test\/lib\n+ * @run junit\/othervm VirtualThreadSchedulerMXBeanTest\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Stream;\n+import java.util.stream.IntStream;\n+import javax.management.MBeanServer;\n+import jdk.management.VirtualThreadSchedulerMXBean;\n+\n+import jdk.test.lib.thread.VThreadRunner;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n+\n+class VirtualThreadSchedulerMXBeanTest {\n+\n+    \/**\n+     * VirtualThreadSchedulerMXBean objects to test.\n+     *\/\n+    private static Stream<VirtualThreadSchedulerMXBean> managedBeans() throws Exception {\n+        var bean1 = ManagementFactory.getPlatformMXBean(VirtualThreadSchedulerMXBean.class);\n+\n+        MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n+        var bean2 = ManagementFactory.newPlatformMXBeanProxy(server,\n+                \"jdk.management:type=VirtualThreadScheduler\",\n+                VirtualThreadSchedulerMXBean.class);\n+\n+        return Stream.of(bean1, bean2);\n+    }\n+\n+    \/**\n+     * Test default parallelism.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"managedBeans\")\n+    void testDefaultParallelism(VirtualThreadSchedulerMXBean bean) {\n+        assertEquals(Runtime.getRuntime().availableProcessors(), bean.getParallelism());\n+    }\n+\n+    \/**\n+     * Test increasing parallelism.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"managedBeans\")\n+    void testIncreaseParallelism(VirtualThreadSchedulerMXBean bean) throws Exception {\n+        assumeFalse(Thread.currentThread().isVirtual(), \"Main thread is a virtual thread\");\n+\n+        final int parallelism = bean.getParallelism();\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+            var done = new AtomicBoolean();\n+            Runnable busyTask = () -> {\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n+                }\n+            };\n+\n+            try {\n+                \/\/ saturate\n+                IntStream.range(0, parallelism).forEach(_ -> executor.submit(busyTask));\n+                awaitPoolSizeGte(bean, parallelism);\n+                awaitMountedVirtualThreadCountGte(bean, parallelism);\n+\n+                \/\/ increase parallelism\n+                for (int k = 1; k <= 4; k++) {\n+                    int newParallelism = parallelism + k;\n+                    bean.setParallelism(newParallelism);\n+                    executor.submit(busyTask);\n+\n+                    \/\/ pool size and mounted virtual thread should increase\n+                    awaitPoolSizeGte(bean, newParallelism);\n+                    awaitMountedVirtualThreadCountGte(bean, newParallelism);\n+                }\n+            } finally {\n+                done.set(true);\n+            }\n+        } finally {\n+            bean.setParallelism(parallelism);   \/\/ restore\n+        }\n+    }\n+\n+    \/**\n+     * Test reducing parallelism.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"managedBeans\")\n+    void testReduceParallelism(VirtualThreadSchedulerMXBean bean) throws Exception {\n+        assumeFalse(Thread.currentThread().isVirtual(), \"Main thread is a virtual thread\");\n+\n+        final int parallelism = bean.getParallelism();\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+            var done = new AtomicBoolean();\n+            var sleep = new AtomicBoolean();\n+\n+            \/\/ spin when !sleep\n+            Runnable busyTask = () -> {\n+                while (!done.get()) {\n+                    if (sleep.get()) {\n+                        try {\n+                            Thread.sleep(10);\n+                        } catch (InterruptedException e) { }\n+                    } else {\n+                        Thread.onSpinWait();\n+                    }\n+                }\n+            };\n+\n+            try {\n+                \/\/ increase parallelism + saturate\n+                int newParallelism = parallelism + 4;\n+                bean.setParallelism(newParallelism);\n+                IntStream.range(0, newParallelism).forEach(_ -> executor.submit(busyTask));\n+                awaitMountedVirtualThreadCountGte(bean, newParallelism);\n+\n+                \/\/ reduce parallelism and workload\n+                newParallelism = Math.clamp(parallelism \/ 2, 1, parallelism);\n+                bean.setParallelism(newParallelism);\n+                sleep.set(true);\n+                \/\/ mounted virtual thread count should reduce\n+                awaitMountedVirtualThreadCountLte(bean, newParallelism);\n+\n+                \/\/ increase workload, the mounted virtual thread count should not increase\n+                sleep.set(false);\n+                for (int i = 0; i < 5; i++) {\n+                    Thread.sleep(100);\n+                    assertTrue(bean.getMountedVirtualThreadCount() <= newParallelism);\n+                }\n+\n+            } finally {\n+                done.set(true);\n+            }\n+        } finally {\n+            bean.setParallelism(parallelism);  \/\/ restore\n+        }\n+    }\n+\n+    \/**\n+     * Test getPoolSize.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"managedBeans\")\n+    void testPoolSize(VirtualThreadSchedulerMXBean bean) {\n+        assertTrue(bean.getPoolSize() >= 0);\n+        VThreadRunner.run(() -> {\n+            assertTrue(Thread.currentThread().isVirtual());\n+            assertTrue(bean.getPoolSize() >= 1);\n+        });\n+    }\n+\n+    \/**\n+     * Test getMountedVirtualThreadCount.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"managedBeans\")\n+    void testMountedVirtualThreadCount(VirtualThreadSchedulerMXBean bean) {\n+        assertTrue(bean.getMountedVirtualThreadCount() >= 0);\n+        VThreadRunner.run(() -> {\n+            assertTrue(Thread.currentThread().isVirtual());\n+            assertTrue(bean.getMountedVirtualThreadCount() >= 1);\n+        });\n+    }\n+\n+    \/**\n+     * Test getQueuedVirtualThreadCount.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"managedBeans\")\n+    void testQueuedVirtualThreadCount(VirtualThreadSchedulerMXBean bean) throws Exception {\n+        assumeFalse(Thread.currentThread().isVirtual(), \"Main thread is a virtual thread\");\n+\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+            var done = new AtomicBoolean();\n+            Runnable busyTask = () -> {\n+                while (!done.get()) {\n+                    Thread.onSpinWait();\n+                }\n+            };\n+\n+            try {\n+                \/\/ saturate\n+                int parallelism = bean.getParallelism();\n+                IntStream.range(0, parallelism).forEach(_ -> executor.submit(busyTask));\n+                awaitMountedVirtualThreadCountGte(bean, parallelism);\n+\n+                \/\/ start 5 virtual threads, their tasks will be queued to execute\n+                for (int i = 0; i < 5; i++) {\n+                    executor.submit(() -> { });\n+                }\n+                assertTrue(bean.getQueuedVirtualThreadCount() >= 5);\n+            } finally {\n+                done.set(true);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Waits for pool size >= target to be true.\n+     *\/\n+    void awaitPoolSizeGte(VirtualThreadSchedulerMXBean bean, int target) throws InterruptedException {\n+        System.err.format(\"await pool size >= %d ...%n\", target);\n+        while (bean.getPoolSize() < target) {\n+            Thread.sleep(10);\n+        }\n+    }\n+\n+    \/**\n+     * Waits for the mounted virtual thread count >= target to be true.\n+     *\/\n+    void awaitMountedVirtualThreadCountGte(VirtualThreadSchedulerMXBean bean,\n+                                           int target) throws InterruptedException {\n+        System.err.format(\"await mounted virtual thread count >= %d ...%n\", target);\n+        while (bean.getMountedVirtualThreadCount() < target) {\n+            Thread.sleep(10);\n+        }\n+    }\n+\n+    \/**\n+     * Waits for the mounted virtual thread count <= target to be true.\n+     *\/\n+    void awaitMountedVirtualThreadCountLte(VirtualThreadSchedulerMXBean bean,\n+                                           int target) throws InterruptedException {\n+        System.err.format(\"await mounted virtual thread count <= %d ...%n\", target);\n+        while (bean.getMountedVirtualThreadCount() > target) {\n+            Thread.sleep(10);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/management\/VirtualThreadSchedulerMXBean\/VirtualThreadSchedulerMXBeanTest.java","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import javax.swing.JApplet;\n@@ -45,2 +44,0 @@\n- *\n- * @author Jeff Dinkins\n@@ -48,1 +45,1 @@\n-public class DemoModule extends JApplet {\n+public class DemoModule extends JPanel {\n@@ -217,5 +214,0 @@\n-    public void init() {\n-        getContentPane().setLayout(new BorderLayout());\n-        getContentPane().add(getDemoPanel(), BorderLayout.CENTER);\n-    }\n-\n@@ -223,1 +215,2 @@\n-}\n\\ No newline at end of file\n+}\n+\n","filename":"test\/jdk\/sanity\/client\/lib\/SwingSet2\/src\/DemoModule.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm -mx128m TestDisposerLeak\n+ * @run main\/othervm -Xmx128m TestDisposerLeak\n","filename":"test\/jdk\/sun\/java2d\/Disposer\/TestDisposerLeak.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.function.Supplier;\n@@ -35,1 +36,1 @@\n- * @run main\/othervm -mx128m TestDisposerRace\n+ * @run main\/othervm -Xmx128m TestDisposerRace\n@@ -42,0 +43,3 @@\n+    private static final String KO_OVERFLOW = \"Some records have not been disposed!\";\n+    private static final String KO_UNDERFLOW = \"Disposed more records than were added!\";\n+\n@@ -43,2 +47,1 @@\n-        TestDisposerRace test = new TestDisposerRace();\n-        test.run();\n+        new TestDisposerRace().run();\n@@ -48,0 +51,1 @@\n+            System.err.println(KO_OVERFLOW); \/\/ In case the next line fails to allocate due to OOME\n@@ -52,0 +56,4 @@\n+    interface ThrowingRunnable<E extends Exception> {\n+        void run() throws E;\n+    }\n+\n@@ -59,3 +67,4 @@\n-            SwingUtilities.invokeAndWait(Disposer::pollRemove);\n-            if (i % 10 == 0) {\n-                \/\/ Adding records will race with the diposer trying to remove them\n+            retryOnOOME(() -> SwingUtilities.invokeAndWait(Disposer::pollRemove));\n+\n+            \/\/ Adding records will race with the diposer trying to remove them\n+            if (i % 10 == 0)\n@@ -63,1 +72,0 @@\n-            }\n@@ -66,1 +74,1 @@\n-        Disposer.addObjectRecord(new Object(), new FinalDisposerRecord());\n+        retryOnOOME(() -> Disposer.addObjectRecord(new Object(), new FinalDisposerRecord()));\n@@ -75,1 +83,26 @@\n-            throw new RuntimeException(\"Disposed more records than were added\");\n+            throw new RuntimeException(KO_UNDERFLOW);\n+        }\n+    }\n+\n+    private static <T> T retryOnOOME(Supplier<T> allocator) {\n+        for(;;) {\n+            try {\n+                return allocator.get();\n+            } catch (OutOfMemoryError ignored1) {\n+                try {\n+                    Thread.sleep(1); \/\/ Give GC a little chance to run\n+                } catch (InterruptedException ignored2) {}\n+            }\n+        }\n+    }\n+\n+    private static <E extends Exception> void retryOnOOME(ThrowingRunnable<E> tr) throws E {\n+        for(;;) {\n+            try {\n+                tr.run();\n+                break;\n+            } catch (OutOfMemoryError ignored1) {\n+                try {\n+                    Thread.sleep(1); \/\/ Give GC a little chance to run\n+                } catch (InterruptedException ignored2) {}\n+            }\n@@ -82,1 +115,1 @@\n-        recordsCount.addAndGet(count);\n+        MyDisposerRecord disposerRecord = retryOnOOME(MyDisposerRecord::new);\n@@ -84,3 +117,5 @@\n-        MyDisposerRecord disposerRecord = new MyDisposerRecord();\n-        for (int i = 0; i < count; i++) {\n-            Disposer.addObjectRecord(new Object(), disposerRecord);\n+        while(count > 0) {\n+            recordsCount.incrementAndGet(); \/\/ pre-add to make sure it doesn't go negative\n+            var o = retryOnOOME(Object::new);\n+            retryOnOOME(() -> Disposer.addObjectRecord(o, disposerRecord));\n+            --count;\n@@ -109,1 +144,0 @@\n-        final List<Object> leak = new LinkedList<>();\n@@ -111,0 +145,1 @@\n+            final List<Object> leak = new LinkedList<>();\n","filename":"test\/jdk\/sun\/java2d\/Disposer\/TestDisposerRace.java","additions":49,"deletions":14,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm -mx512m CrashTest\n+ * @run main\/othervm -Xmx512m CrashTest\n@@ -40,1 +40,1 @@\n- * @run main\/othervm -ms4g -mx4g CrashTest -slow\n+ * @run main\/othervm -Xms4g -Xmx4g CrashTest -slow\n","filename":"test\/jdk\/sun\/java2d\/marlin\/CrashTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-import sun.security.provider.SHAKE256;\n+import sun.security.provider.SHA3.SHAKE256;\n","filename":"test\/jdk\/sun\/security\/ec\/ed\/TestEdOps.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8338587\n+ * @summary Ensure squeeze and digest always have the same output\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.provider\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.provider.SHA3;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+\n+public class SHAKEsqueeze {\n+    public static void main(String[] args) throws Exception {\n+        var r = SeededSecureRandom.one();\n+        var atlast = 0;\n+        \/\/ Random test on SHAKE\n+        for (var i = 0; i < 1_000_000; i++) {\n+            var s = new SHA3.SHAKE256(0);\n+            var in = new ByteArrayOutputStream();\n+            while (r.nextBoolean()) {\n+                var b = r.nBytes(r.nextInt(200));\n+                if (b.length > 0 && r.nextBoolean()) {\n+                    \/\/ Test update(b)\n+                    s.update(b[0]);\n+                    in.write(b[0]);\n+                } else if (r.nextBoolean()) {\n+                    \/\/ Test update(byte[])\n+                    s.update(b);\n+                    in.write(b);\n+                } else {\n+                    \/\/ Test update(byte[], offset, len)\n+                    var prepend = r.nextInt(100);\n+                    var append = r.nextInt(100);\n+                    var bb = new byte[prepend + b.length + append];\n+                    r.nextBytes(bb);\n+                    System.arraycopy(b, 0, bb, prepend, b.length);\n+                    s.update(bb, prepend, b.length);\n+                    in.write(b);\n+                }\n+            }\n+\n+            \/\/ Squeeze for multiple times\n+            var out = new ByteArrayOutputStream();\n+            do {\n+                var n = r.nextInt(200);\n+                out.write(s.squeeze(n));\n+            } while (out.size() == 0 || r.nextBoolean());\n+            var b1 = out.toByteArray();\n+\n+            \/\/ Digest for one time\n+            var s2 = new SHA3.SHAKE256(b1.length);\n+            s2.update(in.toByteArray());\n+            var b2 = s2.digest();\n+\n+            atlast = Arrays.hashCode(b2) * 17 + atlast;\n+            Asserts.assertEqualsByteArray(b1, b2);\n+        }\n+        \/\/ Just to provide a visual clue to show that the same\n+        \/\/ SeededSecureRandom seed results in same final result\n+        \/\/ so that the test can be exactly reproduced.\n+        System.out.println(\"Final hash: \" + atlast);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/MessageDigest\/SHAKEsqueeze.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,2 @@\n- * @bug 6425477 8141039\n+ * @bug 6425477 8141039 8324648\n+ * @library \/test\/lib\n@@ -33,0 +34,2 @@\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n@@ -92,0 +95,21 @@\n+\n+        testParamsUnsupported(\"NativePRNG\");\n+        testParamsUnsupported(\"NativePRNGNonBlocking\");\n+        testParamsUnsupported(\"NativePRNGBlocking\");\n+    }\n+\n+    private static void testParamsUnsupported(String alg) throws NoSuchAlgorithmException {\n+        System.out.println(\"Testing that \" + alg + \" does not support params\");\n+\n+        try {\n+            SecureRandom.getInstance(alg, new SecureRandomParameters() {});\n+            throw new RuntimeException(\"Params should not be supported\");\n+        } catch (NoSuchAlgorithmException nsae) {\n+            Throwable cause = nsae.getCause();\n+            if (cause instanceof IllegalArgumentException) {\n+                assertTrue(cause.getMessage().contains(\"Unsupported params\"),\n+                        \"Unexpected error message: \" + cause.getMessage());\n+            } else {\n+                throw nsae;\n+            }\n+        }\n","filename":"test\/jdk\/sun\/security\/provider\/SecureRandom\/StrongSecureRandom.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies multiple PSKs are used by JSSE\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=1\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=3\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=10\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.2 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+\/**\n+ * This test verifies that multiple NSTs and PSKs are sent by a JSSE server.\n+ * Then JSSE client is able to store them all and resume the connection.  It\n+ * requires specific text in the TLS debugging to verify the success.\n+ *\/\n+\n+public class MultiNSTClient {\n+\n+    static HexFormat hex = HexFormat.of();\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> {\n+                sb.append(a);\n+                sb.append(\" \");\n+            });\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params\n+                );\n+\n+            boolean TLS13 = args[0].contains(\"1.3\");\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTClient\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            System.out.println(\"I'm here\");\n+            boolean pass = true;\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> serverPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                for (int i = 0; i < 2; i++) {\n+                    String svr = serverPSK.getFirst();\n+                    String cli = clientPSK.getFirst();\n+                    if (svr.regionMatches(svr.length() - 16, cli, cli.length() - 16, 16)) {\n+                        System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                    } else {\n+                        System.out.println(\"entry \" + (i + 1) + \" server and client PSK didn't match:\");\n+                        System.out.println(\"  server: \" + svr);\n+                        System.out.println(\"  client: \" + cli);\n+                        pass = false;\n+                    }\n+                }\n+            } catch (RuntimeException e) {\n+                System.out.println(\"No MultiNST PSK found.\");\n+                pass = false;\n+            }\n+\n+            if (TLS13) {\n+                if (!pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            } else {\n+                if (pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Start connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        SSLSession initialSession = initial.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  getNewSession from original client\");\n+        TLSBase.Client resumClient = new TLSBase.Client(initial);\n+        SSLSession resumption = resumClient.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  Second getNewSession from original client\");\n+        TLSBase.Client resumClient2 = new TLSBase.Client(initial);\n+        resumption = resumClient2.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  New client connection\");\n+        TLSBase.Client newConnection = new TLSBase.Client();\n+        SSLSession newSession = newConnection.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(newSession.getId()));\n+        System.out.println(\"session = \" + newSession);\n+        if (initialSession.toString().equalsIgnoreCase(newSession.toString())) {\n+            throw new Exception(\"new session is the same as the initial.\");\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        resumClient.close();\n+        resumClient2.close();\n+        newConnection.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTClient.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies resumption fails with 0 NSTs and session creation off\n+ * @run main\/othervm MultiNSTNoSessionCreation -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=0\n+ * @run main\/othervm MultiNSTNoSessionCreation -Djdk.tls.client.protocols=TLSv1.2 -Djdk.tls.server.newSessionTicketCount=0\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * With no NSTs sent by the server, try to resume the session with\n+ * setEnabledSessionCreation(false).  The test should get an exception and\n+ * fail to connect.\n+ *\/\n+\n+public class MultiNSTNoSessionCreation {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> sb.append(a).append(\" \"));\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params);\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTNoSessionCreation\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            try {\n+                if (output.stderrContains(\n+                    \"(PROTOCOL_VERSION): New session creation is disabled\")) {\n+                    return;\n+                }\n+            } catch (RuntimeException e) {\n+                throw new Exception(\"Error collecting data\", e);\n+            }\n+            throw new Exception(\"Disabled creation msg not found\");\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Initial connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        initial.connect();\n+        System.out.println(\n+            \"------  Resume client w\/ setEnableSessionCreation set to false\");\n+        TLSBase.Client resumClient = new TLSBase.Client(initial);\n+        resumClient.socket.setEnableSessionCreation(false);\n+        resumClient.connect();\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        resumClient.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTNoSessionCreation.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies multiple PSKs are used by TLSv1.3\n+ * @run main\/othervm MultiNSTParallel 10 -Djdk.tls.client.protocols=TLSv1.3\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.ArrayList;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * This test verifies that parallel resumption connections successfully get\n+ * a PSK entry and not initiate a full handshake.\n+ *\n+ * Note:  THe first argument after 'MultiNSTParallel' is the ticket count\n+ * The test will set 'jdk.tls.server.NewSessionTicketCount` to that number and\n+ * will start the same number of resumption client attempts. The ticket count\n+ * must be the same or larger than resumption attempts otherwise the queue runs\n+ * empty and the test will fail.\n+ *\n+ * Because this test runs parallel connections, the thread order finish is not\n+ * guaranteed.  Each client NST id is checked with all server NSTs ids until\n+ * a match is found.  When a match is found, it is removed from the list to\n+ * verify no NST was used more than once.\n+ *\n+ * TLS 1.2 spec does not specify multiple NST behavior.\n+ *\/\n+\n+public class MultiNSTParallel {\n+\n+    static HexFormat hex = HexFormat.of();\n+    final static CountDownLatch wait = new CountDownLatch(1);\n+\n+    static class ClientThread extends Thread {\n+        TLSBase.Client client;\n+\n+        ClientThread(TLSBase.Client c) {\n+            client = c;\n+        }\n+\n+        public void run() {\n+            String name = Thread.currentThread().getName();\n+            SSLSession r;\n+            System.err.println(\"waiting \" + Thread.currentThread().getName());\n+            try {\n+                wait.await();\n+                r = new TLSBase.Client(client).connect().getSession();\n+            } catch (Exception e) {\n+                throw new RuntimeException(name + \": \" +e);\n+            }\n+            StringBuffer sb = new StringBuffer(100);\n+            sb.append(\"(\").append(name).append(\") id = \");\n+            sb.append(hex.formatHex(r.getId()));\n+            sb.append(\"\\n(\").append(name).append(\") session = \").append(r);\n+            if (!client.getSession().toString().equalsIgnoreCase(r.toString())) {\n+                throw new RuntimeException(\"(\" + name +\n+                    \") Resumed session did not match\");\n+            }\n+        }\n+    }\n+\n+    static boolean pass = true;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            int ticketCount = Integer.parseInt(args[0]);\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 1; i < args.length; i++) {\n+                sb.append(\" \").append(args[i]);\n+            }\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" +\n+                    \" -Djdk.tls.server.newSessionTicketCount=\" + ticketCount +\n+                    params);\n+\n+            boolean TLS13 = args[1].contains(\"1.3\");\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTParallel\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> sp = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> serverPSK = new ArrayList<>(sp.stream().toList());\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+\n+                \/\/ Must search all results as order is not guaranteed.\n+                clientPSK.stream().forEach(cli -> {\n+                    for (int i = 0; i < serverPSK.size(); i++) {\n+                        String svr = serverPSK.get(i);\n+                        if (svr.regionMatches(svr.length() - 16, cli,\n+                            cli.length() - 16, 16)) {\n+                            System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                            serverPSK.remove(i);\n+                            return;\n+                        }\n+                    }\n+                    System.out.println(\"client entry (\" + cli.substring(0, 16) +\n+                        \") not found in server list\");\n+                    pass = false;\n+                });\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Error looking at PSK results.\");\n+                throw new Exception(e);\n+            }\n+\n+            if (TLS13) {\n+                if (!pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            } else {\n+                if (pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        int ticketCount = Integer.parseInt(\n+            System.getProperty(\"jdk.tls.server.newSessionTicketCount\"));\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Start connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        SSLSession initialSession = initial.getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  getNewSession from original client\");\n+\n+        ArrayList<Thread> slist = new ArrayList<>(ticketCount);\n+\n+        System.out.println(\"tx \" + ticketCount);\n+        for (int i = 0; ticketCount > i; i++) {\n+            Thread t = new ClientThread(initial);\n+            t.setName(\"Iteration \" + i);\n+            slist.add(t);\n+            t.start();\n+        }\n+\n+        wait.countDown();\n+        for (Thread t : slist) {\n+            t.join(1000);\n+            System.err.println(\"released: \" + t.getName());\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTParallel.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies sequence of used NST entries from the cache queue.\n+ * @run main\/othervm MultiNSTSequence -Djdk.tls.server.newSessionTicketCount=2\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+\/**\n+ * This test verifies that multiple NSTs take the oldest PSK from the\n+ * QueueCacheEntry stored in the TLS Session Cache.\n+ *\n+ * Note: Beyond 9 iterations the PSK id verification code becomes complicated\n+ * with a QueueCacheEntry limit set to retain only the 10 newest entries.\n+ *\n+ * TLS 1.2 spec does not specify multiple NST behavior.\n+ *\/\n+\n+public class MultiNSTSequence {\n+\n+    static HexFormat hex = HexFormat.of();\n+    static final int ITERATIONS = 9;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> sb.append(a).append(\" \"));\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params\n+                              );\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTSequence\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            boolean pass = true;\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> serverPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                int i;\n+                for (i = 0; i < ITERATIONS; i++) {\n+                    String svr = serverPSK.get(i);\n+                    String cli = clientPSK.get(i);\n+                    if (svr.regionMatches(svr.length() - 16, cli, cli.length() - 16, 16)) {\n+                        System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                    } else {\n+                        System.out.println(\"entry \" + (i + 1) + \" server and client PSK didn't match:\");\n+                        System.out.println(\"  server: \" + svr);\n+                        System.out.println(\"  client: \" + cli);\n+                        pass = false;\n+                    }\n+                }\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Server and Client PSK usage order is not\" +\n+                    \" the same.\");\n+                pass = false;\n+            }\n+\n+            if (!pass) {\n+                throw new Exception(\"Test failed: \" + params);\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Initial connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+\n+        SSLSession initialSession = initial.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  Resume client\");\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            SSLSession r = new TLSBase.Client(initial).connect().getSession();\n+            StringBuilder sb = new StringBuilder(100);\n+            sb.append(\"Iteration: \").append(i);\n+            sb.append(\"\\tid = \").append(hex.formatHex(r.getId()));\n+            sb.append(\"\\tsession = \").append(r);\n+            System.out.println(sb);\n+            if (!initialSession.toString().equalsIgnoreCase(r.toString())) {\n+                throw new Exception(\"Resumed session did not match\");\n+            }\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTSequence.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.math.BigInteger;\n+import java.security.*;\n+import java.security.cert.*;\n+import java.time.*;\n+import java.util.*;\n+import javax.net.ssl.*;\n+import sun.security.validator.Validator;\n+import sun.security.validator.ValidatorException;\n+\n+import jdk.test.lib.security.SecurityUtils;\n+\n+\/**\n+ * @test\n+ * @bug 8337664\n+ * @summary Check that TLS Server certificates chaining back to distrusted\n+ *          Entrust roots are invalid\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.validator\n+ * @run main\/othervm Distrust after policyOn invalid\n+ * @run main\/othervm Distrust after policyOff valid\n+ * @run main\/othervm Distrust before policyOn valid\n+ * @run main\/othervm Distrust before policyOff valid\n+ *\/\n+\n+public class Distrust {\n+\n+    private static final String TEST_SRC = System.getProperty(\"test.src\", \".\");\n+    private static CertificateFactory cf;\n+\n+    \/\/ Each of the roots have a test certificate chain stored in a file\n+    \/\/ named \"<root>-chain.pem\".\n+    private static String[] rootsToTest = new String[] {\n+        \"entrustevca\", \"entrustrootcaec1\", \"entrustrootcag2\", \"entrustrootcag4\",\n+        \"entrust2048ca\", \"affirmtrustcommercialca\", \"affirmtrustnetworkingca\",\n+        \"affirmtrustpremiumca\", \"affirmtrustpremiumeccca\" };\n+\n+    \/\/ A date that is after the restrictions take effect\n+    private static final Date NOVEMBER_1_2024 =\n+        Date.from(LocalDate.of(2024, 11, 1)\n+                           .atStartOfDay(ZoneOffset.UTC)\n+                           .toInstant());\n+\n+    \/\/ A date that is a second before the restrictions take effect\n+    private static final Date BEFORE_NOVEMBER_1_2024 =\n+        Date.from(LocalDate.of(2024, 11, 1)\n+                           .atStartOfDay(ZoneOffset.UTC)\n+                           .minusSeconds(1)\n+                           .toInstant());\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        cf = CertificateFactory.getInstance(\"X.509\");\n+\n+        boolean before = args[0].equals(\"before\");\n+        boolean policyOn = args[1].equals(\"policyOn\");\n+        boolean isValid = args[2].equals(\"valid\");\n+\n+        if (!policyOn) {\n+            \/\/ disable policy (default is on)\n+            Security.setProperty(\"jdk.security.caDistrustPolicies\", \"\");\n+        }\n+\n+        Date notBefore = before ? BEFORE_NOVEMBER_1_2024 : NOVEMBER_1_2024;\n+\n+        X509TrustManager pkixTM = getTMF(\"PKIX\", null);\n+        X509TrustManager sunX509TM = getTMF(\"SunX509\", null);\n+        for (String test : rootsToTest) {\n+            System.err.println(\"Testing \" + test);\n+            X509Certificate[] chain = loadCertificateChain(test);\n+\n+            testTM(sunX509TM, chain, notBefore, isValid);\n+            testTM(pkixTM, chain, notBefore, isValid);\n+        }\n+    }\n+\n+    private static X509TrustManager getTMF(String type,\n+            PKIXBuilderParameters params) throws Exception {\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(type);\n+        if (params == null) {\n+            tmf.init((KeyStore)null);\n+        } else {\n+            tmf.init(new CertPathTrustManagerParameters(params));\n+        }\n+        TrustManager[] tms = tmf.getTrustManagers();\n+        for (TrustManager tm : tms) {\n+            X509TrustManager xtm = (X509TrustManager)tm;\n+            return xtm;\n+        }\n+        throw new Exception(\"No TrustManager for \" + type);\n+    }\n+\n+    private static PKIXBuilderParameters getParams() throws Exception {\n+        PKIXBuilderParameters pbp =\n+            new PKIXBuilderParameters(SecurityUtils.getCacertsKeyStore(),\n+                                      new X509CertSelector());\n+        pbp.setRevocationEnabled(false);\n+        return pbp;\n+    }\n+\n+    private static void testTM(X509TrustManager xtm, X509Certificate[] chain,\n+                               Date notBefore, boolean valid) throws Exception {\n+        \/\/ Check if TLS Server certificate (the first element of the chain)\n+        \/\/ is issued after the specified notBefore date (should be rejected\n+        \/\/ unless distrust property is false). To do this, we need to\n+        \/\/ fake the notBefore date since none of the test certs are issued\n+        \/\/ after then.\n+        chain[0] = new DistrustedTLSServerCert(chain[0], notBefore);\n+\n+        try {\n+            xtm.checkServerTrusted(chain, \"ECDHE_RSA\");\n+            if (!valid) {\n+                throw new Exception(\"chain should be invalid\");\n+            }\n+        } catch (CertificateException ce) {\n+            \/\/ expired TLS certificates should not be treated as failure\n+            if (expired(ce)) {\n+                System.err.println(\"Test is N\/A, chain is expired\");\n+                return;\n+            }\n+            if (valid) {\n+                throw new Exception(\"Unexpected exception, chain \" +\n+                                    \"should be valid\", ce);\n+            }\n+            if (ce instanceof ValidatorException) {\n+                ValidatorException ve = (ValidatorException)ce;\n+                if (ve.getErrorType() != ValidatorException.T_UNTRUSTED_CERT) {\n+                    ce.printStackTrace(System.err);\n+                    throw new Exception(\"Unexpected exception: \" + ce);\n+                }\n+            } else {\n+                throw new Exception(\"Unexpected exception: \" + ce);\n+            }\n+        }\n+    }\n+\n+    \/\/ check if a cause of exception is an expired cert\n+    private static boolean expired(CertificateException ce) {\n+        if (ce instanceof CertificateExpiredException) {\n+            return true;\n+        }\n+        Throwable t = ce.getCause();\n+        while (t != null) {\n+            if (t instanceof CertificateExpiredException) {\n+                return true;\n+            }\n+            t = t.getCause();\n+        }\n+        return false;\n+    }\n+\n+    private static X509Certificate[] loadCertificateChain(String name)\n+            throws Exception {\n+        try (InputStream in = new FileInputStream(TEST_SRC + File.separator +\n+                                                  name + \"-chain.pem\")) {\n+            Collection<X509Certificate> certs =\n+                (Collection<X509Certificate>)cf.generateCertificates(in);\n+            return certs.toArray(new X509Certificate[0]);\n+        }\n+    }\n+\n+    private static class DistrustedTLSServerCert extends X509Certificate {\n+        private final X509Certificate cert;\n+        private final Date notBefore;\n+        DistrustedTLSServerCert(X509Certificate cert, Date notBefore) {\n+            this.cert = cert;\n+            this.notBefore = notBefore;\n+        }\n+        public Set<String> getCriticalExtensionOIDs() {\n+           return cert.getCriticalExtensionOIDs();\n+        }\n+        public byte[] getExtensionValue(String oid) {\n+            return cert.getExtensionValue(oid);\n+        }\n+        public Set<String> getNonCriticalExtensionOIDs() {\n+            return cert.getNonCriticalExtensionOIDs();\n+        }\n+        public boolean hasUnsupportedCriticalExtension() {\n+            return cert.hasUnsupportedCriticalExtension();\n+        }\n+        public void checkValidity() throws CertificateExpiredException,\n+            CertificateNotYetValidException {\n+            \/\/ always pass\n+        }\n+        public void checkValidity(Date date) throws CertificateExpiredException,\n+            CertificateNotYetValidException {\n+            \/\/ always pass\n+        }\n+        public int getVersion() { return cert.getVersion(); }\n+        public BigInteger getSerialNumber() { return cert.getSerialNumber(); }\n+        public Principal getIssuerDN() { return cert.getIssuerDN(); }\n+        public Principal getSubjectDN() { return cert.getSubjectDN(); }\n+        public Date getNotBefore() { return notBefore; }\n+        public Date getNotAfter() { return cert.getNotAfter(); }\n+        public byte[] getTBSCertificate() throws CertificateEncodingException {\n+            return cert.getTBSCertificate();\n+        }\n+        public byte[] getSignature() { return cert.getSignature(); }\n+        public String getSigAlgName() { return cert.getSigAlgName(); }\n+        public String getSigAlgOID() { return cert.getSigAlgOID(); }\n+        public byte[] getSigAlgParams() { return cert.getSigAlgParams(); }\n+        public boolean[] getIssuerUniqueID() {\n+            return cert.getIssuerUniqueID();\n+        }\n+        public boolean[] getSubjectUniqueID() {\n+            return cert.getSubjectUniqueID();\n+        }\n+        public boolean[] getKeyUsage() { return cert.getKeyUsage(); }\n+        public int getBasicConstraints() { return cert.getBasicConstraints(); }\n+        public byte[] getEncoded() throws CertificateEncodingException {\n+            return cert.getEncoded();\n+        }\n+        public void verify(PublicKey key) throws CertificateException,\n+            InvalidKeyException, NoSuchAlgorithmException,\n+            NoSuchProviderException, SignatureException {\n+            cert.verify(key);\n+        }\n+        public void verify(PublicKey key, String sigProvider) throws\n+            CertificateException, InvalidKeyException, NoSuchAlgorithmException,\n+            NoSuchProviderException, SignatureException {\n+            cert.verify(key, sigProvider);\n+        }\n+        public PublicKey getPublicKey() { return cert.getPublicKey(); }\n+        public String toString() { return cert.toString(); }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/Distrust.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number: 8608355977964138876 (0x7777062726a9b17c)\n+        Signature Algorithm: sha256WithRSAEncryption\n+        Issuer: C=US, O=AffirmTrust, CN=AffirmTrust Commercial\n+        Validity\n+            Not Before: Jan 29 14:06:06 2010 GMT\n+            Not After : Dec 31 14:06:06 2030 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIHHjCCBgagAwIBAgIQAWZjFOyCvT00u\/gtkCvS2TANBgkqhkiG9w0BAQsFADCB\n+gzELMAkGA1UEBhMCQ0ExFDASBgNVBAoTC0FmZmlybVRydXN0MSswKQYDVQQLEyJT\n+ZWUgd3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MTEwLwYDVQQDEyhBZmZp\n+cm1UcnVzdCBFeHRlbmRlZCBWYWxpZGF0aW9uIENBIC0gRVYxMB4XDTI0MDYyODIx\n+MzgwNVoXDTI1MDcyODIxMzgwNFowgdgxCzAJBgNVBAYTAkNBMRAwDgYDVQQIEwdP\n+bnRhcmlvMQ8wDQYDVQQHEwZPdHRhd2ExEzARBgsrBgEEAYI3PAIBAxMCQ0ExGDAW\n+BgsrBgEEAYI3PAIBAhMHT250YXJpbzEcMBoGA1UEChMTQWZmaXJtdHJ1c3QgTGlt\n+aXRlZDEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xEDAOBgNVBAUTBzI1\n+NDA1NDcxKDAmBgNVBAMTH3ZhbGlkY29tbWVyY2lhbC5hZmZpcm10cnVzdC5jb20w\n+ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDeIT2XO0hJ5wDSbIiIcMvs\n+P3NpQc7O7v5DqldpME6+Qn2sF5b9hc6j72hgTXREa77uUcP5u1JcMWCSWwYQHMpJ\n+kFzmIzijhS60wW1epb5QyTgM3ZYh1WKvttFCbHUcrTtd+LoPFYsjw9ZK\/\/K9tPp+\n+ddn06\/ivWvUO5y5vn0wrCaB9tuLdDn4RCQzK2XoZdDuqhPlBBogJX0vM6lsXjgLy\n+EbvE+\/sKYps\/In6VtRvCoYavg3OqaIMeaA7gTiYTb1ZGFOAiltnq7fcp6SZUohK3\n+QNihv1DadVc+n8LnEUKKDkgG2YgWEFczaE3qwG3ef6L3MzLGrkgVY+qGHyyv2IE7\n+AgMBAAGjggM1MIIDMTAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBT4ARNL47hAsOpa\n+96VMgKEY3sLIAjAfBgNVHSMEGDAWgBTb72U3C+VHyzXRkB8DwbyIx6fqgDBsBggr\n+BgEFBQcBAQRgMF4wJwYIKwYBBQUHMAGGG2h0dHA6Ly9vY3NwLmFmZmlybXRydXN0\n+LmNvbTAzBggrBgEFBQcwAoYnaHR0cDovL2FpYS5hZmZpcm10cnVzdC5jb20vYWZ0\n+ZXYxY2EuY3J0MDwGA1UdHwQ1MDMwMaAvoC2GK2h0dHA6Ly9jcmwuYWZmaXJtdHJ1\n+c3QuY29tL2NybC9hZnRldjFjYS5jcmwwKgYDVR0RBCMwIYIfdmFsaWRjb21tZXJj\n+aWFsLmFmZmlybXRydXN0LmNvbTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYI\n+KwYBBQUHAwEGCCsGAQUFBwMCMFYGA1UdIARPME0wBwYFZ4EMAQEwQgYKKwYBBAGC\n+jwkCATA0MDIGCCsGAQUFBwIBFiZodHRwczovL3d3dy5hZmZpcm10cnVzdC5jb20v\n+cmVwb3NpdG9yeTCCAYAGCisGAQQB1nkCBAIEggFwBIIBbAFqAHcAEvFONL1TckyE\n+BhnDjz96E\/jntWKHiJxtMAWE6+WGJjoAAAGQYMi3wQAABAMASDBGAiEAjvdsU4G2\n+o4BZSOOjaH6gOp7zhKtXQByQUvfHfsi2ePcCIQDnnIO2qlHBm+sskUDlXfR0lCUW\n+yFPVr9nFZ0L9YPpozgB2AA3h8jAr0w3BQGISCepVLvxHdHyx1+kw7w5CHrR+Tqo0\n+AAABkGDIt9MAAAQDAEcwRQIhANh1zS3Qeo9yKF+j3G52JhmDRYBS+1TM0wykoXCY\n+llpxAiAG+LAlKSbwwgrboUSTDDXWNeoRYZ7fKbU72kKfHrpZvwB3ABoE\/0nQVB1A\n+r\/agw7\/x2MRnL07s7iNAaJhrF0Au3Il9AAABkGDIt9sAAAQDAEgwRgIhAN8OoC4I\n+zw8bFJy8ACgK40c9ZfsIfFhePTc9CyrL5uDsAiEA4Jn\/IqBB9L5DeTgqw9hBaYag\n+FmY\/2gWDip36ga0WUsAwDQYJKoZIhvcNAQELBQADggEBABywPLJP097Emz6LNeFU\n+\/HvfhaUKv2pgIHf\/Kvjs5x78RK9G605THPEHr\/TeUjNZ4PBd48WBNVWzyd\/8FuOt\n+r+FsYkRJb9CnrOhZHuCwlcdWXvuY8PiuBmT+xB16BWR5yhYbbiGe4hea0Pf6CfHh\n+jJoGJw4dQKfgneZOV7IcaWnNTKYawlcZOgxvEwFvj+iZM31WphEPKRAV+N+Tp+ZR\n+nxlEdjmdbOjqBydlYIEzuFIgxgtnPdK5wqCOWb+z2cARUAO\/AkiWrOLTPDc7ydQK\n+GcfDrSqffHOlwaee08C6STFaJWIcpqxZdXE6Jc+8\/85bfPEAG1UepgfnBTqW9RGT\n+Q3s=\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIEqDCCA5CgAwIBAgIQFylVHtaOf7Ht9XMA811\/1TANBgkqhkiG9w0BAQsFADBE\n+MQswCQYDVQQGEwJVUzEUMBIGA1UECgwLQWZmaXJtVHJ1c3QxHzAdBgNVBAMMFkFm\n+ZmlybVRydXN0IENvbW1lcmNpYWwwHhcNMTkwMzIxMjAyNzU0WhcNMzAxMjAyMDQw\n+MDAwWjCBgzELMAkGA1UEBhMCQ0ExFDASBgNVBAoTC0FmZmlybVRydXN0MSswKQYD\n+VQQLEyJTZWUgd3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MTEwLwYDVQQD\n+EyhBZmZpcm1UcnVzdCBFeHRlbmRlZCBWYWxpZGF0aW9uIENBIC0gRVYxMIIBIjAN\n+BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuPBMIa9VuXJGAw0MHvieGciPFA11\n+b9T49YJ7T+zVpoMMQO+ueUKVHb2l26oeCiwIhXMQ5LquOVcx+rofouzcKXY3wKDZ\n+zHIOnAkU+23Ucn\/3dRH7aHJULsBufZq+NvwgYSgJJEDKfqvIV\/c5HiRyZ2H+nAI5\n+10Q2xC0UxgSBsufccQ+Fwkg6BAGDlTXrvi8wi75UaGue6jv\/qcKLybeVUrgqKE64\n+d9oa9PG5\/g89QwSdsIQEdVSFzFvFpOG9YhJbJ177Zg6DGCxU0lWwFrVpyH\/2vnXl\n+jhMQScn8UxzCJdDg3EDqjgaV0JH2yoLug+QVYgURPu5BEb5ut9vAdP7cLwIDAQAB\n+o4IBVDCCAVAwNwYIKwYBBQUHAQEEKzApMCcGCCsGAQUFBzABhhtodHRwOi8vb2Nz\n+cC5hZmZpcm10cnVzdC5jb20wHQYDVR0OBBYEFNvvZTcL5UfLNdGQHwPBvIjHp+qA\n+MBIGA1UdEwEB\/wQIMAYBAf8CAQAwHwYDVR0jBBgwFoAUnZPGU4teyq8\/nx4P5ZmV\n+vCT2lI8wRwYDVR0gBEAwPjA8BgRVHSAAMDQwMgYIKwYBBQUHAgEWJmh0dHBzOi8v\n+d3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MEkGA1UdHwRCMEAwPqA8oDqG\n+OGh0dHA6Ly9jcmwuYWZmaXJtdHJ1c3QuY29tL2NybC9BZmZpcm1UcnVzdENvbW1l\n+cmNpYWwuY3JsMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcDAQYI\n+KwYBBQUHAwIwDQYJKoZIhvcNAQELBQADggEBAATH11fMrINGmQGQqQW0ATteVnUG\n+LrmRSN2OlmRm+dkUwKXhcQQEfYYlEggPqgvxSUpw13fXSOqVHqAcj3BIqF957kh+\n+m3DmC0RX9KaEKD165pf77P5nZcRmZpBl9cctvzIxN19uzcminchusYwLyeWhBtTZ\n+xpER9LbrfMNaQ7GnrgalMx54QvdjOhw\/GJs9\/SqEzYmPshL+DzgZX\/oAzY63rQIh\n+rBblf6\/2talZqci96oFzNst8rGfPy\/xQ7lgkki1hwIYbORMfloBhP+vAZJo0mxdM\n+ipu3Z0ToK+KU2iqnBxXVr2\/kod+CpkHnjUHa1wnQuSaefng3XwZ\/vqtSL9c=\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustcommercialca-chain.pem","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number: 8957382827206547757 (0x7c4f04391cd4992d)\n+        Signature Algorithm: sha1WithRSAEncryption\n+        Issuer: C=US, O=AffirmTrust, CN=AffirmTrust Networking\n+        Validity\n+            Not Before: Jan 29 14:08:24 2010 GMT\n+            Not After : Dec 31 14:08:24 2030 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIHGjCCBgKgAwIBAgIQX2vGPaCJ1tS0ncp2OlBMFjANBgkqhkiG9w0BAQsFADCB\n+gzELMAkGA1UEBhMCQ0ExFDASBgNVBAoTC0FmZmlybVRydXN0MSswKQYDVQQLEyJT\n+ZWUgd3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MTEwLwYDVQQDEyhBZmZp\n+cm1UcnVzdCBFeHRlbmRlZCBWYWxpZGF0aW9uIENBIC0gRVYzMB4XDTI0MDYyODIx\n+NDU0OVoXDTI1MDcyODIxNDU0OFowgdgxCzAJBgNVBAYTAkNBMRAwDgYDVQQIEwdP\n+bnRhcmlvMQ8wDQYDVQQHEwZPdHRhd2ExEzARBgsrBgEEAYI3PAIBAxMCQ0ExGDAW\n+BgsrBgEEAYI3PAIBAhMHT250YXJpbzEcMBoGA1UEChMTQWZmaXJtdHJ1c3QgTGlt\n+aXRlZDEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xEDAOBgNVBAUTBzI1\n+NDA1NDcxKDAmBgNVBAMTH3ZhbGlkbmV0d29ya2luZy5hZmZpcm10cnVzdC5jb20w\n+ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCkGknE8kFr+CaIybQrDPRw\n+z9OKXq77p4CnrkF1\/g9w\/HiIs6Ps8YqTjsiTKM3wYLbvPA+TbO9DpCSyCP2bVyLf\n+AjUE617KZSpfy9RqzvGjn\/1qH\/cBKohhEliMfDj4ZHfY4x+1WYTZPVK\/g0Ny5RAP\n+wz9lJHR2SsVGLvpqXzWaVoxifJ8HZWD7n5z\/75WeYko+Hubx3WvzJZcN2Xjn+q6a\n+7wkDaXPayrvn5uWGPlOLQHqJ5z7wts21jASMTfJAToFyzH6dGwvqxkP3bVJGJ8AF\n+vtMfqVjcOcjWgmmOEHMPAAqs5QKrYuSLccH6hFTwFEUCdMwVqfloznt2sNUSBoKj\n+AgMBAAGjggMxMIIDLTAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBTrE0z4fRyx9P9M\n+0FfA6VgGkJiYVDAfBgNVHSMEGDAWgBR5HrHJF8cerLHHFNfD6H+8uVCbFTBsBggr\n+BgEFBQcBAQRgMF4wJwYIKwYBBQUHMAGGG2h0dHA6Ly9vY3NwLmFmZmlybXRydXN0\n+LmNvbTAzBggrBgEFBQcwAoYnaHR0cDovL2FpYS5hZmZpcm10cnVzdC5jb20vYWZ0\n+ZXYzY2EuY3J0MDwGA1UdHwQ1MDMwMaAvoC2GK2h0dHA6Ly9jcmwuYWZmaXJtdHJ1\n+c3QuY29tL2NybC9hZnRldjNjYS5jcmwwKgYDVR0RBCMwIYIfdmFsaWRuZXR3b3Jr\n+aW5nLmFmZmlybXRydXN0LmNvbTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYI\n+KwYBBQUHAwEGCCsGAQUFBwMCMFYGA1UdIARPME0wBwYFZ4EMAQEwQgYKKwYBBAGC\n+jwkCAjA0MDIGCCsGAQUFBwIBFiZodHRwczovL3d3dy5hZmZpcm10cnVzdC5jb20v\n+cmVwb3NpdG9yeTCCAXwGCisGAQQB1nkCBAIEggFsBIIBaAFmAHYADeHyMCvTDcFA\n+YhIJ6lUu\/Ed0fLHX6TDvDkIetH5OqjQAAAGQYM\/MjQAABAMARzBFAiBjnehs1mvh\n+5Xm3uXZ7Bq8gijwiXThwnLSYROQxnWrnbAIhALbgJG+PRZQfzTBbgM\/zAwNsBjhe\n+F5iENnaajJCxzOhaAHUAEvFONL1TckyEBhnDjz96E\/jntWKHiJxtMAWE6+WGJjoA\n+AAGQYM\/MgQAABAMARjBEAiAsWOm1IIjaxQP9uaPI9tQmkiJPUOTrBTsTDO+jkgiG\n++QIgVNhND82rsFGjrtAAHzzgCVzLDUM3zaHxnP\/z3BNuO4QAdQAaBP9J0FQdQK\/2\n+oMO\/8djEZy9O7O4jQGiYaxdALtyJfQAAAZBgz8zLAAAEAwBGMEQCIBIGxtjk7Lw8\n+i+oggK7VrPMNTB632t321cwhEm517BbZAiBws3+uytwh59N6qGJUuSFQnOZNPOPj\n+eQnH2fSdT1J2sDANBgkqhkiG9w0BAQsFAAOCAQEAcSzitESRKlbcUvxvUB7FjK0I\n+CaBU1Nyu0xDFCoG2pmp7GASJz34wtPYfsiX5+j4hDh\/noMcgk7WlD8pzgWYw15Rk\n++5kTv2v4U85y\/JFjzMOHbz64KjQdGebqhjvC\/E\/EXxK+AZf4H574\/w7rbyJ30vFL\n+gNvPF9AxS1MuYIO55jXrHMByKnFoQZgPsmAY\/x+n+OzMxWOdR18PupypCB5TyJZ8\n+pQzwoxmX7qeZHiXyJ8jQUwe1qoQc2SbwfQxfwSPUPSJuQo90N+5nyQMe7vvPBM0Y\n+\/CXaFpfPqh71D4C0Ey+0hYxSt99gYs4P9twUByjIlP0wTyhaoEpt3zw9DdZypQ==\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIEqDCCA5CgAwIBAgIQNCSh7Pjwo1\/nRrcBHEPoRDANBgkqhkiG9w0BAQsFADBE\n+MQswCQYDVQQGEwJVUzEUMBIGA1UECgwLQWZmaXJtVHJ1c3QxHzAdBgNVBAMMFkFm\n+ZmlybVRydXN0IE5ldHdvcmtpbmcwHhcNMTkwMzIxMjAzODU5WhcNMzAxMjAyMDQw\n+MDAwWjCBgzELMAkGA1UEBhMCQ0ExFDASBgNVBAoTC0FmZmlybVRydXN0MSswKQYD\n+VQQLEyJTZWUgd3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MTEwLwYDVQQD\n+EyhBZmZpcm1UcnVzdCBFeHRlbmRlZCBWYWxpZGF0aW9uIENBIC0gRVYzMIIBIjAN\n+BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmHDl\/3xr1qiHoe0Rzb3AGLw56e9J\n+l2a3X59+PAfI5wGBHuK9Dl7XsyoH65X6QIC\/rXyVpuNgKbbwIGHB+rCSplyHzGyC\n+WeM3LXa2q1US7VteeFDS959nxJVRFfwATR9xAK6YTUWQ\/yWdw0dZSm0lQNmEMBwS\n+qi0ufWokiWXZUzWHOu7A6driCohu9sFDwe1INJUPH6uIlovmzGvG3UYbUSymJcjs\n+Ka0fXXX9zukco8exlOIKWRJSNLxKtSSPDVASrGLQ1xi3qkiLTKci3+jKMNDFf1vw\n+foZN99HhUcWKXfr2KlWfANdjTMlsTKCfuhfWl1OBVNHGRrACAQCXI\/ji0wIDAQAB\n+o4IBVDCCAVAwNwYIKwYBBQUHAQEEKzApMCcGCCsGAQUFBzABhhtodHRwOi8vb2Nz\n+cC5hZmZpcm10cnVzdC5jb20wHQYDVR0OBBYEFHkesckXxx6ssccU18Pof7y5UJsV\n+MBIGA1UdEwEB\/wQIMAYBAf8CAQAwHwYDVR0jBBgwFoAUBx\/S55zawm6iQLSwelAQ\n+UHTEyL0wRwYDVR0gBEAwPjA8BgRVHSAAMDQwMgYIKwYBBQUHAgEWJmh0dHBzOi8v\n+d3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MEkGA1UdHwRCMEAwPqA8oDqG\n+OGh0dHA6Ly9jcmwuYWZmaXJtdHJ1c3QuY29tL2NybC9BZmZpcm1UcnVzdE5ldHdv\n+cmtpbmcuY3JsMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcDAQYI\n+KwYBBQUHAwIwDQYJKoZIhvcNAQELBQADggEBAAhmE4I56hNpnWXQ2Si8a\/TgQUZr\n+X5Jlv1LDvl3rkDyfEIHNZ8dth17SakJYJBWHExph\/iIYjCJ9YmeyhghV5rPqT+wF\n+4yyE2ngenIusfnWT2bTpT9u2VZbCNeACE5XnN2UHSA0J9idPjfLuthViWEvSZZUh\n+DJ53bX+exO366nDY4AI7owIyhz8hdsWyhZ\/0ST+eD+kbgd8osd+GdxzRmyKcfl84\n+D1K1uff01T9w2dyUaZglQsFljkaO6xmeXZJsPnhwCp\/HlMHWzhAneUQ7I9FZSOW+\n+WiYbt4RitmBpysadBReikWM4knECzJQ\/fMT9vC0k9BLlqUYRwCH9vr0UnZo=\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustnetworkingca-chain.pem","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number: 7893706540734352110 (0x6d8c1446b1a60aee)\n+        Signature Algorithm: sha384WithRSAEncryption\n+        Issuer: C=US, O=AffirmTrust, CN=AffirmTrust Premium\n+        Validity\n+            Not Before: Jan 29 14:10:36 2010 GMT\n+            Not After : Dec 31 14:10:36 2040 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIIFjCCBv6gAwIBAgIQQVOTWr7tEAJXmRDkCSxkajANBgkqhkiG9w0BAQsFADCB\n+gzELMAkGA1UEBhMCQ0ExFDASBgNVBAoTC0FmZmlybVRydXN0MSswKQYDVQQLEyJT\n+ZWUgd3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MTEwLwYDVQQDEyhBZmZp\n+cm1UcnVzdCBFeHRlbmRlZCBWYWxpZGF0aW9uIENBIC0gRVYyMB4XDTI0MDYyODIx\n+NDgyN1oXDTI1MDcyODIxNDgyNlowgdUxCzAJBgNVBAYTAkNBMRAwDgYDVQQIEwdP\n+bnRhcmlvMQ8wDQYDVQQHEwZPdHRhd2ExEzARBgsrBgEEAYI3PAIBAxMCQ0ExGDAW\n+BgsrBgEEAYI3PAIBAhMHT250YXJpbzEcMBoGA1UEChMTQWZmaXJtdHJ1c3QgTGlt\n+aXRlZDEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xEDAOBgNVBAUTBzI1\n+NDA1NDcxJTAjBgNVBAMTHHZhbGlkcHJlbWl1bS5hZmZpcm10cnVzdC5jb20wggIi\n+MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDVRMzwbDq47ivHOKqJdiEJNL2+\n+g9Snj\/BRctqcQTrIV99RP0pmAh5fHg7vnhVsHqc9sRLVcQWTJk9NuRJ2VnDKWsBa\n+Xrp5UWaNjS0vaFA4jzCi1gWzTTZgPTQn3VRG3JP1F5CZb405\/mtWDaw\/CfWkcUqQ\n+VSilqFlJRsjcPCzQh7ZaXAo+FmzJxNSwjxdP6JSYMeTDRCUpSb3T8PypVI1CEmLZ\n+jsxrg5oIZn25591g\/pzgLE56N0stNY4d3q4YD1t5x46RsqYAJYSkk8rcTN+kHzsY\n+VSqaRDyPkGbmuCeJUvW24wJ30yQtXQWA+U0dMYLe7LyglJ7dkOzvWNbqrIcvM8My\n+hxH\/wwVH7e4dL\/1E58yr1BHENUk7Mp9rzIXj496eLkF5G1lMkNnuVRQqCAOW0rPY\n+V0rI8yrCMTK52s4mNjQo2J7JOYdTUvAWZ92MKvEjjhQlMH8eK72Km\/+mkxpsgGmr\n+3c6u+Gom7oI5VaLZ+3p2uWaOsutk1tkzWjhzY4L27hwmIdWujfrWMRx8uxcfoJxX\n+gQ40d1QiSN51BtCPE5UnpLU\/YUxMdzWmtUoGUfYIGVqDVToBnunIFMdmFjC0IrNl\n+hquDQi\/OGMpzuOvxX1FoXb+rRwOhhdrcR0BQqUVRTV0U5LlcsDeNMqmqPE9mzGtJ\n+W69Fsh7crntng\/L72wIDAQABo4IDMDCCAywwDAYDVR0TAQH\/BAIwADAdBgNVHQ4E\n+FgQU3PWyi\/4usZghgahc\/Tj+Q60QLOcwHwYDVR0jBBgwFoAUc3yaOGg8UXxBCP6h\n+HyoetGHbzTwwbAYIKwYBBQUHAQEEYDBeMCcGCCsGAQUFBzABhhtodHRwOi8vb2Nz\n+cC5hZmZpcm10cnVzdC5jb20wMwYIKwYBBQUHMAKGJ2h0dHA6Ly9haWEuYWZmaXJt\n+dHJ1c3QuY29tL2FmdGV2MmNhLmNydDA8BgNVHR8ENTAzMDGgL6AthitodHRwOi8v\n+Y3JsLmFmZmlybXRydXN0LmNvbS9jcmwvYWZ0ZXYyY2EuY3JsMCcGA1UdEQQgMB6C\n+HHZhbGlkcHJlbWl1bS5hZmZpcm10cnVzdC5jb20wDgYDVR0PAQH\/BAQDAgWgMB0G\n+A1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjBWBgNVHSAETzBNMAcGBWeBDAEB\n+MEIGCisGAQQBgo8JAgMwNDAyBggrBgEFBQcCARYmaHR0cHM6Ly93d3cuYWZmaXJt\n+dHJ1c3QuY29tL3JlcG9zaXRvcnkwggF+BgorBgEEAdZ5AgQCBIIBbgSCAWoBaAB2\n+ABoE\/0nQVB1Ar\/agw7\/x2MRnL07s7iNAaJhrF0Au3Il9AAABkGDSN7EAAAQDAEcw\n+RQIgVDWwhv7yG6RNnkMZnVq1YYA7ypn\/GSH0ibUKnESHRpYCIQCY8gyCX7VFONUI\n+QuR8daz7ra2FCUI9TwylrR3eFfIgGgB3AN3cyjSV1+EWBeeVMvrHn\/g9HFDf2wA6\n+FBJ2Ciysu8gqAAABkGDSN5cAAAQDAEgwRgIhAM1edsSyFUKU0Dj1WxTGwziE6fCW\n+g2ByfL8kDrP260YXAiEA6YQOpJf04N13Nn263BxAl+laH9Ar0eo03fArlv743TQA\n+dQAN4fIwK9MNwUBiEgnqVS78R3R8sdfpMO8OQh60fk6qNAAAAZBg0je+AAAEAwBG\n+MEQCIExqK4katETAQo+H0+ImuNJCSeFEI9C+9wrjhl6ZnWb9AiBwkC1vpLYOIm\/1\n+YCLCQIOmTdg2wf8LITlrQNJA8vbBljANBgkqhkiG9w0BAQsFAAOCAQEASOmPu7ot\n+yl6MoMns19uI6H2KSUjMFh3\/fKMcY\/ettmEYalgrytexFMrLnD2UniBlD+nJEshp\n+5\/z7o0YDiRoiLhMAs7VqIdX3erNu\/ghNh7P2bDnoMWShSoAKxez1XOGL3rRE0NAi\n+DsWCaNRHH9rnC97275sbGnua7ZYg+8BiF62vpJlqjrxDHjGiej8qAWSjztbB43Af\n+bwRscpXTxNkMvOBuRFMH+rSxB8CrOV68W+yxmzPuPxVjM7oJH8Qk5BC53NRqFsVz\n+JhbNfot0+\/drj7JT3jlacUVQcD\/BzDuC3+qczQlLjLdHgQM2\/e4fXsD6C5S6B11d\n+BDx6ipGpaASofA==\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIFojCCA4qgAwIBAgIQU3HI6weE\/VEI5dTz4yPsRjANBgkqhkiG9w0BAQsFADBB\n+MQswCQYDVQQGEwJVUzEUMBIGA1UECgwLQWZmaXJtVHJ1c3QxHDAaBgNVBAMME0Fm\n+ZmlybVRydXN0IFByZW1pdW0wHhcNMTkwMzIxMjA0NjM1WhcNMzAxMjAyMDQwMDAw\n+WjCBgzELMAkGA1UEBhMCQ0ExFDASBgNVBAoTC0FmZmlybVRydXN0MSswKQYDVQQL\n+EyJTZWUgd3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MTEwLwYDVQQDEyhB\n+ZmZpcm1UcnVzdCBFeHRlbmRlZCBWYWxpZGF0aW9uIENBIC0gRVYyMIIBIjANBgkq\n+hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvDDZHfxkB1nAGFKdw0VCgV+B\/eBtW1o+\n+bXzwRcpeFh5saDI+tv1RAMrYFq+AJkXCCJopgMF2Wqfv5myE3JMgxEHuuKUpJz7H\n+FprrFckVOGCtJKH8Iy9AWPjBwt8lKmxGJF7EZst+QoVt4hMe0qhL0WEKbATFPe41\n+DcM7UsyQv6Bvpn424uePy3\/1ATIsVL3YmvAbUNR0aqVxYAJzTefvyIet\/761bKGc\n+NyqdOVWFFeTDtr8iL1TBXToAgl0GJ39bFQZsP19VcCpfk9Zj3YHTPRPq5wZOZuUN\n+F7jiBUEi6DaVOi3Wy4vdySHtWPeBHRYif1I6fcUfdCNORMc4ee6KewIDAQABo4IB\n+UTCCAU0wNwYIKwYBBQUHAQEEKzApMCcGCCsGAQUFBzABhhtodHRwOi8vb2NzcC5h\n+ZmZpcm10cnVzdC5jb20wHQYDVR0OBBYEFHN8mjhoPFF8QQj+oR8qHrRh2808MBIG\n+A1UdEwEB\/wQIMAYBAf8CAQAwHwYDVR0jBBgwFoAUncBnpgwi2Sb1RaumZVIRJ9hF\n+rGMwRwYDVR0gBEAwPjA8BgRVHSAAMDQwMgYIKwYBBQUHAgEWJmh0dHBzOi8vd3d3\n+LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MEYGA1UdHwQ\/MD0wO6A5oDeGNWh0\n+dHA6Ly9jcmwuYWZmaXJtdHJ1c3QuY29tL2NybC9BZmZpcm1UcnVzdFByZW1pdW0u\n+Y3JsMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUH\n+AwIwDQYJKoZIhvcNAQELBQADggIBABi64UEwl3l0yIiuSACyVQQIBI60BUmhseac\n+4BzCAsJrR5tE\/2U9QAa2y6JpR1nqm76DJvw1QQgvFcNe+fkwpvoViCaSTbZkGGwD\n+mQe2xRSYJcDSMQUc\/GgzLcX2c1CrexQXE1vwV\/q33af1en5s1GzLl915aNS\/k1ch\n+G7EMruJ\/D4cuH9j4j2i+b+llmVBzavBwelN5rc693o+Ot9id\/1sTWNugwAu3uXGb\n+VlhETMnjXGIciegOLdWYhWBln0izYlt9IwlDEpjMVaZ0HZlj2JBGaSe4PfEFpJPO\n+beuPcQpLQGw2XpW2ZMG5JcRYaoKWjixXAGktRA3H9nvVW92jvzx\/RX484w2ZM5Rt\n+E+I1ikAuQLAyWG7clht387e2RuC3NZTtefSyjE3L9gQDOPC+Z9ycwr0WJHRsxFvh\n+FJQi3JnxgFZf5mc5n2mh3qAgALTNOUHuDiHrerjTOWbpF\/1\/NJmo\/c\/YZ63vZIhc\n+EaER4HuhbBqlpf6z3WOIQdZm1ChwXYHrEcLDgfwm9cXoaVK2HZapkMwQbPffPlT1\n+E+AxRFB4YmT1y2WzdaHfhFA9nH6ByUdL5+FfrDoIIUO2e8OLOAcrJsf5+unhAhc0\n+v7N48JWdmpstjkXCaCIaidrZLJxS+pikNgHB1dXF\/TxokLTiPB9jcYKdGaYs3XHb\n+YKLdwubu\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustpremiumca-chain.pem","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number: 8401224907861490260 (0x7497258ac73f7a54)\n+        Signature Algorithm: ecdsa-with-SHA384\n+        Issuer: C=US, O=AffirmTrust, CN=AffirmTrust Premium ECC\n+        Validity\n+            Not Before: Jan 29 14:20:24 2010 GMT\n+            Not After : Dec 31 14:20:24 2040 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIF0zCCBVmgAwIBAgIQFVwk9nYUM5SYOnBd+IoGtzAKBggqhkjOPQQDAzCBhTEL\n+MAkGA1UEBhMCQ0ExFDASBgNVBAoTC0FmZmlybVRydXN0MSswKQYDVQQLEyJTZWUg\n+d3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MTMwMQYDVQQDEypBZmZpcm1U\n+cnVzdCBFeHRlbmRlZCBWYWxpZGF0aW9uIENBIC0gRVZFQzEwHhcNMjQwNjI4MjE0\n+OTUwWhcNMjUwNzI4MjE0OTQ4WjCB2DELMAkGA1UEBhMCQ0ExEDAOBgNVBAgTB09u\n+dGFyaW8xDzANBgNVBAcTBk90dGF3YTETMBEGCysGAQQBgjc8AgEDEwJDQTEYMBYG\n+CysGAQQBgjc8AgECEwdPbnRhcmlvMRwwGgYDVQQKExNBZmZpcm10cnVzdCBMaW1p\n+dGVkMR0wGwYDVQQPExRQcml2YXRlIE9yZ2FuaXphdGlvbjEQMA4GA1UEBRMHMjU0\n+MDU0NzEoMCYGA1UEAxMfdmFsaWRwcmVtaXVtZWNjLmFmZmlybXRydXN0LmNvbTB2\n+MBAGByqGSM49AgEGBSuBBAAiA2IABEkLBzBYSJPRENKDaA1iBPQz+jZUV+OoM9nJ\n+sr9sMfmHaqr3nlWxAMM99b9\/usVfYyUxqyi+YL2Z3ZSxjX2dpyhwMtPpIQkL1pMW\n+Iv55XBIcYRyl2NjcADS9B06G+nnix6OCAzcwggMzMAwGA1UdEwEB\/wQCMAAwHQYD\n+VR0OBBYEFP+37ywf2YJJ\/4CEVy1GY4ioGm1yMB8GA1UdIwQYMBaAFMaQjAKD113j\n+vjucLtVlfSoQYO7lMG4GCCsGAQUFBwEBBGIwYDAnBggrBgEFBQcwAYYbaHR0cDov\n+L29jc3AuYWZmaXJtdHJ1c3QuY29tMDUGCCsGAQUFBzAChilodHRwOi8vYWlhLmFm\n+ZmlybXRydXN0LmNvbS9hZnRldmVjMWNhLmNydDA+BgNVHR8ENzA1MDOgMaAvhi1o\n+dHRwOi8vY3JsLmFmZmlybXRydXN0LmNvbS9jcmwvYWZ0ZXZlYzFjYS5jcmwwKgYD\n+VR0RBCMwIYIfdmFsaWRwcmVtaXVtZWNjLmFmZmlybXRydXN0LmNvbTAOBgNVHQ8B\n+Af8EBAMCB4AwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMFYGA1UdIARP\n+ME0wBwYFZ4EMAQEwQgYKKwYBBAGCjwkCBDA0MDIGCCsGAQUFBwIBFiZodHRwczov\n+L3d3dy5hZmZpcm10cnVzdC5jb20vcmVwb3NpdG9yeTCCAX4GCisGAQQB1nkCBAIE\n+ggFuBIIBagFoAHUA5tIxY0B3jMEQQQbXcbnOwdJA9paEhvu6hzId\/R43jlAAAAGQ\n+YNN5tQAABAMARjBEAiAnainEoBGI9czVh+c9QLPL30S3Rtov8zrnhlXfeKLzZQIg\n+UGkntBMux0MqHt9Aj60qMsS\/C4ZWF7AihVVaUKcrEVgAdgAN4fIwK9MNwUBiEgnq\n+VS78R3R8sdfpMO8OQh60fk6qNAAAAZBg03m1AAAEAwBHMEUCIGI9kBByoozH4cfS\n+ECW\/O2N\/ElkdATkt7EwQ52kcc4ICAiEA9QTh8JlJTb\/ytYC1ECX0vQbrYVexg+fu\n+dw7dfToF9nAAdwAS8U40vVNyTIQGGcOPP3oT+Oe1YoeInG0wBYTr5YYmOgAAAZBg\n+03ndAAAEAwBIMEYCIQCox5nSCcVB2AfNYXco77zsJnYP7KAU2I4VA2GNL7I4wQIh\n+AP6WEzyfBoGpYYqFmNnJUavyhKBmeNiR7eNtaFwpSc+UMAoGCCqGSM49BAMDA2gA\n+MGUCMAGSNMXAAKDRk0ZOtydN95Rkja97+70TatCIIxEAsJD8Hu7lfj2LHCYFQjVY\n+oaWTrQIxAKUudx7E\/JnjsthuL6sNqKVHfD3iLUJyQNK9wE0SVt1xAm7Cu1JXZORE\n+M64KMKoQFQ==\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIDXDCCAuKgAwIBAgIQAgKlhME0Bk3J8y0gfqNymDAKBggqhkjOPQQDAzBFMQsw\n+CQYDVQQGEwJVUzEUMBIGA1UECgwLQWZmaXJtVHJ1c3QxIDAeBgNVBAMMF0FmZmly\n+bVRydXN0IFByZW1pdW0gRUNDMB4XDTE5MDMyMTIwNTUwN1oXDTMwMTIwMjA0MDAw\n+MFowgYUxCzAJBgNVBAYTAkNBMRQwEgYDVQQKEwtBZmZpcm1UcnVzdDErMCkGA1UE\n+CxMiU2VlIHd3dy5hZmZpcm10cnVzdC5jb20vcmVwb3NpdG9yeTEzMDEGA1UEAxMq\n+QWZmaXJtVHJ1c3QgRXh0ZW5kZWQgVmFsaWRhdGlvbiBDQSAtIEVWRUMxMHYwEAYH\n+KoZIzj0CAQYFK4EEACIDYgAEu9f5NkumdaVlmaNaxpDB+rBk\/S6lhqcUU1zTLcRz\n+4G0dr4290hezjrvZJxGJ\/X15aexpdD2V9cwaPD\/yuEJcaaz+rg\/qDoqQF3+AFqVc\n+41jw1E0S59+57XVKLtXI7Xh6o4IBVDCCAVAwNwYIKwYBBQUHAQEEKzApMCcGCCsG\n+AQUFBzABhhtodHRwOi8vb2NzcC5hZmZpcm10cnVzdC5jb20wHQYDVR0OBBYEFMaQ\n+jAKD113jvjucLtVlfSoQYO7lMBIGA1UdEwEB\/wQIMAYBAf8CAQAwHwYDVR0jBBgw\n+FoAUmq8pesARNTUmUTAAw2r+QNWu1jwwRwYDVR0gBEAwPjA8BgRVHSAAMDQwMgYI\n+KwYBBQUHAgEWJmh0dHBzOi8vd3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5\n+MEkGA1UdHwRCMEAwPqA8oDqGOGh0dHA6Ly9jcmwuYWZmaXJtdHJ1c3QuY29tL2Ny\n+bC9BZmZpcm1UcnVzdFByZW1pdW1FQ0MuY3JsMA4GA1UdDwEB\/wQEAwIBhjAdBgNV\n+HSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwCgYIKoZIzj0EAwMDaAAwZQIwHJ5g\n+a6sHvQ51DGr0bWq34awuwlWbybC2grHoNp5uYapcXr\/qTJusb\/6n+dczqFdaAjEA\n+7VQY06fE9ifMnTgT9824jc3+H6kfhMk4PoIj9ouWdYfc1DyTBS\/low9Hb8liQyFr\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustpremiumeccca-chain.pem","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number: 946069240 (0x3863def8)\n+        Signature Algorithm: sha1WithRSAEncryption\n+        Issuer: O=Entrust.net, OU=www.entrust.net\/CPS_2048 incorp. by ref. (limits liab.), OU=(c) 1999 Entrust.net Limited, CN=Entrust.net Certification Authority (2048)\n+        Validity\n+            Not Before: Dec 24 17:50:51 1999 GMT\n+            Not After : Jul 24 14:15:12 2029 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIGiDCCBXCgAwIBAgIQS5P8oVcgTBT74PnIwDQivjANBgkqhkiG9w0BAQsFADCB\n+ujELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsT\n+H1NlZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAy\n+MDEyIEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEuMCwG\n+A1UEAxMlRW50cnVzdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEwxSzAeFw0y\n+MzEwMDIxOTE4MTBaFw0yNDExMDIxOTE4MDlaMGkxCzAJBgNVBAYTAkNBMRAwDgYD\n+VQQIEwdPbnRhcmlvMQ8wDQYDVQQHEwZPdHRhd2ExGDAWBgNVBAoTD0VudHJ1c3Qg\n+TGltaXRlZDEdMBsGA1UEAxMUMjA0OHRlc3QuZW50cnVzdC5uZXQwggEiMA0GCSqG\n+SIb3DQEBAQUAA4IBDwAwggEKAoIBAQCgkrsKoDEHyJjll\/fu7mjvtbookb50rzTI\n+i+jQzvtL8AJOcCfxJL1cVriufc\/zRYdSQeRJxkbUb+SqIJkec+27onPpY3xOjJAK\n+bWdmac1Iv9JPXYMpKJXnOGrooeXEtCcKSKphx4VhHnLA67BGfSNfHLm4JwghX4jY\n+VpZ8P89gmh8l1eLRP+b3y7OzEkFliwmErALSD8i\/bkzE+GxYMnpg\/HI2Iw1lakxE\n+wZOg0ydgl7jHWZUDdnxhAvLS\/hfzPVhi9ZwgoXQJiUXUp0JJo6QgVOIC5IztpdZa\n+3HW1VK7a0eTLhmdFRx39ARn\/GbbIyoIqUzLOhAa2cbsGIJjtXjhrAgMBAAGjggLY\n+MIIC1DAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBRHn0CebGnHRqTZTeTYCbPHhiVB\n+MzAfBgNVHSMEGDAWgBSConB03bxTP8971PfNf6dgxgpMvzBoBggrBgEFBQcBAQRc\n+MFowIwYIKwYBBQUHMAGGF2h0dHA6Ly9vY3NwLmVudHJ1c3QubmV0MDMGCCsGAQUF\n+BzAChidodHRwOi8vYWlhLmVudHJ1c3QubmV0L2wxay1jaGFpbjI1Ni5jZXIwMwYD\n+VR0fBCwwKjAooCagJIYiaHR0cDovL2NybC5lbnRydXN0Lm5ldC9sZXZlbDFrLmNy\n+bDAfBgNVHREEGDAWghQyMDQ4dGVzdC5lbnRydXN0Lm5ldDAOBgNVHQ8BAf8EBAMC\n+BaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMBMGA1UdIAQMMAowCAYG\n+Z4EMAQICMIIBfgYKKwYBBAHWeQIEAgSCAW4EggFqAWgAdwA\/F0tP1yJHWJQdZRyE\n+vg0S7ZA3fx+FauvBvyiF7PhkbgAAAYrx05lbAAAEAwBIMEYCIQDbMXKdzSr90jM+\n+TekjpqVTEBDDvub7+AEx\/kQYzf9gugIhAKPCjJmIh1NZrKkwK8MsOEL4jkN6FJ\/h\n+4kiiJoze3fB\/AHYAdv+IPwq2+5VRwmHM9Ye6NLSkzbsp3GhCCp\/mZ0xaOnQAAAGK\n+8dOZVAAABAMARzBFAiAW11p7sV2byjrpk6AMQrMGwV2CuT3AKNuQVyxva7XQPAIh\n+AP1P7DfYsZ1aR12Tkg2x2BYjFrlsJCl36n5I\/565xQk4AHUA2ra\/az+1tiKfm8K7\n+XGvocJFxbLtRhIU0vaQ9MEjX+6sAAAGK8dOZnwAABAMARjBEAiA43NURCcnHNpkH\n+XggwpVY9QYNIEAjpHEcPmyXJuQ9y8QIgPqx0MnlKXLuJVReuI5Hzc3iFtcYo070d\n+UYWH2AuVaFwwDQYJKoZIhvcNAQELBQADggEBAIZoSHApNF6DNYvGKHZJX411QkA0\n+5zkq3dcm95BFomaqroEp1QeUeQ8e6xofUs84CURzopE9P81JBHX2Qzb\/VeBzZOKy\n+dekaoz4NGW5ZvpMh7HXXaUpHKU\/xZ5uUHVSatBU+cnidPhgn1czntqOwjzsgEZNW\n+\/wbPEjqvIrZvAW4DPak\/MSwlENys4ty5gX4453S5gwd18b+NFBq44O\/FofR8bvWU\n+3lJ3VcVeONDzTcXPv+Yd1SlyO1\/eXdWlFqloYFjkpcQ4wSLbOEeiWWITkZ0xCAxQ\n+j8uWuDOSyFQLpaPJvEuG1dlho7RZdor0flUIxYfqg2Nr4Svq1ezskwrdQm0=\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIFKjCCBBKgAwIBAgIQLgRRzl0kJMcrXWV2cWUG2DANBgkqhkiG9w0BAQsFADCB\n+tDEUMBIGA1UEChMLRW50cnVzdC5uZXQxQDA+BgNVBAsUN3d3dy5lbnRydXN0Lm5l\n+dC9DUFNfMjA0OCBpbmNvcnAuIGJ5IHJlZi4gKGxpbWl0cyBsaWFiLikxJTAjBgNV\n+BAsTHChjKSAxOTk5IEVudHJ1c3QubmV0IExpbWl0ZWQxMzAxBgNVBAMTKkVudHJ1\n+c3QubmV0IENlcnRpZmljYXRpb24gQXV0aG9yaXR5ICgyMDQ4KTAeFw0yMjExMjUy\n+MTE5NDNaFw0yOTA3MjMwMDAwMDBaMIG6MQswCQYDVQQGEwJVUzEWMBQGA1UEChMN\n+RW50cnVzdCwgSW5jLjEoMCYGA1UECxMfU2VlIHd3dy5lbnRydXN0Lm5ldC9sZWdh\n+bC10ZXJtczE5MDcGA1UECxMwKGMpIDIwMTIgRW50cnVzdCwgSW5jLiAtIGZvciBh\n+dXRob3JpemVkIHVzZSBvbmx5MS4wLAYDVQQDEyVFbnRydXN0IENlcnRpZmljYXRp\n+b24gQXV0aG9yaXR5IC0gTDFLMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC\n+AQEA2j+W0E25L0Tn2zlem1DuXKVh2kFnUwmqAJqOV38pa9vH4SEkqjrQjUcj0u1y\n+FvCRIdJdt7hLqIOPt5EyaM\/OJZMssn2XyP7BtBe6CZ4DkJN7fEmDImiKm95HwzGY\n+ei59QAvS7z7Tsoyqj0ip\/wDoKVgG97aTWpRzJiatWA7lQrjV6nN5ZGhTJbiEz5R6\n+rgZFDKNrTdDGvuoYpDbwkrK6HIiPOlJ\/915tgxyd8B\/lw9bdpXiSPbBtLOrJz5RB\n+GXFEaLpHPATpXbo+8DX3Fbae8i4VHj9HyMg4p3NFXU2wO7GOFyk36t0FASK7lDYq\n+jVs1\/lMZLwhGwSqzGmIdTivZGwIDAQABo4IBLjCCASowEgYDVR0TAQH\/BAgwBgEB\n+\/wIBADAdBgNVHQ4EFgQUgqJwdN28Uz\/Pe9T3zX+nYMYKTL8wHwYDVR0jBBgwFoAU\n+VeSB0RGAvtiJuQijMfmhJAkWuXAwMwYIKwYBBQUHAQEEJzAlMCMGCCsGAQUFBzAB\n+hhdodHRwOi8vb2NzcC5lbnRydXN0Lm5ldDAyBgNVHR8EKzApMCegJaAjhiFodHRw\n+Oi8vY3JsLmVudHJ1c3QubmV0LzIwNDhjYS5jcmwwDgYDVR0PAQH\/BAQDAgEGMB0G\n+A1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjA8BgNVHSAENTAzMDEGBFUdIAAw\n+KTAnBggrBgEFBQcCARYbaHR0cHM6Ly93d3cuZW50cnVzdC5uZXQvcnBhMA0GCSqG\n+SIb3DQEBCwUAA4IBAQAuAlHLO8CoKt2a4I23UDkKc7kQI3nUkWqq2RxRh8a\/4TEF\n+C9WSF03EHVBW9JZZcrZ3ZdTDRsNF8vSqmCABz1FLu6vw3D3bEXELonAYlkmeFFV7\n+1hiW9AdyMJD92XsXiU0Yr9J76Tk4iknMTTHiZXdZOcPMOXlMwPy++HS5tTIyqO0d\n+zl1PS8tlCcZrKaNNKbmiIWPhmBUSog9IQt2VKpoAIP8tlvRt5tHf5qW5m7vp7qmG\n+HF2ou54+qQIXO6jIP8CQ4xWvj0aiLklTNMkvXesaVq0xzNgRkx9ZzhREfbuM6eWc\n+GQHwG7m+JmfL+u1dCAZhh4Uyn5oLU9gogFM6v4jX\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrust2048ca-chain.pem","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number: 1164660820 (0x456b5054)\n+        Signature Algorithm: sha1WithRSAEncryption\n+        Issuer: C=US, O=Entrust, Inc., OU=www.entrust.net\/CPS is incorporated by reference, OU=(c) 2006 Entrust, Inc., CN=Entrust Root Certification Authority\n+        Validity\n+            Not Before: Nov 27 20:23:42 2006 GMT\n+            Not After : Nov 27 20:53:42 2026 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIHEjCCBfqgAwIBAgIQFhH4VGskTR+tQK3JbN63kTANBgkqhkiG9w0BAQsFADCB\n+sTELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xOTA3BgNVBAsT\n+MHd3dy5lbnRydXN0Lm5ldC9ycGEgaXMgaW5jb3Jwb3JhdGVkIGJ5IHJlZmVyZW5j\n+ZTEfMB0GA1UECxMWKGMpIDIwMDkgRW50cnVzdCwgSW5jLjEuMCwGA1UEAxMlRW50\n+cnVzdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEwxRTAeFw0yNDA2MjgyMTQw\n+NDVaFw0yNTA3MjgyMTQwNDRaMIHIMQswCQYDVQQGEwJDQTEQMA4GA1UECBMHT250\n+YXJpbzEPMA0GA1UEBxMGT3R0YXdhMRMwEQYLKwYBBAGCNzwCAQMTAkNBMRgwFgYL\n+KwYBBAGCNzwCAQITB09udGFyaW8xGDAWBgNVBAoTD0VudHJ1c3QgTGltaXRlZDEd\n+MBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xEDAOBgNVBAUTBzE5MTM2MDUx\n+HDAaBgNVBAMTE3ZhbGlkZXYuZW50cnVzdC5uZXQwggEiMA0GCSqGSIb3DQEBAQUA\n+A4IBDwAwggEKAoIBAQDL2vkrBEZ5qeVdac1C01bcNnoeCU3AVU3Fh1Ifldic9\/Gw\n+xqNVOFYQNzTk8M62FnPUvas4MnXmeBkPhhym+dnjsM22EeS2p6gTlvOGtJFVr+Ix\n+vq1UAKtqK0gYGriW6SexroSYiG1O0aeqEnKSLlEBHYhmacj2jlbx0ToxMfdBMRRq\n+4UjnIrh\/CBochxt7aKv525tChnZGMT06QKAjx71w2cou0C05v83KJ75EI4EAmTfE\n+z9sKJeST5pH5MI3WKcP6ZmXynKYSIpIGb4Z8B9Ftp8HdzdR9EafOSlRlbIkEn3lm\n+nq4UCph48\/PsUcJoViBCoY6zDLcPGt3gGQVIjq3vAgMBAAGjggMLMIIDBzAMBgNV\n+HRMBAf8EAjAAMB0GA1UdDgQWBBRF6MZkqXf3sICXuvbrBH1R9I8bAjAfBgNVHSME\n+GDAWgBRbQYqyxEPBvb\/IVEFVneCWrf+5oTBlBggrBgEFBQcBAQRZMFcwIwYIKwYB\n+BQUHMAGGF2h0dHA6Ly9vY3NwLmVudHJ1c3QubmV0MDAGCCsGAQUFBzAChiRodHRw\n+Oi8vYWlhLmVudHJ1c3QubmV0L2wxZS1jaGFpbi5jZXIwMwYDVR0fBCwwKjAooCag\n+JIYiaHR0cDovL2NybC5lbnRydXN0Lm5ldC9sZXZlbDFlLmNybDAeBgNVHREEFzAV\n+ghN2YWxpZGV2LmVudHJ1c3QubmV0MA4GA1UdDwEB\/wQEAwIFoDAdBgNVHSUEFjAU\n+BggrBgEFBQcDAQYIKwYBBQUHAwIwSwYDVR0gBEQwQjAHBgVngQwBATA3BgpghkgB\n+hvpsCgECMCkwJwYIKwYBBQUHAgEWG2h0dHBzOi8vd3d3LmVudHJ1c3QubmV0L3Jw\n+YTCCAX0GCisGAQQB1nkCBAIEggFtBIIBaQFnAHUAEvFONL1TckyEBhnDjz96E\/jn\n+tWKHiJxtMAWE6+WGJjoAAAGQYMsp8gAABAMARjBEAiAL794Fw7wyzricvRl+2AON\n+FbGf2hwDB3wh8RkGLBRQ7AIgTCarii0atho7ZeUO3h66Ug7s7WxnF9onDZrtoMrH\n+U9MAdQAN4fIwK9MNwUBiEgnqVS78R3R8sdfpMO8OQh60fk6qNAAAAZBgyyoMAAAE\n+AwBGMEQCIFaXc4M9C9mNukrV68Sc2E5lw9srQ80nMBCGseY99nFxAiAppQmR9FKC\n+TE\/ROlgZRfimx61W4k+SaQ52eek4JNWXXwB3ABoE\/0nQVB1Ar\/agw7\/x2MRnL07s\n+7iNAaJhrF0Au3Il9AAABkGDLKi0AAAQDAEgwRgIhAPFUevU47H5uJqYL5y1ClFS7\n+mEve7E8350JKnR1VykGLAiEArn7VAJcmRNNCDAegsHCCLlpasz9PLHFd9XHQAwvL\n+IFwwDQYJKoZIhvcNAQELBQADggEBAHfMCQP5Y+7IYzqOh5D\/81WqHagmWOqkJYsN\n+33uux44fhVGqiG1O5ImTQsxJpt\/HmDuK1qLEjG31Y9q89U91KAqLQauCQ5iMXrBg\n+TlwK8kzO1XYC5KkpO5ZWanqfjOahM9mkEKHPV9srwj6xTbInCq9DabRwuWyohj3b\n+EKrmB016TOT0hJ94jCb8PWl15oQJdsGlEfrG7amtDSRuoDHVA3nXJIJqx5LVnErB\n+glfsAmP8TPkWYY8kuNE2Rjr2M6P5LRLEvtRELCQF3lPuY0+xxGksGVM207YqhYKv\n+GzMmA8c7tF3ZclbE0rUA2T8FuBuweAV8tnWq2TaeAHWIJ4nY17s=\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIFHjCCBAagAwIBAgIRAIZmsCrBy1RAAAAAAFHTWJwwDQYJKoZIhvcNAQELBQAw\n+gbAxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMTkwNwYDVQQL\n+EzB3d3cuZW50cnVzdC5uZXQvQ1BTIGlzIGluY29ycG9yYXRlZCBieSByZWZlcmVu\n+Y2UxHzAdBgNVBAsTFihjKSAyMDA2IEVudHJ1c3QsIEluYy4xLTArBgNVBAMTJEVu\n+dHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0xOTA2MTkxNjUy\n+MDhaFw0yNjExMTkxNzIyMDhaMIGxMQswCQYDVQQGEwJVUzEWMBQGA1UEChMNRW50\n+cnVzdCwgSW5jLjE5MDcGA1UECxMwd3d3LmVudHJ1c3QubmV0L3JwYSBpcyBpbmNv\n+cnBvcmF0ZWQgYnkgcmVmZXJlbmNlMR8wHQYDVQQLExYoYykgMjAwOSBFbnRydXN0\n+LCBJbmMuMS4wLAYDVQQDEyVFbnRydXN0IENlcnRpZmljYXRpb24gQXV0aG9yaXR5\n+IC0gTDFFMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtlsEVHfdDiRm\n+3Cqh24DMXcdf\/VIWWNpflAapuLa5YwxHIILsx5VOi7h3Umo9tYep1uHMdOWmyMDU\n+Vk+NLtYIPgxMQz7wQZNeRu8559llKgx2UCe9Ww0zMwfg96KpnOERM61m\/NIseqqj\n+cxa+k4V1D9c3jPojt2T440xu7bMFveI223zedkTagnJ2tm7\/lKHQhvcQzUpai7B1\n+jGZSgE5ITEmDpkDXd4ETTV5yfkhGIqoP4j5llDjhcnH+SnEJujV\/VYk9gdW4KAEQ\n+dzZaEIXSvWCEK0lhlAzeTEBqKsR5YIQkgjJpSphL4lYQugNFUSDTz9qOVBtFtnq6\n+l5pa2MbRXwIDAQABo4IBLjCCASowDgYDVR0PAQH\/BAQDAgGGMB0GA1UdJQQWMBQG\n+CCsGAQUFBwMBBggrBgEFBQcDAjASBgNVHRMBAf8ECDAGAQH\/AgEAMDMGCCsGAQUF\n+BwEBBCcwJTAjBggrBgEFBQcwAYYXaHR0cDovL29jc3AuZW50cnVzdC5uZXQwMwYD\n+VR0fBCwwKjAooCagJIYiaHR0cDovL2NybC5lbnRydXN0Lm5ldC9yb290Y2ExLmNy\n+bDA7BgNVHSAENDAyMDAGBFUdIAAwKDAmBggrBgEFBQcCARYaaHR0cDovL3d3dy5l\n+bnRydXN0Lm5ldC9ycGEwHQYDVR0OBBYEFFtBirLEQ8G9v8hUQVWd4Jat\/7mhMB8G\n+A1UdIwQYMBaAFGiQ5GekplOAx4ZmpPH3S0P7hL1tMA0GCSqGSIb3DQEBCwUAA4IB\n+AQAPUNBX97sqIXZl\/zLu53iv7a0HK7prvD0cVaZM0yRfVptvARgjIZZzTtv32v6X\n+wSr4fDeRmpLaTWtipBGSqh3fNkTSVT8GGBq6+h1lrPEYv6jnStDf7VLQxVliKt2w\n+h34JjgRUx9rdia30tk\/EpPavkxxPks8vjoLN3f4dbkIY\/sfljyZbseqVLx9kl\/we\n+OvqL6jZgaQOapFQLZJze7VwLiPVuUnW8ddK3JIE1a5YCZs0irIW5+96ttznIgPK2\n+aUOmHQp\/zasi7SFl49HrKGKWtZuyDB9U56e01H6PDTpSSSTPyLsSVg3JALHBPDzS\n+bBraAU3wuAyc3BQ4OIOmwwnT\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustevca-chain.pem","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number:\n+            a6:8b:79:29:00:00:00:00:50:d0:91:f9\n+        Signature Algorithm: ecdsa-with-SHA384\n+        Issuer: C=US, O=Entrust, Inc., OU=See www.entrust.net\/legal-terms, OU=(c) 2012 Entrust, Inc. - for authorized use only, CN=Entrust Root Certification Authority - EC1\n+        Validity\n+            Not Before: Dec 18 15:25:36 2012 GMT\n+            Not After : Dec 18 15:55:36 2037 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIFzDCCBVOgAwIBAgIQcbNJ8XJLeT3fV8DU3QNYSDAKBggqhkjOPQQDAzCBujEL\n+MAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1Nl\n+ZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDE2\n+IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEuMCwGA1UE\n+AxMlRW50cnVzdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEwxSjAeFw0yNDA2\n+MjgyMTM5MzVaFw0yNTA3MjgyMTM5MzRaMIHLMQswCQYDVQQGEwJDQTEQMA4GA1UE\n+CBMHT250YXJpbzEPMA0GA1UEBxMGT3R0YXdhMRMwEQYLKwYBBAGCNzwCAQMTAkNB\n+MRgwFgYLKwYBBAGCNzwCAQITB09udGFyaW8xGDAWBgNVBAoTD0VudHJ1c3QgTGlt\n+aXRlZDEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xEzARBgNVBAUTCjEw\n+MDA0OTI4NzkxHDAaBgNVBAMTE3ZhbGlkZWMuZW50cnVzdC5uZXQwdjAQBgcqhkjO\n+PQIBBgUrgQQAIgNiAAS90ZyZ86Gl5Fh1qJ\/70UwyQWATu3igiQLeVVvZ4G79SBEG\n+Xc4TcAn0LzBhfJonAzWFkAS860ARjvFHgUj0otyT+Q2\/zC9c8CjOsL3bYp3SNUbC\n+FWBhIV0vhGGY8NafeXCjggMJMIIDBTAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBTP\n+DXJE\/iZfi5wUSAo4GN4thBCCHDAfBgNVHSMEGDAWgBTD+UUDvsj5CzxFNfPrcuzn\n+6OuUmzBjBggrBgEFBQcBAQRXMFUwIwYIKwYBBQUHMAGGF2h0dHA6Ly9vY3NwLmVu\n+dHJ1c3QubmV0MC4GCCsGAQUFBzAChiJodHRwOi8vYWlhLmVudHJ1c3QubmV0L2wx\n+ai1lYzEuY2VyMDMGA1UdHwQsMCowKKAmoCSGImh0dHA6Ly9jcmwuZW50cnVzdC5u\n+ZXQvbGV2ZWwxai5jcmwwHgYDVR0RBBcwFYITdmFsaWRlYy5lbnRydXN0Lm5ldDAO\n+BgNVHQ8BAf8EBAMCB4AwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMEsG\n+A1UdIAREMEIwBwYFZ4EMAQEwNwYKYIZIAYb6bAoBAjApMCcGCCsGAQUFBwIBFhto\n+dHRwczovL3d3dy5lbnRydXN0Lm5ldC9ycGEwggF9BgorBgEEAdZ5AgQCBIIBbQSC\n+AWkBZwB1AA3h8jAr0w3BQGISCepVLvxHdHyx1+kw7w5CHrR+Tqo0AAABkGDKGokA\n+AAQDAEYwRAIgZwtzml8YzKjqeP86zX+88q8sHOt\/\/2Qmahr2tk97ozUCIFCOM2nF\n+s1GJVBjKQZEH8QqkivVp+Cai9pC\/57TiOmCOAHUAzPsPaoVxCWX+lZtTzumyfCLp\n+hVwNl422qX5UwP5MDbAAAAGQYMoamAAABAMARjBEAiEA37X8EgQAUzLxn\/Ny1Yx3\n+uszQF5D85m8vZ0otf8nHzuwCH168zpAxzKS71Fz6CgmDS0QZOfBSYFBD+Pdcm6e1\n+ilkAdwAS8U40vVNyTIQGGcOPP3oT+Oe1YoeInG0wBYTr5YYmOgAAAZBgyhq6AAAE\n+AwBIMEYCIQCljVuYzRe6oQTZPdx0tGhIQSOwM1JbxoMJu2cW+gEGLAIhAMSSJoni\n+0KT3KavwtsSWuuHsWjt8atv6TpJtLmVxCIdlMAoGCCqGSM49BAMDA2cAMGQCMBPY\n+1dn1Js8F9b08aVCZ3vqDGFTKuzTXaxArf\/y\/WhLtcHdZPLaYVifQcAKzp1WCFQIw\n+MvpE6RDccmnZi5TX88p16s8ev\/qkegpbf7Xuw1JQEfy2NRwrXc+NwA422EjXBTti\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIID5zCCA2ygAwIBAgIQCoPUgD5+n1EAAAAAUdTB9zAKBggqhkjOPQQDAzCBvzEL\n+MAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1Nl\n+ZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDEy\n+IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEzMDEGA1UE\n+AxMqRW50cnVzdCBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0gRUMxMB4X\n+DTE2MDQwNTIwMTk1NFoXDTM3MTAwNTIwNDk1NFowgboxCzAJBgNVBAYTAlVTMRYw\n+FAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQLEx9TZWUgd3d3LmVudHJ1c3Qu\n+bmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykgMjAxNiBFbnRydXN0LCBJbmMu\n+IC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxLjAsBgNVBAMTJUVudHJ1c3QgQ2Vy\n+dGlmaWNhdGlvbiBBdXRob3JpdHkgLSBMMUowdjAQBgcqhkjOPQIBBgUrgQQAIgNi\n+AAT14eFXmpQX\/dEf7NAxrMH13n0btz1KKvH2S1rROGPAKex2CY8yxznbffK\/MbCk\n+F7ByYXGs1+8kL5xmTysU\/c+YmjOZx2mMSAk2DPw30fijJ3tRrwChZ+TBpgtB6+A5\n+MsCjggEuMIIBKjAOBgNVHQ8BAf8EBAMCAQYwEgYDVR0TAQH\/BAgwBgEB\/wIBADAz\n+BggrBgEFBQcBAQQnMCUwIwYIKwYBBQUHMAGGF2h0dHA6Ly9vY3NwLmVudHJ1c3Qu\n+bmV0MDMGA1UdHwQsMCowKKAmoCSGImh0dHA6Ly9jcmwuZW50cnVzdC5uZXQvZWMx\n+cm9vdC5jcmwwOwYDVR0gBDQwMjAwBgRVHSAAMCgwJgYIKwYBBQUHAgEWGmh0dHA6\n+Ly93d3cuZW50cnVzdC5uZXQvcnBhMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEF\n+BQcDAjAdBgNVHQ4EFgQUw\/lFA77I+Qs8RTXz63Ls5+jrlJswHwYDVR0jBBgwFoAU\n+t2PnGt2N6QimVYOk4GpQQWURQkkwCgYIKoZIzj0EAwMDaQAwZgIxAPnVAOqxKDd7\n+v37EBmpPqWCCWBFPKW6HpRx3GUWc9caeQIw8rO2HXYgf92pb\/TsJYAIxAJhI0MpR\n+z5L42xF1R9UIPfQxCMwgsnWBqIqcfMrMO+2DxQy6GIP3cFFj9gRyxguKWw==\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustrootcaec1-chain.pem","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number: 1246989352 (0x4a538c28)\n+        Signature Algorithm: sha256WithRSAEncryption\n+        Issuer: C=US, O=Entrust, Inc., OU=See www.entrust.net\/legal-terms, OU=(c) 2009 Entrust, Inc. - for authorized use only, CN=Entrust Root Certification Authority - G2\n+        Validity\n+            Not Before: Jul  7 17:25:54 2009 GMT\n+            Not After : Dec  7 17:55:54 2030 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIHOzCCBiOgAwIBAgIQWFfRPoYcAxEc+S0tOlD+ljANBgkqhkiG9w0BAQsFADCB\n+ujELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsT\n+H1NlZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAy\n+MDE0IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEuMCwG\n+A1UEAxMlRW50cnVzdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEwxTTAeFw0y\n+NDA2MjgyMTQyMTRaFw0yNTA3MjgyMTQyMTNaMIHLMQswCQYDVQQGEwJDQTEQMA4G\n+A1UECBMHT250YXJpbzEPMA0GA1UEBxMGT3R0YXdhMRMwEQYLKwYBBAGCNzwCAQMT\n+AkNBMRgwFgYLKwYBBAGCNzwCAQITB09udGFyaW8xGDAWBgNVBAoTD0VudHJ1c3Qg\n+TGltaXRlZDEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xEzARBgNVBAUT\n+CjEwMDA0OTI4NzkxHDAaBgNVBAMTE3ZhbGlkZzIuZW50cnVzdC5uZXQwggEiMA0G\n+CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCZ66eWZS5ytmbHJeHcA9WfnpbGFC04\n+Tov7L0NWiStVRPEFrXrGSn6RPriGci6RwrCz5yn47EWjk2AjSD4e5lySDKHwTg+0\n+S9pl3lcSd8tQOTbTwVM0EfOxdUlO4IY0jCOSM8rnZUc1JvEIIrXWXWF9AWoDb4BQ\n+erTefRm\/YykFC558PEzn84vU9KoEmDwIP4upWKVutuzBpHWhZW3q9wagg62KifHN\n+1yaagv4PUGgdkrVkyA1ZO3D7b2RpQjBreOTk+tsTnWtbAkFGtRBOA\/2QrEvyqMU7\n+eCnpFZMIaj2tKeSLqhIWxzOnrAGUJNp5wLYmVnnhPhHEv1g79pNsZLR3AgMBAAGj\n+ggMoMIIDJDAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBRt85gfkWUjfTKgrLytMp8o\n+VvOe3zAfBgNVHSMEGDAWgBTD99C1KjCtrw2RIXA5VN28iXDHOjBoBggrBgEFBQcB\n+AQRcMFowIwYIKwYBBQUHMAGGF2h0dHA6Ly9vY3NwLmVudHJ1c3QubmV0MDMGCCsG\n+AQUFBzAChidodHRwOi8vYWlhLmVudHJ1c3QubmV0L2wxbS1jaGFpbjI1Ni5jZXIw\n+MwYDVR0fBCwwKjAooCagJIYiaHR0cDovL2NybC5lbnRydXN0Lm5ldC9sZXZlbDFt\n+LmNybDA3BgNVHREEMDAughN2YWxpZGcyLmVudHJ1c3QubmV0ghd3d3cudmFsaWRn\n+Mi5lbnRydXN0Lm5ldDAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUH\n+AwEGCCsGAQUFBwMCMEsGA1UdIAREMEIwBwYFZ4EMAQEwNwYKYIZIAYb6bAoBAjAp\n+MCcGCCsGAQUFBwIBFhtodHRwczovL3d3dy5lbnRydXN0Lm5ldC9ycGEwggF+Bgor\n+BgEEAdZ5AgQCBIIBbgSCAWoBaAB3ABLxTjS9U3JMhAYZw48\/ehP457Vih4icbTAF\n+hOvlhiY6AAABkGDMhQQAAAQDAEgwRgIhAMzddgbnWlodtosz6EMh2Y89n0JR4eMO\n+v+W6tUp2gVwYAiEA6UKa2eFlX0KdzuZCvTlPgi8DeK3ZI2wffyV2bYMXtsIAdgAN\n+4fIwK9MNwUBiEgnqVS78R3R8sdfpMO8OQh60fk6qNAAAAZBgzIURAAAEAwBHMEUC\n+IQDmVH2NlaV2\/Y3OaPMXhH+BT63zA+Bh\/5aCfPiYrJ7K2AIgRADPHzpwS7bfvVZI\n+k8QxUBSCDXFmZQOrpamBaEko6YIAdQDM+w9qhXEJZf6Vm1PO6bJ8IumFXA2Xjbap\n+flTA\/kwNsAAAAZBgzIUGAAAEAwBGMEQCIA1CHfNw7cCcJSb3s7ik9Wflf3irqE9G\n+QKxZ+Y9BOIx0AiA6CMvw7OHjG519E1tZgr\/HFRXzxKchBp80dfsaEKxY9zANBgkq\n+hkiG9w0BAQsFAAOCAQEAqvn1CTObiV5zKVY6NWjGK49Wqsr9t1ok\/h\/yfKRmr36O\n+UZkMTPANj0uhwM4gtieTze9hnNzEkx1ec6G40JyABRiSX+0dtq3n8wiW3d8G1Qj5\n+\/s8yZ13\/ATrdjjr1mlGOvh0sgWTTPaQpl8ijXTy40GYpZIUXXBK09Rm6W0siq+7m\n+OHNpJR4APWOBBU4QwiWrHHsFq4KvwxiTjNWWizCOnZwVi3awNBoDD\/Iwszn+trOA\n+8U\/1SsHGuPBWKajcGorwi2zQ99JxAwJJ8XNBCekynjbPZYx52KkqfR07Fd2Occbl\n+3lh3wXrepzzU1a6vdyiQpagX8btyIqQpAzytypzaLQ==\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIFLTCCBBWgAwIBAgIMYaHn0gAAAABR02amMA0GCSqGSIb3DQEBCwUAMIG+MQsw\n+CQYDVQQGEwJVUzEWMBQGA1UEChMNRW50cnVzdCwgSW5jLjEoMCYGA1UECxMfU2Vl\n+IHd3dy5lbnRydXN0Lm5ldC9sZWdhbC10ZXJtczE5MDcGA1UECxMwKGMpIDIwMDkg\n+RW50cnVzdCwgSW5jLiAtIGZvciBhdXRob3JpemVkIHVzZSBvbmx5MTIwMAYDVQQD\n+EylFbnRydXN0IFJvb3QgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBHMjAeFw0x\n+NDEyMTUxNTI1MDNaFw0zMDEwMTUxNTU1MDNaMIG6MQswCQYDVQQGEwJVUzEWMBQG\n+A1UEChMNRW50cnVzdCwgSW5jLjEoMCYGA1UECxMfU2VlIHd3dy5lbnRydXN0Lm5l\n+dC9sZWdhbC10ZXJtczE5MDcGA1UECxMwKGMpIDIwMTQgRW50cnVzdCwgSW5jLiAt\n+IGZvciBhdXRob3JpemVkIHVzZSBvbmx5MS4wLAYDVQQDEyVFbnRydXN0IENlcnRp\n+ZmljYXRpb24gQXV0aG9yaXR5IC0gTDFNMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A\n+MIIBCgKCAQEA0IHBOSPCsdHs91fdVSQ2kSAiSPf8ylIKsKs\/M7WwhAf23056sPuY\n+Ij0BrFb7cW2y7rmgD1J3q5iTvjOK64dex6qwymmPQwhqPyK\/MzlG1ZTy4kwFItln\n+gJHxBEoOm3yiydJs\/TwJhL39axSagR3nioPvYRZ1R5gTOw2QFpi\/iuInMlOZmcP7\n+lhw192LtjL1JcdJDQ6Gh4yEqI3CodT2ybEYGYW8YZ+QpfrI8wcVfCR5uRE7sIZlY\n+FUj0VUgqtzS0BeN8SYwAWN46lsw53GEzVc4qLj\/RmWLoquY0djGqr3kplnjLgRSv\n+adr7BLlZg0SqCU+01CwBnZuUMWstoc\/B5QIDAQABo4IBKzCCAScwDgYDVR0PAQH\/\n+BAQDAgEGMB0GA1UdJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATASBgNVHRMBAf8E\n+CDAGAQH\/AgEAMDMGCCsGAQUFBwEBBCcwJTAjBggrBgEFBQcwAYYXaHR0cDovL29j\n+c3AuZW50cnVzdC5uZXQwMAYDVR0fBCkwJzAloCOgIYYfaHR0cDovL2NybC5lbnRy\n+dXN0Lm5ldC9nMmNhLmNybDA7BgNVHSAENDAyMDAGBFUdIAAwKDAmBggrBgEFBQcC\n+ARYaaHR0cDovL3d3dy5lbnRydXN0Lm5ldC9ycGEwHQYDVR0OBBYEFMP30LUqMK2v\n+DZEhcDlU3byJcMc6MB8GA1UdIwQYMBaAFGpyJnrQHu995ztpUdRsjZ+QEmarMA0G\n+CSqGSIb3DQEBCwUAA4IBAQC0h8eEIhopwKR47PVPG7SEl2937tTPWa+oQ5YvHVje\n+pvMVWy7ZQ5xMQrkXFxGttLFBx2YMIoYFp7Qi+8VoaIqIMthx1hGOjlJ+Qgld2dnA\n+DizvRGsf2yS89byxqsGK5Wbb0CTz34mmi\/5e0FC6m3UAyQhKS3Q\/WFOv9rihbISY\n+Jnz8\/DVRZZgeO2x28JkPxLkJ1YXYJKd\/KsLak0tkuHB8VCnTglTVz6WUwzOeTTRn\n+4Dh2ZgCN0C\/GqwmqcvrOLzWJ\/MDtBgO334wlV\/H77yiI2YIowAQPlIFpI+CRKMVe\n+1QzX1CA778n4wI+nQc1XRG5sZ2L+hN\/nYNjvv9QiHg3n\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustrootcag2-chain.pem","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number:\n+            d9:b5:43:7f:af:a9:39:0f:00:00:00:00:55:65:ad:58\n+        Signature Algorithm: sha256WithRSAEncryption\n+        Issuer: C=US, O=Entrust, Inc., OU=See www.entrust.net\/legal-terms, OU=(c) 2015 Entrust, Inc. - for authorized use only, CN=Entrust Root Certification Authority - G4\n+        Validity\n+            Not Before: May 27 11:11:16 2015 GMT\n+            Not After : Dec 27 11:41:16 2037 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIIIzCCBwugAwIBAgIQDD4I8FgD7+DVcBLMBwa39jANBgkqhkiG9w0BAQsFADCB\r\n+ujELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsT\r\n+H1NlZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAy\r\n+MDE0IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEuMCwG\r\n+A1UEAxMlRW50cnVzdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEwxTjAeFw0y\r\n+NDA2MjgyMTQzNTRaFw0yNTA3MjgyMTQzNTNaMIHLMQswCQYDVQQGEwJDQTEQMA4G\r\n+A1UECBMHT250YXJpbzEPMA0GA1UEBxMGT3R0YXdhMRMwEQYLKwYBBAGCNzwCAQMT\r\n+AkNBMRgwFgYLKwYBBAGCNzwCAQITB09udGFyaW8xGDAWBgNVBAoTD0VudHJ1c3Qg\r\n+TGltaXRlZDEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xEzARBgNVBAUT\r\n+CjEwMDA0OTI4NzkxHDAaBgNVBAMTE3ZhbGlkZzQuZW50cnVzdC5uZXQwggIiMA0G\r\n+CSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCfUHGdeme0jraIiUzPYtuX1G9rlCU1\r\n+eKDqDbsgp7VIS7rI\/VgbsS7oKnE6KHP+qGrXRhYdvFLFDa+REY6fVOWkLuTXhVLb\r\n+5C7ym2pi0OUMKvrGtDLUxlHiEAmkmjPDl6TLMTDrLgWOLFMRzyeTcxnZtMrxUnAf\r\n+yzSPlqm1bkN\/oRp2EOiXvuSbci8UA0QswV6g8EUbRB0qyv6OophoaQYo\/+KRwTJT\r\n+k6S8YDsEJnlDb8tjEhfIUjp2Md5ThBxf5Ib29aXebZ5HFh2x5VPrzOwDUPk0fVNM\r\n+pWFfiX79RW6w5Vei5qtretLohbw6b5aJmaJ1LweAEkIlhy5eUuuG6v8Efm8JSAle\r\n+eKMtflTigmayaWMVCd2GeB6LajcflAw7BUU2brRMJwMpaeXXhL\/mVpjbev\/5TtVD\r\n++H9IlW3PMyQnUJc0YuUVmdi1eOM5qoQaQE4BDPHz2G41eDgT8J9Gb1FX5mT+9l2I\r\n+iJD47pwcBIw5tHCn2nuz1+8CDuYpfH2+t2LPFHVI15h1scGotZvzUJ5TzPdQqZI7\r\n+K2LTL49Zs2HsObrGr07Vj28WyzkjIfTrVSV\/29hgz1zVjUa0uyTeOzrc3VIg7NTv\r\n+RoMTTYuUeUoMSmFQ8z9CSGh7cxFlrhGjFO+66++JFNwakAEp7kS5c2qTLaapY9dM\r\n+8UMIr5951z994QIDAQABo4IDEDCCAwwwDAYDVR0TAQH\/BAIwADAdBgNVHQ4EFgQU\r\n+\/EjjpmMa\/SepMqPlglXS5AbGcScwHwYDVR0jBBgwFoAU7kfRhXHx\/S23P7s+Y1h3\r\n+F0lADpUwaAYIKwYBBQUHAQEEXDBaMCMGCCsGAQUFBzABhhdodHRwOi8vb2NzcC5l\r\n+bnRydXN0Lm5ldDAzBggrBgEFBQcwAoYnaHR0cDovL2FpYS5lbnRydXN0Lm5ldC9s\r\n+MW4tY2hhaW4yNTYuY2VyMDMGA1UdHwQsMCowKKAmoCSGImh0dHA6Ly9jcmwuZW50\r\n+cnVzdC5uZXQvbGV2ZWwxbi5jcmwwHgYDVR0RBBcwFYITdmFsaWRnNC5lbnRydXN0\r\n+Lm5ldDAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwIGCCsGAQUF\r\n+BwMBMEsGA1UdIAREMEIwBwYFZ4EMAQEwNwYKYIZIAYb6bAoBAjApMCcGCCsGAQUF\r\n+BwIBFhtodHRwczovL3d3dy5lbnRydXN0Lm5ldC9ycGEwggF\/BgorBgEEAdZ5AgQC\r\n+BIIBbwSCAWsBaQB2ABLxTjS9U3JMhAYZw48\/ehP457Vih4icbTAFhOvlhiY6AAAB\r\n+kGDOC9YAAAQDAEcwRQIgWhFWhf2sBQ3ufMH0yubwLDt+3f\/b5rScs09o1YEjg6MC\r\n+IQDpkgEMWBAM+NV2aCnC8QH+RH6xBqhPPt6JZTm3W+vHkwB3ABoE\/0nQVB1Ar\/ag\r\n+w7\/x2MRnL07s7iNAaJhrF0Au3Il9AAABkGDODBQAAAQDAEgwRgIhAOgp+oas+jBr\r\n+9wOBo0QDdVQGmP8KJupfRf\/MDKO+kSRjAiEA9JnEHTbFHre2TS9habVJA\/3jM\/t5\r\n+CKtixwQqdpLXQUAAdgAN4fIwK9MNwUBiEgnqVS78R3R8sdfpMO8OQh60fk6qNAAA\r\n+AZBgzgwVAAAEAwBHMEUCIBOYI8rl87VepcPQlaGh6AbKhKw1UlbxIf7etR\/d2M47\r\n+AiEAkFXOVvzkP6kX\/z1yRneYn0mlPbDvAFLsSDghl\/gkdtYwDQYJKoZIhvcNAQEL\r\n+BQADggEBAJovgoheNHFBUpnodfOiKtpRo8AE6dLuOX1H2uRHiDg0Gza0\/w95KkEE\r\n+BqjKmJIbJrs2TQJnkM0LjaubHn1TP4XC40qieMXB4ylJzC5FWDZBqMHZmLTvVY01\r\n+irBMyub0On8d1BlEquD2r3KHQFnyUvi\/uxzbNJOVbNJYglKhTI+UfcXk7zpHmNG+\r\n++SbBkpJkuqQ9ujG1K25FRa\/01j1p4ZlDrJ3KCT7fDEf10TN0u5VX6moVT9cRVR2U\r\n+gX16BV8m\/hoJVTD0fBCKIKjtklS\/\/b+Jr49uxWFulrDwlRKyDWmBXLnqsZvpCobi\r\n+deDsWiUkcvd+DjNgpDTEHCTrXXjd8tU=\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIGMjCCBBqgAwIBAgIRAKvsd\/8bQQwHAAAAAFVl2AUwDQYJKoZIhvcNAQELBQAw\r\n+gb4xCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQL\r\n+Ex9TZWUgd3d3LmVudHJ1c3QubmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykg\r\n+MjAxNSBFbnRydXN0LCBJbmMuIC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxMjAw\r\n+BgNVBAMTKUVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEc0\r\n+MB4XDTE3MTEyMjIwMDQyMFoXDTMwMTIyMjIwMzQyMFowgboxCzAJBgNVBAYTAlVT\r\n+MRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQLEx9TZWUgd3d3LmVudHJ1\r\n+c3QubmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykgMjAxNCBFbnRydXN0LCBJ\r\n+bmMuIC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxLjAsBgNVBAMTJUVudHJ1c3Qg\r\n+Q2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBMMU4wggEiMA0GCSqGSIb3DQEBAQUA\r\n+A4IBDwAwggEKAoIBAQDcSG+caYQ4xcvf+dt8bgCEHorO0g5j0H1NOtQzRXgUoG8y\r\n+QuRbJX9swyKqQZbsc18YvTV8OKA\/uSNE46Jvq47TFPojWWTVLbNDqpM07e4EFYKs\r\n+A9NFzAUngijnf3ivnXA6iNPAMXaEhXmhY\/YFjk8NoM7Y1PFsA0oj5hamKQ06iO\/j\r\n+gvBScLmnQ1ju9Qj9IGIg18UL5AJNw0frspLUQBYVrLGaqAy5Nl2BUJKaZ4vnSLvP\r\n+nk6YrB15mo1phHae10Ba4fx7R3z8IZ\/hby4OXTy\/KZpu107VEQPAwTuDK8ZXxB5y\r\n+0DSzi4vaw27aLrUsq4aFqUo03gEfC31vWW76TNkFAgMBAAGjggErMIIBJzAOBgNV\r\n+HQ8BAf8EBAMCAQYwEgYDVR0TAQH\/BAgwBgEB\/wIBADAdBgNVHSUEFjAUBggrBgEF\r\n+BQcDAQYIKwYBBQUHAwIwOwYDVR0gBDQwMjAwBgRVHSAAMCgwJgYIKwYBBQUHAgEW\r\n+Gmh0dHA6Ly93d3cuZW50cnVzdC5uZXQvcnBhMDMGCCsGAQUFBwEBBCcwJTAjBggr\r\n+BgEFBQcwAYYXaHR0cDovL29jc3AuZW50cnVzdC5uZXQwMAYDVR0fBCkwJzAloCOg\r\n+IYYfaHR0cDovL2NybC5lbnRydXN0Lm5ldC9nNGNhLmNybDAdBgNVHQ4EFgQU7kfR\r\n+hXHx\/S23P7s+Y1h3F0lADpUwHwYDVR0jBBgwFoAUnzjEViPDOeigcWzoVEzk6Dqx\r\n+v2cwDQYJKoZIhvcNAQELBQADggIBACMeFFgsWmC7h6D1v8DJUkOpm\/m5UhVhO0hb\r\n+pQMQKMhKkl744Y9SWG4WNmpQy743TTciEJPZFhc7ke2R6VmK8ZJUqro2awOw1RWZ\r\n+OtHla59Btf1NQd41vOVdU+qFhs8lFfXg9sK7YHTrfxHtMXLoGnkkamK3xJgn7sXa\r\n+\/zUvUDBTpDCXcpO9SyHoKIQswmkIPpRyIdPF4biRdR3N+9MYmlfqN\/Nk3OEZ73xZ\r\n+AUZP6Gu+f9cEiHTA8NdYHCPLJWyFnIHWK+QuTFEnKYnOYxCeroLBNOO64e8JWZ39\r\n+kZ22BBXhHzqOCCczS7JOJTRF+JgvWuxbFwRstj8qf3fE+JndWmq2FC4hTHtpuK5K\r\n+ENuiRm5gdkXfsXmB+qB6y5gaajiTIMscGIcZIKTe2YdKrLoicvEz8k+loM7favik\r\n+vzFioTNTDHYGx3mkfElBE7ycY8n+jZE3QBBv33k28MeQi7XNgEaMc4tYwoZIdE9A\r\n+xVccXTzEQzka82dOkRB1dU0XZId9XAWv+CtNc2TjF6Wgx2seA\/c6H8S0IfgQBIV2\r\n+8iN2wZns2QFdawkdy3hMUqPnA++kuGhLW3GemsIY5dP\/WxY8rd+OfLb\/Ks9T1pCd\r\n+28t7PQRcQsgkYmouzrOW9ASBvYqLLdhl4y+fFXff8RkPIKMNoYP06WJvRKmky9R\/\r\n+41\/nXRas\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustrootcag4-chain.pem","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8339347\n+ * @summary Test keytool -importpass with password input from System.in for\n+ *          the non-terminal console\n+ * @library \/test\/lib\n+ * @run main TestImportPass\n+ *\/\n+\n+import jdk.test.lib.SecurityTools;\n+\n+public class TestImportPass {\n+    public static void main(String[] args) throws Throwable {\n+        SecurityTools.setResponse(\"pass123\");\n+        SecurityTools.keytool(\"-importpass -keystore ks.p12 -storepass changeit \" +\n+                \"-storetype pkcs12 -alias newentry\")\n+                .shouldNotContain(\"Enter the password to be stored:\")\n+                .shouldHaveExitValue(0);\n+\n+        SecurityTools.keytool(\"-list -keystore ks.p12 -storepass changeit \" +\n+                \"-v\")\n+                .shouldContain(\"Alias name: newentry\")\n+                .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/TestImportPass.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,2 @@\n-# 2. Signing: ca -> user\n+# 2. Signing: ca -> user. The startdate is set to 1 minute in the past to ensure the certificate\n+# is valid at the time of validation and to prevent any issues with timing discrepancies\n@@ -67,2 +68,2 @@\n-$KT -certreq -alias user | $KT -gencert -rfc -alias ca1 > samedn1.certs\n-$KT -certreq -alias user | $KT -gencert -rfc -alias ca2 > samedn2.certs\n+$KT -certreq -alias user | $KT -gencert -rfc -alias ca1 -startdate -1M > samedn1.certs\n+$KT -certreq -alias user | $KT -gencert -rfc -alias ca2 -startdate -1M > samedn2.certs\n","filename":"test\/jdk\/sun\/security\/validator\/samedn.sh","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,5 +24,0 @@\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n@@ -50,9 +45,0 @@\n-    private static final Map<String,Month> abbreviations\n-                                = new HashMap<String,Month>(12);\n-\n-    static {\n-        for (Month m : Month.values()) {\n-            abbreviations.put(m.abbr, m);\n-        }\n-    }\n-\n@@ -73,5 +59,16 @@\n-        Month m = abbreviations.get(name);\n-        if (m != null) {\n-            return m;\n-        }\n-        return null;\n+        int len = name.length();\n+\n+        if (name.regionMatches(true, 0, \"January\", 0, len)) return Month.JANUARY;\n+        if (name.regionMatches(true, 0, \"February\", 0, len)) return Month.FEBRUARY;\n+        if (name.regionMatches(true, 0, \"March\", 0, len)) return Month.MARCH;\n+        if (name.regionMatches(true, 0, \"April\", 0, len)) return Month.APRIL;\n+        if (name.regionMatches(true, 0, \"May\", 0, len)) return Month.MAY;\n+        if (name.regionMatches(true, 0, \"June\", 0, len)) return Month.JUNE;\n+        if (name.regionMatches(true, 0, \"July\", 0, len)) return Month.JULY;\n+        if (name.regionMatches(true, 0, \"August\", 0, len)) return Month.AUGUST;\n+        if (name.regionMatches(true, 0, \"September\", 0, len)) return Month.SEPTEMBER;\n+        if (name.regionMatches(true, 0, \"October\", 0, len)) return Month.OCTOBER;\n+        if (name.regionMatches(true, 0, \"November\", 0, len)) return Month.NOVEMBER;\n+        if (name.regionMatches(true, 0, \"December\", 0, len)) return Month.DECEMBER;\n+\n+        throw new IllegalArgumentException(\"Unknown month: \" + name);\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Month.java","additions":17,"deletions":20,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,5 +24,0 @@\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n@@ -37,7 +32,0 @@\n-    private static final Map<String,DayOfWeek> abbreviations = new HashMap<String,DayOfWeek>(7);\n-    static {\n-        for (DayOfWeek day : DayOfWeek.values()) {\n-            abbreviations.put(day.getAbbr(), day);\n-        }\n-    }\n-\n@@ -169,2 +157,12 @@\n-    private static DayOfWeek getDOW(String abbr) {\n-        return abbreviations.get(abbr);\n+    private static DayOfWeek getDOW(String name) {\n+        int len = name.length();\n+\n+        if (name.regionMatches(true, 0, \"Monday\", 0, len)) return DayOfWeek.MONDAY;\n+        if (name.regionMatches(true, 0, \"Tuesday\", 0, len)) return DayOfWeek.TUESDAY;\n+        if (name.regionMatches(true, 0, \"Wednesday\", 0, len)) return DayOfWeek.WEDNESDAY;\n+        if (name.regionMatches(true, 0, \"Thursday\", 0, len)) return DayOfWeek.THURSDAY;\n+        if (name.regionMatches(true, 0, \"Friday\", 0, len)) return DayOfWeek.FRIDAY;\n+        if (name.regionMatches(true, 0, \"Saturday\", 0, len)) return DayOfWeek.SATURDAY;\n+        if (name.regionMatches(true, 0, \"Sunday\", 0, len)) return DayOfWeek.SUNDAY;\n+\n+        throw new IllegalArgumentException(\"Unknown day-of-week: \" + name);\n@@ -175,1 +173,1 @@\n-     * name defined in {@link java.util.Calenda}.\n+     * name defined in {@link java.util.Calendar}.\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/RuleDay.java","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,1 +171,2 @@\n-                if (\"min\".equals(token) || \"minimum\".equals(token)) {\n+                int len = token.length();\n+                if (token.regionMatches(true, 0, \"minimum\", 0, len)) {\n@@ -173,1 +174,1 @@\n-                } else if (\"max\".equals(token) || \"maximum\".equals(token)) {\n+                } else if (token.regionMatches(true, 0, \"maximum\", 0, len)) {\n@@ -176,1 +177,1 @@\n-                } else if (\"only\".equals(token)) {\n+                } else if (token.regionMatches(true, 0, \"only\", 0, len)) {\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/RuleRec.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -243,0 +243,1 @@\n+                int len = token.length();\n@@ -244,1 +245,1 @@\n-                if (continued || \"Zone\".equals(token)) {\n+                if (continued || token.regionMatches(true, 0, \"Zone\", 0, len)){\n@@ -271,1 +272,1 @@\n-                } else if (\"Rule\".equals(token)) {\n+                } else if (token.regionMatches(true, 0, \"Rule\", 0, len)) {\n@@ -284,1 +285,1 @@\n-                } else if (\"Link\".equals(token)) {\n+                } else if (token.regionMatches(true, 0, \"Link\", 0, len)) {\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Zoneinfo.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-        args.add(\"-ms64m\");\n+        args.add(\"-Xms64m\");\n","filename":"test\/jdk\/tools\/jimage\/JImageToolTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+        map.put(\"systemd.support\", this::systemdSupport);\n@@ -613,1 +614,1 @@\n-              isSupported = checkDockerSupport();\n+              isSupported = checkProgramSupport(\"checkDockerSupport()\", Container.ENGINE_COMMAND);\n@@ -623,0 +624,21 @@\n+    \/**\n+     * A simple check for systemd support\n+     *\n+     * @return true if systemd is supported in a given environment\n+     *\/\n+    protected String systemdSupport() {\n+        log(\"Entering systemdSupport()\");\n+\n+        boolean isSupported = Platform.isLinux();\n+        if (isSupported) {\n+           try {\n+              isSupported = checkProgramSupport(\"checkSystemdSupport()\", \"systemd-run\");\n+           } catch (Exception e) {\n+              isSupported = false;\n+           }\n+         }\n+\n+        log(\"systemdSupport(): returning isSupported = \" + isSupported);\n+        return \"\" + isSupported;\n+    }\n+\n@@ -657,3 +679,3 @@\n-    private boolean checkDockerSupport() throws IOException, InterruptedException {\n-        log(\"checkDockerSupport(): entering\");\n-        ProcessBuilder pb = new ProcessBuilder(\"which\", Container.ENGINE_COMMAND);\n+    private boolean checkProgramSupport(String logString, String cmd) throws IOException, InterruptedException {\n+        log(logString + \": entering\");\n+        ProcessBuilder pb = new ProcessBuilder(\"which\", cmd);\n@@ -661,2 +683,2 @@\n-            redirectOutputToLogFile(\"checkDockerSupport(): which \" + Container.ENGINE_COMMAND,\n-                                                      pb, \"which-container\");\n+            redirectOutputToLogFile(logString + \": which \" + cmd,\n+                                                      pb, \"which-cmd\");\n@@ -667,1 +689,1 @@\n-        log(String.format(\"checkDockerSupport(): exitValue = %s, pid = %s\", exitValue, p.pid()));\n+        log(String.format(\"%s: exitValue = %s, pid = %s\", logString, exitValue, p.pid()));\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-tools\/javac\/patterns\/Exhaustiveness.java \t\t\t\t\t8326616    generic-all    intermittently timeout\n","filename":"test\/langtools\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,3 +73,3 @@\n-        HtmlTree html = new HtmlTree(HtmlTag.HTML);\n-        HtmlTree head = new HtmlTree(HtmlTag.HEAD);\n-        HtmlTree title = new HtmlTree(HtmlTag.TITLE);\n+        HtmlTree html = HtmlTree.of(HtmlTag.HTML);\n+        HtmlTree head = HtmlTree.of(HtmlTag.HEAD);\n+        HtmlTree title = HtmlTree.of(HtmlTag.TITLE);\n@@ -81,1 +81,1 @@\n-        HtmlTree meta = new HtmlTree(HtmlTag.META);\n+        HtmlTree meta = HtmlTree.of(HtmlTag.META);\n@@ -85,1 +85,1 @@\n-        HtmlTree link = new HtmlTree(HtmlTag.LINK);\n+        HtmlTree link = HtmlTree.of(HtmlTag.LINK);\n@@ -93,1 +93,1 @@\n-        HtmlTree body = new HtmlTree(HtmlTag.BODY);\n+        HtmlTree body = HtmlTree.of(HtmlTag.BODY);\n@@ -96,1 +96,1 @@\n-        HtmlTree p = new HtmlTree(HtmlTag.P);\n+        HtmlTree p = HtmlTree.of(HtmlTag.P);\n@@ -109,1 +109,1 @@\n-        HtmlTree p1 = new HtmlTree(HtmlTag.P);\n+        HtmlTree p1 = HtmlTree.of(HtmlTag.P);\n@@ -111,1 +111,1 @@\n-        HtmlTree anchor = new HtmlTree(HtmlTag.A);\n+        HtmlTree anchor = HtmlTree.of(HtmlTag.A);\n@@ -117,1 +117,1 @@\n-        HtmlTree dl = new HtmlTree(HtmlTag.DL);\n+        HtmlTree dl = HtmlTree.of(HtmlTag.DL);\n@@ -120,3 +120,3 @@\n-        HtmlTree dlTree = new HtmlTree(HtmlTag.DL);\n-        dlTree.add(new HtmlTree(HtmlTag.DT));\n-        dlTree.add(new HtmlTree (HtmlTag.DD));\n+        HtmlTree dlTree = HtmlTree.of(HtmlTag.DL);\n+        dlTree.add(HtmlTree.of(HtmlTag.DT));\n+        dlTree.add(HtmlTree.of (HtmlTag.DD));\n@@ -124,3 +124,3 @@\n-        HtmlTree dlDisplay = new HtmlTree(HtmlTag.DL);\n-        dlDisplay.add(new HtmlTree(HtmlTag.DT));\n-        HtmlTree dd = new HtmlTree (HtmlTag.DD);\n+        HtmlTree dlDisplay = HtmlTree.of(HtmlTag.DL);\n+        dlDisplay.add(HtmlTree.of(HtmlTag.DT));\n+        HtmlTree dd = HtmlTree.of (HtmlTag.DD);\n@@ -135,1 +135,1 @@\n-        HtmlTree hr = new HtmlTree(HtmlTag.HR);\n+        HtmlTree hr = HtmlTree.of(HtmlTag.HR);\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHtmlDocument\/TestHtmlDocument.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- *           8331947\n+ *           8331947 8281533\n@@ -159,1 +159,14 @@\n-                    <\/ol>\"\"\");\n+                    <\/ol>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\">Preview feature. Links: <a href=\"CoreRecord.html\" title=\"cla\\\n+                    ss in preview\"><code>CoreRecord<\/code><\/a><sup><a href=\"CoreRecord.html#preview\\\n+                    -preview.CoreRecord\">PREVIEW<\/a><\/sup>, <a href=\"CoreRecord.html\" title=\"class \\\n+                    in preview\"><code>core record<\/code><\/a><sup><a href=\"CoreRecord.html#preview-p\\\n+                    review.CoreRecord\">PREVIEW<\/a><\/sup>,\n+                     <a href=\"CoreRecord.html\" title=\"class in preview\">CoreRecord<\/a>, <a href=\"Co\\\n+                    reRecord.html\" title=\"class in preview\">core record<\/a>.<\/div>\"\"\",\n+                \"\"\"\n+                    <li><a href=\"CoreRecord.html\" title=\"class in preview\"><code>CoreRecord<\/code><\\\n+                    \/a><sup><a href=\"CoreRecord.html#preview-preview.CoreRecord\">PREVIEW<\/a><\/sup><\\\n+                    \/li>\n+                    <li><a href=\"CoreRecord.html\" title=\"class in preview\">core record<\/a><\/li>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPreview\/TestPreview.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+\/**\n+ * Preview feature. Links: {@link CoreRecord}, {@link CoreRecord core record},\n+ * {@linkplain CoreRecord}, {@linkplain CoreRecord core record}.\n+ *\n+ * @see CoreRecord\n+ * @see CoreRecord core record\n+ *\/\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPreview\/api\/preview\/Core.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        boolean elementIsVoid = new HtmlTree(htmlTag).isVoid();\n+        boolean elementIsVoid = HtmlTree.of(htmlTag).isVoid();\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testVoidHtmlElements\/TestVoidHtmlElements.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @key intermittent\n","filename":"test\/langtools\/jdk\/jshell\/ExceptionMessageTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,5 @@\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n@@ -38,0 +43,2 @@\n+import static org.testng.Assert.assertFalse;\n+import org.testng.annotations.BeforeMethod;\n@@ -39,1 +46,0 @@\n-@Test\n@@ -56,0 +62,1 @@\n+    @Test\n@@ -63,0 +70,1 @@\n+    @Test\n@@ -71,0 +79,1 @@\n+    @Test\n@@ -121,0 +130,45 @@\n+    @Test\n+    public void testRunShutdownHooks() throws IOException {\n+        Path temporary = Paths.get(\"temp\");\n+        Files.newOutputStream(temporary).close();\n+        assertEval(\"import java.io.*;\");\n+        assertEval(\"import java.nio.file.*;\");\n+        assertEval(\"\"\"\n+                        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+                            try {\n+                                Files.delete(Paths.get(\"$TEMPORARY\"));\n+                            } catch (IOException ex) {\n+                                \/\/ignored\n+                            }\n+                        }))\n+                        \"\"\".replace(\"$TEMPORARY\", temporary.toAbsolutePath()\n+                                                           .toString()\n+                                                           .replace(\"\\\\\", \"\\\\\\\\\")));\n+        getState().close();\n+        assertFalse(Files.exists(temporary));\n+    }\n+\n+    private Method currentTestMethod;\n+\n+    @BeforeMethod\n+    public void setUp(Method testMethod) {\n+        currentTestMethod = testMethod;\n+        super.setUp();\n+    }\n+\n+    @BeforeMethod\n+    public void setUp() {\n+    }\n+\n+    @Override\n+    public void setUp(Consumer<JShell.Builder> bc) {\n+        Consumer<JShell.Builder> augmentedBuilder = switch (currentTestMethod.getName()) {\n+            case \"testRunShutdownHooks\" -> builder -> {\n+                builder.executionEngine(Presets.TEST_STANDARD_EXECUTION);\n+                bc.accept(builder);\n+            };\n+            default -> bc;\n+        };\n+        super.setUp(augmentedBuilder);\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/ShutdownTest.java","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -606,1 +606,1 @@\n-            boolean matches = checkMatch((Annotation) anno);\n+            boolean matches = checkMatch(anno.annotation());\n@@ -1200,2 +1200,2 @@\n-                    for(Annotation anno : rvattr.annotations()) {\n-                        expected.matchAnnotation(anno);\n+                    for(var anno : rvattr.annotations()) {\n+                        expected.matchAnnotation(anno.annotation());\n","filename":"test\/langtools\/lib\/annotations\/annotations\/classfile\/ClassfileInspector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8338301\n+ * @summary Verify error recovery and reporting related to implicitly declared classes\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ErrorRecovery\n+*\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.JavaTask;\n+import toolbox.Task;\n+import toolbox.Task.OutputKind;\n+import toolbox.ToolBox;\n+\n+public class ErrorRecovery extends TestRunner {\n+\n+    private static final String SOURCE_VERSION = System.getProperty(\"java.specification.version\");\n+    private ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new ErrorRecovery().runTests();\n+    }\n+\n+    ErrorRecovery() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testMethodNoReturnType(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     main() {}\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> log = new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(OutputKind.DIRECT);\n+        List<String> expected = List.of(\n+            \"Test.java:1:1: compiler.err.invalid.meth.decl.ret.type.req\",\n+            \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+            \"- compiler.note.preview.recompile\",\n+            \"1 error\"\n+        );\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+    }\n+\n+    @Test\n+    public void testStatement(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     if (true) {int var = 0;}\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> log = new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"-XDshould-stop.at=FLOW\",\n+                     \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(OutputKind.DIRECT);\n+        List<String> expected = List.of(\n+            \"Test.java:1:1: compiler.err.statement.not.expected\",\n+            \"1 error\"\n+        );\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+    }\n+\n+    @Test\n+    public void testExtraSemi(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     class C {};\n+                     void main() {};\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+    }\n+\n+    @Test\n+    public void testVeryBroken(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     \"neither-of-class-method-file-statement\"\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> log;\n+        List<String> expected;\n+\n+        log = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\",\n+                        \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+        expected = List.of(\n+                \"Test.java:1:1: compiler.err.class.method.or.field.expected\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+\n+        log = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+        expected = List.of(\n+                \"Test.java:1:1: compiler.err.expected4: class, interface, enum, record\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+\n+        log = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\",\n+                         \"--release\", \"17\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+        expected = List.of(\n+                \"Test.java:1:1: compiler.err.expected4: class, interface, enum, record\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ErrorRecovery.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -1,320 +0,0 @@\n-class T {\n-  0xCAFEBABE;\n-  0; \/\/ minor version\n-  49; \/\/ version\n-  [73] { \/\/ Constant Pool\n-    ; \/\/ first element is empty\n-    Utf8 \"T\"; \/\/ #1     at 0x0A\n-    class #1; \/\/ #2     at 0x1A\n-    Utf8 \"Ljava\/lang\/Enum<LT;>;\"; \/\/ #3     at 0x1D\n-    Utf8 \"java\/lang\/Enum\"; \/\/ #4     at 0x41\n-    class #4; \/\/ #5     at 0x52\n-    Utf8 \"T.java\"; \/\/ #6     at 0x55\n-    Utf8 \"T1\"; \/\/ #7     at 0x61\n-    Utf8 \"LT;\"; \/\/ #8     at 0x66\n-    Utf8 \"T2\"; \/\/ #9     at 0x78\n-    Utf8 \"T3\"; \/\/ #10     at 0x7D\n-    Utf8 \"myName\"; \/\/ #11     at 0x82\n-    Utf8 \"Ljava\/lang\/String;\"; \/\/ #12     at 0x8B\n-    Utf8 \"$VALUES\"; \/\/ #13     at 0xA0\n-    Utf8 \"[LT;\"; \/\/ #14     at 0xAA\n-    Utf8 \"values\"; \/\/ #15     at 0xBD\n-    Utf8 \"()[LT;\"; \/\/ #16     at 0xC6\n-    NameAndType #13 #14; \/\/ #17     at 0xDB\n-    Field #2 #17; \/\/ #18     at 0xE0\n-    class #14; \/\/ #19     at 0xE5\n-    Utf8 \"clone\"; \/\/ #20     at 0xE8\n-    Utf8 \"()Ljava\/lang\/Object;\"; \/\/ #21     at 0xF0\n-    NameAndType #20 #21; \/\/ #22     at 0x0107\n-    Method #19 #22; \/\/ #23     at 0x010C\n-    Utf8 \"valueOf\"; \/\/ #24     at 0x0111\n-    Utf8 \"(Ljava\/lang\/String;)LT;\"; \/\/ #25     at 0x011B\n-    Utf8 \"(Ljava\/lang\/Class;Ljava\/lang\/String;)Ljava\/lang\/Enum;\"; \/\/ #26     at 0x0141\n-    NameAndType #24 #26; \/\/ #27     at 0x0179\n-    Method #5 #27; \/\/ #28     at 0x017E\n-    Utf8 \"name\"; \/\/ #29     at 0x0183\n-    Utf8 \"getName\"; \/\/ #30     at 0x018A\n-    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #31     at 0x0194\n-    NameAndType #11 #12; \/\/ #32     at 0x01AB\n-    Field #2 #32; \/\/ #33     at 0x01B0\n-    Utf8 \"this\"; \/\/ #34     at 0x01B5\n-    Utf8 \"<init>\"; \/\/ #35     at 0x01BC\n-    Utf8 \"(Ljava\/lang\/String;ILjava\/lang\/String;)V\"; \/\/ #36     at 0x01C5\n-    Utf8 \"LNotNull;\"; \/\/ #37     at 0x01F0\n-    Utf8 \"java\/lang\/IllegalArgumentException\"; \/\/ #38     at 0x0216\n-    class #38; \/\/ #39     at 0x023B\n-    Utf8 \"Argument 0 for @NotNull parameter of T.<init> must not be null\"; \/\/ #40     at 0x023E\n-    String #40; \/\/ #41     at 0x028B\n-    Utf8 \"(Ljava\/lang\/String;)V\"; \/\/ #42     at 0x028E\n-    NameAndType #35 #42; \/\/ #43     at 0x02A6\n-    Method #39 #43; \/\/ #44     at 0x02AB\n-    Utf8 \"(Ljava\/lang\/String;I)V\"; \/\/ #45     at 0x02B0\n-    NameAndType #35 #45; \/\/ #46     at 0x02C9\n-    Method #5 #46; \/\/ #47     at 0x02CE\n-    Utf8 \"<clinit>\"; \/\/ #48     at 0x02D3\n-    Utf8 \"()V\"; \/\/ #49     at 0x02DE\n-    String #7; \/\/ #50     at 0x02E4\n-    Utf8 \"type1\"; \/\/ #51     at 0x02E7\n-    String #51; \/\/ #52     at 0x02EF\n-    NameAndType #35 #36; \/\/ #53     at 0x02F2\n-    Method #2 #53; \/\/ #54     at 0x02F7\n-    NameAndType #7 #8; \/\/ #55     at 0x02FC\n-    Field #2 #55; \/\/ #56     at 0x0301\n-    String #9; \/\/ #57     at 0x0306\n-    Utf8 \"type2\"; \/\/ #58     at 0x0309\n-    String #58; \/\/ #59     at 0x0311\n-    NameAndType #9 #8; \/\/ #60     at 0x0314\n-    Field #2 #60; \/\/ #61     at 0x0319\n-    String #10; \/\/ #62     at 0x031E\n-    Utf8 \"type3\"; \/\/ #63     at 0x0321\n-    String #63; \/\/ #64     at 0x0329\n-    NameAndType #10 #8; \/\/ #65     at 0x032C\n-    Field #2 #65; \/\/ #66     at 0x0331\n-    Utf8 \"Code\"; \/\/ #67     at 0x0336\n-    Utf8 \"LineNumberTable\"; \/\/ #68     at 0x033D\n-    Utf8 \"LocalVariableTable\"; \/\/ #69     at 0x034F\n-    Utf8 \"Signature\"; \/\/ #70     at 0x0364\n-    Utf8 \"RuntimeInvisibleParameterAnnotations\"; \/\/ #71     at 0x0370\n-    Utf8 \"SourceFile\"; \/\/ #72     at 0x0397\n-  } \/\/ Constant Pool\n-\n-  0x4031; \/\/ access\n-  #2;\/\/ this_cpx\n-  #5;\/\/ super_cpx\n-\n-  [0] { \/\/ Interfaces\n-  } \/\/ Interfaces\n-\n-  [5] { \/\/ fields\n-    { \/\/ Member at 0x03AE\n-      0x4019; \/\/ access\n-      #7; \/\/ name_cpx\n-      #8; \/\/ sig_cpx\n-      [0] { \/\/ Attributes\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x03B6\n-      0x4019; \/\/ access\n-      #9; \/\/ name_cpx\n-      #8; \/\/ sig_cpx\n-      [0] { \/\/ Attributes\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x03BE\n-      0x4019; \/\/ access\n-      #10; \/\/ name_cpx\n-      #8; \/\/ sig_cpx\n-      [0] { \/\/ Attributes\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x03C6\n-      0x0012; \/\/ access\n-      #11; \/\/ name_cpx\n-      #12; \/\/ sig_cpx\n-      [0] { \/\/ Attributes\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x03CE\n-      0x101A; \/\/ access\n-      #13; \/\/ name_cpx\n-      #14; \/\/ sig_cpx\n-      [0] { \/\/ Attributes\n-      } \/\/ Attributes\n-    } \/\/ Member\n-  } \/\/ fields\n-\n-  [5] { \/\/ methods\n-    { \/\/ Member at 0x03D8\n-      0x0019; \/\/ access\n-      #15; \/\/ name_cpx\n-      #16; \/\/ sig_cpx\n-      [1] { \/\/ Attributes\n-        Attr(#67, 34) { \/\/ Code at 0x03E0\n-          1; \/\/ max_stack\n-          0; \/\/ max_locals\n-          Bytes[10]{\n-            0xB20012B60017C000;\n-            0x13B0;\n-          };\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [1] { \/\/ Attributes\n-            Attr(#68, 6) { \/\/ LineNumberTable at 0x03FC\n-              [1] { \/\/ LineNumberTable\n-                0  9; \/\/  at 0x0408\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x0408\n-      0x0009; \/\/ access\n-      #24; \/\/ name_cpx\n-      #25; \/\/ sig_cpx\n-      [1] { \/\/ Attributes\n-        Attr(#67, 52) { \/\/ Code at 0x0410\n-          2; \/\/ max_stack\n-          1; \/\/ max_locals\n-          Bytes[10]{\n-            0x12022AB8001CC000;\n-            0x02B0;\n-          };\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [2] { \/\/ Attributes\n-            Attr(#69, 12) { \/\/ LocalVariableTable at 0x042C\n-              [1] { \/\/ LocalVariableTable\n-                0 10 29 12 0; \/\/  at 0x043E\n-              }\n-            } \/\/ end LocalVariableTable\n-            ;\n-            Attr(#68, 6) { \/\/ LineNumberTable at 0x043E\n-              [1] { \/\/ LineNumberTable\n-                0  9; \/\/  at 0x044A\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x044A\n-      0x0001; \/\/ access\n-      #30; \/\/ name_cpx\n-      #31; \/\/ sig_cpx\n-      [1] { \/\/ Attributes\n-        Attr(#67, 47) { \/\/ Code at 0x0452\n-          1; \/\/ max_stack\n-          1; \/\/ max_locals\n-          Bytes[5]{\n-            0x2AB40021B0;\n-          };\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [2] { \/\/ Attributes\n-            Attr(#69, 12) { \/\/ LocalVariableTable at 0x0469\n-              [1] { \/\/ LocalVariableTable\n-                0 5 34 8 0; \/\/  at 0x047B\n-              }\n-            } \/\/ end LocalVariableTable\n-            ;\n-            Attr(#68, 6) { \/\/ LineNumberTable at 0x047B\n-              [1] { \/\/ LineNumberTable\n-                0  17; \/\/  at 0x0487\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x0487\n-      0x0002; \/\/ access\n-      #35; \/\/ name_cpx\n-      #36; \/\/ sig_cpx\n-      [3] { \/\/ Attributes\n-        Attr(#67, 86) { \/\/ Code at 0x048F\n-          3; \/\/ max_stack\n-          4; \/\/ max_locals\n-          Bytes[26]{\n-            0x2BC7000DBB002759;\n-            0x1229B7002CBF2A2B;\n-            0x1CB7002F2A2DB500;\n-            0x21B1;\n-          };\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [2] { \/\/ Attributes\n-            Attr(#69, 22) { \/\/ LocalVariableTable at 0x04BB\n-              [2] { \/\/ LocalVariableTable\n-                14 12 34 8 0; \/\/  at 0x04CD\n-                14 12 29 12 3; \/\/  at 0x04D7\n-              }\n-            } \/\/ end LocalVariableTable\n-            ;\n-            Attr(#68, 14) { \/\/ LineNumberTable at 0x04D7\n-              [3] { \/\/ LineNumberTable\n-                14  20; \/\/  at 0x04E3\n-                20  21; \/\/  at 0x04E7\n-                25  22; \/\/  at 0x04EB\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-        ;\n-        Attr(#70, 2) { \/\/ Signature at 0x04EB\n-          #42;\n-        } \/\/ end Signature\n-        ;\n-        Attr(#71, 11) { \/\/ RuntimeInvisibleParameterAnnotations at 0x04F3\n-          [3]b { \/\/ parameters\n-            [1] { \/\/ annotations\n-              {  \/\/  annotation\n-                #37;\n-                [0] { \/\/ element_value_pairs\n-                }  \/\/  element_value_pairs\n-              }  \/\/  annotation\n-            }\n-            ;\n-            [0] { \/\/ annotations\n-            }\n-            ;\n-            [0] { \/\/ annotations\n-            }\n-          }\n-        } \/\/ end RuntimeInvisibleParameterAnnotations\n-      } \/\/ Attributes\n-    } \/\/ Member\n-    ;\n-    { \/\/ Member at 0x0504\n-      0x0008; \/\/ access\n-      #48; \/\/ name_cpx\n-      #49; \/\/ sig_cpx\n-      [1] { \/\/ Attributes\n-        Attr(#67, 107) { \/\/ Code at 0x050C\n-          5; \/\/ max_stack\n-          0; \/\/ max_locals\n-          Bytes[71]{\n-            0xBB00025912320312;\n-            0x34B70036B30038BB;\n-            0x000259123904123B;\n-            0xB70036B3003DBB00;\n-            0x0259123E051240B7;\n-            0x0036B3004206BD00;\n-            0x025903B200385359;\n-            0x04B2003D535905B2;\n-            0x004253B30012B1;\n-          };\n-          [0] { \/\/ Traps\n-          } \/\/ end Traps\n-          [1] { \/\/ Attributes\n-            Attr(#68, 18) { \/\/ LineNumberTable at 0x0565\n-              [4] { \/\/ LineNumberTable\n-                0  10; \/\/  at 0x0571\n-                15  11; \/\/  at 0x0575\n-                30  12; \/\/  at 0x0579\n-                45  9; \/\/  at 0x057D\n-              }\n-            } \/\/ end LineNumberTable\n-          } \/\/ Attributes\n-        } \/\/ end Code\n-      } \/\/ Attributes\n-    } \/\/ Member\n-  } \/\/ methods\n-\n-  [2] { \/\/ Attributes\n-    Attr(#70, 2) { \/\/ Signature at 0x057F\n-      #3;\n-    } \/\/ end Signature\n-    ;\n-    Attr(#72, 2) { \/\/ SourceFile at 0x0587\n-      #6;\n-    } \/\/ end SourceFile\n-  } \/\/ Attributes\n-} \/\/ end class T\n","filename":"test\/langtools\/tools\/javac\/T6435291\/T.jcod","additions":0,"deletions":320,"binary":false,"changes":320,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug     6435291\n- * @summary javac shouldn't throw NPE while compiling invalid RuntimeInvisibleParameterAnnotations\n- * @author  Wei Tao\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.code\n- *          jdk.compiler\/com.sun.tools.javac.comp\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.javac.util\n- * @build T\n- * @run main\/othervm T6435291\n- *\/\n-\n-import com.sun.tools.javac.api.JavacTaskImpl;\n-import com.sun.tools.javac.code.ClassFinder.BadClassFile;\n-import com.sun.tools.javac.code.Symtab;\n-import com.sun.tools.javac.util.Names;\n-import javax.tools.ToolProvider;\n-\n-public class T6435291 {\n-    public static void main(String... args) {\n-        javax.tools.JavaCompiler tool = ToolProvider.getSystemJavaCompiler();\n-        JavacTaskImpl task = (JavacTaskImpl)tool.getTask(null, null, null, null, null, null);\n-        Symtab syms = Symtab.instance(task.getContext());\n-        Names names = Names.instance(task.getContext());\n-        task.ensureEntered();\n-        try {\n-            syms.enterClass(syms.unnamedModule, names.fromString(\"T\")).complete();\n-        } catch (BadClassFile e) {\n-            System.err.println(\"Passed: expected completion failure \" + e.getClass().getName());\n-            return;\n-        } catch (Exception e) {\n-            throw new RuntimeException(\"Failed: unexpected exception\");\n-        }\n-        throw new RuntimeException(\"Failed: no error reported\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/T6435291\/T6435291.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -0,0 +1,699 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8024694 8334870\n+ * @summary Check javac can handle various Runtime(In)VisibleParameterAnnotations attribute combinations\n+ * @enablePreview\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ParameterAnnotations\n+*\/\n+\n+import java.io.OutputStream;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.MethodBuilder;\n+import java.lang.classfile.MethodElement;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.attribute.MethodParametersAttribute;\n+import java.lang.classfile.attribute.RuntimeInvisibleParameterAnnotationsAttribute;\n+import java.lang.classfile.attribute.RuntimeVisibleParameterAnnotationsAttribute;\n+import java.lang.classfile.attribute.SignatureAttribute;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.ElementFilter;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class ParameterAnnotations extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new ParameterAnnotations().runTests();\n+    }\n+\n+    ParameterAnnotations() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testEnum(Path base) throws Exception {\n+        \/\/not parameterized:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public enum E {\n+                   A(0);\n+                   E(@Visible @Invisible long i) {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"E\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"@Invisible @Visible long\");\n+        \/\/parameterized:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public enum E {\n+                   A(0);\n+                   <T> E(@Visible @Invisible long i) {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"E\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"@Invisible @Visible long\");\n+        \/\/not parameterized, and no Signature attribute:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public enum E {\n+                   A(0);\n+                   E(@Visible @Invisible long i) {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"E\",\n+               NO_SIGNATURE,\n+               \"java.lang.String, int, @Invisible @Visible long\");\n+        \/\/not parameterized, and no Signature and MethodParameters attribute:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public enum E {\n+                   A(0);\n+                   E(@Visible @Invisible long i) {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"E\",\n+               NO_SIGNATURE_NO_METHOD_PARAMETERS,\n+               \"java.lang.String, int, @Invisible @Visible long\");\n+    }\n+\n+    @Test\n+    public void testInnerClass(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public class I {\n+                       public I(@Visible @Invisible long l) {}\n+                       public String toString() {\n+                           return T.this.toString(); \/\/force outer this capture\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$I\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"@Invisible @Visible long\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public class I {\n+                       public <T> I(@Visible @Invisible long l) {}\n+                       public String toString() {\n+                           return T.this.toString(); \/\/force outer this capture\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$I\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"@Invisible @Visible long\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public class I {\n+                       public I(@Visible @Invisible long l) {}\n+                       public String toString() {\n+                           return T.this.toString(); \/\/force outer this capture\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$I\",\n+               NO_SIGNATURE,\n+               \"@Invisible @Visible long\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public class I {\n+                       public I(@Visible @Invisible long l) {}\n+                       public String toString() {\n+                           return T.this.toString(); \/\/force outer this capture\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$I\",\n+               NO_SIGNATURE_NO_METHOD_PARAMETERS,\n+               \"@Invisible @Visible long\");\n+    }\n+\n+    @Test\n+    public void testCapturingLocal(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public void test(int i) {\n+                       class I {\n+                           public I(@Visible @Invisible long l) {}\n+                           public String toString() {\n+                               return T.this.toString() + i; \/\/force outer this capture\n+                           }\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$1I\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"@Invisible @Visible long\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public void test(int i) {\n+                       class I {\n+                           public <T> I(@Visible @Invisible long l) {}\n+                           public String toString() {\n+                               return T.this.toString() + i; \/\/force outer this capture\n+                           }\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$1I\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"@Invisible @Visible long\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public void test(int i) {\n+                       class I {\n+                           public I(@Visible @Invisible long l) {}\n+                           public String toString() {\n+                               return T.this.toString() + i; \/\/force outer this capture\n+                           }\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$1I\",\n+                NO_SIGNATURE,\n+               \"T, @Invisible @Visible long, int\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public void test(int i) {\n+                       class I {\n+                           public I(@Visible @Invisible long l) {}\n+                           public String toString() {\n+                               return T.this.toString() + i; \/\/force outer this capture\n+                           }\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$1I\",\n+                NO_SIGNATURE_NO_METHOD_PARAMETERS,\n+               \"T, @Invisible @Visible long, int\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   {\n+                       int i = 0;\n+                       class I {\n+                           public I(@Visible @Invisible long l) {}\n+                           public String toString() {\n+                               return T.this.toString() + i; \/\/force outer this capture\n+                           }\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$1I\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"@Invisible @Visible long\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   {\n+                       int i = 0;\n+                       class I {\n+                           public <T> I(@Visible @Invisible long l) {}\n+                           public String toString() {\n+                               return T.this.toString() + i; \/\/force outer this capture\n+                           }\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$1I\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"@Invisible @Visible long\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   {\n+                       int i = 0;\n+                       class I {\n+                           public I(@Visible @Invisible long l) {}\n+                           public String toString() {\n+                               return T.this.toString() + i; \/\/force outer this capture\n+                           }\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$1I\",\n+                NO_SIGNATURE,\n+               \"T, @Invisible @Visible long, int\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   {\n+                       int i = 0;\n+                       class I {\n+                           public I(@Visible @Invisible long l) {}\n+                           public String toString() {\n+                               return T.this.toString() + i; \/\/force outer this capture\n+                           }\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$1I\",\n+                NO_SIGNATURE_NO_METHOD_PARAMETERS,\n+               \"T, @Invisible @Visible long, int\");\n+    }\n+\n+    @Test\n+    public void testSyntheticTests(Path base) throws Exception {\n+        \/\/Signature attribute will defined one parameter, but the\n+        \/\/Runtime(In)VisibleParameterAnnotations will define 3 parameters:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public void test(int i) {\n+                       class I {\n+                           public I(@Visible @Invisible long l) {}\n+                           public String toString() {\n+                               return T.this.toString() + i; \/\/force outer this capture\n+                           }\n+                       }\n+                   }\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T$1I\",\n+                new MethodTransform() {\n+                    @Override\n+                    public void accept(MethodBuilder builder, MethodElement element) {\n+                        if (element instanceof RuntimeInvisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 1;\n+                            builder.accept(RuntimeInvisibleParameterAnnotationsAttribute.of(List.of(List.of(), annos.parameterAnnotations().get(0), List.of())));\n+                        } else if (element instanceof RuntimeVisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 1;\n+                            builder.accept(RuntimeVisibleParameterAnnotationsAttribute.of(List.of(List.of(), annos.parameterAnnotations().get(0), List.of())));\n+                        } else {\n+                            builder.accept(element);\n+                        }\n+                    }\n+                },\n+               \"@Invisible @Visible long\");\n+        \/\/no Signature attribute, no synthetic parameters,\n+        \/\/but less entries in Runtime(In)VisibleParameterAnnotations than parameters\n+        \/\/no way to map anything:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public T(int i, @Visible @Invisible long l, String s) {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T\",\n+                new MethodTransform() {\n+                    @Override\n+                    public void accept(MethodBuilder builder, MethodElement element) {\n+                        if (element instanceof RuntimeInvisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 3;\n+                            builder.accept(RuntimeInvisibleParameterAnnotationsAttribute.of(List.of(annos.parameterAnnotations().get(1))));\n+                        } else if (element instanceof RuntimeVisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 3;\n+                            builder.accept(RuntimeVisibleParameterAnnotationsAttribute.of(List.of(annos.parameterAnnotations().get(1))));\n+                        } else {\n+                            builder.accept(element);\n+                        }\n+                    }\n+                },\n+               \"int, long, java.lang.String\",\n+               \"- compiler.warn.runtime.invisible.parameter.annotations: T.class\",\n+               \"1 warning\");\n+        \/\/no Signature attribute, no synthetic parameters,\n+        \/\/but more entries in Runtime(In)VisibleParameterAnnotations than parameters\n+        \/\/no way to map anything:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public T(@Visible @Invisible long l) {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T\",\n+                new MethodTransform() {\n+                    @Override\n+                    public void accept(MethodBuilder builder, MethodElement element) {\n+                        if (element instanceof RuntimeInvisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 1;\n+                            builder.accept(RuntimeInvisibleParameterAnnotationsAttribute.of(List.of(List.of(), annos.parameterAnnotations().get(0), List.of())));\n+                        } else if (element instanceof RuntimeVisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 1;\n+                            builder.accept(RuntimeVisibleParameterAnnotationsAttribute.of(List.of(List.of(), annos.parameterAnnotations().get(0), List.of())));\n+                        } else {\n+                            builder.accept(element);\n+                        }\n+                    }\n+                },\n+               \"long\",\n+               \"- compiler.warn.runtime.invisible.parameter.annotations: T.class\",\n+               \"1 warning\");\n+        \/\/mismatched lengths on RuntimeVisibleParameterAnnotations and\n+        \/\/RuntimeInvisibleParameterAnnotations:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public class T {\n+                   public T(@Visible @Invisible long l) {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"T\",\n+                new MethodTransform() {\n+                    @Override\n+                    public void accept(MethodBuilder builder, MethodElement element) {\n+                        if (element instanceof RuntimeInvisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 1;\n+                            builder.accept(annos); \/\/keep intact\n+                        } else if (element instanceof RuntimeVisibleParameterAnnotationsAttribute annos) {\n+                            assert annos.parameterAnnotations().size() == 1;\n+                            builder.accept(RuntimeVisibleParameterAnnotationsAttribute.of(List.of(List.of(), annos.parameterAnnotations().get(0), List.of())));\n+                        } else {\n+                            builder.accept(element);\n+                        }\n+                    }\n+                },\n+               \"long\",\n+               \"- compiler.warn.runtime.visible.invisible.param.annotations.mismatch: T.class\",\n+               \"1 warning\");\n+    }\n+\n+    @Test\n+    public void testRecord(Path base) throws Exception {\n+        \/\/implicit constructor:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public record R(int i, @Visible @Invisible long l, String s) {\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"R\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"int, @Invisible @Visible long, java.lang.String\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public record R(int i, @Visible @Invisible long l, String s) {\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"R\",\n+                NO_SIGNATURE,\n+               \"int, @Invisible @Visible long, java.lang.String\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public record R(int i, @Visible @Invisible long l, String s) {\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"R\",\n+                NO_SIGNATURE_NO_METHOD_PARAMETERS,\n+               \"int, @Invisible @Visible long, java.lang.String\");\n+        \/\/compact constructor:\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public record R(int i, @Visible @Invisible long l, String s) {\n+                   public R {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"R\",\n+                MethodTransform.ACCEPT_ALL,\n+               \"int, @Invisible @Visible long, java.lang.String\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public record R(int i, @Visible @Invisible long l, String s) {\n+                   public R {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"R\",\n+                NO_SIGNATURE,\n+               \"int, @Invisible @Visible long, java.lang.String\");\n+        doTest(base,\n+               \"\"\"\n+               import java.lang.annotation.*;\n+               public record R(int i, @Visible @Invisible long l, String s) {\n+                   public R {}\n+               }\n+               @Retention(RetentionPolicy.RUNTIME)\n+               @interface Visible {}\n+               @interface Invisible {}\n+               \"\"\",\n+               \"R\",\n+                NO_SIGNATURE_NO_METHOD_PARAMETERS,\n+               \"int, @Invisible @Visible long, java.lang.String\");\n+    }\n+\n+    private MethodTransform NO_SIGNATURE =\n+            MethodTransform.dropping(element -> element instanceof SignatureAttribute);\n+\n+    private MethodTransform NO_SIGNATURE_NO_METHOD_PARAMETERS =\n+            MethodTransform.dropping(element -> element instanceof SignatureAttribute ||\n+                                     element instanceof MethodParametersAttribute);\n+\n+    private void doTest(Path base, String code, String binaryNameToCheck,\n+                        MethodTransform changeConstructor, String expectedOutput,\n+                        String... expectedDiagnostics) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeJavaFiles(src, code);\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+\n+        Path classfile = classes.resolve(binaryNameToCheck + \".class\");\n+        ClassFile cf = ClassFile.of();\n+\n+        ClassModel model = cf.parse(classfile);\n+\n+        byte[] newClassFile = cf.transformClass(model,\n+                                                ClassTransform.transformingMethods(m -> m.methodName()\n+                                                                                         .equalsString(\"<init>\"),\n+                                                                                  changeConstructor));\n+\n+        try (OutputStream out = Files.newOutputStream(classfile)) {\n+            out.write(newClassFile);\n+        }\n+\n+        Task.Result result = new JavacTask(tb)\n+                .options(\"-classpath\", classes.toString(),\n+                        \"-processor\", TestAP.class.getName(),\n+                        \"-XDrawDiagnostics\",\n+                        \"-Xlint:classfile\")\n+                .outdir(classes)\n+                .classes(binaryNameToCheck)\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll();\n+        List<String> out = result.getOutputLines(Task.OutputKind.STDOUT);\n+        if (!out.equals(List.of(expectedOutput))) {\n+            throw new AssertionError(\"Expected: \" + List.of(expectedOutput) + \", but got: \" + out);\n+        }\n+        List<String> diagnostics =\n+                new ArrayList<>(result.getOutputLines(Task.OutputKind.DIRECT));\n+        diagnostics.remove(\"\");\n+        if (!diagnostics.equals(List.of(expectedDiagnostics))) {\n+            throw new AssertionError(\"Expected: \" + List.of(expectedDiagnostics) + \", but got: \" + diagnostics);\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    public static final class TestAP extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            for (TypeElement clazz : ElementFilter.typesIn(roundEnv.getRootElements())) {\n+                for (ExecutableElement el : ElementFilter.constructorsIn(clazz.getEnclosedElements())) {\n+                    String sep = \"\";\n+\n+                    for (VariableElement p : el.getParameters()) {\n+                        System.out.print(sep);\n+                        if (!p.getAnnotationMirrors().isEmpty()) {\n+                            System.out.print(p.getAnnotationMirrors()\n+                                              .stream()\n+                                              .map(m -> m.toString())\n+                                              .collect(Collectors.joining(\" \")));\n+                            System.out.print(\" \");\n+                        }\n+                        System.out.print(p.asType());\n+                        sep = \", \";\n+                    }\n+\n+                    System.out.println();\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latest();\n+        }\n+\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/parameter\/ParameterAnnotations.java","additions":699,"deletions":0,"binary":false,"changes":699,"status":"added"},{"patch":"@@ -218,1 +218,1 @@\n-            name = annotation.classSymbol().descriptorString();\n+            name = annotation.annotation().classSymbol().descriptorString();\n@@ -230,1 +230,1 @@\n-                annotationValueDebugString(cm, annotation),\n+                annotationValueDebugString(cm, annotation.annotation()),\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/AnonymousClassTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-            tad.annotation = anno.className().stringValue();\n+            tad.annotation = anno.annotation().className().stringValue();\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/ReferenceInfoUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,2 @@\n-compiler.misc.bad.runtime.invisible.param.annotations   # bad class file\n+compiler.warn.runtime.invisible.parameter.annotations   # bad class file\n+compiler.warn.runtime.visible.invisible.param.annotations.mismatch   # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.class.method.or.field.expected\n+\/\/ options: --enable-preview --source ${jdk.version}\n+\n+\"neither-of-class-method-file-statement\"\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ClassMethodOrFieldExpected.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976 8324859\n@@ -2486,0 +2486,531 @@\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion1() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              return true;\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             return true;\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion2() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }                       \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion2: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion3() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion3: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion4() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          }\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion4: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion5() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test(String,\n+                      }\n+                      class T {}\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:38:compiler.err.expected\",\n+                             \"4:1:compiler.err.illegal.start.of.type\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test(String <error>, (ERROR: ) <error>);\n+                     }\n+                     class T {\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion6() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          private Object testMethod(final String arg1 final String arg2) {\n+                              return null;\n+                          }\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:48:compiler.err.expected3\",\n+                             \"3:66:compiler.err.expected\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         private Object testMethod(final String arg1);\n+                         final String arg2;\n+                         {\n+                             return null;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion7() throws IOException {\n+        \/\/after 'default' attribute value, only semicolon (';') is expected,\n+        \/\/not left brace ('{'):\n+        String code = \"\"\"\n+                      package tests;\n+                      public @interface A {\n+                          public String value() default \"\"\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:37:compiler.err.expected\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public @interface A {\n+                         \\n\\\n+                         public String value() default \"\";\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion10() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              String s = \"\";\n+                              return s.isEmpty();\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             String s = \"\";\n+                             return s.isEmpty();\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion11() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          String s = \"\"; \/\/field declaration\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         String s = \"\";\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion12() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              final String s = \"\";\n+                              return s.isEmpty();\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             final String s = \"\";\n+                             return s.isEmpty();\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion13() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          final String s = \"\"; \/\/field declaration?\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         final String s = \"\";\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion14() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              String s = \"\";\n+                              s.length();\n+                              if (true); \/\/force parse as block\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\",\n+                             \"7:5:compiler.err.illegal.start.of.expr\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             String s = \"\";\n+                             s.length();\n+                             if (true) ;\n+                             (ERROR: );\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":532,"deletions":1,"binary":false,"changes":533,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-                    actual.append(ta.className().stringValue() + \" pos: [\" + ta.targetInfo().targetType());\n+                    actual.append(ta.annotation().className().stringValue() + \" pos: [\" + ta.targetInfo().targetType());\n","filename":"test\/langtools\/tools\/javac\/patterns\/Annotations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1618,1 +1618,1 @@\n-        String annotationName = tAnno.classSymbol().displayName();\n+        String annotationName = tAnno.annotation().classSymbol().displayName();\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301580 8322159 8333107 8332230\n+ * @bug 8301580 8322159 8333107 8332230 8338678\n@@ -37,0 +37,5 @@\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n@@ -38,0 +43,1 @@\n+import java.util.IdentityHashMap;\n@@ -39,0 +45,1 @@\n+import java.util.Map;\n@@ -40,0 +47,7 @@\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.tools.Diagnostic;\n@@ -237,0 +251,76 @@\n+    @Test\n+    public void testParameterizedErroneousType() throws Exception {\n+        String code = \"\"\"\n+                      public class C {\n+                          Undefined1<Undefined2, Undefined3> variable1;\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .callback(task -> {\n+                    task.addTaskListener(new TaskListener() {\n+                        @Override\n+                        public void finished(TaskEvent e) {\n+                            Trees trees = Trees.instance(task);\n+\n+                            if (e.getKind() == TaskEvent.Kind.ANALYZE) {\n+                                new TreePathScanner<Void, Void>() {\n+                                    @Override\n+                                    public Void visitVariable(VariableTree tree, Void p) {\n+                                        VariableElement var = (VariableElement) trees.getElement(getCurrentPath());\n+\n+                                        trees.printMessage(Diagnostic.Kind.NOTE, type2String(var.asType()), tree, e.getCompilationUnit());\n+\n+                                        return super.visitVariable(tree, p);\n+                                    }\n+                                }.scan(e.getCompilationUnit(), null);\n+                            }\n+                        }\n+                        Map<Element, Integer> identityRename = new IdentityHashMap<>();\n+                        String type2String(TypeMirror type) {\n+                            StringBuilder result = new StringBuilder();\n+\n+                            result.append(type.getKind());\n+                            result.append(\":\");\n+                            result.append(type.toString());\n+\n+                            if (type.getKind() == TypeKind.DECLARED ||\n+                                type.getKind() == TypeKind.ERROR) {\n+                                DeclaredType dt = (DeclaredType) type;\n+                                Element el = task.getTypes().asElement(dt);\n+                                result.append(\":\");\n+                                result.append(el.toString());\n+                                if (!dt.getTypeArguments().isEmpty()) {\n+                                    result.append(dt.getTypeArguments()\n+                                                    .stream()\n+                                                    .map(tm -> type2String(tm))\n+                                                    .collect(Collectors.joining(\", \", \"<\", \">\")));\n+                                }\n+                            } else {\n+                                throw new AssertionError(type.getKind().name());\n+                            }\n+\n+                            return result.toString();\n+                        }\n+                    });\n+                })\n+                .run(Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"C.java:2:5: compiler.err.cant.resolve.location: kindname.class, Undefined1, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:16: compiler.err.cant.resolve.location: kindname.class, Undefined2, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:28: compiler.err.cant.resolve.location: kindname.class, Undefined3, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:40: compiler.note.proc.messager: ERROR:Undefined1<Undefined2,Undefined3>:Undefined1<ERROR:Undefined2:Undefined2, ERROR:Undefined3:Undefined3>\",\n+                \"3 errors\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":91,"deletions":1,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,2 +130,2 @@\n-            if (nif.getName().contains(\"awdl\")) {\n-                return false; \/\/ exclude awdl\n+            if (nif.getName().contains(\"awdl\") || nif.getName().contains(\"docker\")) {\n+                return false; \/\/ exclude awdl or docker\n@@ -148,0 +148,7 @@\n+\n+        if (Platform.isLinux()) {\n+            String dName = nif.getDisplayName();\n+            if (dName != null && dName.contains(\"docker\")) {\n+                return false;\n+            }\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/NetworkConfiguration.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -324,4 +324,5 @@\n-        String template =\n-            \"FROM %s:%s\\n\" +\n-            \"RUN apt-get install libubsan1\\n\" +\n-            \"COPY \/jdk \/jdk\\n\" +\n+        String template = \"FROM %s:%s\\n\";\n+        if (baseImage.contains(\"ubuntu\") && DockerfileConfig.isUbsan()) {\n+            template += \"RUN apt-get update && apt-get install -y libubsan1\\n\";\n+        }\n+        template = template + \"COPY \/jdk \/jdk\\n\" +\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerTestUtils.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+\n+    public static boolean isUbsan() {\n+        return Boolean.getBoolean(\"jdk.test.docker.image.isUbsan\");\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerfileConfig.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.systemd;\n+\n+import static jdk.test.lib.Asserts.assertNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+\n+\/\/ This class represents options for running java inside systemd slices\n+\/\/ in test environment.\n+public class SystemdRunOptions {\n+    public ArrayList<String> javaOpts = new ArrayList<>();\n+    public String classToRun;  \/\/ class or \"-version\"\n+    public ArrayList<String> classParams = new ArrayList<>();\n+    public String memoryLimit; \/\/ used in slice for MemoryLimit property\n+    public String cpuLimit;    \/\/ used in slice for CPUQuota property\n+    public String sliceName;   \/\/ name of the slice (nests CPU in memory)\n+    public String sliceDMemoryLimit; \/\/ used in jdk_internal.slice.d\n+    public String sliceDCpuLimit;    \/\/ used in jdk_internal.slice.d\n+\n+    \/**\n+     * Convenience constructor for most common use cases in testing.\n+     * @param classToRun  a class to run, or \"-version\"\n+     * @param javaOpts  java options to use\n+     *\n+     * @return Default docker run options\n+     *\/\n+    public SystemdRunOptions(String classToRun, String... javaOpts) {\n+        this.classToRun = classToRun;\n+        Collections.addAll(this.javaOpts, javaOpts);\n+        this.sliceName = defaultSliceName();\n+    }\n+\n+    private static String defaultSliceName() {\n+        \/\/ Create a unique name for a systemd slice\n+        \/\/ jtreg guarantees that test.name is unique among all concurrently executing\n+        \/\/ tests. For example, if you have two test roots:\n+        \/\/\n+        \/\/     $ find test -type f\n+        \/\/     test\/foo\/TEST.ROOT\n+        \/\/     test\/foo\/my\/TestCase.java\n+        \/\/     test\/bar\/TEST.ROOT\n+        \/\/     test\/bar\/my\/TestCase.java\n+        \/\/     $ jtreg -concur:2 test\/foo test\/bar\n+        \/\/\n+        \/\/ jtreg will first run all the tests under test\/foo. When they are all finished, then\n+        \/\/ jtreg will run all the tests under test\/bar. So you will never have two concurrent\n+        \/\/ test cases whose test.name is \"my\/TestCase.java\"\n+        String testname = System.getProperty(\"test.name\");\n+        assertNotNull(testname, \"must be set by jtreg\");\n+        testname = testname.replace(\".java\", \"\");\n+        testname = testname.replace(\"\/\", \"_\");\n+        testname = testname.replace(\"\\\\\", \"_\");\n+        testname = testname.replace(\"-\", \"_\");\n+\n+        \/\/ Example:\n+        \/\/  Memory: \"test_containers_systemd_TestMemoryAwareness\"\n+        \/\/  CPU:    \"test_containers_systemd_TestMemoryAwareness-cpu\" => derived\n+        return testname;\n+    }\n+\n+    \/**\n+     * The memory limit set with a .slice file in the systemd\n+     * config directory.\n+     *\n+     * @param memLimit The memory limit to set (e.g. 1000M).\n+     * @return The run options.\n+     *\/\n+    public SystemdRunOptions memoryLimit(String memLimit) {\n+        this.memoryLimit = memLimit;\n+        return this;\n+    }\n+\n+    \/**\n+     * The memory limit to set in the top-level jdk_internal.slice.d\n+     * systemd config directory.\n+     *\n+     * @param memoryLimit The memory limit to set.\n+     * @return The run options.\n+     *\/\n+    public SystemdRunOptions sliceDMemoryLimit(String memoryLimit) {\n+        this.sliceDMemoryLimit = memoryLimit;\n+        return this;\n+    }\n+\n+    \/**\n+     * The CPU limit set with a .slice file in the systemd\n+     * config directory.\n+     *\n+     * @param cpuLimit\n+     * @return The run options.\n+     *\/\n+    public SystemdRunOptions cpuLimit(String cpuLimit) {\n+        this.cpuLimit = cpuLimit;\n+        return this;\n+    }\n+\n+    \/**\n+     * The Cpu limit set in the top-level jdk_internal.slice.d\n+     * systemd config directory.\n+     *\n+     * @param cpuLimit The CPU limit to set to.\n+     * @return The run options.\n+     *\/\n+    public SystemdRunOptions sliceDCpuLimit(String cpuLimit) {\n+        this.sliceDCpuLimit = cpuLimit;\n+        return this;\n+    }\n+\n+    public SystemdRunOptions sliceName(String name) {\n+        this.sliceName = name;\n+        return this;\n+    }\n+\n+    public SystemdRunOptions addJavaOpts(String... opts) {\n+        Collections.addAll(javaOpts, opts);\n+        return this;\n+    }\n+\n+    public SystemdRunOptions addClassOptions(String... opts) {\n+        Collections.addAll(classParams,opts);\n+        return this;\n+    }\n+\n+    public boolean hasSliceDLimit() {\n+        return this.sliceDMemoryLimit != null ||\n+                this.sliceDCpuLimit != null;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/systemd\/SystemdRunOptions.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,350 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.systemd;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.platform.Metrics;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.FileUtils;\n+import jtreg.SkippedException;\n+\n+public class SystemdTestUtils {\n+\n+    private static final String CGROUPS_PROVIDER = Metrics.systemMetrics().getProvider();\n+    private static boolean CGROUPS_V2 = \"cgroupv2\".equals(CGROUPS_PROVIDER);\n+    public static boolean RUN_AS_USER = !Platform.isRoot() && CGROUPS_V2;\n+    private static final String SLICE_NAMESPACE_PREFIX = \"jdk_internal\";\n+    private static final String SLICE_D_MEM_CONFIG_FILE = \"memory-limit.conf\";\n+    private static final String SLICE_D_CPU_CONFIG_FILE = \"cpu-limit.conf\";\n+    private static final String USER_HOME = System.getProperty(\"user.home\");\n+    private static final Path SYSTEMD_CONFIG_HOME_ROOT = Path.of(\"\/\", \"etc\", \"systemd\", \"system\");\n+    private static final Path SYSTEMD_CONFIG_HOME_USER = Path.of(USER_HOME, \".config\", \"systemd\", \"user\");\n+    private static final Path SYSTEMD_CONFIG_HOME = Platform.isRoot() ? SYSTEMD_CONFIG_HOME_ROOT : SYSTEMD_CONFIG_HOME_USER;\n+\n+    \/\/ Specifies how many lines to copy from child STDOUT to main test output.\n+    \/\/ Having too many lines in the main test output will result\n+    \/\/ in JT harness trimming the output, and can lead to loss of useful\n+    \/\/ diagnostic information.\n+    private static final int MAX_LINES_TO_COPY_FOR_CHILD_STDOUT = 100;\n+\n+    public record ResultFiles(Path memory, Path cpu, Path sliceDotDDir) {}\n+\n+    \/**\n+     * Create commonly used options with the class to be launched inside the\n+     * systemd slice\n+     *\n+     * @param testClass The test class or {@code -version}\n+     * @return The basic options.\n+     *\/\n+    public static SystemdRunOptions newOpts(String testClass) {\n+        return new SystemdRunOptions(testClass,\n+                                     \"-Xlog:os+container=trace\",\n+                                     \"-cp\",\n+                                     Utils.TEST_CLASSES);\n+    }\n+\n+    \/**\n+     * Run Java inside a systemd slice with specified parameters and options.\n+     *\n+     * @param opts The systemd slice options when running java\n+     * @return An OutputAnalyzer of the output of the command than ran.\n+     * @throws Exception If something went wrong.\n+     * @throws SkippedException If the test cannot be run (i.e. non-root user\n+     *         on cgroups v1).\n+     *\/\n+    public static OutputAnalyzer buildAndRunSystemdJava(SystemdRunOptions opts) throws Exception, SkippedException {\n+        if (!Platform.isRoot() && !CGROUPS_V2) {\n+            throw new SkippedException(\"Systemd tests require root on cgroup v1. Test skipped!\");\n+        }\n+        ResultFiles files = SystemdTestUtils.buildSystemdSlices(opts);\n+\n+        try {\n+            return SystemdTestUtils.systemdRunJava(opts);\n+        } finally {\n+            try {\n+                if (files.memory() != null) {\n+                    Files.delete(files.memory());\n+                }\n+                if (files.cpu() != null) {\n+                    Files.delete(files.cpu());\n+                }\n+                if (files.sliceDotDDir() != null) {\n+                    FileUtils.deleteFileTreeUnchecked(files.sliceDotDDir());\n+                }\n+            } catch (NoSuchFileException e) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    private static OutputAnalyzer systemdRunJava(SystemdRunOptions opts) throws Exception {\n+        return execute(buildJavaCommand(opts));\n+    }\n+\n+    \/**\n+     * Create systemd slice files under \/etc\/systemd\/system.\n+     *\n+     * The JDK will then run within that slice as provided by the SystemdRunOptions.\n+     *\n+     * @param runOpts The systemd slice options to use when running the test.\n+     * @return The systemd slice files (for cleanup-purposes later).\n+     * @throws Exception\n+     *\/\n+    private static ResultFiles buildSystemdSlices(SystemdRunOptions runOpts) throws Exception {\n+        String sliceName = sliceName(runOpts);\n+        String sliceNameCpu = sliceNameCpu(runOpts);\n+\n+        \/\/ Generate systemd slices for cpu\/memory\n+        String memorySliceContent = getMemorySlice(runOpts, sliceName);\n+        String cpuSliceContent = getCpuSlice(runOpts, sliceName);\n+\n+        \/\/ Ensure base directory exists\n+        Files.createDirectories(SYSTEMD_CONFIG_HOME);\n+        Path sliceDotDDir = null;\n+        if (runOpts.hasSliceDLimit()) {\n+            String dirName = String.format(\"%s.slice.d\", SLICE_NAMESPACE_PREFIX);\n+            sliceDotDDir = SYSTEMD_CONFIG_HOME.resolve(Path.of(dirName));\n+            Files.createDirectory(sliceDotDDir);\n+\n+            if (runOpts.sliceDMemoryLimit != null) {\n+                Path memoryConfig = sliceDotDDir.resolve(Path.of(SLICE_D_MEM_CONFIG_FILE));\n+                Files.writeString(memoryConfig, getMemoryDSliceContent(runOpts));\n+            }\n+            if (runOpts.sliceDCpuLimit != null) {\n+                Path cpuConfig = sliceDotDDir.resolve(Path.of(SLICE_D_CPU_CONFIG_FILE));\n+                Files.writeString(cpuConfig, getCPUDSliceContent(runOpts));\n+            }\n+        }\n+\n+        Path memory, cpu;\n+        try {\n+            \/\/ memory slice\n+            memory = SYSTEMD_CONFIG_HOME.resolve(Path.of(sliceFileName(sliceName)));\n+            \/\/ cpu slice nested in memory\n+            cpu = SYSTEMD_CONFIG_HOME.resolve(Path.of(sliceFileName(sliceNameCpu)));\n+            Files.writeString(memory, memorySliceContent);\n+            Files.writeString(cpu, cpuSliceContent);\n+        } catch (IOException e) {\n+            throw new AssertionError(\"Failed to write systemd slice files\");\n+        }\n+\n+        systemdDaemonReload(cpu);\n+\n+        return new ResultFiles(memory, cpu, sliceDotDDir);\n+    }\n+\n+    private static String sliceName(SystemdRunOptions runOpts) {\n+        \/\/ Slice name may include '-' which is a hierarchical slice indicator.\n+        \/\/ Replace '-' with '_' to avoid side-effects.\n+        return SLICE_NAMESPACE_PREFIX + \"-\" + runOpts.sliceName.replace(\"-\", \"_\");\n+    }\n+\n+    private static String sliceNameCpu(SystemdRunOptions runOpts) {\n+        String slice = sliceName(runOpts);\n+        return String.format(\"%s-cpu\", slice);\n+    }\n+\n+    private static void systemdDaemonReload(Path cpu) throws Exception {\n+        List<String> daemonReload = systemCtl();\n+        daemonReload.add(\"daemon-reload\");\n+\n+        if (execute(daemonReload).getExitValue() != 0) {\n+            throw new AssertionError(\"Failed to reload systemd daemon\");\n+        }\n+    }\n+\n+    private static List<String> systemCtl() {\n+        return commandWithUser(\"systemctl\");\n+    }\n+\n+    \/**\n+     * 'baseCommand' or 'baseCommand --user' as list, depending on the cgroups\n+     * version and running user.\n+     *\n+     * @return 'baseCommand' if we are the root user, 'systemctl --user' if\n+     *         the current user is non-root and we are on cgroups v2. Note:\n+     *         Cgroups v1 and non-root is not possible as tests are skipped then.\n+     *\/\n+    private static List<String> commandWithUser(String baseCommand) {\n+        List<String> command = new ArrayList<>();\n+        command.add(baseCommand);\n+        if (RUN_AS_USER) {\n+            command.add(\"--user\");\n+        }\n+        return command;\n+    }\n+\n+    private static String getCpuSlice(SystemdRunOptions runOpts, String sliceName) {\n+        String basicSliceFormat = getBasicSliceFormat();\n+        return String.format(basicSliceFormat, sliceName, getCPUSliceContent(runOpts));\n+    }\n+\n+    private static String getCPUSliceContent(SystemdRunOptions runOpts) {\n+        String format = basicCPUContentFormat();\n+         return String.format(format, runOpts.cpuLimit);\n+    }\n+\n+    private static String getMemorySlice(SystemdRunOptions runOpts, String sliceName) {\n+        String basicSliceFormat = getBasicSliceFormat();\n+        return String.format(basicSliceFormat, sliceName, getMemorySliceContent(runOpts));\n+    }\n+\n+    private static String getMemoryDSliceContent(SystemdRunOptions runOpts) {\n+        String format = \"[Slice]\\n\" + basicMemoryContentFormat();\n+        return String.format(format, runOpts.sliceDMemoryLimit);\n+    }\n+\n+    private static String getCPUDSliceContent(SystemdRunOptions runOpts) {\n+        String format = \"[Slice]\\n\" + basicCPUContentFormat();\n+        return String.format(format, runOpts.sliceDCpuLimit);\n+    }\n+\n+    private static String basicCPUContentFormat() {\n+        return \"\"\"\n+                CPUAccounting=true\n+                CPUQuota=%s\n+                \"\"\";\n+    }\n+\n+    private static String basicMemoryContentFormat() {\n+        return \"\"\"\n+                MemoryAccounting=true\n+                MemoryLimit=%s\n+                \"\"\";\n+    }\n+\n+    private static String getMemorySliceContent(SystemdRunOptions runOpts) {\n+        String format = basicMemoryContentFormat();\n+\n+        return String.format(format, runOpts.memoryLimit);\n+    }\n+\n+    private static String getBasicSliceFormat() {\n+        return \"\"\"\n+               [Unit]\n+               Description=OpenJDK Tests Slice for %s\n+               Before=slices.target\n+\n+               [Slice]\n+               %s\n+               \"\"\";\n+    }\n+\n+    private static String sliceFileName(String sliceName) {\n+        return String.format(\"%s.slice\", sliceName);\n+    }\n+\n+    \/**\n+     * Build the java command to run inside a systemd slice\n+     *\n+     * @param SystemdRunOptions options for running the systemd slice test\n+     *\n+     * @return command\n+     * @throws Exception\n+     *\/\n+    private static List<String> buildJavaCommand(SystemdRunOptions opts) throws Exception {\n+        \/\/ systemd-run [--user] --slice <slice-name>.slice --scope <java>\n+        List<String> javaCmd = systemdRun();\n+        javaCmd.add(\"--slice\");\n+        javaCmd.add(sliceFileName(sliceNameCpu(opts)));\n+        javaCmd.add(\"--scope\");\n+        javaCmd.add(Path.of(Utils.TEST_JDK, \"bin\", \"java\").toString());\n+        javaCmd.addAll(opts.javaOpts);\n+        javaCmd.add(opts.classToRun);\n+        javaCmd.addAll(opts.classParams);\n+        return javaCmd;\n+    }\n+\n+    private static List<String> systemdRun() {\n+        return commandWithUser(\"systemd-run\");\n+    }\n+\n+    \/**\n+     * Execute a specified command in a process, report diagnostic info.\n+     *\n+     * @param command to be executed\n+     * @return The output from the process\n+     * @throws Exception\n+     *\/\n+    private static OutputAnalyzer execute(List<String> command) throws Exception {\n+        return execute(command.toArray(String[]::new));\n+    }\n+\n+    \/**\n+     * Execute a specified command in a process, report diagnostic info.\n+     *\n+     * @param command to be executed\n+     * @return The output from the process\n+     * @throws Exception\n+     *\/\n+    private static OutputAnalyzer execute(String... command) throws Exception {\n+        ProcessBuilder pb = new ProcessBuilder(command);\n+        System.out.println(\"[COMMAND]\\n\" + Utils.getCommandLine(pb));\n+\n+        Process p = pb.start();\n+        long pid = p.pid();\n+        OutputAnalyzer output = new OutputAnalyzer(p);\n+\n+        int max = MAX_LINES_TO_COPY_FOR_CHILD_STDOUT;\n+        String stdout = output.getStdout();\n+        String stdoutLimited = limitLines(stdout, max);\n+        System.out.println(\"[STDERR]\\n\" + output.getStderr());\n+        System.out.println(\"[STDOUT]\\n\" + stdoutLimited);\n+        if (stdout != stdoutLimited) {\n+            System.out.printf(\"Child process STDOUT is limited to %d lines\\n\",\n+                              max);\n+        }\n+\n+        String stdoutLogFile = String.format(\"systemd-stdout-%d.log\", pid);\n+        writeOutputToFile(stdout, stdoutLogFile);\n+        System.out.println(\"Full child process STDOUT was saved to \" + stdoutLogFile);\n+\n+        return output;\n+    }\n+\n+    private static void writeOutputToFile(String output, String fileName) throws Exception {\n+        try (FileWriter fw = new FileWriter(fileName)) {\n+            fw.write(output, 0, output.length());\n+        }\n+    }\n+\n+    private static String limitLines(String buffer, int nrOfLines) {\n+        List<String> l = Arrays.asList(buffer.split(\"\\\\R\"));\n+        if (l.size() < nrOfLines) {\n+            return buffer;\n+        }\n+\n+        return String.join(\"\\n\", l.subList(0, nrOfLines));\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/systemd\/SystemdTestUtils.java","additions":350,"deletions":0,"binary":false,"changes":350,"status":"added"},{"patch":"@@ -43,1 +43,2 @@\n-    private static final String deprecatedmsg = \".* VM warning:.* deprecated.*\";\n+    private static final String VM_DEPRECATED_MSG = \".* VM warning:.* deprecated.*\";\n+    private static final String OTHER_DEPRECATED_MSG = \"^WARNING: .* is deprecated.*\";\n@@ -185,1 +186,1 @@\n-        if (!getStderr().replaceAll(deprecatedmsg + \"\\\\R\", \"\").isEmpty()) {\n+        if (!getStderrNoDeprecatedWarnings().isEmpty()) {\n@@ -606,0 +607,9 @@\n+    \/**\n+     * Get the contents of the stderr buffer, with known deprecation warning patterns removed\n+     *\n+     * @return stderr buffer, with known deprecation warnings removed\n+     *\/\n+    public String getStderrNoDeprecatedWarnings() {\n+        return getStderr().replaceAll(VM_DEPRECATED_MSG + \"\\\\R\", \"\").replaceAll(OTHER_DEPRECATED_MSG + \"\\\\R\", \"\");\n+    }\n+\n@@ -692,1 +702,1 @@\n-        String stderr = getStderr().replaceAll(deprecatedmsg + \"\\\\R\", \"\");\n+        String stderr = getStderrNoDeprecatedWarnings();\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputAnalyzer.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -68,0 +68,6 @@\n+\n+    public byte[] nBytes(int n) {\n+        var out = new byte[n];\n+        nextBytes(out);\n+        return out;\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/security\/SeededSecureRandom.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.thread;\n+\n+import java.util.concurrent.ThreadFactory;\n+\n+\/*\n+    This factory is used to start new threads in tests.\n+    It supports creation of virtual threads when jtreg test.thread.factory plugin is enabled.\n+*\/\n+\n+public class TestThreadFactory {\n+\n+    private static ThreadFactory threadFactory = \"Virtual\".equals(System.getProperty(\"test.thread.factory\"))\n+            ? virtualThreadFactory() : platformThreadFactory();\n+\n+    public static Thread newThread(Runnable task) {\n+        return threadFactory.newThread(task);\n+    }\n+\n+    public static Thread newThread(Runnable task, String name) {\n+        Thread t = threadFactory.newThread(task);\n+        t.setName(name);\n+        return t;\n+    }\n+\n+    private static ThreadFactory platformThreadFactory() {\n+        return Thread.ofPlatform().factory();\n+    }\n+\n+    private static ThreadFactory virtualThreadFactory() {\n+        return Thread.ofVirtual().factory();\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/thread\/TestThreadFactory.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-import java.lang.reflect.Field;\n+import java.lang.management.ManagementFactory;\n@@ -28,1 +28,0 @@\n-import java.util.concurrent.ForkJoinPool;\n@@ -30,0 +29,1 @@\n+import jdk.management.VirtualThreadSchedulerMXBean;\n@@ -136,14 +136,0 @@\n-    \/**\n-     * Returns the virtual thread scheduler.\n-     *\/\n-    private static ForkJoinPool defaultScheduler() {\n-        try {\n-            var clazz = Class.forName(\"java.lang.VirtualThread\");\n-            var field = clazz.getDeclaredField(\"DEFAULT_SCHEDULER\");\n-            field.setAccessible(true);\n-            return (ForkJoinPool) field.get(null);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n@@ -152,0 +138,4 @@\n+     *\n+     * <p> Tests using this method should use \"{@code @modules jdk.management}\" to help\n+     * test selection.\n+     *\n@@ -155,1 +145,4 @@\n-        return defaultScheduler().setParallelism(size);\n+        var bean = ManagementFactory.getPlatformMXBean(VirtualThreadSchedulerMXBean.class);\n+        int parallelism = bean.getParallelism();\n+        bean.setParallelism(size);\n+        return parallelism;\n@@ -162,0 +155,4 @@\n+     *\n+     * <p> Tests using this method should use \"{@code @modules jdk.management}\" to help\n+     * test selection.\n+     *\n@@ -165,2 +162,2 @@\n-        ForkJoinPool pool = defaultScheduler();\n-        int parallelism = pool.getParallelism();\n+        var bean = ManagementFactory.getPlatformMXBean(VirtualThreadSchedulerMXBean.class);\n+        int parallelism = bean.getParallelism();\n@@ -168,1 +165,1 @@\n-            pool.setParallelism(size);\n+            bean.setParallelism(size);\n","filename":"test\/lib\/jdk\/test\/lib\/thread\/VThreadRunner.java","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,3 +81,2 @@\n-        obj = null;\n-        Reference.reachabilityFence(obj);\n-        Reference.reachabilityFence(ref);\n+        try {\n+            obj = null;\n@@ -85,5 +84,5 @@\n-        int retries = (int)(timeout \/ 200);\n-        for (; retries >= 0; retries--) {\n-            if (booleanSupplier.getAsBoolean()) {\n-                return true;\n-            }\n+            int retries = (int) (timeout \/ 200);\n+            for (; retries >= 0; retries--) {\n+                if (booleanSupplier.getAsBoolean()) {\n+                    return true;\n+                }\n@@ -91,1 +90,1 @@\n-            System.gc();\n+                System.gc();\n@@ -93,8 +92,9 @@\n-            try {\n-                \/\/ The remove() will always block for the specified milliseconds\n-                \/\/ if the reference has already been removed from the queue.\n-                \/\/ But it is fine.  For most cases, the 1st GC is sufficient\n-                \/\/ to trigger and complete the cleanup.\n-                queue.remove(200L);\n-            } catch (InterruptedException ie) {\n-                \/\/ ignore, the loop will try again\n+                try {\n+                    \/\/ The remove() will always block for the specified milliseconds\n+                    \/\/ if the reference has already been removed from the queue.\n+                    \/\/ But it is fine.  For most cases, the 1st GC is sufficient\n+                    \/\/ to trigger and complete the cleanup.\n+                    queue.remove(200L);\n+                } catch (InterruptedException ie) {\n+                    \/\/ ignore, the loop will try again\n+                }\n@@ -102,0 +102,2 @@\n+        } finally {\n+            Reference.reachabilityFence(ref);\n@@ -103,1 +105,0 @@\n-\n","filename":"test\/lib\/jdk\/test\/lib\/util\/ForceGC.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -772,0 +772,1 @@\n+  public native int hostCPUs();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -51,1 +52,2 @@\n-\n+    public Integer integerValue = intValue;\n+    public float floatValue = 156456.36435637F + intValue;\n@@ -53,1 +55,0 @@\n-\n@@ -55,1 +56,0 @@\n-\n@@ -57,1 +57,1 @@\n-\n+    public Boolean booleanValue = Boolean.TRUE;\n@@ -59,1 +59,0 @@\n-\n@@ -62,0 +61,10 @@\n+    @Benchmark\n+    public String concatConstBool() {\n+        return \"string\" + boolValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstBoolean() {\n+        return \"string\" + booleanValue;\n+    }\n+\n@@ -67,0 +76,10 @@\n+    @Benchmark\n+    public String concatConstInteger() {\n+        return \"string\" + integerValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstFloat() {\n+        return \"string\" + floatValue;\n+    }\n+\n@@ -97,0 +116,25 @@\n+    @Benchmark\n+    public String concatConstBoolString() {\n+        return \"string\" + boolValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstBooleanString() {\n+        return \"string\" + booleanValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntString() {\n+        return \"string\" + intValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntegerString() {\n+        return \"string\" + integerValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstFloatString() {\n+        return \"string\" + floatValue + stringValue;\n+    }\n+\n@@ -107,0 +151,30 @@\n+    @Benchmark\n+    public String concatConstStringConst() {\n+        return \"string\" + stringValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntConst() {\n+        return \"string\" + intValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntegerConst() {\n+        return \"string\" + integerValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstFloatConst() {\n+        return \"string\" + floatValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstObjectConst() {\n+        return \"string\" + objectValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstBooleanConst() {\n+        return \"string\" + booleanValue + \"string\";\n+    }\n+\n@@ -117,0 +191,25 @@\n+    @Benchmark\n+    public String concat3String() {\n+        return stringValue + stringValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringBoolString() {\n+        return stringValue + boolValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringBooleanString() {\n+        return stringValue + booleanValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringIntString() {\n+        return stringValue + intValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringIntegerString() {\n+        return stringValue + integerValue + stringValue;\n+    }\n+\n@@ -179,0 +278,9 @@\n+\n+    @Benchmark\n+    public String concat30Mix() {\n+        return f0 + \",\" + f1 + \",\"+ f2 + \",\"+  f3 + \",\"+  f4 + \",\"+  f5 + \",\"+  f6 + \",\"+  f7 + \",\"+  f8 + \",\"+  f9 + \",\"\n+              +f10 + \",\"+f11 + \",\"+f12 + \",\"+ f13 + \",\"+ f14 + \",\"+ f15 + \",\"+ f16 + \",\"+ f17 + \",\"+ f18 + \",\"+ f19 + \",\"\n+              +f20 + \",\"+f21 + \",\"+f22 + \",\" + boolValue + \",\" + booleanValue + \",\" + intValue + \",\" + integerValue\n+              + \",\" + floatValue + \",\" + byteValue + \",\" + objectValue;\n+    }\n+\n@@ -196,0 +304,29 @@\n+    @Benchmark\n+    public String concat13StringConst() {\n+        return f0  + f1  + f2  + f3 + f4\n+             + f5  + f6  + f7  + f8 + f9\n+             +f10 + f11 + f12 + \"\"\"\n+                A really long constant string. Such as a copyright header:\n+                 * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+                 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+                 *\n+                 * This code is free software; you can redistribute it and\/or modify it\n+                 * under the terms of the GNU General Public License version 2 only, as\n+                 * published by the Free Software Foundation.\n+                 *\n+                 * This code is distributed in the hope that it will be useful, but WITHOUT\n+                 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+                 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+                 * version 2 for more details (a copy is included in the LICENSE file that\n+                 * accompanied this code).\n+                 *\n+                 * You should have received a copy of the GNU General Public License version\n+                 * 2 along with this work; if not, write to the Free Software Foundation,\n+                 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+                 *\n+                 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+                 * or visit www.oracle.com if you need additional information or have any\n+                 * questions.\n+                \"\"\";\n+    }\n+\n@@ -198,1 +335,1 @@\n-        return f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + \"\"\"\n+        return f0 + f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8 + f9 + f10 + f11 + f12 + f13 + f14 + f15 + f16 + f17 + f18 + f19 + f20 + f21 + f22 + \"\"\"\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConcat.java","additions":143,"deletions":6,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -47,1 +49,7 @@\n-        String[] selection = new String[] { \"StringLarge\", \"MixedSmall\", \"StringSingle\", \"MixedLarge\" };\n+        String[] selection = {\n+                \"StringLarge\",\n+                \"MixedSmall\",\n+                \"StringSingle\",\n+                \"StringThree\",\n+                \"MixedLarge\"\n+        };\n@@ -53,1 +61,13 @@\n-                case \"StringSingle\" -> new StringSingle().run();\n+                case \"StringSingle\" -> {\n+                    new StringSingle().constInt();\n+                    new StringSingle().constFloat();\n+                    new StringSingle().constString();\n+                    new StringSingle().const2String();\n+                    new StringSingle().constIntString();\n+                    new StringSingle().constFloatString();\n+                    new StringSingle().constBooleanString();\n+                }\n+                case \"StringThree\" -> {\n+                    new StringThree().stringIntString();\n+                    new StringThree().stringIntegerString();\n+                }\n@@ -67,1 +87,7 @@\n-        public String s = \"foo\";\n+        @Param(\"4711\")\n+        public int intValue;\n+        public Integer integerValue = intValue;\n+        public float floatValue = 156456.36435637F + intValue;\n+        public String stringValue = String.valueOf(intValue);\n+        public boolean boolValue = true;\n+        public Boolean booleanValue = Boolean.TRUE;\n@@ -70,2 +96,56 @@\n-        public String run() {\n-            return \"\" + s;\n+        public String constBool() {\n+            return \"string\" + boolValue;\n+        }\n+\n+        @Benchmark\n+        public String constBoolean() {\n+            return \"string\" + booleanValue;\n+        }\n+\n+        @Benchmark\n+        public String constInt() {\n+            return \"string\" + intValue;\n+        }\n+\n+        @Benchmark\n+        public String constInteger() {\n+            return \"string\" + integerValue;\n+        }\n+\n+        @Benchmark\n+        public String constFloat() {\n+            return \"string\" + floatValue;\n+        }\n+\n+        @Benchmark\n+        public String constString() {\n+            return \"string\" + stringValue;\n+        }\n+\n+        public String const2String() {\n+            return \"string\" + stringValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constIntString() {\n+            return \"string\" + intValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constIntegerString() {\n+            return \"string\" + integerValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constFloatString() {\n+            return \"string\" + floatValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constBoolString() {\n+            return \"string\" + boolValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constBooleanString() {\n+            return \"string\" + booleanValue + stringValue;\n@@ -75,0 +155,21 @@\n+    @BenchmarkMode(Mode.SingleShotTime)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    @State(Scope.Thread)\n+    @Fork(value = 40, warmups = 2)\n+    public static class StringThree {\n+\n+        @Param(\"4711\")\n+        public int intValue;\n+        public Integer integerValue = intValue;\n+        public String stringValue = String.valueOf(intValue);\n+\n+        @Benchmark\n+        public String stringIntString() {\n+            return stringValue + intValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String stringIntegerString() {\n+            return stringValue + integerValue + stringValue;\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConcatStartup.java","additions":106,"deletions":5,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.classfile;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.*;\n+import java.lang.constant.*;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HexFormat;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+import jdk.internal.classfile.impl.*;\n+\/**\n+ * Test various operations on\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 1, time = 2)\n+@Measurement(iterations = 3, time = 1)\n+@Fork(jvmArgsAppend = \"--enable-preview\", value = 3)\n+@State(Scope.Thread)\n+public class Utf8EntryWriteTo {\n+    static final ClassDesc STRING_BUILDER = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringBuilder;\");\n+    static final MethodTypeDesc MTD_append = MethodTypeDesc.of(STRING_BUILDER, CD_String);\n+    static final MethodTypeDesc MTD_String = MethodTypeDesc.of(CD_String);\n+    static final ClassDesc CLASS_DESC = ClassDesc.ofDescriptor(\"Lorg\/openjdk\/bench\/java\/lang\/classfile\/String$$StringConcat;\");\n+\n+    @Param({\"ascii\", \"utf8_2_bytes\", \"utf8_3_bytes\", \"emoji\"})\n+    public String charType;\n+    ConstantPoolBuilder poolBuilder;\n+    ClassEntry thisClass;\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        byte[] bytes = HexFormat.of().parseHex(\n+                switch (charType) {\n+                    case \"ascii\"        -> \"78\";\n+                    case \"utf8_2_bytes\" -> \"c2a9\";\n+                    case \"utf8_3_bytes\" -> \"e6b8a9\";\n+                    case \"emoji\"        -> \"e29da3efb88f\";\n+                    default -> throw new IllegalArgumentException(\"bad charType: \" + charType);\n+                }\n+        );\n+        String s = new String(bytes, 0, bytes.length, StandardCharsets.UTF_8);\n+        String[] constants = new String[128];\n+        for (int i = 0; i < constants.length; i++) {\n+            constants[i] = \"A\".repeat(i).concat(s);\n+        }\n+\n+        poolBuilder = ConstantPoolBuilder.of();\n+        thisClass = poolBuilder.classEntry(CLASS_DESC);\n+        for (var c : constants) {\n+            poolBuilder.utf8Entry(c);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void writeTo(Blackhole bh) {\n+        bh.consume(ClassFile\n+                .of()\n+                .build(thisClass, poolBuilder, (ClassBuilder clb) -> {}));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/classfile\/Utf8EntryWriteTo.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -61,0 +61,4 @@\n+            \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/lang\/Object;\",\n+            \"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/String;\",\n+            \"(Ljava\/lang\/Integer;Ljava\/lang\/Integer;)Ljava\/lang\/Integer;\",\n+            \"()Ljava\/lang\/Object;\",\n@@ -64,0 +68,1 @@\n+            \"([III.Z[B..[.[B).\",\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/MethodTypeDescFactories.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class CopyTest {\n+\n+    @Param({\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\",\n+            \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\",\n+            \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\",\n+            \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\",\n+            \"33\", \"36\", \"40\", \"44\", \"48\", \"52\", \"56\", \"60\", \"63\", \"64\", \"128\"})\n+    public int ELEM_SIZE;\n+\n+    byte[] srcArray;\n+    byte[] dstArray;\n+    MemorySegment heapSrcSegment;\n+    MemorySegment heapDstSegment;\n+    MemorySegment nativeSrcSegment;\n+    MemorySegment nativeDstSegment;\n+    ByteBuffer srcBuffer;\n+    ByteBuffer dstBuffer;\n+\n+    @Setup\n+    public void setup() {\n+        srcArray = new byte[ELEM_SIZE];\n+        dstArray = new byte[ELEM_SIZE];\n+        heapSrcSegment = MemorySegment.ofArray(srcArray);\n+        heapDstSegment = MemorySegment.ofArray(dstArray);\n+        nativeSrcSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n+        nativeDstSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n+        srcBuffer = ByteBuffer.wrap(srcArray);\n+        dstBuffer = ByteBuffer.wrap(dstArray);\n+    }\n+\n+    @Benchmark\n+    public void array_copy() {\n+        System.arraycopy(srcArray, 0, dstArray, 0, ELEM_SIZE);\n+    }\n+\n+    @Benchmark\n+    public void heap_segment_copy5Arg() {\n+        MemorySegment.copy(heapSrcSegment, 0, heapDstSegment, 0, ELEM_SIZE);\n+    }\n+\n+    @Benchmark\n+    public void native_segment_copy5Arg() {\n+        MemorySegment.copy(nativeSrcSegment, 0, nativeDstSegment, 0, ELEM_SIZE);\n+    }\n+\n+    @Benchmark\n+    public void heap_segment_copy7arg() {\n+        MemorySegment.copy(heapSrcSegment, JAVA_BYTE, 0, heapDstSegment, JAVA_BYTE, 0, ELEM_SIZE);\n+    }\n+\n+    @Benchmark\n+    public void buffer_copy() {\n+        dstBuffer.put(srcBuffer);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CopyTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class TestFill {\n+\n+    @Param({\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\n+            \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\n+            \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\",\n+            \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\",\n+            \"32\", \"128\", \"256\", \"384\", \"511\", \"512\"})\n+    public int ELEM_SIZE;\n+\n+    byte[] array;\n+    MemorySegment heapSegment;\n+    MemorySegment nativeSegment;\n+    MemorySegment unalignedSegment;\n+    ByteBuffer buffer;\n+\n+    @Setup\n+    public void setup() {\n+        array = new byte[ELEM_SIZE];\n+        heapSegment = MemorySegment.ofArray(array);\n+        nativeSegment = Arena.ofAuto().allocate(ELEM_SIZE, 8);\n+        unalignedSegment = Arena.ofAuto().allocate(ELEM_SIZE + 1, 8).asSlice(1);\n+        buffer = ByteBuffer.wrap(array);\n+    }\n+\n+    @Benchmark\n+    public void arrays_fill() {\n+        Arrays.fill(array, (byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void heap_segment_fill() {\n+        heapSegment.fill((byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void native_segment_fill() {\n+        nativeSegment.fill((byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void unaligned_segment_fill() {\n+        unalignedSegment.fill((byte) 0);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestFill.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -115,7 +115,0 @@\n-\n-    @Benchmark\n-    public void forPrimitiveType(Blackhole bh) throws Throwable {\n-        for (char c : PRIM_TYPES) {\n-            bh.consume(Wrapper.forPrimitiveType(c));\n-        }\n-    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/Wrappers.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    @Param({\"4\"})\n+    @Param({\"4\", \"32\", \"76\", \"128\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/Base64Decode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -38,0 +39,1 @@\n+import java.util.Enumeration;\n@@ -130,0 +132,15 @@\n+    @Benchmark\n+    public int testConcurrentHashMapIterators() {\n+        ConcurrentHashMap<Integer, Integer> map = (ConcurrentHashMap<Integer, Integer>) staticMap;\n+        int sum = 0;\n+        Enumeration it = map.elements();\n+        while (it.hasMoreElements()) {\n+            sum += (int) it.nextElement();\n+        }\n+        it = map.keys();\n+        while (it.hasMoreElements()) {\n+            sum += (int) it.nextElement();\n+        }\n+        return sum;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/concurrent\/Maps.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -63,0 +63,6 @@\n+    public static void main(String... args) {\n+        FindAny findAny = new FindAny();\n+        findAny.size = 100000;\n+        findAny.seq_invoke();\n+        findAny.par_invoke();\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/FindAny.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.lang.classfile.Attributes;\n@@ -28,1 +29,0 @@\n-import java.nio.ByteBuffer;\n@@ -31,1 +31,0 @@\n-import java.util.Iterator;\n@@ -36,2 +35,0 @@\n-import java.lang.classfile.MethodModel;\n-import java.lang.classfile.constantpool.ConstantPool;\n@@ -41,1 +38,0 @@\n-import jdk.internal.classfile.impl.CodeImpl;\n@@ -44,0 +40,1 @@\n+import jdk.internal.classfile.impl.RawBytecodeHelper;\n@@ -73,1 +70,1 @@\n-                    ByteBuffer bytecode,\n+                    RawBytecodeHelper.CodeRange bytecode,\n@@ -88,2 +85,1 @@\n-                    m.code().ifPresent(com -> {\n-                        var bb = ByteBuffer.wrap(((CodeImpl)com).contents());\n+                    m.findAttribute(Attributes.code()).ifPresent(com -> {\n@@ -96,1 +92,1 @@\n-                                bb.slice(8, bb.getInt(4)),\n+                                RawBytecodeHelper.of(com.codeArray()),\n@@ -115,1 +111,1 @@\n-                d.bytecode().rewind(),\n+                d.bytecode(),\n@@ -125,0 +121,1 @@\n+                null,\n@@ -129,1 +126,1 @@\n-                d.bytecode().rewind(),\n+                d.bytecode(),\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/CodeAttributeTools.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.classfile.TypeKind;\n@@ -145,1 +144,1 @@\n-                      .withCode(codeb -> codeb.loadLocal(TypeKind.ReferenceType, 0)\n+                      .withCode(codeb -> codeb.loadLocal(REFERENCE, 0)\n@@ -147,1 +146,1 @@\n-                                              .return_(VoidType)\n+                                              .return_(VOID)\n@@ -193,1 +192,1 @@\n-                          mb -> mb.withCode(codeb -> codeb.loadLocal(ReferenceType, 0)\n+                          mb -> mb.withCode(codeb -> codeb.loadLocal(REFERENCE, 0)\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Write.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,3 @@\n+    private boolean[] boolsA;\n+    private boolean[] boolsB;\n+    private boolean[] resZ;\n@@ -61,0 +64,3 @@\n+        boolsA = new boolean[COUNT];\n+        boolsB = new boolean[COUNT];\n+        resZ = new boolean[COUNT];\n@@ -76,0 +82,2 @@\n+            boolsA[i] = r.nextBoolean();\n+            boolsB[i] = r.nextBoolean();\n@@ -369,0 +377,7 @@\n+    @Benchmark\n+    public void andZ() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resZ[i] = boolsA[i] & boolsB[i];\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.util.Random;\n+\n@@ -41,0 +43,10 @@\n+    @Setup(Level.Iteration)\n+    public void setup() {\n+        Random random = new Random(1000);\n+\n+        for (int i = 0; i < 1024; i++) {\n+            INT_ARRAY[i] = random.nextInt();\n+            LONG_ARRAY[i] = random.nextLong();\n+        }\n+    }\n+\n@@ -128,0 +140,7 @@\n+\n+    @Benchmark\n+    public void cmovL_imm_01(Blackhole bh) {\n+        for (int i = 0; i < INT_ARRAY.length; i++) {\n+            bh.consume(INT_ARRAY[i] > 0 ? 1L : 0L);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/x86\/BasicRules.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+    public volatile Object lockObject3Inflated;\n+    public volatile Object lockObject4Inflated;\n@@ -65,0 +67,15 @@\n+        lockObject3Inflated = new Object();\n+        lockObject4Inflated = new Object();\n+\n+        \/\/ Inflate the lock to use an ObjectMonitor\n+        try {\n+          synchronized (lockObject3Inflated) {\n+            lockObject3Inflated.wait(1);\n+          }\n+          synchronized (lockObject4Inflated) {\n+            lockObject4Inflated.wait(1);\n+          }\n+        } catch (InterruptedException e) {\n+          throw new RuntimeException(e);\n+        }\n+\n@@ -71,1 +88,1 @@\n-    public void testSimpleLockUnlock() {\n+    public void testBasicSimpleLockUnlockLocal() {\n@@ -81,0 +98,34 @@\n+    \/** Perform a synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testBasicSimpleLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject1) {\n+                dummyInt1++;\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform a synchronized on a local object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedSimpleLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (localObject) {\n+                dummyInt1++;\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform a synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedSimpleLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n@@ -83,1 +134,1 @@\n-    public void testRecursiveLockUnlock() {\n+    public void testBasicRecursiveLockUnlockLocal() {\n@@ -95,0 +146,13 @@\n+    \/** Perform a recursive synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testBasicRecursiveLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject1) {\n+                synchronized (lockObject1) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n@@ -97,1 +161,1 @@\n-    public void testSerialLockUnlock() {\n+    public void testBasicSerialLockUnlockLocal() {\n@@ -109,0 +173,120 @@\n+  \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testBasicSerialLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject1) {\n+                dummyInt1++;\n+            }\n+            synchronized (lockObject1) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same local object. *\/\n+    @Benchmark\n+    public void testInflatedSerialLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (localObject) {\n+                dummyInt1++;\n+            }\n+            synchronized (localObject) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedSerialLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+            }\n+            synchronized (lockObject3Inflated) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedMultipleSerialLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+            }\n+            synchronized (lockObject4Inflated) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedMultipleRecursiveLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+                synchronized (lockObject4Inflated) {\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+      \/** Perform a recursive-only synchronized on a local object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveOnlyLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        synchronized (localObject) {\n+            for (int i = 0; i < innerCount; i++) {\n+                synchronized (localObject) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Perform a recursive-only synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveOnlyLockUnlock() {\n+        synchronized (lockObject3Inflated) {\n+            for (int i = 0; i < innerCount; i++) {\n+                synchronized (lockObject3Inflated) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Perform a recursive-only synchronized on a local object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (localObject) {\n+                synchronized (localObject) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Perform a recursive-only synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                synchronized (lockObject3Inflated) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/LockUnlock.java","additions":187,"deletions":3,"binary":false,"changes":190,"status":"modified"}]}