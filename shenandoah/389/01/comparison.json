{"files":[{"patch":"@@ -69,1 +69,1 @@\n-      uses: actions\/upload-artifact@v3\n+      uses: actions\/upload-artifact@v4\n@@ -77,1 +77,1 @@\n-      uses: actions\/github-script@v6\n+      uses: actions\/github-script@v7\n","filename":".github\/actions\/do-build\/action.yml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-      uses: actions\/cache@v3\n+      uses: actions\/cache@v4\n","filename":".github\/actions\/get-bootjdk\/action.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-      uses: actions\/download-artifact@v3\n+      uses: actions\/download-artifact@v4\n@@ -58,1 +58,1 @@\n-      uses: actions\/download-artifact@v3\n+      uses: actions\/download-artifact@v4\n","filename":".github\/actions\/get-bundles\/action.yml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-      uses: actions\/cache@v3\n+      uses: actions\/cache@v4\n","filename":".github\/actions\/get-jtreg\/action.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-      # use a specific release of msys2\/setup-msys2 to prevent jtreg build failures on newer release\n-      uses: msys2\/setup-msys2@7efe20baefed56359985e327d329042cde2434ff\n+      uses: msys2\/setup-msys2@v2.22.0\n","filename":".github\/actions\/get-msys2\/action.yml","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-      uses: actions\/upload-artifact@v3\n+      uses: actions\/upload-artifact@v4\n","filename":".github\/actions\/upload-bundles\/action.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  echo 'failure=true' >> $GITHUB_OUTPUT\n","filename":".github\/scripts\/gen-test-summary.sh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-        uses: actions\/cache@v3\n+        uses: actions\/cache@v4\n","filename":".github\/workflows\/build-cross-compile.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-        uses: actions\/github-script@v6\n+        uses: actions\/github-script@v7\n","filename":".github\/workflows\/main.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-        uses: actions\/upload-artifact@v3\n+        uses: actions\/upload-artifact@v4\n@@ -227,1 +227,1 @@\n-        uses: actions\/github-script@v6\n+        uses: actions\/github-script@v7\n","filename":".github\/workflows\/test.yml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-    java\/lang\/classfile\/components\/snippet-files\n+    java\/lang\/classfile\/components\/snippet-files \\\n+    java\/lang\/foreign\/snippet-files\n","filename":"make\/modules\/java.base\/Java.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -452,1 +452,0 @@\n-  # gcc_ftobjs.c := maybe-uninitialized required for GCC 7 builds.\n@@ -461,1 +460,0 @@\n-      DISABLED_WARNINGS_gcc_ftobjs.c := maybe-uninitialized, \\\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2380,1 +2380,1 @@\n-int Matcher::superword_max_vector_size(const BasicType bt) {\n+int Matcher::max_vector_size_auto_vectorization(const BasicType bt) {\n@@ -8292,1 +8292,1 @@\n-            \"dmb ish\" %}\n+            \"dmb ishld\" %}\n@@ -8346,1 +8346,1 @@\n-            \"dmb ish\" %}\n+            \"dmb ishst\\n\\tdmb ishld\" %}\n@@ -8350,1 +8350,2 @@\n-    __ membar(Assembler::LoadStore|Assembler::StoreStore);\n+    __ membar(Assembler::StoreStore);\n+    __ membar(Assembler::LoadStore);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,1 @@\n-  bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+  bool Matcher::match_rule_supported_auto_vectorization(int opcode, int vlen, BasicType bt) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-  bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+  bool Matcher::match_rule_supported_auto_vectorization(int opcode, int vlen, BasicType bt) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -190,0 +190,20 @@\n+\/\/ This encoding is similar (but not quite identical) to the encoding used\n+\/\/ by literal ld\/st. see JDK-8324123.\n+\/\/ PRFM does not support writeback or pre\/post index.\n+void Assembler::prfm(const Address &adr, prfop pfop) {\n+  Address::mode mode = adr.getMode();\n+  \/\/ PRFM does not support pre\/post index\n+  guarantee((mode != Address::pre) && (mode != Address::post), \"prfm does not support pre\/post indexing\");\n+  if (mode == Address::literal) {\n+    starti;\n+    f(0b11, 31, 30), f(0b011, 29, 27), f(0b000, 26, 24);\n+    f(pfop, 4, 0);\n+    int64_t offset = (adr.target() - pc()) >> 2;\n+    sf(offset, 23, 5);\n+  } else {\n+    assert((mode == Address::base_plus_offset)\n+            || (mode == Address::base_plus_offset_reg), \"must be base_plus_offset\/base_plus_offset_reg\");\n+    ld_st2(as_Register(pfop), adr, 0b11, 0b10);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -800,0 +800,2 @@\n+  void prfm(const Address &adr, prfop pfop = PLDL1KEEP);\n+\n@@ -1577,11 +1579,0 @@\n-#define INSN(NAME, size, op)                                    \\\n-  void NAME(const Address &adr, prfop pfop = PLDL1KEEP) {       \\\n-    ld_st2(as_Register(pfop), adr, size, op);                   \\\n-  }\n-\n-  INSN(prfm, 0b11, 0b10); \/\/ FIXME: PRFM should not be used with\n-                          \/\/ writeback modes, but the assembler\n-                          \/\/ doesn't enfore that.\n-\n-#undef INSN\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -834,5 +834,3 @@\n-      if (StubRoutines::dlog() != nullptr) {\n-        __ call_runtime_leaf(StubRoutines::dlog(), getThreadTemp(), result_reg, cc->args());\n-      } else {\n-        __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog), getThreadTemp(), result_reg, cc->args());\n-      }\n+      \/\/ Math.log intrinsic is not implemented on AArch64 (see JDK-8210858),\n+      \/\/ but we can still call the shared runtime.\n+      __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog), getThreadTemp(), result_reg, cc->args());\n@@ -841,5 +839,1 @@\n-      if (StubRoutines::dlog10() != nullptr) {\n-        __ call_runtime_leaf(StubRoutines::dlog10(), getThreadTemp(), result_reg, cc->args());\n-      } else {\n-        __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog10), getThreadTemp(), result_reg, cc->args());\n-      }\n+      __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog10), getThreadTemp(), result_reg, cc->args());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -130,0 +130,2 @@\n+  product(bool, AlwaysMergeDMB, false, DIAGNOSTIC,                      \\\n+          \"Always merge DMB instructions in code emission\")             \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2069,7 +2069,12 @@\n-    \/\/ We are merging two memory barrier instructions.  On AArch64 we\n-    \/\/ can do this simply by ORing them together.\n-    bar->set_kind(bar->get_kind() | order_constraint);\n-    BLOCK_COMMENT(\"merged membar\");\n-  } else {\n-    code()->set_last_insn(pc());\n-    dmb(Assembler::barrier(order_constraint));\n+    \/\/ Don't promote DMB ST|DMB LD to DMB (a full barrier) because\n+    \/\/ doing so would introduce a StoreLoad which the caller did not\n+    \/\/ intend\n+    if (AlwaysMergeDMB || bar->get_kind() == order_constraint\n+        || bar->get_kind() == AnyAny\n+        || order_constraint == AnyAny) {\n+      \/\/ We are merging two memory barrier instructions.  On AArch64 we\n+      \/\/ can do this simply by ORing them together.\n+      bar->set_kind(bar->get_kind() | order_constraint);\n+      BLOCK_COMMENT(\"merged membar\");\n+      return;\n+    }\n@@ -2077,0 +2082,2 @@\n+  code()->set_last_insn(pc());\n+  dmb(Assembler::barrier(order_constraint));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1428,5 +1428,0 @@\n-  void fast_log(FloatRegister vtmp0, FloatRegister vtmp1, FloatRegister vtmp2,\n-                FloatRegister vtmp3, FloatRegister vtmp4, FloatRegister vtmp5,\n-                FloatRegister tmpC1, FloatRegister tmpC2, FloatRegister tmpC3,\n-                FloatRegister tmpC4, Register tmp1, Register tmp2,\n-                Register tmp3, Register tmp4, Register tmp5);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,366 +0,0 @@\n-\/* Copyright (c) 2018, Cavium. All rights reserved. (By BELLSOFT)\n- * Copyright (c) 2016, 2021, Intel Corporation. All rights reserved.\n- * Intel Math Library (LIBM) Source Code\n- *\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/assembler.hpp\"\n-#include \"asm\/assembler.inline.hpp\"\n-#include \"macroAssembler_aarch64.hpp\"\n-\n-\/\/ Algorithm idea is taken from x86 hotspot intrinsic and adapted for AARCH64.\n-\/\/\n-\/\/ For mathematical background please refer to the following literature:\n-\/\/\n-\/\/ Tang, Ping-Tak Peter.\n-\/\/ Table-driven implementation of the logarithm function\n-\/\/ in IEEE floating-point arithmetic.\n-\/\/ ACM Transactions on Mathematical Software (TOMS) 16, no. 4, 1990: 378-400.\n-\n-\/******************************************************************************\/\n-\/\/                     ALGORITHM DESCRIPTION - LOG()\n-\/\/                     ---------------------\n-\/\/\n-\/\/    x=2^k * mx, mx in [1,2)\n-\/\/\n-\/\/    Get B~1\/mx based on the output of frecpe instruction (B0)\n-\/\/    B = int((B0*2^7+0.5))\/2^7\n-\/\/\n-\/\/    Reduced argument: r=B*mx-1.0 (computed accurately in high and low parts)\n-\/\/\n-\/\/    Result:  k*log(2) - log(B) + p(r) if |x-1| >= small value (2^-6)  and\n-\/\/             p(r) is a degree 7 polynomial\n-\/\/             -log(B) read from data table (high, low parts)\n-\/\/             Result is formed from high and low parts\n-\/\/\n-\/\/ Special cases:\n-\/\/ 1. log(NaN) = quiet NaN\n-\/\/ 2. log(+INF) = that INF\n-\/\/ 3. log(0) = -INF\n-\/\/ 4. log(1) = +0\n-\/\/ 5. log(x) = NaN if x < -0, including -INF\n-\/\/\n-\/******************************************************************************\/\n-\n-\/\/ Table with p(r) polynomial coefficients\n-\/\/ and table representation of logarithm values (hi and low parts)\n-ATTRIBUTE_ALIGNED(64) juint _L_tbl[] =\n-{\n-    \/\/ coefficients of p(r) polynomial:\n-    \/\/ _coeff[]\n-    0x00000000UL, 0xbfd00000UL, \/\/ C1_0 = -0.25\n-    0x92492492UL, 0x3fc24924UL, \/\/ C1_1 = 0.14285714285714285\n-    0x55555555UL, 0x3fd55555UL, \/\/ C2_0 = 0.3333333333333333\n-    0x3d6fb175UL, 0xbfc5555eUL, \/\/ C2_1 = -0.16666772842235003\n-    0x00000000UL, 0xbfe00000UL, \/\/ C3_0 = -0.5\n-    0x9999999aUL, 0x3fc99999UL, \/\/ C3_1 = 0.2\n-    \/\/ _log2[]\n-    0xfefa3800UL, 0x3fa62e42UL, \/\/ C4_0 = 0.043321698784993146\n-    0x93c76730UL, 0x3ceef357UL, \/\/ C4_1 = 3.436201886692732e-15\n-    \/\/ _L_tbl[] with logarithm values (hi and low parts)\n-    0xfefa3800UL, 0x3fe62e42UL, 0x93c76730UL, 0x3d2ef357UL, 0xaa241800UL,\n-    0x3fe5ee82UL, 0x0cda46beUL, 0x3d220238UL, 0x5c364800UL, 0x3fe5af40UL,\n-    0xac10c9fbUL, 0x3d2dfa63UL, 0x26bb8c00UL, 0x3fe5707aUL, 0xff3303ddUL,\n-    0x3d09980bUL, 0x26867800UL, 0x3fe5322eUL, 0x5d257531UL, 0x3d05ccc4UL,\n-    0x835a5000UL, 0x3fe4f45aUL, 0x6d93b8fbUL, 0xbd2e6c51UL, 0x6f970c00UL,\n-    0x3fe4b6fdUL, 0xed4c541cUL, 0x3cef7115UL, 0x27e8a400UL, 0x3fe47a15UL,\n-    0xf94d60aaUL, 0xbd22cb6aUL, 0xf2f92400UL, 0x3fe43d9fUL, 0x481051f7UL,\n-    0xbcfd984fUL, 0x2125cc00UL, 0x3fe4019cUL, 0x30f0c74cUL, 0xbd26ce79UL,\n-    0x0c36c000UL, 0x3fe3c608UL, 0x7cfe13c2UL, 0xbd02b736UL, 0x17197800UL,\n-    0x3fe38ae2UL, 0xbb5569a4UL, 0xbd218b7aUL, 0xad9d8c00UL, 0x3fe35028UL,\n-    0x9527e6acUL, 0x3d10b83fUL, 0x44340800UL, 0x3fe315daUL, 0xc5a0ed9cUL,\n-    0xbd274e93UL, 0x57b0e000UL, 0x3fe2dbf5UL, 0x07b9dc11UL, 0xbd17a6e5UL,\n-    0x6d0ec000UL, 0x3fe2a278UL, 0xe797882dUL, 0x3d206d2bUL, 0x1134dc00UL,\n-    0x3fe26962UL, 0x05226250UL, 0xbd0b61f1UL, 0xd8bebc00UL, 0x3fe230b0UL,\n-    0x6e48667bUL, 0x3d12fc06UL, 0x5fc61800UL, 0x3fe1f863UL, 0xc9fe81d3UL,\n-    0xbd2a7242UL, 0x49ae6000UL, 0x3fe1c078UL, 0xed70e667UL, 0x3cccacdeUL,\n-    0x40f23c00UL, 0x3fe188eeUL, 0xf8ab4650UL, 0x3d14cc4eUL, 0xf6f29800UL,\n-    0x3fe151c3UL, 0xa293ae49UL, 0xbd2edd97UL, 0x23c75c00UL, 0x3fe11af8UL,\n-    0xbb9ddcb2UL, 0xbd258647UL, 0x8611cc00UL, 0x3fe0e489UL, 0x07801742UL,\n-    0x3d1c2998UL, 0xe2d05400UL, 0x3fe0ae76UL, 0x887e7e27UL, 0x3d1f486bUL,\n-    0x0533c400UL, 0x3fe078bfUL, 0x41edf5fdUL, 0x3d268122UL, 0xbe760400UL,\n-    0x3fe04360UL, 0xe79539e0UL, 0xbd04c45fUL, 0xe5b20800UL, 0x3fe00e5aUL,\n-    0xb1727b1cUL, 0xbd053ba3UL, 0xaf7a4800UL, 0x3fdfb358UL, 0x3c164935UL,\n-    0x3d0085faUL, 0xee031800UL, 0x3fdf4aa7UL, 0x6f014a8bUL, 0x3d12cde5UL,\n-    0x56b41000UL, 0x3fdee2a1UL, 0x5a470251UL, 0x3d2f27f4UL, 0xc3ddb000UL,\n-    0x3fde7b42UL, 0x5372bd08UL, 0xbd246550UL, 0x1a272800UL, 0x3fde148aUL,\n-    0x07322938UL, 0xbd1326b2UL, 0x484c9800UL, 0x3fddae75UL, 0x60dc616aUL,\n-    0xbd1ea42dUL, 0x46def800UL, 0x3fdd4902UL, 0xe9a767a8UL, 0x3d235bafUL,\n-    0x18064800UL, 0x3fdce42fUL, 0x3ec7a6b0UL, 0xbd0797c3UL, 0xc7455800UL,\n-    0x3fdc7ff9UL, 0xc15249aeUL, 0xbd29b6ddUL, 0x693fa000UL, 0x3fdc1c60UL,\n-    0x7fe8e180UL, 0x3d2cec80UL, 0x1b80e000UL, 0x3fdbb961UL, 0xf40a666dUL,\n-    0x3d27d85bUL, 0x04462800UL, 0x3fdb56faUL, 0x2d841995UL, 0x3d109525UL,\n-    0x5248d000UL, 0x3fdaf529UL, 0x52774458UL, 0xbd217cc5UL, 0x3c8ad800UL,\n-    0x3fda93edUL, 0xbea77a5dUL, 0x3d1e36f2UL, 0x0224f800UL, 0x3fda3344UL,\n-    0x7f9d79f5UL, 0x3d23c645UL, 0xea15f000UL, 0x3fd9d32bUL, 0x10d0c0b0UL,\n-    0xbd26279eUL, 0x43135800UL, 0x3fd973a3UL, 0xa502d9f0UL, 0xbd152313UL,\n-    0x635bf800UL, 0x3fd914a8UL, 0x2ee6307dUL, 0xbd1766b5UL, 0xa88b3000UL,\n-    0x3fd8b639UL, 0xe5e70470UL, 0xbd205ae1UL, 0x776dc800UL, 0x3fd85855UL,\n-    0x3333778aUL, 0x3d2fd56fUL, 0x3bd81800UL, 0x3fd7fafaUL, 0xc812566aUL,\n-    0xbd272090UL, 0x687cf800UL, 0x3fd79e26UL, 0x2efd1778UL, 0x3d29ec7dUL,\n-    0x76c67800UL, 0x3fd741d8UL, 0x49dc60b3UL, 0x3d2d8b09UL, 0xe6af1800UL,\n-    0x3fd6e60eUL, 0x7c222d87UL, 0x3d172165UL, 0x3e9c6800UL, 0x3fd68ac8UL,\n-    0x2756eba0UL, 0x3d20a0d3UL, 0x0b3ab000UL, 0x3fd63003UL, 0xe731ae00UL,\n-    0xbd2db623UL, 0xdf596000UL, 0x3fd5d5bdUL, 0x08a465dcUL, 0xbd0a0b2aUL,\n-    0x53c8d000UL, 0x3fd57bf7UL, 0xee5d40efUL, 0x3d1fadedUL, 0x0738a000UL,\n-    0x3fd522aeUL, 0x8164c759UL, 0x3d2ebe70UL, 0x9e173000UL, 0x3fd4c9e0UL,\n-    0x1b0ad8a4UL, 0xbd2e2089UL, 0xc271c800UL, 0x3fd4718dUL, 0x0967d675UL,\n-    0xbd2f27ceUL, 0x23d5e800UL, 0x3fd419b4UL, 0xec90e09dUL, 0x3d08e436UL,\n-    0x77333000UL, 0x3fd3c252UL, 0xb606bd5cUL, 0x3d183b54UL, 0x76be1000UL,\n-    0x3fd36b67UL, 0xb0f177c8UL, 0x3d116ecdUL, 0xe1d36000UL, 0x3fd314f1UL,\n-    0xd3213cb8UL, 0xbd28e27aUL, 0x7cdc9000UL, 0x3fd2bef0UL, 0x4a5004f4UL,\n-    0x3d2a9cfaUL, 0x1134d800UL, 0x3fd26962UL, 0xdf5bb3b6UL, 0x3d2c93c1UL,\n-    0x6d0eb800UL, 0x3fd21445UL, 0xba46baeaUL, 0x3d0a87deUL, 0x635a6800UL,\n-    0x3fd1bf99UL, 0x5147bdb7UL, 0x3d2ca6edUL, 0xcbacf800UL, 0x3fd16b5cUL,\n-    0xf7a51681UL, 0x3d2b9acdUL, 0x8227e800UL, 0x3fd1178eUL, 0x63a5f01cUL,\n-    0xbd2c210eUL, 0x67616000UL, 0x3fd0c42dUL, 0x163ceae9UL, 0x3d27188bUL,\n-    0x604d5800UL, 0x3fd07138UL, 0x16ed4e91UL, 0x3cf89cdbUL, 0x5626c800UL,\n-    0x3fd01eaeUL, 0x1485e94aUL, 0xbd16f08cUL, 0x6cb3b000UL, 0x3fcf991cUL,\n-    0xca0cdf30UL, 0x3d1bcbecUL, 0xe4dd0000UL, 0x3fcef5adUL, 0x65bb8e11UL,\n-    0xbcca2115UL, 0xffe71000UL, 0x3fce530eUL, 0x6041f430UL, 0x3cc21227UL,\n-    0xb0d49000UL, 0x3fcdb13dUL, 0xf715b035UL, 0xbd2aff2aUL, 0xf2656000UL,\n-    0x3fcd1037UL, 0x75b6f6e4UL, 0xbd084a7eUL, 0xc6f01000UL, 0x3fcc6ffbUL,\n-    0xc5962bd2UL, 0xbcf1ec72UL, 0x383be000UL, 0x3fcbd087UL, 0x595412b6UL,\n-    0xbd2d4bc4UL, 0x575bd000UL, 0x3fcb31d8UL, 0x4eace1aaUL, 0xbd0c358dUL,\n-    0x3c8ae000UL, 0x3fca93edUL, 0x50562169UL, 0xbd287243UL, 0x07089000UL,\n-    0x3fc9f6c4UL, 0x6865817aUL, 0x3d29904dUL, 0xdcf70000UL, 0x3fc95a5aUL,\n-    0x58a0ff6fUL, 0x3d07f228UL, 0xeb390000UL, 0x3fc8beafUL, 0xaae92cd1UL,\n-    0xbd073d54UL, 0x6551a000UL, 0x3fc823c1UL, 0x9a631e83UL, 0x3d1e0ddbUL,\n-    0x85445000UL, 0x3fc7898dUL, 0x70914305UL, 0xbd1c6610UL, 0x8b757000UL,\n-    0x3fc6f012UL, 0xe59c21e1UL, 0xbd25118dUL, 0xbe8c1000UL, 0x3fc6574eUL,\n-    0x2c3c2e78UL, 0x3d19cf8bUL, 0x6b544000UL, 0x3fc5bf40UL, 0xeb68981cUL,\n-    0xbd127023UL, 0xe4a1b000UL, 0x3fc527e5UL, 0xe5697dc7UL, 0x3d2633e8UL,\n-    0x8333b000UL, 0x3fc4913dUL, 0x54fdb678UL, 0x3d258379UL, 0xa5993000UL,\n-    0x3fc3fb45UL, 0x7e6a354dUL, 0xbd2cd1d8UL, 0xb0159000UL, 0x3fc365fcUL,\n-    0x234b7289UL, 0x3cc62fa8UL, 0x0c868000UL, 0x3fc2d161UL, 0xcb81b4a1UL,\n-    0x3d039d6cUL, 0x2a49c000UL, 0x3fc23d71UL, 0x8fd3df5cUL, 0x3d100d23UL,\n-    0x7e23f000UL, 0x3fc1aa2bUL, 0x44389934UL, 0x3d2ca78eUL, 0x8227e000UL,\n-    0x3fc1178eUL, 0xce2d07f2UL, 0x3d21ef78UL, 0xb59e4000UL, 0x3fc08598UL,\n-    0x7009902cUL, 0xbd27e5ddUL, 0x39dbe000UL, 0x3fbfe891UL, 0x4fa10afdUL,\n-    0xbd2534d6UL, 0x830a2000UL, 0x3fbec739UL, 0xafe645e0UL, 0xbd2dc068UL,\n-    0x63844000UL, 0x3fbda727UL, 0x1fa71733UL, 0x3d1a8940UL, 0x01bc4000UL,\n-    0x3fbc8858UL, 0xc65aacd3UL, 0x3d2646d1UL, 0x8dad6000UL, 0x3fbb6ac8UL,\n-    0x2bf768e5UL, 0xbd139080UL, 0x40b1c000UL, 0x3fba4e76UL, 0xb94407c8UL,\n-    0xbd0e42b6UL, 0x5d594000UL, 0x3fb9335eUL, 0x3abd47daUL, 0x3d23115cUL,\n-    0x2f40e000UL, 0x3fb8197eUL, 0xf96ffdf7UL, 0x3d0f80dcUL, 0x0aeac000UL,\n-    0x3fb700d3UL, 0xa99ded32UL, 0x3cec1e8dUL, 0x4d97a000UL, 0x3fb5e95aUL,\n-    0x3c5d1d1eUL, 0xbd2c6906UL, 0x5d208000UL, 0x3fb4d311UL, 0x82f4e1efUL,\n-    0xbcf53a25UL, 0xa7d1e000UL, 0x3fb3bdf5UL, 0xa5db4ed7UL, 0x3d2cc85eUL,\n-    0xa4472000UL, 0x3fb2aa04UL, 0xae9c697dUL, 0xbd20b6e8UL, 0xd1466000UL,\n-    0x3fb1973bUL, 0x560d9e9bUL, 0xbd25325dUL, 0xb59e4000UL, 0x3fb08598UL,\n-    0x7009902cUL, 0xbd17e5ddUL, 0xc006c000UL, 0x3faeea31UL, 0x4fc93b7bUL,\n-    0xbd0e113eUL, 0xcdddc000UL, 0x3faccb73UL, 0x47d82807UL, 0xbd1a68f2UL,\n-    0xd0fb0000UL, 0x3faaaef2UL, 0x353bb42eUL, 0x3d20fc1aUL, 0x149fc000UL,\n-    0x3fa894aaUL, 0xd05a267dUL, 0xbd197995UL, 0xf2d4c000UL, 0x3fa67c94UL,\n-    0xec19afa2UL, 0xbd029efbUL, 0xd42e0000UL, 0x3fa466aeUL, 0x75bdfd28UL,\n-    0xbd2c1673UL, 0x2f8d0000UL, 0x3fa252f3UL, 0xe021b67bUL, 0x3d283e9aUL,\n-    0x89e74000UL, 0x3fa0415dUL, 0x5cf1d753UL, 0x3d0111c0UL, 0xec148000UL,\n-    0x3f9c63d2UL, 0x3f9eb2f3UL, 0x3d2578c6UL, 0x28c90000UL, 0x3f984925UL,\n-    0x325a0c34UL, 0xbd2aa0baUL, 0x25980000UL, 0x3f9432a9UL, 0x928637feUL,\n-    0x3d098139UL, 0x58938000UL, 0x3f902056UL, 0x06e2f7d2UL, 0xbd23dc5bUL,\n-    0xa3890000UL, 0x3f882448UL, 0xda74f640UL, 0xbd275577UL, 0x75890000UL,\n-    0x3f801015UL, 0x999d2be8UL, 0xbd10c76bUL, 0x59580000UL, 0x3f700805UL,\n-    0xcb31c67bUL, 0x3d2166afUL, 0x00000000UL, 0x00000000UL, 0x00000000UL,\n-    0x80000000UL\n-};\n-\n-\/\/ BEGIN dlog PSEUDO CODE:\n-\/\/  double dlog(double X) {\n-\/\/    \/\/ p(r) polynomial coefficients initialized from _L_tbl table\n-\/\/    double C1_0 = _L_tbl[0];\n-\/\/    double C1_1 = _L_tbl[1];\n-\/\/    double C2_0 = _L_tbl[2];\n-\/\/    double C2_1 = _L_tbl[3];\n-\/\/    double C3_0 = _L_tbl[4];\n-\/\/    double C3_1 = _L_tbl[5];\n-\/\/    double C4_0 = _L_tbl[6];\n-\/\/    double C4_1 = _L_tbl[7];\n-\/\/    \/\/ NOTE: operations with coefficients above are mostly vectorized in assembly\n-\/\/    \/\/ Check corner cases first\n-\/\/    if (X == 1.0d || AS_LONG_BITS(X) + 0x0010000000000000 <= 0x0010000000000000) {\n-\/\/      \/\/ NOTE: AS_LONG_BITS(X) + 0x0010000000000000 <= 0x0010000000000000 means\n-\/\/      \/\/    that X < 0 or X >= 0x7FF0000000000000 (0x7FF* is NaN or INF)\n-\/\/      if (X < 0 || X is NaN) return NaN;\n-\/\/      if (X == 1.0d) return 0.0d;\n-\/\/      if (X == 0.0d) return -INFINITY;\n-\/\/      if (X is INFINITY) return INFINITY;\n-\/\/    }\n-\/\/    \/\/ double representation is 2^exponent * mantissa\n-\/\/    \/\/ split X into two multipliers: 2^exponent and 1.0 * mantissa\n-\/\/    \/\/ pseudo function: zeroExponent(X) return value of X with exponent == 0\n-\/\/    float vtmp5 = 1\/(float)(zeroExponent(X)); \/\/ reciprocal estimate\n-\/\/    \/\/ pseudo function: HI16(X) returns high 16 bits of double value\n-\/\/    int hiWord = HI16(X);\n-\/\/    double vtmp1 = (double) 0x77F0 << 48 | mantissa(X);\n-\/\/    hiWord -= 16;\n-\/\/    if (AS_LONG_BITS(hiWord) > 0x8000) {\n-\/\/      \/\/ SMALL_VALUE branch\n-\/\/      vtmp0 = vtmp1 = vtmp0 * AS_DOUBLE_BITS(0x47F0000000000000);\n-\/\/      hiWord = HI16(vtmp1);\n-\/\/      vtmp0 = AS_DOUBLE_BITS(AS_LONG_BITS(vtmp0) |= 0x3FF0000000000000);\n-\/\/      vtmp5 = (double) (1\/(float)vtmp0);\n-\/\/      vtmp1 <<= 12;\n-\/\/      vtmp1 >>= 12;\n-\/\/    }\n-\/\/    \/\/ MAIN branch\n-\/\/    double vtmp3 = AS_LONG_BITS(vtmp1) & 0xffffe00000000000; \/\/ hi part\n-\/\/    int intB0 = AS_INT_BITS(vtmp5) + 0x8000;\n-\/\/    double vtmp0 = AS_DOUBLE_BITS(0xffffe00000000000 & (intB0<<29));\n-\/\/    int index = (intB0 >> 16) && 0xFF;\n-\/\/    double hiTableValue = _L_tbl[8+index]; \/\/ vtmp2[0]\n-\/\/    double lowTableValue = _L_tbl[16+index]; \/\/ vtmp2[1]\n-\/\/    vtmp5 = AS_DOUBLE_BITS(hiWord & 0x7FF0 - 0x3FE0); \/\/ 0x3FE = 1023 << 4\n-\/\/    vtmp1 -= vtmp3; \/\/ low part\n-\/\/    vtmp3 = vtmp3*vtmp0 - 1.0;\n-\/\/    hiTableValue += C4_0 * vtmp5;\n-\/\/    lowTableValue += C4_1 * vtmp5;\n-\/\/    double r = vtmp1 * vtmp0 + vtmp3; \/\/ r = B*mx-1.0, computed in hi and low parts\n-\/\/    vtmp0 = hiTableValue + r;\n-\/\/    hiTableValue -= vtmp0;\n-\/\/    double r2 = r*r;\n-\/\/    double r3 = r2*r;\n-\/\/    double p7 = C3_0*r2 + C2_0*r3 + C1_0*r2*r2 + C3_1*r3*r2 + C2_1*r3*r3\n-\/\/              + C1_1*r3*r2*r2; \/\/ degree 7 polynomial\n-\/\/    return p7 + (vtmp0 + ((r + hiTableValue) + lowTableValue));\n-\/\/  }\n-\/\/\n-\/\/ END dlog PSEUDO CODE\n-\n-\n-\/\/ Generate log(X). X passed in register v0. Return log(X) into v0.\n-\/\/ Generator parameters: 10 temporary FPU registers and  temporary general\n-\/\/ purpose registers\n-void MacroAssembler::fast_log(FloatRegister vtmp0, FloatRegister vtmp1,\n-                              FloatRegister vtmp2, FloatRegister vtmp3,\n-                              FloatRegister vtmp4, FloatRegister vtmp5,\n-                              FloatRegister C1, FloatRegister C2,\n-                              FloatRegister C3, FloatRegister C4,\n-                              Register tmp1, Register tmp2, Register tmp3,\n-                              Register tmp4, Register tmp5) {\n-  Label DONE, CHECK_CORNER_CASES, SMALL_VALUE, MAIN,\n-      CHECKED_CORNER_CASES, RETURN_MINF_OR_NAN;\n-  const int64_t INF_OR_NAN_PREFIX = 0x7FF0;\n-  const int64_t MINF_OR_MNAN_PREFIX = 0xFFF0;\n-  const int64_t ONE_PREFIX = 0x3FF0;\n-    movz(tmp2, ONE_PREFIX, 48);\n-    movz(tmp4, 0x0010, 48);\n-    fmovd(rscratch1, v0); \/\/ rscratch1 = AS_LONG_BITS(X)\n-    lea(rscratch2, ExternalAddress((address)_L_tbl));\n-    movz(tmp5, 0x7F);\n-    add(tmp1, rscratch1, tmp4);\n-    cmp(tmp2, rscratch1);\n-    lsr(tmp3, rscratch1, 29);\n-    ccmp(tmp1, tmp4, 0b1101 \/* LE *\/, NE);\n-    bfm(tmp3, tmp5, 41, 8);\n-    fmovs(vtmp5, tmp3);\n-    \/\/ Load coefficients from table. All coefficients are organized to be\n-    \/\/ in specific order, because load below will load it in vectors to be used\n-    \/\/ later in vector instructions. Load will be performed in parallel while\n-    \/\/ branches are taken. C1 will contain vector of {C1_0, C1_1}, C2 =\n-    \/\/ {C2_0, C2_1}, C3 = {C3_0, C3_1}, C4 = {C4_0, C4_1}\n-    ld1(C1, C2, C3, C4, T2D, post(rscratch2, 64));\n-    br(LE, CHECK_CORNER_CASES);\n-  bind(CHECKED_CORNER_CASES);\n-    \/\/ all corner cases are handled\n-    frecpe(vtmp5, vtmp5, S);                   \/\/ vtmp5 ~= 1\/vtmp5\n-    lsr(tmp2, rscratch1, 48);\n-    movz(tmp4, 0x77f0, 48);\n-    fmovd(vtmp4, 1.0);\n-    movz(tmp1, INF_OR_NAN_PREFIX, 48);\n-    bfm(tmp4, rscratch1, 0, 51);               \/\/ tmp4 = 0x77F0 << 48 | mantissa(X)\n-    \/\/ vtmp1 = AS_DOUBLE_BITS(0x77F0 << 48 | mantissa(X)) == mx\n-    fmovd(vtmp1, tmp4);\n-    subw(tmp2, tmp2, 16);\n-    subs(zr, tmp2, 0x8000);\n-    br(GE, SMALL_VALUE);\n-  bind(MAIN);\n-    fmovs(tmp3, vtmp5);                        \/\/ int intB0 = AS_INT_BITS(B);\n-    mov(tmp5, 0x3FE0);\n-    uint64_t mask = UCONST64(0xffffe00000000000);\n-    mov(rscratch1, mask);\n-    andr(tmp2, tmp2, tmp1, LSR, 48);           \/\/ hiWord & 0x7FF0\n-    sub(tmp2, tmp2, tmp5);                     \/\/ tmp2 = hiWord & 0x7FF0 - 0x3FE0\n-    scvtfwd(vtmp5, tmp2);                      \/\/ vtmp5 = (double)tmp2;\n-    addw(tmp3, tmp3, 0x8000);                  \/\/ tmp3 = B\n-    andr(tmp4, tmp4, rscratch1);               \/\/ tmp4 == hi_part(mx)\n-    andr(rscratch1, rscratch1, tmp3, LSL, 29); \/\/ rscratch1 = hi_part(B)\n-    ubfm(tmp3, tmp3, 16, 23);                  \/\/ int index = (intB0 >> 16) && 0xFF\n-    ldrq(vtmp2, Address(rscratch2, tmp3, Address::lsl(4))); \/\/ vtmp2 = _L_tbl[index]\n-    \/\/ AS_LONG_BITS(vtmp1) & 0xffffe00000000000 \/\/ hi_part(mx)\n-    fmovd(vtmp3, tmp4);\n-    fmovd(vtmp0, rscratch1);                   \/\/ vtmp0 = hi_part(B)\n-    fsubd(vtmp1, vtmp1, vtmp3);                \/\/ vtmp1 -= vtmp3; \/\/ low_part(mx)\n-    fnmsub(vtmp3, vtmp3, vtmp0, vtmp4);        \/\/ vtmp3 = vtmp3*vtmp0 - vtmp4\n-    fmlavs(vtmp2, T2D, C4, vtmp5, 0);          \/\/ vtmp2 += {C4} * vtmp5\n-    \/\/ vtmp1 = r = vtmp1 * vtmp0 + vtmp3 == low_part(mx) * hi_part(B) + (hi_part(mx)*hi_part(B) - 1.0)\n-    fmaddd(vtmp1, vtmp1, vtmp0, vtmp3);\n-    ins(vtmp5, D, vtmp2, 0, 1);                \/\/ vtmp5 = vtmp2[1];\n-    faddd(vtmp0, vtmp2, vtmp1);                \/\/ vtmp0 = vtmp2 + vtmp1\n-    fmlavs(C3, T2D, C2, vtmp1, 0);             \/\/ {C3} += {C2}*vtmp1\n-    fsubd(vtmp2, vtmp2, vtmp0);                \/\/ vtmp2 -= vtmp0\n-    fmuld(vtmp3, vtmp1, vtmp1);                \/\/ vtmp3 = vtmp1*vtmp1\n-    faddd(C4, vtmp1, vtmp2);                   \/\/ C4[0] = vtmp1 + vtmp2\n-    fmlavs(C3, T2D, C1, vtmp3, 0);             \/\/ {C3} += {C1}*vtmp3\n-    faddd(C4, C4, vtmp5);                      \/\/ C4 += vtmp5\n-    fmuld(vtmp4, vtmp3, vtmp1);                \/\/ vtmp4 = vtmp3*vtmp1\n-    faddd(vtmp0, vtmp0, C4);                   \/\/ vtmp0 += C4\n-    fmlavs(C3, T2D, vtmp4, C3, 1);             \/\/ {C3} += {vtmp4}*C3[1]\n-    fmaddd(vtmp0, C3, vtmp3, vtmp0);           \/\/ vtmp0 = C3 * vtmp3 + vtmp0\n-    ret(lr);\n-\n-  block_comment(\"if (AS_LONG_BITS(hiWord) > 0x8000)\"); {\n-    bind(SMALL_VALUE);\n-      movz(tmp2, 0x47F0, 48);\n-      fmovd(vtmp1, tmp2);\n-      fmuld(vtmp0, vtmp1, v0);\n-      fmovd(vtmp1, vtmp0);\n-      umov(tmp2, vtmp1, S, 3);\n-      orr(vtmp0, T16B, vtmp0, vtmp4);\n-      ushr(vtmp5, T2D, vtmp0, 27);\n-      ushr(vtmp5, T4S, vtmp5, 2);\n-      frecpe(vtmp5, vtmp5, S);\n-      shl(vtmp1, T2D, vtmp1, 12);\n-      ushr(vtmp1, T2D, vtmp1, 12);\n-      b(MAIN);\n-  }\n-\n-  block_comment(\"Corner cases\"); {\n-    bind(RETURN_MINF_OR_NAN);\n-      movz(tmp1, MINF_OR_MNAN_PREFIX, 48);\n-      orr(rscratch1, rscratch1, tmp1);\n-      fmovd(v0, rscratch1);\n-      ret(lr);\n-    bind(CHECK_CORNER_CASES);\n-      movz(tmp1, INF_OR_NAN_PREFIX, 48);\n-      cmp(rscratch1, zr);\n-      br(LE, RETURN_MINF_OR_NAN);\n-      cmp(rscratch1, tmp1);\n-      br(GE, DONE);\n-      cmp(rscratch1, tmp2);\n-      br(NE, CHECKED_CORNER_CASES);\n-      fmovd(v0, 0.0);\n-  }\n-  bind(DONE);\n-    ret(lr);\n-}\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64_log.cpp","additions":0,"deletions":366,"binary":false,"changes":366,"status":"deleted"},{"patch":"@@ -5330,13 +5330,0 @@\n-  address generate_dlog() {\n-    __ align(CodeEntryAlignment);\n-    StubCodeMark mark(this, \"StubRoutines\", \"dlog\");\n-    address entry = __ pc();\n-    FloatRegister vtmp0 = v0, vtmp1 = v1, vtmp2 = v2, vtmp3 = v3, vtmp4 = v4,\n-        vtmp5 = v5, tmpC1 = v16, tmpC2 = v17, tmpC3 = v18, tmpC4 = v19;\n-    Register tmp1 = r0, tmp2 = r1, tmp3 = r2, tmp4 = r3, tmp5 = r4;\n-    __ fast_log(vtmp0, vtmp1, vtmp2, vtmp3, vtmp4, vtmp5, tmpC1, tmpC2, tmpC3,\n-        tmpC4, tmp1, tmp2, tmp3, tmp4, tmp5);\n-    return entry;\n-  }\n-\n-\n@@ -8336,5 +8323,0 @@\n-    \/\/ Disabled until JDK-8210858 is fixed\n-    \/\/ if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_dlog)) {\n-    \/\/   StubRoutines::_dlog = generate_dlog();\n-    \/\/ }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -186,0 +186,3 @@\n+    if (FLAG_IS_DEFAULT(AlwaysMergeDMB)) {\n+      FLAG_SET_DEFAULT(AlwaysMergeDMB, true);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1005,1 +1005,1 @@\n-bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+bool Matcher::match_rule_supported_auto_vectorization(int opcode, int vlen, BasicType bt) {\n@@ -1077,1 +1077,1 @@\n-int Matcher::superword_max_vector_size(const BasicType bt) {\n+int Matcher::max_vector_size_auto_vectorization(const BasicType bt) {\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2176,1 +2176,1 @@\n-bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+bool Matcher::match_rule_supported_auto_vectorization(int opcode, int vlen, BasicType bt) {\n@@ -2245,1 +2245,1 @@\n-int Matcher::superword_max_vector_size(const BasicType bt) {\n+int Matcher::max_vector_size_auto_vectorization(const BasicType bt) {\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2013, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024 SAP SE. All rights reserved.\n@@ -3806,2 +3806,4 @@\n-    \/\/ Make sure klass is fully initialized and get instance_size.\n-    __ lbz(Rscratch, in_bytes(InstanceKlass::init_state_offset()), RinstanceKlass);\n+    \/\/ Make sure klass is initialized.\n+    assert(VM_Version::supports_fast_class_init_checks(), \"Optimization requires support for fast class initialization checks\");\n+    __ clinit_barrier(RinstanceKlass, R16_thread, nullptr \/*L_fast_path*\/, &Lslow_case);\n+\n@@ -3810,1 +3812,0 @@\n-    __ cmpdi(CCR1, Rscratch, InstanceKlass::fully_initialized);\n@@ -3813,3 +3814,1 @@\n-\n-    __ crnand(CCR0, Assembler::equal, CCR1, Assembler::equal); \/\/ slow path bit set or not fully initialized?\n-    __ beq(CCR0, Lslow_case);\n+    __ bne(CCR0, Lslow_case);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2020,1 +2020,1 @@\n-int Matcher::superword_max_vector_size(const BasicType bt) {\n+int Matcher::max_vector_size_auto_vectorization(const BasicType bt) {\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+  bool Matcher::match_rule_supported_auto_vectorization(int opcode, int vlen, BasicType bt) {\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3550,5 +3550,4 @@\n-  \/\/ make sure klass is initialized & doesn't have finalizer\n-  \/\/ make sure klass is fully initialized\n-  __ lbu(t0, Address(x14, InstanceKlass::init_state_offset()));\n-  __ sub(t1, t0, (u1)InstanceKlass::fully_initialized);\n-  __ bnez(t1, slow_case);\n+  \/\/ make sure klass is initialized\n+  assert(VM_Version::supports_fast_class_init_checks(),\n+         \"Optimization requires support for fast class initialization checks\");\n+  __ clinit_barrier(x14, t0, nullptr \/*L_fast_path*\/, &slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1516,1 +1516,1 @@\n-bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+bool Matcher::match_rule_supported_auto_vectorization(int opcode, int vlen, BasicType bt) {\n@@ -1577,1 +1577,1 @@\n-int Matcher::superword_max_vector_size(const BasicType bt) {\n+int Matcher::max_vector_size_auto_vectorization(const BasicType bt) {\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n@@ -3917,1 +3917,1 @@\n-  __ z_sllg(offset, offset, LogBytesPerWord); \/\/ Convert to to offset.\n+  __ z_sllg(offset, offset, LogBytesPerWord); \/\/ Convert to offset.\n@@ -3922,9 +3922,4 @@\n-  \/\/ Make sure klass is initialized & doesn't have finalizer.\n-  \/\/ Make sure klass is fully initialized.\n-  const int state_offset = in_bytes(InstanceKlass::init_state_offset());\n-  if (Immediate::is_uimm12(state_offset)) {\n-    __ z_cli(state_offset, iklass, InstanceKlass::fully_initialized);\n-  } else {\n-    __ z_cliy(state_offset, iklass, InstanceKlass::fully_initialized);\n-  }\n-  __ z_brne(slow_case);\n+  \/\/ make sure klass is initialized\n+  assert(VM_Version::supports_fast_class_init_checks(),\n+         \"Optimization requires support for fast class initialization checks\");\n+  __ clinit_barrier(iklass, Z_thread, nullptr \/*L_fast_path*\/, &slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1092,1 +1092,1 @@\n-    assert(VM_Version::supports_evex(), \"shouldn't have EVEX prefix\");\n+    assert(VM_Version::cpu_supports_evex(), \"shouldn't have EVEX prefix\");\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2571,1 +2571,3 @@\n-  if (is_simm32(src)) {\n+  if (is_uimm32(src)) {\n+    movl(dst, checked_cast<uint32_t>(src));\n+  } else if (is_simm32(src)) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -812,1 +812,2 @@\n-    _features = feature_flags();\n+    _features = feature_flags(); \/\/ These can be changed by VM settings\n+    _cpu_features = _features;   \/\/ Preserve features\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -643,1 +643,1 @@\n-  \/\/ Feature identification\n+  \/\/ Feature identification which can be affected by VM settings\n@@ -706,0 +706,5 @@\n+  \/\/\n+  \/\/ Feature identification not affected by VM flags\n+  \/\/\n+  static bool cpu_supports_evex()     { return (_cpu_features & CPU_AVX512F) != 0; }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1702,1 +1702,1 @@\n-bool Matcher::match_rule_supported_superword(int opcode, int vlen, BasicType bt) {\n+bool Matcher::match_rule_supported_auto_vectorization(int opcode, int vlen, BasicType bt) {\n@@ -2283,1 +2283,1 @@\n-int Matcher::superword_max_vector_size(const BasicType bt) {\n+int Matcher::max_vector_size_auto_vectorization(const BasicType bt) {\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1889,0 +1889,4 @@\n+size_t os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  return page_size;\n+}\n+\n@@ -3030,1 +3034,0 @@\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1640,0 +1640,4 @@\n+size_t os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  return page_size;\n+}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,3 @@\n-\n+  product(bool, UseMadvPopulateWrite, true, DIAGNOSTIC,                 \\\n+          \"Use MADV_POPULATE_WRITE in os::pd_pretouch_memory.\")         \\\n+                                                                        \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -420,1 +420,1 @@\n-  return (julong)si.totalswap;\n+  return (julong)(si.totalswap * si.mem_unit);\n@@ -2901,0 +2901,9 @@\n+\/\/ Define MADV_POPULATE_WRITE here so we can build HotSpot on old systems.\n+#define MADV_POPULATE_WRITE_value 23\n+#ifndef MADV_POPULATE_WRITE\n+  #define MADV_POPULATE_WRITE MADV_POPULATE_WRITE_value\n+#else\n+  \/\/ Sanity-check our assumed default value if we build with a new enough libc.\n+  static_assert(MADV_POPULATE_WRITE == MADV_POPULATE_WRITE_value);\n+#endif\n+\n@@ -2960,0 +2969,25 @@\n+size_t os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  const size_t len = pointer_delta(last, first, sizeof(char)) + page_size;\n+  \/\/ Use madvise to pretouch on Linux when THP is used, and fallback to the\n+  \/\/ common method if unsupported. THP can form right after madvise rather than\n+  \/\/ being assembled later.\n+  if (HugePages::thp_mode() == THPMode::always || UseTransparentHugePages) {\n+    int err = 0;\n+    if (UseMadvPopulateWrite &&\n+        ::madvise(first, len, MADV_POPULATE_WRITE) == -1) {\n+      err = errno;\n+    }\n+    if (!UseMadvPopulateWrite || err == EINVAL) { \/\/ Not to use or not supported\n+      \/\/ When using THP we need to always pre-touch using small pages as the\n+      \/\/ OS will initially always use small pages.\n+      return os::vm_page_size();\n+    } else if (err != 0) {\n+      log_info(gc, os)(\"::madvise(\" PTR_FORMAT \", \" SIZE_FORMAT \", %d) failed; \"\n+                       \"error='%s' (errno=%d)\", p2i(first), len,\n+                       MADV_POPULATE_WRITE, os::strerror(err), err);\n+    }\n+    return 0;\n+  }\n+  return page_size;\n+}\n+\n@@ -4382,0 +4416,3 @@\n+  \/\/ Check the availability of MADV_POPULATE_WRITE.\n+  FLAG_SET_DEFAULT(UseMadvPopulateWrite, (::madvise(0, 0, MADV_POPULATE_WRITE) == 0));\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -756,1 +756,1 @@\n-  return (jlong) ::lseek(fd, offset, whence);\n+  return (jlong) AIX_ONLY(::lseek64) NOT_AIX(::lseek)(fd, offset, whence);\n@@ -760,1 +760,1 @@\n-   return ::ftruncate(fd, length);\n+   return AIX_ONLY(::ftruncate64) NOT_AIX(::ftruncate)(fd, length);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2472,1 +2472,1 @@\n-  guarantee(pc[0] >= Assembler::REX && pc[0] <= Assembler::REX_WRXB && pc[1] == 0xF7 || pc[0] == 0xF7,\n+  guarantee((pc[0] >= Assembler::REX && pc[0] <= Assembler::REX_WRXB && pc[1] == 0xF7) || pc[0] == 0xF7,\n@@ -2474,1 +2474,1 @@\n-  guarantee(pc[0] >= Assembler::REX && pc[0] <= Assembler::REX_WRXB && (pc[2] & ~0x7) == 0xF8 || (pc[1] & ~0x7) == 0xF8,\n+  guarantee((pc[0] >= Assembler::REX && pc[0] <= Assembler::REX_WRXB && (pc[2] & ~0x7) == 0xF8) || (pc[1] & ~0x7) == 0xF8,\n@@ -3799,0 +3799,5 @@\n+\n+size_t os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  return page_size;\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -52,0 +52,21 @@\n+#define   RISCV_HWPROBE_EXT_ZICBOZ              (1 << 6)\n+#define   RISCV_HWPROBE_EXT_ZBC                 (1 << 7)\n+#define   RISCV_HWPROBE_EXT_ZBKB                (1 << 8)\n+#define   RISCV_HWPROBE_EXT_ZBKC                (1 << 9)\n+#define   RISCV_HWPROBE_EXT_ZBKX                (1 << 10)\n+#define   RISCV_HWPROBE_EXT_ZKND                (1 << 11)\n+#define   RISCV_HWPROBE_EXT_ZKNE                (1 << 12)\n+#define   RISCV_HWPROBE_EXT_ZKNH                (1 << 13)\n+#define   RISCV_HWPROBE_EXT_ZKSED               (1 << 14)\n+#define   RISCV_HWPROBE_EXT_ZKSH                (1 << 15)\n+#define   RISCV_HWPROBE_EXT_ZKT                 (1 << 16)\n+#define   RISCV_HWPROBE_EXT_ZVBB                (1 << 17)\n+#define   RISCV_HWPROBE_EXT_ZVBC                (1 << 18)\n+#define   RISCV_HWPROBE_EXT_ZVKB                (1 << 19)\n+#define   RISCV_HWPROBE_EXT_ZVKG                (1 << 20)\n+#define   RISCV_HWPROBE_EXT_ZVKNED              (1 << 21)\n+#define   RISCV_HWPROBE_EXT_ZVKNHA              (1 << 22)\n+#define   RISCV_HWPROBE_EXT_ZVKNHB              (1 << 23)\n+#define   RISCV_HWPROBE_EXT_ZVKSED              (1 << 24)\n+#define   RISCV_HWPROBE_EXT_ZVKSH               (1 << 25)\n+#define   RISCV_HWPROBE_EXT_ZVKT                (1 << 26)\n@@ -53,0 +74,8 @@\n+#define   RISCV_HWPROBE_EXT_ZFHMIN              (1 << 28)\n+#define   RISCV_HWPROBE_EXT_ZIHINTNTL           (1 << 29)\n+#define   RISCV_HWPROBE_EXT_ZVFH                (1 << 30)\n+#define   RISCV_HWPROBE_EXT_ZVFHMIN             (1 << 31)\n+#define   RISCV_HWPROBE_EXT_ZFA                 (1ULL << 32)\n+#define   RISCV_HWPROBE_EXT_ZTSO                (1ULL << 33)\n+#define   RISCV_HWPROBE_EXT_ZACAS               (1ULL << 34)\n+#define   RISCV_HWPROBE_EXT_ZICOND              (1ULL << 35)\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/riscv_hwprobe.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -247,0 +247,2 @@\n+  ext_Zacas.enable_feature();\n+  ext_Zicboz.enable_feature();\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -362,0 +362,1 @@\n+  static bool is_uimm32(uint64_t x) { return is_uimm(x, 32); }\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -472,3 +472,5 @@\n-  \/\/ Caution: do not use do_Op2(x) here for now since\n-  \/\/          we map the condition to the op for now!\n-  move_const_to_right(x);\n+  \/\/ Currently, Canonicalizer is only used by GraphBuilder,\n+  \/\/ and IfOp is not created by GraphBuilder but only later\n+  \/\/ when eliminating conditional expressions with CE_Eliminator,\n+  \/\/ so this method will not be called.\n+  ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"oops\/methodData.inline.hpp\"\n@@ -90,2 +91,12 @@\n-    \/\/ Holding locks through safepoints is bad practice.\n-    MutexUnlocker mu(_mdo->extra_data_lock());\n+    \/\/ We are currently holding the extra_data_lock and ensuring\n+    \/\/ no safepoint breaks the lock.\n+    _mdo->check_extra_data_locked();\n+\n+    \/\/ We now want to cache some method data. This could cause a safepoint.\n+    \/\/ We temporarily release the lock and allow safepoints, and revert that\n+    \/\/ at the end of the scope. This is safe, since we currently do not hold\n+    \/\/ any extra_method_data: finish is called only after clean_extra_data,\n+    \/\/ and the outer scope that first aquired the lock should not hold any\n+    \/\/ extra_method_data while cleaning is performed, as the offsets can change.\n+    MutexUnlocker mu(_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -126,1 +137,4 @@\n-  MutexLocker ml(mdo->extra_data_lock());\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not unintentionally broken by a safepoint\n+  MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -565,0 +579,3 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -589,0 +606,3 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1114,0 +1114,5 @@\n+    \/\/ The lambda proxy class and its nest host have the same class loader and class loader data,\n+    \/\/ as verified in SystemDictionaryShared::add_lambda_proxy_class()\n+    assert(shared_nest_host->class_loader() == class_loader(), \"mismatched class loader\");\n+    assert(shared_nest_host->class_loader_data() == class_loader_data(class_loader), \"mismatched class loader data\");\n+    ik->set_nest_host(shared_nest_host);\n@@ -1116,6 +1121,0 @@\n-  \/\/ The lambda proxy class and its nest host have the same class loader and class loader data,\n-  \/\/ as verified in SystemDictionaryShared::add_lambda_proxy_class()\n-  assert(shared_nest_host->class_loader() == class_loader(), \"mismatched class loader\");\n-  assert(shared_nest_host->class_loader_data() == class_loader_data(class_loader), \"mismatched class loader data\");\n-  ik->set_nest_host(shared_nest_host);\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"opto\/traceAutoVectorizationTag.hpp\"\n@@ -303,1 +304,2 @@\n-  _ideal_phase_name_set(PHASE_NUM_TYPES, mtCompiler)\n+  _ideal_phase_name_set(PHASE_NUM_TYPES, mtCompiler),\n+  _trace_auto_vectorization_tags(TRACE_AUTO_VECTORIZATION_TAG_NUM, mtCompiler)\n@@ -436,0 +438,10 @@\n+    if (!_modified[TraceAutoVectorizationIndex]) {\n+      \/\/ Parse ccstr and create mask\n+      ccstrlist option;\n+      if (CompilerOracle::has_option_value(method, CompileCommand::TraceAutoVectorization, option)) {\n+        TraceAutoVectorizationTagValidator validator(option, false);\n+        if (validator.is_valid()) {\n+          set.cloned()->set_trace_auto_vectorization_tags(validator.tags());\n+        }\n+      }\n+    }\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,0 @@\n-    cflags(VectorizeDebug,          uintx, 0, VectorizeDebug) \\\n@@ -94,0 +93,1 @@\n+NOT_PRODUCT(cflags(TraceAutoVectorization, ccstrlist, \"\", TraceAutoVectorization)) \\\n@@ -134,0 +134,1 @@\n+  CHeapBitMap _trace_auto_vectorization_tags;\n@@ -208,0 +209,6 @@\n+  void set_trace_auto_vectorization_tags(const CHeapBitMap& tags) {\n+    _trace_auto_vectorization_tags.set_from(tags);\n+  };\n+  const CHeapBitMap& trace_auto_vectorization_tags() {\n+    return _trace_auto_vectorization_tags;\n+  };\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+#include \"opto\/traceAutoVectorizationTag.hpp\"\n@@ -778,2 +779,8 @@\n-#ifndef PRODUCT\n-      else if (option == CompileCommand::PrintIdealPhase) {\n+#if !defined(PRODUCT) && defined(COMPILER2)\n+      else if (option == CompileCommand::TraceAutoVectorization) {\n+        TraceAutoVectorizationTagValidator validator(value, true);\n+\n+        if (!validator.is_valid()) {\n+          jio_snprintf(errorbuf, buf_size, \"Unrecognized tag name in %s: %s\", option2name(option), validator.what());\n+        }\n+      } else if (option == CompileCommand::PrintIdealPhase) {\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,1 @@\n+NOT_PRODUCT(option(TraceAutoVectorization, \"TraceAutoVectorization\", Ccstrlist)) \\\n@@ -90,1 +91,0 @@\n-  option(VectorizeDebug, \"VectorizeDebug\", Uintx) \\\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"opto\/traceAutoVectorizationTag.hpp\"\n@@ -338,0 +339,11 @@\n+        }\n+#if !defined(PRODUCT) && defined(COMPILER2)\n+        else if (strncmp(option_key->name, \"TraceAutoVectorization\", 22) == 0) {\n+          TraceAutoVectorizationTagValidator validator(s, false);\n+\n+          valid = validator.is_valid();\n+          if (valid) {\n+            set->set_trace_auto_vectorization_tags(validator.tags());\n+          } else {\n+            error(VALUE_ERROR, \"Unrecognized tag name detected in TraceAutoVectorization: %s\", validator.what());\n+          }\n@@ -348,0 +360,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/compiler\/directivesParser.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1RegionPinCache.inline.hpp\"\n@@ -174,0 +175,4 @@\n+  {\n+    G1RegionPinCache& cache = G1ThreadLocalData::pin_count_cache(thread);\n+    cache.flush();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+#include \"gc\/g1\/g1RegionPinCache.inline.hpp\"\n@@ -2474,0 +2475,6 @@\n+void G1CollectedHeap::flush_region_pin_cache() {\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {\n+    G1ThreadLocalData::pin_count_cache(thread).flush();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -778,0 +778,4 @@\n+  \/\/ Update all region's pin counts from the per-thread caches and resets them.\n+  \/\/ Must be called before any decision based on pin counts.\n+  void flush_region_pin_cache();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"gc\/g1\/g1RegionPinCache.inline.hpp\"\n@@ -269,2 +270,3 @@\n-  HeapRegion *r = heap_region_containing(obj);\n-  r->increment_pinned_object_count();\n+\n+  uint obj_region_idx = heap_region_containing(obj)->hrm_index();\n+  G1ThreadLocalData::pin_count_cache(thread).inc_count(obj_region_idx);\n@@ -276,2 +278,3 @@\n-  HeapRegion *r = heap_region_containing(obj);\n-  r->decrement_pinned_object_count();\n+\n+  uint obj_region_idx = heap_region_containing(obj)->hrm_index();\n+  G1ThreadLocalData::pin_count_cache(thread).dec_count(obj_region_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,0 +194,1 @@\n+  _heap->flush_region_pin_cache();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1REGIONPINCACHE_HPP\n+#define SHARE_GC_G1_G1REGIONPINCACHE_HPP\n+\n+#include \"gc\/g1\/heapRegion.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Holds (caches) the pending pinned object count adjustment for the region\n+\/\/ _region_idx on a per thread basis.\n+\/\/ Keeping such a cache avoids the expensive atomic operations when updating the\n+\/\/ pin count for the very common case that the application pins and unpins the\n+\/\/ same object without any interleaving by a garbage collection or pinning\/unpinning\n+\/\/ to an object in another region.\n+class G1RegionPinCache : public StackObj {\n+  uint _region_idx;\n+  size_t _count;\n+\n+  void flush_and_set(uint new_region_idx, size_t new_count);\n+\n+public:\n+  G1RegionPinCache() : _region_idx(G1_NO_HRM_INDEX), _count(0) { }\n+\n+#ifdef ASSERT\n+  size_t count() const { return _count; }\n+#endif\n+\n+  void inc_count(uint region_idx);\n+  void dec_count(uint region_idx);\n+\n+  void flush();\n+};\n+\n+#endif \/* SHARE_GC_G1_G1REGIONPINCACHE_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionPinCache.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1REGIONPINCACHE_INLINE_HPP\n+#define SHARE_GC_G1_G1REGIONPINCACHE_INLINE_HPP\n+\n+#include \"gc\/g1\/g1RegionPinCache.hpp\"\n+\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+\n+inline void G1RegionPinCache::inc_count(uint region_idx) {\n+  if (region_idx == _region_idx) {\n+    ++_count;\n+  } else {\n+    flush_and_set(region_idx, (size_t)1);\n+  }\n+}\n+\n+inline void G1RegionPinCache::dec_count(uint region_idx) {\n+  if (region_idx == _region_idx) {\n+    --_count;\n+  } else {\n+    flush_and_set(region_idx, ~(size_t)0);\n+  }\n+}\n+\n+inline void G1RegionPinCache::flush_and_set(uint new_region_idx, size_t new_count) {\n+  if (_count != 0) {\n+    G1CollectedHeap::heap()->region_at(_region_idx)->add_pinned_object_count(_count);\n+  }\n+  _region_idx = new_region_idx;\n+  _count = new_count;\n+}\n+\n+inline void G1RegionPinCache::flush() {\n+  flush_and_set(G1_NO_HRM_INDEX, 0);\n+}\n+\n+#endif \/* SHARE_GC_G1_G1REGIONPINCACHE_INLINE_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionPinCache.inline.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1RegionPinCache.hpp\"\n@@ -40,0 +41,5 @@\n+  \/\/ Per-thread cache of pinned object count to reduce atomic operation traffic\n+  \/\/ due to region pinning. Holds the last region where the mutator pinned an\n+  \/\/ object and the number of pin operations since the last change of the region.\n+  G1RegionPinCache _pin_cache;\n+\n@@ -42,1 +48,2 @@\n-      _dirty_card_queue(&G1BarrierSet::dirty_card_queue_set()) {}\n+      _dirty_card_queue(&G1BarrierSet::dirty_card_queue_set()),\n+      _pin_cache() {}\n@@ -93,0 +100,4 @@\n+\n+  static G1RegionPinCache& pin_count_cache(Thread* thread) {\n+    return data(thread)->_pin_cache;\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ThreadLocalData.hpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"gc\/g1\/g1RegionPinCache.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+#include \"gc\/g1\/g1RegionPinCache.inline.hpp\"\n+#include \"gc\/g1\/g1ThreadLocalData.hpp\"\n@@ -60,0 +62,1 @@\n+      \/\/ Retire TLABs.\n@@ -63,1 +66,1 @@\n-\n+      \/\/ Concatenate logs.\n@@ -66,0 +69,2 @@\n+      \/\/ Flush region pin count cache.\n+      G1ThreadLocalData::pin_count_cache(thread).flush();\n@@ -135,0 +140,2 @@\n+\n+      assert(G1ThreadLocalData::pin_count_cache(thread).count() == 0, \"NonJava thread has pinned Java objects\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPreEvacuateTasks.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -305,2 +305,3 @@\n-  inline void increment_pinned_object_count();\n-  inline void decrement_pinned_object_count();\n+  \/\/ Atomically adjust the pinned object count by the given value. Value must not\n+  \/\/ be zero.\n+  inline void add_pinned_object_count(size_t value);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -556,6 +556,4 @@\n-inline void HeapRegion::increment_pinned_object_count() {\n-  Atomic::add(&_pinned_object_count, (size_t)1, memory_order_relaxed);\n-}\n-\n-inline void HeapRegion::decrement_pinned_object_count() {\n-  Atomic::sub(&_pinned_object_count, (size_t)1, memory_order_relaxed);\n+inline void HeapRegion::add_pinned_object_count(size_t value) {\n+  assert(value != 0, \"wasted effort\");\n+  assert(!is_free(), \"trying to pin free region %u, adding %zu\", hrm_index(), value);\n+  Atomic::add(&_pinned_object_count, value, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -105,1 +105,0 @@\n-  double max_gc_minor_pause_sec = ((double) MaxGCMinorPauseMillis)\/1000.0;\n@@ -116,1 +115,0 @@\n-                             max_gc_minor_pause_sec,\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-                                           double gc_minor_pause_goal_sec,\n@@ -58,1 +57,0 @@\n-     _gc_minor_pause_goal_sec(gc_minor_pause_goal_sec),\n@@ -285,1 +283,1 @@\n-  } else if (_avg_minor_pause->padded_average() > gc_minor_pause_goal_sec()) {\n+  } else if (_avg_minor_pause->padded_average() > gc_pause_goal_sec()) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,2 +94,0 @@\n-  const double _gc_minor_pause_goal_sec;    \/\/ goal for maximum minor gc pause\n-\n@@ -116,3 +114,0 @@\n-  \/\/ Accessors\n-  double gc_minor_pause_goal_sec() const { return _gc_minor_pause_goal_sec; }\n-\n@@ -190,1 +185,0 @@\n-                       double gc_minor_pause_goal_sec,\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/serial\/tenuredGeneration.hpp\"\n@@ -57,3 +58,2 @@\n-void CardTableRS::maintain_old_to_young_invariant(Generation* old_gen, bool is_young_gen_empty) {\n-  assert(SerialHeap::heap()->is_old_gen(old_gen), \"precondition\");\n-\n+void CardTableRS::maintain_old_to_young_invariant(TenuredGeneration* old_gen,\n+                                                  bool is_young_gen_empty) {\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-class Generation;\n@@ -34,0 +33,1 @@\n+class TenuredGeneration;\n@@ -83,1 +83,1 @@\n-  void maintain_old_to_young_invariant(Generation* old_gen, bool is_young_gen_empty);\n+  void maintain_old_to_young_invariant(TenuredGeneration* old_gen, bool is_young_gen_empty);\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -652,0 +652,6 @@\n+bool DefNewGeneration::is_in(const void* p) const {\n+  return eden()->is_in(p)\n+      || from()->is_in(p)\n+      || to()  ->is_in(p);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -177,0 +177,9 @@\n+\n+  \/\/ Returns \"TRUE\" iff \"p\" points into the used areas in each space of young-gen.\n+  bool is_in(const void* p) const;\n+\n+  \/\/ Return an estimate of the maximum allocation that could be performed\n+  \/\/ in the generation without triggering any collection or expansion\n+  \/\/ activity.  It is \"unsafe\" because no locks are taken; the result\n+  \/\/ should be treated as an approximation, not a guarantee, for use in\n+  \/\/ heuristic resizing decisions.\n@@ -178,0 +187,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -86,20 +86,0 @@\n-\/\/ Utility iterator classes\n-\n-class GenerationIsInClosure : public SpaceClosure {\n- public:\n-  const void* _p;\n-  Space* sp;\n-  virtual void do_space(Space* s) {\n-    if (sp == nullptr) {\n-      if (s->is_in(_p)) sp = s;\n-    }\n-  }\n-  GenerationIsInClosure(const void* p) : _p(p), sp(nullptr) {}\n-};\n-\n-bool Generation::is_in(const void* p) const {\n-  GenerationIsInClosure blk(p);\n-  ((Generation*)this)->space_iterate(&blk);\n-  return blk.sp != nullptr;\n-}\n-\n@@ -167,19 +147,0 @@\n-\n-class GenerationBlockIsObjClosure : public SpaceClosure {\n- public:\n-  const HeapWord* _p;\n-  bool is_obj;\n-  virtual void do_space(Space* s) {\n-    if (!is_obj && s->is_in_reserved(_p)) {\n-      is_obj |= s->block_is_obj(_p);\n-    }\n-  }\n-  GenerationBlockIsObjClosure(const HeapWord* p) { _p = p; is_obj = false; }\n-};\n-\n-bool Generation::block_is_obj(const HeapWord* p) const {\n-  GenerationBlockIsObjClosure blk(p);\n-  \/\/ Cast away const\n-  ((Generation*)this)->space_iterate(&blk);\n-  return blk.is_obj;\n-}\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -111,7 +111,0 @@\n-  \/\/ Return an estimate of the maximum allocation that could be performed\n-  \/\/ in the generation without triggering any collection or expansion\n-  \/\/ activity.  It is \"unsafe\" because no locks are taken; the result\n-  \/\/ should be treated as an approximation, not a guarantee, for use in\n-  \/\/ heuristic resizing decisions.\n-  virtual size_t unsafe_max_alloc_nogc() const = 0;\n-\n@@ -133,7 +126,0 @@\n-  \/\/ Returns \"TRUE\" iff \"p\" points into the committed areas in the generation.\n-  \/\/ For some kinds of generations, this may be an expensive operation.\n-  \/\/ To avoid performance problems stemming from its inadvertent use in\n-  \/\/ product jvm's, we restrict its use to assertion checking or\n-  \/\/ verification only.\n-  virtual bool is_in(const void* p) const;\n-\n@@ -237,4 +223,0 @@\n-  \/\/ Requires \"addr\" to be the start of a block, and returns \"TRUE\" iff\n-  \/\/ the block is an object.\n-  virtual bool block_is_obj(const HeapWord* addr) const;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -927,0 +927,1 @@\n+\n@@ -928,1 +929,3 @@\n-    return _young_gen->block_is_obj(addr);\n+    return _young_gen->eden()->is_in(addr)\n+        || _young_gen->from()->is_in(addr)\n+        || _young_gen->to()  ->is_in(addr);\n@@ -931,2 +934,2 @@\n-  assert(_old_gen->is_in_reserved(addr), \"Some generation should contain the address\");\n-  return _old_gen->block_is_obj(addr);\n+  assert(_old_gen->is_in_reserved(addr), \"must be in old-gen\");\n+  return addr < _old_gen->space()->top();\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -453,4 +453,0 @@\n-size_t TenuredGeneration::unsafe_max_alloc_nogc() const {\n-  return _the_space->free();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,1 +114,0 @@\n-  size_t unsafe_max_alloc_nogc() const;\n@@ -132,2 +131,0 @@\n-  inline bool block_is_obj(const HeapWord* addr) const;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,4 +64,0 @@\n-bool TenuredGeneration::block_is_obj(const HeapWord* addr) const {\n-  return addr < _the_space  ->top();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,17 +312,0 @@\n-  product(uintx, MaxRAMFraction, 4,                                         \\\n-          \"Maximum fraction (1\/n) of real memory used for maximum heap \"    \\\n-          \"size. \"                                                          \\\n-          \"Deprecated, use MaxRAMPercentage instead\")                       \\\n-          range(1, max_uintx)                                               \\\n-                                                                            \\\n-  product(uintx, MinRAMFraction, 2,                                         \\\n-          \"Minimum fraction (1\/n) of real memory used for maximum heap \"    \\\n-          \"size on systems with small physical memory size. \"               \\\n-          \"Deprecated, use MinRAMPercentage instead\")                       \\\n-          range(1, max_uintx)                                               \\\n-                                                                            \\\n-  product(uintx, InitialRAMFraction, 64,                                    \\\n-          \"Fraction (1\/n) of real memory used for initial heap size. \"      \\\n-          \"Deprecated, use InitialRAMPercentage instead\")                   \\\n-          range(1, max_uintx)                                               \\\n-                                                                            \\\n@@ -445,5 +428,0 @@\n-  product(uintx, MaxGCMinorPauseMillis, max_uintx,                          \\\n-          \"Adaptive size policy maximum GC minor pause time goal \"          \\\n-          \"in millisecond\")                                                 \\\n-          range(0, max_uintx)                                               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -71,6 +71,0 @@\n-#ifdef LINUX\n-  \/\/ When using THP we need to always pre-touch using small pages as the OS will\n-  \/\/ initially always use small pages.\n-  page_size = UseTransparentHugePages ? (size_t)os::vm_page_size() : page_size;\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-    \/\/ This control loop iteration have seen this much allocations.\n+    \/\/ This control loop iteration has seen this much allocation.\n@@ -111,1 +111,1 @@\n-    const bool soft_max_changed = check_soft_max_changed();\n+    const bool soft_max_changed = heap->check_soft_max_changed();\n@@ -365,1 +365,1 @@\n-      service_uncommit(shrink_before, shrink_until);\n+      heap->maybe_uncommit(shrink_before, shrink_until);\n@@ -591,19 +591,0 @@\n-bool ShenandoahControlThread::check_soft_max_changed() const {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  size_t new_soft_max = Atomic::load(&SoftMaxHeapSize);\n-  size_t old_soft_max = heap->soft_max_capacity();\n-  if (new_soft_max != old_soft_max) {\n-    new_soft_max = MAX2(heap->min_capacity(), new_soft_max);\n-    new_soft_max = MIN2(heap->max_capacity(), new_soft_max);\n-    if (new_soft_max != old_soft_max) {\n-      log_info(gc)(\"Soft Max Heap Size: \" SIZE_FORMAT \"%s -> \" SIZE_FORMAT \"%s\",\n-                   byte_size_in_proper_unit(old_soft_max), proper_unit_for_byte_size(old_soft_max),\n-                   byte_size_in_proper_unit(new_soft_max), proper_unit_for_byte_size(new_soft_max)\n-      );\n-      heap->set_soft_max_capacity(new_soft_max);\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n@@ -783,23 +764,0 @@\n-void ShenandoahControlThread::service_uncommit(double shrink_before, size_t shrink_until) {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  \/\/ Determine if there is work to do. This avoids taking heap lock if there is\n-  \/\/ no work available, avoids spamming logs with superfluous logging messages,\n-  \/\/ and minimises the amount of work while locks are taken.\n-\n-  if (heap->committed() <= shrink_until) return;\n-\n-  bool has_work = false;\n-  for (size_t i = 0; i < heap->num_regions(); i++) {\n-    ShenandoahHeapRegion *r = heap->get_region(i);\n-    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n-      has_work = true;\n-      break;\n-    }\n-  }\n-\n-  if (has_work) {\n-    heap->entry_uncommit(shrink_before, shrink_until);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":3,"deletions":45,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-  void service_uncommit(double shrink_before, size_t shrink_until);\n@@ -118,3 +117,0 @@\n-  \/\/ Returns true if the soft maximum heap has been changed using management APIs.\n-  bool check_soft_max_changed() const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -884,0 +884,27 @@\n+void ShenandoahHeap::maybe_uncommit(double shrink_before, size_t shrink_until) {\n+  assert (ShenandoahUncommit, \"should be enabled\");\n+\n+  \/\/ Determine if there is work to do. This avoids taking heap lock if there is\n+  \/\/ no work available, avoids spamming logs with superfluous logging messages,\n+  \/\/ and minimises the amount of work while locks are taken.\n+\n+  if (committed() <= shrink_until) return;\n+\n+  bool has_work = false;\n+  for (size_t i = 0; i < num_regions(); i++) {\n+    ShenandoahHeapRegion* r = get_region(i);\n+    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n+      has_work = true;\n+      break;\n+    }\n+  }\n+\n+  if (has_work) {\n+    static const char* msg = \"Concurrent uncommit\";\n+    ShenandoahConcurrentPhase gcPhase(msg, ShenandoahPhaseTimings::conc_uncommit, true \/* log_heap_usage *\/);\n+    EventMark em(\"%s\", msg);\n+\n+    op_uncommit(shrink_before, shrink_until);\n+  }\n+}\n+\n@@ -914,0 +941,18 @@\n+bool ShenandoahHeap::check_soft_max_changed() {\n+  size_t new_soft_max = Atomic::load(&SoftMaxHeapSize);\n+  size_t old_soft_max = soft_max_capacity();\n+  if (new_soft_max != old_soft_max) {\n+    new_soft_max = MAX2(min_capacity(), new_soft_max);\n+    new_soft_max = MIN2(max_capacity(), new_soft_max);\n+    if (new_soft_max != old_soft_max) {\n+      log_info(gc)(\"Soft Max Heap Size: \" SIZE_FORMAT \"%s -> \" SIZE_FORMAT \"%s\",\n+                   byte_size_in_proper_unit(old_soft_max), proper_unit_for_byte_size(old_soft_max),\n+                   byte_size_in_proper_unit(new_soft_max), proper_unit_for_byte_size(new_soft_max)\n+      );\n+      set_soft_max_capacity(new_soft_max);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -3278,8 +3323,0 @@\n-void ShenandoahHeap::entry_uncommit(double shrink_before, size_t shrink_until) {\n-  static const char *msg = \"Concurrent uncommit\";\n-  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_uncommit, true \/* log_heap_usage *\/);\n-  EventMark em(\"%s\", msg);\n-\n-  op_uncommit(shrink_before, shrink_until);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":45,"deletions":8,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -511,2 +511,3 @@\n-  \/\/ Elastic heap support\n-  void entry_uncommit(double shrink_before, size_t shrink_until);\n+  \/\/ These will uncommit empty regions if heap::committed > shrink_until\n+  \/\/ and there exists at least one region which was made empty before shrink_before.\n+  void maybe_uncommit(double shrink_before, size_t shrink_until);\n@@ -515,0 +516,3 @@\n+  \/\/ Returns true if the soft maximum heap has been changed using management APIs.\n+  bool check_soft_max_changed();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-      !FLAG_IS_CMDLINE(MaxRAMFraction) &&\n","filename":"src\/hotspot\/share\/gc\/z\/zArguments.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -595,0 +595,4 @@\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -550,1 +550,6 @@\n-    ProfileData* pdata = h_method->method_data()->allocate_bci_to_data(current_bci, nullptr);\n+    MethodData* mdo = h_method->method_data();\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n+    ProfileData* pdata = mdo->allocate_bci_to_data(current_bci, nullptr);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -59,0 +59,4 @@\n+\n+  \/\/ Lock to access ProfileData, and ensure lock is not broken by a safepoint\n+  MutexLocker ml(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrMethodData.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1892,1 +1892,4 @@\n-  MutexLocker mu(mdo->extra_data_lock());\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+  MutexLocker mu(mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2534,1 +2534,0 @@\n-      ConditionalMutexLocker ml(mdo->extra_data_lock(), !SafepointSynchronize::is_at_safepoint());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1221,1 +1221,1 @@\n-    _extra_data_lock(Mutex::safepoint-2, \"MDOExtraData_lock\"),\n+    _extra_data_lock(Mutex::nosafepoint, \"MDOExtraData_lock\"),\n@@ -1382,0 +1382,2 @@\n+  check_extra_data_locked();\n+\n@@ -1432,1 +1434,3 @@\n-ProfileData* MethodData::bci_to_extra_data_helper(int bci, Method* m, DataLayout*& dp, bool concurrent) {\n+ProfileData* MethodData::bci_to_extra_data_find(int bci, Method* m, DataLayout*& dp) {\n+  check_extra_data_locked();\n+\n@@ -1453,3 +1457,0 @@\n-        \/\/ data->method() may be null in case of a concurrent\n-        \/\/ allocation. Maybe it's for the same method. Try to use that\n-        \/\/ entry in that case.\n@@ -1457,4 +1458,2 @@\n-          if (data->method() == nullptr) {\n-            assert(concurrent, \"impossible because no concurrent allocation\");\n-            return nullptr;\n-          } else if (data->method() == m) {\n+          assert(data->method() != nullptr, \"method must be set\");\n+          if (data->method() == m) {\n@@ -1476,0 +1475,2 @@\n+  check_extra_data_locked();\n+\n@@ -1489,5 +1490,3 @@\n-  \/\/ Allocation in the extra data space has to be atomic because not\n-  \/\/ all entries have the same size and non atomic concurrent\n-  \/\/ allocation would result in a corrupted extra data space.\n-  ProfileData* result = bci_to_extra_data_helper(bci, m, dp, true);\n-  if (result != nullptr) {\n+  \/\/ Find if already exists\n+  ProfileData* result = bci_to_extra_data_find(bci, m, dp);\n+  if (result != nullptr || dp >= end) {\n@@ -1497,9 +1496,2 @@\n-  if (create_if_missing && dp < end) {\n-    MutexLocker ml(&_extra_data_lock);\n-    \/\/ Check again now that we have the lock. Another thread may\n-    \/\/ have added extra data entries.\n-    ProfileData* result = bci_to_extra_data_helper(bci, m, dp, false);\n-    if (result != nullptr || dp >= end) {\n-      return result;\n-    }\n-\n+  if (create_if_missing) {\n+    \/\/ Not found -> Allocate\n@@ -1732,0 +1724,2 @@\n+  check_extra_data_locked();\n+\n@@ -1773,0 +1767,2 @@\n+  check_extra_data_locked();\n+\n@@ -1817,0 +1813,2 @@\n+  check_extra_data_locked();\n+\n@@ -1854,0 +1852,4 @@\n+\n+  \/\/ Lock to modify extra data, and prevent Safepoint from breaking the lock\n+  MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -1863,0 +1865,4 @@\n+\n+  \/\/ Lock to modify extra data, and prevent Safepoint from breaking the lock\n+  MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -1876,0 +1882,13 @@\n+\n+#ifdef ASSERT\n+void MethodData::check_extra_data_locked() const {\n+    \/\/ Cast const away, just to be able to verify the lock\n+    \/\/ Usually we only want non-const accesses on the lock,\n+    \/\/ so this here is an exception.\n+    MethodData* self = (MethodData*)this;\n+    assert(self->extra_data_lock()->owned_by_self(), \"must have lock\");\n+    assert(!Thread::current()->is_Java_thread() ||\n+           JavaThread::current()->is_in_no_safepoint_scope(),\n+           \"JavaThread must have NoSafepointVerifier inside lock scope\");\n+}\n+#endif\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":43,"deletions":24,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2171,1 +2171,1 @@\n-  ProfileData* bci_to_extra_data_helper(int bci, Method* m, DataLayout*& dp, bool concurrent);\n+  ProfileData* bci_to_extra_data_find(int bci, Method* m, DataLayout*& dp);\n@@ -2313,5 +2313,1 @@\n-  uint arg_modified(int a)                       { ArgInfoData *aid = arg_info();\n-                                                   assert(aid != nullptr, \"arg_info must be not null\");\n-                                                   assert(a >= 0 && a < aid->number_of_args(), \"valid argument number\");\n-                                                   return aid->arg_modified(a); }\n-\n+  uint arg_modified(int a);\n@@ -2322,5 +2318,1 @@\n-  void set_arg_modified(int a, uint v)           { ArgInfoData *aid = arg_info();\n-                                                   assert(aid != nullptr, \"arg_info must be not null\");\n-                                                   assert(a >= 0 && a < aid->number_of_args(), \"valid argument number\");\n-                                                   aid->set_arg_modified(a, v); }\n-\n+  void set_arg_modified(int a, uint v);\n@@ -2374,0 +2366,2 @@\n+    check_extra_data_locked();\n+\n@@ -2400,1 +2394,4 @@\n-  DataLayout* extra_data_base() const  { return limit_data_position(); }\n+  DataLayout* extra_data_base() const  {\n+    check_extra_data_locked();\n+    return limit_data_position();\n+  }\n@@ -2415,1 +2412,1 @@\n-  int extra_data_size() const          { return (int)((address)extra_data_limit() - (address)extra_data_base()); }\n+  int extra_data_size() const          { return (int)((address)extra_data_limit() - (address)limit_data_position()); }\n@@ -2532,0 +2529,1 @@\n+  void check_extra_data_locked() const NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -56,0 +57,18 @@\n+inline uint MethodData::arg_modified(int a) {\n+  \/\/ Lock and avoid breaking lock with Safepoint\n+  MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+  ArgInfoData* aid = arg_info();\n+  assert(aid != nullptr, \"arg_info must be not null\");\n+  assert(a >= 0 && a < aid->number_of_args(), \"valid argument number\");\n+  return aid->arg_modified(a);\n+}\n+\n+inline void MethodData::set_arg_modified(int a, uint v) {\n+  \/\/ Lock and avoid breaking lock with Safepoint\n+  MutexLocker ml(extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+  ArgInfoData* aid = arg_info();\n+  assert(aid != nullptr, \"arg_info must be not null\");\n+  assert(a >= 0 && a < aid->number_of_args(), \"valid argument number\");\n+  aid->set_arg_modified(a, v);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.inline.hpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,11 +78,0 @@\n-\/\/ Convert OopHandle to oop*\n-\n-template<>\n-struct PrimitiveConversions::Translate<OopHandle> : public std::true_type {\n-  typedef OopHandle Value;\n-  typedef oop* Decayed;\n-\n-  static Decayed decay(Value x) { return x.ptr_raw(); }\n-  static Value recover(Decayed x) { return OopHandle(x); }\n-};\n-\n","filename":"src\/hotspot\/share\/oops\/oopHandle.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -342,3 +342,0 @@\n-  develop(bool, SuperWordRTDepCheck, false,                                 \\\n-          \"Enable runtime dependency checks.\")                              \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -3471,1 +3471,4 @@\n-  Node* box = _gvn.transform(new BoxLockNode(next_monitor()));\n+  Node* box = new BoxLockNode(next_monitor());\n+  \/\/ Check for bailout after new BoxLockNode\n+  if (failing()) { return nullptr; }\n+  box = _gvn.transform(box);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,4 @@\n+  if (!RegMask::can_represent(reg, Compile::current()->sync_stack_slots())) {\n+    Compile::current()->record_method_not_compilable(\"must be able to represent all monitor slots in reg mask\");\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -334,1 +334,1 @@\n-  static bool match_rule_supported_superword(int opcode, int vlen, BasicType bt);\n+  static bool match_rule_supported_auto_vectorization(int opcode, int vlen, BasicType bt);\n@@ -358,1 +358,1 @@\n-  static int superword_max_vector_size(const BasicType bt);\n+  static int max_vector_size_auto_vectorization(const BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -567,1 +567,0 @@\n-  bool    seems_stable_comparison() const;\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,1 +227,4 @@\n-    Node *box = _gvn.transform(new BoxLockNode(next_monitor()));\n+    Node *box = new BoxLockNode(next_monitor());\n+    \/\/ Check for bailout after new BoxLockNode\n+    if (failing()) { return; }\n+    box = _gvn.transform(box);\n@@ -1263,0 +1266,2 @@\n+    \/\/ Check for bailout in shared_lock\n+    if (failing()) { return; }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1357,15 +1357,0 @@\n-\/\/ True if the comparison seems to be the kind that will not change its\n-\/\/ statistics from true to false.  See comments in adjust_map_after_if.\n-\/\/ This question is only asked along paths which are already\n-\/\/ classified as untaken (by seems_never_taken), so really,\n-\/\/ if a path is never taken, its controlling comparison is\n-\/\/ already acting in a stable fashion.  If the comparison\n-\/\/ seems stable, we will put an expensive uncommon trap\n-\/\/ on the untaken path.\n-bool Parse::seems_stable_comparison() const {\n-  if (C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if)) {\n-    return false;\n-  }\n-  return true;\n-}\n-\n@@ -1575,1 +1560,2 @@\n-  return (seems_never_taken(prob) && seems_stable_comparison());\n+  return seems_never_taken(prob) &&\n+         !C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);\n@@ -2781,0 +2767,1 @@\n+  if (failing()) { return; }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -142,41 +143,0 @@\n-class PhaseNameIter {\n- private:\n-  char* _token;\n-  char* _saved_ptr;\n-  char* _list;\n-\n- public:\n-  PhaseNameIter(ccstrlist option) {\n-    _list = (char*) canonicalize(option);\n-    _saved_ptr = _list;\n-    _token = strtok_r(_saved_ptr, \",\", &_saved_ptr);\n-  }\n-\n-  ~PhaseNameIter() {\n-    FREE_C_HEAP_ARRAY(char, _list);\n-  }\n-\n-  const char* operator*() const { return _token; }\n-\n-  PhaseNameIter& operator++() {\n-    _token = strtok_r(nullptr, \",\", &_saved_ptr);\n-    return *this;\n-  }\n-\n-  ccstrlist canonicalize(ccstrlist option_value) {\n-    char* canonicalized_list = NEW_C_HEAP_ARRAY(char, strlen(option_value) + 1, mtCompiler);\n-    int i = 0;\n-    char current;\n-    while ((current = option_value[i]) != '\\0') {\n-      if (current == '\\n' || current == ' ') {\n-        canonicalized_list[i] = ',';\n-      } else {\n-        canonicalized_list[i] = current;\n-      }\n-      i++;\n-    }\n-    canonicalized_list[i] = '\\0';\n-    return canonicalized_list;\n-  }\n-};\n-\n@@ -195,1 +155,1 @@\n-    for (PhaseNameIter iter(option); *iter != nullptr && _valid; ++iter) {\n+    for (StringUtils::CommaSeparatedStringIterator iter(option); *iter != nullptr && _valid; ++iter) {\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":3,"deletions":43,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -362,5 +363,4 @@\n-  static bool can_represent(OptoReg::Name reg) {\n-    \/\/ NOTE: -1 in computation reflects the usage of the last\n-    \/\/       bit of the regmask as an infinite stack flag and\n-    \/\/       -7 is to keep mask aligned for largest value (VecZ).\n-    return (int)reg < (int)(CHUNK_SIZE - 1);\n+  static bool can_represent(OptoReg::Name reg, unsigned int size = 1) {\n+    \/\/ NOTE: MAX2(1U,size) in computation reflects the usage of the last\n+    \/\/       bit of the regmask as an infinite stack flag.\n+    return (int)reg < (int)(CHUNK_SIZE - MAX2(1U,size));\n@@ -369,1 +369,1 @@\n-    \/\/ NOTE: -SlotsPerVecZ in computation reflects the need\n+    \/\/ NOTE: SlotsPerVecZ in computation reflects the need\n@@ -371,1 +371,1 @@\n-    return (int)reg < (int)(CHUNK_SIZE - SlotsPerVecZ);\n+    return can_represent(reg, SlotsPerVecZ);\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-  _disjoint_ptrs(arena(), 8,  0, OrderedPair::initial),     \/\/ runtime disambiguated pointer pairs\n@@ -61,3 +60,0 @@\n-  _visited(arena()),                                        \/\/ visited node set\n-  _post_visited(arena()),                                   \/\/ post visited node set\n-  _n_idx_list(arena(), 8),                                  \/\/ scratch list of (node,index) pairs\n@@ -65,1 +61,0 @@\n-  _stk(arena(), 8, 0, nullptr),                             \/\/ scratch stack of nodes\n@@ -77,7 +72,0 @@\n-#ifndef PRODUCT\n-  _vector_loop_debug = 0;\n-  if (_phase->C->method() != nullptr) {\n-    _vector_loop_debug = phase->C->directive()->VectorizeDebugOption;\n-  }\n-\n-#endif\n@@ -123,1 +111,1 @@\n-      if (TraceSuperWord) {\n+      if (is_trace_superword_precondition()) {\n@@ -185,1 +173,1 @@\n-  int max_vector = Matcher::superword_max_vector_size(T_BYTE);\n+  int max_vector = Matcher::max_vector_size_auto_vectorization(T_BYTE);\n@@ -192,1 +180,0 @@\n-      is_marked_reduction(n) ||\n@@ -299,1 +286,1 @@\n-      int cur_max_vector = Matcher::superword_max_vector_size(bt);\n+      int cur_max_vector = Matcher::max_vector_size_auto_vectorization(bt);\n@@ -305,0 +292,1 @@\n+#ifndef PRODUCT\n@@ -308,0 +296,1 @@\n+#endif\n@@ -354,0 +343,5 @@\n+#ifndef PRODUCT\n+      if (TraceSuperWordLoopUnrollAnalysis) {\n+        tty->print_cr(\"slp analysis: set max unroll to %d\", local_loop_unroll_factor);\n+      }\n+#endif\n@@ -527,13 +521,0 @@\n-\n-#ifndef PRODUCT\n-  if (_do_vector_loop && TraceSuperWord) {\n-    tty->print(\"SuperWord::SLP_extract\\n\");\n-    tty->print(\"input loop\\n\");\n-    _lpt->dump_head();\n-    _lpt->dump();\n-    for (uint i = 0; i < _lpt->_body.size(); i++) {\n-      _lpt->_body.at(i)->dump();\n-    }\n-  }\n-#endif\n-\n@@ -548,1 +529,1 @@\n-  \/\/ build _dg, _disjoint_ptrs\n+  \/\/ build _dg\n@@ -562,1 +543,1 @@\n-    if (TraceSuperWord) {\n+    if (is_trace_superword_any()) {\n@@ -605,1 +586,2 @@\n-  if (TraceSuperWord) {\n+#ifndef PRODUCT\n+  if (is_trace_superword_adjacent_memops()) {\n@@ -608,0 +590,1 @@\n+#endif\n@@ -675,2 +658,2 @@\n-  if (TraceSuperWord) {\n-    tty->print_cr(\"\\nAfter find_adjacent_refs\");\n+  if (is_trace_superword_packset()) {\n+    tty->print_cr(\"\\nAfter Superword::find_adjacent_refs\");\n@@ -758,2 +741,2 @@\n-#ifdef ASSERT\n-  if (TraceSuperWord && Verbose) {\n+#ifndef PRODUCT\n+  if (is_trace_superword_verbose()) {\n@@ -770,3 +753,3 @@\n-#ifdef ASSERT\n-    if (TraceSuperWord) {\n-      tty->print(\"\\nVector align to node: \");\n+#ifndef PRODUCT\n+    if (is_trace_superword_adjacent_memops()) {\n+      tty->print(\"SuperWord::find_align_to_ref: \");\n@@ -797,1 +780,1 @@\n-      vw = MIN2(Matcher::superword_max_vector_size(btype)*type2aelembytes(btype), vw * 2);\n+      vw = MIN2(Matcher::max_vector_size_auto_vectorization(btype)*type2aelembytes(btype), vw * 2);\n@@ -803,1 +786,1 @@\n-  if (vectsize < Matcher::superword_max_vector_size(btype)) {\n+  if (vectsize < Matcher::max_vector_size_auto_vectorization(btype)) {\n@@ -833,1 +816,1 @@\n-  if (TraceSuperWord) {\n+  if (is_trace_superword_alignment()) {\n@@ -866,8 +849,0 @@\n-#ifndef PRODUCT\n-    if(TraceSuperWord && Verbose) {\n-      tty->print_cr(\"SuperWord::dependence_graph: built a new mem slice\");\n-      for (int j = _nlist.length() - 1; j >= 0 ; j--) {\n-        _nlist.at(j)->dump();\n-      }\n-    }\n-#endif\n@@ -899,6 +874,0 @@\n-        if (SuperWordRTDepCheck &&\n-            p1.base() != p2.base() && p1.valid() && p2.valid()) {\n-          \/\/ Trace disjoint pointers\n-          OrderedPair pp(p1.base(), p2.base());\n-          _disjoint_ptrs.append_if_missing(pp);\n-        }\n@@ -916,1 +885,2 @@\n-    if (TraceSuperWord) {\n+#ifndef PRODUCT\n+    if (is_trace_superword_dependence_graph()) {\n@@ -923,0 +893,1 @@\n+#endif\n@@ -926,10 +897,0 @@\n-\n-  if (TraceSuperWord) {\n-    tty->print_cr(\"\\ndisjoint_ptrs: %s\", _disjoint_ptrs.length() > 0 ? \"\" : \"NONE\");\n-    for (int r = 0; r < _disjoint_ptrs.length(); r++) {\n-      _disjoint_ptrs.at(r).print();\n-      tty->cr();\n-    }\n-    tty->cr();\n-  }\n-\n@@ -945,1 +906,0 @@\n-    NOT_PRODUCT( if(is_trace_mem_slice()) tty->print_cr(\"SuperWord::mem_slice_preds: n %d\", n->_idx);)\n@@ -952,3 +912,0 @@\n-          if (TraceSuperWord && Verbose) {\n-            tty->print_cr(\"SuperWord::mem_slice_preds: added pred(%d)\", out->_idx);\n-          }\n@@ -973,3 +930,0 @@\n-    if (TraceSuperWord && Verbose) {\n-      tty->print_cr(\"SuperWord::mem_slice_preds: added pred(%d)\", n->_idx);\n-    }\n@@ -980,0 +934,10 @@\n+\n+#ifndef PRODUCT\n+  if (is_trace_superword_memory_slices()) {\n+    tty->print_cr(\"\\nSuperWord::mem_slice_preds:\");\n+    stop->dump();\n+    for (int j = preds.length() - 1; j >= 0 ; j--) {\n+      preds.at(j)->dump();\n+    }\n+  }\n+#endif\n@@ -993,2 +957,2 @@\n-  if (Matcher::superword_max_vector_size(bt1) < 2 ||\n-      (longer_bt != T_ILLEGAL && Matcher::superword_max_vector_size(longer_bt) < 2)) {\n+  if (Matcher::max_vector_size_auto_vectorization(bt1) < 2 ||\n+      (longer_bt != T_ILLEGAL && Matcher::max_vector_size_auto_vectorization(longer_bt) < 2)) {\n@@ -1080,1 +1044,0 @@\n-  \/\/  assert(s1->Opcode() == s2->Opcode(), \"check isomorphic first\");\n@@ -1083,1 +1046,9 @@\n-  if (d1 == d2) return s1 != s2;\n+\n+  if (d1 == d2) {\n+    \/\/ Same depth:\n+    \/\/  1) same node       -> dependent\n+    \/\/  2) different nodes -> same level implies there is no path\n+    return s1 != s2;\n+  }\n+\n+  \/\/ Traversal starting at the deeper node to find the shallower one.\n@@ -1086,0 +1057,1 @@\n+  int min_d = MIN2(d1, d2); \/\/ prune traversal at min_d\n@@ -1087,3 +1059,16 @@\n-  visited_clear();\n-\n-  return independent_path(shallow, deep);\n+  ResourceMark rm;\n+  Unique_Node_List worklist;\n+  worklist.push(deep);\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    Node* n = worklist.at(i);\n+    for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {\n+      Node* pred = preds.current();\n+      if (in_bb(pred) && depth(pred) >= min_d) {\n+        if (pred == shallow) {\n+          return false; \/\/ found it -> dependent\n+        }\n+        worklist.push(pred);\n+      }\n+    }\n+  }\n+  return true; \/\/ not found -> independent\n@@ -1092,2 +1077,1 @@\n-\/\/------------------------------find_dependence---------------------\n-\/\/ Is any s1 in p dependent on any s2 in p? Yes: return such a s2. No: return nullptr.\n+\/\/ Are all nodes in nodes list mutually independent?\n@@ -1095,10 +1079,7 @@\n-\/\/ in O(p.size * p.size) graph traversals. We can do it all in one BFS!\n-\/\/ Start the BFS traversal at all nodes from the pack. Traverse DepPreds\n-\/\/ recursively, for nodes that have at least depth min_d, which is the\n-\/\/ smallest depth of all nodes from the pack. Once we have traversed all\n-\/\/ those nodes, and have not found another node from the pack, we know\n-\/\/ that all nodes in the pack are independent.\n-Node* SuperWord::find_dependence(Node_List* p) {\n-  if (is_marked_reduction(p->at(0))) {\n-    return nullptr; \/\/ ignore reductions\n-  }\n+\/\/ in O(size * size) graph traversals. We can do it all in one BFS!\n+\/\/ Start the BFS traversal at all nodes from the nodes list. Traverse\n+\/\/ Preds recursively, for nodes that have at least depth min_d, which\n+\/\/ is the smallest depth of all nodes from the nodes list. Once we have\n+\/\/ traversed all those nodes, and have not found another node from the\n+\/\/ nodes list, we know that all nodes in the nodes list are independent.\n+bool SuperWord::mutually_independent(Node_List* nodes) const {\n@@ -1106,5 +1087,5 @@\n-  Unique_Node_List worklist; \/\/ traversal queue\n-  int min_d = depth(p->at(0));\n-  visited_clear();\n-  for (uint k = 0; k < p->size(); k++) {\n-    Node* n = p->at(k);\n+  Unique_Node_List worklist;\n+  VectorSet nodes_set;\n+  int min_d = depth(nodes->at(0));\n+  for (uint k = 0; k < nodes->size(); k++) {\n+    Node* n = nodes->at(k);\n@@ -1112,2 +1093,2 @@\n-    worklist.push(n); \/\/ start traversal at all nodes in p\n-    visited_set(n); \/\/ mark node\n+    worklist.push(n); \/\/ start traversal at all nodes in nodes list\n+    nodes_set.set(bb_idx(n));\n@@ -1120,2 +1101,2 @@\n-        if (visited_test(pred)) { \/\/ marked as in p?\n-          return pred;\n+        if (nodes_set.test(bb_idx(pred))) {\n+          return false; \/\/ found one -> dependent\n@@ -1127,1 +1108,1 @@\n-  return nullptr;\n+  return true; \/\/ not found -> independent\n@@ -1175,21 +1156,0 @@\n-\/\/------------------------------independent_path------------------------------\n-\/\/ Helper for independent\n-bool SuperWord::independent_path(Node* shallow, Node* deep, uint dp) {\n-  if (dp >= 1000) return false; \/\/ stop deep recursion\n-  visited_set(deep);\n-  int shal_depth = depth(shallow);\n-  assert(shal_depth <= depth(deep), \"must be\");\n-  for (DepPreds preds(deep, _dg); !preds.done(); preds.next()) {\n-    Node* pred = preds.current();\n-    if (in_bb(pred) && !visited_test(pred)) {\n-      if (shallow == pred) {\n-        return false;\n-      }\n-      if (shal_depth < depth(pred) && !independent_path(shallow, pred, dp+1)) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -1234,2 +1194,3 @@\n-  if (TraceSuperWord) {\n-    tty->print_cr(\"\\nAfter extend_packlist\");\n+#ifndef PRODUCT\n+  if (is_trace_superword_packset()) {\n+    tty->print_cr(\"\\nAfter Superword::extend_packlist\");\n@@ -1238,0 +1199,1 @@\n+#endif\n@@ -1267,1 +1229,6 @@\n-  NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_use_defs: s1 %d, align %d\", s1->_idx, alignment(s1));)\n+#ifndef PRODUCT\n+  if (is_trace_superword_alignment()) {\n+    tty->print_cr(\"SuperWord::follow_use_defs: s1 %d, align %d\",\n+                  s1->_idx, alignment(s1));\n+  }\n+#endif\n@@ -1286,1 +1253,6 @@\n-        NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_use_defs: set_alignment(%d, %d, %d)\", t1->_idx, t2->_idx, align);)\n+#ifndef PRODUCT\n+        if (is_trace_superword_alignment()) {\n+          tty->print_cr(\"SuperWord::follow_use_defs: set_alignment(%d, %d, %d)\",\n+                        t1->_idx, t2->_idx, align);\n+        }\n+#endif\n@@ -1308,1 +1280,6 @@\n-  NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_def_uses: s1 %d, align %d\", s1->_idx, align);)\n+#ifndef PRODUCT\n+  if (is_trace_superword_alignment()) {\n+    tty->print_cr(\"SuperWord::follow_def_uses: s1 %d, align %d\",\n+                  s1->_idx, align);\n+  }\n+#endif\n@@ -1350,1 +1327,6 @@\n-    NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_def_uses: set_alignment(%d, %d, %d)\", u1->_idx, u2->_idx, align);)\n+#ifndef PRODUCT\n+    if (is_trace_superword_alignment()) {\n+      tty->print_cr(\"SuperWord::follow_def_uses: set_alignment(%d, %d, %d)\",\n+                    u1->_idx, u2->_idx, align);\n+    }\n+#endif\n@@ -1541,1 +1523,1 @@\n-        if (TraceSuperWord) {\n+        if (is_trace_superword_rejections()) {\n@@ -1588,2 +1570,3 @@\n-      Node* dependence = find_dependence(p);\n-      if (dependence != nullptr) {\n+      \/\/ reductions are trivially connected\n+      if (!is_marked_reduction(p->at(0)) &&\n+          !mutually_independent(p)) {\n@@ -1591,1 +1574,1 @@\n-        if (TraceSuperWord) {\n+        if (is_trace_superword_rejections()) {\n@@ -1594,1 +1577,0 @@\n-          dependence->dump();\n@@ -1608,2 +1590,2 @@\n-  if (TraceSuperWord) {\n-    tty->print_cr(\"\\nAfter combine_packs\");\n+  if (is_trace_superword_packset()) {\n+    tty->print_cr(\"\\nAfter Superword::combine_packs\");\n@@ -1649,2 +1631,2 @@\n-  if (TraceSuperWord || is_trace_align_vector()) {\n-    tty->print_cr(\"\\nfilter_packs_for_alignment:\");\n+  if (is_trace_superword_info() || is_trace_align_vector()) {\n+    tty->print_cr(\"\\nSuperWord::filter_packs_for_alignment:\");\n@@ -1680,0 +1662,6 @@\n+#ifndef PRODUCT\n+          if (is_trace_superword_rejections() || is_trace_align_vector()) {\n+            tty->print_cr(\"Rejected by AlignVector:\");\n+            p->at(0)->dump();\n+          }\n+#endif\n@@ -1691,1 +1679,1 @@\n-  if (TraceSuperWord || is_trace_align_vector()) {\n+  if (is_trace_superword_info() || is_trace_align_vector()) {\n@@ -1708,0 +1696,7 @@\n+\n+#ifndef PRODUCT\n+  if (is_trace_superword_packset() || is_trace_align_vector()) {\n+    tty->print_cr(\"\\nAfter Superword::filter_packs_for_alignment\");\n+    print_packset();\n+  }\n+#endif\n@@ -1753,1 +1748,1 @@\n-      if ((TraceSuperWord && Verbose) || _vector_loop_debug) {\n+      if (is_trace_superword_rejections()) {\n@@ -1777,1 +1772,1 @@\n-        if ((TraceSuperWord && Verbose) || _vector_loop_debug) {\n+        if (is_trace_superword_rejections()) {\n@@ -1789,2 +1784,2 @@\n-  if (TraceSuperWord) {\n-    tty->print_cr(\"\\nAfter filter_packs\");\n+  if (is_trace_superword_packset()) {\n+    tty->print_cr(\"\\nAfter Superword::filter_packs\");\n@@ -1977,12 +1972,3 @@\n-    Node* dependence = find_dependence(p);\n-    if (dependence != nullptr) {\n-      tty->print_cr(\"Other nodes in pack have dependence on:\");\n-      dependence->dump();\n-      tty->print_cr(\"The following nodes are not independent:\");\n-      for (uint k = 0; k < p->size(); k++) {\n-        Node* n = p->at(k);\n-        if (!independent(n, dependence)) {\n-          n->dump();\n-        }\n-      }\n-      tty->print_cr(\"They are all from pack[%d]\", i);\n+    if (!is_marked_reduction(p->at(0)) &&\n+        !mutually_independent(p)) {\n+      tty->print_cr(\"FAILURE: nodes not mutually independent in pack[%d]\", i);\n@@ -1990,0 +1976,1 @@\n+      assert(false, \"pack nodes not mutually independent\");\n@@ -1991,1 +1978,0 @@\n-    assert(dependence == nullptr, \"all nodes in pack must be mutually independent\");\n@@ -1995,0 +1981,1 @@\n+  ResourceMark rm;\n@@ -2272,1 +2259,2 @@\n-    if (TraceSuperWord) {\n+#ifndef PRODUCT\n+    if (is_trace_superword_rejections()) {\n@@ -2277,0 +2265,1 @@\n+#endif\n@@ -2282,1 +2271,1 @@\n-  if (TraceSuperWord) {\n+  if (is_trace_superword_info()) {\n@@ -2402,4 +2391,1 @@\n-  \/\/ Insert extract (unpack) operations for scalar uses\n-  for (int i = 0; i < _packset.length(); i++) {\n-    insert_extracts(_packset.at(i));\n-  }\n+  DEBUG_ONLY(verify_no_extract());\n@@ -2421,1 +2407,0 @@\n-      NOT_PRODUCT(if(is_trace_cmov()) {tty->print_cr(\"VPointer::output: %d executed first, %d executed last in pack\", first->_idx, n->_idx); print_pack(p);})\n@@ -2714,0 +2699,1 @@\n+#ifndef PRODUCT\n@@ -2717,0 +2703,1 @@\n+#endif\n@@ -2856,6 +2843,6 @@\n-\/\/------------------------------insert_extracts---------------------------\n-\/\/ If a use of pack p is not a vector use, then replace the\n-\/\/ use with an extract operation.\n-void SuperWord::insert_extracts(Node_List* p) {\n-  if (p->at(0)->is_Store()) return;\n-  assert(_n_idx_list.is_empty(), \"empty (node,index) list\");\n+#ifdef ASSERT\n+\/\/ We check that every packset (name it p_def) only has vector uses (p_use),\n+\/\/ which are proper vector uses of def.\n+void SuperWord::verify_no_extract() {\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* p_def = _packset.at(i);\n@@ -2863,2 +2850,2 @@\n-  \/\/ Inspect each use of each pack member.  For each use that is\n-  \/\/ not a vector use, replace the use with an extract operation.\n+    \/\/ A vector store has no uses\n+    if (p_def->at(0)->is_Store()) { continue; }\n@@ -2866,10 +2853,12 @@\n-  for (uint i = 0; i < p->size(); i++) {\n-    Node* def = p->at(i);\n-    for (DUIterator_Fast jmax, j = def->fast_outs(jmax); j < jmax; j++) {\n-      Node* use = def->fast_out(j);\n-      for (uint k = 0; k < use->req(); k++) {\n-        Node* n = use->in(k);\n-        if (def == n) {\n-          Node_List* u_pk = my_pack(use);\n-          if ((u_pk == nullptr || use->is_CMove()) && !is_vector_use(use, k)) {\n-              _n_idx_list.push(use, k);\n+    \/\/ for every def in p_def, and every use:\n+    for (uint i = 0; i < p_def->size(); i++) {\n+      Node* def = p_def->at(i);\n+      for (DUIterator_Fast jmax, j = def->fast_outs(jmax); j < jmax; j++) {\n+        Node* use = def->fast_out(j);\n+        \/\/ find every use->def edge:\n+        for (uint k = 0; k < use->req(); k++) {\n+          Node* maybe_def = use->in(k);\n+          if (def == maybe_def) {\n+            Node_List* p_use = my_pack(use);\n+            if (is_marked_reduction(def)) { continue; }\n+            assert(p_use != nullptr && is_vector_use(use, k), \"all uses must be vector uses\");\n@@ -2881,23 +2870,0 @@\n-\n-  while (_n_idx_list.is_nonempty()) {\n-    Node* use = _n_idx_list.node();\n-    int   idx = _n_idx_list.index();\n-    _n_idx_list.pop();\n-    Node* def = use->in(idx);\n-\n-    if (is_marked_reduction(def)) continue;\n-\n-    \/\/ Insert extract operation\n-    _igvn.hash_delete(def);\n-    int def_pos = alignment(def) \/ data_size(def);\n-\n-    ConINode* def_pos_con = _igvn.intcon(def_pos)->as_ConI();\n-    Node* ex = ExtractNode::make(def, def_pos_con, velt_basic_type(def));\n-    _igvn.register_new_node_with_optimizer(ex);\n-    _phase->set_ctrl(ex, _phase->get_ctrl(def));\n-    _igvn.replace_input_of(use, idx, ex);\n-    _igvn._worklist.push(def);\n-\n-    bb_insert_after(ex, bb_idx(def));\n-    set_velt_type(ex, velt_type(def));\n-  }\n@@ -2905,0 +2871,1 @@\n+#endif\n@@ -2988,1 +2955,0 @@\n-  assert(_stk.length() == 0,            \"stk is empty\");\n@@ -3045,2 +3011,4 @@\n-  visited_clear();\n-  post_visited_clear();\n+  ResourceMark rm;\n+  GrowableArray<Node*> stack;\n+  VectorSet visited;\n+  VectorSet post_visited;\n@@ -3051,2 +3019,2 @@\n-    visited_set(n);\n-    _stk.push(n);\n+    visited.set(bb_idx(n));\n+    stack.push(n);\n@@ -3054,2 +3022,2 @@\n-  visited_set(entry);\n-  _stk.push(entry);\n+  visited.set(bb_idx(entry));\n+  stack.push(entry);\n@@ -3061,3 +3029,3 @@\n-  while ((size = _stk.length()) > 0) {\n-    Node* n = _stk.top(); \/\/ Leave node on stack\n-    if (!visited_test_set(n)) {\n+  while ((size = stack.length()) > 0) {\n+    Node* n = stack.top(); \/\/ Leave node on stack\n+    if (!visited.test_set(bb_idx(n))) {\n@@ -3065,1 +3033,1 @@\n-    } else if (!post_visited_test(n)) {\n+    } else if (!post_visited.test(bb_idx(n))) {\n@@ -3069,1 +3037,1 @@\n-        if (in_bb(use) && !visited_test(use) &&\n+        if (in_bb(use) && !visited.test(bb_idx(use)) &&\n@@ -3076,1 +3044,1 @@\n-            if (ReductionNode::implemented(use->Opcode(), Matcher::superword_max_vector_size(bt), bt)) {\n+            if (ReductionNode::implemented(use->Opcode(), Matcher::max_vector_size_auto_vectorization(bt), bt)) {\n@@ -3080,1 +3048,1 @@\n-          _stk.push(use);\n+          stack.push(use);\n@@ -3083,1 +3051,1 @@\n-      if (_stk.length() == size) {\n+      if (stack.length() == size) {\n@@ -3085,1 +3053,1 @@\n-        _stk.pop(); \/\/ Remove node from stack\n+        stack.pop(); \/\/ Remove node from stack\n@@ -3089,2 +3057,2 @@\n-        post_visited_set(n);\n-        assert(rpo_idx >= 0 || _stk.is_empty(), \"\");\n+        post_visited.set(bb_idx(n));\n+        assert(rpo_idx >= 0 || stack.is_empty(), \"\");\n@@ -3093,1 +3061,1 @@\n-      _stk.pop(); \/\/ Remove post-visited node from stack\n+      stack.pop(); \/\/ Remove post-visited node from stack\n@@ -3109,1 +3077,1 @@\n-  if (TraceSuperWord) {\n+  if (is_trace_superword_info()) {\n@@ -3116,0 +3084,2 @@\n+  }\n+  if (is_trace_superword_memory_slices()) {\n@@ -3182,1 +3152,2 @@\n-  if (TraceSuperWord && Verbose) {\n+#ifndef PRODUCT\n+  if (is_trace_superword_dependence_graph()) {\n@@ -3185,0 +3156,1 @@\n+#endif\n@@ -3230,1 +3202,1 @@\n-  int max = Matcher::superword_max_vector_size(vt);\n+  int max = Matcher::max_vector_size_auto_vectorization(vt);\n@@ -3233,1 +3205,1 @@\n-  return max < 2 ? Matcher::superword_max_vector_size(bt) : max;\n+  return max < 2 ? Matcher::max_vector_size_auto_vectorization(bt) : max;\n@@ -3244,1 +3216,2 @@\n-  if (TraceSuperWord && Verbose) {\n+#ifndef PRODUCT\n+  if (is_trace_superword_vector_element_type()) {\n@@ -3247,0 +3220,1 @@\n+#endif\n@@ -3322,1 +3296,1 @@\n-  if (TraceSuperWord && Verbose) {\n+  if (is_trace_superword_vector_element_type()) {\n@@ -3337,1 +3311,1 @@\n-  if ((TraceSuperWord && Verbose) || is_trace_alignment()) {\n+  if (is_trace_superword_alignment()) {\n@@ -3343,1 +3317,1 @@\n-    NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"VPointer::memory_alignment: VPointer p invalid, return bottom_align\");)\n+    NOT_PRODUCT(if(is_trace_superword_alignment()) tty->print_cr(\"SuperWord::memory_alignment: VPointer p invalid, return bottom_align\");)\n@@ -3348,1 +3322,1 @@\n-    NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"VPointer::memory_alignment: vector_width_in_bytes < 2, return bottom_align\");)\n+    NOT_PRODUCT(if(is_trace_superword_alignment()) tty->print_cr(\"SuperWord::memory_alignment: vector_width_in_bytes < 2, return bottom_align\");)\n@@ -3356,2 +3330,2 @@\n-  if ((TraceSuperWord && Verbose) || is_trace_alignment()) {\n-    tty->print_cr(\"VPointer::memory_alignment: off_rem = %d, off_mod = %d (offset = %d)\", off_rem, off_mod, offset);\n+  if (is_trace_superword_alignment()) {\n+    tty->print_cr(\"SuperWord::memory_alignment: off_rem = %d, off_mod = %d (offset = %d)\", off_rem, off_mod, offset);\n@@ -3804,1 +3778,0 @@\n-  _disjoint_ptrs.clear();\n@@ -3862,4 +3835,0 @@\n-\/\/ ========================= OrderedPair =====================\n-\n-const OrderedPair OrderedPair::initial;\n-\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":209,"deletions":240,"binary":false,"changes":449,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-class OrderedPair;\n@@ -201,27 +200,0 @@\n-class SuperWord;\n-\n-\/\/ JVMCI: OrderedPair is moved up to deal with compilation issues on Windows\n-\/\/------------------------------OrderedPair---------------------------\n-\/\/ Ordered pair of Node*.\n-class OrderedPair {\n- protected:\n-  Node* _p1;\n-  Node* _p2;\n- public:\n-  OrderedPair() : _p1(nullptr), _p2(nullptr) {}\n-  OrderedPair(Node* p1, Node* p2) {\n-    if (p1->_idx < p2->_idx) {\n-      _p1 = p1; _p2 = p2;\n-    } else {\n-      _p1 = p2; _p2 = p1;\n-    }\n-  }\n-\n-  bool operator==(const OrderedPair &rhs) {\n-    return _p1 == rhs._p1 && _p2 == rhs._p2;\n-  }\n-  void print() { tty->print(\"  (%d, %d)\", _p1->_idx, _p2->_idx); }\n-\n-  static const OrderedPair initial;\n-};\n-\n@@ -252,2 +224,0 @@\n-  GrowableArray<OrderedPair> _disjoint_ptrs; \/\/ runtime disambiguated pointer pairs\n-\n@@ -257,3 +227,0 @@\n-  VectorSet    _visited;       \/\/ Visited set\n-  VectorSet    _post_visited;  \/\/ Post-visited set\n-  Node_Stack   _n_idx_list;    \/\/ List of (node,index) pairs\n@@ -261,1 +228,0 @@\n-  GrowableArray<Node*> _stk;   \/\/ Stack of nodes\n@@ -278,7 +244,70 @@\n-  bool     is_debug()              { return _vector_loop_debug > 0; }\n-  bool     is_trace_alignment()    { return (_vector_loop_debug & 2) > 0; }\n-  bool     is_trace_mem_slice()    { return (_vector_loop_debug & 4) > 0; }\n-  bool     is_trace_loop()         { return (_vector_loop_debug & 8) > 0; }\n-  bool     is_trace_adjacent()     { return (_vector_loop_debug & 16) > 0; }\n-  bool     is_trace_cmov()         { return (_vector_loop_debug & 32) > 0; }\n-  bool     is_trace_align_vector() { return (_vector_loop_debug & 128) > 0; }\n+  \/\/ TraceAutoVectorization and TraceSuperWord\n+  bool is_trace_superword_precondition() const {\n+    return TraceSuperWord ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PRECONDITION);\n+  }\n+\n+  bool is_trace_superword_vector_element_type() const {\n+    \/\/ Too verbose for TraceSuperWord\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::SW_TYPES);\n+  }\n+\n+  bool is_trace_superword_alignment() const {\n+    \/\/ Too verbose for TraceSuperWord\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::SW_ALIGNMENT);\n+  }\n+\n+  bool is_trace_superword_memory_slices() const {\n+    return TraceSuperWord ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_MEMORY_SLICES);\n+  }\n+\n+  bool is_trace_superword_dependence_graph() const {\n+    return TraceSuperWord ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_DEPENDENCE_GRAPH);\n+  }\n+\n+  bool is_trace_superword_adjacent_memops() const {\n+    return TraceSuperWord ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_ADJACENT_MEMOPS);\n+  }\n+\n+  bool is_trace_superword_rejections() const {\n+    return TraceSuperWord ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_REJECTIONS);\n+  }\n+\n+  bool is_trace_superword_packset() const {\n+    return TraceSuperWord ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PACKSET);\n+  }\n+\n+  bool is_trace_superword_info() const {\n+    return TraceSuperWord ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_INFO);\n+  }\n+\n+  bool is_trace_superword_verbose() const {\n+    \/\/ Too verbose for TraceSuperWord\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::SW_VERBOSE);\n+  }\n+\n+  bool is_trace_superword_any() const {\n+    return TraceSuperWord ||\n+           is_trace_align_vector() ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PRECONDITION) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_TYPES) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_ALIGNMENT) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_MEMORY_SLICES) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_DEPENDENCE_GRAPH) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_ADJACENT_MEMOPS) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_REJECTIONS) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_PACKSET) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_INFO) ||\n+           _vtrace.is_trace(TraceAutoVectorizationTag::SW_VERBOSE);\n+  }\n+\n+  bool is_trace_align_vector() const {\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::ALIGN_VECTOR) ||\n+           is_trace_superword_verbose();\n+  }\n@@ -286,0 +315,1 @@\n+\n@@ -302,3 +332,1 @@\n-#ifndef PRODUCT\n-  uintx          _vector_loop_debug; \/\/ provide more printing in debug mode\n-#endif\n+  NOT_PRODUCT(VTrace _vtrace);\n@@ -340,9 +368,0 @@\n-  \/\/ visited set accessors\n-  void visited_clear()           { _visited.clear(); }\n-  void visited_set(Node* n)      { return _visited.set(bb_idx(n)); }\n-  int visited_test(Node* n)      { return _visited.test(bb_idx(n)); }\n-  int visited_test_set(Node* n)  { return _visited.test_set(bb_idx(n)); }\n-  void post_visited_clear()      { _post_visited.clear(); }\n-  void post_visited_set(Node* n) { return _post_visited.set(bb_idx(n)); }\n-  int post_visited_test(Node* n) { return _post_visited.test(bb_idx(n)); }\n-\n@@ -360,1 +379,1 @@\n-  int depth(Node* n)                         { return _node_info.adr_at(bb_idx(n))->_depth; }\n+  int depth(Node* n) const                   { return _node_info.adr_at(bb_idx(n))->_depth; }\n@@ -463,2 +482,2 @@\n-  \/\/ Is any s1 in p dependent on any s2 in p? Yes: return such a s2. No: return nullptr.\n-  Node* find_dependence(Node_List* p);\n+  \/\/ Are all nodes in nodes list mutually independent?\n+  bool mutually_independent(Node_List* nodes) const;\n@@ -470,2 +489,0 @@\n-  \/\/ Helper for independent\n-  bool independent_path(Node* shallow, Node* deep, uint dp=0);\n@@ -516,2 +533,2 @@\n-  \/\/ If a use of pack p is not a vector use, then replace the use with an extract operation.\n-  void insert_extracts(Node_List* p);\n+  \/\/ Verify that all uses of packs are also packs, i.e. we do not need extract operations.\n+  DEBUG_ONLY(void verify_no_extract();)\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":77,"deletions":60,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_TRACEAUTOVECTORIZATIONTAG_HPP\n+#define SHARE_OPTO_TRACEAUTOVECTORIZATIONTAG_HPP\n+\n+#include \"utilities\/bitMap.inline.hpp\"\n+#include \"utilities\/stringUtils.hpp\"\n+\n+#define COMPILER_TRACE_AUTO_VECTORIZATION_TAG(flags) \\\n+  flags(POINTER_ANALYSIS,     \"Trace VPointer\") \\\n+  flags(SW_PRECONDITION,      \"Trace SuperWord precondition\") \\\n+  flags(SW_TYPES,             \"Trace SuperWord::compute_vector_element_type\") \\\n+  flags(SW_ALIGNMENT,         \"Trace SuperWord alignment analysis\") \\\n+  flags(SW_MEMORY_SLICES,     \"Trace SuperWord memory slices\") \\\n+  flags(SW_DEPENDENCE_GRAPH,  \"Trace SuperWord::dependence_graph\") \\\n+  flags(SW_ADJACENT_MEMOPS,   \"Trace SuperWord::find_adjacent_refs\") \\\n+  flags(SW_REJECTIONS,        \"Trace SuperWord rejections (non vectorizations)\") \\\n+  flags(SW_PACKSET,           \"Trace SuperWord packset at different stages\") \\\n+  flags(SW_INFO,              \"Trace SuperWord info (equivalent to TraceSuperWord)\") \\\n+  flags(SW_VERBOSE,           \"Trace SuperWord verbose (all SW tags enabled)\") \\\n+  flags(ALIGN_VECTOR,         \"Trace AlignVector\") \\\n+  flags(ALL,                  \"Trace everything (very verbose)\")\n+\n+#define table_entry(name, description) name,\n+enum TraceAutoVectorizationTag {\n+  COMPILER_TRACE_AUTO_VECTORIZATION_TAG(table_entry)\n+  TRACE_AUTO_VECTORIZATION_TAG_NUM,\n+  TRACE_AUTO_VECTORIZATION_TAG_NONE\n+};\n+#undef table_entry\n+\n+static const char* tag_descriptions[] = {\n+#define array_of_labels(name, description) description,\n+       COMPILER_TRACE_AUTO_VECTORIZATION_TAG(array_of_labels)\n+#undef array_of_labels\n+};\n+\n+static const char* tag_names[] = {\n+#define array_of_labels(name, description) #name,\n+       COMPILER_TRACE_AUTO_VECTORIZATION_TAG(array_of_labels)\n+#undef array_of_labels\n+};\n+\n+static TraceAutoVectorizationTag find_tag(const char* str) {\n+  for (int i = 0; i < TRACE_AUTO_VECTORIZATION_TAG_NUM; i++) {\n+    if (strcmp(tag_names[i], str) == 0) {\n+      return (TraceAutoVectorizationTag)i;\n+    }\n+  }\n+  return TRACE_AUTO_VECTORIZATION_TAG_NONE;\n+}\n+\n+class TraceAutoVectorizationTagValidator {\n+ private:\n+  CHeapBitMap _tags;\n+  bool _valid;\n+  char* _bad;\n+  bool _is_print_usage;\n+\n+ public:\n+  TraceAutoVectorizationTagValidator(ccstrlist option, bool is_print_usage) :\n+    _tags(TRACE_AUTO_VECTORIZATION_TAG_NUM, mtCompiler),\n+    _valid(true),\n+    _bad(nullptr),\n+    _is_print_usage(is_print_usage)\n+  {\n+    for (StringUtils::CommaSeparatedStringIterator iter(option); *iter != nullptr && _valid; ++iter) {\n+      char const* tag_name = *iter;\n+      if (strcmp(\"help\", tag_name) == 0) {\n+        if (_is_print_usage) {\n+          print_help();\n+        }\n+        continue;\n+      }\n+      bool set_bit = true;\n+      \/\/ Check for \"TAG\" or \"-TAG\"\n+      if (strncmp(\"-\", tag_name, strlen(\"-\")) == 0) {\n+        tag_name++;\n+        set_bit = false;\n+      }\n+      TraceAutoVectorizationTag tag = find_tag(tag_name);\n+      if (TRACE_AUTO_VECTORIZATION_TAG_NONE == tag) {\n+        \/\/ cap len to a value we know is enough for all tags\n+        const size_t len = MIN2<size_t>(strlen(*iter), 63) + 1;\n+        _bad = NEW_C_HEAP_ARRAY(char, len, mtCompiler);\n+        \/\/ strncpy always writes len characters. If the source string is\n+        \/\/ shorter, the function fills the remaining bytes with nulls.\n+        strncpy(_bad, *iter, len);\n+        _valid = false;\n+      } else if (ALL == tag) {\n+        _tags.set_range(0, TRACE_AUTO_VECTORIZATION_TAG_NUM);\n+      } else if (SW_VERBOSE == tag) {\n+        _tags.at_put(SW_PRECONDITION, set_bit);\n+        _tags.at_put(SW_TYPES, set_bit);\n+        _tags.at_put(SW_ALIGNMENT, set_bit);\n+        _tags.at_put(SW_MEMORY_SLICES, set_bit);\n+        _tags.at_put(SW_DEPENDENCE_GRAPH, set_bit);\n+        _tags.at_put(SW_ADJACENT_MEMOPS, set_bit);\n+        _tags.at_put(SW_REJECTIONS, set_bit);\n+        _tags.at_put(SW_PACKSET, set_bit);\n+        _tags.at_put(SW_INFO, set_bit);\n+        _tags.at_put(SW_VERBOSE, set_bit);\n+      } else if (SW_INFO == tag) {\n+        _tags.at_put(SW_PRECONDITION, set_bit);\n+        _tags.at_put(SW_MEMORY_SLICES, set_bit);\n+        _tags.at_put(SW_DEPENDENCE_GRAPH, set_bit);\n+        _tags.at_put(SW_ADJACENT_MEMOPS, set_bit);\n+        _tags.at_put(SW_REJECTIONS, set_bit);\n+        _tags.at_put(SW_PACKSET, set_bit);\n+        _tags.at_put(SW_INFO, set_bit);\n+      } else {\n+        assert(tag < TRACE_AUTO_VECTORIZATION_TAG_NUM, \"out of bounds\");\n+        _tags.at_put(tag, set_bit);\n+      }\n+    }\n+  }\n+\n+  ~TraceAutoVectorizationTagValidator() {\n+    if (_bad != nullptr) {\n+      FREE_C_HEAP_ARRAY(char, _bad);\n+    }\n+  }\n+\n+  bool is_valid() const { return _valid; }\n+  const char* what() const { return _bad; }\n+  const CHeapBitMap& tags() const {\n+    assert(is_valid(), \"only read tags when valid\");\n+    return _tags;\n+  }\n+\n+  static void print_help() {\n+    tty->cr();\n+    tty->print_cr(\"Usage for CompileCommand TraceAutoVectorization:\");\n+    tty->print_cr(\"  -XX:CompileCommand=TraceAutoVectorization,<package.class::method>,<tags>\");\n+    tty->print_cr(\"  %-22s %s\", \"tags\", \"descriptions\");\n+    for (int i = 0; i < TRACE_AUTO_VECTORIZATION_TAG_NUM; i++) {\n+      tty->print_cr(\"  %-22s %s\", tag_names[i], tag_descriptions[i]);\n+    }\n+    tty->cr();\n+  }\n+};\n+\n+#endif \/\/ SHARE_OPTO_TRACEAUTOVECTORIZATIONTAG_HPP\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -49,1 +49,1 @@\n-  , _tracer((phase->C->directive()->VectorizeDebugOption & 2) > 0)\n+  , _tracer(phase->C->directive()->trace_auto_vectorization_tags().at(TraceAutoVectorizationTag::POINTER_ANALYSIS))\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/traceAutoVectorizationTag.hpp\"\n@@ -34,0 +35,16 @@\n+#ifndef PRODUCT\n+\/\/ Access to TraceAutoVectorization tags\n+class VTrace : public StackObj {\n+private:\n+  const CHeapBitMap &_trace_tags;\n+\n+public:\n+  VTrace() : _trace_tags(Compile::current()->directive()->trace_auto_vectorization_tags()) {}\n+  NONCOPYABLE(VTrace);\n+\n+  bool is_trace(TraceAutoVectorizationTag tag) const {\n+    return _trace_tags.at(tag);\n+  }\n+};\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -392,1 +392,1 @@\n-  return Matcher::superword_max_vector_size(bt) >= size &&\n+  return Matcher::max_vector_size_auto_vectorization(bt) >= size &&\n@@ -412,1 +412,1 @@\n-    return vopc > 0 && Matcher::match_rule_supported_superword(vopc, vlen, bt);\n+    return vopc > 0 && Matcher::match_rule_supported_auto_vectorization(vopc, vlen, bt);\n@@ -1437,1 +1437,1 @@\n-    return vopc > 0 && Matcher::match_rule_supported_superword(vopc, vlen, dst_type);\n+    return vopc > 0 && Matcher::match_rule_supported_auto_vectorization(vopc, vlen, dst_type);\n@@ -1531,1 +1531,1 @@\n-    return vopc != opc && Matcher::match_rule_supported_superword(vopc, vlen, bt);\n+    return vopc != opc && Matcher::match_rule_supported_auto_vectorization(vopc, vlen, bt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -152,1 +152,9 @@\n-    JVMTI_ONLY(_can_hotswap_or_post_breakpoint = (on != 0);)\n+#if INCLUDE_JVMTI\n+    \/\/ Check that _can_hotswap_or_post_breakpoint is not reset once it\n+    \/\/ was set to true. When _can_hotswap_or_post_breakpoint is set to true\n+    \/\/ _all_dependencies_are_recorded is also set to true and never\n+    \/\/ reset so we have to ensure that evol dependencies are always\n+    \/\/ recorded from that point on.\n+    assert(!_can_hotswap_or_post_breakpoint || on, \"sanity check\");\n+    _can_hotswap_or_post_breakpoint = (on != 0);\n+#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4063,3 +4063,3 @@\n-\/\/ phase then the compiler has recorded all dependencies from startup.\n-\/\/ In that case we need only deoptimize and throw away all compiled code\n-\/\/ that depends on the class.\n+\/\/ phase or 'AlwaysRecordEvolDependencies' is true, then the compiler has\n+\/\/ recorded all dependencies from startup. In that case we need only\n+\/\/ deoptimize and throw away all compiled code that depends on the class.\n@@ -4067,7 +4067,7 @@\n-\/\/ If can_redefine_classes is obtained sometime after the onload\n-\/\/ phase then the dependency information may be incomplete. In that case\n-\/\/ the first call to RedefineClasses causes all compiled code to be\n-\/\/ thrown away. As can_redefine_classes has been obtained then\n-\/\/ all future compilations will record dependencies so second and\n-\/\/ subsequent calls to RedefineClasses need only throw away code\n-\/\/ that depends on the class.\n+\/\/ If can_redefine_classes is obtained sometime after the onload phase\n+\/\/ (and 'AlwaysRecordEvolDependencies' is false) then the dependency\n+\/\/ information may be incomplete. In that case the first call to\n+\/\/ RedefineClasses causes all compiled code to be thrown away. As\n+\/\/ can_redefine_classes has been obtained then all future compilations will\n+\/\/ record dependencies so second and subsequent calls to RedefineClasses\n+\/\/ need only throw away code that depends on the class.\n@@ -4078,0 +4078,1 @@\n+  assert(JvmtiExport::all_dependencies_are_recorded() || !AlwaysRecordEvolDependencies, \"sanity check\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"oops\/methodData.inline.hpp\"\n@@ -1229,1 +1230,0 @@\n-    MutexLocker mu(THREAD, mdo->extra_data_lock());\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+uint64_t Abstract_VM_Version::_cpu_features = 0;\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  \/\/ CPU feature flags.\n+  \/\/ CPU feature flags, can be affected by VM settings.\n@@ -61,0 +61,3 @@\n+  \/\/ Original CPU feature flags, not affected by VM settings.\n+  static uint64_t _cpu_features;\n+\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -497,4 +497,0 @@\n-  { \"MaxGCMinorPauseMillis\",        JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"MaxRAMFraction\",               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"MinRAMFraction\",               JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },\n-  { \"InitialRAMFraction\",           JDK_Version::jdk(10),  JDK_Version::undefined(), JDK_Version::undefined() },\n@@ -510,1 +506,0 @@\n-  { \"DefaultMaxRAMFraction\",        JDK_Version::jdk(8),  JDK_Version::undefined(), JDK_Version::undefined() },\n@@ -529,0 +524,5 @@\n+  { \"MaxGCMinorPauseMillis\",        JDK_Version::jdk(8), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"MaxRAMFraction\",               JDK_Version::jdk(10),  JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"MinRAMFraction\",               JDK_Version::jdk(10),  JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"InitialRAMFraction\",           JDK_Version::jdk(10),  JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"DefaultMaxRAMFraction\",        JDK_Version::jdk(8),  JDK_Version::jdk(23), JDK_Version::jdk(24) },\n@@ -554,1 +554,0 @@\n-  { \"DefaultMaxRAMFraction\",    \"MaxRAMFraction\"    },\n@@ -1482,1 +1481,0 @@\n-                           !FLAG_IS_DEFAULT(MaxRAMFraction) ||\n@@ -1484,1 +1482,0 @@\n-                           !FLAG_IS_DEFAULT(MinRAMFraction) ||\n@@ -1486,1 +1483,0 @@\n-                           !FLAG_IS_DEFAULT(InitialRAMFraction) ||\n@@ -1500,14 +1496,0 @@\n-\n-  \/\/ Convert deprecated flags\n-  if (FLAG_IS_DEFAULT(MaxRAMPercentage) &&\n-      !FLAG_IS_DEFAULT(MaxRAMFraction))\n-    MaxRAMPercentage = 100.0 \/ (double)MaxRAMFraction;\n-\n-  if (FLAG_IS_DEFAULT(MinRAMPercentage) &&\n-      !FLAG_IS_DEFAULT(MinRAMFraction))\n-    MinRAMPercentage = 100.0 \/ (double)MinRAMFraction;\n-\n-  if (FLAG_IS_DEFAULT(InitialRAMPercentage) &&\n-      !FLAG_IS_DEFAULT(InitialRAMFraction))\n-    InitialRAMPercentage = 100.0 \/ (double)InitialRAMFraction;\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":6,"deletions":24,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -394,1 +394,2 @@\n-  for (int i = 0; i < chunk->length(); i++) {\n+  \/\/ Start locking from outermost\/oldest frame\n+  for (int i = (chunk->length() - 1); i >= 0; i--) {\n@@ -1727,1 +1728,2 @@\n-      for (int j = 0; j < monitors->number_of_monitors(); j++) {\n+      \/\/ Unlock in reverse order starting from most nested monitor.\n+      for (int j = (monitors->number_of_monitors() - 1); j >= 0; j--) {\n@@ -1804,0 +1806,3 @@\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    MutexLocker ml(imm_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -2109,0 +2114,6 @@\n+\n+      \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+      \/\/ We must do this already now, since we cannot acquire this lock while\n+      \/\/ holding the tty lock (lock ordering by rank).\n+      MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n@@ -2110,0 +2121,1 @@\n+\n@@ -2144,0 +2156,3 @@\n+\n+        \/\/ We need to lock to read the ProfileData. But to keep the locks ordered, we need to\n+        \/\/ lock extra_data_lock before the tty lock.\n@@ -2319,0 +2334,5 @@\n+\n+    \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+    ConditionalMutexLocker ml((trap_mdo != nullptr) ? trap_mdo->extra_data_lock() : nullptr,\n+                              (trap_mdo != nullptr),\n+                              Mutex::_no_safepoint_check_flag);\n@@ -2325,0 +2345,1 @@\n+\n@@ -2480,0 +2501,2 @@\n+  trap_mdo->check_extra_data_locked();\n+\n@@ -2562,0 +2585,4 @@\n+\n+  \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+  MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -278,1 +278,0 @@\n-    \/\/      uintx MinRAMFraction                                     [ 1                         ...      18446744073709551615 ]                            {product} {default}\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2012,0 +2012,5 @@\n+                                                                            \\\n+  product(bool, AlwaysRecordEvolDependencies, true, EXPERIMENTAL,           \\\n+                \"Unconditionally record nmethod dependencies on class \"     \\\n+                \"rewriting\/transformation independently of the JVMTI \"      \\\n+                \"can_{retransform\/redefine}_classes capabilities.\")         \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -118,0 +118,6 @@\n+#if INCLUDE_JVMTI\n+  if (AlwaysRecordEvolDependencies) {\n+    JvmtiExport::set_can_hotswap_or_post_breakpoint(true);\n+    JvmtiExport::set_all_dependencies_are_recorded(true);\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -261,0 +261,1 @@\n+  bool is_in_no_safepoint_scope() { return _no_safepoint_count > 0; }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2117,1 +2117,1 @@\n-    char* cur = static_cast<char*>(align_down(start, page_size));\n+    void* first = align_down(start, page_size);\n@@ -2119,6 +2119,10 @@\n-    assert(cur <= last, \"invariant\");\n-    \/\/ Iterate from first page through last (inclusive), being careful to\n-    \/\/ avoid overflow if the last page abuts the end of the address range.\n-    for ( ; true; cur += page_size) {\n-      Atomic::add(reinterpret_cast<int*>(cur), 0, memory_order_relaxed);\n-      if (cur >= last) break;\n+    assert(first <= last, \"invariant\");\n+    const size_t pd_page_size = pd_pretouch_memory(first, last, page_size);\n+    if (pd_page_size > 0) {\n+      \/\/ Iterate from first page through last (inclusive), being careful to\n+      \/\/ avoid overflow if the last page abuts the end of the address range.\n+      last = align_down(static_cast<char*>(end) - 1, pd_page_size);\n+      for (char* cur = static_cast<char*>(first); \/* break *\/; cur += pd_page_size) {\n+        Atomic::add(reinterpret_cast<int*>(cur), 0, memory_order_relaxed);\n+        if (cur >= last) break;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -227,0 +227,4 @@\n+  \/\/ Returns 0 if pretouch is done via platform dependent method, or otherwise\n+  \/\/ returns page_size that should be used for the common method.\n+  static size_t pd_pretouch_memory(void* first, void* last, size_t page_size);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -618,0 +618,4 @@\n+\n+        \/\/ Lock to read ProfileData, and ensure lock is not broken by a safepoint\n+        MutexLocker ml(trap_mdo->extra_data_lock(), Mutex::_no_safepoint_check_flag);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,7 @@\n-MemoryManager::MemoryManager(const char* name) :\n-  _num_pools(0), _name(name) {}\n+MemoryManager::MemoryManager(const char* name)\n+  : _pools(),\n+    _num_pools(0),\n+    _name(name),\n+    _memory_mgr_obj(),\n+    _memory_mgr_obj_initialized(false)\n+{}\n@@ -59,1 +64,5 @@\n-  return mh() == Atomic::load(&_memory_mgr_obj).resolve();\n+  if (Atomic::load_acquire(&_memory_mgr_obj_initialized)) {\n+    return mh() == _memory_mgr_obj.resolve();\n+  } else {\n+    return false;\n+  }\n@@ -71,0 +80,1 @@\n+  \/\/ Lazily create the manager object.\n@@ -73,2 +83,1 @@\n-  oop mgr_obj = Atomic::load_acquire(&_memory_mgr_obj).resolve();\n-  if (mgr_obj == nullptr) {\n+  if (!Atomic::load_acquire(&_memory_mgr_obj_initialized)) {\n@@ -117,24 +126,26 @@\n-    instanceOop m = (instanceOop) result.get_oop();\n-    instanceHandle mgr(THREAD, m);\n-\n-    {\n-      \/\/ Get lock before setting _memory_mgr_obj\n-      \/\/ since another thread may have created the instance\n-      MutexLocker ml(THREAD, Management_lock);\n-\n-      \/\/ Check if another thread has created the management object.  We reload\n-      \/\/ _memory_mgr_obj here because some other thread may have initialized\n-      \/\/ it while we were executing the code before the lock.\n-      mgr_obj = Atomic::load(&_memory_mgr_obj).resolve();\n-      if (mgr_obj != nullptr) {\n-         return (instanceOop)mgr_obj;\n-      }\n-\n-      \/\/ Get the address of the object we created via call_special.\n-      mgr_obj = mgr();\n-\n-      \/\/ Use store barrier to make sure the memory accesses associated\n-      \/\/ with creating the management object are visible before publishing\n-      \/\/ its address.  The unlock will publish the store to _memory_mgr_obj\n-      \/\/ because it does a release first.\n-      Atomic::release_store(&_memory_mgr_obj, OopHandle(Universe::vm_global(), mgr_obj));\n+    \/\/ Verify we didn't get a null manager.  If that could happen then we'd\n+    \/\/ need to return immediately rather than continuing on and recording the\n+    \/\/ manager has been created.\n+    oop m = result.get_oop();\n+    guarantee(m != nullptr, \"Manager creation returned null\");\n+    instanceHandle mgr(THREAD, (instanceOop)m);\n+\n+    \/\/ Allocate global handle outside lock, to avoid any lock nesting issues\n+    \/\/ with the Management_lock.\n+    OopHandle mgr_handle(Universe::vm_global(), mgr());\n+\n+    \/\/ Get lock since another thread may have created and installed the instance.\n+    MutexLocker ml(THREAD, Management_lock);\n+\n+    if (Atomic::load(&_memory_mgr_obj_initialized)) {\n+      \/\/ Some other thread won the race.  Release the handle we allocated and\n+      \/\/ use the other one.  Relaxed load is sufficient because flag update is\n+      \/\/ under the lock.\n+      mgr_handle.release(Universe::vm_global());\n+    } else {\n+      \/\/ Record the object we created via call_special.\n+      assert(_memory_mgr_obj.is_empty(), \"already set manager obj\");\n+      _memory_mgr_obj = mgr_handle;\n+      \/\/ Record manager has been created.  Release matching unlocked acquire,\n+      \/\/ to safely publish the manager object.\n+      Atomic::release_store(&_memory_mgr_obj_initialized, true);\n@@ -144,1 +155,1 @@\n-  return (instanceOop)mgr_obj;\n+  return (instanceOop)_memory_mgr_obj.resolve();\n","filename":"src\/hotspot\/share\/services\/memoryManager.cpp","additions":42,"deletions":31,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,2 @@\n-  volatile OopHandle _memory_mgr_obj;\n+  OopHandle _memory_mgr_obj;\n+  volatile bool _memory_mgr_obj_initialized;\n@@ -62,1 +63,0 @@\n-public:\n@@ -65,0 +65,1 @@\n+public:\n","filename":"src\/hotspot\/share\/services\/memoryManager.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,2 @@\n-  _memory_pool_obj()\n+  _memory_pool_obj(),\n+  _memory_pool_obj_initialized(false)\n@@ -70,1 +71,5 @@\n-  return pool() == Atomic::load(&_memory_pool_obj).resolve();\n+  if (Atomic::load_acquire(&_memory_pool_obj_initialized)) {\n+    return pool() == _memory_pool_obj.resolve();\n+  } else {\n+    return false;\n+  }\n@@ -86,0 +91,1 @@\n+  \/\/ Lazily create the pool object.\n@@ -88,2 +94,1 @@\n-  oop pool_obj = Atomic::load_acquire(&_memory_pool_obj).resolve();\n-  if (pool_obj == nullptr) {\n+  if (!Atomic::load_acquire(&_memory_pool_obj_initialized)) {\n@@ -116,23 +121,26 @@\n-    instanceOop p = (instanceOop) result.get_oop();\n-    instanceHandle pool(THREAD, p);\n-\n-    {\n-      \/\/ Get lock since another thread may have create the instance\n-      MutexLocker ml(THREAD, Management_lock);\n-\n-      \/\/ Check if another thread has created the pool.  We reload\n-      \/\/ _memory_pool_obj here because some other thread may have\n-      \/\/ initialized it while we were executing the code before the lock.\n-      pool_obj = Atomic::load(&_memory_pool_obj).resolve();\n-      if (pool_obj != nullptr) {\n-         return (instanceOop)pool_obj;\n-      }\n-\n-      \/\/ Get the address of the object we created via call_special.\n-      pool_obj = pool();\n-\n-      \/\/ Use store barrier to make sure the memory accesses associated\n-      \/\/ with creating the pool are visible before publishing its address.\n-      \/\/ The unlock will publish the store to _memory_pool_obj because\n-      \/\/ it does a release first.\n-      Atomic::release_store(&_memory_pool_obj, OopHandle(Universe::vm_global(), pool_obj));\n+    \/\/ Verify we didn't get a null pool.  If that could happen then we'd\n+    \/\/ need to return immediately rather than continuing on and recording the\n+    \/\/ pool has been created.\n+    oop p = result.get_oop();\n+    guarantee(p != nullptr, \"Pool creation returns null\");\n+    instanceHandle pool(THREAD, (instanceOop)p);\n+\n+    \/\/ Allocate global handle outside lock, to avoid any lock nesting issues\n+    \/\/ with the Management_lock.\n+    OopHandle pool_handle(Universe::vm_global(), pool());\n+\n+    \/\/ Get lock since another thread may have created and installed the instance.\n+    MutexLocker ml(THREAD, Management_lock);\n+\n+    if (Atomic::load(&_memory_pool_obj_initialized)) {\n+      \/\/ Some other thread won the race.  Release the handle we allocated and\n+      \/\/ use the other one.  Relaxed load is sufficient because flag update is\n+      \/\/ under the lock.\n+      pool_handle.release(Universe::vm_global());\n+    } else {\n+      \/\/ Record the object we created via call_special.\n+      assert(_memory_pool_obj.is_empty(), \"already set pool obj\");\n+      _memory_pool_obj = pool_handle;\n+      \/\/ Record pool has been created.  Release matching unlocked acquire, to\n+      \/\/ safely publish the pool object.\n+      Atomic::release_store(&_memory_pool_obj_initialized, true);\n@@ -142,1 +150,1 @@\n-  return (instanceOop)pool_obj;\n+  return (instanceOop)_memory_pool_obj.resolve();\n","filename":"src\/hotspot\/share\/services\/memoryPool.cpp","additions":37,"deletions":29,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,2 @@\n-  volatile OopHandle _memory_pool_obj;\n+  OopHandle _memory_pool_obj;\n+  volatile bool _memory_pool_obj_initialized;\n","filename":"src\/hotspot\/share\/services\/memoryPool.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -436,0 +436,1 @@\n+        ResourceMark rm(THREAD);\n@@ -444,0 +445,1 @@\n+      ResourceMark rm(THREAD);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -125,0 +126,20 @@\n+\n+StringUtils::CommaSeparatedStringIterator::~CommaSeparatedStringIterator() {\n+  FREE_C_HEAP_ARRAY(char, _list);\n+}\n+\n+ccstrlist StringUtils::CommaSeparatedStringIterator::canonicalize(ccstrlist option_value) {\n+  char* canonicalized_list = NEW_C_HEAP_ARRAY(char, strlen(option_value) + 1, mtCompiler);\n+  int i = 0;\n+  char current;\n+  while ((current = option_value[i]) != '\\0') {\n+    if (current == '\\n' || current == ' ') {\n+      canonicalized_list[i] = ',';\n+    } else {\n+      canonicalized_list[i] = current;\n+    }\n+    i++;\n+  }\n+  canonicalized_list[i] = '\\0';\n+  return canonicalized_list;\n+}\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,5 @@\n+#ifdef _WINDOWS\n+  \/\/ strtok_s is the Windows thread-safe equivalent of POSIX strtok_r\n+# define strtok_r strtok_s\n+#endif\n+\n@@ -52,0 +57,27 @@\n+\n+  class CommaSeparatedStringIterator {\n+  private:\n+    char* _token;\n+    char* _saved_ptr;\n+    char* _list;\n+\n+  public:\n+    CommaSeparatedStringIterator(ccstrlist option) {\n+      \/\/ Immediately make a private copy of option, and\n+      \/\/ replace spaces and newlines with comma.\n+      _list = (char*) canonicalize(option);\n+      _saved_ptr = _list;\n+      _token = strtok_r(_saved_ptr, \",\", &_saved_ptr);\n+    }\n+\n+    ~CommaSeparatedStringIterator();\n+\n+    const char* operator*() const { return _token; }\n+\n+    CommaSeparatedStringIterator& operator++() {\n+      _token = strtok_r(nullptr, \",\", &_saved_ptr);\n+      return *this;\n+    }\n+\n+    ccstrlist canonicalize(ccstrlist option_value);\n+  };\n","filename":"src\/hotspot\/share\/utilities\/stringUtils.hpp","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat, Inc.\n+ * Copyright (c) 2020, 2024, Red Hat, Inc.\n@@ -57,1 +57,1 @@\n-    return (jlong)si.totalswap;\n+    return (jlong)(si.totalswap * si.mem_unit);\n","filename":"src\/java.base\/linux\/native\/libjava\/CgroupMetrics.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1990,3 +1990,2 @@\n-        } catch (OutOfMemoryError memerr) {\n-            throw new InvalidObjectException(\"Proxy interface limit exceeded: \" +\n-                                             Arrays.toString(ifaces), memerr);\n+        } catch (OutOfMemoryError oome) {\n+            throw genInvalidObjectException(oome, ifaces);\n@@ -2004,3 +2003,2 @@\n-        } catch (OutOfMemoryError memerr) {\n-            throw new InvalidObjectException(\"Proxy interface limit exceeded: \" +\n-                                             Arrays.toString(ifaces), memerr);\n+        } catch (OutOfMemoryError oome) {\n+            throw genInvalidObjectException(oome, ifaces);\n@@ -2016,0 +2014,8 @@\n+    \/\/ Generate an InvalidObjectException for an OutOfMemoryError\n+    \/\/ Use String.concat() to avoid string formatting invoke dynamic\n+    private static InvalidObjectException genInvalidObjectException(OutOfMemoryError oome,\n+                                                                    String[] ifaces) {\n+        return new InvalidObjectException(\"Proxy interface limit exceeded: \"\n+                .concat(Arrays.toString(ifaces)), oome);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -867,1 +867,2 @@\n-                                                  path -> path.groupElement(name));\n+                                                  path -> path.groupElement(name),\n+                                                  \"groupElement(\\\"\" + name + \"\\\")\");\n@@ -882,1 +883,2 @@\n-                    path -> path.groupElement(index));\n+                                                  path -> path.groupElement(index),\n+                                                  \"groupElement(\" + index + \")\");\n@@ -897,1 +899,2 @@\n-                                                  path -> path.sequenceElement(index));\n+                                                  path -> path.sequenceElement(index),\n+                                                  \"sequenceElement(\" + index + \")\");\n@@ -930,1 +933,2 @@\n-                                                  path -> path.sequenceElement(start, step));\n+                                                  path -> path.sequenceElement(start, step),\n+                                                  \"sequenceElement(\" + start + \", \" + step + \")\");\n@@ -943,1 +947,2 @@\n-                                                  LayoutPath::sequenceElement);\n+                                                  LayoutPath::sequenceElement,\n+                                                  \"sequenceElement()\");\n@@ -952,1 +957,2 @@\n-                    LayoutPath::derefElement);\n+                                                  LayoutPath::derefElement,\n+                                                  \"dereferenceElement()\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.runtime;\n+\n+\/**\n+ * A testing conversion of a value is exact if it yields a result without loss\n+ * of information or throwing an exception. Otherwise, it is inexact. Some\n+ * conversions are always exact regardless of the value. These conversions are\n+ * said to be unconditionally exact.\n+ * <p>\n+ * For example, a conversion from {@code int} to {@code byte} for the value 10\n+ * is exact because the result, 10, is the same as the original value. In\n+ * contrast, if the {@code int} variable {@code i} stores the value 1000 then a\n+ * narrowing primitive conversion to {@code byte} will yield the result -24.\n+ * Loss of information has occurred: both the magnitude and the sign of the\n+ * result are different than those of the original value. As such, a conversion\n+ * from {@code int} to {@code byte} for the value 1000 is inexact. Finally a\n+ * widening primitive conversion from {@code byte} to {@code int} is\n+ * unconditionally exact because it will always succeed with no loss of\n+ * information about the magnitude of the numeric value.\n+ * <p>\n+ * The methods in this class provide the run-time support for the exactness\n+ * checks of testing conversions from a primitive type to primitive type. These\n+ * methods may be used, for example, by Java compiler implementations to\n+ * implement checks for {@code instanceof} and pattern matching runtime\n+ * implementations. Unconditionally exact testing conversions do not require a\n+ * corresponding action at run time and, for this reason, methods corresponding\n+ * to these exactness checks are omitted here.\n+ * <p>\n+ * The run time conversion checks examine whether loss of information would\n+ * occur if a testing conversion would be to be applied. In those cases where a\n+ * floating-point primitive type is involved, and the value of the testing\n+ * conversion is either signed zero, signed infinity or {@code NaN}, these\n+ * methods comply with the following:\n+ *\n+ * <ul>\n+ * <li>Converting a floating-point negative zero to an integer type is considered\n+ *   inexact.<\/li>\n+ * <li>Converting a floating-point {@code NaN} or infinity to an integer type is\n+ *   considered inexact.<\/li>\n+ * <li>Converting a floating-point {@code NaN} or infinity or signed zero to another\n+ *   floating-point type is considered exact.<\/li>\n+ * <\/ul>\n+ *\n+ * @jls 5.7.1 Exact Testing Conversions\n+ * @jls 5.7.2 Unconditionally Exact Testing Conversions\n+ * @jls 15.20.2 The instanceof Operator\n+ *\n+ * @implNote Some exactness checks describe a test which can be redirected\n+ * safely through one of the existing methods. Those are omitted too (i.e.,\n+ * {@code byte} to {@code char} can be redirected  to\n+ * {@link ExactConversionsSupport#isIntToCharExact(int)}, {@code short} to\n+ * {@code byte} can be redirected to\n+ * {@link ExactConversionsSupport#isIntToByteExact(int)} and similarly for\n+ * {@code short} to {@code char}, {@code char} to {@code byte} and {@code char}\n+ * to {@code short} to the corresponding methods that take an {@code int}).\n+ *\n+ * @since 23\n+ *\/\n+public final class ExactConversionsSupport {\n+\n+    private ExactConversionsSupport() { }\n+\n+    \/**\n+     * Exactness method from int to byte\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\/\n+    public static boolean isIntToByteExact(int n)      {return n == (int)(byte)n;}\n+\n+    \/**\n+     * Exactness method from int to short\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\/\n+    public static boolean isIntToShortExact(int n)     {return n == (int)(short)n;}\n+\n+    \/**\n+     * Exactness method from int to char\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\/\n+    public static boolean isIntToCharExact(int n)      {return n == (int)(char)n;}\n+\n+    \/**\n+     * Exactness method from int to float\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isIntToFloatExact(int n) {\n+        return n == (int)(float)n && n != Integer.MAX_VALUE;\n+    }\n+    \/**\n+     * Exactness method from long to byte\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\/\n+    public static boolean isLongToByteExact(long n)    {return n == (long)(byte)n;}\n+\n+    \/**\n+     * Exactness method from long to short\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\/\n+    public static boolean isLongToShortExact(long n)   {return n == (long)(short)n;}\n+\n+    \/**\n+     * Exactness method from long to char\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\/\n+    public static boolean isLongToCharExact(long n)    {return n == (long)(char)n;}\n+\n+    \/**\n+     * Exactness method from long to int\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\/\n+    public static boolean isLongToIntExact(long n)     {return n == (long)(int)n;}\n+\n+    \/**\n+     * Exactness method from long to float\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isLongToFloatExact(long n) {\n+        return n == (long)(float)n && n != Long.MAX_VALUE;\n+    }\n+\n+    \/**\n+     * Exactness method from long to double\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isLongToDoubleExact(long n) {\n+        return n == (long)(double)n && n != Long.MAX_VALUE;\n+    }\n+\n+    \/**\n+     * Exactness method from float to byte\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isFloatToByteExact(float n)  {\n+        return n == (float)(byte)n && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from float to short\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isFloatToShortExact(float n) {\n+        return n == (float)(short)n && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from float to char\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isFloatToCharExact(float n)  {\n+        return n == (float)(char)n && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from float to int\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isFloatToIntExact(float n) {\n+        return n == (float)(int)n && n != 0x1p31f && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from float to long\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isFloatToLongExact(float n) {\n+        return n == (float)(long)n && n != 0x1p63f && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from double to byte\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isDoubleToByteExact(double n) {\n+        return n == (double)(byte)n && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from double to short\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isDoubleToShortExact(double n){\n+        return n == (double)(short)n && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from double to char\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isDoubleToCharExact(double n) {\n+        return n == (double)(char)n && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from double to int\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isDoubleToIntExact(double n)  {\n+        return n == (double)(int)n && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from double to long\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isDoubleToLongExact(double n) {\n+        return n == (double)(long)n && n != 0x1p63 && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from double to float\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isDoubleToFloatExact(double n) {\n+        return n == (double)(float)n || n != n;\n+    }\n+\n+    private static boolean isNegativeZero(float n) {\n+        return Float.floatToRawIntBits(n) == Integer.MIN_VALUE;\n+    }\n+\n+    private static boolean isNegativeZero(double n) {\n+        return Double.doubleToRawLongBits(n) == Long.MIN_VALUE;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ExactConversionsSupport.java","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.lang.classfile.CodeBuilder;\n@@ -30,0 +31,1 @@\n+import java.lang.constant.ConstantDesc;\n@@ -43,0 +45,1 @@\n+import java.util.function.Consumer;\n@@ -48,0 +51,1 @@\n+import jdk.internal.misc.PreviewFeatures;\n@@ -52,0 +56,2 @@\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -53,0 +59,1 @@\n+import sun.invoke.util.Wrapper;\n@@ -68,0 +75,1 @@\n+    private static final boolean previewEnabled = PreviewFeatures.isEnabled();\n@@ -77,0 +85,2 @@\n+    private static final Map<TypePairs, String> typePairToName;\n+\n@@ -92,0 +102,1 @@\n+        typePairToName = TypePairs.initialize();\n@@ -137,6 +148,9 @@\n-     * @throws NullPointerException if any argument is {@code null}\n-     * @throws IllegalArgumentException if any element in the labels array is null, if the\n-     * invocation type is not not a method type of first parameter of a reference type,\n-     * second parameter of type {@code int} and with {@code int} as its return type,\n-     * or if {@code labels} contains an element that is not of type {@code String},\n-     * {@code Integer}, {@code Class} or {@code EnumDesc}.\n+     * @throws NullPointerException     if any argument is {@code null}\n+     * @throws IllegalArgumentException if any element in the labels array is null\n+     * @throws IllegalArgumentException if the invocation type is not a method type of first parameter of a reference type,\n+     *                                  second parameter of type {@code int} and with {@code int} as its return type,\n+     * @throws IllegalArgumentException if {@code labels} contains an element that is not of type {@code String},\n+     *                                  {@code Integer}, {@code Long}, {@code Float}, {@code Double}, {@code Boolean},\n+     *                                  {@code Class} or {@code EnumDesc}.\n+     * @throws IllegalArgumentException if {@code labels} contains an element that is not of type {@code Boolean}\n+     *                                  when {@code target} is a {@code Boolean.class}.\n@@ -150,0 +164,1 @@\n+        Class<?> selectorType = invocationType.parameterType(0);\n@@ -152,1 +167,0 @@\n-            || invocationType.parameterType(0).isPrimitive()\n@@ -157,2 +171,1 @@\n-        labels = labels.clone();\n-        Stream.of(labels).forEach(SwitchBootstraps::verifyLabel);\n+        Stream.of(labels).forEach(l -> verifyLabel(l, selectorType));\n@@ -160,1 +173,1 @@\n-        MethodHandle target = generateInnerClass(lookup, labels);\n+        MethodHandle target = generateTypeSwitch(lookup, selectorType, labels);\n@@ -167,1 +180,1 @@\n-    private static void verifyLabel(Object label) {\n+    private static void verifyLabel(Object label, Class<?> selectorType) {\n@@ -172,0 +185,1 @@\n+\n@@ -175,0 +189,8 @@\n+\n+            ((labelClass != Float.class &&\n+              labelClass != Long.class &&\n+              labelClass != Double.class &&\n+              labelClass != Boolean.class) ||\n+              ((selectorType.equals(boolean.class) || selectorType.equals(Boolean.class)) && labelClass != Boolean.class && labelClass != Class.class) ||\n+             !previewEnabled) &&\n+\n@@ -269,1 +291,1 @@\n-                                                                            generateInnerClass(lookup, labels),\n+                                                                            generateTypeSwitch(lookup, invocationType.parameterType(0), labels),\n@@ -273,1 +295,1 @@\n-            target = generateInnerClass(lookup, labels);\n+            target = generateTypeSwitch(lookup, invocationType.parameterType(0), labels);\n@@ -384,55 +406,66 @@\n-    @SuppressWarnings(\"removal\")\n-    private static MethodHandle generateInnerClass(MethodHandles.Lookup caller, Object[] labels) {\n-        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n-        List<Class<?>> extraClassLabels = new ArrayList<>();\n-\n-        byte[] classBytes = ClassFile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())), clb -> {\n-            clb.withFlags(AccessFlag.FINAL, AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n-               .withMethodBody(\"typeSwitch\",\n-                               TYPES_SWITCH_DESCRIPTOR,\n-                               ClassFile.ACC_FINAL | ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n-                               cb -> {\n-                    cb.aload(0);\n-                    Label nonNullLabel = cb.newLabel();\n-                    cb.if_nonnull(nonNullLabel);\n-                    cb.iconst_m1();\n-                    cb.ireturn();\n-                    cb.labelBinding(nonNullLabel);\n-                    if (labels.length == 0) {\n-                        cb.constantInstruction(0)\n-                          .ireturn();\n-                        return ;\n-                    }\n-                    cb.iload(1);\n-                    Label dflt = cb.newLabel();\n-                    record Element(Label target, Label next, Object caseLabel) {}\n-                    List<Element> cases = new ArrayList<>();\n-                    List<SwitchCase> switchCases = new ArrayList<>();\n-                    Object lastLabel = null;\n-                    for (int idx = labels.length - 1; idx >= 0; idx--) {\n-                        Object currentLabel = labels[idx];\n-                        Label target = cb.newLabel();\n-                        Label next;\n-                        if (lastLabel == null) {\n-                            next = dflt;\n-                        } else if (lastLabel.equals(currentLabel)) {\n-                            next = cases.getLast().next();\n-                        } else {\n-                            next = cases.getLast().target();\n-                        }\n-                        lastLabel = currentLabel;\n-                        cases.add(new Element(target, next, currentLabel));\n-                        switchCases.add(SwitchCase.of(idx, target));\n-                    }\n-                    cases = cases.reversed();\n-                    switchCases = switchCases.reversed();\n-                    cb.tableswitch(0, labels.length - 1, dflt, switchCases);\n-                    for (int idx = 0; idx < cases.size(); idx++) {\n-                        Element element = cases.get(idx);\n-                        Label next = element.next();\n-                        cb.labelBinding(element.target());\n-                        if (element.caseLabel() instanceof Class<?> classLabel) {\n-                            Optional<ClassDesc> classLabelConstableOpt = classLabel.describeConstable();\n-                            if (classLabelConstableOpt.isPresent()) {\n-                                cb.aload(0);\n-                                cb.instanceof_(classLabelConstableOpt.orElseThrow());\n+    private static Consumer<CodeBuilder> generateTypeSwitchSkeleton(Class<?> selectorType, Object[] labelConstants, List<EnumDesc<?>> enumDescs, List<Class<?>> extraClassLabels) {\n+        int SELECTOR_OBJ        = 0;\n+        int RESTART_IDX         = 1;\n+        int ENUM_CACHE          = 2;\n+        int EXTRA_CLASS_LABELS  = 3;\n+\n+        return cb -> {\n+            cb.aload(SELECTOR_OBJ);\n+            Label nonNullLabel = cb.newLabel();\n+            cb.if_nonnull(nonNullLabel);\n+            cb.iconst_m1();\n+            cb.ireturn();\n+            cb.labelBinding(nonNullLabel);\n+            if (labelConstants.length == 0) {\n+                cb.constantInstruction(0)\n+                        .ireturn();\n+                return;\n+            }\n+            cb.iload(RESTART_IDX);\n+            Label dflt = cb.newLabel();\n+            record Element(Label target, Label next, Object caseLabel) { }\n+            List<Element> cases = new ArrayList<>();\n+            List<SwitchCase> switchCases = new ArrayList<>();\n+            Object lastLabel = null;\n+            for (int idx = labelConstants.length - 1; idx >= 0; idx--) {\n+                Object currentLabel = labelConstants[idx];\n+                Label target = cb.newLabel();\n+                Label next;\n+                if (lastLabel == null) {\n+                    next = dflt;\n+                } else if (lastLabel.equals(currentLabel)) {\n+                    next = cases.getLast().next();\n+                } else {\n+                    next = cases.getLast().target();\n+                }\n+                lastLabel = currentLabel;\n+                cases.add(new Element(target, next, currentLabel));\n+                switchCases.add(SwitchCase.of(idx, target));\n+            }\n+            cases = cases.reversed();\n+            switchCases = switchCases.reversed();\n+            cb.tableswitch(0, labelConstants.length - 1, dflt, switchCases);\n+            for (int idx = 0; idx < cases.size(); idx++) {\n+                Element element = cases.get(idx);\n+                Label next = element.next();\n+                cb.labelBinding(element.target());\n+                if (element.caseLabel() instanceof Class<?> classLabel) {\n+                    if (unconditionalExactnessCheck(selectorType, classLabel)) {\n+                        \/\/nothing - unconditionally use this case\n+                    } else if (classLabel.isPrimitive()) {\n+                        if (!selectorType.isPrimitive() && !Wrapper.isWrapperNumericOrBooleanType(selectorType)) {\n+                            \/\/ Object o = ...\n+                            \/\/ o instanceof Wrapped(float)\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.instanceof_(Wrapper.forBasicType(classLabel)\n+                                    .wrapperType()\n+                                    .describeConstable()\n+                                    .orElseThrow());\n+                            cb.ifeq(next);\n+                        } else if (!unconditionalExactnessCheck(Wrapper.asPrimitiveType(selectorType), classLabel)) {\n+                            \/\/ Integer i = ... or int i = ...\n+                            \/\/ o instanceof float\n+                            Label notNumber = cb.newLabel();\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.instanceof_(ConstantDescs.CD_Number);\n+                            if (selectorType == long.class || selectorType == float.class || selectorType == double.class) {\n@@ -441,12 +474,25 @@\n-                                cb.aload(3);\n-                                cb.constantInstruction(extraClassLabels.size());\n-                                cb.invokeinterface(ConstantDescs.CD_List,\n-                                                   \"get\",\n-                                                   MethodTypeDesc.of(ConstantDescs.CD_Object,\n-                                                                     ConstantDescs.CD_int));\n-                                cb.checkcast(ConstantDescs.CD_Class);\n-                                cb.aload(0);\n-                                cb.invokevirtual(ConstantDescs.CD_Class,\n-                                                 \"isInstance\",\n-                                                 MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                                                   ConstantDescs.CD_Object));\n+                                cb.ifeq(notNumber);\n+                            }\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.checkcast(ConstantDescs.CD_Number);\n+                            if (selectorType == long.class) {\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"longValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_long));\n+                            } else if (selectorType == float.class) {\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"floatValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_float));\n+                            } else if (selectorType == double.class) {\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"doubleValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_double));\n+                            } else {\n+                                Label compare = cb.newLabel();\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"intValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_int));\n+                                cb.goto_(compare);\n+                                cb.labelBinding(notNumber);\n+                                cb.aload(SELECTOR_OBJ);\n+                                cb.instanceof_(ConstantDescs.CD_Character);\n@@ -454,1 +500,6 @@\n-                                extraClassLabels.add(classLabel);\n+                                cb.aload(SELECTOR_OBJ);\n+                                cb.checkcast(ConstantDescs.CD_Character);\n+                                cb.invokevirtual(ConstantDescs.CD_Character,\n+                                        \"charValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_char));\n+                                cb.labelBinding(compare);\n@@ -456,23 +507,6 @@\n-                        } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n-                            int enumIdx = enumDescs.size();\n-                            enumDescs.add(enumLabel);\n-                            cb.aload(2);\n-                            cb.constantInstruction(enumIdx);\n-                            cb.invokestatic(ConstantDescs.CD_Integer,\n-                                            \"valueOf\",\n-                                            MethodTypeDesc.of(ConstantDescs.CD_Integer,\n-                                                              ConstantDescs.CD_int));\n-                            cb.aload(0);\n-                            cb.invokeinterface(BiPredicate.class.describeConstable().orElseThrow(),\n-                                               \"test\",\n-                                               MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                                                 ConstantDescs.CD_Object,\n-                                                                 ConstantDescs.CD_Object));\n-                            cb.ifeq(next);\n-                        } else if (element.caseLabel() instanceof String stringLabel) {\n-                            cb.ldc(stringLabel);\n-                            cb.aload(0);\n-                            cb.invokevirtual(ConstantDescs.CD_Object,\n-                                             \"equals\",\n-                                             MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                                               ConstantDescs.CD_Object));\n+\n+                            TypePairs typePair = TypePairs.of(Wrapper.asPrimitiveType(selectorType), classLabel);\n+                            String methodName = typePairToName.get(typePair);\n+                            cb.invokestatic(ExactConversionsSupport.class.describeConstable().orElseThrow(),\n+                                    methodName,\n+                                    MethodTypeDesc.of(ConstantDescs.CD_boolean, typePair.from.describeConstable().orElseThrow()));\n@@ -480,15 +514,6 @@\n-                        } else if (element.caseLabel() instanceof Integer integerLabel) {\n-                            Label compare = cb.newLabel();\n-                            Label notNumber = cb.newLabel();\n-                            cb.aload(0);\n-                            cb.instanceof_(ConstantDescs.CD_Number);\n-                            cb.ifeq(notNumber);\n-                            cb.aload(0);\n-                            cb.checkcast(ConstantDescs.CD_Number);\n-                            cb.invokevirtual(ConstantDescs.CD_Number,\n-                                             \"intValue\",\n-                                             MethodTypeDesc.of(ConstantDescs.CD_int));\n-                            cb.goto_(compare);\n-                            cb.labelBinding(notNumber);\n-                            cb.aload(0);\n-                            cb.instanceof_(ConstantDescs.CD_Character);\n+                        }\n+                    } else {\n+                        Optional<ClassDesc> classLabelConstableOpt = classLabel.describeConstable();\n+                        if (classLabelConstableOpt.isPresent()) {\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.instanceof_(classLabelConstableOpt.orElseThrow());\n@@ -496,8 +521,0 @@\n-                            cb.aload(0);\n-                            cb.checkcast(ConstantDescs.CD_Character);\n-                            cb.invokevirtual(ConstantDescs.CD_Character,\n-                                             \"charValue\",\n-                                             MethodTypeDesc.of(ConstantDescs.CD_char));\n-                            cb.labelBinding(compare);\n-                            cb.ldc(integerLabel);\n-                            cb.if_icmpne(next);\n@@ -505,2 +522,14 @@\n-                            throw new InternalError(\"Unsupported label type: \" +\n-                                                    element.caseLabel().getClass());\n+                            cb.aload(EXTRA_CLASS_LABELS);\n+                            cb.constantInstruction(extraClassLabels.size());\n+                            cb.invokeinterface(ConstantDescs.CD_List,\n+                                    \"get\",\n+                                    MethodTypeDesc.of(ConstantDescs.CD_Object,\n+                                            ConstantDescs.CD_int));\n+                            cb.checkcast(ConstantDescs.CD_Class);\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.invokevirtual(ConstantDescs.CD_Class,\n+                                    \"isInstance\",\n+                                    MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                            ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                            extraClassLabels.add(classLabel);\n@@ -508,2 +537,0 @@\n-                        cb.constantInstruction(idx);\n-                        cb.ireturn();\n@@ -511,4 +538,95 @@\n-                    cb.labelBinding(dflt);\n-                    cb.constantInstruction(cases.size());\n-                    cb.ireturn();\n-                });\n+                } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n+                    int enumIdx = enumDescs.size();\n+                    enumDescs.add(enumLabel);\n+                    cb.aload(ENUM_CACHE);\n+                    cb.constantInstruction(enumIdx);\n+                    cb.invokestatic(ConstantDescs.CD_Integer,\n+                            \"valueOf\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_Integer,\n+                                    ConstantDescs.CD_int));\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.invokeinterface(BiPredicate.class.describeConstable().orElseThrow(),\n+                            \"test\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                    ConstantDescs.CD_Object,\n+                                    ConstantDescs.CD_Object));\n+                    cb.ifeq(next);\n+                } else if (element.caseLabel() instanceof String stringLabel) {\n+                    cb.ldc(stringLabel);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.invokevirtual(ConstantDescs.CD_Object,\n+                            \"equals\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                    ConstantDescs.CD_Object));\n+                    cb.ifeq(next);\n+                } else if (element.caseLabel() instanceof Integer integerLabel) {\n+                    Label compare = cb.newLabel();\n+                    Label notNumber = cb.newLabel();\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.instanceof_(ConstantDescs.CD_Number);\n+                    cb.ifeq(notNumber);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.checkcast(ConstantDescs.CD_Number);\n+                    cb.invokevirtual(ConstantDescs.CD_Number,\n+                            \"intValue\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_int));\n+                    cb.goto_(compare);\n+                    cb.labelBinding(notNumber);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.instanceof_(ConstantDescs.CD_Character);\n+                    cb.ifeq(next);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.checkcast(ConstantDescs.CD_Character);\n+                    cb.invokevirtual(ConstantDescs.CD_Character,\n+                            \"charValue\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_char));\n+                    cb.labelBinding(compare);\n+\n+                    cb.ldc(integerLabel);\n+                    cb.if_icmpne(next);\n+                } else if ((element.caseLabel() instanceof Long ||\n+                        element.caseLabel() instanceof Float ||\n+                        element.caseLabel() instanceof Double ||\n+                        element.caseLabel() instanceof Boolean)) {\n+                    if (element.caseLabel() instanceof Boolean c) {\n+                        cb.constantInstruction(c ? 1 : 0);\n+                    } else {\n+                        cb.constantInstruction((ConstantDesc) element.caseLabel());\n+                    }\n+                    cb.invokestatic(element.caseLabel().getClass().describeConstable().orElseThrow(),\n+                            \"valueOf\",\n+                            MethodTypeDesc.of(element.caseLabel().getClass().describeConstable().orElseThrow(),\n+                                    Wrapper.asPrimitiveType(element.caseLabel().getClass()).describeConstable().orElseThrow()));\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.invokevirtual(ConstantDescs.CD_Object,\n+                            \"equals\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                    ConstantDescs.CD_Object));\n+                    cb.ifeq(next);\n+                } else {\n+                    throw new InternalError(\"Unsupported label type: \" +\n+                            element.caseLabel().getClass());\n+                }\n+                cb.constantInstruction(idx);\n+                cb.ireturn();\n+            }\n+            cb.labelBinding(dflt);\n+            cb.constantInstruction(cases.size());\n+            cb.ireturn();\n+        };\n+    }\n+\n+    \/*\n+     * Construct the method handle that represents the method int typeSwitch(Object, int, BiPredicate, List)\n+     *\/\n+    private static MethodHandle generateTypeSwitch(MethodHandles.Lookup caller, Class<?> selectorType, Object[] labelConstants) {\n+        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n+        List<Class<?>> extraClassLabels = new ArrayList<>();\n+\n+        byte[] classBytes = ClassFile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())),\n+                clb -> {\n+                    clb.withFlags(AccessFlag.FINAL, AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n+                       .withMethodBody(\"typeSwitch\",\n+                                       TYPES_SWITCH_DESCRIPTOR,\n+                                       ClassFile.ACC_FINAL | ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                                       generateTypeSwitchSkeleton(selectorType, labelConstants, enumDescs, extraClassLabels));\n@@ -528,2 +646,7 @@\n-            return MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(EnumDesc[]::new)),\n-                                                                List.copyOf(extraClassLabels));\n+            typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(EnumDesc[]::new)),\n+                                                       List.copyOf(extraClassLabels));\n+            typeSwitch = MethodHandles.explicitCastArguments(typeSwitch,\n+                                                             MethodType.methodType(int.class,\n+                                                                                   selectorType,\n+                                                                                   int.class));\n+            return typeSwitch;\n@@ -544,0 +667,57 @@\n+\n+    \/\/ this method should be in sync with com.sun.tools.javac.code.Types.checkUnconditionallyExactPrimitives\n+    private static boolean unconditionalExactnessCheck(Class<?> selectorType, Class<?> targetType) {\n+        Wrapper selectorWrapper = Wrapper.forBasicType(selectorType);\n+        Wrapper targetWrapper   = Wrapper.forBasicType(targetType);\n+        if (selectorType.isPrimitive() && targetType.equals(selectorWrapper.wrapperType())) {\n+            return true;\n+        }\n+        else if (selectorType.equals(targetType) ||\n+                ((selectorType.equals(byte.class) && !targetType.equals(char.class)) ||\n+                 (selectorType.equals(short.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))) ||\n+                 (selectorType.equals(char.class)  && (selectorWrapper.isStrictSubRangeOf(targetWrapper)))  ||\n+                 (selectorType.equals(int.class)   && (targetType.equals(double.class) || targetType.equals(long.class))) ||\n+                 (selectorType.equals(float.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))))) return true;\n+        return false;\n+    }\n+\n+    \/\/ TypePairs should be in sync with the corresponding record in Lower\n+    record TypePairs(Class<?> from, Class<?> to) {\n+        public static TypePairs of(Class<?> from,  Class<?> to) {\n+            if (from == byte.class || from == short.class || from == char.class) {\n+                from = int.class;\n+            }\n+            return new TypePairs(from, to);\n+        }\n+\n+        public static Map<TypePairs, String> initialize() {\n+            Map<TypePairs, String> typePairToName = new HashMap<>();\n+            typePairToName.put(new TypePairs(byte.class,   char.class),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(short.class,  byte.class),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(short.class,  char.class),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(char.class,   byte.class),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(char.class,   short.class),  \"isIntToShortExact\");     \/\/ redirected\n+            typePairToName.put(new TypePairs(int.class,    byte.class),   \"isIntToByteExact\");\n+            typePairToName.put(new TypePairs(int.class,    short.class),  \"isIntToShortExact\");\n+            typePairToName.put(new TypePairs(int.class,    char.class),   \"isIntToCharExact\");\n+            typePairToName.put(new TypePairs(int.class,    float.class),  \"isIntToFloatExact\");\n+            typePairToName.put(new TypePairs(long.class,   byte.class),   \"isLongToByteExact\");\n+            typePairToName.put(new TypePairs(long.class,   short.class),  \"isLongToShortExact\");\n+            typePairToName.put(new TypePairs(long.class,   char.class),   \"isLongToCharExact\");\n+            typePairToName.put(new TypePairs(long.class,   int.class),    \"isLongToIntExact\");\n+            typePairToName.put(new TypePairs(long.class,   float.class),  \"isLongToFloatExact\");\n+            typePairToName.put(new TypePairs(long.class,   double.class), \"isLongToDoubleExact\");\n+            typePairToName.put(new TypePairs(float.class,  byte.class),   \"isFloatToByteExact\");\n+            typePairToName.put(new TypePairs(float.class,  short.class),  \"isFloatToShortExact\");\n+            typePairToName.put(new TypePairs(float.class,  char.class),   \"isFloatToCharExact\");\n+            typePairToName.put(new TypePairs(float.class,  int.class),    \"isFloatToIntExact\");\n+            typePairToName.put(new TypePairs(float.class,  long.class),   \"isFloatToLongExact\");\n+            typePairToName.put(new TypePairs(double.class, byte.class),   \"isDoubleToByteExact\");\n+            typePairToName.put(new TypePairs(double.class, short.class),  \"isDoubleToShortExact\");\n+            typePairToName.put(new TypePairs(double.class, char.class),   \"isDoubleToCharExact\");\n+            typePairToName.put(new TypePairs(double.class, int.class),    \"isDoubleToIntExact\");\n+            typePairToName.put(new TypePairs(double.class, long.class),   \"isDoubleToLongExact\");\n+            typePairToName.put(new TypePairs(double.class, float.class),  \"isDoubleToFloatExact\");\n+            return typePairToName;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":318,"deletions":138,"binary":false,"changes":456,"status":"modified"},{"patch":"@@ -392,0 +392,1 @@\n+        final String stringRepresentation;\n@@ -393,1 +394,3 @@\n-        public PathElementImpl(PathKind kind, UnaryOperator<LayoutPath> pathOp) {\n+        public PathElementImpl(PathKind kind,\n+                               UnaryOperator<LayoutPath> pathOp,\n+                               String stringRepresentation) {\n@@ -396,0 +399,1 @@\n+            this.stringRepresentation = stringRepresentation;\n@@ -406,0 +410,5 @@\n+\n+        @Override\n+        public String toString() {\n+            return stringRepresentation;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -115,0 +115,11 @@\n+    \/**\n+      * The annotation visitor to which this visitor must delegate method calls. May be {@literal\n+      * null}.\n+      *\n+      * @return the annotation visitor to which this visitor must delegate method calls, or {@literal\n+      *     null}.\n+      *\/\n+    public AnnotationVisitor getDelegate() {\n+        return av;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/AnnotationVisitor.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -406,1 +406,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ByteVector.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -410,1 +410,1 @@\n-      * Returns the internal of name of the super class (see {@link Type#getInternalName()}). For\n+      * Returns the internal name of the super class (see {@link Type#getInternalName()}). For\n@@ -2085,0 +2085,1 @@\n+            readBytecodeInstructionOffset(currentBytecodeOffset);\n@@ -2700,0 +2701,14 @@\n+    \/**\n+      * Handles the bytecode offset of the next instruction to be visited in {@link\n+      * #accept(ClassVisitor,int)}. This method is called just before the instruction and before its\n+      * associated label and stack map frame, if any. The default implementation of this method does\n+      * nothing. Subclasses can override this method to store the argument in a mutable field, for\n+      * instance, so that {@link MethodVisitor} instances can get the bytecode offset of each visited\n+      * instruction (if so, the usual concurrency issues related to mutable data should be addressed).\n+      *\n+      * @param bytecodeOffset the bytecode offset of the next instruction to be visited.\n+      *\/\n+    protected void readBytecodeInstructionOffset(final int bytecodeOffset) {\n+        \/\/ Do nothing by default.\n+    }\n+\n@@ -3885,1 +3900,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -77,1 +77,2 @@\n-      * @param className the internal name of the class.\n+      * @param className the internal name of the class (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -87,1 +88,1 @@\n-      * Returns the internal name of the class.\n+      * Returns the internal name of the class (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -104,1 +105,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassTooLargeException.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -114,0 +114,9 @@\n+    \/**\n+      * The class visitor to which this visitor must delegate method calls. May be {@literal null}.\n+      *\n+      * @return the class visitor to which this visitor must delegate method calls, or {@literal null}.\n+      *\/\n+    public ClassVisitor getDelegate() {\n+        return cv;\n+    }\n+\n@@ -188,1 +197,2 @@\n-      * @param nestHost the internal name of the host class of the nest.\n+      * @param nestHost the internal name of the host class of the nest (see {@link\n+      *     Type#getInternalName()}).\n@@ -200,2 +210,2 @@\n-      * Visits the enclosing class of the class. This method must be called only if the class has an\n-      * enclosing class.\n+      * Visits the enclosing class of the class. This method must be called only if this class is a\n+      * local or anonymous class. See the JVMS 4.7.7 section for more details.\n@@ -203,1 +213,2 @@\n-      * @param owner internal name of the enclosing class of the class.\n+      * @param owner internal name of the enclosing class of the class (see {@link\n+      *     Type#getInternalName()}).\n@@ -205,1 +216,3 @@\n-      *     not enclosed in a method of its enclosing class.\n+      *     not enclosed in a method or constructor of its enclosing class (e.g. if it is enclosed in\n+      *     an instance initializer, static initializer, instance variable initializer, or class\n+      *     variable initializer).\n@@ -207,1 +220,3 @@\n-      *     the class is not enclosed in a method of its enclosing class.\n+      *     the class is not enclosed in a method or constructor of its enclosing class (e.g. if it is\n+      *     enclosed in an instance initializer, static initializer, instance variable initializer, or\n+      *     class variable initializer).\n@@ -274,1 +289,1 @@\n-      * @param nestMember the internal name of a nest member.\n+      * @param nestMember the internal name of a nest member (see {@link Type#getInternalName()}).\n@@ -289,1 +304,2 @@\n-      * @param permittedSubclass the internal name of a permitted subclass.\n+      * @param permittedSubclass the internal name of a permitted subclass (see {@link\n+      *     Type#getInternalName()}).\n@@ -302,1 +318,4 @@\n-      * class being visited.\n+      * class being visited. More precisely, every class or interface C which is referenced by this\n+      * class and which is not a package member must be visited with this method. This class must\n+      * reference its nested class or interface members, and its enclosing class, if any. See the JVMS\n+      * 4.7.6 section for more details.\n@@ -304,7 +323,7 @@\n-      * @param name the internal name of an inner class (see {@link Type#getInternalName()}).\n-      * @param outerName the internal name of the class to which the inner class belongs (see {@link\n-      *     Type#getInternalName()}). May be {@literal null} for not member classes.\n-      * @param innerName the (simple) name of the inner class inside its enclosing class. May be\n-      *     {@literal null} for anonymous inner classes.\n-      * @param access the access flags of the inner class as originally declared in the enclosing\n-      *     class.\n+      * @param name the internal name of C (see {@link Type#getInternalName()}).\n+      * @param outerName the internal name of the class or interface C is a member of (see {@link\n+      *     Type#getInternalName()}). Must be {@literal null} if C is not the member of a class or\n+      *     interface (e.g. for local or anonymous classes).\n+      * @param innerName the (simple) name of C. Must be {@literal null} for anonymous inner classes.\n+      * @param access the access flags of C originally declared in the source code from which this\n+      *     class was compiled.\n@@ -408,1 +427,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassVisitor.java","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -252,0 +252,1 @@\n+      * MethodWriter#COMPUTE_MAX_STACK_AND_LOCAL_FROM_FRAMES}, {@link\n@@ -877,1 +878,1 @@\n-      * @param value the internal name of the class.\n+      * @param value the internal name of the class (see {@link Type#getInternalName()}).\n@@ -929,1 +930,2 @@\n-      * @param owner the internal name of the field or method owner class.\n+      * @param owner the internal name of the field or method owner class (see {@link\n+      *     Type#getInternalName()}).\n@@ -951,1 +953,2 @@\n-      * @param owner the internal name of the field or method owner class.\n+      * @param owner the internal name of the field or method owner class (see {@link\n+      *     Type#getInternalName()}).\n@@ -1013,1 +1016,1 @@\n-      * @param owner the internal name of the field's owner class.\n+      * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\n@@ -1027,1 +1030,2 @@\n-      * @param owner the internal name of the method's owner class.\n+      * @param owner the internal name of the method's owner class (see {@link\n+      *     Type#getInternalName()}).\n@@ -1063,3 +1067,4 @@\n-      * @param type1 the internal name of a class.\n-      * @param type2 the internal name of another class.\n-      * @return the internal name of the common super class of the two given classes.\n+      * @param type1 the internal name of a class (see {@link Type#getInternalName()}).\n+      * @param type2 the internal name of another class (see {@link Type#getInternalName()}).\n+      * @return the internal name of the common super class of the two given classes (see {@link\n+      *     Type#getInternalName()}).\n@@ -1108,1 +1113,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassWriter.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -211,1 +211,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ConstantDynamic.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -254,1 +254,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Constants.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -169,1 +169,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Context.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/CurrentFrame.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -124,1 +124,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Edge.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -111,0 +111,9 @@\n+    \/**\n+      * The field visitor to which this visitor must delegate method calls. May be {@literal null}.\n+      *\n+      * @return the field visitor to which this visitor must delegate method calls, or {@literal null}.\n+      *\/\n+    public FieldVisitor getDelegate() {\n+        return fv;\n+    }\n+\n@@ -171,1 +180,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/FieldVisitor.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -317,1 +317,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/FieldWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -99,2 +99,2 @@\n- *       #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND}, {@link #LOCAL_KIND}\n- *       or {@link #STACK_KIND}.\n+ *       #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND}, {@link\n+ *       #FORWARD_UNINITIALIZED_KIND},{@link #LOCAL_KIND} or {@link #STACK_KIND}.\n@@ -113,1 +113,4 @@\n- *             table of a SymbolTable, if KIND is equal to {@link #UNINITIALIZED_KIND}.\n+ *             table of a {@link SymbolTable}, if KIND is equal to {@link #UNINITIALIZED_KIND}.\n+ *         <li>the index of a {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG} {@link Symbol} in the\n+ *             type table of a {@link SymbolTable}, if KIND is equal to {@link\n+ *             #FORWARD_UNINITIALIZED_KIND}.\n@@ -123,4 +126,4 @@\n- * abstract type value). Input frames can only contain CONSTANT_KIND, REFERENCE_KIND or\n- * UNINITIALIZED_KIND abstract types of positive or {@literal null} array dimension. In all cases\n- * the type table contains only internal type names (array type descriptors are forbidden - array\n- * dimensions must be represented through the DIM field).\n+ * abstract type value). Input frames can only contain CONSTANT_KIND, REFERENCE_KIND,\n+ * UNINITIALIZED_KIND or FORWARD_UNINITIALIZED_KIND abstract types of positive or {@literal null}\n+ * array dimension. In all cases the type table contains only internal type names (array type\n+ * descriptors are forbidden - array dimensions must be represented through the DIM field).\n@@ -194,2 +197,3 @@\n-    private static final int LOCAL_KIND = 4 << KIND_SHIFT;\n-    private static final int STACK_KIND = 5 << KIND_SHIFT;\n+    private static final int FORWARD_UNINITIALIZED_KIND = 4 << KIND_SHIFT;\n+    private static final int LOCAL_KIND = 5 << KIND_SHIFT;\n+    private static final int STACK_KIND = 6 << KIND_SHIFT;\n@@ -255,7 +259,7 @@\n-      * UNINITIALIZED or UNINITIALIZED_THIS abstract type must replace <i>every occurrence<\/i> of this\n-      * type in the local variables and in the operand stack. This cannot be done during the first step\n-      * of the algorithm since, during this step, the local variables and the operand stack types are\n-      * still abstract. It is therefore necessary to store the abstract types of the constructors which\n-      * are invoked in the basic block, in order to do this replacement during the second step of the\n-      * algorithm, where the frames are fully computed. Note that this array can contain abstract types\n-      * that are relative to the input locals or to the input stack.\n+      * UNINITIALIZED, FORWARD_UNINITIALIZED or UNINITIALIZED_THIS abstract type must replace <i>every\n+      * occurrence<\/i> of this type in the local variables and in the operand stack. This cannot be\n+      * done during the first step of the algorithm since, during this step, the local variables and\n+      * the operand stack types are still abstract. It is therefore necessary to store the abstract\n+      * types of the constructors which are invoked in the basic block, in order to do this replacement\n+      * during the second step of the algorithm, where the frames are fully computed. Note that this\n+      * array can contain abstract types that are relative to the input locals or to the input stack.\n@@ -319,2 +323,6 @@\n-            return UNINITIALIZED_KIND\n-                    | symbolTable.addUninitializedType(\"\", ((Label) type).bytecodeOffset);\n+            Label label = (Label) type;\n+            if ((label.flags & Label.FLAG_RESOLVED) != 0) {\n+                return UNINITIALIZED_KIND | symbolTable.addUninitializedType(\"\", label.bytecodeOffset);\n+            } else {\n+                return FORWARD_UNINITIALIZED_KIND | symbolTable.addForwardUninitializedType(\"\", label);\n+            }\n@@ -402,1 +410,2 @@\n-                        throw new IllegalArgumentException();\n+                        throw new IllegalArgumentException(\n+                                \"Invalid descriptor fragment: \" + buffer.substring(elementDescriptorOffset));\n@@ -406,1 +415,1 @@\n-                throw new IllegalArgumentException();\n+                throw new IllegalArgumentException(\"Invalid descriptor: \" + buffer.substring(offset));\n@@ -614,1 +623,1 @@\n-            outputStackTop -= (short) elements;\n+            outputStackTop -= (short)elements;\n@@ -671,2 +680,3 @@\n-      *     UNINITIALIZED_THIS or an UNINITIALIZED_KIND abstract type for one of the types on which a\n-      *     constructor is invoked in the basic block. Otherwise returns abstractType.\n+      *     UNINITIALIZED_THIS or an UNINITIALIZED_KIND or FORWARD_UNINITIALIZED_KIND abstract type for\n+      *     one of the types on which a constructor is invoked in the basic block. Otherwise returns\n+      *     abstractType.\n@@ -676,1 +686,2 @@\n-                || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND) {\n+                || (abstractType & (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND\n+                || (abstractType & (DIM_MASK | KIND_MASK)) == FORWARD_UNINITIALIZED_KIND) {\n@@ -1287,2 +1298,3 @@\n-      *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND} or {@link\n-      *     #UNINITIALIZED_KIND} kind, with positive or {@literal null} array dimensions.\n+      *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link\n+      *     #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND} kind, with positive or\n+      *     {@literal null} array dimensions.\n@@ -1290,2 +1302,2 @@\n-      *     {@link #REFERENCE_KIND} or {@link #UNINITIALIZED_KIND} kind, with positive or {@literal\n-      *     null} array dimensions.\n+      *     {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND} or {@link #FORWARD_UNINITIALIZED_KIND}\n+      *     kind, with positive or {@literal null} array dimensions.\n@@ -1434,1 +1446,2 @@\n-      *     Frame#REFERENCE_KIND} or {@link Frame#UNINITIALIZED_KIND} types.\n+      *     Frame#REFERENCE_KIND}, {@link Frame#UNINITIALIZED_KIND} or {@link\n+      *     Frame#FORWARD_UNINITIALIZED_KIND} types.\n@@ -1456,0 +1469,4 @@\n+                case FORWARD_UNINITIALIZED_KIND:\n+                    output.putByte(ITEM_UNINITIALIZED);\n+                    symbolTable.getForwardUninitializedLabel(typeValue).put(output);\n+                    break;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Frame.java","additions":46,"deletions":29,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-      *     handle.\n+      *     handle (see {@link Type#getInternalName()}).\n@@ -119,1 +119,1 @@\n-      *     handle.\n+      *     handle (see {@link Type#getInternalName()}).\n@@ -152,1 +152,2 @@\n-      * @return the internal name of the class that owns the field or method designated by this handle.\n+      * @return the internal name of the class that owns the field or method designated by this handle\n+      *     (see {@link Type#getInternalName()}).\n@@ -221,1 +222,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Handle.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Handler.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -116,0 +116,3 @@\n+    \/** A flag indicating that this label has at least one associated line number. *\/\n+    static final int FLAG_LINE_NUMBER = 128;\n+\n@@ -148,0 +151,7 @@\n+    \/**\n+      * The type of forward references stored in two bytes in the <i>stack map table<\/i>. This is the\n+      * case of the labels of {@link Frame#ITEM_UNINITIALIZED} stack map frame elements, when the NEW\n+      * instruction is after the &lt;init&gt; constructor call (in bytecode offset order).\n+      *\/\n+    static final int FORWARD_REFERENCE_TYPE_STACK_MAP = 0x30000000;\n+\n@@ -180,3 +190,3 @@\n-      * The source line number corresponding to this label, or 0. If there are several source line\n-      * numbers corresponding to this label, the first one is stored in this field, and the remaining\n-      * ones are stored in {@link #otherLineNumbers}.\n+      * The source line number corresponding to this label, if {@link #FLAG_LINE_NUMBER} is set. If\n+      * there are several source line numbers corresponding to this label, the first one is stored in\n+      * this field, and the remaining ones are stored in {@link #otherLineNumbers}.\n@@ -367,1 +377,2 @@\n-        if (this.lineNumber == 0) {\n+        if ((flags & FLAG_LINE_NUMBER) == 0) {\n+            flags |= FLAG_LINE_NUMBER;\n@@ -391,1 +402,1 @@\n-        if (visitLineNumbers && lineNumber != 0) {\n+        if (visitLineNumbers && (flags & FLAG_LINE_NUMBER) != 0) {\n@@ -435,0 +446,14 @@\n+    \/**\n+      * Puts a reference to this label in the <i>stack map table<\/i> of a method. If the bytecode\n+      * offset of the label is known, it is written directly. Otherwise, a null relative offset is\n+      * written and a new forward reference is declared for this label.\n+      *\n+      * @param stackMapTableEntries the stack map table where the label offset must be added.\n+      *\/\n+    final void put(final ByteVector stackMapTableEntries) {\n+        if ((flags & FLAG_RESOLVED) == 0) {\n+            addForwardReference(0, FORWARD_REFERENCE_TYPE_STACK_MAP, stackMapTableEntries.length);\n+        }\n+        stackMapTableEntries.putShort(bytecodeOffset);\n+    }\n+\n@@ -467,1 +492,2 @@\n-      * where left in the bytecode by each forward reference previously added to this label.\n+      * where left in the bytecode (and optionally in the stack map table) by each forward reference\n+      * previously added to this label.\n@@ -470,0 +496,2 @@\n+      * @param stackMapTableEntries the 'entries' array of the StackMapTable code attribute of the\n+      *     method. Maybe {@literal null}.\n@@ -477,1 +505,2 @@\n-    final boolean resolve(final byte[] code, final int bytecodeOffset) {\n+    final boolean resolve(\n+            final byte[] code, final ByteVector stackMapTableEntries, final int bytecodeOffset) {\n@@ -507,1 +536,1 @@\n-            } else {\n+            } else if ((reference & FORWARD_REFERENCE_TYPE_MASK) == FORWARD_REFERENCE_TYPE_WIDE) {\n@@ -512,0 +541,3 @@\n+            } else {\n+                stackMapTableEntries.data[handle++] = (byte) (bytecodeOffset >>> 8);\n+                stackMapTableEntries.data[handle] = (byte) bytecodeOffset;\n@@ -655,1 +687,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Label.java","additions":40,"deletions":9,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-      * @param className the internal name of the owner class.\n+      * @param className the internal name of the owner class (see {@link Type#getInternalName()}).\n@@ -99,1 +99,1 @@\n-      * @return the internal name of the owner class.\n+      * @return the internal name of the owner class (see {@link Type#getInternalName()}).\n@@ -132,1 +132,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/MethodTooLargeException.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n- * {@code visitAnnotableParameterCount} | {@code visitParameterAnnotation} {@code\n+ * {@code visitAnnotableParameterCount} | {@code visitParameterAnnotation} | {@code\n@@ -127,0 +127,10 @@\n+    \/**\n+      * The method visitor to which this visitor must delegate method calls. May be {@literal null}.\n+      *\n+      * @return the method visitor to which this visitor must delegate method calls, or {@literal\n+      *     null}.\n+      *\/\n+    public MethodVisitor getDelegate() {\n+        return mv;\n+    }\n+\n@@ -153,1 +163,1 @@\n-      *     exacly one visit method must be called on this annotation visitor, followed by visitEnd.\n+      *     exactly one visit method must be called on this annotation visitor, followed by visitEnd.\n@@ -306,1 +316,2 @@\n-      * @param numLocal the number of local variables in the visited frame.\n+      * @param numLocal the number of local variables in the visited frame. Long and double values\n+      *     count for one variable.\n@@ -311,4 +322,5 @@\n-      *     Reference types are represented by String objects (representing internal names), and\n-      *     uninitialized types by Label objects (this label designates the NEW instruction that\n-      *     created this uninitialized value).\n-      * @param numStack the number of operand stack elements in the visited frame.\n+      *     Reference types are represented by String objects (representing internal names, see {@link\n+      *     Type#getInternalName()}), and uninitialized types by Label objects (this label designates\n+      *     the NEW instruction that created this uninitialized value).\n+      * @param numStack the number of operand stack elements in the visited frame. Long and double\n+      *     values count for one stack element.\n@@ -393,1 +405,1 @@\n-      * a class as parameter.\n+      * a class as parameter (see {@link Type#getInternalName()}).\n@@ -676,2 +688,3 @@\n-      * @param type the internal name of the type of exceptions handled by the handler, or {@literal\n-      *     null} to catch any exceptions (for \"finally\" blocks).\n+      * @param type the internal name of the type of exceptions handled by the handler (see {@link\n+      *     Type#getInternalName()}), or {@literal null} to catch any exceptions (for \"finally\"\n+      *     blocks).\n@@ -815,1 +828,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/MethodVisitor.java","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -569,2 +569,3 @@\n-      * but restricted to {@link Frame#CONSTANT_KIND}, {@link Frame#REFERENCE_KIND} or {@link\n-      * Frame#UNINITIALIZED_KIND} abstract types. Long and double types use only one array entry.\n+      * but restricted to {@link Frame#CONSTANT_KIND}, {@link Frame#REFERENCE_KIND}, {@link\n+      * Frame#UNINITIALIZED_KIND} or {@link Frame#FORWARD_UNINITIALIZED_KIND} abstract types. Long and\n+      * double types use only one array entry.\n@@ -728,1 +729,1 @@\n-                        new AnnotationWriter[Type.getArgumentTypes(descriptor).length];\n+                        new AnnotationWriter[Type.getArgumentCount(descriptor)];\n@@ -736,1 +737,1 @@\n-                        new AnnotationWriter[Type.getArgumentTypes(descriptor).length];\n+                        new AnnotationWriter[Type.getArgumentCount(descriptor)];\n@@ -1234,1 +1235,1 @@\n-        hasAsmInstructions |= label.resolve(code.data, code.length);\n+        hasAsmInstructions |= label.resolve(code.data, stackMapTableEntries, code.length);\n@@ -1247,1 +1248,1 @@\n-                    currentBasicBlock.flags |= (short) (label.flags & Label.FLAG_JUMP_TARGET);\n+                    currentBasicBlock.flags |= (short)(label.flags & Label.FLAG_JUMP_TARGET);\n@@ -1263,1 +1264,1 @@\n-                    lastBasicBlock.flags |= (short) (label.flags & Label.FLAG_JUMP_TARGET);\n+                    lastBasicBlock.flags |= (short)(label.flags & Label.FLAG_JUMP_TARGET);\n@@ -1830,1 +1831,1 @@\n-            nextBasicBlock.resolve(code.data, code.length);\n+            nextBasicBlock.resolve(code.data, stackMapTableEntries, code.length);\n@@ -2014,3 +2015,2 @@\n-            stackMapTableEntries\n-                    .putByte(Frame.ITEM_UNINITIALIZED)\n-                    .putShort(((Label) type).bytecodeOffset);\n+            stackMapTableEntries.putByte(Frame.ITEM_UNINITIALIZED);\n+            ((Label) type).put(stackMapTableEntries);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/MethodWriter.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -113,0 +113,10 @@\n+    \/**\n+      * The module visitor to which this visitor must delegate method calls. May be {@literal null}.\n+      *\n+      * @return the module visitor to which this visitor must delegate method calls, or {@literal\n+      *     null}.\n+      *\/\n+    public ModuleVisitor getDelegate() {\n+        return mv;\n+    }\n+\n@@ -116,1 +126,2 @@\n-      * @param mainClass the internal name of the main class of the current module.\n+      * @param mainClass the internal name of the main class of the current module (see {@link\n+      *     Type#getInternalName()}).\n@@ -127,1 +138,1 @@\n-      * @param packaze the internal name of a package.\n+      * @param packaze the internal name of a package (see {@link Type#getInternalName()}).\n@@ -152,1 +163,1 @@\n-      * @param packaze the internal name of the exported package.\n+      * @param packaze the internal name of the exported package (see {@link Type#getInternalName()}).\n@@ -167,1 +178,1 @@\n-      * @param packaze the internal name of the opened package.\n+      * @param packaze the internal name of the opened package (see {@link Type#getInternalName()}).\n@@ -183,1 +194,1 @@\n-      * @param service the internal name of the service.\n+      * @param service the internal name of the service (see {@link Type#getInternalName()}).\n@@ -194,3 +205,3 @@\n-      * @param service the internal name of the service.\n-      * @param providers the internal names of the implementations of the service (there is at least\n-      *     one provider).\n+      * @param service the internal name of the service (see {@link Type#getInternalName()}).\n+      * @param providers the internal names (see {@link Type#getInternalName()}) of the implementations\n+      *     of the service (there is at least one provider).\n@@ -214,1 +225,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ModuleVisitor.java","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -286,1 +286,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ModuleWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -591,1 +591,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    \/*package-private*\/ RecordComponentVisitor delegate;\n+    protected RecordComponentVisitor delegate;\n@@ -116,1 +116,2 @@\n-      * @return the record visitor to which this visitor must delegate method calls or {@literal null}.\n+      * @return the record visitor to which this visitor must delegate method calls, or {@literal\n+      *     null}.\n@@ -181,1 +182,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/RecordComponentVisitor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -258,1 +258,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/RecordComponentWriter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -138,1 +138,5 @@\n-      * The tag value of an {@link Frame#ITEM_UNINITIALIZED} type entry in the type table of a class.\n+      * The tag value of an uninitialized type entry in the type table of a class. This type is used\n+      * for the normal case where the NEW instruction is before the &lt;init&gt; constructor call (in\n+      * bytecode offset order), i.e. when the label of the NEW instruction is resolved when the\n+      * constructor call is visited. If the NEW instruction is after the constructor call, use the\n+      * {@link #FORWARD_UNINITIALIZED_TYPE_TAG} tag value instead.\n@@ -142,0 +146,9 @@\n+    \/**\n+      * The tag value of an uninitialized type entry in the type table of a class. This type is used\n+      * for the unusual case where the NEW instruction is after the &lt;init&gt; constructor call (in\n+      * bytecode offset order), i.e. when the label of the NEW instruction is not resolved when the\n+      * constructor call is visited. If the NEW instruction is before the constructor call, use the\n+      * {@link #UNINITIALIZED_TYPE_TAG} tag value instead.\n+      *\/\n+    static final int FORWARD_UNINITIALIZED_TYPE_TAG = 130;\n+\n@@ -143,1 +156,1 @@\n-    static final int MERGED_TYPE_TAG = 130;\n+    static final int MERGED_TYPE_TAG = 131;\n@@ -186,2 +199,2 @@\n-      *   <li>an internal class name for {@link #CONSTANT_CLASS_TAG}, {@link #TYPE_TAG} and {@link\n-      *       #UNINITIALIZED_TYPE_TAG} symbols,\n+      *   <li>an internal class name for {@link #CONSTANT_CLASS_TAG}, {@link #TYPE_TAG}, {@link\n+      *       #UNINITIALIZED_TYPE_TAG} and {@link #FORWARD_UNINITIALIZED_TYPE_TAG} symbols,\n@@ -207,0 +220,3 @@\n+      *   <li>the index of the {@link Label} (in the {@link SymbolTable#labelTable} table) of the NEW\n+      *       instruction that created an {@link Frame#ITEM_UNINITIALIZED} type for {@link\n+      *       #FORWARD_UNINITIALIZED_TYPE_TAG} symbols,\n@@ -276,1 +292,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Symbol.java","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -143,2 +143,3 @@\n-      * Symbol#TYPE_TAG} and {@link Symbol#UNINITIALIZED_TYPE_TAG}) Symbol. The type symbol at index\n-      * {@code i} has its {@link Symbol#index} equal to {@code i} (and vice versa).\n+      * Symbol#TYPE_TAG}, {@link Symbol#UNINITIALIZED_TYPE_TAG},{@link\n+      * Symbol#FORWARD_UNINITIALIZED_TYPE_TAG} and {@link Symbol#MERGED_TYPE_TAG} entries. The type\n+      * symbol at index {@code i} has its {@link Symbol#index} equal to {@code i} (and vice versa).\n@@ -148,0 +149,23 @@\n+    \/**\n+      * The actual number of {@link LabelEntry} in {@link #labelTable}. These elements are stored from\n+      * index 0 to labelCount (excluded). The other array entries are empty. These label entries are\n+      * also stored in the {@link #labelEntries} hash set.\n+      *\/\n+    private int labelCount;\n+\n+    \/**\n+      * The labels corresponding to the \"forward uninitialized\" types in the ASM specific {@link\n+      * typeTable} (see {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}). The label entry at index {@code\n+      * i} has its {@link LabelEntry#index} equal to {@code i} (and vice versa).\n+      *\/\n+    private LabelEntry[] labelTable;\n+\n+    \/**\n+      * A hash set of all the {@link LabelEntry} elements in the {@link #labelTable}. Each {@link\n+      * LabelEntry} instance is stored at the array index given by its hash code modulo the array size.\n+      * If several entries must be stored at the same array index, they are linked together via their\n+      * {@link LabelEntry#next} field. The {@link #getOrAddLabelEntry(Label)} method ensures that this\n+      * table does not contain duplicated entries.\n+      *\/\n+    private LabelEntry[] labelEntries;\n+\n@@ -1164,0 +1188,12 @@\n+    \/**\n+      * Returns the label corresponding to the \"forward uninitialized\" type table element whose index\n+      * is given.\n+      *\n+      * @param typeIndex the type table index of a \"forward uninitialized\" type table element.\n+      * @return the label corresponding of the NEW instruction which created this \"forward\n+      *     uninitialized\" type.\n+      *\/\n+    Label getForwardUninitializedLabel(final int typeIndex) {\n+        return labelTable[(int) typeTable[typeIndex].data].label;\n+    }\n+\n@@ -1184,2 +1220,2 @@\n-      * Adds an {@link Frame#ITEM_UNINITIALIZED} type in the type table of this symbol table. Does\n-      * nothing if the type table already contains a similar type.\n+      * Adds an uninitialized type in the type table of this symbol table. Does nothing if the type\n+      * table already contains a similar type.\n@@ -1188,3 +1224,3 @@\n-      * @param bytecodeOffset the bytecode offset of the NEW instruction that created this {@link\n-      *     Frame#ITEM_UNINITIALIZED} type value.\n-      * @return the index of a new or already existing type Symbol with the given value.\n+      * @param bytecodeOffset the bytecode offset of the NEW instruction that created this\n+      *     uninitialized type value.\n+      * @return the index of a new or already existing type #@link Symbol} with the given value.\n@@ -1208,0 +1244,26 @@\n+    \/**\n+      * Adds a \"forward uninitialized\" type in the type table of this symbol table. Does nothing if the\n+      * type table already contains a similar type.\n+      *\n+      * @param value an internal class name.\n+      * @param label the label of the NEW instruction that created this uninitialized type value. If\n+      *     the label is resolved, use the {@link #addUninitializedType} method instead.\n+      * @return the index of a new or already existing type {@link Symbol} with the given value.\n+      *\/\n+    int addForwardUninitializedType(final String value, final Label label) {\n+        int labelIndex = getOrAddLabelEntry(label).index;\n+        int hashCode = hash(Symbol.FORWARD_UNINITIALIZED_TYPE_TAG, value, labelIndex);\n+        Entry entry = get(hashCode);\n+        while (entry != null) {\n+            if (entry.tag == Symbol.FORWARD_UNINITIALIZED_TYPE_TAG\n+                    && entry.hashCode == hashCode\n+                    && entry.data == labelIndex\n+                    && entry.value.equals(value)) {\n+                return entry.index;\n+            }\n+            entry = entry.next;\n+        }\n+        return addTypeInternal(\n+                new Entry(typeCount, Symbol.FORWARD_UNINITIALIZED_TYPE_TAG, value, labelIndex, hashCode));\n+    }\n+\n@@ -1260,0 +1322,53 @@\n+    \/**\n+      * Returns the {@link LabelEntry} corresponding to the given label. Creates a new one if there is\n+      * no such entry.\n+      *\n+      * @param label the {@link Label} of a NEW instruction which created an uninitialized type, in the\n+      *     case where this NEW instruction is after the &lt;init&gt; constructor call (in bytecode\n+      *     offset order). See {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}.\n+      * @return the {@link LabelEntry} corresponding to {@code label}.\n+      *\/\n+    private LabelEntry getOrAddLabelEntry(final Label label) {\n+        if (labelEntries == null) {\n+            labelEntries = new LabelEntry[16];\n+            labelTable = new LabelEntry[16];\n+        }\n+        int hashCode = System.identityHashCode(label);\n+        LabelEntry labelEntry = labelEntries[hashCode % labelEntries.length];\n+        while (labelEntry != null && labelEntry.label != label) {\n+            labelEntry = labelEntry.next;\n+        }\n+        if (labelEntry != null) {\n+            return labelEntry;\n+        }\n+\n+        if (labelCount > (labelEntries.length * 3) \/ 4) {\n+            int currentCapacity = labelEntries.length;\n+            int newCapacity = currentCapacity * 2 + 1;\n+            LabelEntry[] newLabelEntries = new LabelEntry[newCapacity];\n+            for (int i = currentCapacity - 1; i >= 0; --i) {\n+                LabelEntry currentEntry = labelEntries[i];\n+                while (currentEntry != null) {\n+                    int newCurrentEntryIndex = System.identityHashCode(currentEntry.label) % newCapacity;\n+                    LabelEntry nextEntry = currentEntry.next;\n+                    currentEntry.next = newLabelEntries[newCurrentEntryIndex];\n+                    newLabelEntries[newCurrentEntryIndex] = currentEntry;\n+                    currentEntry = nextEntry;\n+                }\n+            }\n+            labelEntries = newLabelEntries;\n+        }\n+        if (labelCount == labelTable.length) {\n+            LabelEntry[] newLabelTable = new LabelEntry[2 * labelTable.length];\n+            System.arraycopy(labelTable, 0, newLabelTable, 0, labelTable.length);\n+            labelTable = newLabelTable;\n+        }\n+\n+        labelEntry = new LabelEntry(labelCount, label);\n+        int index = hashCode % labelEntries.length;\n+        labelEntry.next = labelEntries[index];\n+        labelEntries[index] = labelEntry;\n+        labelTable[labelCount++] = labelEntry;\n+        return labelEntry;\n+    }\n+\n@@ -1310,1 +1425,1 @@\n-    private static class Entry extends Symbol {\n+    private static final class Entry extends Symbol {\n@@ -1354,1 +1469,0 @@\n-}\n@@ -1356,0 +1470,26 @@\n+    \/**\n+      * A label corresponding to a \"forward uninitialized\" type in the ASM specific {@link\n+      * SymbolTable#typeTable} (see {@link Symbol#FORWARD_UNINITIALIZED_TYPE_TAG}).\n+      *\n+      * @author Eric Bruneton\n+      *\/\n+    private static final class LabelEntry {\n+\n+        \/** The index of this label entry in the {@link SymbolTable#labelTable} array. *\/\n+        final int index;\n+\n+        \/** The value of this label entry. *\/\n+        final Label label;\n+\n+        \/**\n+          * Another entry (and so on recursively) having the same hash code (modulo the size of {@link\n+          * SymbolTable#labelEntries}}) as this one.\n+          *\/\n+        LabelEntry next;\n+\n+        LabelEntry(final int index, final Label label) {\n+            this.index = index;\n+            this.label = label;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/SymbolTable.java","additions":149,"deletions":9,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-      * @param internalName an internal name.\n+      * @param internalName an internal name (see {@link Type#getInternalName()}).\n@@ -330,15 +330,1 @@\n-        int numArgumentTypes = 0;\n-        \/\/ Skip the first character, which is always a '('.\n-        int currentOffset = 1;\n-        \/\/ Parse the argument types, one at a each loop iteration.\n-        while (methodDescriptor.charAt(currentOffset) != ')') {\n-            while (methodDescriptor.charAt(currentOffset) == '[') {\n-                currentOffset++;\n-            }\n-            if (methodDescriptor.charAt(currentOffset++) == 'L') {\n-                \/\/ Skip the argument descriptor content.\n-                int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\n-                currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\n-            }\n-            ++numArgumentTypes;\n-        }\n+        int numArgumentTypes = getArgumentCount(methodDescriptor);\n@@ -349,1 +335,1 @@\n-        currentOffset = 1;\n+        int currentOffset = 1;\n@@ -737,0 +723,37 @@\n+    \/**\n+      * Returns the number of arguments of this method type. This method should only be used for method\n+      * types.\n+      *\n+      * @return the number of arguments of this method type. Each argument counts for 1, even long and\n+      *     double ones. The implicit @literal{this} argument is not counted.\n+      *\/\n+    public int getArgumentCount() {\n+        return getArgumentCount(getDescriptor());\n+    }\n+\n+    \/**\n+      * Returns the number of arguments in the given method descriptor.\n+      *\n+      * @param methodDescriptor a method descriptor.\n+      * @return the number of arguments in the given method descriptor. Each argument counts for 1,\n+      *     even long and double ones. The implicit @literal{this} argument is not counted.\n+      *\/\n+    public static int getArgumentCount(final String methodDescriptor) {\n+        int argumentCount = 0;\n+        \/\/ Skip the first character, which is always a '('.\n+        int currentOffset = 1;\n+        \/\/ Parse the argument types, one at a each loop iteration.\n+        while (methodDescriptor.charAt(currentOffset) != ')') {\n+            while (methodDescriptor.charAt(currentOffset) == '[') {\n+                currentOffset++;\n+            }\n+            if (methodDescriptor.charAt(currentOffset++) == 'L') {\n+                \/\/ Skip the argument descriptor content.\n+                int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);\n+                currentOffset = Math.max(currentOffset, semiColumnOffset + 1);\n+            }\n+            ++argumentCount;\n+        }\n+        return argumentCount;\n+    }\n+\n@@ -744,1 +767,2 @@\n-      *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}).\n+      *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}). Long and double values have size 2,\n+      *     the others have size 1.\n@@ -757,1 +781,2 @@\n-      *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}).\n+      *     i &gt;&gt; 2}, and returnSize to {@code i &amp; 0x03}). Long and double values have size 2,\n+      *     the others have size 1.\n@@ -928,1 +953,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Type.java","additions":44,"deletions":20,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -233,1 +233,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/TypePath.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -468,1 +468,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/TypeReference.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -703,1 +703,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/AdviceAdapter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,3 +95,4 @@\n-      * represented by String objects (representing internal names), and uninitialized types by Label\n-      * objects (this label designates the NEW instruction that created this uninitialized value). This\n-      * field is {@literal null} for unreachable instructions.\n+      * represented by String objects (representing internal names, see {@link\n+      * Type#getInternalName()}), and uninitialized types by Label objects (this label designates the\n+      * NEW instruction that created this uninitialized value). This field is {@literal null} for\n+      * unreachable instructions.\n@@ -106,3 +107,4 @@\n-      * represented by String objects (representing internal names), and uninitialized types by Label\n-      * objects (this label designates the NEW instruction that created this uninitialized value). This\n-      * field is {@literal null} for unreachable instructions.\n+      * represented by String objects (representing internal names, see {@link\n+      * Type#getInternalName()}), and uninitialized types by Label objects (this label designates the\n+      * NEW instruction that created this uninitialized value). This field is {@literal null} for\n+      * unreachable instructions.\n@@ -117,3 +119,3 @@\n-      * Label objects. Each label designates a NEW instruction that created the currently uninitialized\n-      * types, and the associated internal name represents the NEW operand, i.e. the final, initialized\n-      * type value.\n+      * Label objects (see {@link Type#getInternalName()}). Each label designates a NEW instruction\n+      * that created the currently uninitialized types, and the associated internal name represents the\n+      * NEW operand, i.e. the final, initialized type value.\n@@ -341,1 +343,1 @@\n-                    initializedValue = uninitializedTypes.get(value);\n+                    initializedValue = owner;\n@@ -941,1 +943,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/AnalyzerAdapter.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-      * internal name of the annotation is {@literal null}.\n+      * descriptor of the annotation is {@literal null}.\n@@ -242,1 +242,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/AnnotationRemapper.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -332,1 +332,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/ClassRemapper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -240,1 +240,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/CodeSizeEvaluator.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -147,1 +147,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/FieldRemapper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-      * @return the internal names of the given types.\n+      * @return the internal names of the given types (see {@link Type#getInternalName()}).\n@@ -1389,1 +1389,2 @@\n-      * @param exception internal name of the type of exceptions handled by the handler.\n+      * @param exception internal name of the type of exceptions handled by the handler (see {@link\n+      *     Type#getInternalName()}).\n@@ -1401,1 +1402,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/GeneratorAdapter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1097,1 +1097,2 @@\n-      * @param owner the internal name of the method's owner class.\n+      * @param owner the internal name of the method's owner class (see {@link\n+      *     Type#getInternalName()}).\n@@ -1135,1 +1136,2 @@\n-      * @param owner the internal name of the method's owner class.\n+      * @param owner the internal name of the method's owner class (see {@link\n+      *     Type#getInternalName()}).\n@@ -1173,1 +1175,2 @@\n-      * @param owner the internal name of the method's owner class.\n+      * @param owner the internal name of the method's owner class (see {@link\n+      *     Type#getInternalName()}).\n@@ -1332,1 +1335,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/InstructionAdapter.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -123,1 +123,2 @@\n-      * @param exceptions the internal names of the method's exception classes. May be {@literal null}.\n+      * @param exceptions the internal names of the method's exception classes (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n@@ -158,1 +159,2 @@\n-      * @param exceptions the internal names of the method's exception classes. May be {@literal null}.\n+      * @param exceptions the internal names of the method's exception classes (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n@@ -458,1 +460,1 @@\n-    private class Instantiation extends AbstractMap<LabelNode, LabelNode> {\n+    private final class Instantiation extends AbstractMap<LabelNode, LabelNode> {\n@@ -603,1 +605,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/JSRInlinerAdapter.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -384,1 +384,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/LocalVariablesSorter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -295,1 +295,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/Method.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -322,1 +322,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/MethodRemapper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -171,1 +171,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/ModuleHashesAttribute.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -153,1 +153,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/ModuleRemapper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -145,1 +145,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/ModuleResolutionAttribute.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -119,1 +119,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/ModuleTargetAttribute.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -150,1 +150,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/RecordComponentRemapper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-      *     descriptor is returned as is).\n+      *     descriptor is returned as is). See {@link Type#getInternalName()}.\n@@ -97,1 +97,1 @@\n-      *     #mapMethodDesc(String)}.\n+      *     #mapMethodDesc(String)}. See {@link Type#getInternalName()}.\n@@ -121,2 +121,4 @@\n-      * @param internalName the internal name (or array type descriptor) of some (array) class.\n-      * @return the given internal name, remapped with {@link #map(String)}.\n+      * @param internalName the internal name (or array type descriptor) of some (array) class (see\n+      *     {@link Type#getInternalName()}).\n+      * @return the given internal name, remapped with {@link #map(String)} (see {@link\n+      *     Type#getInternalName()}).\n@@ -134,2 +136,4 @@\n-      * @param internalNames the internal names (or array type descriptors) of some (array) classes.\n-      * @return the given internal name, remapped with {@link #map(String)}.\n+      * @param internalNames the internal names (or array type descriptors) of some (array) classes\n+      *     (see {@link Type#getInternalName()}).\n+      * @return the given internal name, remapped with {@link #map(String)} (see {@link\n+      *     Type#getInternalName()}).\n@@ -289,3 +293,5 @@\n-      * @param name the fully-qualified internal name of the inner class.\n-      * @param ownerName the internal name of the owner class of the inner class.\n-      * @param innerName the internal name of the inner class.\n+      * @param name the fully-qualified internal name of the inner class (see {@link\n+      *     Type#getInternalName()}).\n+      * @param ownerName the internal name of the owner class of the inner class (see {@link\n+      *     Type#getInternalName()}).\n+      * @param innerName the internal name of the inner class (see {@link Type#getInternalName()}).\n@@ -297,0 +303,14 @@\n+\n+        if (remappedInnerName.equals(name)) {\n+            return innerName;\n+        } else {\n+            int originSplit = name.lastIndexOf('\/');\n+            int remappedSplit = remappedInnerName.lastIndexOf('\/');\n+            if (originSplit != -1 && remappedSplit != -1) {\n+                if (name.substring(originSplit).equals(remappedInnerName.substring(remappedSplit))) {\n+                    \/\/ class name not changed\n+                    return innerName;\n+                }\n+            }\n+        }\n+\n@@ -313,1 +333,2 @@\n-      * @param owner the internal name of the owner class of the method.\n+      * @param owner the internal name of the owner class of the method (see {@link\n+      *     Type#getInternalName()}).\n@@ -338,1 +359,2 @@\n-      * @param owner the internal name of the owner class of the field.\n+      * @param owner the internal name of the owner class of the field (see {@link\n+      *     Type#getInternalName()}).\n@@ -352,1 +374,2 @@\n-      * @param owner the internal name of the owner class of the field.\n+      * @param owner the internal name of the owner class of the field (see {@link\n+      *     Type#getInternalName()}).\n@@ -387,2 +410,2 @@\n-      * @param internalName the internal name of a class.\n-      * @return the new internal name.\n+      * @param internalName the internal name of a class (see {@link Type#getInternalName()}).\n+      * @return the new internal name (see {@link Type#getInternalName()}).\n@@ -394,1 +417,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/Remapper.java","additions":37,"deletions":15,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -525,1 +525,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/SerialVersionUIDAdder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/SignatureRemapper.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-      *           internal name.\n+      *           internal name (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -100,1 +100,2 @@\n-      * @param newName the new method, field or internal name.\n+      * @param newName the new method, field or internal name (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -135,1 +136,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/SimpleRemapper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -157,1 +157,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/StaticInitMerger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/TableSwitchGenerator.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -158,1 +158,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/commons\/TryCatchBlockSorter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -285,1 +285,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/signature\/SignatureReader.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -214,1 +214,2 @@\n-      * @param name the internal name of the class or interface.\n+      * @param name the internal name of the class or interface (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -241,1 +242,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/signature\/SignatureVisitor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    private final StringBuilder stringBuilder = new StringBuilder();\n+    private final StringBuilder stringBuilder;\n@@ -86,2 +86,3 @@\n-      * a boolean encoded in one bit. The top of the stack is the least significant bit. Pushing false\n-      * = *2, pushing true = *2+1, popping = \/2.\n+      * a boolean encoded in one bit. The top of the stack is the least significant bit. The bottom of\n+      * the stack is a sentinel element always equal to 1 (used to detect when the stack is full).\n+      * Pushing false = {@code <<= 1}, pushing true = {@code ( <<= 1) | 1}, popping = {@code >>>= 1}.\n@@ -97,2 +98,2 @@\n-      * <p>we need a stack to properly balance these 'parentheses'. A new element is pushed on this\n-      * stack for each new visited type, and popped when the visit of this type ends (either is\n+      * <p>we need a stack to properly balance these angle brackets. A new element is pushed on this\n+      * stack for each new visited type, and popped when the visit of this type ends (either in\n@@ -101,1 +102,1 @@\n-    private int argumentStack;\n+    private int argumentStack = 1;\n@@ -105,0 +106,4 @@\n+        this(new StringBuilder());\n+    }\n+\n+    private SignatureWriter(final StringBuilder stringBuilder) {\n@@ -106,0 +111,1 @@\n+        this.stringBuilder = stringBuilder;\n@@ -194,1 +200,1 @@\n-        argumentStack *= 2;\n+        argumentStack <<= 1;\n@@ -204,1 +210,1 @@\n-        argumentStack *= 2;\n+        argumentStack <<= 1;\n@@ -212,1 +218,1 @@\n-        if (argumentStack % 2 == 0) {\n+        if ((argumentStack & 1) == 0) {\n@@ -224,1 +230,1 @@\n-        if (argumentStack % 2 == 0) {\n+        if ((argumentStack & 1) == 0) {\n@@ -231,1 +237,2 @@\n-        return this;\n+        \/\/ If the stack is full, start a nested one by returning a new SignatureWriter.\n+        return (argumentStack & (1 << 31)) == 0 ? this : new SignatureWriter(stringBuilder);\n@@ -267,1 +274,1 @@\n-        if (argumentStack % 2 == 1) {\n+        if ((argumentStack & 1) == 1) {\n@@ -270,1 +277,1 @@\n-        argumentStack \/= 2;\n+        argumentStack >>>= 1;\n@@ -273,1 +280,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/signature\/SignatureWriter.java","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -123,1 +123,4 @@\n-    \/** The opcode of this instruction. *\/\n+    \/**\n+      * The opcode of this instruction, or -1 if this is not a JVM instruction (e.g. a label or a line\n+      * number).\n+      *\/\n@@ -166,1 +169,2 @@\n-      * @return the opcode of this instruction.\n+      * @return the opcode of this instruction, or -1 if this is not a JVM instruction (e.g. a label or\n+      *     a line number).\n@@ -298,1 +302,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/AbstractInsnNode.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -263,1 +263,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/AnnotationNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    \/** The internal name of this class (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName}). *\/\n+    \/** The internal name of this class (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}). *\/\n@@ -100,1 +100,1 @@\n-      * The internal of name of the super class (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName}).\n+      * The internal of name of the super class (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -108,1 +108,1 @@\n-      * jdk.internal.org.objectweb.asm.Type#getInternalName}).\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -123,1 +123,5 @@\n-    \/** The internal name of the enclosing class of this class. May be {@literal null}. *\/\n+    \/**\n+      * The internal name of the enclosing class of this class (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}). Must be {@literal null} if this class has no\n+      * enclosing class, or if it is a local or anonymous class.\n+      *\/\n@@ -127,2 +131,4 @@\n-      * The name of the method that contains this class, or {@literal null} if this class is not\n-      * enclosed in a method.\n+      * The name of the method that contains the class, or {@literal null} if the class has no\n+      * enclosing class, or is not enclosed in a method or constructor of its enclosing class (e.g. if\n+      * it is enclosed in an instance initializer, static initializer, instance variable initializer,\n+      * or class variable initializer).\n@@ -133,2 +139,4 @@\n-      * The descriptor of the method that contains this class, or {@literal null} if this class is not\n-      * enclosed in a method.\n+      * The descriptor of the method that contains the class, or {@literal null} if the class has no\n+      * enclosing class, or is not enclosed in a method or constructor of its enclosing class (e.g. if\n+      * it is enclosed in an instance initializer, static initializer, instance variable initializer,\n+      * or class variable initializer).\n@@ -156,1 +164,4 @@\n-    \/** The internal name of the nest host class of this class. May be {@literal null}. *\/\n+    \/**\n+      * The internal name of the nest host class of this class (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *\/\n@@ -159,1 +170,4 @@\n-    \/** The internal names of the nest members of this class. May be {@literal null}. *\/\n+    \/**\n+      * The internal names of the nest members of this class (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *\/\n@@ -162,1 +176,4 @@\n-    \/** The internal names of the permitted subclasses of this class. May be {@literal null}. *\/\n+    \/**\n+      * The internal names of the permitted subclasses of this class (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *\/\n@@ -488,1 +505,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/ClassNode.java","additions":28,"deletions":12,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-      * jdk.internal.org.objectweb.asm.Type#getInternalName}).\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -91,1 +91,1 @@\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName}).\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -129,1 +129,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/FieldInsnNode.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -277,1 +277,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/FieldNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,1 +114,2 @@\n-      * @param numLocal number of local variables of this stack map frame.\n+      * @param numLocal number of local variables of this stack map frame. Long and double values count\n+      *     for one variable.\n@@ -117,2 +118,4 @@\n-      *     types respectively - see {@link MethodVisitor}).\n-      * @param numStack number of operand stack elements of this stack map frame.\n+      *     types respectively - see {@link MethodVisitor}). Long and double values are represented by\n+      *     a single element.\n+      * @param numStack number of operand stack elements of this stack map frame. Long and double\n+      *     values count for one stack element.\n@@ -121,1 +124,2 @@\n-      *     uninitialized types respectively - see {@link MethodVisitor}).\n+      *     uninitialized types respectively - see {@link MethodVisitor}). Long and double values are\n+      *     represented by a single element.\n@@ -221,1 +225,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/FrameNode.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/IincInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,1 +65,5 @@\n- * A node that represents an inner class.\n+ * A node that represents an inner class. This inner class is not necessarily a member of the {@link\n+ * ClassNode} containing this object. More precisely, every class or interface C which is referenced\n+ * by a {@link ClassNode} and which is not a package member must be represented with an {@link\n+ * InnerClassNode}. The {@link ClassNode} must reference its nested class or interface members, and\n+ * its enclosing class, if any. See the JVMS 4.7.6 section for more details.\n@@ -81,2 +85,2 @@\n-      * The (simple) name of the inner class inside its enclosing class. May be {@literal null} for\n-      * anonymous inner classes.\n+      * The (simple) name of the inner class inside its enclosing class. Must be {@literal null} if the\n+      * inner class is not the member of a class or interface (e.g. for local or anonymous classes).\n@@ -86,1 +90,4 @@\n-    \/** The access flags of the inner class as originally declared in the enclosing class. *\/\n+    \/**\n+      * The access flags of the inner class as originally declared in the source code from which the\n+      * class was compiled.\n+      *\/\n@@ -90,1 +97,1 @@\n-      * Constructs a new {@link InnerClassNode}.\n+      * Constructs a new {@link InnerClassNode} for an inner class C.\n@@ -92,8 +99,7 @@\n-      * @param name the internal name of an inner class (see {@link\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n-      * @param outerName the internal name of the class to which the inner class belongs (see {@link\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n-      * @param innerName the (simple) name of the inner class inside its enclosing class. May be\n-      *     {@literal null} for anonymous inner classes.\n-      * @param access the access flags of the inner class as originally declared in the enclosing\n-      *     class.\n+      * @param name the internal name of C (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      * @param outerName the internal name of the class or interface C is a member of (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). Must be {@literal null} if C is not the member\n+      *     of a class or interface (e.g. for local or anonymous classes).\n+      * @param innerName the (simple) name of C. Must be {@literal null} for anonymous inner classes.\n+      * @param access the access flags of C originally declared in the source code from which this\n+      *     class was compiled.\n@@ -118,1 +124,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/InnerClassNode.java","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -637,1 +637,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/InsnList.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/InsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/IntInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-            final Object... bootstrapMethodArguments) { \/\/ NOPMD(ArrayIsStoredDirectly): public field.\n+            final Object... bootstrapMethodArguments) {\n@@ -106,1 +106,1 @@\n-        this.bsmArgs = bootstrapMethodArguments;\n+        this.bsmArgs = bootstrapMethodArguments; \/\/ NOPMD(ArrayIsStoredDirectly): public field.\n@@ -125,1 +125,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/InvokeDynamicInsnNode.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/JumpInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/LabelNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -116,1 +116,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/LdcInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/LineNumberNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -172,1 +172,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/LocalVariableAnnotationNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -125,1 +125,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/LocalVariableNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/LookupSwitchInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -156,1 +156,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/MethodInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-                int params = Type.getArgumentTypes(desc).length;\n+                int params = Type.getArgumentCount(desc);\n@@ -336,1 +336,1 @@\n-                int params = Type.getArgumentTypes(desc).length;\n+                int params = Type.getArgumentCount(desc);\n@@ -805,1 +805,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/MethodNode.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -72,1 +72,4 @@\n-    \/** The internal name of the exported package. *\/\n+    \/**\n+      * The internal name of the exported package (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      *\/\n@@ -90,1 +93,2 @@\n-      * @param packaze the internal name of the exported package.\n+      * @param packaze the internal name of the exported package (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -112,1 +116,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/ModuleExportNode.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -87,1 +87,4 @@\n-    \/** The internal name of the main class of this module. May be {@literal null}. *\/\n+    \/**\n+      * The internal name of the main class of this module (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *\/\n@@ -90,1 +93,4 @@\n-    \/** The internal name of the packages declared by this module. May be {@literal null}. *\/\n+    \/**\n+      * The internal name of the packages declared by this module (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *\/\n@@ -102,1 +108,4 @@\n-    \/** The internal names of the services used by this module. May be {@literal null}. *\/\n+    \/**\n+      * The internal names of the services used by this module (see {@link\n+      * jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *\/\n@@ -141,1 +150,2 @@\n-      * @param uses The internal names of the services used by this module. May be {@literal null}.\n+      * @param uses The internal names of the services used by this module (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n@@ -268,1 +278,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/ModuleNode.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -72,1 +72,3 @@\n-    \/** The internal name of the opened package. *\/\n+    \/**\n+      * The internal name of the opened package (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      *\/\n@@ -90,1 +92,2 @@\n-      * @param packaze the internal name of the opened package.\n+      * @param packaze the internal name of the opened package (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -112,1 +115,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/ModuleOpenNode.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    \/** The internal name of the service. *\/\n+    \/** The internal name of the service (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}). *\/\n@@ -75,1 +75,4 @@\n-    \/** The internal names of the implementations of the service (there is at least one provider). *\/\n+    \/**\n+      * The internal names of the implementations of the service (there is at least one provider). See\n+      * {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}.\n+      *\/\n@@ -83,1 +86,1 @@\n-      *     one provider).\n+      *     one provider). See {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}.\n@@ -99,1 +102,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/ModuleProvideNode.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/ModuleRequireNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/MultiANewArrayInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -101,1 +101,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/ParameterNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -237,1 +237,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/RecordComponentNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/TableSwitchInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -101,2 +101,3 @@\n-      * @param type the internal name of the type of exceptions handled by the handler, or {@literal\n-      *     null} to catch any exceptions (for \"finally\" blocks).\n+      * @param type the internal name of the type of exceptions handled by the handler (see {@link\n+      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}), or {@literal null} to catch any exceptions (for\n+      *     \"finally\" blocks).\n@@ -159,1 +160,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/TryCatchBlockNode.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -118,1 +118,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/TypeAnnotationNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,2 +66,2 @@\n- * A node that represents a type instruction. A type instruction is an instruction that takes a type\n- * descriptor as parameter.\n+ * A node that represents a type instruction. A type instruction is an instruction which takes an\n+ * internal name as parameter (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -74,2 +74,2 @@\n-      * The operand of this instruction. This operand is an internal name (see {@link\n-      * jdk.internal.org.objectweb.asm.Type}).\n+      * The operand of this instruction. Despite its name (due to historical reasons), this operand is\n+      * an internal name (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -84,2 +84,2 @@\n-      * @param descriptor the operand of the instruction to be constructed. This operand is an internal\n-      *     name (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param type the operand of the instruction to be constructed. This operand is an internal name\n+      *     (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n@@ -87,1 +87,1 @@\n-    public TypeInsnNode(final int opcode, final String descriptor) {\n+    public TypeInsnNode(final int opcode, final String type) {\n@@ -89,1 +89,1 @@\n-        this.desc = descriptor;\n+        this.desc = type;\n@@ -118,1 +118,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/TypeInsnNode.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/UnsupportedClassVersionException.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -196,1 +196,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/Util.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -115,1 +115,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/VarInsnNode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n- * @param <V> type of the Value used for the analysis.\n+ * @param <V> type of the {@link Value} used for the analysis.\n@@ -127,1 +127,2 @@\n-      * @param owner the internal name of the class to which 'method' belongs.\n+      * @param owner the internal name of the class to which 'method' belongs (see {@link\n+      *     Type#getInternalName()}).\n@@ -157,1 +158,1 @@\n-            for (int j = startIndex; j < endIndex; ++j) {\n+            for (int j = startIndex; j <= endIndex; ++j) {\n@@ -167,26 +168,2 @@\n-        \/\/ For each instruction, compute the subroutine to which it belongs.\n-        \/\/ Follow the main 'subroutine', and collect the jsr instructions to nested subroutines.\n-        Subroutine main = new Subroutine(null, method.maxLocals, null);\n-        List<AbstractInsnNode> jsrInsns = new ArrayList<>();\n-        findSubroutine(0, main, jsrInsns);\n-        \/\/ Follow the nested subroutines, and collect their own nested subroutines, until all\n-        \/\/ subroutines are found.\n-        Map<LabelNode, Subroutine> jsrSubroutines = new HashMap<>();\n-        while (!jsrInsns.isEmpty()) {\n-            JumpInsnNode jsrInsn = (JumpInsnNode) jsrInsns.remove(0);\n-            Subroutine subroutine = jsrSubroutines.get(jsrInsn.label);\n-            if (subroutine == null) {\n-                subroutine = new Subroutine(jsrInsn.label, method.maxLocals, jsrInsn);\n-                jsrSubroutines.put(jsrInsn.label, subroutine);\n-                findSubroutine(insnList.indexOf(jsrInsn.label), subroutine, jsrInsns);\n-            } else {\n-                subroutine.callers.add(jsrInsn);\n-            }\n-        }\n-        \/\/ Clear the main 'subroutine', which is not a real subroutine (and was used only as an\n-        \/\/ intermediate step above to find the real ones).\n-        for (int i = 0; i < insnListSize; ++i) {\n-            if (subroutines[i] != null && subroutines[i].start == null) {\n-                subroutines[i] = null;\n-            }\n-        }\n+        \/\/ Finds the method's subroutines.\n+        findSubroutines(method.maxLocals);\n@@ -195,3 +172,9 @@\n-        Frame<V> currentFrame = computeInitialFrame(owner, method);\n-        merge(0, currentFrame, null);\n-        init(owner, method);\n+        Frame<V> currentFrame;\n+        try {\n+            currentFrame = computeInitialFrame(owner, method);\n+            merge(0, currentFrame, null);\n+            init(owner, method);\n+        } catch (RuntimeException e) {\n+            \/\/ DontCheck(IllegalCatch): can't be fixed, for backward compatibility.\n+            throw new AnalyzerException(insnList.get(0), \"Error at instruction 0: \" + e.getMessage(), e);\n+        }\n@@ -339,1 +322,2 @@\n-      * @param owner the internal name of the class to which 'method' belongs.\n+      * @param owner the internal name of the class to which 'method' belongs (see {@link\n+      *     Type#getInternalName()}).\n@@ -364,0 +348,3 @@\n+        if ((method.access & Opcodes.ACC_STATIC) != 0) {\n+            maxLocals -= 1;\n+        }\n@@ -403,0 +390,36 @@\n+    \/**\n+      * Finds the subroutines of the currently analyzed method and stores them in {@link #subroutines}.\n+      *\n+      * @param maxLocals the maximum number of local variables of the currently analyzed method (long\n+      *     and double values count for two variables).\n+      * @throws AnalyzerException if the control flow graph can fall off the end of the code.\n+      *\/\n+    private void findSubroutines(final int maxLocals) throws AnalyzerException {\n+        \/\/ For each instruction, compute the subroutine to which it belongs.\n+        \/\/ Follow the main 'subroutine', and collect the jsr instructions to nested subroutines.\n+        Subroutine main = new Subroutine(null, maxLocals, null);\n+        List<AbstractInsnNode> jsrInsns = new ArrayList<>();\n+        findSubroutine(0, main, jsrInsns);\n+        \/\/ Follow the nested subroutines, and collect their own nested subroutines, until all\n+        \/\/ subroutines are found.\n+        Map<LabelNode, Subroutine> jsrSubroutines = new HashMap<>();\n+        while (!jsrInsns.isEmpty()) {\n+            JumpInsnNode jsrInsn = (JumpInsnNode) jsrInsns.remove(0);\n+            Subroutine subroutine = jsrSubroutines.get(jsrInsn.label);\n+            if (subroutine == null) {\n+                subroutine = new Subroutine(jsrInsn.label, maxLocals, jsrInsn);\n+                jsrSubroutines.put(jsrInsn.label, subroutine);\n+                findSubroutine(insnList.indexOf(jsrInsn.label), subroutine, jsrInsns);\n+            } else {\n+                subroutine.callers.add(jsrInsn);\n+            }\n+        }\n+        \/\/ Clear the main 'subroutine', which is not a real subroutine (and was used only as an\n+        \/\/ intermediate step above to find the real ones).\n+        for (int i = 0; i < insnListSize; ++i) {\n+            if (subroutines[i] != null && subroutines[i].start == null) {\n+                subroutines[i] = null;\n+            }\n+        }\n+    }\n+\n@@ -488,1 +511,2 @@\n-      * @param owner the internal name of the class to which 'method' belongs.\n+      * @param owner the internal name of the class to which 'method' belongs (see {@link\n+      *     Type#getInternalName()}).\n@@ -545,1 +569,1 @@\n-      * analysis loop in #analyze. The default implementation of this method does nothing.\n+      * analysis loop in {@link #analyze}. The default implementation of this method does nothing.\n@@ -547,1 +571,2 @@\n-      * @param owner the internal name of the class to which the method belongs.\n+      * @param owner the internal name of the class to which the method belongs (see {@link\n+      *     Type#getInternalName()}).\n@@ -705,1 +730,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/Analyzer.java","additions":61,"deletions":37,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/AnalyzerException.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -408,1 +408,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/BasicInterpreter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -162,1 +162,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/BasicValue.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -483,1 +483,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/BasicVerifier.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -707,1 +707,1 @@\n-        for (int i = Type.getArgumentTypes(methodDescriptor).length; i > 0; --i) {\n+        for (int i = Type.getArgumentCount(methodDescriptor); i > 0; --i) {\n@@ -785,1 +785,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/Frame.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -300,1 +300,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/Interpreter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -414,1 +414,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/SimpleVerifier.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/SmallSet.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -253,1 +253,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/SourceInterpreter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,1 +152,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/SourceValue.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -139,1 +139,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/Subroutine.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/tree\/analysis\/Value.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n- * A {@link Printer} that prints the ASM code to generate the classes if visits.\n+ * A {@link Printer} that prints the ASM code to generate the classes it visits.\n@@ -144,0 +144,4 @@\n+        classVersions.put(Opcodes.V20, \"V20\");\n+        classVersions.put(Opcodes.V21, \"V21\");\n+        classVersions.put(Opcodes.V22, \"V22\");\n+        classVersions.put(Opcodes.V23, \"V23\");\n@@ -1644,1 +1648,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/ASMifier.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -84,1 +84,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/ASMifierSupport.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -168,1 +168,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckAnnotationAdapter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -499,1 +499,2 @@\n-                        new CheckMethodAdapter.MethodWriterWrapper(api, (ClassWriter) cv, methodVisitor);\n+                        new CheckMethodAdapter.MethodWriterWrapper(\n+                                api, version, (ClassWriter) cv, methodVisitor);\n@@ -1169,1 +1170,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckClassAdapter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -149,1 +149,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckFieldAdapter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,513 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, the following notice accompanied the original version of this\n+ * file:\n+ *\n+ * ASM: a very small and fast Java bytecode manipulation framework\n+ * Copyright (c) 2000-2011 INRIA, France Telecom\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and\/or other materials provided with the distribution.\n+ * 3. Neither the name of the copyright holders nor the names of its\n+ *    contributors may be used to endorse or promote products derived from\n+ *    this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+\n+package jdk.internal.org.objectweb.asm.util;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.Type;\n+import jdk.internal.org.objectweb.asm.tree.AbstractInsnNode;\n+import jdk.internal.org.objectweb.asm.tree.FrameNode;\n+import jdk.internal.org.objectweb.asm.tree.InsnList;\n+import jdk.internal.org.objectweb.asm.tree.InsnNode;\n+import jdk.internal.org.objectweb.asm.tree.JumpInsnNode;\n+import jdk.internal.org.objectweb.asm.tree.LabelNode;\n+import jdk.internal.org.objectweb.asm.tree.LookupSwitchInsnNode;\n+import jdk.internal.org.objectweb.asm.tree.MethodNode;\n+import jdk.internal.org.objectweb.asm.tree.TableSwitchInsnNode;\n+import jdk.internal.org.objectweb.asm.tree.TryCatchBlockNode;\n+import jdk.internal.org.objectweb.asm.tree.TypeInsnNode;\n+import jdk.internal.org.objectweb.asm.tree.analysis.Analyzer;\n+import jdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException;\n+import jdk.internal.org.objectweb.asm.tree.analysis.Frame;\n+import jdk.internal.org.objectweb.asm.tree.analysis.Interpreter;\n+import jdk.internal.org.objectweb.asm.tree.analysis.Value;\n+\n+\/**\n+ * An {@link Analyzer} subclass which checks that methods provide stack map frames where expected\n+ * (i.e. at jump target and after instructions without immediate successor), and that these stack\n+ * map frames are valid (for the provided interpreter; they may still be invalid for the JVM, if the\n+ * {@link Interpreter} uses a simplified type system compared to the JVM verifier). This is done in\n+ * two steps:\n+ *\n+ * <ul>\n+ *   <li>First, the stack map frames in {@link FrameNode}s are expanded, and stored at their\n+ *       respective instruction offsets. The expansion process uncompresses the APPEND, CHOP and\n+ *       SAME frames to FULL frames. It also converts the stack map frame verification types to\n+ *       {@link Value}s, via the provided {@link Interpreter}. The expansion is done in {@link\n+ *       #expandFrames}, by looking at each {@link FrameNode} in sequence (compressed frames are\n+ *       defined relatively to the previous {@link FrameNode}, or the implicit first frame). The\n+ *       actual decompression is done in {@link #expandFrame}, and the type conversion in {@link\n+ *       #newFrameValue}.\n+ *   <li>Next, the method instructions are checked in sequence. Starting from the implicit initial\n+ *       frame, the execution of each instruction <em>i<\/em> is simulated on the current stack map\n+ *       frame, with the {@link Frame#execute} method. This gives a new stack map frame <em>f<\/em>,\n+ *       representing the stack map frame state after the execution of <em>i<\/em>. Then:\n+ *       <ul>\n+ *         <li>If there is a next instruction and if the control flow cannot continue to it (e.g. if\n+ *             <em>i<\/em> is a RETURN or an ATHROW, for instance): an existing stack map frame\n+ *             <em>f0<\/em> (coming from the first step) is expected after <em>i<\/em>.\n+ *         <li>If there is a next instruction and if the control flow can continue to it (e.g. if\n+ *             <em>i<\/em> is a ALOAD, for instance): either there an existing stack map frame\n+ *             <em>f0<\/em> (coming from the first step) after <em>i<\/em>, or there is none. In the\n+ *             first case <em>f<\/em> and <em>f0<\/em> must be <em>compatible<\/em>: the types in\n+ *             <em>f<\/em> must be sub types of the corresponding types in the existing frame\n+ *             <em>f0<\/em> (otherwise an exception is thrown). In the second case, <em>f0<\/em> is\n+ *             simply set to the value of <em>f<\/em>.\n+ *         <li>If the control flow can continue to some instruction <em>j<\/em> (e.g. if <em>i<\/em>\n+ *             is an IF_EQ, for instance): an existing stack map frame <em>f0<\/em> (coming from the\n+ *             first step) is expected at <em>j<\/em>, which must be compatible with <em>f<\/em> (as\n+ *             defined previously).\n+ *       <\/ul>\n+ *       The sequential loop over the instructions is done in {@link #init}, which is called from\n+ *       the {@link Analyzer#analyze} method. Cases where the control flow cannot continue to the\n+ *       next instruction are handled in {@link #endControlFlow}. Cases where the control flow can\n+ *       continue to the next instruction, or jump to another instruction, are handled in {@link\n+ *       #checkFrame}. This method checks that an existing stack map frame is present when required,\n+ *       and checks the stack map frames compatibility with {@link #checkMerge}.\n+ * <\/ul>\n+ *\n+ * @author Eric Bruneton\n+ * @param <V> type of the {@link Value} used for the analysis.\n+ *\/\n+class CheckFrameAnalyzer<V extends Value> extends Analyzer<V> {\n+\n+    \/** The interpreter to use to symbolically interpret the bytecode instructions. *\/\n+    private final Interpreter<V> interpreter;\n+\n+    \/** The instructions of the currently analyzed method. *\/\n+    private InsnList insnList;\n+\n+    \/**\n+      * The number of locals in the last stack map frame processed by {@link expandFrame}. Long and\n+      * double values are represented with two elements.\n+      *\/\n+    private int currentLocals;\n+\n+    CheckFrameAnalyzer(final Interpreter<V> interpreter) {\n+        super(interpreter);\n+        this.interpreter = interpreter;\n+    }\n+\n+    @Override\n+    protected void init(final String owner, final MethodNode method) throws AnalyzerException {\n+        insnList = method.instructions;\n+        currentLocals = Type.getArgumentsAndReturnSizes(method.desc) >> 2;\n+        if ((method.access & Opcodes.ACC_STATIC) != 0) {\n+            currentLocals -= 1;\n+        }\n+\n+        Frame<V>[] frames = getFrames();\n+        Frame<V> currentFrame = frames[0];\n+        expandFrames(owner, method, currentFrame);\n+        for (int insnIndex = 0; insnIndex < insnList.size(); ++insnIndex) {\n+            Frame<V> oldFrame = frames[insnIndex];\n+\n+            \/\/ Simulate the execution of this instruction.\n+            AbstractInsnNode insnNode = null;\n+            try {\n+                insnNode = method.instructions.get(insnIndex);\n+                int insnOpcode = insnNode.getOpcode();\n+                int insnType = insnNode.getType();\n+\n+                if (insnType == AbstractInsnNode.LABEL\n+                        || insnType == AbstractInsnNode.LINE\n+                        || insnType == AbstractInsnNode.FRAME) {\n+                    checkFrame(insnIndex + 1, oldFrame, \/* requireFrame = *\/ false);\n+                } else {\n+                    currentFrame.init(oldFrame).execute(insnNode, interpreter);\n+\n+                    if (insnNode instanceof JumpInsnNode) {\n+                        if (insnOpcode == JSR) {\n+                            throw new AnalyzerException(insnNode, \"JSR instructions are unsupported\");\n+                        }\n+                        JumpInsnNode jumpInsn = (JumpInsnNode) insnNode;\n+                        int targetInsnIndex = insnList.indexOf(jumpInsn.label);\n+                        checkFrame(targetInsnIndex, currentFrame, \/* requireFrame = *\/ true);\n+                        if (insnOpcode == GOTO) {\n+                            endControlFlow(insnIndex);\n+                        } else {\n+                            checkFrame(insnIndex + 1, currentFrame, \/* requireFrame = *\/ false);\n+                        }\n+                    } else if (insnNode instanceof LookupSwitchInsnNode) {\n+                        LookupSwitchInsnNode lookupSwitchInsn = (LookupSwitchInsnNode) insnNode;\n+                        int targetInsnIndex = insnList.indexOf(lookupSwitchInsn.dflt);\n+                        checkFrame(targetInsnIndex, currentFrame, \/* requireFrame = *\/ true);\n+                        for (int i = 0; i < lookupSwitchInsn.labels.size(); ++i) {\n+                            LabelNode label = lookupSwitchInsn.labels.get(i);\n+                            targetInsnIndex = insnList.indexOf(label);\n+                            currentFrame.initJumpTarget(insnOpcode, label);\n+                            checkFrame(targetInsnIndex, currentFrame, \/* requireFrame = *\/ true);\n+                        }\n+                        endControlFlow(insnIndex);\n+                    } else if (insnNode instanceof TableSwitchInsnNode) {\n+                        TableSwitchInsnNode tableSwitchInsn = (TableSwitchInsnNode) insnNode;\n+                        int targetInsnIndex = insnList.indexOf(tableSwitchInsn.dflt);\n+                        currentFrame.initJumpTarget(insnOpcode, tableSwitchInsn.dflt);\n+                        checkFrame(targetInsnIndex, currentFrame, \/* requireFrame = *\/ true);\n+                        newControlFlowEdge(insnIndex, targetInsnIndex);\n+                        for (int i = 0; i < tableSwitchInsn.labels.size(); ++i) {\n+                            LabelNode label = tableSwitchInsn.labels.get(i);\n+                            currentFrame.initJumpTarget(insnOpcode, label);\n+                            targetInsnIndex = insnList.indexOf(label);\n+                            checkFrame(targetInsnIndex, currentFrame, \/* requireFrame = *\/ true);\n+                        }\n+                        endControlFlow(insnIndex);\n+                    } else if (insnOpcode == RET) {\n+                        throw new AnalyzerException(insnNode, \"RET instructions are unsupported\");\n+                    } else if (insnOpcode != ATHROW && (insnOpcode < IRETURN || insnOpcode > RETURN)) {\n+                        checkFrame(insnIndex + 1, currentFrame, \/* requireFrame = *\/ false);\n+                    } else {\n+                        endControlFlow(insnIndex);\n+                    }\n+                }\n+\n+                List<TryCatchBlockNode> insnHandlers = getHandlers(insnIndex);\n+                if (insnHandlers != null) {\n+                    for (TryCatchBlockNode tryCatchBlock : insnHandlers) {\n+                        Type catchType;\n+                        if (tryCatchBlock.type == null) {\n+                            catchType = Type.getObjectType(\"java\/lang\/Throwable\");\n+                        } else {\n+                            catchType = Type.getObjectType(tryCatchBlock.type);\n+                        }\n+                        Frame<V> handler = newFrame(oldFrame);\n+                        handler.clearStack();\n+                        handler.push(interpreter.newExceptionValue(tryCatchBlock, handler, catchType));\n+                        checkFrame(insnList.indexOf(tryCatchBlock.handler), handler, \/* requireFrame = *\/ true);\n+                    }\n+                }\n+\n+                if (!hasNextJvmInsnOrFrame(insnIndex)) {\n+                    break;\n+                }\n+            } catch (AnalyzerException e) {\n+                throw new AnalyzerException(\n+                        e.node, \"Error at instruction \" + insnIndex + \": \" + e.getMessage(), e);\n+            } catch (RuntimeException e) {\n+                \/\/ DontCheck(IllegalCatch): can't be fixed, for backward compatibility.\n+                throw new AnalyzerException(\n+                        insnNode, \"Error at instruction \" + insnIndex + \": \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+      * Expands the {@link FrameNode} \"instructions\" of the given method into {@link Frame} objects and\n+      * stores them at the corresponding indices of the {@link #frames} array. The expanded frames are\n+      * also associated with the label and line number nodes immediately preceding each frame node.\n+      *\n+      * @param owner the internal name of the class to which 'method' belongs.\n+      * @param method the method whose frames must be expanded.\n+      * @param initialFrame the implicit initial frame of 'method'.\n+      * @throws AnalyzerException if the stack map frames of 'method', i.e. its FrameNode\n+      *     \"instructions\", are invalid.\n+      *\/\n+    private void expandFrames(\n+            final String owner, final MethodNode method, final Frame<V> initialFrame)\n+            throws AnalyzerException {\n+        int lastJvmOrFrameInsnIndex = -1;\n+        Frame<V> currentFrame = initialFrame;\n+        int currentInsnIndex = 0;\n+        for (AbstractInsnNode insnNode : method.instructions) {\n+            if (insnNode instanceof FrameNode) {\n+                try {\n+                    currentFrame = expandFrame(owner, currentFrame, (FrameNode) insnNode);\n+                } catch (AnalyzerException e) {\n+                    throw new AnalyzerException(\n+                            e.node, \"Error at instruction \" + currentInsnIndex + \": \" + e.getMessage(), e);\n+                }\n+                for (int index = lastJvmOrFrameInsnIndex + 1; index <= currentInsnIndex; ++index) {\n+                    getFrames()[index] = currentFrame;\n+                }\n+            }\n+            if (isJvmInsnNode(insnNode) || insnNode instanceof FrameNode) {\n+                lastJvmOrFrameInsnIndex = currentInsnIndex;\n+            }\n+            currentInsnIndex += 1;\n+        }\n+    }\n+\n+    \/**\n+      * Returns the expanded representation of the given {@link FrameNode}.\n+      *\n+      * @param owner the internal name of the class to which 'frameNode' belongs.\n+      * @param previousFrame the frame before 'frameNode', in expanded form.\n+      * @param frameNode a possibly compressed stack map frame.\n+      * @return the expanded version of 'frameNode'.\n+      * @throws AnalyzerException if 'frameNode' is invalid.\n+      *\/\n+    @SuppressWarnings(\"fallthrough\")\n+    private Frame<V> expandFrame(\n+            final String owner, final Frame<V> previousFrame, final FrameNode frameNode)\n+            throws AnalyzerException {\n+        Frame<V> frame = newFrame(previousFrame);\n+        List<Object> locals = frameNode.local == null ? Collections.emptyList() : frameNode.local;\n+        int currentLocal = currentLocals;\n+        switch (frameNode.type) {\n+            case Opcodes.F_NEW:\n+            case Opcodes.F_FULL:\n+                currentLocal = 0;\n+                \/\/ fall through\n+            case Opcodes.F_APPEND:\n+                for (Object type : locals) {\n+                    V value = newFrameValue(owner, frameNode, type);\n+                    if (currentLocal + value.getSize() > frame.getLocals()) {\n+                        throw new AnalyzerException(frameNode, \"Cannot append more locals than maxLocals\");\n+                    }\n+                    frame.setLocal(currentLocal++, value);\n+                    if (value.getSize() == 2) {\n+                        frame.setLocal(currentLocal++, interpreter.newValue(null));\n+                    }\n+                }\n+                break;\n+            case Opcodes.F_CHOP:\n+                for (Object unusedType : locals) {\n+                    if (currentLocal <= 0) {\n+                        throw new AnalyzerException(frameNode, \"Cannot chop more locals than defined\");\n+                    }\n+                    if (currentLocal > 1 && frame.getLocal(currentLocal - 2).getSize() == 2) {\n+                        currentLocal -= 2;\n+                    } else {\n+                        currentLocal -= 1;\n+                    }\n+                }\n+                break;\n+            case Opcodes.F_SAME:\n+            case Opcodes.F_SAME1:\n+                break;\n+            default:\n+                throw new AnalyzerException(frameNode, \"Illegal frame type \" + frameNode.type);\n+        }\n+        currentLocals = currentLocal;\n+        while (currentLocal < frame.getLocals()) {\n+            frame.setLocal(currentLocal++, interpreter.newValue(null));\n+        }\n+\n+        List<Object> stack = frameNode.stack == null ? Collections.emptyList() : frameNode.stack;\n+        frame.clearStack();\n+        for (Object type : stack) {\n+            frame.push(newFrameValue(owner, frameNode, type));\n+        }\n+        return frame;\n+    }\n+\n+    \/**\n+      * Creates a new {@link Value} that represents the given stack map frame type.\n+      *\n+      * @param owner the internal name of the class to which 'frameNode' belongs.\n+      * @param frameNode the stack map frame to which 'type' belongs.\n+      * @param type an Integer, String or LabelNode object representing a primitive, reference or\n+      *     uninitialized a stack map frame type, respectively. See {@link FrameNode}.\n+      * @return a value that represents the given type.\n+      * @throws AnalyzerException if 'type' is an invalid stack map frame type.\n+      *\/\n+    private V newFrameValue(final String owner, final FrameNode frameNode, final Object type)\n+            throws AnalyzerException {\n+        if (type == Opcodes.TOP) {\n+            return interpreter.newValue(null);\n+        } else if (type == Opcodes.INTEGER) {\n+            return interpreter.newValue(Type.INT_TYPE);\n+        } else if (type == Opcodes.FLOAT) {\n+            return interpreter.newValue(Type.FLOAT_TYPE);\n+        } else if (type == Opcodes.LONG) {\n+            return interpreter.newValue(Type.LONG_TYPE);\n+        } else if (type == Opcodes.DOUBLE) {\n+            return interpreter.newValue(Type.DOUBLE_TYPE);\n+        } else if (type == Opcodes.NULL) {\n+            return interpreter.newOperation(new InsnNode(Opcodes.ACONST_NULL));\n+        } else if (type == Opcodes.UNINITIALIZED_THIS) {\n+            return interpreter.newValue(Type.getObjectType(owner));\n+        } else if (type instanceof String) {\n+            return interpreter.newValue(Type.getObjectType((String) type));\n+        } else if (type instanceof LabelNode) {\n+            AbstractInsnNode referencedNode = (LabelNode) type;\n+            while (referencedNode != null && !isJvmInsnNode(referencedNode)) {\n+                referencedNode = referencedNode.getNext();\n+            }\n+            if (referencedNode == null || referencedNode.getOpcode() != Opcodes.NEW) {\n+                throw new AnalyzerException(frameNode, \"LabelNode does not designate a NEW instruction\");\n+            }\n+            return interpreter.newValue(Type.getObjectType(((TypeInsnNode) referencedNode).desc));\n+        }\n+        throw new AnalyzerException(frameNode, \"Illegal stack map frame value \" + type);\n+    }\n+\n+    \/**\n+      * Checks that the given frame is compatible with the frame at the given instruction index, if\n+      * any. If there is no frame at this instruction index and none is required, the frame at\n+      * 'insnIndex' is set to the given frame. Otherwise, if the merge of the two frames is not equal\n+      * to the current frame at 'insnIndex', an exception is thrown.\n+      *\n+      * @param insnIndex an instruction index.\n+      * @param frame a frame. This frame is left unchanged by this method.\n+      * @param requireFrame whether a frame must already exist or not in {@link #frames} at\n+      *     'insnIndex'.\n+      * @throws AnalyzerException if the frames have incompatible sizes or if the frame at 'insnIndex'\n+      *     is missing (if required) or not compatible with 'frame'.\n+      *\/\n+    private void checkFrame(final int insnIndex, final Frame<V> frame, final boolean requireFrame)\n+            throws AnalyzerException {\n+        Frame<V> oldFrame = getFrames()[insnIndex];\n+        if (oldFrame == null) {\n+            if (requireFrame) {\n+                throw new AnalyzerException(null, \"Expected stack map frame at instruction \" + insnIndex);\n+            }\n+            getFrames()[insnIndex] = newFrame(frame);\n+        } else {\n+            String error = checkMerge(frame, oldFrame);\n+            if (error != null) {\n+                throw new AnalyzerException(\n+                        null,\n+                        \"Stack map frame incompatible with frame at instruction \"\n+                                + insnIndex\n+                                + \" (\"\n+                                + error\n+                                + \")\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+      * Checks that merging the two given frames would not produce any change, i.e. that the types in\n+      * the source frame are sub types of the corresponding types in the destination frame.\n+      *\n+      * @param srcFrame a source frame. This frame is left unchanged by this method.\n+      * @param dstFrame a destination frame. This frame is left unchanged by this method.\n+      * @return an error message if the frames have incompatible sizes, or if a type in the source\n+      *     frame is not a sub type of the corresponding type in the destination frame. Returns\n+      *     {@literal null} otherwise.\n+      *\/\n+    private String checkMerge(final Frame<V> srcFrame, final Frame<V> dstFrame) {\n+        int numLocals = srcFrame.getLocals();\n+        if (numLocals != dstFrame.getLocals()) {\n+            throw new AssertionError();\n+        }\n+        for (int i = 0; i < numLocals; ++i) {\n+            V v = interpreter.merge(srcFrame.getLocal(i), dstFrame.getLocal(i));\n+            if (!v.equals(dstFrame.getLocal(i))) {\n+                return \"incompatible types at local \"\n+                        + i\n+                        + \": \"\n+                        + srcFrame.getLocal(i)\n+                        + \" and \"\n+                        + dstFrame.getLocal(i);\n+            }\n+        }\n+        int numStack = srcFrame.getStackSize();\n+        if (numStack != dstFrame.getStackSize()) {\n+            return \"incompatible stack heights\";\n+        }\n+        for (int i = 0; i < numStack; ++i) {\n+            V v = interpreter.merge(srcFrame.getStack(i), dstFrame.getStack(i));\n+            if (!v.equals(dstFrame.getStack(i))) {\n+                return \"incompatible types at stack item \"\n+                        + i\n+                        + \": \"\n+                        + srcFrame.getStack(i)\n+                        + \" and \"\n+                        + dstFrame.getStack(i);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+      * Ends the control flow graph at the given instruction. This method checks that there is an\n+      * existing frame for the next instruction, if any.\n+      *\n+      * @param insnIndex an instruction index.\n+      * @throws AnalyzerException if 'insnIndex' is not the last instruction and there is no frame at\n+      *     'insnIndex' + 1 in {@link #getFrames}.\n+      *\/\n+    private void endControlFlow(final int insnIndex) throws AnalyzerException {\n+        if (hasNextJvmInsnOrFrame(insnIndex) && getFrames()[insnIndex + 1] == null) {\n+            throw new AnalyzerException(\n+                    null, \"Expected stack map frame at instruction \" + (insnIndex + 1));\n+        }\n+    }\n+\n+    \/**\n+      * Returns true if the given instruction is followed by a JVM instruction or a by stack map frame.\n+      *\n+      * @param insnIndex an instruction index.\n+      * @return true if 'insnIndex' is followed by a JVM instruction or a by stack map frame.\n+      *\/\n+    private boolean hasNextJvmInsnOrFrame(final int insnIndex) {\n+        AbstractInsnNode insn = insnList.get(insnIndex).getNext();\n+        while (insn != null) {\n+            if (isJvmInsnNode(insn) || insn instanceof FrameNode) {\n+                return true;\n+            }\n+            insn = insn.getNext();\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+      * Returns true if the given instruction node corresponds to a real JVM instruction.\n+      *\n+      * @param insnNode an instruction node.\n+      * @return true except for label, line number and stack map frame nodes.\n+      *\/\n+    private static boolean isJvmInsnNode(final AbstractInsnNode insnNode) {\n+        return insnNode.getOpcode() >= 0;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckFrameAnalyzer.java","additions":513,"deletions":0,"binary":false,"changes":513,"status":"added"},{"patch":"@@ -65,1 +65,0 @@\n-import java.util.Collections;\n@@ -482,2 +481,6 @@\n-                        Analyzer<BasicValue> analyzer = new Analyzer<>(new BasicVerifier());\n-                        try {\n+                        int originalMaxLocals = maxLocals;\n+                        int originalMaxStack = maxStack;\n+                        boolean checkMaxStackAndLocals = false;\n+                        boolean checkFrames = false;\n+                        if (methodVisitor instanceof MethodWriterWrapper) {\n+                            MethodWriterWrapper methodWriter = (MethodWriterWrapper) methodVisitor;\n@@ -487,5 +490,11 @@\n-                            \/\/ TODO(ebruneton): similarly, check that valid stack map frames are provided if the\n-                            \/\/ class writer has no flags to compute them, and the class version is V1_7 or more.\n-                            boolean checkMaxStackAndLocals =\n-                                    (methodVisitor instanceof MethodWriterWrapper)\n-                                            && !((MethodWriterWrapper) methodVisitor).computesMaxs();\n+                            checkMaxStackAndLocals = !methodWriter.computesMaxs();\n+                            \/\/ If 'methodVisitor' is a MethodWriter of a ClassWriter with no flags to compute the\n+                            \/\/ stack map frames, we know that valid frames must be provided. Otherwise we assume\n+                            \/\/ they are not needed at this stage.\n+                            checkFrames = methodWriter.requiresFrames() && !methodWriter.computesFrames();\n+                        }\n+                        Analyzer<BasicValue> analyzer =\n+                                checkFrames\n+                                        ? new CheckFrameAnalyzer<>(new BasicVerifier())\n+                                        : new Analyzer<>(new BasicVerifier());\n+                        try {\n@@ -501,0 +510,2 @@\n+                            maxLocals = originalMaxLocals;\n+                            maxStack = originalMaxStack;\n@@ -811,1 +822,1 @@\n-        checkLabel(label, false, \"label\");\n+        checkLabel(label, \/* checkVisited = *\/ false, \"label\");\n@@ -813,1 +824,0 @@\n-        referencedLabels.add(label);\n@@ -821,1 +831,1 @@\n-        checkLabel(label, false, \"label\");\n+        checkLabel(label, \/* checkVisited = *\/ false, \"label\");\n@@ -857,1 +867,1 @@\n-        checkLabel(dflt, false, \"default label\");\n+        checkLabel(dflt, \/* checkVisited = *\/ false, \"default label\");\n@@ -862,1 +872,1 @@\n-            checkLabel(labels[i], false, \"label at index \" + i);\n+            checkLabel(labels[i], \/* checkVisited = *\/ false, \"label at index \" + i);\n@@ -865,1 +875,0 @@\n-        Collections.addAll(referencedLabels, labels);\n@@ -873,1 +882,1 @@\n-        checkLabel(dflt, false, \"default label\");\n+        checkLabel(dflt, \/* checkVisited = *\/ false, \"default label\");\n@@ -878,1 +887,1 @@\n-            checkLabel(labels[i], false, \"label at index \" + i);\n+            checkLabel(labels[i], \/* checkVisited = *\/ false, \"label at index \" + i);\n@@ -881,2 +890,0 @@\n-        referencedLabels.add(dflt);\n-        Collections.addAll(referencedLabels, labels);\n@@ -936,3 +943,3 @@\n-        checkLabel(start, false, START_LABEL);\n-        checkLabel(end, false, END_LABEL);\n-        checkLabel(handler, false, \"handler label\");\n+        checkLabel(start, \/* checkVisited = *\/ false, START_LABEL);\n+        checkLabel(end, \/* checkVisited = *\/ false, END_LABEL);\n+        checkLabel(handler, \/* checkVisited = *\/ false, \"handler label\");\n@@ -982,2 +989,2 @@\n-        checkLabel(start, true, START_LABEL);\n-        checkLabel(end, true, END_LABEL);\n+        checkLabel(start, \/* checkVisited = *\/ true, START_LABEL);\n+        checkLabel(end, \/* checkVisited = *\/ true, END_LABEL);\n@@ -1020,2 +1027,2 @@\n-            checkLabel(start[i], true, START_LABEL);\n-            checkLabel(end[i], true, END_LABEL);\n+            checkLabel(start[i], \/* checkVisited = *\/ true, START_LABEL);\n+            checkLabel(end[i], \/* checkVisited = *\/ true, END_LABEL);\n@@ -1039,1 +1046,1 @@\n-        checkLabel(start, true, START_LABEL);\n+        checkLabel(start, \/* checkVisited = *\/ true, START_LABEL);\n@@ -1056,3 +1063,0 @@\n-            if (startInsnIndex == null || endInsnIndex == null) {\n-                throw new IllegalStateException(\"Undefined try catch block labels\");\n-            }\n@@ -1060,1 +1064,1 @@\n-                throw new IllegalStateException(\"Emty try catch block handler range\");\n+                throw new IllegalStateException(\"Empty try catch block handler range\");\n@@ -1119,1 +1123,1 @@\n-            referencedLabels.add((Label) value);\n+            checkLabel((Label) value, \/* checkVisited = *\/ false, \"label\");\n@@ -1132,1 +1136,1 @@\n-        if (opcode < Opcodes.NOP || opcode > Opcodes.IFNONNULL || OPCODE_METHODS[opcode] != method) {\n+        if (opcode < Opcodes.NOP || opcode > Opcodes.IFNONNULL) {\n@@ -1135,0 +1139,4 @@\n+        if (OPCODE_METHODS[opcode] != method) {\n+            throw new IllegalArgumentException(\n+                    \"Invalid combination of opcode and method: \" + opcode + \", \" + method);\n+        }\n@@ -1479,0 +1487,1 @@\n+        referencedLabels.add(label);\n@@ -1483,0 +1492,3 @@\n+        \/** The class version number. *\/\n+        private final int version;\n+\n@@ -1485,1 +1497,5 @@\n-        MethodWriterWrapper(final int api, final ClassWriter owner, final MethodVisitor methodWriter) {\n+        MethodWriterWrapper(\n+                final int api,\n+                final int version,\n+                final ClassWriter owner,\n+                final MethodVisitor methodWriter) {\n@@ -1487,0 +1503,1 @@\n+            this.version = version;\n@@ -1493,0 +1510,8 @@\n+\n+        boolean computesFrames() {\n+            return owner.hasFlags(ClassWriter.COMPUTE_FRAMES);\n+        }\n+\n+        boolean requiresFrames() {\n+            return (version & 0xFFFF) >= Opcodes.V1_7;\n+        }\n@@ -1495,1 +1520,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckMethodAdapter.java","additions":58,"deletions":34,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -245,1 +245,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckModuleAdapter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -154,1 +154,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckRecordComponentAdapter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -392,1 +392,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/CheckSignatureAdapter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -373,2 +373,1 @@\n-      * @param name the internal name of the class (see {@link\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      * @param name the internal name of the class (see {@link Type#getInternalName()}).\n@@ -377,3 +376,3 @@\n-      * @param superName the internal of name of the super class (see {@link\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). For interfaces, the super class is {@link\n-      *     Object}. May be {@literal null}, but only for the {@link Object} class.\n+      * @param superName the internal of name of the super class (see {@link Type#getInternalName()}).\n+      *     For interfaces, the super class is {@link Object}. May be {@literal null}, but only for the\n+      *     {@link Object} class.\n@@ -381,1 +380,1 @@\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *     Type#getInternalName()}). May be {@literal null}.\n@@ -422,1 +421,2 @@\n-      * @param nestHost the internal name of the host class of the nest.\n+      * @param nestHost the internal name of the host class of the nest (see {@link\n+      *     Type#getInternalName()}).\n@@ -431,1 +431,2 @@\n-      * @param owner internal name of the enclosing class of the class.\n+      * @param owner internal name of the enclosing class of the class (see {@link\n+      *     Type#getInternalName()}).\n@@ -452,4 +453,3 @@\n-      *     {@link jdk.internal.org.objectweb.asm.TypeReference#CLASS_TYPE_PARAMETER}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#CLASS_EXTENDS}. See {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference}.\n+      *     {@link TypeReference#CLASS_TYPE_PARAMETER}, {@link\n+      *     TypeReference#CLASS_TYPE_PARAMETER_BOUND} or {@link TypeReference#CLASS_EXTENDS}. See\n+      *     {@link TypeReference}.\n@@ -482,1 +482,1 @@\n-      * @param nestMember the internal name of a nest member.\n+      * @param nestMember the internal name of a nest member (see {@link Type#getInternalName()}).\n@@ -492,1 +492,2 @@\n-      * @param permittedSubclass the internal name of a permitted subclass.\n+      * @param permittedSubclass the internal name of a permitted subclass (see {@link\n+      *     Type#getInternalName()}).\n@@ -501,2 +502,1 @@\n-      * @param name the internal name of an inner class (see {@link\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      * @param name the internal name of an inner class (see {@link Type#getInternalName()}).\n@@ -504,1 +504,1 @@\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null} for not member classes.\n+      *     Type#getInternalName()}). May be {@literal null} for not member classes.\n@@ -534,1 +534,1 @@\n-      * @param descriptor the field's descriptor (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param descriptor the field's descriptor (see {@link Type}).\n@@ -554,1 +554,1 @@\n-      * @param descriptor the method's descriptor (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param descriptor the method's descriptor (see {@link Type}).\n@@ -558,1 +558,1 @@\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}). May be {@literal null}.\n+      *     Type#getInternalName()}). May be {@literal null}.\n@@ -574,1 +574,2 @@\n-      * @param mainClass the internal name of the main class of the current module.\n+      * @param mainClass the internal name of the main class of the current module (see {@link\n+      *     Type#getInternalName()}).\n@@ -583,1 +584,1 @@\n-      * @param packaze the internal name of a package.\n+      * @param packaze the internal name of a package (see {@link Type#getInternalName()}).\n@@ -604,1 +605,1 @@\n-      * @param packaze the internal name of the exported package.\n+      * @param packaze the internal name of the exported package (see {@link Type#getInternalName()}).\n@@ -617,1 +618,1 @@\n-      * @param packaze the internal name of the opened package.\n+      * @param packaze the internal name of the opened package (see {@link Type#getInternalName()}).\n@@ -630,1 +631,1 @@\n-      * @param service the internal name of the service.\n+      * @param service the internal name of the service (see {@link Type#getInternalName()}).\n@@ -639,1 +640,1 @@\n-      * @param service the internal name of the service.\n+      * @param service the internal name of the service (see {@link Type#getInternalName()}).\n@@ -662,4 +663,4 @@\n-      *     {@link String} or {@link jdk.internal.org.objectweb.asm.Type} of {@link jdk.internal.org.objectweb.asm.Type#OBJECT}\n-      *     or {@link jdk.internal.org.objectweb.asm.Type#ARRAY} sort. This value can also be an array of byte,\n-      *     boolean, short, char, int, long, float or double values (this is equivalent to using {@link\n-      *     #visitArray} and visiting each array element in turn, but is more convenient).\n+      *     {@link String} or {@link Type} of {@link Type#OBJECT} or {@link Type#ARRAY} sort. This\n+      *     value can also be an array of byte, boolean, short, char, int, long, float or double values\n+      *     (this is equivalent to using {@link #visitArray} and visiting each array element in turn,\n+      *     but is more convenient).\n@@ -773,1 +774,1 @@\n-      *     {@link jdk.internal.org.objectweb.asm.TypeReference#FIELD}. See {@link jdk.internal.org.objectweb.asm.TypeReference}.\n+      *     {@link TypeReference#FIELD}. See {@link TypeReference}.\n@@ -831,6 +832,4 @@\n-      *     {@link jdk.internal.org.objectweb.asm.TypeReference#METHOD_TYPE_PARAMETER}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#METHOD_RETURN}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#METHOD_RECEIVER}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#METHOD_FORMAL_PARAMETER} or {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#THROWS}. See {@link jdk.internal.org.objectweb.asm.TypeReference}.\n+      *     {@link TypeReference#METHOD_TYPE_PARAMETER}, {@link\n+      *     TypeReference#METHOD_TYPE_PARAMETER_BOUND}, {@link TypeReference#METHOD_RETURN}, {@link\n+      *     TypeReference#METHOD_RECEIVER}, {@link TypeReference#METHOD_FORMAL_PARAMETER} or {@link\n+      *     TypeReference#THROWS}. See {@link TypeReference}.\n@@ -905,3 +904,3 @@\n-      *     Reference types are represented by String objects (representing internal names), and\n-      *     uninitialized types by Label objects (this label designates the NEW instruction that\n-      *     created this uninitialized value).\n+      *     Reference types are represented by String objects (representing internal names, see {@link\n+      *     Type#getInternalName()}), and uninitialized types by Label objects (this label designates\n+      *     the NEW instruction that created this uninitialized value).\n@@ -963,1 +962,1 @@\n-      *     name of an object or array class (see {@link jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      *     name of an object or array class (see {@link Type#getInternalName()}).\n@@ -972,2 +971,1 @@\n-      * @param owner the internal name of the field's owner class (see {@link\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      * @param owner the internal name of the field's owner class (see {@link Type#getInternalName()}).\n@@ -975,1 +973,1 @@\n-      * @param descriptor the field's descriptor (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param descriptor the field's descriptor (see {@link Type}).\n@@ -985,1 +983,1 @@\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      *     Type#getInternalName()}).\n@@ -987,1 +985,1 @@\n-      * @param descriptor the method's descriptor (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param descriptor the method's descriptor (see {@link Type}).\n@@ -1005,1 +1003,1 @@\n-      *     jdk.internal.org.objectweb.asm.Type#getInternalName()}).\n+      *     Type#getInternalName()}).\n@@ -1007,1 +1005,1 @@\n-      * @param descriptor the method's descriptor (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param descriptor the method's descriptor (see {@link Type}).\n@@ -1023,1 +1021,1 @@\n-      * @param descriptor the method's descriptor (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param descriptor the method's descriptor (see {@link Type}).\n@@ -1027,2 +1025,2 @@\n-      *     jdk.internal.org.objectweb.asm.Type} or {@link Handle} value. This method is allowed to modify the\n-      *     content of the array so a caller should expect that this array may change.\n+      *     Type} or {@link Handle} value. This method is allowed to modify the content of the array so\n+      *     a caller should expect that this array may change.\n@@ -1098,1 +1096,1 @@\n-      * @param descriptor an array type descriptor (see {@link jdk.internal.org.objectweb.asm.Type}).\n+      * @param descriptor an array type descriptor (see {@link Type}).\n@@ -1107,10 +1105,6 @@\n-      *     {@link jdk.internal.org.objectweb.asm.TypeReference#INSTANCEOF}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#NEW}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#CONSTRUCTOR_REFERENCE}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#METHOD_REFERENCE}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#CAST}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#METHOD_INVOCATION_TYPE_ARGUMENT}, {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#METHOD_REFERENCE_TYPE_ARGUMENT}. See {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference}.\n+      *     {@link TypeReference#INSTANCEOF}, {@link TypeReference#NEW}, {@link\n+      *     TypeReference#CONSTRUCTOR_REFERENCE}, {@link TypeReference#METHOD_REFERENCE}, {@link\n+      *     TypeReference#CAST}, {@link TypeReference#CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT}, {@link\n+      *     TypeReference#METHOD_INVOCATION_TYPE_ARGUMENT}, {@link\n+      *     TypeReference#CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or {@link\n+      *     TypeReference#METHOD_REFERENCE_TYPE_ARGUMENT}. See {@link TypeReference}.\n@@ -1135,2 +1129,3 @@\n-      * @param type the internal name of the type of exceptions handled by the handler, or {@literal\n-      *     null} to catch any exceptions (for \"finally\" blocks).\n+      * @param type the internal name of the type of exceptions handled by the handler (see {@link\n+      *     Type#getInternalName()}), or {@literal null} to catch any exceptions (for \"finally\"\n+      *     blocks).\n@@ -1145,2 +1140,1 @@\n-      *     {@link jdk.internal.org.objectweb.asm.TypeReference#EXCEPTION_PARAMETER}. See {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference}.\n+      *     {@link TypeReference#EXCEPTION_PARAMETER}. See {@link TypeReference}.\n@@ -1179,3 +1173,2 @@\n-      *     {@link jdk.internal.org.objectweb.asm.TypeReference#LOCAL_VARIABLE} or {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference#RESOURCE_VARIABLE}. See {@link\n-      *     jdk.internal.org.objectweb.asm.TypeReference}.\n+      *     {@link TypeReference#LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE}. See {@link\n+      *     TypeReference}.\n@@ -1350,1 +1343,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/Printer.java","additions":62,"deletions":70,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -90,1 +90,3 @@\n-    \/** The type of internal names. See {@link #appendDescriptor}. *\/\n+    \/**\n+      * The type of internal names (see {@link Type#getInternalName()}). See {@link #appendDescriptor}.\n+      *\/\n@@ -1358,1 +1360,2 @@\n-      * @param value an internal name, type descriptor or a type signature. May be {@literal null}.\n+      * @param value an internal name (see {@link Type#getInternalName()}), type descriptor or a type\n+      *     signature. May be {@literal null}.\n@@ -1634,1 +1637,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/Textifier.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/TextifierSupport.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/TraceAnnotationVisitor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -277,1 +277,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/TraceClassVisitor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/TraceFieldVisitor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -345,1 +345,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/TraceMethodVisitor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -129,1 +129,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/TraceRecordComponentVisitor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -377,1 +377,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/util\/TraceSignatureVisitor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-ASM_9_3\n+ASM_9_6\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/version.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.Map;\n+import static sun.invoke.util.Wrapper.NumericClasses.*;\n@@ -31,2 +33,2 @@\n-    \/\/        wrapperType      simple     primitiveType  simple     char  emptyArray     format\n-    BOOLEAN(  Boolean.class,   \"Boolean\", boolean.class, \"boolean\", 'Z', new boolean[0], Format.unsigned( 1)),\n+    \/\/        wrapperType      simple     primitiveType  simple     char  emptyArray     format               numericClass  superClass\n+    BOOLEAN(  Boolean.class,   \"Boolean\", boolean.class, \"boolean\", 'Z', new boolean[0], Format.unsigned( 1), 0, 0),\n@@ -35,8 +37,8 @@\n-    BYTE   (     Byte.class,      \"Byte\",    byte.class,    \"byte\", 'B', new    byte[0], Format.signed(   8)),\n-    SHORT  (    Short.class,     \"Short\",   short.class,   \"short\", 'S', new   short[0], Format.signed(  16)),\n-    CHAR   (Character.class, \"Character\",    char.class,    \"char\", 'C', new    char[0], Format.unsigned(16)),\n-    INT    (  Integer.class,   \"Integer\",     int.class,     \"int\", 'I', new     int[0], Format.signed(  32)),\n-    LONG   (     Long.class,      \"Long\",    long.class,    \"long\", 'J', new    long[0], Format.signed(  64)),\n-    FLOAT  (    Float.class,     \"Float\",   float.class,   \"float\", 'F', new   float[0], Format.floating(32)),\n-    DOUBLE (   Double.class,    \"Double\",  double.class,  \"double\", 'D', new  double[0], Format.floating(64)),\n-    OBJECT (   Object.class,    \"Object\",  Object.class,  \"Object\", 'L', new  Object[0], Format.other(    1)),\n+    BYTE   (     Byte.class,      \"Byte\",    byte.class,    \"byte\", 'B', new    byte[0], Format.signed(   8), BYTE_CLASS, BYTE_SUPERCLASSES),\n+    SHORT  (    Short.class,     \"Short\",   short.class,   \"short\", 'S', new   short[0], Format.signed(  16), SHORT_CLASS, SHORT_SUPERCLASSES),\n+    CHAR   (Character.class, \"Character\",    char.class,    \"char\", 'C', new    char[0], Format.unsigned(16), CHAR_CLASS, CHAR_SUPERCLASSES),\n+    INT    (  Integer.class,   \"Integer\",     int.class,     \"int\", 'I', new     int[0], Format.signed(  32), INT_CLASS, INT_SUPERCLASSES),\n+    LONG   (     Long.class,      \"Long\",    long.class,    \"long\", 'J', new    long[0], Format.signed(  64), LONG_CLASS, LONG_SUPERCLASSES),\n+    FLOAT  (    Float.class,     \"Float\",   float.class,   \"float\", 'F', new   float[0], Format.floating(32), FLOAT_CLASS, FLOAT_SUPERCLASSES),\n+    DOUBLE (   Double.class,    \"Double\",  double.class,  \"double\", 'D', new  double[0], Format.floating(64), DOUBLE_CLASS, DOUBLE_CLASS),\n+    OBJECT (   Object.class,    \"Object\",  Object.class,  \"Object\", 'L', new  Object[0], Format.other(    1), 0, 0),\n@@ -44,1 +46,1 @@\n-    VOID   (     Void.class,      \"Void\",    void.class,    \"void\", 'V',           null, Format.other(    0)),\n+    VOID   (     Void.class,      \"Void\",    void.class,    \"void\", 'V',           null, Format.other(    0), 0, 0),\n@@ -55,0 +57,2 @@\n+    private final int      numericClass;\n+    private final int      superClasses;\n@@ -58,1 +62,1 @@\n-    private Wrapper(Class<?> wtype, String wtypeName, Class<?> ptype, String ptypeName, char tchar, Object emptyArray, int format) {\n+    private Wrapper(Class<?> wtype, String wtypeName, Class<?> ptype, String ptypeName, char tchar, Object emptyArray, int format, int numericClass, int superClasses) {\n@@ -65,0 +69,2 @@\n+        this.numericClass = numericClass;\n+        this.superClasses = superClasses;\n@@ -427,0 +433,5 @@\n+    \/** Query:  Is the given type a wrapper, such as {@code Integer}, {@code Byte}, etc excluding {@code Void} and {@code Object}? *\/\n+    public static boolean isWrapperNumericOrBooleanType(Class<?> type) {\n+        return isWrapperType(type) && findWrapperType(type) != VOID && findWrapperType(type) != OBJECT;\n+    }\n+\n@@ -631,0 +642,30 @@\n+\n+    \/\/ NumericClasses should be in sync with com.sun.tools.javac.code.TypeTag.NumericClasses\n+    public static class NumericClasses {\n+        public static final int BYTE_CLASS = 1;\n+        public static final int CHAR_CLASS = 2;\n+        public static final int SHORT_CLASS = 4;\n+        public static final int INT_CLASS = 8;\n+        public static final int LONG_CLASS = 16;\n+        public static final int FLOAT_CLASS = 32;\n+        public static final int DOUBLE_CLASS = 64;\n+\n+        static final int BYTE_SUPERCLASSES = BYTE_CLASS | SHORT_CLASS | INT_CLASS |\n+                LONG_CLASS | FLOAT_CLASS | DOUBLE_CLASS;\n+\n+        static final int CHAR_SUPERCLASSES = CHAR_CLASS | INT_CLASS |\n+                LONG_CLASS | FLOAT_CLASS | DOUBLE_CLASS;\n+\n+        static final int SHORT_SUPERCLASSES = SHORT_CLASS | INT_CLASS |\n+                LONG_CLASS | FLOAT_CLASS | DOUBLE_CLASS;\n+\n+        static final int INT_SUPERCLASSES = INT_CLASS | LONG_CLASS | FLOAT_CLASS | DOUBLE_CLASS;\n+\n+        static final int LONG_SUPERCLASSES = LONG_CLASS | FLOAT_CLASS | DOUBLE_CLASS;\n+\n+        static final int FLOAT_SUPERCLASSES = FLOAT_CLASS | DOUBLE_CLASS;\n+    }\n+\n+    public boolean isStrictSubRangeOf(Wrapper target) {\n+        return (this.superClasses & target.numericClass) != 0 && this != target;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":53,"deletions":12,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## ASM Bytecode Manipulation Framework v9.3\n+## ASM Bytecode Manipulation Framework v9.6\n","filename":"src\/java.base\/share\/legal\/asm.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,0 +4,10 @@\n+Changes in 1.3.1 (22 Jan 2024)\n+- Reject overflows of zip header fields in minizip\n+- Fix bug in inflateSync() for data held in bit buffer\n+- Add LIT_MEM define to use more memory for a small deflate speedup\n+- Fix decision on the emission of Zip64 end records in minizip\n+- Add bounds checking to ERR_MSG() macro, used by zError()\n+- Neutralize zip file traversal attacks in miniunz\n+- Fix a bug in ZLIB_DEBUG compiles in check_match()\n+- Various portability and appearance improvements\n+\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/ChangeLog","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-zlib 1.3 is a general purpose data compression library.  All the code is\n+zlib 1.3.1 is a general purpose data compression library.  All the code is\n@@ -34,1 +34,1 @@\n-The changes made in version 1.3 are documented in the file ChangeLog.\n+The changes made in version 1.3.1 are documented in the file ChangeLog.\n@@ -86,1 +86,1 @@\n- (C) 1995-2023 Jean-loup Gailly and Mark Adler\n+ (C) 1995-2024 Jean-loup Gailly and Mark Adler\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/README","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2023 Jean-loup Gailly and Mark Adler\n+ * Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n@@ -79,1 +79,1 @@\n-   \" deflate 1.3 Copyright 1995-2023 Jean-loup Gailly and Mark Adler \";\n+   \" deflate 1.3.1 Copyright 1995-2024 Jean-loup Gailly and Mark Adler \";\n@@ -520,1 +520,1 @@\n-    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, 4);\n+    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, LIT_BUFS);\n@@ -530,0 +530,5 @@\n+#ifdef LIT_MEM\n+    s->d_buf = (ushf *)(s->pending_buf + (s->lit_bufsize << 1));\n+    s->l_buf = s->pending_buf + (s->lit_bufsize << 2);\n+    s->sym_end = s->lit_bufsize - 1;\n+#else\n@@ -532,0 +537,1 @@\n+#endif\n@@ -747,0 +753,5 @@\n+#ifdef LIT_MEM\n+    if (bits < 0 || bits > 16 ||\n+        (uchf *)s->d_buf < s->pending_out + ((Buf_size + 7) >> 3))\n+        return Z_BUF_ERROR;\n+#else\n@@ -750,0 +761,1 @@\n+#endif\n@@ -1321,1 +1333,1 @@\n-    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);\n+    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, LIT_BUFS);\n@@ -1332,1 +1344,1 @@\n-    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n+    zmemcpy(ds->pending_buf, ss->pending_buf, ds->lit_bufsize * LIT_BUFS);\n@@ -1335,0 +1347,4 @@\n+#ifdef LIT_MEM\n+    ds->d_buf = (ushf *)(ds->pending_buf + (ds->lit_bufsize << 1));\n+    ds->l_buf = ds->pending_buf + (ds->lit_bufsize << 2);\n+#else\n@@ -1336,0 +1352,1 @@\n+#endif\n@@ -1566,4 +1583,12 @@\n-    if (zmemcmp(s->window + match,\n-                s->window + start, length) != EQUAL) {\n-        fprintf(stderr, \" start %u, match %u, length %d\\n\",\n-                start, match, length);\n+    Bytef *back = s->window + (int)match, *here = s->window + start;\n+    IPos len = length;\n+    if (match == (IPos)-1) {\n+        \/* match starts one byte before the current window -- just compare the\n+           subsequent length-1 bytes *\/\n+        back++;\n+        here++;\n+        len--;\n+    }\n+    if (zmemcmp(back, here, len) != EQUAL) {\n+        fprintf(stderr, \" start %u, match %d, length %d\\n\",\n+                start, (int)match, length);\n@@ -1571,2 +1596,2 @@\n-            fprintf(stderr, \"%c%c\", s->window[match++], s->window[start++]);\n-        } while (--length != 0);\n+            fprintf(stderr, \"(%02x %02x)\", *back++, *here++);\n+        } while (--len != 0);\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/deflate.c","additions":36,"deletions":11,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2018 Jean-loup Gailly\n+ * Copyright (C) 1995-2024 Jean-loup Gailly\n@@ -50,0 +50,4 @@\n+\/* define LIT_MEM to slightly increase the speed of deflate (order 1% to 2%) at\n+   the cost of a larger memory footprint *\/\n+\/* #define LIT_MEM *\/\n+\n@@ -244,0 +248,6 @@\n+#ifdef LIT_MEM\n+#   define LIT_BUFS 5\n+    ushf *d_buf;          \/* buffer for distances *\/\n+    uchf *l_buf;          \/* buffer for literals\/lengths *\/\n+#else\n+#   define LIT_BUFS 4\n@@ -245,0 +255,1 @@\n+#endif\n@@ -266,1 +277,1 @@\n-    uInt sym_next;      \/* running index in sym_buf *\/\n+    uInt sym_next;      \/* running index in symbol buffer *\/\n@@ -345,0 +356,19 @@\n+#ifdef LIT_MEM\n+# define _tr_tally_lit(s, c, flush) \\\n+  { uch cc = (c); \\\n+    s->d_buf[s->sym_next] = 0; \\\n+    s->l_buf[s->sym_next++] = cc; \\\n+    s->dyn_ltree[cc].Freq++; \\\n+    flush = (s->sym_next == s->sym_end); \\\n+   }\n+# define _tr_tally_dist(s, distance, length, flush) \\\n+  { uch len = (uch)(length); \\\n+    ush dist = (ush)(distance); \\\n+    s->d_buf[s->sym_next] = dist; \\\n+    s->l_buf[s->sym_next++] = len; \\\n+    dist--; \\\n+    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \\\n+    s->dyn_dtree[d_code(dist)].Freq++; \\\n+    flush = (s->sym_next == s->sym_end); \\\n+  }\n+#else\n@@ -364,0 +394,1 @@\n+#endif\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/deflate.h","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 2004-2019 Mark Adler\n+ * Copyright (C) 2004-2024 Mark Adler\n@@ -237,3 +237,0 @@\n-#ifdef INT_MAX\n-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > INT_MAX)\n-#else\n@@ -241,2 +238,1 @@\n-#  define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())\n-#endif\n+#define GT_OFF(x) (sizeof(int) == sizeof(z_off64_t) && (x) > gz_intmax())\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/gzguts.h","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 2004-2019 Mark Adler\n+ * Copyright (C) 2004-2024 Mark Adler\n@@ -590,1 +590,0 @@\n-#ifndef INT_MAX\n@@ -596,3 +595,4 @@\n-    unsigned p, q;\n-\n-    p = 1;\n+#ifdef INT_MAX\n+    return INT_MAX;\n+#else\n+    unsigned p = 1, q;\n@@ -605,1 +605,0 @@\n-}\n@@ -607,0 +606,1 @@\n+}\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/gzlib.c","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1414,1 +1414,1 @@\n-        state->hold <<= state->bits & 7;\n+        state->hold >>= state->bits & 7;\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/inflate.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2023 Mark Adler\n+ * Copyright (C) 1995-2024 Mark Adler\n@@ -36,1 +36,1 @@\n-   \" inflate 1.3 Copyright 1995-2023 Mark Adler \";\n+   \" inflate 1.3.1 Copyright 1995-2024 Mark Adler \";\n@@ -84,1 +84,1 @@\n-        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 198, 203};\n+        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 203, 77};\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/inftrees.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-   returns returns 852, and \"enough 30 6 15\" for distance codes returns 592.\n-   The initial root table size (9 or 6) is found in the fifth argument of the\n+   returns 852, and \"enough 30 6 15\" for distance codes returns 592. The\n+   initial root table size (9 or 6) is found in the fifth argument of the\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/inftrees.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-Changes from zlib 1.3\n+Changes from zlib 1.3.1\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/patches\/ChangeLog_java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2021 Jean-loup Gailly\n+ * Copyright (C) 1995-2024 Jean-loup Gailly\n@@ -926,1 +926,1 @@\n-    unsigned sx = 0;    \/* running index in sym_buf *\/\n+    unsigned sx = 0;    \/* running index in symbol buffers *\/\n@@ -931,0 +931,4 @@\n+#ifdef LIT_MEM\n+        dist = s->d_buf[sx];\n+        lc = s->l_buf[sx++];\n+#else\n@@ -934,0 +938,1 @@\n+#endif\n@@ -958,1 +963,4 @@\n-        \/* Check that the overlay between pending_buf and sym_buf is ok: *\/\n+        \/* Check for no overlay of pending_buf on needed symbols *\/\n+#ifdef LIT_MEM\n+        Assert(s->pending < 2 * (s->lit_bufsize + sx), \"pendingBuf overflow\");\n+#else\n@@ -960,0 +968,1 @@\n+#endif\n@@ -1109,0 +1118,4 @@\n+#ifdef LIT_MEM\n+    s->d_buf[s->sym_next] = (ush)dist;\n+    s->l_buf[s->sym_next++] = (uch)lc;\n+#else\n@@ -1112,0 +1125,1 @@\n+#endif\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/trees.c","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler\n+ * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n@@ -327,8 +327,0 @@\n-#ifndef Z_ARG \/* function prototypes for stdarg *\/\n-#  if defined(STDC) || defined(Z_HAVE_STDARG_H)\n-#    define Z_ARG(args)  args\n-#  else\n-#    define Z_ARG(args)  ()\n-#  endif\n-#endif\n-\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/zconf.h","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-  version 1.3, August 18th, 2023\n+  version 1.3.1, January 22nd, 2024\n@@ -28,1 +28,1 @@\n-  Copyright (C) 1995-2023 Jean-loup Gailly and Mark Adler\n+  Copyright (C) 1995-2024 Jean-loup Gailly and Mark Adler\n@@ -64,2 +64,2 @@\n-#define ZLIB_VERSION \"1.3\"\n-#define ZLIB_VERNUM 0x1300\n+#define ZLIB_VERSION \"1.3.1\"\n+#define ZLIB_VERNUM 0x1310\n@@ -68,1 +68,1 @@\n-#define ZLIB_VER_REVISION 0\n+#define ZLIB_VER_REVISION 1\n@@ -963,4 +963,4 @@\n-   In the success case, the application may save the current current value of\n-   total_in which indicates where valid compressed data was found.  In the\n-   error case, the application may repeatedly call inflateSync, providing more\n-   input each time, until success or end of the input data.\n+   In the success case, the application may save the current value of total_in\n+   which indicates where valid compressed data was found.  In the error case,\n+   the application may repeatedly call inflateSync, providing more input each\n+   time, until success or end of the input data.\n@@ -1785,1 +1785,1 @@\n-   len2.\n+   len2. len2 must be non-negative.\n@@ -1792,1 +1792,1 @@\n-   crc32_combine_op().\n+   crc32_combine_op(). len2 must be non-negative.\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/zlib.h","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * Copyright (C) 1995-2022 Jean-loup Gailly, Mark Adler\n+ * Copyright (C) 1995-2024 Jean-loup Gailly, Mark Adler\n@@ -83,1 +83,1 @@\n-#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]\n+#define ERR_MSG(err) z_errmsg[(err) < -6 || (err) > 2 ? 9 : 2 - (err)]\n@@ -164,1 +164,1 @@\n-#if defined(MACOS) || defined(TARGET_OS_MAC)\n+#if defined(MACOS)\n@@ -166,9 +166,0 @@\n-#  ifndef Z_SOLO\n-#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os\n-#      include <unix.h> \/* for fdopen *\/\n-#    else\n-#      ifndef fdopen\n-#        define fdopen(fd,mode) NULL \/* No fdopen() *\/\n-#      endif\n-#    endif\n-#  endif\n@@ -197,12 +188,0 @@\n-#if defined(_BEOS_) || defined(RISCOS)\n-#  define fdopen(fd,mode) NULL \/* No fdopen() *\/\n-#endif\n-\n-#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX\n-#  if defined(_WIN32_WCE)\n-#    define fdopen(fd,mode) NULL \/* No fdopen() *\/\n-#  else\n-#    define fdopen(fd,type)  _fdopen(fd,type)\n-#  endif\n-#endif\n-\n","filename":"src\/java.base\/share\/native\/libzip\/zlib\/zutil.h","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -690,0 +690,18 @@\n+     * Consistent with the usage of the {@link Override @Override}\n+     * annotation, if an interface declares a method\n+     * override-equivalent to a {@code public} method of {@link Object\n+     * java.lang.Object}, such a method of the interface is regarded\n+     * as overriding the corresponding {@code Object} method; for\n+     * example:\n+     *\n+     * {@snippet lang=java :\n+     * interface I {\n+     *   @Override\n+     *   String toString();\n+     * }\n+     * ...\n+     * assert elements.overrides(elementForItoString,\n+     *                           elementForObjecttoString,\n+     *                           elements.getTypeElement(\"I\"));\n+     * }\n+     *\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,15 @@\n+ * Most methods operate on {@linkplain PrimitiveType primitive types},\n+ * {@linkplain ReferenceType reference types} (including {@linkplain\n+ * ArrayType array types} and the {@linkplain NullType null type}),\n+ * {@linkplain IntersectionType intersection types}, and the\n+ * pseudo-type '{@link TypeKind#VOID void}'. {@linkplain\n+ * ExecutableType Executable types} and the pseudo-types for\n+ * {@linkplain TypeKind#PACKAGE packages} and {@linkplain\n+ * TypeKind#MODULE modules} are generally out of scope for these\n+ * methods. One or more out of scope arguments will typically result\n+ * in a method throwing an {@link IllegalArgumentException}.\n+ *\n+ * <p>Where a method returns a type mirror or a collection of type\n+ * mirrors, any type mirrors represent types with no type annotations,\n+ * unless otherwise indicated.\n+ *\n@@ -156,0 +171,2 @@\n+     * Annotations on the direct super types are preserved.\n+     *\n@@ -208,0 +225,1 @@\n+     * @jls 4.2 Primitive Types and Values\n@@ -213,0 +231,1 @@\n+     * @jls 4.1 The Kinds of Types and Values\n@@ -238,0 +257,2 @@\n+     * Annotations on the component type are preserved.\n+     *\n@@ -240,1 +261,2 @@\n-     *          an array\n+     *          an array, including executable, package, module, and wildcard types\n+     * @jls 10.1 Array Types\n@@ -248,0 +270,2 @@\n+     * Annotations on the bounds are preserved.\n+     *\n@@ -251,0 +275,1 @@\n+     * @jls 4.5.1 Type Arguments of Parameterized Types\n@@ -263,0 +288,2 @@\n+     * Annotations on the type arguments are preserved.\n+     *\n@@ -294,0 +321,2 @@\n+     * Annotations on the type arguments are preserved.\n+     *\n@@ -327,0 +356,25 @@\n+\n+    \/**\n+     * {@return a type mirror equivalent to the argument, but with no annotations}\n+     * If the type mirror is a composite type, such as an array type\n+     * or a wildcard type, any constitute types, such as the\n+     * component type of an array and the type of the bounds of a\n+     * wildcard type, also have no annotations, recursively.\n+     *\n+     * <p>For most kinds of type mirrors, the result of\n+     * {@snippet lang=\"java\" :\n+     *   types.isSameType(typeMirror, types.stripAnnotations(typeMirror))\n+     * }\n+     * is {@code true}. The predicate is {@code false} on wildcard\n+     * types for {@linkplain #isSameType(TypeMirror, TypeMirror)\n+     * reasons discussed elsewhere}.\n+     *\n+     * @param t the type mirror\n+     * @param <T> the specific type of type mirror\n+     * @implSpec\n+     * The default implementation throws {@code UnsupportedOperationException}.\n+     * @since 23\n+     *\/\n+    default <T extends TypeMirror> T stripAnnotations(T t) {\n+        throw new UnsupportedOperationException();\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Types.java","additions":56,"deletions":2,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -329,4 +329,1 @@\n-        if (table.getRowCount() <= 0 || table.getColumnCount() <= 0 ||\n-                \/\/ this check prevents us from painting the entire table\n-                \/\/ when the clip doesn't intersect our bounds at all\n-                !bounds.intersects(clip)) {\n+        if (table.getRowCount() <= 0 || table.getColumnCount() <= 0) {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthTableUI.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+            case PRIMITIVE_PATTERNS -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -257,0 +257,1 @@\n+        PRIMITIVE_PATTERNS(JDK23, Fragments.FeaturePrimitivePatterns, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+    public final Type exactConversionsSupportType;\n@@ -548,0 +549,1 @@\n+        exactConversionsSupportType = enterClass(\"java.lang.runtime.ExactConversionsSupport\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-        return metadata.isEmpty() ? this : baseType();\n+        return metadata.isEmpty() ? this : stripMetadata();\n@@ -429,0 +429,6 @@\n+        \/**\n+         * Note: this visitor only needs to handle cases where\n+         * 'contained' types can be annotated. These cases are\n+         * described in JVMS 4.7.20.2 and are : classes (for type\n+         * parameters and enclosing types), wildcards, and arrays.\n+         *\/\n@@ -432,1 +438,1 @@\n-                return super.visitClassType((ClassType)t.typeNoMetadata(), aVoid);\n+                return super.visitClassType((ClassType) dropMetadata(t), aVoid);\n@@ -437,1 +443,1 @@\n-                return super.visitArrayType((ArrayType)t.typeNoMetadata(), aVoid);\n+                return super.visitArrayType((ArrayType) dropMetadata(t), aVoid);\n@@ -441,2 +447,2 @@\n-            public Type visitTypeVar(TypeVar t, Void aVoid) {\n-                return super.visitTypeVar((TypeVar)t.typeNoMetadata(), aVoid);\n+            public Type visitWildcardType(WildcardType wt, Void aVoid) {\n+                return super.visitWildcardType((WildcardType) dropMetadata(wt), aVoid);\n@@ -446,2 +452,13 @@\n-            public Type visitWildcardType(WildcardType wt, Void aVoid) {\n-                return super.visitWildcardType((WildcardType)wt.typeNoMetadata(), aVoid);\n+            public Type visitType(Type t, Void aVoid) {\n+                return dropMetadata(t);\n+            }\n+\n+            private static Type dropMetadata(Type t) {\n+                if (t.getMetadata().isEmpty()) {\n+                    return t;\n+                }\n+                Type baseType = t.baseType();\n+                if (baseType.getMetadata().isEmpty()) {\n+                    return baseType;\n+                }\n+                return baseType.cloneWithMetadata(List.nil());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -189,0 +189,4 @@\n+    public boolean isInSuperClassesOf(TypeTag tag) {\n+        return (this.numericClass & tag.superClasses) != 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeTag.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5027,0 +5027,46 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditionality\">\n+    \/** Check unconditionality between any combination of reference or primitive types.\n+     *\n+     *  Rules:\n+     *    an identity conversion\n+     *    a widening reference conversion\n+     *    a widening primitive conversion (delegates to `checkUnconditionallyExactPrimitives`)\n+     *    a boxing conversion\n+     *    a boxing conversion followed by a widening reference conversion\n+     *\n+     *  @param source     Source primitive or reference type\n+     *  @param target     Target primitive or reference type\n+     *\/\n+    public boolean isUnconditionallyExact(Type source, Type target) {\n+        if (isSameType(source, target)) {\n+            return true;\n+        }\n+\n+        return target.isPrimitive()\n+                ? isUnconditionallyExactPrimitives(source, target)\n+                : isSubtype(boxedTypeOrType(erasure(source)), target);\n+    }\n+\n+    \/** Check unconditionality between primitive types.\n+     *\n+     *  - widening from one integral type to another,\n+     *  - widening from one floating point type to another,\n+     *  - widening from byte, short, or char to a floating point type,\n+     *  - widening from int to double.\n+     *\n+     *  @param selectorType     Type of selector\n+     *  @param targetType       Target type\n+     *\/\n+    public boolean isUnconditionallyExactPrimitives(Type selectorType, Type targetType) {\n+        if (isSameType(selectorType, targetType)) {\n+            return true;\n+        }\n+\n+        return (selectorType.isPrimitive() && targetType.isPrimitive()) &&\n+                ((selectorType.hasTag(BYTE) && !targetType.hasTag(CHAR)) ||\n+                 (selectorType.hasTag(SHORT) && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag()))) ||\n+                 (selectorType.hasTag(CHAR)  && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag())))  ||\n+                 (selectorType.hasTag(INT)   && (targetType.hasTag(DOUBLE) || targetType.hasTag(LONG))) ||\n+                 (selectorType.hasTag(FLOAT) && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag()))));\n+    }\n+    \/\/ <\/editor-fold>\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1685,0 +1685,1 @@\n+            boolean booleanSwitch = types.isSameType(types.unboxedTypeOrType(seltype), syms.booleanType);\n@@ -1687,1 +1688,0 @@\n-            boolean errorPrimitiveSwitch = seltype.isPrimitive() && !intSwitch;\n@@ -1689,0 +1689,4 @@\n+            if (seltype.isPrimitive() && !intSwitch) {\n+                preview.checkSourceLevel(selector.pos(), Feature.PRIMITIVE_PATTERNS);\n+                patternSwitch = true;\n+            }\n@@ -1690,1 +1694,1 @@\n-                !intSwitch && !errorPrimitiveSwitch) {\n+                !intSwitch) {\n@@ -1694,3 +1698,0 @@\n-                if (errorPrimitiveSwitch) {\n-                    log.error(selector.pos(), Errors.SelectorTypeNotAllowed(seltype));\n-                }\n@@ -1712,0 +1713,1 @@\n+            JCCaseLabel unconditionalCaseLabel = null;\n@@ -1779,4 +1781,9 @@\n-                                } else if (!stringSwitch && !intSwitch && !errorPrimitiveSwitch) {\n-                                    log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n-                                } else if (!constants.add(pattype.constValue())) {\n-                                    log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                                }\n+                                else {\n+                                    if (!stringSwitch && !intSwitch &&\n+                                            !((pattype.getTag().isInSuperClassesOf(LONG) || pattype.getTag().equals(BOOLEAN)) &&\n+                                              types.isSameType(types.unboxedTypeOrType(seltype), pattype))) {\n+                                        log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n+                                    } else if (!constants.add(pattype.constValue())) {\n+                                        log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                                    }\n@@ -1791,0 +1798,2 @@\n+                        }  else if (booleanSwitch && constants.containsAll(Set.of(0, 1))) {\n+                            log.error(label.pos(), Errors.DefaultAndBothBooleanValues);\n@@ -1799,1 +1808,4 @@\n-                        if (!primaryType.hasTag(TYPEVAR)) {\n+\n+                        if (primaryType.isPrimitive()) {\n+                            preview.checkSourceLevel(pat.pos(), Feature.PRIMITIVE_PATTERNS);\n+                        } else if (!primaryType.hasTag(TYPEVAR)) {\n@@ -1802,3 +1814,1 @@\n-                        if (!errorPrimitiveSwitch) {\n-                            checkCastablePattern(pat.pos(), seltype, primaryType);\n-                        }\n+                        checkCastablePattern(pat.pos(), seltype, primaryType);\n@@ -1827,2 +1837,1 @@\n-                                types.isSubtype(types.boxedTypeOrType(types.erasure(seltype)),\n-                                                patternType);\n+                                types.isUnconditionallyExact(seltype, patternType);\n@@ -1834,0 +1843,2 @@\n+                            } else if (booleanSwitch && constants.containsAll(Set.of(0, 1))) {\n+                                log.error(pat.pos(), Errors.UnconditionalPatternAndBothBooleanValues);\n@@ -1836,0 +1847,1 @@\n+                            unconditionalCaseLabel = label;\n@@ -1862,1 +1874,1 @@\n-                chk.checkSwitchCaseLabelDominated(cases);\n+                chk.checkSwitchCaseLabelDominated(unconditionalCaseLabel, cases);\n@@ -4100,2 +4112,7 @@\n-        Type exprtype = chk.checkNullOrRefType(\n-                tree.expr.pos(), attribExpr(tree.expr, env));\n+        Type exprtype = attribExpr(tree.expr, env);\n+        if (exprtype.isPrimitive()) {\n+            preview.checkSourceLevel(tree.expr.pos(), Feature.PRIMITIVE_PATTERNS);\n+        } else {\n+            exprtype = chk.checkNullOrRefType(\n+                    tree.expr.pos(), exprtype);\n+        }\n@@ -4122,11 +4139,5 @@\n-        if (!clazztype.hasTag(TYPEVAR)) {\n-            clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);\n-        }\n-        if (!clazztype.isErroneous() && !types.isReifiable(clazztype)) {\n-            boolean valid = false;\n-            if (allowReifiableTypesInInstanceof) {\n-                valid = checkCastablePattern(tree.expr.pos(), exprtype, clazztype);\n-            } else {\n-                log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                          Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n-                allowReifiableTypesInInstanceof = true;\n+        if (clazztype.isPrimitive()) {\n+            preview.checkSourceLevel(tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n+        } else {\n+            if (!clazztype.hasTag(TYPEVAR)) {\n+                clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);\n@@ -4134,2 +4145,12 @@\n-            if (!valid) {\n-                clazztype = types.createErrorType(clazztype);\n+            if (!clazztype.isErroneous() && !types.isReifiable(clazztype)) {\n+                boolean valid = false;\n+                if (allowReifiableTypesInInstanceof) {\n+                    valid = checkCastablePattern(tree.expr.pos(), exprtype, clazztype);\n+                } else {\n+                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n+                            Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n+                    allowReifiableTypesInInstanceof = true;\n+                }\n+                if (!valid) {\n+                    clazztype = types.createErrorType(clazztype);\n+                }\n@@ -4155,6 +4176,3 @@\n-                   (!exprType.isPrimitive() ||\n-                    !pattType.isPrimitive() ||\n-                    !types.isSameType(exprType, pattType))) {\n-            chk.basicHandler.report(pos,\n-                    diags.fragment(Fragments.NotApplicableTypes(exprType, pattType)));\n-            return false;\n+                (!exprType.isPrimitive() || !pattType.isPrimitive() || !types.isSameType(exprType, pattType))) {\n+            preview.checkSourceLevel(pos, Feature.PRIMITIVE_PATTERNS);\n+            return true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":55,"deletions":37,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -4803,1 +4803,1 @@\n-    void checkSwitchCaseLabelDominated(List<JCCase> cases) {\n+    void checkSwitchCaseLabelDominated(JCCaseLabel unconditionalCaseLabel, List<JCCase> cases) {\n@@ -4808,0 +4808,2 @@\n+        boolean unconditionalFound = false;\n+\n@@ -4835,1 +4837,3 @@\n-                    if (types.isSubtype(currentType, testType) &&\n+                    boolean dominated = false;\n+                    if (unconditionalCaseLabel == testCaseLabel) unconditionalFound = true;\n+                    if (types.isUnconditionallyExact(currentType, testType) &&\n@@ -4838,1 +4842,0 @@\n-                        boolean dominated = false;\n@@ -4848,3 +4851,9 @@\n-                        if (dominated) {\n-                            log.error(label.pos(), Errors.PatternDominated);\n-                        }\n+                    }\n+\n+                    \/\/ Domination can occur even when we have not an unconditional pair between case labels.\n+                    if (unconditionalFound && unconditionalCaseLabel != label) {\n+                        dominated = true;\n+                    }\n+\n+                    if (dominated) {\n+                        log.error(label.pos(), Errors.PatternDominated);\n@@ -4861,1 +4870,1 @@\n-                case CONSTANTCASELABEL -> types.boxedTypeOrType(((JCConstantCaseLabel) label).expr.type);\n+                case CONSTANTCASELABEL -> ((JCConstantCaseLabel) label).expr.type;\n@@ -4868,1 +4877,1 @@\n-            if (existingPatternType.isPrimitive() ^ currentPatternType.isPrimitive()) {\n+            if (!types.isUnconditionallyExact(currentPatternType, existingPatternType)) {\n@@ -4871,7 +4880,0 @@\n-            if (existingPatternType.isPrimitive()) {\n-                return types.isSameType(existingPatternType, currentPatternType);\n-            } else {\n-                if (!types.isSubtype(currentPatternType, existingPatternType)) {\n-                    return false;\n-                }\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -760,3 +760,8 @@\n-            tree.isExhaustive = tree.hasUnconditionalPattern ||\n-                                TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases) ||\n-                                exhausts(tree.selector, tree.cases);\n+\n+            if (tree.hasUnconditionalPattern ||\n+                TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases)) {\n+                tree.isExhaustive = true;\n+            } else {\n+                tree.isExhaustive = exhausts(tree.selector, tree.cases);\n+            }\n+\n@@ -773,0 +778,1 @@\n+            Set<Object> booleanLiterals = new HashSet<>();\n@@ -783,9 +789,14 @@\n-                        Symbol s = TreeInfo.symbol(constantLabel.expr);\n-                        if (s != null && s.isEnum()) {\n-                            enum2Constants.computeIfAbsent(s.owner, x -> {\n-                                Set<Symbol> result = new HashSet<>();\n-                                s.owner.members()\n-                                       .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n-                                       .forEach(result::add);\n-                                return result;\n-                            }).remove(s);\n+                        if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN)) {\n+                            Object value = ((JCLiteral) constantLabel.expr).value;\n+                            booleanLiterals.add(value);\n+                        } else {\n+                            Symbol s = TreeInfo.symbol(constantLabel.expr);\n+                            if (s != null && s.isEnum()) {\n+                                enum2Constants.computeIfAbsent(s.owner, x -> {\n+                                    Set<Symbol> result = new HashSet<>();\n+                                    s.owner.members()\n+                                            .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n+                                            .forEach(result::add);\n+                                    return result;\n+                                }).remove(s);\n+                            }\n@@ -796,0 +807,5 @@\n+\n+            if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.size() == 2) {\n+                return true;\n+            }\n+\n@@ -826,2 +842,1 @@\n-                    if (pd instanceof BindingPattern bp &&\n-                        types.isSubtype(seltypeComponent, types.erasure(bp.type))) {\n+                    if(isBpCovered(seltypeComponent, pd)) {\n@@ -1107,2 +1122,1 @@\n-                    covered &= newNested instanceof BindingPattern bp &&\n-                               types.isSubtype(types.erasure(componentType[i]), types.erasure(bp.type));\n+                    covered &= isBpCovered(componentType[i], newNested);\n@@ -1284,0 +1298,24 @@\n+    private boolean isBpCovered(Type componentType, PatternDescription newNested) {\n+        if (newNested instanceof BindingPattern bp) {\n+            var seltype = types.erasure(componentType);\n+\n+            if (seltype.isPrimitive()) {\n+                if (types.isSameType(bp.type, types.boxedClass(seltype).type)) {\n+                    return true;\n+                }\n+\n+                \/\/ if the target is unconditionally exact to the pattern, target is covered\n+                if (types.isUnconditionallyExact(seltype, bp.type)) {\n+                    return true;\n+                }\n+            } else if (seltype.isReference() && bp.type.isPrimitive() && types.isCastable(seltype, bp.type)) {\n+                return true;\n+            } else {\n+                if (types.isSubtype(seltype, types.erasure(bp.type))) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -3465,1 +3503,1 @@\n-            Type type = types.isSubtype(selectorType, binding.type)\n+            Type type = !selectorType.isPrimitive() && types.isSubtype(selectorType, binding.type)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":55,"deletions":17,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+    private final HashMap<TypePairs, String> typePairToName;\n@@ -136,0 +137,1 @@\n+        typePairToName = TypePairs.initialize(syms);\n@@ -2924,0 +2926,172 @@\n+    \/**\n+     * All the exactness checks between primitive types that require a run-time\n+     * check are in {@code java.lang.runtime.ExactConversionsSupport}. Those methods\n+     * are in the form {@code ExactConversionsSupport.is<S>To<T>Exact} where both\n+     * {@code S} and {@code T} are primitive types and correspond to the runtime\n+     * action that will be executed to check whether a certain value (that is passed\n+     * as a parameter) can be converted to {@code T} without loss of information.\n+     *\n+     * Rewrite {@code instanceof if expr : Object} and Type is primitive type:\n+     *\n+     * {@snippet :\n+     *   Object v = ...\n+     *   if (v instanceof float)\n+     *   =>\n+     *   if (let tmp$123 = v; tmp$123 instanceof Float)\n+     * }\n+     *\n+     * Rewrite {@code instanceof if expr : wrapper reference type}\n+     *\n+     * {@snippet :\n+     *   Integer v = ...\n+     *   if (v instanceof float)\n+     *   =>\n+     *   if (let tmp$123 = v; tmp$123 != null && ExactConversionsSupport.intToFloatExact(tmp$123.intValue()))\n+     * }\n+     *\n+     * Rewrite {@code instanceof if expr : primitive}\n+     *\n+     * {@snippet :\n+     *   int v = ...\n+     *   if (v instanceof float)\n+     *   =>\n+     *   if (let tmp$123 = v; ExactConversionsSupport.intToFloatExact(tmp$123))\n+     * }\n+     *\n+     * More rewritings:\n+     * <ul>\n+     * <li>If the {@code instanceof} check is unconditionally exact rewrite to true.<\/li>\n+     * <li>If expression type is {@code Byte}, {@code Short}, {@code Integer}, ..., an\n+     *     unboxing conversion followed by a widening primitive conversion.<\/li>\n+     * <li>If expression type is a supertype: {@code Number}, a narrowing reference\n+     *     conversion followed by an unboxing conversion.<\/li>\n+     * <\/ul>\n+     *\/\n+    public void visitTypeTest(JCInstanceOf tree) {\n+        if (tree.expr.type.isPrimitive() || tree.pattern.type.isPrimitive()) {\n+            JCExpression exactnessCheck = null;\n+            JCExpression instanceOfExpr = translate(tree.expr);\n+\n+            \/\/ preserving the side effects of the value\n+            VarSymbol dollar_s = new VarSymbol(FINAL | SYNTHETIC,\n+                    names.fromString(\"tmp\" + tree.pos + this.target.syntheticNameChar()),\n+                    tree.expr.type,\n+                    currentMethodSym);\n+            JCStatement var = make.at(tree.pos())\n+                    .VarDef(dollar_s, instanceOfExpr).setType(dollar_s.type);\n+\n+            if (types.isUnconditionallyExact(tree.expr.type, tree.pattern.type)) {\n+                exactnessCheck = make\n+                        .LetExpr(List.of(var), make.Literal(BOOLEAN, 1).setType(syms.booleanType.constType(1)))\n+                        .setType(syms.booleanType);\n+            }\n+            else if (tree.expr.type.isReference()) {\n+                JCExpression nullCheck = makeBinary(NE,\n+                        make.Ident(dollar_s),\n+                        makeNull());\n+                if (types.isUnconditionallyExact(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n+                    exactnessCheck = make\n+                            .LetExpr(List.of(var), nullCheck)\n+                            .setType(syms.booleanType);\n+                } else if (types.unboxedType(tree.expr.type).isPrimitive()) {\n+                    exactnessCheck = getExactnessCheck(tree,\n+                            boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type)));\n+                } else {\n+                    exactnessCheck = make.at(tree.pos())\n+                            .TypeTest(tree.expr, make.Type(types.boxedClass(tree.pattern.type).type))\n+                            .setType(syms.booleanType);\n+                }\n+\n+                exactnessCheck = make.LetExpr(List.of(var), makeBinary(AND,\n+                        nullCheck,\n+                        exactnessCheck))\n+                        .setType(syms.booleanType);\n+            }\n+            else if (tree.expr.type.isPrimitive()) {\n+                JCIdent argument = make.Ident(dollar_s);\n+\n+                JCExpression exactnessCheckCall =\n+                        getExactnessCheck(tree, argument);\n+\n+                exactnessCheck = make.LetExpr(List.of(var), exactnessCheckCall)\n+                        .setType(syms.booleanType);\n+            }\n+\n+            result = exactnessCheck;\n+        } else {\n+            tree.expr = translate(tree.expr);\n+            tree.pattern = translate(tree.pattern);\n+            result = tree;\n+        }\n+    }\n+\n+    \/\/ TypePairs should be in sync with the corresponding record in SwitchBootstraps\n+    record TypePairs(TypeSymbol from, TypeSymbol to) {\n+        public static TypePairs of(Symtab syms, Type from, Type to) {\n+            if (from == syms.byteType || from == syms.shortType || from == syms.charType) {\n+                from = syms.intType;\n+            }\n+            return new TypePairs(from, to);\n+        }\n+\n+        public TypePairs(Type from, Type to) {\n+            this(from.tsym, to.tsym);\n+        }\n+\n+        public static HashMap<TypePairs, String> initialize(Symtab syms) {\n+            HashMap<TypePairs, String> typePairToName = new HashMap<>();\n+            typePairToName.put(new TypePairs(syms.byteType,   syms.charType),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.shortType,  syms.byteType),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.shortType,  syms.charType),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.charType,   syms.byteType),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.charType,   syms.shortType),  \"isIntToShortExact\");     \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.intType,    syms.byteType),   \"isIntToByteExact\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.shortType),  \"isIntToShortExact\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.charType),   \"isIntToCharExact\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.floatType),  \"isIntToFloatExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.byteType),   \"isLongToByteExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.shortType),  \"isLongToShortExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.charType),   \"isLongToCharExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.intType),    \"isLongToIntExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.floatType),  \"isLongToFloatExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.doubleType), \"isLongToDoubleExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.byteType),   \"isFloatToByteExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.shortType),  \"isFloatToShortExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.charType),   \"isFloatToCharExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.intType),    \"isFloatToIntExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.longType),   \"isFloatToLongExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.byteType),   \"isDoubleToByteExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.shortType),  \"isDoubleToShortExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.charType),   \"isDoubleToCharExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.intType),    \"isDoubleToIntExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.longType),   \"isDoubleToLongExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.floatType),  \"isDoubleToFloatExact\");\n+            return typePairToName;\n+        }\n+    }\n+\n+    private JCExpression getExactnessCheck(JCInstanceOf tree, JCExpression argument) {\n+        TypePairs pair = TypePairs.of(syms, types.unboxedTypeOrType(tree.expr.type), tree.pattern.type);\n+\n+        Name exactnessFunction = names.fromString(typePairToName.get(pair));\n+\n+        \/\/ Resolve the exactness method\n+        Symbol ecsym = lookupMethod(tree.pos(),\n+                exactnessFunction,\n+                syms.exactConversionsSupportType,\n+                List.of(pair.from.type));\n+\n+        \/\/ Generate the method call ExactnessChecks.<exactness method>(<argument>);\n+        JCFieldAccess select = make.Select(\n+                make.QualIdent(syms.exactConversionsSupportType.tsym),\n+                exactnessFunction);\n+        select.sym = ecsym;\n+        select.setType(syms.booleanType);\n+\n+        JCExpression exactnessCheck = make.Apply(List.nil(),\n+                select,\n+                List.of(argument));\n+        exactnessCheck.setType(syms.booleanType);\n+        return exactnessCheck;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-                if (!tree.allowNull && !principalType.isPrimitive()) {\n+                if (!tree.allowNull || !types.isSubtype(currentValue.type, principalType)) {\n@@ -499,0 +499,1 @@\n+            boolean primitiveSelector = seltype.isPrimitive();\n@@ -503,0 +504,1 @@\n+            Type resolvedSelectorType = seltype;\n@@ -504,1 +506,1 @@\n-                    List.of(enumSelector ? seltype : syms.objectType, syms.intType),\n+                    List.of(resolvedSelectorType, syms.intType),\n@@ -738,0 +740,75 @@\n+    private Symbol.DynamicVarSymbol makePrimitive(DiagnosticPosition pos, Type primitiveType) {\n+        Assert.checkNonNull(currentClass);\n+\n+        List<Type> bsm_staticArgs = List.of(syms.methodHandleLookupType,\n+                syms.stringType,\n+                new ClassType(syms.classType.getEnclosingType(),\n+                        List.of(syms.constantBootstrapsType),\n+                        syms.classType.tsym));\n+\n+        Name bootstrapName = names.fromString(\"primitiveClass\");\n+        MethodSymbol bsm = rs.resolveInternalMethod(pos, env, syms.constantBootstrapsType,\n+                bootstrapName, bsm_staticArgs, List.nil());\n+\n+        PrimitiveGenerator primitiveGenerator = new PrimitiveGenerator();\n+        primitiveGenerator.assembleSig(primitiveType);\n+        return new Symbol.DynamicVarSymbol(names.fromString(primitiveGenerator.sb.toString()),\n+                syms.noSymbol,\n+                new Symbol.MethodHandleSymbol(bsm),\n+                syms.classType,\n+                new LoadableConstant[]{});\n+    }\n+\n+    private Symbol.DynamicVarSymbol makeBooleanConstant(DiagnosticPosition pos, int constant) {\n+        Assert.checkNonNull(currentClass);\n+\n+        List<Type> bsm_staticArgs = List.of(syms.methodHandleLookupType,\n+                syms.stringType,\n+                new ClassType(syms.classType.getEnclosingType(),\n+                        List.of(syms.constantBootstrapsType),\n+                        syms.classType.tsym));\n+\n+        Name bootstrapName = names.fromString(\"getStaticFinal\");\n+        MethodSymbol bsm = rs.resolveInternalMethod(pos, env, syms.constantBootstrapsType,\n+                bootstrapName, bsm_staticArgs, List.nil());\n+\n+        return new Symbol.DynamicVarSymbol(constant == 0 ? names.fromString(\"FALSE\") : names.fromString(\"TRUE\"),\n+                syms.noSymbol,\n+                new Symbol.MethodHandleSymbol(bsm),\n+                types.boxedTypeOrType(syms.booleanType),\n+                new LoadableConstant[]{});\n+    }\n+\n+    private class PrimitiveGenerator extends Types.SignatureGenerator {\n+\n+        \/**\n+         * An output buffer for type signatures.\n+         *\/\n+        StringBuilder sb = new StringBuilder();\n+\n+        PrimitiveGenerator() {\n+            super(types);\n+        }\n+\n+        @Override\n+        protected void append(char ch) {\n+            sb.append(ch);\n+        }\n+\n+        @Override\n+        protected void append(byte[] ba) {\n+            sb.append(new String(ba));\n+        }\n+\n+        @Override\n+        protected void append(Name name) {\n+            sb.append(name.toString());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return sb.toString();\n+        }\n+    }\n+\n+\n@@ -826,1 +903,2 @@\n-                                instanceofCheck.allowNull &&\n+                                (!types.erasure(binding.type).isPrimitive() ? instanceofCheck.allowNull :\n+                                types.isUnconditionallyExact(commonNestedExpression.type, types.erasure(binding.type))) &&\n@@ -857,0 +935,1 @@\n+                    newSwitch.hasUnconditionalPattern = hasUnconditional;\n@@ -933,1 +1012,1 @@\n-        return types.boxedTypeOrType(types.erasure(TreeInfo.primaryPatternType(p)));\n+        return types.erasure(TreeInfo.primaryPatternType(p));\n@@ -939,2 +1018,6 @@\n-            if (types.isSubtype(selector, principalType)) {\n-                return (LoadableConstant) selector;\n+            if (((JCPatternCaseLabel) l).pat.type.isReference()) {\n+                if (types.isSubtype(selector, principalType)) {\n+                    return (LoadableConstant) selector;\n+                } else {\n+                    return (LoadableConstant) principalType;\n+                }\n@@ -942,1 +1025,1 @@\n-                return (LoadableConstant) principalType;\n+                return makePrimitive(l.pos(), principalType);\n@@ -957,2 +1040,5 @@\n-                    case BYTE, CHAR,\n-                         SHORT, INT -> LoadableConstant.Int((Integer) expr.type.constValue());\n+                    case BOOLEAN -> makeBooleanConstant(l.pos(), (Integer) expr.type.constValue());\n+                    case BYTE, CHAR, SHORT, INT -> LoadableConstant.Int((Integer) expr.type.constValue());\n+                    case LONG -> LoadableConstant.Long((Long) expr.type.constValue());\n+                    case FLOAT -> LoadableConstant.Float((Float) expr.type.constValue());\n+                    case DOUBLE -> LoadableConstant.Double((Double) expr.type.constValue());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":95,"deletions":9,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-        return types.erasure((Type)t).stripMetadataIfNeeded();\n+        return types.erasure((Type)t).stripMetadata();\n@@ -158,1 +158,1 @@\n-        return types.capture((Type)t).stripMetadataIfNeeded();\n+        return types.capture((Type)t).stripMetadata();\n@@ -307,0 +307,7 @@\n+    @DefinedBy(Api.LANGUAGE_MODEL)\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends TypeMirror> T stripAnnotations(T t) {\n+        return (T)((Type) t).stripMetadata();\n+    }\n+\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacTypes.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -552,0 +552,6 @@\n+compiler.err.unconditional.pattern.and.both.boolean.values=\\\n+    switch has both boolean values and an unconditional pattern\n+\n+compiler.err.default.and.both.boolean.values=\\\n+    switch has both boolean values and a default label\n+\n@@ -566,4 +572,0 @@\n-# 0: type\n-compiler.err.selector.type.not.allowed=\\\n-    selector type {0} is not allowed\n-\n@@ -2668,4 +2670,0 @@\n-# 0: type, 1: type\n-compiler.misc.not.applicable.types=\\\n-    pattern of type {1} is not applicable at {0}\n-\n@@ -3203,0 +3201,3 @@\n+compiler.misc.feature.primitive.patterns=\\\n+    primitive patterns\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.vm.ci.hotspot;\n-\n-import jdk.vm.ci.meta.JavaType;\n-import jdk.vm.ci.runtime.JVMCICompilerFactory;\n-\n-\/**\n- * HotSpot extensions to {@link JVMCICompilerFactory}.\n- *\/\n-public abstract class HotSpotJVMCICompilerFactory implements JVMCICompilerFactory {\n-\n-    public enum CompilationLevelAdjustment {\n-        \/**\n-         * No adjustment.\n-         *\/\n-        None,\n-\n-        \/**\n-         * Adjust based on declaring class of method.\n-         *\/\n-        ByHolder,\n-\n-        \/**\n-         * Adjust based on declaring class, name and signature of method.\n-         *\/\n-        ByFullSignature\n-    }\n-\n-    \/**\n-     * Determines if this object may want to adjust the compilation level for a method that is being\n-     * scheduled by the VM for compilation.\n-     *\/\n-    public CompilationLevelAdjustment getCompilationLevelAdjustment() {\n-        return CompilationLevelAdjustment.None;\n-    }\n-\n-    public enum CompilationLevel {\n-        None,\n-        Simple,\n-        LimitedProfile,\n-        FullProfile,\n-        FullOptimization\n-    }\n-\n-    \/**\n-     * Potentially modifies the compilation level currently selected by the VM compilation policy\n-     * for a method.\n-     *\n-     * @param declaringClass the class in which the method is declared. This value is either a\n-     *            {@code Class} instance or a {@code String} representing the\n-     *            {@link JavaType#toJavaName() name} of the class.\n-     * @param name the name of the method or {@code null} depending on the value that was returned\n-     *            by {@link #getCompilationLevelAdjustment()}\n-     * @param signature the signature of the method or {@code null} depending on the value that was\n-     *            returned by {@link #getCompilationLevelAdjustment()}\n-     * @param isOsr specifies if the compilation being scheduled in an OSR compilation\n-     * @param level the compilation level currently selected by the VM compilation policy\n-     * @return the compilation level to use for the compilation being scheduled (must be a valid\n-     *         {@code CompLevel} enum value)\n-     *\/\n-    public CompilationLevel adjustCompilationLevel(Object declaringClass, String name, String signature, boolean isOsr, CompilationLevel level) {\n-        throw new InternalError(getClass().getName() + \" must override adjustCompilationLevel(...) since it returned a value other than \" + CompilationLevel.class.getName() + \".\" +\n-                        CompilationLevel.None + \" from getCompilationLevelAdjustment()\");\n-    }\n-}\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCICompilerFactory.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -26,1 +26,0 @@\n-import static jdk.vm.ci.hotspot.HotSpotJVMCICompilerFactory.CompilationLevelAdjustment.None;\n@@ -471,1 +470,0 @@\n-    private final HotSpotJVMCICompilerFactory hsCompilerFactory;\n@@ -575,12 +573,0 @@\n-        if (compilerFactory instanceof HotSpotJVMCICompilerFactory) {\n-            hsCompilerFactory = (HotSpotJVMCICompilerFactory) compilerFactory;\n-            if (hsCompilerFactory.getCompilationLevelAdjustment() != None) {\n-                String name = HotSpotJVMCICompilerFactory.class.getName();\n-                String msg = String.format(\"%s.getCompilationLevelAdjustment() is no longer supported. \" +\n-                                \"Use %s.excludeFromJVMCICompilation() instead.\", name, name);\n-                throw new UnsupportedOperationException(msg);\n-            }\n-        } else {\n-            hsCompilerFactory = null;\n-        }\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCIRuntime.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,1 +225,1 @@\n-doclet.search=SEARCH\n+doclet.search=Suchen\n@@ -227,0 +227,1 @@\n+doclet.search_in_documentation=In Dokumentation suchen\n@@ -240,0 +241,6 @@\n+doclet.table_of_contents=Inhaltsverzeichnis\n+doclet.hide_sidebar=Randleiste ausblenden\n+doclet.show_sidebar=Randleiste einblenden\n+doclet.filter_label=Filter\n+doclet.filter_table_of_contents=Inhaltsverzeichnis filtern\n+doclet.filter_reset=Zurücksetzen\n@@ -243,0 +250,1 @@\n+doclet.unexpectedRedirect=Unerwartete Umleitung für URL {0} zu {1}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets_de.properties","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,1 +225,1 @@\n-doclet.search=SEARCH\n+doclet.search=検索\n@@ -227,0 +227,1 @@\n+doclet.search_in_documentation=ドキュメントで検索\n@@ -240,0 +241,6 @@\n+doclet.table_of_contents=目次\n+doclet.hide_sidebar=サイドバーの非表示\n+doclet.show_sidebar=サイドバーの表示\n+doclet.filter_label=フィルタ\n+doclet.filter_table_of_contents=目次のフィルタ\n+doclet.filter_reset=リセット\n@@ -243,0 +250,1 @@\n+doclet.unexpectedRedirect=URL {0}から{1}への予期しないリダイレクト\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets_ja.properties","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,1 +225,1 @@\n-doclet.search=SEARCH\n+doclet.search=搜索\n@@ -227,0 +227,1 @@\n+doclet.search_in_documentation=在文档中搜索\n@@ -240,0 +241,6 @@\n+doclet.table_of_contents=目录\n+doclet.hide_sidebar=隐藏子工具栏\n+doclet.show_sidebar=显示子工具栏\n+doclet.filter_label=筛选器\n+doclet.filter_table_of_contents=筛选目录\n+doclet.filter_reset=重置\n@@ -243,0 +250,1 @@\n+doclet.unexpectedRedirect=URL {0} 意外重定向到 {1}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets_zh_CN.properties","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import javax.lang.model.type.TypeKind;\n@@ -184,0 +185,2 @@\n+        if (te.asType().getKind() == TypeKind.ERROR)\n+            return Kind.OTHER;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolEnvironment.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,6 @@\n+main.did-you-mean=Meinten Sie: {0}\n+\n+main.did-you-mean-one-of=Meinten Sie eine der folgenden Optionen: {0}\n+\n+main.for-more-details-see-usage=Weitere Einzelheiten zu den verfügbaren Optionen finden Sie mit \"--help\" oder \"--help-extra\"\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc_de.properties","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,6 @@\n+main.did-you-mean=もしかして: {0}\n+\n+main.did-you-mean-one-of=もしかして次のいずれかですか: {0}\n+\n+main.for-more-details-see-usage=使用可能なオプションの詳細を確認するには、--helpまたは--help-extraを使用してください\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc_ja.properties","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,6 @@\n+main.did-you-mean=您要查找的是：{0}\n+\n+main.did-you-mean-one-of=您要查找的是以下项之一：{0}\n+\n+main.for-more-details-see-usage=有关可用选项的更多详细信息，请使用 --help 或 --help-extra\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc_zh_CN.properties","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -212,8 +212,8 @@\n-        BOOLEAN(TokenKind.BOOLEAN, XEXPR1|XDECL1),  \/\/  boolean\n-        BYTE(TokenKind.BYTE, XEXPR1|XDECL1),  \/\/  byte\n-        CHAR(TokenKind.CHAR, XEXPR1|XDECL1),  \/\/  char\n-        DOUBLE(TokenKind.DOUBLE, XEXPR1|XDECL1),  \/\/  double\n-        FLOAT(TokenKind.FLOAT, XEXPR1|XDECL1),  \/\/  float\n-        INT(TokenKind.INT, XEXPR1|XDECL1),  \/\/  int\n-        LONG(TokenKind.LONG, XEXPR1|XDECL1),  \/\/  long\n-        SHORT(TokenKind.SHORT, XEXPR1|XDECL1),  \/\/  short\n+        BOOLEAN(TokenKind.BOOLEAN, XEXPR1|XDECL1|XTERM),  \/\/  boolean\n+        BYTE(TokenKind.BYTE, XEXPR1|XDECL1|XTERM),  \/\/  byte\n+        CHAR(TokenKind.CHAR, XEXPR1|XDECL1|XTERM),  \/\/  char\n+        DOUBLE(TokenKind.DOUBLE, XEXPR1|XDECL1|XTERM),  \/\/  double\n+        FLOAT(TokenKind.FLOAT, XEXPR1|XDECL1|XTERM),  \/\/  float\n+        INT(TokenKind.INT, XEXPR1|XDECL1|XTERM),  \/\/  int\n+        LONG(TokenKind.LONG, XEXPR1|XDECL1|XTERM),  \/\/  long\n+        SHORT(TokenKind.SHORT, XEXPR1|XDECL1|XTERM),  \/\/  short\n@@ -808,1 +808,2 @@\n-            while (token.kind.isExpression())\n+            while (token.kind.isExpression()) {\n+                CT prevToken = in.prevCT;\n@@ -810,0 +811,15 @@\n+                \/\/ primitive types can only appear in the end of an `instanceof` expression\n+                switch (token.kind) {\n+                    case EOF:\n+                        switch (in.prevCT.kind) {\n+                            case BYTE, SHORT, CHAR, INT, LONG, FLOAT, DOUBLE, BOOLEAN:\n+                                switch (prevToken.kind) {\n+                                    case INSTANCEOF:\n+                                        return Completeness.COMPLETE;\n+                                    default:\n+                                        return Completeness.DEFINITELY_INCOMPLETE;\n+                                }\n+                        }\n+                }\n+            }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,6 @@\n+#elif defined(_AIX)\n+    perfstat_memory_total_t memory_info;\n+    if (perfstat_memory_total(NULL, &memory_info, sizeof(perfstat_memory_total_t), 1) == -1) {\n+        throw_internal_error(env, \"perfstat_memory_total failed\");\n+    }\n+    return available ? (jlong)(memory_info.pgsp_free * 4L * 1024L) : (jlong)(memory_info.pgsp_total * 4L * 1024L);\n","filename":"src\/jdk.management\/unix\/native\/libmanagement_ext\/OperatingSystemImpl.c","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  DirectivesParserTest() : _locale(setlocale(LC_NUMERIC, NULL)) {\n+  DirectivesParserTest() : _locale(setlocale(LC_NUMERIC, nullptr)) {\n","filename":"test\/hotspot\/gtest\/compiler\/test_directivesParser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  MemRegion heap(NULL, num_regions_in_test * HeapRegion::GrainWords);\n+  MemRegion heap(nullptr, num_regions_in_test * HeapRegion::GrainWords);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_freeRegionList.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    if (_workers == NULL) {\n+    if (_workers == nullptr) {\n@@ -90,1 +90,1 @@\n-WorkerThreads* G1CardSetTest::_workers = NULL;\n+WorkerThreads* G1CardSetTest::_workers = nullptr;\n@@ -100,1 +100,1 @@\n-    if (results != NULL) {\n+    if (results != nullptr) {\n@@ -272,1 +272,1 @@\n-    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), NULL);\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), nullptr);\n@@ -294,1 +294,1 @@\n-    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), NULL);\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), nullptr);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSet.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    if (_workers == NULL) {\n+    if (_workers == nullptr) {\n@@ -51,1 +51,1 @@\n-WorkerThreads* G1MapperWorkers::_workers = NULL;\n+WorkerThreads* G1MapperWorkers::_workers = nullptr;\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_stressCommitUncommit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-    ASSERT_EQ((BufferNode*)NULL, nodes[i]->next());\n+    ASSERT_EQ(nullptr, nodes[i]->next());\n@@ -105,1 +105,1 @@\n-    assert(node != NULL, \"precondition\");\n+    assert(node != nullptr, \"precondition\");\n@@ -172,1 +172,1 @@\n-      if (node != NULL) {\n+      if (node != nullptr) {\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_bufferNodeAllocator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-  \/\/ Test that NULL is not in the heap.\n-  ASSERT_FALSE(heap->is_in(NULL)) << \"NULL is unexpectedly in the heap\";\n+  \/\/ Test that nullptr is not in the heap.\n+  ASSERT_FALSE(heap->is_in(nullptr)) << \"null is unexpectedly in the heap\";\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_collectedHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-      if (setter2 != NULL) {\n+      if (setter2 != nullptr) {\n@@ -83,1 +83,1 @@\n-      test(setter, NULL, checker);\n+      test(setter, nullptr, checker);\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_collectorPolicy.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,2 +107,2 @@\n-\/\/ Using EXPECT_EQ can't use NULL directly. Otherwise AIX build breaks.\n-const OopBlock* const NULL_BLOCK = NULL;\n+\/\/ Using EXPECT_EQ can't use nullptr directly. Otherwise AIX build breaks.\n+const OopBlock* const NULL_BLOCK = nullptr;\n@@ -113,1 +113,1 @@\n-       block != NULL;\n+       block != nullptr;\n@@ -122,1 +122,1 @@\n-  for (OopBlock* block = list.head(); block != NULL; block = next) {\n+  for (OopBlock* block = list.head(); block != nullptr; block = next) {\n@@ -129,1 +129,1 @@\n-  return list.chead() == NULL;\n+  return list.chead() == nullptr;\n@@ -142,1 +142,1 @@\n-  *entry = NULL;\n+  *entry = nullptr;\n@@ -153,1 +153,1 @@\n-       (block != NULL) && block->is_empty();\n+       (block != nullptr) && block->is_empty();\n@@ -167,1 +167,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -206,1 +206,1 @@\n-    EXPECT_TRUE(_entries[i] != NULL);\n+    EXPECT_TRUE(_entries[i] != nullptr);\n@@ -218,2 +218,2 @@\n-  for ( ; (block != NULL) && block->is_empty(); block = list.prev(*block)) {}\n-  for ( ; block != NULL; block = list.prev(*block)) {\n+  for ( ; (block != nullptr) && block->is_empty(); block = list.prev(*block)) {}\n+  for ( ; block != nullptr; block = list.prev(*block)) {\n@@ -242,1 +242,1 @@\n-  EXPECT_TRUE(ptr != NULL);\n+  EXPECT_TRUE(ptr != nullptr);\n@@ -252,1 +252,1 @@\n-  EXPECT_NE(block, (OopBlock*)NULL);\n+  EXPECT_NE(block, (OopBlock*)nullptr);\n@@ -329,1 +329,1 @@\n-  ASSERT_TRUE(entries[0] != NULL);\n+  ASSERT_TRUE(entries[0] != nullptr);\n@@ -342,1 +342,1 @@\n-    ASSERT_TRUE(entries[i] != NULL);\n+    ASSERT_TRUE(entries[i] != nullptr);\n@@ -345,1 +345,1 @@\n-    if (block == NULL) {\n+    if (block == nullptr) {\n@@ -353,1 +353,1 @@\n-      block = NULL;\n+      block = nullptr;\n@@ -361,1 +361,1 @@\n-  if (block != NULL) {\n+  if (block != nullptr) {\n@@ -378,1 +378,1 @@\n-       block != NULL;\n+       block != nullptr;\n@@ -398,1 +398,1 @@\n-    if (_entries[i] != NULL) {\n+    if (_entries[i] != nullptr) {\n@@ -400,1 +400,1 @@\n-      _entries[i] = NULL;\n+      _entries[i] = nullptr;\n@@ -430,1 +430,1 @@\n-    if (_entries[i] != NULL) {\n+    if (_entries[i] != nullptr) {\n@@ -432,1 +432,1 @@\n-      _entries[i] = NULL;\n+      _entries[i] = nullptr;\n@@ -461,1 +461,1 @@\n-      *to_release[i] = NULL;\n+      *to_release[i] = nullptr;\n@@ -512,1 +512,1 @@\n-    EXPECT_EQ(NULL, entries[i]);\n+    EXPECT_EQ(nullptr, entries[i]);\n@@ -549,1 +549,1 @@\n-    if (*ptr != NULL) {\n+    if (*ptr != nullptr) {\n@@ -556,1 +556,1 @@\n-    if (*ptr != NULL) {\n+    if (*ptr != nullptr) {\n@@ -598,1 +598,1 @@\n-      ASSERT_TRUE(entries[allocated] != NULL);\n+      ASSERT_TRUE(entries[allocated] != nullptr);\n@@ -875,1 +875,1 @@\n-WorkerThreads* OopStorageTestParIteration::_workers = NULL;\n+WorkerThreads* OopStorageTestParIteration::_workers = nullptr;\n@@ -878,1 +878,1 @@\n-  if (_workers == NULL) {\n+  if (_workers == nullptr) {\n@@ -1077,1 +1077,1 @@\n-      ASSERT_TRUE(entries[allocated] != NULL);\n+      ASSERT_TRUE(entries[allocated] != nullptr);\n@@ -1095,1 +1095,1 @@\n-    _entries[i] = NULL;\n+    _entries[i] = nullptr;\n@@ -1101,1 +1101,1 @@\n-    _entries[i] = NULL;\n+    _entries[i] = nullptr;\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorage.cpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-WorkerThreads* OopStorageParIterPerf::_workers = NULL;\n+WorkerThreads* OopStorageParIterPerf::_workers = nullptr;\n@@ -80,1 +80,1 @@\n-  if (_workers == NULL) {\n+  if (_workers == nullptr) {\n@@ -129,1 +129,1 @@\n-    _worker_times(NULL),\n+    _worker_times(nullptr),\n@@ -155,1 +155,1 @@\n-  virtual void do_oop(oop* p) { guarantee(*p == NULL, \"expected NULL\"); }\n+  virtual void do_oop(oop* p) { guarantee(*p == nullptr, \"expected null\"); }\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorage_parperf.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    array(NULL, title, 3),\n+    array(nullptr, title, 3),\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_workerDataArray.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n-  check_is_weak_good_or_null((uintptr_t)NULL);\n+  check_is_weak_good_or_null((uintptr_t)nullptr);\n","filename":"test\/hotspot\/gtest\/gc\/x\/test_xAddress.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-    if (_jvm != NULL) {\n+    if (_jvm != nullptr) {\n@@ -154,1 +154,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -247,1 +247,1 @@\n-  if (java_home == NULL) {\n+  if (java_home == nullptr) {\n@@ -273,1 +273,1 @@\n-  JVMInitializerListener* jvm_listener = NULL;\n+  JVMInitializerListener* jvm_listener = nullptr;\n@@ -276,1 +276,1 @@\n-    JavaVM* jvm = NULL;\n+    JavaVM* jvm = nullptr;\n@@ -303,1 +303,1 @@\n-  if (jvm_listener != NULL) {\n+  if (jvm_listener != nullptr) {\n@@ -326,2 +326,2 @@\n-  hdl = CreateThread(NULL, STACK_SIZE, thread_wrapper, (void*)args, 0, NULL);\n-  if (hdl == NULL) {\n+  hdl = CreateThread(nullptr, STACK_SIZE, thread_wrapper, (void*)args, 0, nullptr);\n+  if (hdl == nullptr) {\n@@ -354,1 +354,1 @@\n-  if (pthread_join(tid, NULL) != 0) {\n+  if (pthread_join(tid, nullptr) != 0) {\n","filename":"test\/hotspot\/gtest\/gtestMain.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,1 +203,1 @@\n-  assert(description != NULL, \"invariant\");\n+  assert(description != nullptr, \"invariant\");\n","filename":"test\/hotspot\/gtest\/jfr\/test_adaptiveSampler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n-      *network_interfaces = NULL;\n+      *network_interfaces = nullptr;\n","filename":"test\/hotspot\/gtest\/jfr\/test_networkUtilization.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-    MockJavaThread* next() { return NULL; }\n+    MockJavaThread* next() { return nullptr; }\n@@ -92,1 +92,1 @@\n-    MockJavaThread* next() { return NULL; }\n+    MockJavaThread* next() { return nullptr; }\n","filename":"test\/hotspot\/gtest\/jfr\/test_threadCpuLoad.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-LogTestFixture::LogTestFixture() : _n_snapshots(0), _configuration_snapshot(NULL) {\n+LogTestFixture::LogTestFixture() : _n_snapshots(0), _configuration_snapshot(nullptr) {\n@@ -101,1 +101,1 @@\n-    if (str != NULL) {\n+    if (str != nullptr) {\n@@ -108,1 +108,1 @@\n-    set_log_config(name, selection, decorators, \/* options = *\/ NULL);\n+    set_log_config(name, selection, decorators, \/* options = *\/ nullptr);\n@@ -113,1 +113,1 @@\n-  if (_configuration_snapshot == NULL) {\n+  if (_configuration_snapshot == nullptr) {\n@@ -121,1 +121,1 @@\n-  _configuration_snapshot = NULL;\n+  _configuration_snapshot = nullptr;\n","filename":"test\/hotspot\/gtest\/logging\/logTestFixture.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  return strstr(haystack, needle) != NULL;\n+  return strstr(haystack, needle) != nullptr;\n@@ -63,1 +63,1 @@\n-  failed = !CreateDirectory(name, NULL);\n+  failed = !CreateDirectory(name, nullptr);\n@@ -118,1 +118,1 @@\n-\/\/ Returns NULL on EOF.\n+\/\/ Returns nullptr on EOF.\n@@ -120,1 +120,1 @@\n-  assert(fp != NULL, \"invalid fp\");\n+  assert(fp != nullptr, \"invalid fp\");\n@@ -124,1 +124,1 @@\n-  if (pos < 0) return NULL;\n+  if (pos < 0) return nullptr;\n@@ -127,1 +127,1 @@\n-  while (ret != NULL && buf[strlen(buf) - 1] != '\\n' && !feof(fp)) {\n+  while (ret != nullptr && buf[strlen(buf) - 1] != '\\n' && !feof(fp)) {\n@@ -142,1 +142,1 @@\n-  assert(fp != NULL, \"error opening file %s: %s\", filename, os::strerror(errno));\n+  assert(fp != nullptr, \"error opening file %s: %s\", filename, os::strerror(errno));\n@@ -145,1 +145,1 @@\n-  while (substrs[idx] != NULL) {\n+  while (substrs[idx] != nullptr) {\n@@ -148,1 +148,1 @@\n-    if (line == NULL) {\n+    if (line == nullptr) {\n@@ -151,1 +151,1 @@\n-    for (char* match = strstr(line, substrs[idx]); match != NULL;) {\n+    for (char* match = strstr(line, substrs[idx]); match != nullptr;) {\n@@ -154,1 +154,1 @@\n-      if (substrs[idx] == NULL) {\n+      if (substrs[idx] == nullptr) {\n@@ -162,1 +162,1 @@\n-  return substrs[idx] == NULL;\n+  return substrs[idx] == nullptr;\n@@ -166,1 +166,1 @@\n-  const char* strs[] = {substr, NULL};\n+  const char* strs[] = {substr, nullptr};\n","filename":"test\/hotspot\/gtest\/logging\/logTestUtils.inline.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-    if (f != NULL) {\n+    if (f != nullptr) {\n@@ -149,1 +149,1 @@\n-  strs[MULTI_LINES] = NULL;\n+  strs[MULTI_LINES] = nullptr;\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    GCTraceTime(Debug, gc) timer(\"Test GC\", NULL, GCCause::_allocation_failure, true);\n+    GCTraceTime(Debug, gc) timer(\"Test GC\", nullptr, GCCause::_allocation_failure, true);\n@@ -54,1 +54,1 @@\n-    NULL\n+    nullptr\n@@ -71,1 +71,1 @@\n-    GCTraceTime(Debug, gc, ref) timer(\"Test GC\", NULL, GCCause::_allocation_failure, true);\n+    GCTraceTime(Debug, gc, ref) timer(\"Test GC\", nullptr, GCCause::_allocation_failure, true);\n@@ -77,1 +77,1 @@\n-    NULL\n+    nullptr\n@@ -92,1 +92,1 @@\n-    GCTraceTime(Debug, gc) timer(\"Test GC\", NULL, GCCause::_allocation_failure, false);\n+    GCTraceTime(Debug, gc) timer(\"Test GC\", nullptr, GCCause::_allocation_failure, false);\n@@ -100,1 +100,1 @@\n-    NULL\n+    nullptr\n@@ -123,1 +123,1 @@\n-    GCTraceTime(Debug, gc) timer(\"Test GC\", NULL, GCCause::_no_gc, true);\n+    GCTraceTime(Debug, gc) timer(\"Test GC\", nullptr, GCCause::_no_gc, true);\n@@ -131,1 +131,1 @@\n-    NULL\n+    nullptr\n@@ -146,1 +146,1 @@\n-    GCTraceTime(Debug, gc) timer(\"Test GC\", NULL, GCCause::_no_gc, false);\n+    GCTraceTime(Debug, gc) timer(\"Test GC\", nullptr, GCCause::_no_gc, false);\n@@ -154,1 +154,1 @@\n-    NULL\n+    nullptr\n","filename":"test\/hotspot\/gtest\/logging\/test_gcTraceTime.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-  ASSERT_NE((void*)NULL, fp);\n+  ASSERT_NE(nullptr, fp);\n@@ -94,1 +94,1 @@\n-  \/\/ Log a dummy line so that fgets doesn't return NULL because the file is empty.\n+  \/\/ Log a dummy line so that fgets doesn't return nullptr because the file is empty.\n@@ -125,1 +125,1 @@\n-  \/\/ Log a dummy line so that fgets doesn't return NULL because the file is empty.\n+  \/\/ Log a dummy line so that fgets doesn't return nullptr because the file is empty.\n@@ -156,1 +156,1 @@\n-  \/\/ Log a dummy line so that fgets doesn't return NULL because the file is empty.\n+  \/\/ Log a dummy line so that fgets doesn't return nullptr because the file is empty.\n","filename":"test\/hotspot\/gtest\/logging\/test_log.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-    for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+    for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -143,1 +143,1 @@\n-    for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+    for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -163,1 +163,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -185,1 +185,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -202,1 +202,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -215,1 +215,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -340,1 +340,1 @@\n-    for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+    for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -430,1 +430,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -444,1 +444,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -461,1 +461,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -479,1 +479,1 @@\n-  LogConfiguration::parse_log_arguments(\"stdout\", \"logging=trace\", NULL, NULL, &ls);\n+  LogConfiguration::parse_log_arguments(\"stdout\", \"logging=trace\", nullptr, nullptr, &ls);\n@@ -495,1 +495,1 @@\n-  bool success = LogConfiguration::parse_log_arguments(\"stdout\", invalid_tagset, NULL, NULL, &ss);\n+  bool success = LogConfiguration::parse_log_arguments(\"stdout\", invalid_tagset, nullptr, nullptr, &ss);\n@@ -530,1 +530,1 @@\n-  for (const char* p = strstr(haystack, needle); p != NULL; p = strstr(p + 1, needle)) {\n+  for (const char* p = strstr(haystack, needle); p != nullptr; p = strstr(p + 1, needle)) {\n@@ -542,1 +542,1 @@\n-  bool success = LogConfiguration::parse_log_arguments(\"#1\", \"all=warning\", NULL, NULL, &ss);\n+  bool success = LogConfiguration::parse_log_arguments(\"#1\", \"all=warning\", nullptr, nullptr, &ss);\n@@ -560,1 +560,1 @@\n-  LogConfiguration::parse_log_arguments(\"stdout\", nonexisting_tagset, NULL, NULL, &ss);\n+  LogConfiguration::parse_log_arguments(\"stdout\", nonexisting_tagset, nullptr, nullptr, &ss);\n","filename":"test\/hotspot\/gtest\/logging\/test_logConfiguration.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-    double cur = strtod(d.decoration(LogDecorators::uptime_decorator, buf, sizeof(buf)), NULL);\n+    double cur = strtod(d.decoration(LogDecorators::uptime_decorator, buf, sizeof(buf)), nullptr);\n@@ -126,1 +126,1 @@\n-      julong val = strtoull(d.decoration(decorator, buf, sizeof(buf)), NULL, 10);\n+      julong val = strtoull(d.decoration(decorator, buf, sizeof(buf)), nullptr, 10);\n@@ -142,1 +142,1 @@\n-  time_t expected_ts = time(NULL);\n+  time_t expected_ts = time(nullptr);\n@@ -177,1 +177,1 @@\n-  time_t expected_ts = time(NULL);\n+  time_t expected_ts = time(nullptr);\n@@ -237,1 +237,1 @@\n-    EXPECT_EQ(ids[i].expected, strtol(reported, NULL, 10));\n+    EXPECT_EQ(ids[i].expected, strtol(reported, nullptr, 10));\n","filename":"test\/hotspot\/gtest\/logging\/test_logDecorations.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-  NULL, \/\/ LogLevel::Off\n+  nullptr, \/\/ LogLevel::Off\n@@ -135,1 +135,1 @@\n-                             \"another error\", \"warning line\", \"debug line\", NULL };\n+                             \"another error\", \"warning line\", \"debug line\", nullptr };\n@@ -159,1 +159,1 @@\n-  const char* expected[] = { start_marker, \"0123456789\", end_marker, NULL };\n+  const char* expected[] = { start_marker, \"0123456789\", end_marker, nullptr };\n@@ -181,1 +181,1 @@\n-  expected_lines[lines] = NULL;\n+  expected_lines[lines] = nullptr;\n@@ -204,1 +204,1 @@\n-  msg.set_prefix(NULL);\n+  msg.set_prefix(nullptr);\n@@ -213,1 +213,1 @@\n-    NULL\n+    nullptr\n@@ -241,1 +241,1 @@\n-  const char* tmp[] = {\"manual flush info\", \"manual flush info\", NULL};\n+  const char* tmp[] = {\"manual flush info\", \"manual flush info\", nullptr};\n","filename":"test\/hotspot\/gtest\/logging\/test_logMessageTest.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -96,1 +96,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n","filename":"test\/hotspot\/gtest\/logging\/test_logSelectionList.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-  const char* message_order[] = {\"1\", \"I am one line\", \"2\", \"but\", \"3\", \"I am not\", NULL};\n+  const char* message_order[] = {\"1\", \"I am one line\", \"2\", \"but\", \"3\", \"I am not\", nullptr};\n@@ -119,1 +119,1 @@\n-  const char* message_order[] = {\"1\", \"2\" , \"3\", \"I am one line\", \"but\", \"I am not\", NULL};\n+  const char* message_order[] = {\"1\", \"2\" , \"3\", \"I am one line\", \"but\", \"I am not\", nullptr};\n","filename":"test\/hotspot\/gtest\/logging\/test_logStream.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-  char* last_tag = NULL;\n+  char* last_tag = nullptr;\n@@ -78,1 +78,1 @@\n-    ASSERT_TRUE(end != NULL) <<  \"line should end with newline\";\n+    ASSERT_TRUE(end != nullptr) <<  \"line should end with newline\";\n@@ -84,1 +84,1 @@\n-    EXPECT_TRUE(last_tag == NULL || strcmp(last_tag, tag) < 0) << tag << \" should be listed before \" << last_tag;\n+    EXPECT_TRUE(last_tag == nullptr || strcmp(last_tag, tag) < 0) << tag << \" should be listed before \" << last_tag;\n","filename":"test\/hotspot\/gtest\/logging\/test_logTag.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -52,1 +52,1 @@\n-  EXPECT_FALSE(ts.has_output(NULL));\n+  EXPECT_FALSE(ts.has_output(nullptr));\n@@ -143,1 +143,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -158,1 +158,1 @@\n-    for (LogTagSet* other = ts->next(); other != NULL; other = other->next()) {\n+    for (LogTagSet* other = ts->next(); other != nullptr; other = other->next()) {\n","filename":"test\/hotspot\/gtest\/logging\/test_logTagSet.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  for (LogTagSetDescription* d = tagset_descriptions; d->tagset != NULL; d++) {\n+  for (LogTagSetDescription* d = tagset_descriptions; d->tagset != nullptr; d++) {\n@@ -54,1 +54,1 @@\n-  ASSERT_NE((void*)NULL, fp);\n+  ASSERT_NE((void*)nullptr, fp);\n@@ -59,1 +59,1 @@\n-  for (LogTagSetDescription* d = tagset_descriptions; d->tagset != NULL; d++) {\n+  for (LogTagSetDescription* d = tagset_descriptions; d->tagset != nullptr; d++) {\n","filename":"test\/hotspot\/gtest\/logging\/test_logTagSetDescriptions.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-\/\/ Test behavior for Afree(NULL) and Arealloc(NULL, x)\n+\/\/ Test behavior for Afree(nullptr) and Arealloc(nullptr, x)\n@@ -100,1 +100,1 @@\n-  ar.Afree(NULL, 10); \/\/ should just be ignored\n+  ar.Afree(nullptr, 10); \/\/ should just be ignored\n@@ -105,1 +105,1 @@\n-  void* p = ar.Arealloc(NULL, 0, 20); \/\/ equivalent to Amalloc(20)\n+  void* p = ar.Arealloc(nullptr, 0, 20); \/\/ equivalent to Amalloc(20)\n@@ -241,1 +241,1 @@\n-    void* p = NULL;\n+    void* p = nullptr;\n@@ -300,1 +300,1 @@\n-      ptrs[i] = NULL;\n+      ptrs[i] = nullptr;\n","filename":"test\/hotspot\/gtest\/memory\/test_arena.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-  ASSERT_TRUE(p != NULL) << \"NULL pointer given to check\";\n+  ASSERT_TRUE(p != nullptr) << \"nullptr pointer given to check\";\n@@ -133,1 +133,1 @@\n-  EXPECT_TRUE(GuardedMemory::free_copy(NULL)) << \"Expected free NULL to be OK\";\n+  EXPECT_TRUE(GuardedMemory::free_copy(nullptr)) << \"Expected free nullptr to be OK\";\n@@ -138,1 +138,1 @@\n-  guarded_memory_test_check(str_copy, str_sz, NULL);\n+  guarded_memory_test_check(str_copy, str_sz, nullptr);\n@@ -145,1 +145,1 @@\n-  void* no_data = NULL;\n+  void* no_data = nullptr;\n","filename":"test\/hotspot\/gtest\/memory\/test_guardedMemory.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    EXPECT_TRUE(rs.base() != NULL) << \"rs.special: \" << rs.special();\n+    EXPECT_TRUE(rs.base() != nullptr) << \"rs.special: \" << rs.special();\n@@ -81,1 +81,1 @@\n-    ReservedSpace rs(size, alignment, page_size, (char *) NULL);\n+    ReservedSpace rs(size, alignment, page_size, (char *) nullptr);\n@@ -83,1 +83,1 @@\n-    ASSERT_TRUE(rs.base() != NULL) << \"rs.special = \" << rs.special();\n+    ASSERT_TRUE(rs.base() != nullptr) << \"rs.special = \" << rs.special();\n@@ -112,1 +112,1 @@\n-    EXPECT_TRUE(rs.base() != NULL) << \"rs.special: \" << rs.special();\n+    EXPECT_TRUE(rs.base() != nullptr) << \"rs.special: \" << rs.special();\n@@ -372,1 +372,1 @@\n-                     (char *)NULL); \/\/ requested_address\n+                     (char *)nullptr); \/\/ requested_address\n@@ -374,1 +374,1 @@\n-    EXPECT_TRUE(rs.base() != NULL);\n+    EXPECT_TRUE(rs.base() != nullptr);\n@@ -392,1 +392,1 @@\n-    EXPECT_TRUE(rs.base() != NULL);\n+    EXPECT_TRUE(rs.base() != nullptr);\n@@ -417,1 +417,1 @@\n-    EXPECT_TRUE(rs.base() != NULL);\n+    EXPECT_TRUE(rs.base() != nullptr);\n","filename":"test\/hotspot\/gtest\/memory\/test_virtualspace.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  assert(word_size > 0 && p != NULL, \"sanity\");\n+  assert(word_size > 0 && p != nullptr, \"sanity\");\n@@ -64,1 +64,1 @@\n-  assert(p != NULL, \"sanity\");\n+  assert(p != nullptr, \"sanity\");\n@@ -77,1 +77,1 @@\n-  assert(word_size > 0 && p != NULL, \"sanity\");\n+  assert(word_size > 0 && p != nullptr, \"sanity\");\n@@ -83,1 +83,1 @@\n-  assert(word_size > 0 && p != NULL, \"sanity\");\n+  assert(word_size > 0 && p != nullptr, \"sanity\");\n@@ -89,1 +89,1 @@\n-  assert(word_size > 0 && p != NULL, \"sanity\");\n+  assert(word_size > 0 && p != nullptr, \"sanity\");\n","filename":"test\/hotspot\/gtest\/metaspace\/metaspaceGtestCommon.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  TestMap(size_t len) : _len(len), _arr(NULL) {\n+  TestMap(size_t len) : _len(len), _arr(nullptr) {\n@@ -148,1 +148,1 @@\n-\/\/ Some helpers to avoid typing out those annoying casts for NULL\n+\/\/ Some helpers to avoid typing out those annoying casts for nullptr\n@@ -150,4 +150,4 @@\n-#define ASSERT_NOT_NULL(ptr)      ASSERT_NE((void*)NULL, (void*)ptr)\n-#define ASSERT_NULL(ptr)          ASSERT_EQ((void*)NULL, (void*)ptr)\n-#define EXPECT_NOT_NULL(ptr)      EXPECT_NE((void*)NULL, (void*)ptr)\n-#define EXPECT_NULL(ptr)          EXPECT_EQ((void*)NULL, (void*)ptr)\n+#define ASSERT_NOT_NULL(ptr)      ASSERT_NE(nullptr, (void*)ptr)\n+#define ASSERT_NULL(ptr)          ASSERT_EQ(nullptr, (void*)ptr)\n+#define EXPECT_NOT_NULL(ptr)      EXPECT_NE(nullptr, (void*)ptr)\n+#define EXPECT_NULL(ptr)          EXPECT_EQ(nullptr, (void*)ptr)\n@@ -191,1 +191,1 @@\n-  FeederBuffer(size_t size) : _buf(NULL), _cap(size), _used(0) {\n+  FeederBuffer(size_t size) : _buf(nullptr), _cap(size), _used(0) {\n@@ -201,1 +201,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"test\/hotspot\/gtest\/metaspace\/metaspaceGtestCommon.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  *p_return_value = NULL;\n+  *p_return_value = nullptr;\n@@ -41,1 +41,1 @@\n-  if (c != NULL) {\n+  if (c != nullptr) {\n","filename":"test\/hotspot\/gtest\/metaspace\/metaspaceGtestContexts.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n","filename":"test\/hotspot\/gtest\/metaspace\/metaspaceGtestContexts.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,2 +71,2 @@\n-    case cond_null:     return _slots[slot] == NULL;\n-    case cond_non_null: return _slots[slot] != NULL;\n+    case cond_null:     return _slots[slot] == nullptr;\n+    case cond_non_null: return _slots[slot] != nullptr;\n@@ -98,1 +98,1 @@\n-      _slots[i] = NULL;\n+      _slots[i] = nullptr;\n@@ -112,1 +112,1 @@\n-  bool slot_is_null(int i) const                      { check_index(i); return _slots[i] == NULL; }\n+  bool slot_is_null(int i) const                      { check_index(i); return _slots[i] == nullptr; }\n","filename":"test\/hotspot\/gtest\/metaspace\/metaspaceGtestSparseArray.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    EXPECT_EQ(p, (MetaWord*)NULL);\n+    EXPECT_EQ(p, (MetaWord*)nullptr);\n@@ -105,1 +105,1 @@\n-          EXPECT_EQ(p, (MetaWord*)NULL);\n+          EXPECT_EQ(p, (MetaWord*)nullptr);\n@@ -138,1 +138,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -159,1 +159,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -169,1 +169,1 @@\n-        ASSERT_EQ(real_size, (size_t)NULL);\n+        ASSERT_EQ(real_size, (size_t)nullptr);\n@@ -188,1 +188,1 @@\n-        ASSERT_NE(p, (MetaWord*) NULL);\n+        ASSERT_NE(p, (MetaWord*) nullptr);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_binlist.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-  MetaWord* p = NULL;\n+  MetaWord* p = nullptr;\n@@ -281,1 +281,1 @@\n-    MetaWord* p = NULL;\n+    MetaWord* p = nullptr;\n@@ -309,1 +309,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -316,1 +316,1 @@\n-    } while (p != NULL && added < max_blocks);\n+    } while (p != nullptr && added < max_blocks);\n@@ -338,1 +338,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n","filename":"test\/hotspot\/gtest\/metaspace\/test_blocktree.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -121,1 +121,1 @@\n-    if (c == NULL) {\n+    if (c == nullptr) {\n@@ -165,1 +165,1 @@\n-    _chunks.set_at(slot, NULL);\n+    _chunks.set_at(slot, nullptr);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_chunkManager_stress.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    if (_elems[index] == NULL) {\n+    if (_elems[index] == nullptr) {\n@@ -56,1 +56,1 @@\n-    _elems[index] = NULL;\n+    _elems[index] = nullptr;\n@@ -69,1 +69,1 @@\n-    if (_elems[index] != NULL) {\n+    if (_elems[index] != nullptr) {\n@@ -85,1 +85,1 @@\n-    if (_elems[index] == NULL) {\n+    if (_elems[index] == nullptr) {\n","filename":"test\/hotspot\/gtest\/metaspace\/test_chunkheaderpool.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-    if (p != NULL) {\n+    if (p != nullptr) {\n@@ -85,1 +85,1 @@\n-    if (a != NULL) {\n+    if (a != nullptr) {\n@@ -104,1 +104,1 @@\n-    if (p != NULL) {\n+    if (p != nullptr) {\n@@ -118,1 +118,1 @@\n-    for (allocation_t* a = _allocations; a != NULL; a = a->next) {\n+    for (allocation_t* a = _allocations; a != nullptr; a = a->next) {\n@@ -180,1 +180,1 @@\n-    _allocations(NULL),\n+    _allocations(nullptr),\n","filename":"test\/hotspot\/gtest\/metaspace\/test_freeblocks.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-  MetaspaceIsMetaspaceObjTest() : _lock(NULL), _ms(NULL) {}\n+  MetaspaceIsMetaspaceObjTest() : _lock(nullptr), _ms(nullptr) {}\n@@ -78,1 +78,1 @@\n-    ASSERT_FALSE(MetaspaceObj::is_valid((MetaspaceObj*)NULL));\n+    ASSERT_FALSE(MetaspaceObj::is_valid((MetaspaceObj*)nullptr));\n@@ -96,1 +96,1 @@\n-    _ms = NULL;\n+    _ms = nullptr;\n@@ -98,1 +98,1 @@\n-    _lock = NULL;\n+    _lock = nullptr;\n","filename":"test\/hotspot\/gtest\/metaspace\/test_is_metaspace_obj.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  Metachunk* c = NULL;\n+  Metachunk* c = nullptr;\n@@ -73,1 +73,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -106,1 +106,1 @@\n-  Metachunk* c = NULL;\n+  Metachunk* c = nullptr;\n@@ -139,1 +139,1 @@\n-  Metachunk* c = NULL;\n+  Metachunk* c = nullptr;\n@@ -155,1 +155,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -170,1 +170,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -205,1 +205,1 @@\n-    Metachunk* c1 = NULL;\n+    Metachunk* c1 = nullptr;\n@@ -209,1 +209,1 @@\n-    Metachunk* c2 = NULL;\n+    Metachunk* c2 = nullptr;\n@@ -237,1 +237,1 @@\n-  Metachunk* c = NULL;\n+  Metachunk* c = nullptr;\n@@ -313,1 +313,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -390,1 +390,1 @@\n-  Metachunk* c = NULL;\n+  Metachunk* c = nullptr;\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metachunk.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -98,1 +98,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -125,1 +125,1 @@\n-    while (c != NULL) {\n+    while (c != nullptr) {\n@@ -156,1 +156,1 @@\n-  Metachunk* c = NULL;\n+  Metachunk* c = nullptr;\n@@ -165,1 +165,1 @@\n-  Metachunk* c_0 = NULL;\n+  Metachunk* c_0 = nullptr;\n@@ -169,1 +169,1 @@\n-  Metachunk* c_full = NULL;\n+  Metachunk* c_full = nullptr;\n@@ -173,1 +173,1 @@\n-  Metachunk* c_1g = NULL;\n+  Metachunk* c_1g = nullptr;\n@@ -177,1 +177,1 @@\n-  Metachunk* c_2g = NULL;\n+  Metachunk* c_2g = nullptr;\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metachunklist.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-    if (_arena != NULL) {\n+    if (_arena != nullptr) {\n@@ -104,1 +104,1 @@\n-      _arena = NULL;\n+      _arena = nullptr;\n@@ -114,2 +114,2 @@\n-    if (p_used != NULL) {\n-      if (p_committed != NULL) {\n+    if (p_used != nullptr) {\n+      if (p_committed != nullptr) {\n@@ -121,1 +121,1 @@\n-    if (p_committed != NULL && p_capacity != NULL) {\n+    if (p_committed != nullptr && p_capacity != nullptr) {\n@@ -134,1 +134,1 @@\n-    MetaWord* dummy = NULL;\n+    MetaWord* dummy = nullptr;\n@@ -140,1 +140,1 @@\n-    MetaWord* dummy = NULL;\n+    MetaWord* dummy = nullptr;\n@@ -161,1 +161,1 @@\n-    if (p == NULL) {\n+    if (p == nullptr) {\n@@ -184,1 +184,1 @@\n-    MetaWord* dummy = NULL;\n+    MetaWord* dummy = nullptr;\n@@ -409,1 +409,1 @@\n-    MetaWord* p1 = NULL;\n+    MetaWord* p1 = nullptr;\n@@ -413,1 +413,1 @@\n-    helper.usage_numbers_with_test(&used1, NULL, &capacity1);\n+    helper.usage_numbers_with_test(&used1, nullptr, &capacity1);\n@@ -419,1 +419,1 @@\n-    helper.usage_numbers_with_test(&used2, NULL, &capacity2);\n+    helper.usage_numbers_with_test(&used2, nullptr, &capacity2);\n@@ -423,1 +423,1 @@\n-    MetaWord* p2 = NULL;\n+    MetaWord* p2 = nullptr;\n@@ -427,1 +427,1 @@\n-    helper.usage_numbers_with_test(&used3, NULL, &capacity3);\n+    helper.usage_numbers_with_test(&used3, nullptr, &capacity3);\n@@ -474,2 +474,2 @@\n-  MetaWord* p = NULL;\n-  while ( (helper3.allocate_from_arena_with_tests(&p, 1), p != NULL) &&\n+  MetaWord* p = nullptr;\n+  while ( (helper3.allocate_from_arena_with_tests(&p, 1), p != nullptr) &&\n@@ -735,1 +735,1 @@\n-    MetaWord* p = NULL, *p2 = NULL;\n+    MetaWord* p = nullptr, *p2 = nullptr;\n@@ -748,1 +748,1 @@\n-    helper.usage_numbers_with_test(&used1, &committed1, NULL);\n+    helper.usage_numbers_with_test(&used1, &committed1, nullptr);\n@@ -759,1 +759,1 @@\n-    helper.usage_numbers_with_test(&used2, &committed2, NULL);\n+    helper.usage_numbers_with_test(&used2, &committed2, nullptr);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-    MetaWord* p; \/\/ NULL if deallocated\n+    MetaWord* p; \/\/ nullptr if deallocated\n@@ -75,1 +75,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -131,1 +131,1 @@\n-    _arena(NULL),\n+    _arena(nullptr),\n@@ -134,1 +134,1 @@\n-    _allocations(NULL),\n+    _allocations(nullptr),\n@@ -146,1 +146,1 @@\n-    while (a != NULL) {\n+    while (a != nullptr) {\n@@ -169,1 +169,1 @@\n-    if (p != NULL) {\n+    if (p != nullptr) {\n@@ -193,1 +193,1 @@\n-    while (a && a->p != NULL && os::random() % 10 != 0) {\n+    while (a && a->p != nullptr && os::random() % 10 != 0) {\n@@ -196,1 +196,1 @@\n-    if (a != NULL && a->p != NULL) {\n+    if (a != nullptr && a->p != nullptr) {\n@@ -200,1 +200,1 @@\n-      a->p = NULL; a->word_size = 0;\n+      a->p = nullptr; a->word_size = 0;\n@@ -260,1 +260,1 @@\n-    _testbeds.set_at(slotindex, NULL);\n+    _testbeds.set_at(slotindex, nullptr);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena_stress.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -261,1 +261,1 @@\n-    Metachunk* result = NULL;\n+    Metachunk* result = nullptr;\n@@ -296,1 +296,1 @@\n-    _node(NULL),\n+    _node(nullptr),\n@@ -330,1 +330,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -334,1 +334,1 @@\n-      if (c != NULL) {\n+      if (c != nullptr) {\n@@ -337,1 +337,1 @@\n-    } while (c != NULL && rc);\n+    } while (c != nullptr && rc);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_virtualspacenode.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,1 +112,1 @@\n-  \/\/ very low, like the result of an overflow or of accessing a NULL this pointer\n+  \/\/ very low, like the result of an overflow or of accessing a null this pointer\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-    p4 = os_realloc(NULL, 10);           \/\/ realloc with NULL pointer\n+    p4 = os_realloc(nullptr, 10);        \/\/ realloc with null pointer\n@@ -91,1 +91,1 @@\n-    os::free(NULL);                      \/\/ free(null)\n+    os::free(nullptr);                      \/\/ free(null)\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmtpreinit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-    allocations[i] = NULL;\n+    allocations[i] = nullptr;\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmtpreinitmap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,4 +86,4 @@\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-      << \"thr->_threads_hazard_ptr must be NULL\";\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) NULL)\n-      << \"thr->_threads_list_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+      << \"thr->_threads_hazard_ptr must be null\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) nullptr)\n+      << \"thr->_threads_list_ptr must be null\";\n@@ -108,2 +108,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -128,4 +128,4 @@\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-      << \"thr->_threads_hazard_ptr must match be NULL\";\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) NULL)\n-      << \"thr->_threads_list_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+      << \"thr->_threads_hazard_ptr must match be null\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) nullptr)\n+      << \"thr->_threads_list_ptr must be null\";\n@@ -150,2 +150,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -196,2 +196,2 @@\n-      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-          << \"list_ptr1->previous() must be NULL\";\n+      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+          << \"list_ptr1->previous() must be null\";\n@@ -216,3 +216,3 @@\n-    \/\/ Verify the current thread's hazard ptr is NULL:\n-    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-        << \"thr->_threads_hazard_ptr must be NULL\";\n+    \/\/ Verify the current thread's hazard ptr is null:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+        << \"thr->_threads_hazard_ptr must be null\";\n@@ -226,2 +226,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -248,4 +248,4 @@\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-      << \"thr->_threads_hazard_ptr must match be NULL\";\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) NULL)\n-      << \"thr->_threads_list_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+      << \"thr->_threads_hazard_ptr must match be null\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) nullptr)\n+      << \"thr->_threads_list_ptr must be null\";\n@@ -270,2 +270,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -316,2 +316,2 @@\n-      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-          << \"list_ptr1->previous() must be NULL\";\n+      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+          << \"list_ptr1->previous() must be null\";\n@@ -380,2 +380,2 @@\n-        EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-            << \"list_ptr1->previous() must be NULL\";\n+        EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+            << \"list_ptr1->previous() must be null\";\n@@ -400,3 +400,3 @@\n-      \/\/ Verify the current thread's hazard ptr is NULL:\n-      EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-          << \"thr->_threads_hazard_ptr must be NULL\";\n+      \/\/ Verify the current thread's hazard ptr is null:\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+          << \"thr->_threads_hazard_ptr must be null\";\n@@ -428,2 +428,2 @@\n-      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-          << \"list_ptr1->previous() must be NULL\";\n+      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+          << \"list_ptr1->previous() must be null\";\n@@ -448,3 +448,3 @@\n-    \/\/ Verify the current thread's hazard ptr is NULL:\n-    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-        << \"thr->_threads_hazard_ptr must be NULL\";\n+    \/\/ Verify the current thread's hazard ptr is null:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+        << \"thr->_threads_hazard_ptr must be null\";\n@@ -458,2 +458,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -480,4 +480,4 @@\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-      << \"thr->_threads_hazard_ptr must match be NULL\";\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) NULL)\n-      << \"thr->_threads_list_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+      << \"thr->_threads_hazard_ptr must match be null\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) nullptr)\n+      << \"thr->_threads_list_ptr must be null\";\n@@ -502,2 +502,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -548,2 +548,2 @@\n-      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-          << \"list_ptr1->previous() must be NULL\";\n+      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+          << \"list_ptr1->previous() must be null\";\n@@ -568,3 +568,3 @@\n-    \/\/ Verify the current thread's hazard ptr is NULL:\n-    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-        << \"thr->_threads_hazard_ptr must be NULL\";\n+    \/\/ Verify the current thread's hazard ptr is null:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+        << \"thr->_threads_hazard_ptr must be null\";\n@@ -578,2 +578,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -626,2 +626,2 @@\n-      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-          << \"list_ptr1->previous() must be NULL\";\n+      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+          << \"list_ptr1->previous() must be null\";\n@@ -646,3 +646,3 @@\n-    \/\/ Verify the current thread's hazard ptr is NULL:\n-    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-        << \"thr->_threads_hazard_ptr must be NULL\";\n+    \/\/ Verify the current thread's hazard ptr is null:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+        << \"thr->_threads_hazard_ptr must be null\";\n@@ -656,2 +656,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -678,4 +678,4 @@\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-      << \"thr->_threads_hazard_ptr must match be NULL\";\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) NULL)\n-      << \"thr->_threads_list_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+      << \"thr->_threads_hazard_ptr must match be null\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) nullptr)\n+      << \"thr->_threads_list_ptr must be null\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_ThreadsListHandle.cpp","additions":64,"deletions":64,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,1 @@\n-  jint err = parse_xss(NULL \/* Silence error messages *\/, str, &value);\n+  jint err = parse_xss(nullptr \/* Silence error messages *\/, str, &value);\n@@ -234,1 +234,1 @@\n-    if (str == NULL) {\n+    if (str == nullptr) {\n@@ -276,1 +276,1 @@\n-      NULL,\n+      nullptr,\n@@ -286,1 +286,1 @@\n-      NULL,\n+      nullptr,\n@@ -296,1 +296,1 @@\n-      NULL,\n+      nullptr,\n@@ -452,1 +452,1 @@\n-  if (flag == NULL) { \/\/ not available in product builds\n+  if (flag == nullptr) { \/\/ not available in product builds\n@@ -467,1 +467,1 @@\n-  if (flag == NULL) { \/\/ not available in product builds\n+  if (flag == nullptr) { \/\/ not available in product builds\n@@ -482,1 +482,1 @@\n-  if (flag == NULL) { \/\/ not available in product builds\n+  if (flag == nullptr) { \/\/ not available in product builds\n@@ -498,1 +498,1 @@\n-  if (flag == NULL) { \/\/ not available in product builds\n+  if (flag == nullptr) { \/\/ not available in product builds\n@@ -558,1 +558,1 @@\n-  if (flag == NULL) { \/\/ not available in product builds\n+  if (flag == nullptr) { \/\/ not available in product builds\n@@ -600,1 +600,1 @@\n-    if (errno == 0 && end != NULL && *end == '\\0') {\n+    if (errno == 0 && end != nullptr && *end == '\\0') {\n","filename":"test\/hotspot\/gtest\/runtime\/test_arguments.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,3 @@\n-  TempNewSymbol retval = ClassLoader::package_from_class_name(NULL, &bad_class_name);\n-  ASSERT_TRUE(bad_class_name) << \"Function did not set bad_class_name with NULL class name\";\n-  ASSERT_TRUE(retval == NULL) << \"Wrong package for NULL class name pointer\";\n+  TempNewSymbol retval = ClassLoader::package_from_class_name(nullptr, &bad_class_name);\n+  ASSERT_TRUE(bad_class_name) << \"Function did not set bad_class_name with null class name\";\n+  ASSERT_TRUE(retval == nullptr) << \"Wrong package for null class name pointer\";\n@@ -42,1 +42,1 @@\n-  ASSERT_TRUE(retval == NULL) << \"Wrong package for empty string\";\n+  ASSERT_TRUE(retval == nullptr) << \"Wrong package for empty string\";\n@@ -50,1 +50,1 @@\n-  ASSERT_TRUE(retval == NULL) << \"Wrong package for class with no slashes\";\n+  ASSERT_TRUE(retval == nullptr) << \"Wrong package for class with no slashes\";\n@@ -58,1 +58,1 @@\n-  ASSERT_TRUE(retval == NULL) << \"Wrong package for class with just slash\";\n+  ASSERT_TRUE(retval == nullptr) << \"Wrong package for class with just slash\";\n@@ -106,1 +106,1 @@\n-  ASSERT_TRUE(retval == NULL) << \"Wrong package for class with leading '[L'\";\n+  ASSERT_TRUE(retval == nullptr) << \"Wrong package for class with leading '[L'\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_classLoader.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    ASSERT_TRUE(rmr != NULL);\n+    ASSERT_TRUE(rmr != nullptr);\n@@ -61,1 +61,1 @@\n-    for (const CommittedMemoryRegion* region = iter.next(); region != NULL; region = iter.next()) {\n+    for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n@@ -98,1 +98,1 @@\n-    ASSERT_NE(base, (char*)NULL);\n+    ASSERT_NE(base, (char*)nullptr);\n@@ -112,1 +112,1 @@\n-    ASSERT_TRUE(rmr != NULL);\n+    ASSERT_TRUE(rmr != nullptr);\n@@ -116,1 +116,1 @@\n-    for (const CommittedMemoryRegion* region = iter.next(); region != NULL; region = iter.next()) {\n+    for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n@@ -119,1 +119,1 @@\n-        ASSERT_TRUE(iter.next() == NULL);\n+        ASSERT_TRUE(iter.next() == nullptr);\n@@ -139,1 +139,1 @@\n-    ASSERT_TRUE(rmr == NULL);\n+    ASSERT_TRUE(rmr == nullptr);\n@@ -164,1 +164,1 @@\n-    ASSERT_NE(base, (char*)NULL);\n+    ASSERT_NE(base, (char*)nullptr);\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-  JVMFlag* flag = (name == NULL) ? NULL : JVMFlag::find_flag(name);\n+  JVMFlag* flag = (name == nullptr) ? nullptr : JVMFlag::find_flag(name);\n@@ -104,1 +104,1 @@\n-  ASSERT_EQ((get_flag<JVM_FLAG_TYPE(int)>(NULL)), JVMFlag::INVALID_FLAG);\n+  ASSERT_EQ((get_flag<JVM_FLAG_TYPE(int)>(nullptr)), JVMFlag::INVALID_FLAG);\n","filename":"test\/hotspot\/gtest\/runtime\/test_globals.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -316,2 +316,2 @@\n-  check_snprintf_result(0, 0, pf(NULL, 0, \"%s\", \"\"), expect_count);\n-  check_snprintf_result(0, 0, pf(NULL, 0, \"\"), expect_count);\n+  check_snprintf_result(0, 0, pf(nullptr, 0, \"%s\", \"\"), expect_count);\n+  check_snprintf_result(0, 0, pf(nullptr, 0, \"\"), expect_count);\n@@ -371,1 +371,1 @@\n-  bool exec_supported = (p != NULL);\n+  bool exec_supported = (p != nullptr);\n@@ -404,2 +404,2 @@\n-  address p = NULL;\n-  for (int tries = 0; tries < 256 && p == NULL; tries ++) {\n+  address p = nullptr;\n+  for (int tries = 0; tries < 256 && p == nullptr; tries ++) {\n@@ -409,1 +409,1 @@\n-    EXPECT_NE(p, (address)NULL);\n+    EXPECT_NE(p, (address)nullptr);\n@@ -423,1 +423,1 @@\n-      if (q == NULL) {\n+      if (q == nullptr) {\n@@ -427,1 +427,1 @@\n-        p = NULL;\n+        p = nullptr;\n@@ -443,1 +443,1 @@\n-  EXPECT_NE(p, (address)NULL);\n+  EXPECT_NE(p, (address)nullptr);\n@@ -494,1 +494,1 @@\n-  ASSERT_NE(p, (address)NULL);\n+  ASSERT_NE(p, (address)nullptr);\n@@ -533,1 +533,1 @@\n-  ASSERT_NE(p, (char*)NULL);\n+  ASSERT_NE(p, (char*)nullptr);\n@@ -627,1 +627,1 @@\n-  ASSERT_FALSE(os::win32::find_mapping((address)NULL, &mapping_info));\n+  ASSERT_FALSE(os::win32::find_mapping((address)nullptr, &mapping_info));\n@@ -633,1 +633,1 @@\n-    ASSERT_NE(p, (address)NULL);\n+    ASSERT_NE(p, (address)nullptr);\n@@ -662,1 +662,1 @@\n-  ASSERT_NE(p, (address)NULL);\n+  ASSERT_NE(p, (address)nullptr);\n@@ -691,1 +691,1 @@\n-    ASSERT_NE(p, (address)NULL);\n+    ASSERT_NE(p, (address)nullptr);\n@@ -798,2 +798,2 @@\n-  LOG(\"os::print_function_and_library_name(st, NULL) expects FALSE.\");\n-  addr = NULL;\n+  LOG(\"os::print_function_and_library_name(st, nullptr) expects FALSE.\");\n+  addr = nullptr;\n@@ -816,1 +816,1 @@\n-                                                    provide_scratch_buffer ? tmp : NULL,\n+                                                    provide_scratch_buffer ? tmp : nullptr,\n@@ -862,1 +862,1 @@\n-  const char* result = NULL;\n+  const char* result = nullptr;\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-      if (_ptr != NULL) {\n+      if (_ptr != nullptr) {\n@@ -84,1 +84,1 @@\n-    char* addr = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs(size, lp, lp, NULL, false);\n+    char* addr = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs(size, lp, lp, nullptr, false);\n@@ -86,1 +86,1 @@\n-    if (addr != NULL) {\n+    if (addr != nullptr) {\n@@ -110,2 +110,2 @@\n-      char* p = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs(size, alignment, lp, NULL, false);\n-      if (p != NULL) {\n+      char* p = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs(size, alignment, lp, nullptr, false);\n+      if (p != nullptr) {\n@@ -138,1 +138,1 @@\n-  char* const mapping = (char*) ::mmap(NULL, mapping_size,\n+  char* const mapping = (char*) ::mmap(nullptr, mapping_size,\n@@ -151,1 +151,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -179,1 +179,1 @@\n-  char* const mapping = (char*) ::mmap(NULL, mapping_size,\n+  char* const mapping = (char*) ::mmap(nullptr, mapping_size,\n@@ -203,2 +203,2 @@\n-      \/\/ return NULL (as per contract, it cannot return another address)\n-      EXPECT_TRUE(p == NULL) << \" size = \" << size\n+      \/\/ return null (as per contract, it cannot return another address)\n+      EXPECT_TRUE(p == nullptr) << \" size = \" << size\n@@ -227,2 +227,2 @@\n-    char* addr = os::reserve_memory_special(size, alignment, page_size, NULL, false);\n-    if (addr != NULL) {\n+    char* addr = os::reserve_memory_special(size, alignment, page_size, nullptr, false);\n+    if (addr != nullptr) {\n@@ -257,1 +257,1 @@\n-    \/\/ 1) with req_addr == NULL\n+    \/\/ 1) with req_addr == nullptr\n@@ -265,1 +265,1 @@\n-    char* const mapping1 = (char*) ::mmap(NULL, mapping_size,\n+    char* const mapping1 = (char*) ::mmap(nullptr, mapping_size,\n@@ -270,1 +270,1 @@\n-    char* const mapping2 = (char*) ::mmap(NULL, mapping_size,\n+    char* const mapping2 = (char*) ::mmap(nullptr, mapping_size,\n@@ -284,2 +284,2 @@\n-        char* p = os::reserve_memory_special(size, alignment, lp, NULL, false);\n-        if (p != NULL) {\n+        char* p = os::reserve_memory_special(size, alignment, lp, nullptr, false);\n+        if (p != nullptr) {\n@@ -300,1 +300,1 @@\n-        if (p != NULL) {\n+        if (p != nullptr) {\n@@ -316,2 +316,2 @@\n-        \/\/ return NULL (as per contract, it cannot return another address)\n-        EXPECT_TRUE(p == NULL);\n+        \/\/ return nullptr (as per contract, it cannot return another address)\n+        EXPECT_TRUE(p == nullptr);\n@@ -353,0 +353,34 @@\n+TEST_VM(os_linux, pretouch_thp_and_use_concurrent) {\n+  \/\/ Explicitly enable thp to test cocurrent system calls.\n+  const size_t size = 1 * G;\n+  const bool useThp = UseTransparentHugePages;\n+  UseTransparentHugePages = true;\n+  char* const heap = os::reserve_memory(size, false, mtInternal);\n+  EXPECT_NE(heap, (char*)NULL);\n+  EXPECT_TRUE(os::commit_memory(heap, size, false));\n+\n+  {\n+    auto pretouch = [heap, size](Thread*, int) {\n+      os::pretouch_memory(heap, heap + size, os::vm_page_size());\n+    };\n+    auto useMemory = [heap, size](Thread*, int) {\n+      int* iptr = reinterpret_cast<int*>(heap);\n+      for (int i = 0; i < 1000; i++) *iptr++ = i;\n+    };\n+    TestThreadGroup<decltype(pretouch)> pretouchThreads{pretouch, 4};\n+    TestThreadGroup<decltype(useMemory)> useMemoryThreads{useMemory, 4};\n+    useMemoryThreads.doit();\n+    pretouchThreads.doit();\n+    useMemoryThreads.join();\n+    pretouchThreads.join();\n+  }\n+\n+  int* iptr = reinterpret_cast<int*>(heap);\n+  for (int i = 0; i < 1000; i++)\n+    EXPECT_EQ(*iptr++, i);\n+\n+  EXPECT_TRUE(os::uncommit_memory(heap, size, false));\n+  EXPECT_TRUE(os::release_memory(heap, size));\n+  UseTransparentHugePages = useThp;\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":55,"deletions":21,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    NULL,                   \/\/ root_path, ignored\n+    nullptr,                \/\/ root_path, ignored\n@@ -72,1 +72,1 @@\n-    NULL,                   \/\/ root_path, ignored\n+    nullptr,                \/\/ root_path, ignored\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux_cgroups.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-      if (_ptr != NULL) {\n+      if (_ptr != nullptr) {\n@@ -56,1 +56,1 @@\n-\/\/ different valid one. A NULL return value at this point is not considered an error but may\n+\/\/ different valid one. A nullptr return value at this point is not considered an error but may\n@@ -70,2 +70,2 @@\n-  char* result = os::reserve_memory_special(large_allocation_size, os::large_page_size(), os::large_page_size(), NULL, false);\n-  if (result == NULL) {\n+  char* result = os::reserve_memory_special(large_allocation_size, os::large_page_size(), os::large_page_size(), nullptr, false);\n+  if (result == nullptr) {\n@@ -81,1 +81,1 @@\n-  EXPECT_TRUE(actual_location == NULL) << \"Should not be allowed to reserve within present reservation\";\n+  EXPECT_TRUE(actual_location == nullptr) << \"Should not be allowed to reserve within present reservation\";\n@@ -86,1 +86,1 @@\n-  EXPECT_TRUE(actual_location != NULL) << \"Unexpected reservation failure, can’t verify correct location\";\n+  EXPECT_TRUE(actual_location != nullptr) << \"Unexpected reservation failure, can’t verify correct location\";\n@@ -93,2 +93,2 @@\n-  char* aligned_request = os::reserve_memory_special(new_large_size, alignment, os::large_page_size(), NULL, false);\n-  EXPECT_TRUE(aligned_request != NULL) << \"Unexpected reservation failure, can’t verify correct alignment\";\n+  char* aligned_request = os::reserve_memory_special(new_large_size, alignment, os::large_page_size(), nullptr, false);\n+  EXPECT_TRUE(aligned_request != nullptr) << \"Unexpected reservation failure, can’t verify correct alignment\";\n@@ -142,1 +142,1 @@\n-  BOOL result = CreateDirectoryW(abs_path, NULL);\n+  BOOL result = CreateDirectoryW(abs_path, nullptr);\n@@ -168,1 +168,1 @@\n-  HANDLE h = CreateFileW(abs_path, 0, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);\n+  HANDLE h = CreateFileW(abs_path, 0, 0, nullptr, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, nullptr);\n@@ -221,1 +221,1 @@\n-    if (path_start == NULL) {\n+    if (path_start == nullptr) {\n@@ -248,1 +248,1 @@\n-      } else if (path_start != NULL) {\n+      } else if (path_start != nullptr) {\n@@ -400,1 +400,1 @@\n-        if (w_path != NULL) {\n+        if (w_path != nullptr) {\n@@ -420,1 +420,1 @@\n-            HANDLE h = ::CreateFileW(w_path, 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+            HANDLE h = ::CreateFileW(w_path, 0, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, nullptr);\n@@ -442,1 +442,1 @@\n-      HANDLE h = ::CreateFileA(buf, 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+      HANDLE h = ::CreateFileA(buf, 0, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, nullptr);\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,4 @@\n-  ASSERT_NE(PerfMemory::start(), (char*)NULL) << \"PerfMemory::_start should not be NULL\";\n-  ASSERT_NE(PerfMemory::end(), (char*)NULL) << \"PerfMemory::_end should not be NULL\";\n-  ASSERT_NE(PerfMemoryTest::top(), (char*)NULL) << \"PerfMemory::_top should not be NULL\";\n-  ASSERT_NE(PerfMemoryTest::prologue(), (PerfDataPrologue*)NULL) << \"PerfMemory::_prologue should not be NULL\";\n+  ASSERT_NE(PerfMemory::start(), (char*)nullptr) << \"PerfMemory::_start should not be null\";\n+  ASSERT_NE(PerfMemory::end(), (char*)nullptr) << \"PerfMemory::_end should not be null\";\n+  ASSERT_NE(PerfMemoryTest::top(), (char*)nullptr) << \"PerfMemory::_top should not be null\";\n+  ASSERT_NE(PerfMemoryTest::prologue(), (PerfDataPrologue*)nullptr) << \"PerfMemory::_prologue should not be null\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_perfdata.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-  \/\/ Also test NULL, but not on AIX, where NULL is readable\n+  \/\/ Also test nullptr, but not on AIX, where nullptr is readable\n@@ -69,1 +69,1 @@\n-  a = SafeFetchN(NULL, 0);\n+  a = SafeFetchN(nullptr, 0);\n@@ -71,1 +71,1 @@\n-  a = SafeFetchN(NULL, ~patternN);\n+  a = SafeFetchN(nullptr, ~patternN);\n@@ -83,1 +83,1 @@\n-  \/\/ Also test NULL, but not on AIX, where NULL is readable\n+  \/\/ Also test nullptr, but not on AIX, where nullptr is readable\n@@ -85,1 +85,1 @@\n-  a = SafeFetch32(NULL, 0);\n+  a = SafeFetch32(nullptr, 0);\n@@ -87,1 +87,1 @@\n-  a = SafeFetch32(NULL, ~pattern32);\n+  a = SafeFetch32(nullptr, ~pattern32);\n@@ -108,1 +108,1 @@\n-\/\/ Try with Thread::current being NULL. SafeFetch should work then too.\n+\/\/ Try with Thread::current being nullptr. SafeFetch should work then too.\n","filename":"test\/hotspot\/gtest\/runtime\/test_safefetch.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,2 +188,2 @@\n-  jobject buffer = env->NewDirectByteBuffer(NULL, (jlong)capacity);\n-  ASSERT_NE((void*)NULL, buffer);\n+  jobject buffer = env->NewDirectByteBuffer(nullptr, (jlong)capacity);\n+  ASSERT_NE((void*)nullptr, buffer);\n","filename":"test\/hotspot\/gtest\/runtime\/test_threads.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-    check_inner((rmr), NULL, 0, __FILE__, __LINE__);  \\\n+    check_inner((rmr), nullptr, 0, __FILE__, __LINE__);  \\\n@@ -64,1 +64,1 @@\n-  for (const CommittedMemoryRegion* region = iter.next(); region != NULL; region = iter.next()) {\n+  for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n@@ -79,1 +79,1 @@\n-  for (const CommittedMemoryRegion* region = iter.next(); region != NULL; region = iter.next()) {\n+  for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n","filename":"test\/hotspot\/gtest\/runtime\/test_virtualMemoryTracker.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,2 +58,2 @@\n-  for (int i = 0; VMStructs::localHotSpotVMTypes[i].typeName != NULL; i++) {\n-    for (int j = i + 1; VMStructs::localHotSpotVMTypes[j].typeName != NULL; j++) {\n+  for (int i = 0; VMStructs::localHotSpotVMTypes[i].typeName != nullptr; i++) {\n+    for (int j = i + 1; VMStructs::localHotSpotVMTypes[j].typeName != nullptr; j++) {\n","filename":"test\/hotspot\/gtest\/runtime\/test_vmStructs.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  if (p != NULL && s > 0) {\n+  if (p != nullptr && s > 0) {\n@@ -44,1 +44,1 @@\n-  if (p == NULL || s == 0) {\n+  if (p == nullptr || s == 0) {\n@@ -48,1 +48,1 @@\n-  const char* first_wrong = NULL;\n+  const char* first_wrong = nullptr;\n@@ -59,1 +59,1 @@\n-  if (first_wrong != NULL) {\n+  if (first_wrong != nullptr) {\n@@ -68,1 +68,1 @@\n-  return first_wrong == NULL;\n+  return first_wrong == nullptr;\n","filename":"test\/hotspot\/gtest\/testutils.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-  \/\/ Tolerates p == NULL or s == 0.\n+  \/\/ Tolerates p == nullptr or s == 0.\n@@ -41,1 +41,1 @@\n-  \/\/ If p == NULL or size == 0, returns true.\n+  \/\/ If p == nullptr or size == 0, returns true.\n@@ -56,2 +56,2 @@\n-\/\/ (ASSERT|EXPECT)_NOT_NULL: check that the given pointer is not NULL\n-\/\/ (ASSERT|EXPECT)_NULL: check that the given pointer is NULL\n+\/\/ (ASSERT|EXPECT)_NOT_NULL: check that the given pointer is not null\n+\/\/ (ASSERT|EXPECT)_NULL: check that the given pointer is null\n","filename":"test\/hotspot\/gtest\/testutils.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    return Pointer::get_hash(_val, NULL);\n+    return Pointer::get_hash(_val, nullptr);\n@@ -122,1 +122,1 @@\n-    EXPECT_NE(value, (uintptr_t*)NULL) << \"expected valid value\";\n+    EXPECT_NE(value, (uintptr_t*)nullptr) << \"expected valid value\";\n@@ -565,1 +565,1 @@\n-    return TestInterface::get_hash(_val, NULL);\n+    return TestInterface::get_hash(_val, nullptr);\n@@ -687,1 +687,1 @@\n-  RunnerSimpleInserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {\n+  RunnerSimpleInserterThread(Semaphore* post) : CHTTestThread(0, 0, nullptr, post) {\n@@ -771,1 +771,1 @@\n-  RunnerDeleteInserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {\n+  RunnerDeleteInserterThread(Semaphore* post) : CHTTestThread(0, 0, nullptr, post) {\n@@ -798,1 +798,1 @@\n-        tv = tmp != NULL ? *tmp : 0;\n+        tv = tmp != nullptr ? *tmp : 0;\n@@ -897,1 +897,1 @@\n-  RunnerGSInserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {\n+  RunnerGSInserterThread(Semaphore* post) : CHTTestThread(0, 0, nullptr, post) {\n@@ -1039,1 +1039,1 @@\n-  RunnerGI_BD_InserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {\n+  RunnerGI_BD_InserterThread(Semaphore* post) : CHTTestThread(0, 0, nullptr, post) {\n","filename":"test\/hotspot\/gtest\/utilities\/test_concurrentHashtable.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-  while (head != NULL) {\n+  while (head != nullptr) {\n@@ -73,1 +73,1 @@\n-  ASSERT_TRUE(i != NULL) << \"Should find it\";\n+  ASSERT_TRUE(i != nullptr) << \"Should find it\";\n@@ -77,1 +77,1 @@\n-  ASSERT_TRUE(i == NULL) << \"Not in the list\";\n+  ASSERT_TRUE(i == nullptr) << \"Not in the list\";\n@@ -80,1 +80,1 @@\n-  ASSERT_TRUE(node != NULL) << \"6 is in the list\";\n+  ASSERT_TRUE(node != nullptr) << \"6 is in the list\";\n@@ -139,1 +139,1 @@\n-  EXPECT_EQ(it2.next(), (Integer* )NULL);\n+  EXPECT_EQ(it2.next(), (Integer* )nullptr);\n@@ -148,1 +148,1 @@\n-  EXPECT_EQ(il.find(404), (int* )NULL);\n+  EXPECT_EQ(il.find(404), (int* )nullptr);\n@@ -192,1 +192,1 @@\n-  ASSERT_TRUE(node != NULL) << \"4 is in the list\";\n+  ASSERT_TRUE(node != nullptr) << \"4 is in the list\";\n","filename":"test\/hotspot\/gtest\/utilities\/test_linkedlist.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,2 +85,2 @@\n-  ASSERT_TRUE(stack.pop() == NULL);\n-  ASSERT_TRUE(stack.top() == NULL);\n+  ASSERT_TRUE(stack.pop() == nullptr);\n+  ASSERT_TRUE(stack.top() == nullptr);\n@@ -104,1 +104,1 @@\n-    ASSERT_TRUE(e != NULL);\n+    ASSERT_TRUE(e != nullptr);\n@@ -110,1 +110,1 @@\n-  ASSERT_TRUE(stack.pop() == NULL);\n+  ASSERT_TRUE(stack.pop() == nullptr);\n@@ -116,1 +116,1 @@\n-  ASSERT_TRUE(other_stack.pop() == NULL);\n+  ASSERT_TRUE(other_stack.pop() == nullptr);\n@@ -118,2 +118,2 @@\n-  ASSERT_TRUE(other_stack.top() == NULL);\n-  ASSERT_TRUE(other_stack.pop() == NULL);\n+  ASSERT_TRUE(other_stack.top() == nullptr);\n+  ASSERT_TRUE(other_stack.pop() == nullptr);\n@@ -125,2 +125,2 @@\n-  ASSERT_TRUE(stack.pop() == NULL);\n-  ASSERT_TRUE(stack.top() == NULL);\n+  ASSERT_TRUE(stack.pop() == nullptr);\n+  ASSERT_TRUE(stack.top() == nullptr);\n@@ -132,1 +132,1 @@\n-    ASSERT_TRUE(e != NULL);\n+    ASSERT_TRUE(e != nullptr);\n@@ -137,1 +137,1 @@\n-  ASSERT_TRUE(other_stack.pop() == NULL);\n+  ASSERT_TRUE(other_stack.pop() == nullptr);\n@@ -144,2 +144,2 @@\n-  ASSERT_TRUE(other_stack.top() == NULL);\n-  ASSERT_TRUE(other_stack.pop() == NULL);\n+  ASSERT_TRUE(other_stack.top() == nullptr);\n+  ASSERT_TRUE(other_stack.pop() == nullptr);\n@@ -155,1 +155,1 @@\n-    ASSERT_TRUE(e != NULL);\n+    ASSERT_TRUE(e != nullptr);\n@@ -160,1 +160,1 @@\n-  ASSERT_TRUE(other_stack.pop() == NULL);\n+  ASSERT_TRUE(other_stack.pop() == nullptr);\n@@ -165,1 +165,1 @@\n-  ASSERT_TRUE(stack1.pop() == NULL);\n+  ASSERT_TRUE(stack1.pop() == nullptr);\n@@ -175,1 +175,1 @@\n-    if (e0 == NULL) break;\n+    if (e0 == nullptr) break;\n@@ -185,1 +185,1 @@\n-    ASSERT_TRUE(e != NULL);\n+    ASSERT_TRUE(e != nullptr);\n@@ -190,1 +190,1 @@\n-    ASSERT_TRUE(e1 != NULL);\n+    ASSERT_TRUE(e1 != nullptr);\n@@ -198,2 +198,2 @@\n-  ASSERT_TRUE(stack.pop() == NULL);\n-  ASSERT_TRUE(stack1.pop() == NULL);\n+  ASSERT_TRUE(stack.pop() == nullptr);\n+  ASSERT_TRUE(stack1.pop() == nullptr);\n@@ -232,1 +232,1 @@\n-      if (e != NULL) {\n+      if (e != nullptr) {\n@@ -303,1 +303,1 @@\n-  while (final_stack.pop() != NULL) {}\n+  while (final_stack.pop() != nullptr) {}\n","filename":"test\/hotspot\/gtest\/utilities\/test_lockFreeStack.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  MyMetaData() : _a(NULL), _b(NULL) {}\n+  MyMetaData() : _a(nullptr), _b(nullptr) {}\n@@ -67,1 +67,1 @@\n-      _visited[i] = NULL;\n+      _visited[i] = nullptr;\n@@ -95,1 +95,1 @@\n-    EXPECT_TRUE(array->at(i) == NULL) << \"should be initialized to null\";\n+    EXPECT_TRUE(array->at(i) == nullptr) << \"should be initialized to null\";\n@@ -120,2 +120,2 @@\n-    EXPECT_TRUE(array->at(i)._a == NULL) << \"should be initialized to null\";\n-    EXPECT_TRUE(array->at(i)._b == NULL) << \"should be initialized to null\";\n+    EXPECT_TRUE(array->at(i)._a == nullptr) << \"should be initialized to null\";\n+    EXPECT_TRUE(array->at(i)._b == nullptr) << \"should be initialized to null\";\n","filename":"test\/hotspot\/gtest\/utilities\/test_metaspaceClosure.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-  ASSERT_TRUE(queue->pop() == NULL);\n+  ASSERT_TRUE(queue->pop() == nullptr);\n@@ -100,1 +100,1 @@\n-    ASSERT_TRUE(e != NULL);\n+    ASSERT_TRUE(e != nullptr);\n@@ -106,1 +106,1 @@\n-  ASSERT_TRUE(queue.pop() == NULL);\n+  ASSERT_TRUE(queue.pop() == nullptr);\n@@ -114,1 +114,1 @@\n-  ASSERT_TRUE(other_queue.pop() == NULL);\n+  ASSERT_TRUE(other_queue.pop() == nullptr);\n@@ -122,1 +122,1 @@\n-  ASSERT_TRUE(queue.pop() == NULL);\n+  ASSERT_TRUE(queue.pop() == nullptr);\n@@ -127,1 +127,1 @@\n-    ASSERT_TRUE(e != NULL);\n+    ASSERT_TRUE(e != nullptr);\n@@ -132,1 +132,1 @@\n-  ASSERT_TRUE(other_queue.pop() == NULL);\n+  ASSERT_TRUE(other_queue.pop() == nullptr);\n@@ -137,1 +137,1 @@\n-  ASSERT_TRUE(queue1.pop() == NULL);\n+  ASSERT_TRUE(queue1.pop() == nullptr);\n@@ -145,2 +145,2 @@\n-  ASSERT_TRUE(e0 != NULL);\n-  ASSERT_TRUE(e1 != NULL);\n+  ASSERT_TRUE(e0 != nullptr);\n+  ASSERT_TRUE(e1 != nullptr);\n@@ -162,1 +162,1 @@\n-    ASSERT_TRUE(e != NULL);\n+    ASSERT_TRUE(e != nullptr);\n@@ -167,1 +167,1 @@\n-    ASSERT_TRUE(e1 != NULL);\n+    ASSERT_TRUE(e1 != nullptr);\n@@ -175,2 +175,2 @@\n-  ASSERT_TRUE(queue.pop() == NULL);\n-  ASSERT_TRUE(queue1.pop() == NULL);\n+  ASSERT_TRUE(queue.pop() == nullptr);\n+  ASSERT_TRUE(queue1.pop() == nullptr);\n@@ -209,1 +209,1 @@\n-      if (e != NULL) {\n+      if (e != nullptr) {\n@@ -281,1 +281,1 @@\n-  while (final_queue.pop() != NULL) {}\n+  while (final_queue.pop() != nullptr) {}\n","filename":"test\/hotspot\/gtest\/utilities\/test_nonblockingQueue.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-\/\/ NOTE: This is a little weird. NULL is not treated any special: ObjectBitSet will happily\n-\/\/ allocate a fragement for the memory range starting at 0 and mark the first bit when passing NULL.\n+\/\/ NOTE: This is a little weird. nullptr is not treated any special: ObjectBitSet will happily\n+\/\/ allocate a fragement for the memory range starting at 0 and mark the first bit when passing nullptr.\n@@ -41,3 +41,3 @@\n-  ASSERT_FALSE(obs.is_marked((oop)NULL));\n-  obs.mark_obj((oop) NULL);\n-  ASSERT_TRUE(obs.is_marked((oop)NULL));\n+  ASSERT_FALSE(obs.is_marked((oop)nullptr));\n+  obs.mark_obj((oop) nullptr);\n+  ASSERT_TRUE(obs.is_marked((oop)nullptr));\n","filename":"test\/hotspot\/gtest\/utilities\/test_objectBitSet.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,2 +84,2 @@\n-    int* test_array = NULL;\n-    int* expected_array = NULL;\n+    int* test_array = nullptr;\n+    int* expected_array = nullptr;\n","filename":"test\/hotspot\/gtest\/utilities\/test_quicksort.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,2 @@\n-TEST_VM_ASSERT_MSG(vmErrorTest, assert1, \"assert.str == NULL. failed: expected null\") {\n-  vmassert(str == NULL, \"expected null\");\n+TEST_VM_ASSERT_MSG(vmErrorTest, assert1, \"assert.str == nullptr. failed: expected null\") {\n+  vmassert(str == nullptr, \"expected null\");\n@@ -55,2 +55,2 @@\n-TEST_VM_ASSERT_MSG(vmErrorTest, guarantee1, \"guarantee.str == NULL. failed: expected null\") {\n-  guarantee(str == NULL, \"expected null\");\n+TEST_VM_ASSERT_MSG(vmErrorTest, guarantee1, \"guarantee.str == nullptr. failed: expected null\") {\n+  guarantee(str == nullptr, \"expected null\");\n","filename":"test\/hotspot\/gtest\/utilities\/test_vmerror.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -112,0 +112,2 @@\n+runtime\/os\/TestTransparentHugePageUsage.java 8324776 linux-all\n+runtime\/Thread\/TestAlwaysPreTouchStacks.java 8324781 linux-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-keys=stress headful intermittent randomness cgroups flag-sensitive\n+# external-dep:         test requires external dependencies to work\n+keys=stress headful intermittent randomness cgroups flag-sensitive external-dep\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+            + \" * @key external-dep\\n\"\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/TestGenerator.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/accessAtomic.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/acqrel.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/atomicity.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/atomics.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/causality.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/coherence.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/collections.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/copy.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/countdownlatch.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/defaultValues.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/executors.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/fences.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/future.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/init.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/initClass.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/initLen.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/interrupt.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/locks.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/memeffects.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/mxbeans.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/oota.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/seqcst.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/singletons.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/strings.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/tearing.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/threadlocal.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/unsafe.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/varhandles.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/jcstress\/volatiles.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @key external-dep\n","filename":"test\/hotspot\/jtreg\/applications\/scimark\/Scimark.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        List<InlineEntry> inlineesNormal = parseLogFile(LOG_FILE_NORMAL, entryString, \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), inlineeCount);\n+        List<InlineEntry> inlineesNormal = parseLogFile(LOG_FILE_NORMAL, entryString, \"compile_id='\" + getCompileIdFromFile(getReplayFileName()) + \"'\", inlineeCount);\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestInliningProtectionDomain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8324174\n+ * @summary During deoptimization locking and unlocking for nested locks are executed in incorrect order.\n+ * @requires vm.compMode != \"Xint\"\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -Xmx128M\n+ *                   -XX:CompileCommand=exclude,TestNestedRelockAtDeopt::main TestNestedRelockAtDeopt\n+ *\/\n+\n+import java.util.ArrayList;\n+public class TestNestedRelockAtDeopt {\n+\n+    static final int CHUNK = 1000;\n+    static ArrayList<Object> arr = null;\n+\n+    public static void main(String[] args) {\n+        arr = new ArrayList<>();\n+        try {\n+            while (true) {\n+                test1();\n+            }\n+        } catch (OutOfMemoryError oom) {\n+            arr = null; \/\/ Free memory\n+            System.out.println(\"OOM caught in test1\");\n+        }\n+        arr = new ArrayList<>();\n+        try {\n+            while (true) {\n+                test2();\n+            }\n+        } catch (OutOfMemoryError oom) {\n+            arr = null; \/\/ Free memory\n+            System.out.println(\"OOM caught in test2\");\n+        }\n+        arr = new ArrayList<>();\n+        TestNestedRelockAtDeopt obj = new TestNestedRelockAtDeopt();\n+        try {\n+            while (true) {\n+                test3(obj);\n+            }\n+        } catch (OutOfMemoryError oom) {\n+            arr = null; \/\/ Free memory\n+            System.out.println(\"OOM caught in test3\");\n+        }\n+        arr = new ArrayList<>();\n+        try {\n+            while (true) {\n+                test4(obj);\n+            }\n+        } catch (OutOfMemoryError oom) {\n+            arr = null; \/\/ Free memory\n+            System.out.println(\"OOM caught in test4\");\n+        }\n+    }\n+\n+    \/\/ Nested locks in one method\n+    static void test1() { \/\/ Nested lock in one method\n+        synchronized (TestNestedRelockAtDeopt.class) {\n+            synchronized (new TestNestedRelockAtDeopt()) { \/\/ lock eliminated - not escaped allocation\n+                synchronized (TestNestedRelockAtDeopt.class) { \/\/ nested lock eliminated\n+                    synchronized (new TestNestedRelockAtDeopt()) { \/\/ lock eliminated - not escaped allocation\n+                        synchronized (TestNestedRelockAtDeopt.class) { \/\/ nested lock eliminated\n+                            arr.add(new byte[CHUNK]);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Nested locks in inlined method\n+    static void foo() {\n+        synchronized (new TestNestedRelockAtDeopt()) {  \/\/ lock eliminated - not escaped allocation\n+            synchronized (TestNestedRelockAtDeopt.class) {  \/\/ nested lock eliminated when inlined\n+                arr.add(new byte[CHUNK]);\n+            }\n+        }\n+    }\n+\n+    static void test2() {\n+        synchronized (TestNestedRelockAtDeopt.class) {\n+            synchronized (new TestNestedRelockAtDeopt()) {  \/\/ lock eliminated - not escaped allocation\n+                synchronized (TestNestedRelockAtDeopt.class) { \/\/ nested lock eliminated\n+                    foo(); \/\/ Inline\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Nested locks in one method\n+    static void test3(TestNestedRelockAtDeopt obj) {\n+        synchronized (TestNestedRelockAtDeopt.class) {\n+            synchronized (obj) { \/\/ lock not eliminated - external object\n+                synchronized (TestNestedRelockAtDeopt.class) { \/\/ nested lock eliminated\n+                    synchronized (obj) { \/\/ nested lock eliminated\n+                        synchronized (TestNestedRelockAtDeopt.class) { \/\/ nested lock eliminated\n+                            arr.add(new byte[CHUNK]);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Nested locks with different objects in inlined method\n+    static void bar(TestNestedRelockAtDeopt obj) {\n+        synchronized (obj) {  \/\/ nested lock eliminated when inlined\n+            synchronized (TestNestedRelockAtDeopt.class) {  \/\/ nested lock eliminated when inlined\n+                arr.add(new byte[CHUNK]);\n+            }\n+        }\n+    }\n+\n+    static void test4(TestNestedRelockAtDeopt obj) {\n+        synchronized (TestNestedRelockAtDeopt.class) {\n+            synchronized (obj) {  \/\/ lock not eliminated - external object\n+                synchronized (TestNestedRelockAtDeopt.class) { \/\/ nested lock eliminated\n+                    bar(obj); \/\/ Inline\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestNestedRelockAtDeopt.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8322996\n+ * @summary Ensure no assert error in C2 with deeply nested synchronize\n+ *          statements.\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.locks.TestNestedSynchronize::test\n+ *                   -Xcomp\n+ *                   compiler.locks.TestNestedSynchronize\n+ *\/\n+\n+package compiler.locks;\n+\n+public class TestNestedSynchronize {\n+\n+    public static void main(String[] args) {\n+        test();\n+    }\n+\n+    public static void test() {\n+\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+        synchronized (TestNestedSynchronize.class) {\n+\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/locks\/TestNestedSynchronize.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-        for (int i = 0; i < data.length; i++) {\n+        for (int i = 0; i < data.length; i+=2) {\n@@ -80,0 +80,11 @@\n+\n+            \/\/ This example used to rely on that reductions were ignored in SuperWord::unrolling_analysis,\n+            \/\/ and hence the largest data type in the loop was the ints. This would then unroll the doubles\n+            \/\/ for twice the vector length, and this resulted in us having twice as many packs. Because of\n+            \/\/ the store \"data[0] = 0\", the first packs were destroyed, since they do not have power of 2\n+            \/\/ size.\n+            \/\/ Now, we no longer ignore reductions, and now we unroll half as much before SuperWord. This\n+            \/\/ means we would only get one pack per operation, and that one would get ruined, and we have\n+            \/\/ no vectorization. We now ensure there are again 2 packs per operation with a 2x hand unroll.\n+            int v2 = data[i + 1];\n+            sum |= v2;\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestUnorderedReductionPartialVectorization.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-            \"-XX:CompileCommand=option,Test::test,VectorizeDebug,3\",\n+            \"-XX:CompileCommand=option,Test::test,MemStat,3\",\n@@ -75,1 +75,1 @@\n-            \"Missing type 'uintx' before option 'VectorizeDebug'\"\n+            \"Missing type 'uintx' before option 'MemStat'\"\n","filename":"test\/hotspot\/jtreg\/compiler\/oracle\/TestInvalidCompileCommand.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-        {\"DefaultMaxRAMFraction\",   \"MaxRAMFraction\", \"1032\"},\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMAliasOptions.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,4 +59,0 @@\n-            {\"MaxGCMinorPauseMillis\",     \"1032\"},\n-            {\"MaxRAMFraction\",            \"8\"},\n-            {\"MinRAMFraction\",            \"2\"},\n-            {\"InitialRAMFraction\",        \"64\"},\n@@ -67,1 +63,0 @@\n-            {\"DefaultMaxRAMFraction\", \"4\"},\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-static jvmtiEnv* jvmti = NULL;\n+static jvmtiEnv* jvmti = nullptr;\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/libAsyncExceptionOnMonitorEnter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-static jvmtiEnv* jvmti = NULL;\n+static jvmtiEnv* jvmti = nullptr;\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/libStopAtExit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-static jvmtiEnv* jvmti = NULL;\n+static jvmtiEnv* jvmti = nullptr;\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/libSuspendAtExit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8323950\n+ * @summary Transforming an interface of an archived lambda proxy class should not\n+ *          crash the VM. The lambda proxy class should be regenerated during runtime.\n+ * @requires vm.cds\n+ * @requires vm.jvmti\n+ * @requires vm.flagless\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @compile test-classes\/SimpleTest.java\n+ * @compile test-classes\/TransformBootClass.java\n+ * @run driver TransformInterfaceOfLambda\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class TransformInterfaceOfLambda {\n+\n+    public static String agentClasses[] = {\n+        TransformBootClass.class.getName(),\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        String mainClass = SimpleTest.class.getName();\n+        String namePrefix = \"transform-interface-of-lambda\";\n+        JarBuilder.build(namePrefix, mainClass);\n+\n+        String appJar = TestCommon.getTestJar(namePrefix + \".jar\");\n+\n+        String agentJar =\n+            ClassFileInstaller.writeJar(\"TransformBootClass.jar\",\n+                                        ClassFileInstaller.Manifest.fromSourceFile(\"test-classes\/TransformBootClass.mf\"),\n+                                        agentClasses);\n+        String useJavaAgent = \"-javaagent:\" + agentJar + \"=java\/util\/function\/IntFunction\";\n+\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-cp\", appJar, \"-Xlog:class+load,cds=debug\",\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+AllowArchivingWithJavaAgent\",\n+            useJavaAgent,\n+            mainClass);\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        System.out.println(out.getStdout());\n+        out.shouldHaveExitValue(0)\n+           \/\/ the class loaded by the SimpleTest should be from the archive\n+           .shouldContain(\"[class,load] java.text.SimpleDateFormat source: shared objects file\")\n+           \/\/ the IntFunction is the interface which is being transformed. The\n+           \/\/ interface is a super type of the following lambda proxy class.\n+           .shouldContain(\"Transforming class java\/util\/function\/IntFunction\")\n+           \/\/ the lambda proxy class should be regenerated\n+           .shouldMatch(\".class.load.*sun.util.locale.provider.LocaleProviderAdapter[$][$]Lambda\/0x.*source:.*sun.util.locale.provider.LocaleProviderAdapter\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TransformInterfaceOfLambda.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * Loading the java.text.SimpleDateFormat class will in turn load the\n+ * sun.util.locale.provider.LocaleProviderAdapter$$Lambda\/0x... lambda proxy class\n+ * which will also load its interface java.util.function.IntFunction.\n+ * By default, all of the above classes should be in the default CDS archive.\n+ *\/\n+public class SimpleTest {\n+    public static void main(String[] args) throws Exception {\n+        new java.text.SimpleDateFormat();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/SimpleTest.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-        if (runnable == NULL)  return JNI_FALSE;\n+        if (runnable == nullptr)  return JNI_FALSE;\n@@ -45,1 +45,1 @@\n-        if (methodId == NULL)  return JNI_FALSE;\n+        if (methodId == nullptr)  return JNI_FALSE;\n@@ -52,1 +52,1 @@\n-        if (test_class_A == NULL)  return JNI_FALSE;\n+        if (test_class_A == nullptr)  return JNI_FALSE;\n@@ -55,1 +55,1 @@\n-        if (test_class_B == NULL)  return JNI_FALSE;\n+        if (test_class_B == nullptr)  return JNI_FALSE;\n@@ -58,1 +58,1 @@\n-        if (test_staticM_id == NULL)  return JNI_FALSE;\n+        if (test_staticM_id == nullptr)  return JNI_FALSE;\n@@ -61,1 +61,1 @@\n-        if (test_staticS_id == NULL)  return JNI_FALSE;\n+        if (test_staticS_id == nullptr)  return JNI_FALSE;\n@@ -64,1 +64,1 @@\n-        if (test_staticN_id == NULL)  return JNI_FALSE;\n+        if (test_staticN_id == nullptr)  return JNI_FALSE;\n@@ -67,1 +67,1 @@\n-        if (test_A_m_id == NULL)  return JNI_FALSE;\n+        if (test_A_m_id == nullptr)  return JNI_FALSE;\n@@ -70,1 +70,1 @@\n-        if (test_staticF_id == NULL)  return JNI_FALSE;\n+        if (test_staticF_id == nullptr)  return JNI_FALSE;\n@@ -73,1 +73,1 @@\n-        if (test_A_f_id == NULL)  return JNI_FALSE;\n+        if (test_A_f_id == nullptr)  return JNI_FALSE;\n@@ -108,2 +108,2 @@\n-          return NULL;\n-        } else if (obj == NULL) {\n+          return nullptr;\n+        } else if (obj == nullptr) {\n@@ -112,1 +112,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -121,2 +121,2 @@\n-          return NULL;\n-        } else if (obj == NULL) {\n+          return nullptr;\n+        } else if (obj == nullptr) {\n@@ -125,1 +125,1 @@\n-          return NULL;\n+          return nullptr;\n","filename":"test\/hotspot\/jtreg\/runtime\/clinit\/libClassInitBarrier.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) Ampere Computing and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestTransparentHugePageUsage\n+ * @bug 8315923\n+ * @library \/test\/lib\n+ * @requires vm.gc.Serial & os.family == \"linux\" & os.maxMemory > 2G\n+ * @summary Check that a pretouched java heap appears to use THPs by checking\n+ *          AnonHugePages in smaps\n+ * @comment Use SerialGC to increase the time window for pretouching\n+ * @run driver runtime.os.TestTransparentHugePageUsage\n+ *\/\n+\n+package runtime.os;\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.InputStreamReader;\n+import java.util.AbstractMap.SimpleEntry;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestTransparentHugePageUsage {\n+  private static final String[] fixedCmdLine = {\n+    \"-XX:+UseTransparentHugePages\", \"-XX:+AlwaysPreTouch\",\n+    \"-Xlog:startuptime,pagesize,gc+heap=debug\",\n+    \"-XX:+UseSerialGC\", \"-Xms1G\", \"-Xmx1G\",\n+  };\n+\n+  public static void main(String[] args) throws Exception {\n+    ArrayList<String> cmdLine = new ArrayList<>(Arrays.asList(fixedCmdLine));\n+    cmdLine.add(\"runtime.os.TestTransparentHugePageUsage$CatSmaps\");\n+    ProcessBuilder builder = ProcessTools.createTestJavaProcessBuilder(cmdLine);\n+    checkUsage(new BufferedReader(new InputStreamReader(builder.start().getInputStream())));\n+  }\n+\n+  private static void checkUsage(BufferedReader reader) throws Exception {\n+    final Pattern useThp = Pattern.compile(\".*\\\\[info\\\\]\\\\[pagesize\\\\].+UseTransparentHugePages=1.*\");\n+    \/\/ Ensure THP is not disabled by OS.\n+    if (reader.lines().filter(line -> useThp.matcher(line).matches()).findFirst().isPresent()) {\n+      final Pattern heapAddr = Pattern.compile(\".*\\\\sHeap:\\\\s.+base=0x0*(\\\\p{XDigit}+).*\");\n+      final Optional<Long> addr = reader.lines()\n+          .map(line -> new SimpleEntry<String, Matcher>(line, heapAddr.matcher(line)))\n+          .filter(e -> e.getValue().matches())\n+          .findFirst()\n+          .map(e -> Long.valueOf(e.getKey().substring(e.getValue().start(1), e.getValue().end(1)), 16));\n+      if (!addr.isPresent()) throw new RuntimeException(\"Heap base was not found in smaps.\");\n+      \/\/ Match the start of a mapping, for example:\n+      \/\/ 200000000-800000000 rw-p 00000000 00:00 0\n+      final Pattern mapping = Pattern.compile(\"^(\\\\p{XDigit}+)-\\\\p{XDigit}+.*\");\n+      reader.lines()\n+            .filter(line -> {\n+                  Matcher matcher = mapping.matcher(line);\n+                  if (matcher.matches()) {\n+                    Long mappingAddr = Long.valueOf(line.substring(matcher.start(1), matcher.end(1)), 16);\n+                    if (mappingAddr.equals(addr.get())) return true;\n+                  }\n+                  return false;\n+                })\n+            .findFirst();\n+      final Pattern thpUsage = Pattern.compile(\"^AnonHugePages:\\\\s+(\\\\d+)\\\\skB\");\n+      final Optional<Long> usage = reader.lines()\n+          .map(line -> new SimpleEntry<String, Matcher>(line, thpUsage.matcher(line)))\n+          .filter(e -> e.getValue().matches())\n+          .findFirst()\n+          .map(e -> Long.valueOf(e.getKey().substring(e.getValue().start(1), e.getValue().end(1))));\n+      if (!usage.isPresent()) throw new RuntimeException(\"The usage of THP was not found.\");\n+      \/\/ Even with MADV_POPULATE_WRITE, the usage of THP is still one page less than the whole heap.\n+      if (usage.get() < 524288) throw new RuntimeException(\"The usage of THP is not enough.\");\n+    }\n+  }\n+\n+  public static class CatSmaps {\n+    public static void main(String[] args) throws Exception {\n+      new BufferedReader(new FileReader(\"\/proc\/self\/smaps\"))\n+          .lines()\n+          .forEach(line -> System.out.println(line));\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTransparentHugePageUsage.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    elem_ = NULL;\n+    elem_ = nullptr;\n@@ -103,1 +103,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -132,1 +132,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, nullptr);\n@@ -138,1 +138,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -146,1 +146,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n@@ -197,1 +197,1 @@\n-  if (agct == NULL) {\n+  if (agct == nullptr) {\n@@ -202,1 +202,1 @@\n-  agct(&trace, MAX_DEPTH, NULL);\n+  agct(&trace, MAX_DEPTH, nullptr);\n@@ -217,2 +217,2 @@\n-  if (trace.frames[0].method_id == NULL) {\n-    fprintf(stderr, \"First frame method_id is NULL\\n\");\n+  if (trace.frames[0].method_id == nullptr) {\n+    fprintf(stderr, \"First frame method_id is null\\n\");\n@@ -222,1 +222,1 @@\n-  jvmtiError err = jvmti->GetMethodName(trace.frames[0].method_id, name.get_addr(), NULL, NULL);\n+  jvmtiError err = jvmti->GetMethodName(trace.frames[0].method_id, name.get_addr(), nullptr, nullptr);\n@@ -228,2 +228,2 @@\n-  if (name.get() == NULL) {\n-    fprintf(stderr, \"Name is NULL\\n\");\n+  if (name.get() == nullptr) {\n+    fprintf(stderr, \"Name is null\\n\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/AsyncGetCallTrace\/libAsyncGetCallTraceTest.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL);\n+    jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr);\n@@ -67,1 +67,1 @@\n-    jvmti->RunAgentThread(agent_thread, GenerateEventsThread, NULL, JVMTI_THREAD_NORM_PRIORITY);\n+    jvmti->RunAgentThread(agent_thread, GenerateEventsThread, nullptr, JVMTI_THREAD_NORM_PRIORITY);\n@@ -86,1 +86,1 @@\n-    jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+    jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/CompiledMethodLoad\/libCompiledZombie.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-static jvmtiEnv* jvmti = NULL;\n+static jvmtiEnv* jvmti = nullptr;\n@@ -37,2 +37,2 @@\n-    jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED, NULL);\n-    jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED, NULL);\n+    jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED, nullptr);\n+    jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/DynamicCodeGenerated\/libDynamicCodeGenerated.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,3 @@\n-static JavaVM *java_vm = NULL;\n-static jthread exp_thread = NULL;\n-static jvmtiEnv *jvmti1 = NULL;\n+static JavaVM *java_vm = nullptr;\n+static jthread exp_thread = nullptr;\n+static jvmtiEnv *jvmti1 = nullptr;\n@@ -51,4 +51,4 @@\n-  JNIEnv* env = NULL;\n-  jthread thread = NULL;\n-  char* name = NULL;\n-  char* sign = NULL;\n+  JNIEnv* env = nullptr;\n+  jthread thread = nullptr;\n+  char* name = nullptr;\n+  char* sign = nullptr;\n@@ -70,1 +70,1 @@\n-  err = jvmti->GetMethodName(method, &name, &sign, NULL);\n+  err = jvmti->GetMethodName(method, &name, &sign, nullptr);\n@@ -114,1 +114,1 @@\n-  jthread thread = NULL;\n+  jthread thread = nullptr;\n@@ -122,1 +122,1 @@\n-  err = jvmti1->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL);\n+  err = jvmti1->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr);\n@@ -128,1 +128,1 @@\n-  err = jvmti1->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL);\n+  err = jvmti1->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GenerateEvents\/libGenerateEvents1.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,3 @@\n-static JavaVM *java_vm = NULL;\n-static jthread exp_thread = NULL;\n-static jvmtiEnv *jvmti2 = NULL;\n+static JavaVM *java_vm = nullptr;\n+static jthread exp_thread = nullptr;\n+static jvmtiEnv *jvmti2 = nullptr;\n@@ -51,4 +51,4 @@\n-  JNIEnv* env = NULL;\n-  jthread thread = NULL;\n-  char* name = NULL;\n-  char* sign = NULL;\n+  JNIEnv* env = nullptr;\n+  jthread thread = nullptr;\n+  char* name = nullptr;\n+  char* sign = nullptr;\n@@ -70,1 +70,1 @@\n-  err = jvmti->GetMethodName(method, &name, &sign, NULL);\n+  err = jvmti->GetMethodName(method, &name, &sign, nullptr);\n@@ -116,1 +116,1 @@\n-  err = jvmti2->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL);\n+  err = jvmti2->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr);\n@@ -124,1 +124,1 @@\n-  err = jvmti2->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL);\n+  err = jvmti2->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GenerateEvents\/libGenerateEvents2.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -36,1 +36,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -54,1 +54,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetClassFields\/FilteredFields\/libFilteredFieldsTest.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -44,1 +44,1 @@\n-  if (options != NULL && strcmp(options, \"maintain_original_method_order\") == 0) {\n+  if (options != nullptr && strcmp(options, \"maintain_original_method_order\") == 0) {\n@@ -61,1 +61,1 @@\n-  jmethodID* methods = NULL;\n+  jmethodID* methods = nullptr;\n@@ -65,1 +65,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -69,1 +69,1 @@\n-  if (method_cls == NULL) {\n+  if (method_cls == nullptr) {\n@@ -71,1 +71,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -73,2 +73,2 @@\n-  jobjectArray array = env->NewObjectArray(method_count, method_cls, NULL);\n-  if (array == NULL) {\n+  jobjectArray array = env->NewObjectArray(method_count, method_cls, nullptr);\n+  if (array == nullptr) {\n@@ -76,1 +76,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -84,1 +84,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -88,1 +88,1 @@\n-    if (array == NULL) {\n+    if (array == nullptr) {\n@@ -90,1 +90,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetClassMethods\/libOverpassMethods.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -170,1 +170,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -226,1 +226,1 @@\n-  jmethodID mid = NULL;\n+  jmethodID mid = nullptr;\n@@ -228,1 +228,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -235,1 +235,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetLocalVariable\/libGetLocalVars.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -58,1 +58,1 @@\n-  jobject msg = NULL;\n+  jobject msg = nullptr;\n@@ -104,1 +104,1 @@\n-  const jobject msg = NULL;\n+  const jobject msg = nullptr;\n@@ -166,1 +166,1 @@\n-  jmethodID method = NULL;\n+  jmethodID method = nullptr;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetLocalVariable\/libGetSetLocalUnsuspended.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -106,1 +106,1 @@\n-  target_info = NULL;\n+  target_info = nullptr;\n@@ -118,1 +118,1 @@\n-  if (target_info == NULL) {\n+  if (target_info == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetThreadListStackTraces\/libOneGetThreadListStackTraces.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-  if (res != JNI_OK || env == NULL) {\n+  if (res != JNI_OK || env == nullptr) {\n@@ -82,1 +82,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -260,1 +260,1 @@\n-    err = jvmti->IterateOverReachableObjects(NULL \/*jvmtiHeapRootCallback*\/,\n+    err = jvmti->IterateOverReachableObjects(nullptr \/*jvmtiHeapRootCallback*\/,\n@@ -262,1 +262,1 @@\n-                                             NULL \/* jvmtiObjectReferenceCallback *\/,\n+                                             nullptr \/* jvmtiObjectReferenceCallback *\/,\n@@ -297,2 +297,2 @@\n-                                  NULL \/* no class filter *\/,\n-                                  NULL \/* no initial object, follow roots *\/,\n+                                  nullptr \/* no class filter *\/,\n+                                  nullptr \/* no initial object, follow roots *\/,\n@@ -311,1 +311,1 @@\n-                                    NULL \/* no class filter *\/,\n+                                    nullptr \/* no class filter *\/,\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Heap\/libIterateHeapWithEscapeAnalysisEnabled.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiEnv *second_jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jvmtiEnv *second_jvmti = nullptr;\n@@ -141,1 +141,1 @@\n-    char *name = NULL, *signature = NULL, *file_name = NULL;\n+    char *name = nullptr, *signature = nullptr, *file_name = nullptr;\n@@ -169,2 +169,2 @@\n-    \/\/ Compare now, none should be NULL.\n-    if (name == NULL) {\n+    \/\/ Compare now, none should be null.\n+    if (name == nullptr) {\n@@ -175,1 +175,1 @@\n-    if (file_name == NULL) {\n+    if (file_name == nullptr) {\n@@ -180,1 +180,1 @@\n-    if (signature == NULL) {\n+    if (signature == nullptr) {\n@@ -207,1 +207,1 @@\n-    char *name = NULL, *signature = NULL, *file_name = NULL;\n+    char *name = nullptr, *signature = nullptr, *file_name = nullptr;\n@@ -230,2 +230,2 @@\n-    \/\/ Compare now, none should be NULL.\n-    if (name == NULL) {\n+    \/\/ Compare now, none should be null.\n+    if (name == nullptr) {\n@@ -235,1 +235,1 @@\n-    if (file_name == NULL) {\n+    if (file_name == nullptr) {\n@@ -239,1 +239,1 @@\n-    if (signature == NULL) {\n+    if (signature == nullptr) {\n@@ -270,1 +270,1 @@\n-    jclass frame_class = NULL;\n+    jclass frame_class = nullptr;\n@@ -274,4 +274,4 @@\n-    jstring string_object = NULL;\n-    const char* method = NULL;\n-    const char* file_name = NULL;\n-    const char* signature = NULL;\n+    jstring string_object = nullptr;\n+    const char* method = nullptr;\n+    const char* file_name = nullptr;\n+    const char* signature = nullptr;\n@@ -413,1 +413,1 @@\n-  if (old_object != NULL) {\n+  if (old_object != nullptr) {\n@@ -499,1 +499,1 @@\n-    if (trace == NULL) {\n+    if (trace == nullptr) {\n@@ -590,1 +590,1 @@\n-    if (!jni->IsSameObject(object, NULL)) {\n+    if (!jni->IsSameObject(object, nullptr)) {\n@@ -597,1 +597,1 @@\n-      live_object->object = NULL;\n+      live_object->object = nullptr;\n@@ -610,1 +610,1 @@\n-    free(array[i]), array[i] = NULL;\n+    free(array[i]), array[i] = nullptr;\n@@ -623,1 +623,1 @@\n-  free(storage->live_objects), storage->live_objects = NULL;\n+  free(storage->live_objects), storage->live_objects = nullptr;\n@@ -802,1 +802,1 @@\n-      JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, NULL),\n+      JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, nullptr),\n@@ -808,1 +808,1 @@\n-      JVMTI_ENABLE, JVMTI_EVENT_SAMPLED_OBJECT_ALLOC, NULL),\n+      JVMTI_ENABLE, JVMTI_EVENT_SAMPLED_OBJECT_ALLOC, nullptr),\n@@ -819,1 +819,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -826,1 +826,1 @@\n-  if (res != JNI_OK || second_jvmti == NULL) {\n+  if (res != JNI_OK || second_jvmti == nullptr) {\n@@ -896,1 +896,1 @@\n-      JVMTI_DISABLE, JVMTI_EVENT_SAMPLED_OBJECT_ALLOC, NULL),\n+      JVMTI_DISABLE, JVMTI_EVENT_SAMPLED_OBJECT_ALLOC, nullptr),\n@@ -900,1 +900,1 @@\n-      JVMTI_DISABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, NULL),\n+      JVMTI_DISABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, nullptr),\n@@ -915,2 +915,2 @@\n-  if (native_frames == NULL) {\n-    env->FatalError(\"Error in get_native_frames: malloc returned NULL\\n\");\n+  if (native_frames == nullptr) {\n+    env->FatalError(\"Error in get_native_frames: malloc returned null\\n\");\n@@ -937,1 +937,1 @@\n-  free(native_frames), native_frames = NULL;\n+  free(native_frames), native_frames = nullptr;\n@@ -952,1 +952,1 @@\n-  free(native_frames), native_frames = NULL;\n+  free(native_frames), native_frames = nullptr;\n@@ -967,1 +967,1 @@\n-  free(native_frames), native_frames = NULL;\n+  free(native_frames), native_frames = nullptr;\n@@ -1086,1 +1086,1 @@\n-      JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, NULL),\n+      JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, nullptr),\n@@ -1106,1 +1106,1 @@\n-  if (env->ExceptionOccurred() || cls == NULL) {\n+  if (env->ExceptionOccurred() || cls == nullptr) {\n@@ -1111,1 +1111,1 @@\n-  if (env->ExceptionOccurred() || constructor == NULL) {\n+  if (env->ExceptionOccurred() || constructor == nullptr) {\n@@ -1118,1 +1118,1 @@\n-  if (env->ExceptionOccurred() || result == NULL) {\n+  if (env->ExceptionOccurred() || result == nullptr) {\n@@ -1138,2 +1138,2 @@\n-    if (allocate_object(jni_env) == NULL) {\n-      jni_env->FatalError(\"allocate_object returned NULL\\n\");\n+    if (allocate_object(jni_env) == nullptr) {\n+      jni_env->FatalError(\"allocate_object returned null\\n\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HeapMonitor\/libHeapMonitorTest.cpp","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -53,1 +53,1 @@\n-  char* csig = NULL;\n+  char* csig = nullptr;\n@@ -55,1 +55,1 @@\n-  jmethodID *methods = NULL;\n+  jmethodID *methods = nullptr;\n@@ -57,3 +57,3 @@\n-  if (clazz == NULL) {\n-    jni->FatalError(\"is_hidden_mid: Error: FindClass returned NULL for java\/lang\/Class\\n\");\n-    return NULL;\n+  if (clazz == nullptr) {\n+    jni->FatalError(\"is_hidden_mid: Error: FindClass returned null for java\/lang\/Class\\n\");\n+    return nullptr;\n@@ -64,1 +64,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n@@ -73,1 +73,1 @@\n-  static jmethodID is_hid_mid = NULL;\n+  static jmethodID is_hid_mid = nullptr;\n@@ -75,1 +75,1 @@\n-  if (is_hid_mid == NULL) {\n+  if (is_hid_mid == nullptr) {\n@@ -91,2 +91,2 @@\n-  char* sig = NULL;\n-  char* gsig = NULL;\n+  char* sig = nullptr;\n+  char* gsig = nullptr;\n@@ -106,2 +106,2 @@\n-  if (is_hidden && gsig == NULL) {\n-    LOG0(\"check_class_signature: FAIL: unexpected NULL generic signature for hidden class\\n\");\n+  if (is_hidden && gsig == nullptr) {\n+    LOG0(\"check_class_signature: FAIL: unexpected null generic signature for hidden class\\n\");\n@@ -155,2 +155,2 @@\n-  jobject loader = NULL;\n-  jclass* loader_classes = NULL;\n+  jobject loader = nullptr;\n+  jclass* loader_classes = nullptr;\n@@ -169,1 +169,1 @@\n-    char* sig = NULL;\n+    char* sig = nullptr;\n@@ -177,1 +177,1 @@\n-    err = jvmti->GetClassSignature(kls, &sig, NULL);\n+    err = jvmti->GetClassSignature(kls, &sig, nullptr);\n@@ -190,1 +190,1 @@\n-  char* sig = NULL;\n+  char* sig = nullptr;\n@@ -192,1 +192,1 @@\n-  jclass* interfaces = NULL;\n+  jclass* interfaces = nullptr;\n@@ -204,1 +204,1 @@\n-  err = jvmti->GetClassSignature(interfaces[0], &sig, NULL);\n+  err = jvmti->GetClassSignature(interfaces[0], &sig, nullptr);\n@@ -218,1 +218,1 @@\n-  char* source_file_name = NULL;\n+  char* source_file_name = nullptr;\n@@ -240,1 +240,1 @@\n-  char* source_file_name = NULL;\n+  char* source_file_name = nullptr;\n@@ -253,2 +253,2 @@\n-  char* sig = NULL;\n-  char* gsig = NULL;\n+  char* sig = nullptr;\n+  char* gsig = nullptr;\n@@ -266,2 +266,2 @@\n-    if (gsig == NULL) {\n-      LOG1(\"%s event: FAIL: GetClassSignature returned NULL generic signature for hidden class\\n\", event_name);\n+    if (gsig == nullptr) {\n+      LOG1(\"%s event: FAIL: GetClassSignature returned null generic signature for hidden class\\n\", event_name);\n@@ -296,1 +296,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, nullptr);\n@@ -300,1 +300,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -330,1 +330,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n@@ -344,1 +344,1 @@\n-  const char* exp_sig = jni->GetStringUTFChars(exp_sig_str, NULL);\n+  const char* exp_sig = jni->GetStringUTFChars(exp_sig_str, nullptr);\n@@ -346,2 +346,2 @@\n-  if (exp_sig == NULL) {\n-    jni->FatalError(\"check_hidden_class: Error: JNI GetStringChars returned NULL for jstring\\n\");\n+  if (exp_sig == nullptr) {\n+    jni->FatalError(\"check_hidden_class: Error: JNI GetStringChars returned null for jstring\\n\");\n@@ -358,1 +358,1 @@\n-  const char* exp_sig = jni->GetStringUTFChars(exp_sig_str, NULL);\n+  const char* exp_sig = jni->GetStringUTFChars(exp_sig_str, nullptr);\n@@ -360,2 +360,2 @@\n-  if (exp_sig == NULL) {\n-    jni->FatalError(\"check_hidden_class_array: Error: JNI GetStringChars returned NULL for jstring\\n\");\n+  if (exp_sig == nullptr) {\n+    jni->FatalError(\"check_hidden_class_array: Error: JNI GetStringChars returned null for jstring\\n\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HiddenClass\/libHiddenClassSigTest.cpp","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-        _log(\"SavedClassBytes: NULL\\n\");\n+        _log(\"SavedClassBytes: null\\n\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/MissedStackMapFrames\/libMissedStackMapFrames.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,1 +155,1 @@\n-            _log(\"%s: savedClassBytes is NULL\\n\", mode);\n+            _log(\"%s: savedClassBytes is null\\n\", mode);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineRetransform\/libRedefineRetransform.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -45,1 +45,1 @@\n-    err = jvmti->GetClassSignature(klass, &buf, NULL);\n+    err = jvmti->GetClassSignature(klass, &buf, nullptr);\n@@ -98,1 +98,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -104,1 +104,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SetBreakpoint\/libTestManyBreakpoints.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-    jvmtiEnv *jvmti = NULL;\n+    jvmtiEnv *jvmti = nullptr;\n@@ -58,1 +58,1 @@\n-    checkJvmti(jvmti->IterateOverHeap(tagged ? JVMTI_HEAP_OBJECT_TAGGED : JVMTI_HEAP_OBJECT_EITHER, &heapObjectCallback, NULL), \"could not iterate\");\n+    checkJvmti(jvmti->IterateOverHeap(tagged ? JVMTI_HEAP_OBJECT_TAGGED : JVMTI_HEAP_OBJECT_EITHER, &heapObjectCallback, nullptr), \"could not iterate\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SetTag\/libTagMapTest.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n-static jvmtiEnv* jvmti = NULL;\n-static jthread* threads = NULL;\n+static jvmtiEnv* jvmti = nullptr;\n+static jthread* threads = nullptr;\n@@ -54,1 +54,1 @@\n-  jvmtiError* results = NULL;\n+  jvmtiError* results = nullptr;\n@@ -56,1 +56,1 @@\n-  const char* tname = get_thread_name(jvmti, jni, NULL); \/\/ current thread name\n+  const char* tname = get_thread_name(jvmti, jni, nullptr); \/\/ current thread name\n@@ -108,1 +108,1 @@\n-  jvmtiError* results = NULL;\n+  jvmtiError* results = nullptr;\n@@ -138,1 +138,1 @@\n-    if (threads[i] != NULL) {\n+    if (threads[i] != nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithCurrentThread\/libSuspendWithCurrentThread.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-static jvmtiEnv* jvmti = NULL;\n+static jvmtiEnv* jvmti = nullptr;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorEnter\/libSuspendWithObjectMonitorEnter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-static jvmtiEnv* jvmti = NULL;\n+static jvmtiEnv* jvmti = nullptr;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithObjectMonitorWait\/libSuspendWithObjectMonitorWait.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n-static jvmtiEnv* jvmti = NULL;\n-static jrawMonitorID threadLock = NULL;\n+static jvmtiEnv* jvmti = nullptr;\n+static jrawMonitorID threadLock = nullptr;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithRawMonitorEnter\/libSuspendWithRawMonitorEnter.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-  char *signature = NULL;\n-  jvmtiError err = jvmti->GetClassSignature(cls, &signature, NULL);\n+  char *signature = nullptr;\n+  jvmtiError err = jvmti->GetClassSignature(cls, &signature, nullptr);\n@@ -83,1 +83,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC , NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC , nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/VMObjectAlloc\/libVMObjectAlloc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -95,1 +95,1 @@\n-    if (sig != NULL && (strcmp(sig, CLASS_SIG) == 0)) {\n+    if (sig != nullptr && (strcmp(sig, CLASS_SIG) == 0)) {\n@@ -119,1 +119,1 @@\n-  const char* thr_name = thr_info.name == NULL ? \"NULL\" : thr_info.name;\n+  const char* thr_name = thr_info.name == nullptr ? \"null\" : thr_info.name;\n@@ -122,1 +122,1 @@\n-  if (thr_info.name == NULL || strcmp(thr_info.name, THREAD_NAME) != 0) {\n+  if (thr_info.name == nullptr || strcmp(thr_info.name, THREAD_NAME) != 0) {\n@@ -151,1 +151,1 @@\n-  if (clsSig == NULL || strcmp(clsSig, CLASS_SIG) != 0) {\n+  if (clsSig == nullptr || strcmp(clsSig, CLASS_SIG) != 0) {\n@@ -153,1 +153,1 @@\n-    LOG(\"TEST FAILED: Breakpoint event with unexpected class signature: %s\\n\\n\", (clsSig == NULL) ? \"NULL\" : clsSig);\n+    LOG(\"TEST FAILED: Breakpoint event with unexpected class signature: %s\\n\\n\", (clsSig == nullptr) ? \"null\" : clsSig);\n@@ -158,1 +158,1 @@\n-  err = jvmti->GetMethodName(method, &methNam, &methSig, NULL);\n+  err = jvmti->GetMethodName(method, &methNam, &methSig, nullptr);\n@@ -233,1 +233,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -271,1 +271,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, nullptr);\n@@ -274,1 +274,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n@@ -277,1 +277,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, nullptr);\n@@ -280,1 +280,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n@@ -286,1 +286,1 @@\n-  if (agent_lock == NULL)\n+  if (agent_lock == nullptr)\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Breakpoint\/breakpoint01\/libbreakpoint01.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -94,1 +94,1 @@\n-    if (sig != NULL &&\n+    if (sig != nullptr &&\n@@ -163,1 +163,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -200,1 +200,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassLoad\/classload01\/libclassload01.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -161,1 +161,1 @@\n-    if (methods[i] == NULL) {\n+    if (methods[i] == nullptr) {\n@@ -176,1 +176,1 @@\n-    if (fields[i] == NULL) {\n+    if (fields[i] == nullptr) {\n@@ -191,1 +191,1 @@\n-    if (interfaces[i] == NULL) {\n+    if (interfaces[i] == nullptr) {\n@@ -229,1 +229,1 @@\n-  if (inf.sig == NULL || strcmp(inf.sig, classes[eventsCount].sig) != 0) {\n+  if (inf.sig == nullptr || strcmp(inf.sig, classes[eventsCount].sig) != 0) {\n@@ -265,1 +265,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -302,1 +302,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -330,1 +330,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassPrepare\/classprep01\/libclassprep01.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-static jvmtiEnv *jvmti_env = NULL;\n+static jvmtiEnv *jvmti_env = nullptr;\n@@ -142,7 +142,7 @@\n-    if (ex.name != NULL && strcmp(ex.name, exs[i].name) == 0\n-        && ex.t_cls != NULL && strcmp(ex.t_cls, exs[i].t_cls) == 0\n-        && ex.t_name != NULL && strcmp(ex.t_name, exs[i].t_name) == 0\n-        && ex.t_sig != NULL && strcmp(ex.t_sig, exs[i].t_sig) == 0\n-        && ex.c_cls != NULL && strcmp(ex.c_cls, exs[i].c_cls) == 0\n-        && ex.c_name != NULL && strcmp(ex.c_name, exs[i].c_name) == 0\n-        && ex.c_sig != NULL && strcmp(ex.c_sig, exs[i].c_sig) == 0\n+    if (ex.name != nullptr && strcmp(ex.name, exs[i].name) == 0\n+        && ex.t_cls != nullptr && strcmp(ex.t_cls, exs[i].t_cls) == 0\n+        && ex.t_name != nullptr && strcmp(ex.t_name, exs[i].t_name) == 0\n+        && ex.t_sig != nullptr && strcmp(ex.t_sig, exs[i].t_sig) == 0\n+        && ex.c_cls != nullptr && strcmp(ex.c_cls, exs[i].c_cls) == 0\n+        && ex.c_name != nullptr && strcmp(ex.c_name, exs[i].c_name) == 0\n+        && ex.c_sig != nullptr && strcmp(ex.c_sig, exs[i].c_sig) == 0\n@@ -178,1 +178,1 @@\n-  if (res != JNI_OK || jvmti_env == NULL) {\n+  if (res != JNI_OK || jvmti_env == nullptr) {\n@@ -220,1 +220,1 @@\n-  if (jvmti_env == NULL) {\n+  if (jvmti_env == nullptr) {\n@@ -225,1 +225,1 @@\n-  if (clz == NULL) {\n+  if (clz == nullptr) {\n@@ -230,1 +230,1 @@\n-  if (clz == NULL) {\n+  if (clz == nullptr) {\n@@ -235,1 +235,1 @@\n-  if (clz == NULL) {\n+  if (clz == nullptr) {\n@@ -240,1 +240,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Exception\/exception01\/libexception01.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -110,4 +110,4 @@\n-    if (ex.name != NULL && strcmp(ex.name, exs[i].name) == 0\n-        && ex.c_cls != NULL && strcmp(ex.c_cls, exs[i].c_cls) == 0\n-        && ex.c_name != NULL && strcmp(ex.c_name, exs[i].c_name) == 0\n-        && ex.c_sig != NULL && strcmp(ex.c_sig, exs[i].c_sig) == 0\n+    if (ex.name != nullptr && strcmp(ex.name, exs[i].name) == 0\n+        && ex.c_cls != nullptr && strcmp(ex.c_cls, exs[i].c_cls) == 0\n+        && ex.c_name != nullptr && strcmp(ex.c_name, exs[i].c_name) == 0\n+        && ex.c_sig != nullptr && strcmp(ex.c_sig, exs[i].c_sig) == 0\n@@ -141,1 +141,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -183,1 +183,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -189,1 +189,1 @@\n-  if (clz == NULL) {\n+  if (clz == nullptr) {\n@@ -194,1 +194,1 @@\n-  if (clz == NULL) {\n+  if (clz == nullptr) {\n@@ -199,1 +199,1 @@\n-  if (clz == NULL) {\n+  if (clz == nullptr) {\n@@ -204,1 +204,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n@@ -216,1 +216,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION_CATCH, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION_CATCH, nullptr);\n@@ -227,1 +227,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_EXCEPTION_CATCH, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_EXCEPTION_CATCH, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ExceptionCatch\/excatch01\/libexcatch01.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 2,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 2,\n@@ -70,1 +70,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 6,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 6,\n@@ -72,1 +72,1 @@\n-    { NULL, \"Lfieldacc01a;\",   \"run\", \"()I\", 15,\n+    { nullptr, \"Lfieldacc01a;\",   \"run\", \"()I\", 15,\n@@ -74,1 +74,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 19,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 19,\n@@ -76,1 +76,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 28,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 28,\n@@ -78,1 +78,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 32,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 32,\n@@ -80,1 +80,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 41,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 41,\n@@ -82,1 +82,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 45,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 45,\n@@ -84,1 +84,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 54,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 54,\n@@ -86,1 +86,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 58,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 58,\n@@ -88,1 +88,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 68,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 68,\n@@ -90,1 +90,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 72,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 72,\n@@ -92,1 +92,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 82,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 82,\n@@ -94,1 +94,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 86,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 86,\n@@ -96,1 +96,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 96,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 96,\n@@ -98,1 +98,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 100,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 100,\n@@ -100,1 +100,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 109,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 109,\n@@ -102,1 +102,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 113,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 113,\n@@ -104,1 +104,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 122,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 122,\n@@ -106,1 +106,1 @@\n-    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 128,\n+    { nullptr, \"Lfieldacc01a;\", \"run\", \"()I\", 128,\n@@ -124,1 +124,1 @@\n-  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  watch.is_static = (obj == nullptr) ? JNI_TRUE : JNI_FALSE;\n@@ -166,1 +166,1 @@\n-      if (watch.m_cls == NULL || strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+      if (watch.m_cls == nullptr || strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n@@ -170,1 +170,1 @@\n-      if (watch.m_name == NULL || strcmp(watch.m_name, watches[i].m_name) != 0) {\n+      if (watch.m_name == nullptr || strcmp(watch.m_name, watches[i].m_name) != 0) {\n@@ -175,1 +175,1 @@\n-      if (watch.m_sig == NULL || strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+      if (watch.m_sig == nullptr || strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n@@ -185,1 +185,1 @@\n-      if (watch.f_name == NULL || strcmp(watch.f_name, watches[i].f_name) != 0) {\n+      if (watch.f_name == nullptr || strcmp(watch.f_name, watches[i].f_name) != 0) {\n@@ -190,1 +190,1 @@\n-      if (watch.f_sig == NULL || strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+      if (watch.f_sig == nullptr || strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n@@ -219,1 +219,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -248,1 +248,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, nullptr);\n@@ -270,1 +270,1 @@\n-  if (cls == NULL) {\n+  if (cls == nullptr) {\n@@ -292,1 +292,1 @@\n-    if (watches[i].fid == NULL) {\n+    if (watches[i].fid == nullptr) {\n@@ -320,1 +320,1 @@\n-  if (cls == NULL) {\n+  if (cls == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc01\/libfieldacc01.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -70,1 +70,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -72,1 +72,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -74,1 +74,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -76,1 +76,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -78,1 +78,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -80,1 +80,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -82,1 +82,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -84,1 +84,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -86,1 +86,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -89,1 +89,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -91,1 +91,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -93,1 +93,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -95,1 +95,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -97,1 +97,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -99,1 +99,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -101,1 +101,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -103,1 +103,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -105,1 +105,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -107,1 +107,1 @@\n-    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -124,1 +124,1 @@\n-  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  watch.is_static = (obj == nullptr) ? JNI_TRUE : JNI_FALSE;\n@@ -165,1 +165,1 @@\n-      if (watch.m_cls == NULL || strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+      if (watch.m_cls == nullptr || strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n@@ -169,1 +169,1 @@\n-      if (watch.m_name == NULL || strcmp(watch.m_name, watches[i].m_name) != 0) {\n+      if (watch.m_name == nullptr || strcmp(watch.m_name, watches[i].m_name) != 0) {\n@@ -174,1 +174,1 @@\n-      if (watch.m_sig == NULL || strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+      if (watch.m_sig == nullptr || strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n@@ -184,1 +184,1 @@\n-      if (watch.f_name == NULL || strcmp(watch.f_name, watches[i].f_name) != 0) {\n+      if (watch.f_name == nullptr || strcmp(watch.f_name, watches[i].f_name) != 0) {\n@@ -189,1 +189,1 @@\n-      if (watch.f_sig == NULL || strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+      if (watch.f_sig == nullptr || strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n@@ -217,1 +217,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -246,1 +246,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, nullptr);\n@@ -267,1 +267,1 @@\n-  if (cls == NULL) {\n+  if (cls == nullptr) {\n@@ -290,1 +290,1 @@\n-    if (watches[i].fid == NULL) {\n+    if (watches[i].fid == nullptr) {\n@@ -316,1 +316,1 @@\n-  if (cls == NULL) {\n+  if (cls == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc02\/libfieldacc02.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 3,\n+    { nullptr, \"Lfieldacc03a;\", \"run\", \"()I\", 3,\n@@ -70,1 +70,1 @@\n-    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 14,\n+    { nullptr, \"Lfieldacc03a;\", \"run\", \"()I\", 14,\n@@ -72,1 +72,1 @@\n-    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 25,\n+    { nullptr, \"Lfieldacc03a;\", \"run\", \"()I\", 25,\n@@ -74,1 +74,1 @@\n-    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 36,\n+    { nullptr, \"Lfieldacc03a;\", \"run\", \"()I\", 36,\n@@ -76,1 +76,1 @@\n-    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 47,\n+    { nullptr, \"Lfieldacc03a;\", \"run\", \"()I\", 47,\n@@ -78,1 +78,1 @@\n-    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 61,\n+    { nullptr, \"Lfieldacc03a;\", \"run\", \"()I\", 61,\n@@ -80,1 +80,1 @@\n-    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 74,\n+    { nullptr, \"Lfieldacc03a;\", \"run\", \"()I\", 74,\n@@ -82,1 +82,1 @@\n-    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 88,\n+    { nullptr, \"Lfieldacc03a;\", \"run\", \"()I\", 88,\n@@ -84,1 +84,1 @@\n-    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 100,\n+    { nullptr, \"Lfieldacc03a;\", \"run\", \"()I\", 100,\n@@ -86,1 +86,1 @@\n-    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 111,\n+    { nullptr, \"Lfieldacc03a;\", \"run\", \"()I\", 111,\n@@ -103,1 +103,1 @@\n-  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  watch.is_static = (obj == nullptr) ? JNI_TRUE : JNI_FALSE;\n@@ -145,1 +145,1 @@\n-      if (watch.m_cls == NULL || strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+      if (watch.m_cls == nullptr || strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n@@ -149,1 +149,1 @@\n-      if (watch.m_name == NULL || strcmp(watch.m_name, watches[i].m_name) != 0) {\n+      if (watch.m_name == nullptr || strcmp(watch.m_name, watches[i].m_name) != 0) {\n@@ -154,1 +154,1 @@\n-      if (watch.m_sig == NULL || strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+      if (watch.m_sig == nullptr || strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n@@ -164,1 +164,1 @@\n-      if (watch.f_name == NULL || strcmp(watch.f_name, watches[i].f_name) != 0) {\n+      if (watch.f_name == nullptr || strcmp(watch.f_name, watches[i].f_name) != 0) {\n@@ -169,1 +169,1 @@\n-      if (watch.f_sig == NULL || strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+      if (watch.f_sig == nullptr || strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n@@ -197,1 +197,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -226,1 +226,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, nullptr);\n@@ -259,1 +259,1 @@\n-    if (cls == NULL) {\n+    if (cls == nullptr) {\n@@ -269,1 +269,1 @@\n-    if (watches[i].fid == NULL) {\n+    if (watches[i].fid == nullptr) {\n@@ -294,1 +294,1 @@\n-    if (cls == NULL) {\n+    if (cls == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc03\/libfieldacc03.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-    { NULL, \"Lfieldacc04a;\", \"run\", \"()I\", 2,\n+    { nullptr, \"Lfieldacc04a;\", \"run\", \"()I\", 2,\n@@ -71,1 +71,1 @@\n-    { NULL, \"Lfieldacc04a;\", \"run\", \"()I\", 12,\n+    { nullptr, \"Lfieldacc04a;\", \"run\", \"()I\", 12,\n@@ -90,1 +90,1 @@\n-  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  watch.is_static = (obj == nullptr) ? JNI_TRUE : JNI_FALSE;\n@@ -132,1 +132,1 @@\n-      if (watch.m_cls == NULL ||  strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+      if (watch.m_cls == nullptr ||  strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n@@ -136,1 +136,1 @@\n-      if (watch.m_name == NULL || strcmp(watch.m_name, watches[i].m_name) != 0) {\n+      if (watch.m_name == nullptr || strcmp(watch.m_name, watches[i].m_name) != 0) {\n@@ -141,1 +141,1 @@\n-      if (watch.m_sig == NULL || strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+      if (watch.m_sig == nullptr || strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n@@ -151,1 +151,1 @@\n-      if (watch.f_name == NULL || strcmp(watch.f_name, watches[i].f_name) != 0) {\n+      if (watch.f_name == nullptr || strcmp(watch.f_name, watches[i].f_name) != 0) {\n@@ -156,1 +156,1 @@\n-      if (watch.f_sig == NULL || strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+      if (watch.f_sig == nullptr || strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n@@ -184,1 +184,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -213,1 +213,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, nullptr);\n@@ -246,1 +246,1 @@\n-    if (cls == NULL) {\n+    if (cls == nullptr) {\n@@ -256,1 +256,1 @@\n-    if (watches[i].fid == NULL) {\n+    if (watches[i].fid == nullptr) {\n@@ -282,1 +282,1 @@\n-    if (cls == NULL) {\n+    if (cls == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc04\/libfieldacc04.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 1,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 1,\n@@ -72,1 +72,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 5,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 5,\n@@ -74,1 +74,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 9,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 9,\n@@ -76,1 +76,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 13,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 13,\n@@ -78,1 +78,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 19,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 19,\n@@ -80,1 +80,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 24,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 24,\n@@ -82,1 +82,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 30,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 30,\n@@ -84,1 +84,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 35,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 35,\n@@ -86,1 +86,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 41,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 41,\n@@ -88,1 +88,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 47,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 47,\n@@ -91,1 +91,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 52,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 52,\n@@ -93,1 +93,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 58,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 58,\n@@ -95,1 +95,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 64,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 64,\n@@ -97,1 +97,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 70,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 70,\n@@ -99,1 +99,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 77,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 77,\n@@ -101,1 +101,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 83,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 83,\n@@ -103,1 +103,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 90,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 90,\n@@ -105,1 +105,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 96,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 96,\n@@ -107,1 +107,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 103,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 103,\n@@ -109,1 +109,1 @@\n-    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 110,\n+    { nullptr, \"Lfieldmod01a;\", \"run\", \"()V\", 110,\n@@ -190,1 +190,1 @@\n-  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  watch.is_static = (obj == nullptr) ? JNI_TRUE : JNI_FALSE;\n@@ -234,1 +234,1 @@\n-      if (watch.m_cls == NULL || strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+      if (watch.m_cls == nullptr || strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n@@ -238,1 +238,1 @@\n-      if (watch.m_name == NULL || strcmp(watch.m_name, watches[i].m_name) != 0) {\n+      if (watch.m_name == nullptr || strcmp(watch.m_name, watches[i].m_name) != 0) {\n@@ -243,1 +243,1 @@\n-      if (watch.m_sig == NULL || strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+      if (watch.m_sig == nullptr || strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n@@ -253,1 +253,1 @@\n-      if (watch.f_name == NULL || strcmp(watch.f_name, watches[i].f_name) != 0) {\n+      if (watch.f_name == nullptr || strcmp(watch.f_name, watches[i].f_name) != 0) {\n@@ -258,1 +258,1 @@\n-      if (watch.f_sig == NULL || strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+      if (watch.f_sig == nullptr || strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n@@ -294,1 +294,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -324,1 +324,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_MODIFICATION, nullptr);\n@@ -356,1 +356,1 @@\n-  if (cls == NULL) {\n+  if (cls == nullptr) {\n@@ -367,1 +367,1 @@\n-    if (watches[i].fid == NULL) {\n+    if (watches[i].fid == nullptr) {\n@@ -415,1 +415,1 @@\n-  if (cls == NULL) {\n+  if (cls == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod01\/libfieldmod01.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -72,1 +72,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -74,1 +74,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -76,1 +76,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -78,1 +78,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -80,1 +80,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -82,1 +82,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -84,1 +84,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -86,1 +86,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -88,1 +88,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -91,1 +91,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -93,1 +93,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -95,1 +95,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -97,1 +97,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -99,1 +99,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -101,1 +101,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -103,1 +103,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -105,1 +105,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -107,1 +107,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -109,1 +109,1 @@\n-    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+    { nullptr, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n@@ -190,1 +190,1 @@\n-  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  watch.is_static = (obj == nullptr) ? JNI_TRUE : JNI_FALSE;\n@@ -235,1 +235,1 @@\n-      if (watch.m_cls == NULL || strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+      if (watch.m_cls == nullptr || strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n@@ -239,1 +239,1 @@\n-      if (watch.m_name == NULL || strcmp(watch.m_name, watches[i].m_name) != 0) {\n+      if (watch.m_name == nullptr || strcmp(watch.m_name, watches[i].m_name) != 0) {\n@@ -244,1 +244,1 @@\n-      if (watch.m_sig == NULL || strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+      if (watch.m_sig == nullptr || strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n@@ -254,1 +254,1 @@\n-      if (watch.f_name == NULL || strcmp(watch.f_name, watches[i].f_name) != 0) {\n+      if (watch.f_name == nullptr || strcmp(watch.f_name, watches[i].f_name) != 0) {\n@@ -259,1 +259,1 @@\n-      if (watch.f_sig == NULL || strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+      if (watch.f_sig == nullptr || strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n@@ -295,1 +295,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -324,1 +324,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_MODIFICATION, nullptr);\n@@ -359,1 +359,1 @@\n-  if (cls == NULL) {\n+  if (cls == nullptr) {\n@@ -370,1 +370,1 @@\n-    if (watches[i].fid == NULL) {\n+    if (watches[i].fid == nullptr) {\n@@ -425,1 +425,1 @@\n-  if (cls == NULL) {\n+  if (cls == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod02\/libfieldmod02.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -114,1 +114,1 @@\n-    if (cls_sig == NULL || strcmp(cls_sig, pops[eventsCount].cls_sig) != 0) {\n+    if (cls_sig == nullptr || strcmp(cls_sig, pops[eventsCount].cls_sig) != 0) {\n@@ -119,1 +119,1 @@\n-    if (name == NULL || strcmp(name, pops[eventsCount].name) != 0) {\n+    if (name == nullptr || strcmp(name, pops[eventsCount].name) != 0) {\n@@ -124,1 +124,1 @@\n-    if (sig == NULL || strcmp(sig, pops[eventsCount].sig) != 0) {\n+    if (sig == nullptr || strcmp(sig, pops[eventsCount].sig) != 0) {\n@@ -155,1 +155,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -206,1 +206,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -221,1 +221,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, nullptr);\n@@ -226,1 +226,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n@@ -233,1 +233,1 @@\n-  if (clz == NULL) {\n+  if (clz == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop01\/libframepop01.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -119,1 +119,1 @@\n-  if (threads[i].tos == NULL) {\n+  if (threads[i].tos == nullptr) {\n@@ -134,1 +134,1 @@\n-  } while (threads[i].tos != NULL);\n+  } while (threads[i].tos != nullptr);\n@@ -158,1 +158,1 @@\n-    threads[i].tos = NULL;\n+    threads[i].tos = nullptr;\n@@ -162,1 +162,1 @@\n-  if (new_item == NULL) {\n+  if (new_item == nullptr) {\n@@ -249,1 +249,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -283,1 +283,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, nullptr);\n@@ -287,1 +287,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n@@ -298,1 +298,1 @@\n-  check_jvmti_status(jni, jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, NULL),\n+  check_jvmti_status(jni, jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, nullptr),\n@@ -300,1 +300,1 @@\n-  check_jvmti_status(jni, jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, NULL),\n+  check_jvmti_status(jni, jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, nullptr),\n@@ -307,1 +307,1 @@\n-  check_jvmti_status(jni, jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FRAME_POP, NULL),\n+  check_jvmti_status(jni, jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FRAME_POP, nullptr),\n@@ -309,1 +309,1 @@\n-  check_jvmti_status(jni, jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_ENTRY, NULL),\n+  check_jvmti_status(jni, jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_ENTRY, nullptr),\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop02\/libframepop02.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -81,1 +81,1 @@\n-  if (cls_sig != NULL && strcmp(cls_sig, \"Lmentry01;\") == 0) {\n+  if (cls_sig != nullptr && strcmp(cls_sig, \"Lmentry01;\") == 0) {\n@@ -103,1 +103,1 @@\n-      if (entry.name == NULL || strcmp(entry.name, entries[eventsCount].name) != 0) {\n+      if (entry.name == nullptr || strcmp(entry.name, entries[eventsCount].name) != 0) {\n@@ -108,1 +108,1 @@\n-      if (entry.sig == NULL || strcmp(entry.sig, entries[eventsCount].sig) != 0) {\n+      if (entry.sig == nullptr || strcmp(entry.sig, entries[eventsCount].sig) != 0) {\n@@ -140,1 +140,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -179,1 +179,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -191,1 +191,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, nullptr);\n@@ -205,1 +205,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n@@ -222,1 +222,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -228,1 +228,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_ENTRY, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_ENTRY, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodEntry\/mentry01\/libmentry01.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -43,1 +43,1 @@\n-static jmethodID mid = NULL;\n+static jmethodID mid = nullptr;\n@@ -78,1 +78,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -119,1 +119,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -133,1 +133,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n@@ -139,1 +139,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, nullptr);\n@@ -148,1 +148,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodEntry\/mentry02\/libmentry02.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -76,1 +76,1 @@\n-  if (cls_sig != NULL && strcmp(cls_sig, \"Lmexit01a;\") == 0) {\n+  if (cls_sig != nullptr && strcmp(cls_sig, \"Lmexit01a;\") == 0) {\n@@ -98,1 +98,1 @@\n-      if (cls_sig == NULL || strcmp(cls_sig, exits[eventsCount].cls_sig) != 0) {\n+      if (cls_sig == nullptr || strcmp(cls_sig, exits[eventsCount].cls_sig) != 0) {\n@@ -103,1 +103,1 @@\n-      if (name == NULL || strcmp(name, exits[eventsCount].name) != 0) {\n+      if (name == nullptr || strcmp(name, exits[eventsCount].name) != 0) {\n@@ -108,1 +108,1 @@\n-      if (sig == NULL || strcmp(sig, exits[eventsCount].sig) != 0) {\n+      if (sig == nullptr || strcmp(sig, exits[eventsCount].sig) != 0) {\n@@ -140,1 +140,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -180,1 +180,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -185,1 +185,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, nullptr);\n@@ -203,1 +203,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -217,1 +217,1 @@\n-  if (clz == NULL) {\n+  if (clz == nullptr) {\n@@ -223,1 +223,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n@@ -230,1 +230,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_EXIT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_EXIT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit01\/libmexit01.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -76,1 +76,1 @@\n-  if (cls_sig != NULL && strcmp(cls_sig, \"Lmexit02a;\") == 0) {\n+  if (cls_sig != nullptr && strcmp(cls_sig, \"Lmexit02a;\") == 0) {\n@@ -103,1 +103,1 @@\n-      if (cls_sig == NULL || strcmp(cls_sig, exits[eventsCount].cls_sig) != 0) {\n+      if (cls_sig == nullptr || strcmp(cls_sig, exits[eventsCount].cls_sig) != 0) {\n@@ -108,1 +108,1 @@\n-      if (name == NULL || strcmp(name, exits[eventsCount].name) != 0) {\n+      if (name == nullptr || strcmp(name, exits[eventsCount].name) != 0) {\n@@ -113,1 +113,1 @@\n-      if (sig == NULL || strcmp(sig, exits[eventsCount].sig) != 0) {\n+      if (sig == nullptr || strcmp(sig, exits[eventsCount].sig) != 0) {\n@@ -140,1 +140,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -181,1 +181,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -195,1 +195,1 @@\n-  if (clz == NULL) {\n+  if (clz == nullptr) {\n@@ -201,1 +201,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n@@ -206,1 +206,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, nullptr);\n@@ -217,1 +217,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_EXIT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_EXIT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit02\/libmexit02.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -43,2 +43,2 @@\n-static jthread expected_thread = NULL;\n-static jobject expected_object = NULL;\n+static jthread expected_thread = nullptr;\n+static jobject expected_object = nullptr;\n@@ -56,2 +56,2 @@\n-  if (expected_thread == NULL) {\n-    jni->FatalError(\"expected_thread is NULL.\");\n+  if (expected_thread == nullptr) {\n+    jni->FatalError(\"expected_thread is null.\");\n@@ -60,2 +60,2 @@\n-  if (expected_object == NULL) {\n-    jni->FatalError(\"expected_object is NULL.\");\n+  if (expected_object == nullptr) {\n+    jni->FatalError(\"expected_object is null.\");\n@@ -75,1 +75,1 @@\n-  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL);\n+  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, nullptr);\n@@ -85,1 +85,1 @@\n-  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL);\n+  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, nullptr);\n@@ -142,1 +142,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -180,1 +180,1 @@\n-  set_agent_proc(agentProc, NULL);\n+  set_agent_proc(agentProc, nullptr);\n@@ -193,1 +193,1 @@\n-  if (expected_object == NULL) {\n+  if (expected_object == nullptr) {\n@@ -199,1 +199,1 @@\n-  if (thread == NULL) {\n+  if (thread == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEnter\/mcontenter01\/libmcontenter01.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -40,2 +40,2 @@\n-static jthread expected_thread = NULL;\n-static jobject expected_object = NULL;\n+static jthread expected_thread = nullptr;\n+static jobject expected_object = nullptr;\n@@ -54,2 +54,2 @@\n-  if (expected_thread == NULL) {\n-    jni->FatalError(\"expected_thread is NULL.\");\n+  if (expected_thread == nullptr) {\n+    jni->FatalError(\"expected_thread is null.\");\n@@ -58,2 +58,2 @@\n-  if (expected_object == NULL) {\n-    jni->FatalError(\"expected_object is NULL.\");\n+  if (expected_object == nullptr) {\n+    jni->FatalError(\"expected_object is null.\");\n@@ -76,2 +76,2 @@\n-  if (expected_thread == NULL) {\n-    jni->FatalError(\"expected_thread is NULL.\");\n+  if (expected_thread == nullptr) {\n+    jni->FatalError(\"expected_thread is null.\");\n@@ -80,2 +80,2 @@\n-  if (expected_object == NULL) {\n-    jni->FatalError(\"expected_object is NULL.\");\n+  if (expected_object == nullptr) {\n+    jni->FatalError(\"expected_object is null.\");\n@@ -100,1 +100,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, nullptr);\n@@ -107,1 +107,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, nullptr);\n@@ -119,1 +119,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,JVMTI_EVENT_MONITOR_CONTENDED_ENTERED,NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,JVMTI_EVENT_MONITOR_CONTENDED_ENTERED,nullptr);\n@@ -176,1 +176,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -217,1 +217,1 @@\n-  set_agent_proc(agentProc, NULL);\n+  set_agent_proc(agentProc, nullptr);\n@@ -230,1 +230,1 @@\n-  if (expected_object == NULL) {\n+  if (expected_object == nullptr) {\n@@ -236,1 +236,1 @@\n-  if (thread == NULL) {\n+  if (thread == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEntered\/mcontentered01\/libmcontentered01.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -39,2 +39,2 @@\n-static jthread expected_thread = NULL;\n-static jobject expected_object = NULL;\n+static jthread expected_thread = nullptr;\n+static jobject expected_object = nullptr;\n@@ -50,2 +50,2 @@\n-  if (expected_thread == NULL) {\n-    jni->FatalError(\"expected_thread is NULL.\");\n+  if (expected_thread == nullptr) {\n+    jni->FatalError(\"expected_thread is null.\");\n@@ -54,2 +54,2 @@\n-  if (expected_object == NULL) {\n-    jni->FatalError(\"expected_object is NULL.\");\n+  if (expected_object == nullptr) {\n+    jni->FatalError(\"expected_object is null.\");\n@@ -73,1 +73,1 @@\n-  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, NULL);\n+  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, nullptr);\n@@ -83,1 +83,1 @@\n-  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAIT, NULL);\n+  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAIT, nullptr);\n@@ -138,1 +138,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -176,1 +176,1 @@\n-  set_agent_proc(agentProc, NULL);\n+  set_agent_proc(agentProc, nullptr);\n@@ -185,1 +185,1 @@\n-  if (expected_object == NULL) {\n+  if (expected_object == nullptr) {\n@@ -191,1 +191,1 @@\n-  if (thread == NULL) {\n+  if (thread == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWait\/monitorwait01\/libmonitorwait01.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -39,2 +39,2 @@\n-static jthread expected_thread = NULL;\n-static jobject expected_object = NULL;\n+static jthread expected_thread = nullptr;\n+static jobject expected_object = nullptr;\n@@ -51,2 +51,2 @@\n-  if (expected_thread == NULL) {\n-    jni->FatalError(\"expected_thread is NULL.\");\n+  if (expected_thread == nullptr) {\n+    jni->FatalError(\"expected_thread is null.\");\n@@ -55,2 +55,2 @@\n-  if (expected_object == NULL) {\n-    jni->FatalError(\"expected_object is NULL.\");\n+  if (expected_object == nullptr) {\n+    jni->FatalError(\"expected_object is null.\");\n@@ -74,1 +74,1 @@\n-  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, NULL);\n+  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, nullptr);\n@@ -84,1 +84,1 @@\n-  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAITED, NULL);\n+  jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAITED, nullptr);\n@@ -139,1 +139,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -179,1 +179,1 @@\n-  set_agent_proc(agentProc, NULL);\n+  set_agent_proc(agentProc, nullptr);\n@@ -188,1 +188,1 @@\n-  if (expected_object == NULL) {\n+  if (expected_object == nullptr) {\n@@ -194,1 +194,1 @@\n-  if (thread == NULL) {\n+  if (thread == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWaited\/monitorwaited01\/libmonitorwaited01.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -79,1 +79,1 @@\n-  err = jvmti->GetMethodName(method, &methNam, &methSig, NULL);\n+  err = jvmti->GetMethodName(method, &methNam, &methSig, nullptr);\n@@ -121,1 +121,1 @@\n-  jclass testedCls = NULL;\n+  jclass testedCls = nullptr;\n@@ -129,1 +129,1 @@\n-    if (testedCls == NULL) {\n+    if (testedCls == nullptr) {\n@@ -171,1 +171,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -206,1 +206,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind01\/libnativemethbind01.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -49,1 +49,1 @@\n-  char *methNam = NULL, *methSig = NULL;\n+  char *methNam = nullptr, *methSig = nullptr;\n@@ -63,1 +63,1 @@\n-  err = jvmti->GetMethodName(method, &methNam, &methSig, NULL);\n+  err = jvmti->GetMethodName(method, &methNam, &methSig, nullptr);\n@@ -73,1 +73,1 @@\n-  if (methNam != NULL) {\n+  if (methNam != nullptr) {\n@@ -81,1 +81,1 @@\n-  if (methSig != NULL) {\n+  if (methSig != nullptr) {\n@@ -119,1 +119,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -153,1 +153,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, nullptr);\n@@ -157,1 +157,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind02\/libnativemethbind02.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -75,1 +75,1 @@\n-  err = jvmti->GetMethodName(method, &methNam, &methSig, NULL);\n+  err = jvmti->GetMethodName(method, &methNam, &methSig, nullptr);\n@@ -87,1 +87,1 @@\n-  if (methNam != NULL) {\n+  if (methNam != nullptr) {\n@@ -95,1 +95,1 @@\n-  if (methSig != NULL) {\n+  if (methSig != nullptr) {\n@@ -136,1 +136,1 @@\n-  jclass testedCls = NULL;\n+  jclass testedCls = nullptr;\n@@ -142,1 +142,1 @@\n-  if (testedCls == NULL) {\n+  if (testedCls == nullptr) {\n@@ -174,1 +174,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -210,1 +210,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, nullptr);\n@@ -214,1 +214,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind03\/libnativemethbind03.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -87,1 +87,1 @@\n-  err = jvmti->GetMethodName(method, &methNam, &methSig, NULL);\n+  err = jvmti->GetMethodName(method, &methNam, &methSig, nullptr);\n@@ -100,1 +100,1 @@\n-  if (methNam != NULL) {\n+  if (methNam != nullptr) {\n@@ -108,1 +108,1 @@\n-  if (methSig != NULL) {\n+  if (methSig != nullptr) {\n@@ -149,1 +149,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -182,1 +182,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind04\/libnativemethbind04.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -65,1 +65,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n@@ -89,1 +89,1 @@\n-    if (sig != NULL && (strcmp(sig, CLASS_SIG) == 0)) {\n+    if (sig != nullptr && (strcmp(sig, CLASS_SIG) == 0)) {\n@@ -120,1 +120,1 @@\n-  if (sig != NULL && (strcmp(sig, CLASS_SIG) == 0)) {\n+  if (sig != nullptr && (strcmp(sig, CLASS_SIG) == 0)) {\n@@ -148,1 +148,1 @@\n-  err = jvmti->GetMethodName(method, &methNam, &methSig, NULL);\n+  err = jvmti->GetMethodName(method, &methNam, &methSig, nullptr);\n@@ -169,1 +169,1 @@\n-  if (sig != NULL) {\n+  if (sig != nullptr) {\n@@ -247,1 +247,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -287,1 +287,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, nullptr);\n@@ -291,1 +291,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n@@ -295,1 +295,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, nullptr);\n@@ -299,1 +299,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep01\/libsinglestep01.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -81,1 +81,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -116,1 +116,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, nullptr);\n@@ -120,1 +120,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep02\/libsinglestep02.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -67,1 +67,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n@@ -94,1 +94,1 @@\n-  if (sig != NULL && (strcmp(sig, CLASS_SIG) == 0)) {\n+  if (sig != nullptr && (strcmp(sig, CLASS_SIG) == 0)) {\n@@ -136,1 +136,1 @@\n-  if (sig != NULL && (strcmp(sig, CLASS_SIG) == 0)) {\n+  if (sig != nullptr && (strcmp(sig, CLASS_SIG) == 0)) {\n@@ -162,1 +162,1 @@\n-  err = jvmti->GetMethodName(method, &methNam, &methSig, NULL);\n+  err = jvmti->GetMethodName(method, &methNam, &methSig, nullptr);\n@@ -183,1 +183,1 @@\n-  if (sig != NULL) {\n+  if (sig != nullptr) {\n@@ -275,1 +275,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -313,1 +313,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, nullptr);\n@@ -317,1 +317,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n@@ -321,1 +321,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, nullptr);\n@@ -325,1 +325,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep03\/libsinglestep03.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -42,1 +42,1 @@\n-static const char *prefix = NULL;\n+static const char *prefix = nullptr;\n@@ -57,1 +57,1 @@\n-  if (inf.name != NULL && strstr(inf.name, prefix) == inf.name) {\n+  if (inf.name != nullptr && strstr(inf.name, prefix) == inf.name) {\n@@ -60,1 +60,1 @@\n-    if (inf.name == NULL || strcmp(name, inf.name) != 0) {\n+    if (inf.name == nullptr || strcmp(name, inf.name) != 0) {\n@@ -73,1 +73,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -92,1 +92,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -97,2 +97,2 @@\n-  prefix = jni->GetStringUTFChars(name, NULL);\n-  if (prefix == NULL) {\n+  prefix = jni->GetStringUTFChars(name, nullptr);\n+  if (prefix == nullptr) {\n@@ -104,1 +104,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, nullptr);\n@@ -115,1 +115,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -120,1 +120,1 @@\n-jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_THREAD_END, NULL);\n+jvmtiError err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_THREAD_END, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadEnd\/threadend01\/libthreadend01.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -55,1 +55,1 @@\n-  err = jvmti->SetEventNotificationMode(enable, event, NULL);\n+  err = jvmti->SetEventNotificationMode(enable, event, nullptr);\n@@ -132,1 +132,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -153,1 +153,1 @@\n-  set_agent_proc(agentProc, NULL);\n+  set_agent_proc(agentProc, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadEnd\/threadend02\/libthreadend02.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -42,1 +42,1 @@\n-static const char *prefix = NULL;\n+static const char *prefix = nullptr;\n@@ -57,1 +57,1 @@\n-  if (inf.name != NULL && strstr(inf.name, prefix) == inf.name) {\n+  if (inf.name != nullptr && strstr(inf.name, prefix) == inf.name) {\n@@ -73,1 +73,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -92,1 +92,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -97,2 +97,2 @@\n-  prefix = jni->GetStringUTFChars(name, NULL);\n-  if (prefix == NULL) {\n+  prefix = jni->GetStringUTFChars(name, nullptr);\n+  if (prefix == nullptr) {\n@@ -104,1 +104,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, nullptr);\n@@ -117,1 +117,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -122,1 +122,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_THREAD_START, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_THREAD_START, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart01\/libthreadstart01.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -41,1 +41,1 @@\n-static volatile jthread agent_thread = NULL;\n+static volatile jthread agent_thread = nullptr;\n@@ -45,1 +45,1 @@\n-static volatile jthread next_thread = NULL;\n+static volatile jthread next_thread = nullptr;\n@@ -131,1 +131,1 @@\n-    if (next_thread == NULL) {\n+    if (next_thread == nullptr) {\n@@ -136,1 +136,1 @@\n-    if (next_thread != NULL) {\n+    if (next_thread != nullptr) {\n@@ -163,1 +163,1 @@\n-    next_thread = NULL;\n+    next_thread = nullptr;\n@@ -270,2 +270,2 @@\n-  jclass cls = NULL;\n-  jmethodID mid = NULL;\n+  jclass cls = nullptr;\n+  jmethodID mid = nullptr;\n@@ -275,1 +275,1 @@\n-  check_jvmti_status(jni, jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL),\n+  check_jvmti_status(jni, jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, nullptr),\n@@ -280,1 +280,1 @@\n-  if (cls == NULL) {\n+  if (cls == nullptr) {\n@@ -287,1 +287,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n@@ -294,1 +294,1 @@\n-  if (agent_thread == NULL) {\n+  if (agent_thread == nullptr) {\n@@ -301,1 +301,1 @@\n-  if (agent_thread == NULL) {\n+  if (agent_thread == nullptr) {\n@@ -314,1 +314,1 @@\n-  check_jvmti_status(jni, jvmti->RunAgentThread(agent_thread, debug_agent, NULL, JVMTI_THREAD_NORM_PRIORITY),\n+  check_jvmti_status(jni, jvmti->RunAgentThread(agent_thread, debug_agent, nullptr, JVMTI_THREAD_NORM_PRIORITY),\n@@ -330,1 +330,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -369,1 +369,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n@@ -376,1 +376,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart02\/libthreadstart02.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -42,1 +42,1 @@\n-static const char *threadName = NULL;\n+static const char *threadName = nullptr;\n@@ -60,1 +60,1 @@\n-  if (inf.name != NULL && strcmp(inf.name, threadName) == 0) {\n+  if (inf.name != nullptr && strcmp(inf.name, threadName) == 0) {\n@@ -77,1 +77,1 @@\n-  if (inf.name != NULL && strcmp(inf.name, threadName) == 0) {\n+  if (inf.name != nullptr && strcmp(inf.name, threadName) == 0) {\n@@ -87,1 +87,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -113,1 +113,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -118,2 +118,2 @@\n-  threadName = jni->GetStringUTFChars(name, NULL);\n-  if (threadName == NULL) {\n+  threadName = jni->GetStringUTFChars(name, nullptr);\n+  if (threadName == nullptr) {\n@@ -126,1 +126,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, nullptr);\n@@ -134,1 +134,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, nullptr);\n@@ -146,1 +146,1 @@\n-    err = jvmti->RunAgentThread(thr, threadProc, NULL, JVMTI_THREAD_MAX_PRIORITY);\n+    err = jvmti->RunAgentThread(thr, threadProc, nullptr, JVMTI_THREAD_MAX_PRIORITY);\n@@ -167,1 +167,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_THREAD_START, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_THREAD_START, nullptr);\n@@ -173,1 +173,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_THREAD_END, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_THREAD_END, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart03\/libthreadstart03.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-  if (signature != NULL)\n+  if (signature != nullptr)\n@@ -71,1 +71,1 @@\n-  if (generic != NULL)\n+  if (generic != nullptr)\n@@ -95,1 +95,1 @@\n-  jvmtiEnv* jvmti = NULL;\n+  jvmtiEnv* jvmti = nullptr;\n@@ -106,1 +106,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -130,1 +130,1 @@\n-  if (jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, NULL) != JVMTI_ERROR_NONE) {\n+  if (jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, nullptr) != JVMTI_ERROR_NONE) {\n@@ -135,1 +135,1 @@\n-  set_agent_proc(agentProc, NULL);\n+  set_agent_proc(agentProc, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/VMObjectAlloc\/vmobjalloc01\/libvmobjalloc01.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jvmtiEnv *jvmti_env = NULL;\n+static jvmtiEnv *jvmti_env = nullptr;\n@@ -36,1 +36,1 @@\n-  if (res != JNI_OK || jvmti_env == NULL) {\n+  if (res != JNI_OK || jvmti_env == nullptr) {\n@@ -51,1 +51,1 @@\n-  if (jvmti_env == NULL) {\n+  if (jvmti_env == nullptr) {\n@@ -58,1 +58,1 @@\n-  err = jvmti_env->GetAllThreads(NULL, &threadsPtr);\n+  err = jvmti_env->GetAllThreads(nullptr, &threadsPtr);\n@@ -67,1 +67,1 @@\n-  err = jvmti_env->GetAllThreads(&threadsCountPtr, NULL);\n+  err = jvmti_env->GetAllThreads(&threadsCountPtr, nullptr);\n@@ -74,1 +74,1 @@\n-  err = jvmti_env->GetAllThreads(NULL, NULL);\n+  err = jvmti_env->GetAllThreads(nullptr, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/negative\/GetAllThreadsNullTest\/libGetAllThreadsNullTest.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -45,1 +45,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -67,1 +67,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -83,1 +83,1 @@\n-  err = jvmti->GetCurrentContendedMonitor(thread, NULL);\n+  err = jvmti->GetCurrentContendedMonitor(thread, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/negative\/contmon03\/libcontmon03.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -43,1 +43,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -57,1 +57,1 @@\n-    err = jvmti->GetFrameCount(thr, NULL);\n+    err = jvmti->GetFrameCount(thr, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/negative\/framecnt02\/libframecnt02.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -43,1 +43,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -56,1 +56,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/negative\/framecnt03\/libframecnt03.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -46,1 +46,1 @@\n-  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+  if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -51,1 +51,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -87,1 +87,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -126,1 +126,1 @@\n-  err = jvmti->GetFrameLocation(thr, 0, NULL, &loc);\n+  err = jvmti->GetFrameLocation(thr, 0, nullptr, &loc);\n@@ -136,1 +136,1 @@\n-  err = jvmti->GetFrameLocation(thr, 0, &mid, NULL);\n+  err = jvmti->GetFrameLocation(thr, 0, &mid, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/negative\/frameloc03\/libframeloc03.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -43,1 +43,1 @@\n-  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+  if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -48,1 +48,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -62,1 +62,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -88,1 +88,1 @@\n-  err = jvmti->GetStackTrace(thread, 0, 1, NULL, &count);\n+  err = jvmti->GetStackTrace(thread, 0, 1, nullptr, &count);\n@@ -98,1 +98,1 @@\n-  err = jvmti->GetStackTrace(thread, 0, 1, &frame, NULL);\n+  err = jvmti->GetStackTrace(thread, 0, 1, &frame, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/negative\/getstacktr02\/libgetstacktr02.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -43,1 +43,1 @@\n-  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+  if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -48,1 +48,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -62,1 +62,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/negative\/getstacktr09\/libgetstacktr09.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -43,1 +43,1 @@\n-  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+  if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -48,1 +48,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -61,1 +61,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -69,1 +69,1 @@\n-  err = jvmti->GetThreadInfo(NULL, &inf);\n+  err = jvmti->GetThreadInfo(nullptr, &inf);\n@@ -76,1 +76,1 @@\n-  if (inf.name == NULL || strcmp(inf.name, \"main\")) {\n+  if (inf.name == nullptr || strcmp(inf.name, \"main\")) {\n@@ -96,1 +96,1 @@\n-  err = jvmti->GetThreadInfo(thr, NULL);\n+  err = jvmti->GetThreadInfo(thr, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/negative\/thrinfo02\/libthrinfo02.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -43,1 +43,1 @@\n-  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+  if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -48,1 +48,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -61,1 +61,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -69,1 +69,1 @@\n-  err = jvmti->GetThreadState(thr, NULL);\n+  err = jvmti->GetThreadState(thr, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/negative\/thrstat04\/libthrstat04.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  jmethodID method = NULL;\n+  jmethodID method = nullptr;\n@@ -81,1 +81,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -93,1 +93,1 @@\n-      jthread tested_thread = NULL;\n+      jthread tested_thread = nullptr;\n@@ -103,1 +103,1 @@\n-      if (tested_thread != NULL) {\n+      if (tested_thread != nullptr) {\n@@ -135,1 +135,1 @@\n-  if (set_agent_proc(agentProc, NULL) != JNI_TRUE) {\n+  if (set_agent_proc(agentProc, nullptr) != JNI_TRUE) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/stress\/StackTrace\/NotSuspended\/libGetStackTraceNotSuspendedStress.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-static jrawMonitorID event_mon = NULL;\n+static jrawMonitorID event_mon = nullptr;\n@@ -40,1 +40,1 @@\n-  jmethodID method = NULL;\n+  jmethodID method = nullptr;\n@@ -96,1 +96,1 @@\n-  if (cthread != NULL) {\n+  if (cthread != nullptr) {\n@@ -121,1 +121,1 @@\n-  \/\/const char* cname = (cthread == NULL) ? \"<no cthread>\" : get_thread_name(jvmti, jni, cthread);\n+  \/\/const char* cname = (cthread == nullptr) ? \"<no cthread>\" : get_thread_name(jvmti, jni, cthread);\n@@ -126,1 +126,1 @@\n-  if (cthread != NULL) { \/\/ pre-condition for reliable testing\n+  if (cthread != nullptr) { \/\/ pre-condition for reliable testing\n@@ -148,1 +148,1 @@\n-  if (cthread != NULL) {\n+  if (cthread != nullptr) {\n@@ -173,1 +173,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -185,1 +185,1 @@\n-      jthread vthread = NULL;\n+      jthread vthread = nullptr;\n@@ -195,1 +195,1 @@\n-      if (iter > 50 && vthread != NULL) {\n+      if (iter > 50 && vthread != nullptr) {\n@@ -259,1 +259,1 @@\n-  if (set_agent_proc(agentProc, NULL) != JNI_TRUE) {\n+  if (set_agent_proc(agentProc, nullptr) != JNI_TRUE) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/stress\/StackTrace\/Suspended\/libGetStackTraceSuspendedStress.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -57,1 +57,1 @@\n-  if (storage == NULL) {\n+  if (storage == nullptr) {\n@@ -59,1 +59,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -74,1 +74,1 @@\n-  if (storage == NULL) {\n+  if (storage == nullptr) {\n@@ -79,1 +79,1 @@\n-  jvmtiError err = jvmti->SetThreadLocalStorage(thread, NULL);\n+  jvmtiError err = jvmti->SetThreadLocalStorage(thread, nullptr);\n@@ -128,1 +128,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -139,1 +139,1 @@\n-      jthread testedThread = NULL;\n+      jthread testedThread = nullptr;\n@@ -148,1 +148,1 @@\n-      if (testedThread == NULL) {\n+      if (testedThread == nullptr) {\n@@ -208,1 +208,1 @@\n-  jvmtiEnv * jvmti = NULL;\n+  jvmtiEnv * jvmti = nullptr;\n@@ -216,1 +216,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -253,6 +253,6 @@\n-  jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n-  jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n-  jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL);\n-  jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, NULL);\n-  jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, NULL);\n-  jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_END, NULL);\n+  jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n+  jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n+  jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, nullptr);\n+  jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, nullptr);\n+  jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, nullptr);\n+  jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_END, nullptr);\n@@ -265,1 +265,1 @@\n-  if (set_agent_proc(agentProc, NULL) != JNI_TRUE) {\n+  if (set_agent_proc(agentProc, nullptr) != JNI_TRUE) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/stress\/ThreadLocalStorage\/SetGetThreadLocalStorageStressTest\/libSetGetThreadLocalStorageStress.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run main\/othervm\/native -Djava.util.concurrent.ForkJoinPool.common.parallelism=1 -agentlib:allthr01 allthr01\n+ * @run main\/othervm\/native -Djdk.virtualThreadScheduler.maxPoolSize=1 -agentlib:allthr01 allthr01\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetAllThreads\/allthr01\/allthr01.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-\/\/ Tes uses -Djava.util.concurrent.ForkJoinPool.common.parallelism=1\n+\/\/ Test uses -Djdk.virtualThreadScheduler.maxPoolSize=1\n@@ -96,1 +96,1 @@\n-  if (res != JNI_OK || jvmti_env == NULL) {\n+  if (res != JNI_OK || jvmti_env == nullptr) {\n@@ -165,1 +165,1 @@\n-                                             sys_thread, NULL,JVMTI_THREAD_NORM_PRIORITY);\n+                                             sys_thread, nullptr,JVMTI_THREAD_NORM_PRIORITY);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetAllThreads\/allthr01\/liballthr01.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -38,1 +38,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -57,1 +57,1 @@\n-  jobject monitor = NULL;\n+  jobject monitor = nullptr;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetCurrentContendedMonitor\/contmon01\/libcontmon01.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -59,1 +59,1 @@\n-  if (monitor != NULL) {\n+  if (monitor != nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetCurrentContendedMonitor\/contmon02\/libcontmon02.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-static jvmtiEnv *jvmti_env = NULL;\n+static jvmtiEnv *jvmti_env = nullptr;\n@@ -38,1 +38,1 @@\n-  if (res != JNI_OK || jvmti_env == NULL) {\n+  if (res != JNI_OK || jvmti_env == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetFrameCount\/framecnt01\/libframecnt01.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-static jvmtiEnv *jvmti_env = NULL;\n+static jvmtiEnv *jvmti_env = nullptr;\n@@ -43,1 +43,1 @@\n-  jmethodID mid = NULL;\n+  jmethodID mid = nullptr;\n@@ -91,1 +91,1 @@\n-  if (res != JNI_OK || jvmti_env == NULL) {\n+  if (res != JNI_OK || jvmti_env == nullptr) {\n@@ -118,1 +118,1 @@\n-  if (mid1 == NULL) {\n+  if (mid1 == nullptr) {\n@@ -124,1 +124,1 @@\n-  err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION_CATCH, NULL);\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION_CATCH, nullptr);\n@@ -137,1 +137,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetFrameLocation\/frameloc01\/libframeloc01.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static jvmtiEnv *jvmti_env = NULL;\n+static jvmtiEnv *jvmti_env = nullptr;\n@@ -50,1 +50,1 @@\n-  if (res != JNI_OK || jvmti_env == NULL) {\n+  if (res != JNI_OK || jvmti_env == nullptr) {\n@@ -101,1 +101,1 @@\n-  if (cls_sig == NULL || strcmp(cls_sig, fi.cls_sig) != 0) {\n+  if (cls_sig == nullptr || strcmp(cls_sig, fi.cls_sig) != 0) {\n@@ -106,1 +106,1 @@\n-  if (name == NULL || strcmp(name, fi.name) != 0) {\n+  if (name == nullptr || strcmp(name, fi.name) != 0) {\n@@ -111,1 +111,1 @@\n-  if (sig == NULL || strcmp(sig, fi.sig) != 0) {\n+  if (sig == nullptr || strcmp(sig, fi.sig) != 0) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetFrameLocation\/frameloc02\/libframeloc02.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"..\/get_stack_trace.h\"\n+#include \"..\/get_stack_trace.hpp\"\n@@ -33,2 +33,2 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jmethodID* ids = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jmethodID* ids = nullptr;\n@@ -40,1 +40,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -74,2 +74,2 @@\n-    jclass rslt = NULL;\n-    char* class_name = NULL;\n+    jclass rslt = nullptr;\n+    char* class_name = nullptr;\n@@ -77,2 +77,2 @@\n-    if (rslt != NULL) {\n-        jvmti->GetClassSignature(rslt, &class_name, NULL);\n+    if (rslt != nullptr) {\n+        jvmti->GetClassSignature(rslt, &class_name, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/GetStackTraceAndRetransformTest\/libGetStackTraceAndRetransformTest.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"..\/get_stack_trace.h\"\n+#include \"..\/get_stack_trace.hpp\"\n@@ -33,1 +33,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -55,1 +55,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/GetStackTraceCurrentThreadTest\/libGetStackTraceCurrentThreadTest.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,2 @@\n-#ifndef GET_STACK_TRACE_H\n-#define GET_STACK_TRACE_H\n+#ifndef GET_STACK_TRACE_HPP\n+#define GET_STACK_TRACE_HPP\n@@ -84,1 +84,1 @@\n-      if (class_signature == NULL || strncmp(class_signature, expected_frames[exp_idx].cls, lambda_idx) != 0) {\n+      if (class_signature == nullptr || strncmp(class_signature, expected_frames[exp_idx].cls, lambda_idx) != 0) {\n@@ -90,1 +90,1 @@\n-      if (name == NULL || strcmp(name, expected_frames[exp_idx].name) != 0) {\n+      if (name == nullptr || strcmp(name, expected_frames[exp_idx].name) != 0) {\n@@ -95,1 +95,1 @@\n-      if (sig == NULL || strcmp(sig, expected_frames[exp_idx].sig) != 0) {\n+      if (sig == nullptr || strcmp(sig, expected_frames[exp_idx].sig) != 0) {\n@@ -106,1 +106,1 @@\n-#endif \/\/GET_STACK_TRACE_H\n+#endif \/\/GET_STACK_TRACE_HPP\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/get_stack_trace.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/get_stack_trace.h","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"..\/get_stack_trace.h\"\n+#include \"..\/get_stack_trace.hpp\"\n@@ -32,1 +32,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -58,1 +58,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr03\/libgetstacktr03.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"..\/get_stack_trace.h\"\n+#include \"..\/get_stack_trace.hpp\"\n@@ -32,1 +32,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -83,1 +83,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -111,1 +111,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n@@ -116,1 +116,1 @@\n-  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE,JVMTI_EVENT_BREAKPOINT, NULL);\n+  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE,JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr04\/libgetstacktr04.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"..\/get_stack_trace.h\"\n+#include \"..\/get_stack_trace.hpp\"\n@@ -32,1 +32,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -105,1 +105,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -135,1 +135,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n@@ -139,1 +139,1 @@\n-  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE,JVMTI_EVENT_BREAKPOINT, NULL);\n+  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE,JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr05\/libgetstacktr05.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"..\/get_stack_trace.h\"\n+#include \"..\/get_stack_trace.hpp\"\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -70,1 +70,1 @@\n-  set_event_notification_mode(jvmti, jni, JVMTI_DISABLE,JVMTI_EVENT_BREAKPOINT, NULL);\n+  set_event_notification_mode(jvmti, jni, JVMTI_DISABLE,JVMTI_EVENT_BREAKPOINT, nullptr);\n@@ -95,1 +95,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -131,1 +131,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n@@ -136,1 +136,1 @@\n-  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE,JVMTI_EVENT_BREAKPOINT, NULL);\n+  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE,JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr06\/libgetstacktr06.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"..\/get_stack_trace.h\"\n+#include \"..\/get_stack_trace.hpp\"\n@@ -35,1 +35,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -76,1 +76,1 @@\n-  if (classBytes == NULL) {\n+  if (classBytes == nullptr) {\n@@ -86,1 +86,1 @@\n-  class_def.class_bytes = (unsigned char *) jni->GetByteArrayElements(classBytes, NULL);\n+  class_def.class_bytes = (unsigned char *) jni->GetByteArrayElements(classBytes, nullptr);\n@@ -90,1 +90,1 @@\n-  classBytes = NULL;\n+  classBytes = nullptr;\n@@ -108,1 +108,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -140,1 +140,1 @@\n-  if (mid == NULL) {\n+  if (mid == nullptr) {\n@@ -145,1 +145,1 @@\n-  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr07\/libgetstacktr07.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"..\/get_stack_trace.h\"\n+#include \"..\/get_stack_trace.hpp\"\n@@ -33,1 +33,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -119,1 +119,1 @@\n-    if (classBytes == NULL) {\n+    if (classBytes == nullptr) {\n@@ -128,1 +128,1 @@\n-    classDef.class_bytes = (unsigned char *) jni->GetByteArrayElements(classBytes, NULL);\n+    classDef.class_bytes = (unsigned char *) jni->GetByteArrayElements(classBytes, nullptr);\n@@ -132,1 +132,1 @@\n-    classBytes = NULL;\n+    classBytes = nullptr;\n@@ -143,1 +143,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -179,1 +179,1 @@\n-  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n@@ -184,1 +184,1 @@\n-  if (mid_chain4 != NULL) {\n+  if (mid_chain4 != nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/getstacktr08\/libgetstacktr08.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv *jvmti_env = NULL;\n+static jvmtiEnv *jvmti_env = nullptr;\n@@ -52,1 +52,1 @@\n-  if (res != JNI_OK || jvmti_env == NULL) {\n+  if (res != JNI_OK || jvmti_env == nullptr) {\n@@ -78,2 +78,2 @@\n-  if (inf.name == NULL) {\n-    LOG(\"Thread %s: incorrect name in NULL\\n\", expected_info.name);\n+  if (inf.name == nullptr) {\n+    LOG(\"Thread %s: incorrect name in null\\n\", expected_info.name);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetThreadInfo\/thrinfo01\/libthrinfo01.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -38,1 +38,1 @@\n-static jthread tested_thread_thr1 = NULL;\n+static jthread tested_thread_thr1 = nullptr;\n@@ -48,1 +48,1 @@\n-  jvmtiError err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL);\n+  jvmtiError err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, nullptr);\n@@ -50,1 +50,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, nullptr);\n@@ -61,1 +61,1 @@\n-  if (thread_info.name != NULL && strcmp(thread_info.name, \"tested_thread_thr1\") == 0) {\n+  if (thread_info.name != nullptr && strcmp(thread_info.name, \"tested_thread_thr1\") == 0) {\n@@ -75,1 +75,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -104,1 +104,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n@@ -120,1 +120,1 @@\n-  if (tested_thread_thr1 == NULL) {\n+  if (tested_thread_thr1 == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetThreadState\/thrstat01\/libthrstat01.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -35,1 +35,1 @@\n-static jthread thr_ptr = NULL;\n+static jthread thr_ptr = nullptr;\n@@ -58,1 +58,1 @@\n-  jvmtiError err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL);\n+  jvmtiError err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, nullptr);\n@@ -66,1 +66,1 @@\n-  if (thread_info.name != NULL && strcmp(thread_info.name, \"tested_thread_thr1\") == 0) {\n+  if (thread_info.name != nullptr && strcmp(thread_info.name, \"tested_thread_thr1\") == 0) {\n@@ -80,1 +80,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -106,1 +106,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n@@ -138,1 +138,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -143,1 +143,1 @@\n-  if (thr_ptr == NULL) {\n+  if (thr_ptr == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetThreadState\/thrstat02\/libthrstat02.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -49,1 +49,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -62,1 +62,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetThreadState\/thrstat03\/libthrstat03.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-static jvmtiEnv *jvmti_env = NULL;\n+static jvmtiEnv *jvmti_env = nullptr;\n@@ -78,1 +78,1 @@\n-    LOG(\"Agent_OnLoad: Error: GetEnv returned error or NULL\\n\");\n+    LOG(\"Agent_OnLoad: Error: GetEnv returned error or null\\n\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetThreadState\/thrstat05\/libthrstat05.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    jthread testedThread = NULL;\n+    jthread testedThread = nullptr;\n@@ -55,1 +55,1 @@\n-    if (testedThread == NULL) {\n+    if (testedThread == nullptr) {\n@@ -103,1 +103,1 @@\n-  jvmtiEnv *jvmti = NULL;\n+  jvmtiEnv *jvmti = nullptr;\n@@ -109,1 +109,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -125,1 +125,1 @@\n-  if (!set_agent_proc(agentProc, NULL)) {\n+  if (!set_agent_proc(agentProc, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/ResumeThread\/resumethrd01\/libresumethrd01.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-static jthread testedThread = NULL;\n+static jthread testedThread = nullptr;\n@@ -62,1 +62,1 @@\n-    if (testedThread == NULL) {\n+    if (testedThread == nullptr) {\n@@ -69,1 +69,1 @@\n-    enable_events_notifications(jvmti, jni, JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL);\n+    enable_events_notifications(jvmti, jni, JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr);\n@@ -105,1 +105,1 @@\n-    enable_events_notifications(jvmti, jni,JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL);\n+    enable_events_notifications(jvmti, jni,JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr);\n@@ -126,1 +126,1 @@\n-  if (thread != NULL && jni->IsSameObject(testedThread, thread)) {\n+  if (thread != nullptr && jni->IsSameObject(testedThread, thread)) {\n@@ -139,1 +139,1 @@\n-  jvmtiEnv* jvmti = NULL;\n+  jvmtiEnv* jvmti = nullptr;\n@@ -144,1 +144,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -176,1 +176,1 @@\n-  if (!set_agent_proc(agentProc, NULL)) {\n+  if (!set_agent_proc(agentProc, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/ResumeThread\/resumethrd02\/libresumethrd02.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n-    jthread* threads = NULL;\n-    jvmtiError* results = NULL;\n+    jthread* threads = nullptr;\n+    jvmtiError* results = nullptr;\n@@ -126,1 +126,1 @@\n-      if (threads[i] != NULL)\n+      if (threads[i] != nullptr)\n@@ -146,1 +146,1 @@\n-  jthread* threads = NULL;\n+  jthread* threads = nullptr;\n@@ -152,1 +152,1 @@\n-    foundThreads[i] = NULL;\n+    foundThreads[i] = nullptr;\n@@ -162,1 +162,1 @@\n-    if (info.name != NULL && strncmp(name, info.name, len) == 0) {\n+    if (info.name != nullptr && strncmp(name, info.name, len) == 0) {\n@@ -185,1 +185,1 @@\n-    if ( foundThreads[i] == NULL) {\n+    if ( foundThreads[i] == nullptr) {\n@@ -197,1 +197,1 @@\n-  jvmtiEnv* jvmti = NULL;\n+  jvmtiEnv* jvmti = nullptr;\n@@ -202,1 +202,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -222,1 +222,1 @@\n-  if (!set_agent_proc(agentProc, NULL)) {\n+  if (!set_agent_proc(agentProc, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/ResumeThreadList\/resumethrdlst01\/libresumethrdlst01.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-static jthread* threads = NULL;\n+static jthread* threads = nullptr;\n@@ -68,1 +68,1 @@\n-    jvmtiError* results = NULL;\n+    jvmtiError* results = nullptr;\n@@ -101,1 +101,1 @@\n-    enable_events_notifications(jvmti, jni,JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL);\n+    enable_events_notifications(jvmti, jni,JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr);\n@@ -139,1 +139,1 @@\n-    enable_events_notifications(jvmti, jni, JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL);\n+    enable_events_notifications(jvmti, jni, JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr);\n@@ -147,1 +147,1 @@\n-      if (threads[i] != NULL)\n+      if (threads[i] != nullptr)\n@@ -167,1 +167,1 @@\n-  jthread* threads = NULL;\n+  jthread* threads = nullptr;\n@@ -173,1 +173,1 @@\n-    foundThreads[i] = NULL;\n+    foundThreads[i] = nullptr;\n@@ -183,1 +183,1 @@\n-    if (info.name != NULL && strncmp(name, info.name, len) == 0) {\n+    if (info.name != nullptr && strncmp(name, info.name, len) == 0) {\n@@ -206,1 +206,1 @@\n-    if ( foundThreads[i] == NULL) {\n+    if ( foundThreads[i] == nullptr) {\n@@ -224,1 +224,1 @@\n-    if (thread != NULL && jni->IsSameObject(threads[i], thread)) {\n+    if (thread != nullptr && jni->IsSameObject(threads[i], thread)) {\n@@ -237,1 +237,1 @@\n-  jvmtiEnv* jvmti = NULL;\n+  jvmtiEnv* jvmti = nullptr;\n@@ -242,1 +242,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -276,1 +276,1 @@\n-  if (!set_agent_proc(agentProc, NULL)) {\n+  if (!set_agent_proc(agentProc, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/ResumeThreadList\/resumethrdlst02\/libresumethrdlst02.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    if (tested_thread == NULL) {\n+    if (tested_thread == nullptr) {\n@@ -100,1 +100,1 @@\n-  jvmtiEnv *jvmti = NULL;\n+  jvmtiEnv *jvmti = nullptr;\n@@ -105,1 +105,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -125,1 +125,1 @@\n-  if (!set_agent_proc(agentProc, NULL)) {\n+  if (!set_agent_proc(agentProc, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/SuspendThread\/suspendthrd01\/libsuspendthrd01.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-static jthread testedThread = NULL;\n+static jthread testedThread = nullptr;\n@@ -64,1 +64,1 @@\n-    if (testedThread == NULL) {\n+    if (testedThread == nullptr) {\n@@ -71,1 +71,1 @@\n-    enable_events_notifications(jvmti, jni, JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL);\n+    enable_events_notifications(jvmti, jni, JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr);\n@@ -99,1 +99,1 @@\n-    enable_events_notifications(jvmti, jni, JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL);\n+    enable_events_notifications(jvmti, jni, JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr);\n@@ -125,1 +125,1 @@\n-  if (thread != NULL && jni->IsSameObject(testedThread, thread)) {\n+  if (thread != nullptr && jni->IsSameObject(testedThread, thread)) {\n@@ -135,1 +135,1 @@\n-  jvmtiEnv *jvmti = NULL;\n+  jvmtiEnv *jvmti = nullptr;\n@@ -140,1 +140,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -171,1 +171,1 @@\n-  if (!set_agent_proc(agentProc, NULL)) {\n+  if (!set_agent_proc(agentProc, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/SuspendThread\/suspendthrd02\/libsuspendthrd02.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,2 @@\n-    jthread *threads = NULL;\n-    jvmtiError *results = NULL;\n+    jthread *threads = nullptr;\n+    jvmtiError *results = nullptr;\n@@ -123,1 +123,1 @@\n-      if (threads[i] != NULL)\n+      if (threads[i] != nullptr)\n@@ -144,1 +144,1 @@\n-  jthread *threads = NULL;\n+  jthread *threads = nullptr;\n@@ -150,1 +150,1 @@\n-    found_threads[i] = NULL;\n+    found_threads[i] = nullptr;\n@@ -161,1 +161,1 @@\n-    if (info.name != NULL && strncmp(name, info.name, len) == 0) {\n+    if (info.name != nullptr && strncmp(name, info.name, len) == 0) {\n@@ -185,1 +185,1 @@\n-    if (found_threads[i] == NULL) {\n+    if (found_threads[i] == nullptr) {\n@@ -197,1 +197,1 @@\n-  jvmtiEnv *jvmti = NULL;\n+  jvmtiEnv *jvmti = nullptr;\n@@ -202,1 +202,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -219,1 +219,1 @@\n-  if (!set_agent_proc(agentProc, NULL)) {\n+  if (!set_agent_proc(agentProc, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/SuspendThreadList\/suspendthrdlst01\/libsuspendthrdlst01.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-static jthread* threads = NULL;\n+static jthread* threads = nullptr;\n@@ -69,1 +69,1 @@\n-    jvmtiError* results = NULL;\n+    jvmtiError* results = nullptr;\n@@ -103,1 +103,1 @@\n-    enable_events_notifications(jvmti, jni, JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL);\n+    enable_events_notifications(jvmti, jni, JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr);\n@@ -124,1 +124,1 @@\n-    enable_events_notifications(jvmti, jni,JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL);\n+    enable_events_notifications(jvmti, jni,JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr);\n@@ -140,1 +140,1 @@\n-      if (threads[i] != NULL) {\n+      if (threads[i] != nullptr) {\n@@ -162,1 +162,1 @@\n-  jthread* threads = NULL;\n+  jthread* threads = nullptr;\n@@ -167,1 +167,1 @@\n-    foundThreads[i] = NULL;\n+    foundThreads[i] = nullptr;\n@@ -177,1 +177,1 @@\n-    if (info.name != NULL && strncmp(name, info.name, len) == 0) {\n+    if (info.name != nullptr && strncmp(name, info.name, len) == 0) {\n@@ -201,1 +201,1 @@\n-    if (foundThreads[i] == NULL) {\n+    if (foundThreads[i] == nullptr) {\n@@ -216,1 +216,1 @@\n-    if (thread != NULL && jni->IsSameObject(threads[i], thread)) {\n+    if (thread != nullptr && jni->IsSameObject(threads[i], thread)) {\n@@ -227,1 +227,1 @@\n-  jvmtiEnv* jvmti = NULL;\n+  jvmtiEnv* jvmti = nullptr;\n@@ -232,1 +232,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -264,1 +264,1 @@\n-  if (!set_agent_proc(agentProc, NULL)) {\n+  if (!set_agent_proc(agentProc, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/SuspendThreadList\/suspendthrdlst02\/libsuspendthrdlst02.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jrawMonitorID event_mon = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jrawMonitorID event_mon = nullptr;\n@@ -66,1 +66,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -134,1 +134,1 @@\n-  jmethodID method = NULL;\n+  jmethodID method = nullptr;\n@@ -139,2 +139,2 @@\n-  JNIEnv* jni = NULL;\n-  jthread thread = NULL;\n+  JNIEnv* jni = nullptr;\n+  jthread thread = nullptr;\n@@ -165,1 +165,1 @@\n-  jmethodID method = NULL;\n+  jmethodID method = nullptr;\n@@ -170,2 +170,2 @@\n-  JNIEnv* jni = NULL;\n-  jthread thread = NULL;\n+  JNIEnv* jni = nullptr;\n+  jthread thread = nullptr;\n@@ -242,1 +242,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, nullptr);\n@@ -248,1 +248,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, nullptr);\n@@ -253,1 +253,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, EXT_EVENT_VIRTUAL_THREAD_MOUNT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, EXT_EVENT_VIRTUAL_THREAD_MOUNT, nullptr);\n@@ -259,1 +259,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, EXT_EVENT_VIRTUAL_THREAD_UNMOUNT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, EXT_EVENT_VIRTUAL_THREAD_UNMOUNT, nullptr);\n@@ -279,3 +279,3 @@\n-  jclass k1 = find_class(jvmti, jni, NULL, \"Ljava\/lang\/VirtualThread;\");\n-  jclass k2 = find_class(jvmti, jni, NULL, \"Ljdk\/internal\/vm\/Continuation;\");\n-  if (k1 == NULL || k2 == NULL) {\n+  jclass k1 = find_class(jvmti, jni, nullptr, \"Ljava\/lang\/VirtualThread;\");\n+  jclass k2 = find_class(jvmti, jni, nullptr, \"Ljdk\/internal\/vm\/Continuation;\");\n+  if (k1 == nullptr || k2 == nullptr) {\n@@ -288,1 +288,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n@@ -300,1 +300,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_THREAD_START, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_THREAD_START, nullptr);\n@@ -303,1 +303,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, nullptr);\n@@ -306,1 +306,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, EXT_EVENT_VIRTUAL_THREAD_MOUNT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, EXT_EVENT_VIRTUAL_THREAD_MOUNT, nullptr);\n@@ -309,1 +309,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, EXT_EVENT_VIRTUAL_THREAD_UNMOUNT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, EXT_EVENT_VIRTUAL_THREAD_UNMOUNT, nullptr);\n@@ -312,1 +312,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/BreakpointInYieldTest\/libBreakpointInYieldTest.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,3 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jthread exp_thread = NULL;\n-static jrawMonitorID event_mon = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jthread exp_thread = nullptr;\n+static jrawMonitorID event_mon = nullptr;\n@@ -43,2 +43,2 @@\n-  char* mname = NULL;\n-  char* msign = NULL;\n+  char* mname = nullptr;\n+  char* msign = nullptr;\n@@ -47,1 +47,1 @@\n-  err = jvmti->GetMethodName(method, &mname, &msign, NULL);\n+  err = jvmti->GetMethodName(method, &mname, &msign, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ContFramePopTest\/libContFramePopTest.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,3 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jthread exp_thread = NULL;\n-static jrawMonitorID event_mon = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jthread exp_thread = nullptr;\n+static jrawMonitorID event_mon = nullptr;\n@@ -45,2 +45,2 @@\n-  char* mname = NULL;\n-  char* msign = NULL;\n+  char* mname = nullptr;\n+  char* msign = nullptr;\n@@ -49,1 +49,1 @@\n-  err = jvmti->GetMethodName(method, &mname, &msign, NULL);\n+  err = jvmti->GetMethodName(method, &mname, &msign, nullptr);\n@@ -184,1 +184,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, nullptr);\n@@ -187,1 +187,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FRAME_POP, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FRAME_POP, nullptr);\n@@ -239,2 +239,2 @@\n-  jmethodID* methods = NULL;\n-  jmethodID method = NULL;\n+  jmethodID* methods = nullptr;\n+  jmethodID method = nullptr;\n@@ -262,1 +262,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -270,1 +270,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ContStackDepthTest\/libContStackDepthTest.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,3 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jthread exp_thread = NULL;\n-static jrawMonitorID event_mon = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jthread exp_thread = nullptr;\n+static jrawMonitorID event_mon = nullptr;\n@@ -42,2 +42,2 @@\n-  char* mname = NULL;\n-  char* msign = NULL;\n+  char* mname = nullptr;\n+  char* msign = nullptr;\n@@ -46,1 +46,1 @@\n-  err = jvmti->GetMethodName(method, &mname, &msign, NULL);\n+  err = jvmti->GetMethodName(method, &mname, &msign, nullptr);\n@@ -153,2 +153,2 @@\n-  jmethodID* methods = NULL;\n-  jmethodID method = NULL;\n+  jmethodID* methods = nullptr;\n+  jmethodID method = nullptr;\n@@ -175,1 +175,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -183,1 +183,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ContYieldBreakPointTest\/libContYieldBreakPointTest.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,3 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jthread exp_thread = NULL;\n-static jrawMonitorID event_mon = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jthread exp_thread = nullptr;\n+static jrawMonitorID event_mon = nullptr;\n@@ -43,2 +43,2 @@\n-  char* mname = NULL;\n-  char* msign = NULL;\n+  char* mname = nullptr;\n+  char* msign = nullptr;\n@@ -49,1 +49,1 @@\n-  err = jvmti->GetMethodName(method, &mname, &msign, NULL);\n+  err = jvmti->GetMethodName(method, &mname, &msign, nullptr);\n@@ -81,1 +81,1 @@\n-      jmethodID frame_method = NULL;\n+      jmethodID frame_method = nullptr;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ContinuationTest\/libContinuationTest.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- *      -Djdk.virtualThreadScheduler.parallelism=1\n+ *      -Djdk.virtualThreadScheduler.maxPoolSize=1\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/FollowReferences\/VThreadStackRefTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,3 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jmethodID mid_B = NULL;\n-static jrawMonitorID monitor = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jmethodID mid_B = nullptr;\n+static jrawMonitorID monitor = nullptr;\n@@ -58,1 +58,1 @@\n-    jobject ret_obj = NULL;\n+    jobject ret_obj = nullptr;\n@@ -82,1 +82,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -127,1 +127,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -131,1 +131,1 @@\n-  if (mid_B == NULL) {\n+  if (mid_B == nullptr) {\n@@ -137,1 +137,1 @@\n-  set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ForceEarlyReturnTest\/libForceEarlyReturnTest.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -63,1 +63,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -91,2 +91,2 @@\n-    char* name = NULL;\n-    char* sign = NULL;\n+    char* name = nullptr;\n+    char* sign = nullptr;\n@@ -94,1 +94,1 @@\n-    err = jvmti->GetMethodName(method, &name, &sign, NULL);\n+    err = jvmti->GetMethodName(method, &name, &sign, nullptr);\n@@ -110,2 +110,2 @@\n-  jobject msg = NULL;\n-  jobject tt = NULL;\n+  jobject msg = nullptr;\n+  jobject tt = nullptr;\n@@ -118,1 +118,1 @@\n-  LOG(\"test_GetLocal: mounted: %d depth: %d fcount: %d\\n\", cthread != NULL, depth, frame_count);\n+  LOG(\"test_GetLocal: mounted: %d depth: %d fcount: %d\\n\", cthread != nullptr, depth, frame_count);\n@@ -129,1 +129,1 @@\n-  if (cthread != NULL) {\n+  if (cthread != nullptr) {\n@@ -168,2 +168,2 @@\n-  \/\/ #5: Test JVMTI GetLocalObject function with NULL value_ptr\n-  err = jvmti->GetLocalObject(vthread, depth, SlotString, NULL);\n+  \/\/ #5: Test JVMTI GetLocalObject function with nullptr value_ptr\n+  err = jvmti->GetLocalObject(vthread, depth, SlotString, nullptr);\n@@ -171,2 +171,2 @@\n-    LOG(\"JVMTI GetLocalObject with NULL value_ptr returned error: %d\\n\", err);\n-    fatal(jni, \"JVMTI GetLocalObject with NULL value_ptr failed to return JVMTI_ERROR_NULL_POINTER\");\n+    LOG(\"JVMTI GetLocalObject with null value_ptr returned error: %d\\n\", err);\n+    fatal(jni, \"JVMTI GetLocalObject with null value_ptr failed to return JVMTI_ERROR_NULL_POINTER\");\n@@ -179,1 +179,1 @@\n-  const char* str = jni->GetStringUTFChars((jstring)msg, NULL);\n+  const char* str = jni->GetStringUTFChars((jstring)msg, nullptr);\n@@ -192,1 +192,1 @@\n-  if (exp_values->tt != NULL && !jni->IsSameObject(tt, exp_values->tt)) {\n+  if (exp_values->tt != nullptr && !jni->IsSameObject(tt, exp_values->tt)) {\n@@ -242,1 +242,1 @@\n-  LOG(\"test_SetLocal: mounted: %d depth: %d fcount: %d\\n\", cthread != NULL, depth, frame_count);\n+  LOG(\"test_SetLocal: mounted: %d depth: %d fcount: %d\\n\", cthread != nullptr, depth, frame_count);\n@@ -260,1 +260,1 @@\n-  if (depth > 0 || cthread == NULL) {\n+  if (depth > 0 || cthread == nullptr) {\n@@ -274,1 +274,1 @@\n-  if (depth > 0 || cthread == NULL) {\n+  if (depth > 0 || cthread == nullptr) {\n@@ -281,1 +281,1 @@\n-  else if (cthread != NULL && err != JVMTI_ERROR_INVALID_SLOT && err != JVMTI_ERROR_TYPE_MISMATCH) {\n+  else if (cthread != nullptr && err != JVMTI_ERROR_INVALID_SLOT && err != JVMTI_ERROR_TYPE_MISMATCH) {\n@@ -289,1 +289,1 @@\n-  if (depth > 0 || cthread == NULL) {\n+  if (depth > 0 || cthread == nullptr) {\n@@ -317,2 +317,2 @@\n-  Values values0 = { NULL, NULL, 1, 2L, (jfloat)3.2F, (jdouble)4.500000047683716 };\n-  Values values1 = { NULL, NULL, 2, 3L, (jfloat)4.2F, (jdouble)5.500000047683716 };\n+  Values values0 = { nullptr, nullptr, 1, 2L, (jfloat)3.2F, (jdouble)4.500000047683716 };\n+  Values values1 = { nullptr, nullptr, 2, 3L, (jfloat)4.2F, (jdouble)5.500000047683716 };\n@@ -332,1 +332,1 @@\n-  if (depth > 0 || cthread == NULL) {\n+  if (depth > 0 || cthread == nullptr) {\n@@ -371,2 +371,2 @@\n-    \/\/ so we can also test with NULL in place of vthread.\n-    test_GetSetLocal(jvmti, jni, NULL, depth, frame_count, true \/* at_event *\/);\n+    \/\/ so we can also test with nullptr in place of vthread.\n+    test_GetSetLocal(jvmti, jni, nullptr, depth, frame_count, true \/* at_event *\/);\n@@ -442,1 +442,1 @@\n-    jmethodID method = NULL;\n+    jmethodID method = nullptr;\n@@ -463,1 +463,1 @@\n-    bool case_2 = !seen_unmounted && depth >= 0 && cthread == NULL;\n+    bool case_2 = !seen_unmounted && depth >= 0 && cthread == nullptr;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetSetLocalTest\/libGetSetLocalTest.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,1 @@\n-            extraVMArgs.add(\"-Djdk.virtualThreadScheduler.parallelism=1\");\n+            extraVMArgs.add(\"-Djdk.virtualThreadScheduler.maxPoolSize=1\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/HeapDump\/VThreadInHeapDump.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/InterruptThreadTest\/libInterruptThreadTest.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,3 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jthread exp_thread = NULL;\n-static jrawMonitorID event_mon = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jthread exp_thread = nullptr;\n+static jrawMonitorID event_mon = nullptr;\n@@ -44,1 +44,1 @@\n-static jmethodID *test_methods = NULL;\n+static jmethodID *test_methods = nullptr;\n@@ -46,1 +46,1 @@\n-jclass test_class = NULL;\n+jclass test_class = nullptr;\n@@ -82,1 +82,1 @@\n-  jmethodID method = NULL;\n+  jmethodID method = nullptr;\n@@ -96,1 +96,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -134,1 +134,1 @@\n-  jthread vthread = NULL;\n+  jthread vthread = nullptr;\n@@ -164,1 +164,1 @@\n-    jmethodID method = NULL;\n+    jmethodID method = nullptr;\n@@ -166,2 +166,2 @@\n-    char* mname1 = NULL;\n-    char* cname1 = NULL;\n+    char* mname1 = nullptr;\n+    char* cname1 = nullptr;\n@@ -255,1 +255,1 @@\n-  set_event_notification_mode(jvmti, jni, JVMTI_DISABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  set_event_notification_mode(jvmti, jni, JVMTI_DISABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n@@ -282,1 +282,1 @@\n-  jthread cthread = NULL;\n+  jthread cthread = nullptr;\n@@ -350,1 +350,1 @@\n-  if (strstr(mname, \"brkpt\") != NULL) { \/\/ event IS in the \"brkpt\" method\n+  if (strstr(mname, \"brkpt\") != nullptr) { \/\/ event IS in the \"brkpt\" method\n@@ -436,1 +436,1 @@\n-  jmethodID method = NULL;\n+  jmethodID method = nullptr;\n@@ -438,2 +438,2 @@\n-  char* mname = NULL;\n-  char* cname = NULL;\n+  char* mname = nullptr;\n+  char* cname = nullptr;\n@@ -443,2 +443,2 @@\n-  JNIEnv* jni = NULL;\n-  jthread thread = NULL;\n+  JNIEnv* jni = nullptr;\n+  jthread thread = nullptr;\n@@ -481,1 +481,1 @@\n-  jmethodID method = NULL;\n+  jmethodID method = nullptr;\n@@ -483,2 +483,2 @@\n-  char* mname = NULL;\n-  char* cname = NULL;\n+  char* mname = nullptr;\n+  char* cname = nullptr;\n@@ -488,2 +488,2 @@\n-  JNIEnv* jni = NULL;\n-  jthread thread = NULL;\n+  JNIEnv* jni = nullptr;\n+  jthread thread = nullptr;\n@@ -565,3 +565,3 @@\n-  set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, NULL);\n-  set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL);\n-  set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, NULL);\n+  set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, nullptr);\n+  set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, nullptr);\n+  set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, nullptr);\n@@ -588,1 +588,1 @@\n-  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/MethodExitTest\/libMethodExitTest.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -52,4 +52,4 @@\n-    char* name0 = NULL;\n-    char* name1 = NULL;\n-    char* sign0 = NULL;\n-    char* sign1 = NULL;\n+    char* name0 = nullptr;\n+    char* name1 = nullptr;\n+    char* sign0 = nullptr;\n+    char* sign1 = nullptr;\n@@ -57,1 +57,1 @@\n-    err = jvmti->GetMethodName(method0, &name0, &sign0, NULL);\n+    err = jvmti->GetMethodName(method0, &name0, &sign0, nullptr);\n@@ -61,1 +61,1 @@\n-      err = jvmti->GetMethodName(method1, &name1, &sign1, NULL);\n+      err = jvmti->GetMethodName(method1, &name1, &sign1, nullptr);\n@@ -83,1 +83,1 @@\n-  err = jvmti->GetThreadInfo(NULL, &inf0);\n+  err = jvmti->GetThreadInfo(nullptr, &inf0);\n@@ -89,1 +89,1 @@\n-  const char* name = (inf0.name == NULL) ? \"<Unnamed thread>\" : inf0.name;\n+  const char* name = (inf0.name == nullptr) ? \"<Unnamed thread>\" : inf0.name;\n@@ -124,1 +124,1 @@\n-  err = jvmti->GetThreadState(NULL, &state0);\n+  err = jvmti->GetThreadState(nullptr, &state0);\n@@ -148,1 +148,1 @@\n-  err = jvmti->GetFrameCount(NULL, &count1);\n+  err = jvmti->GetFrameCount(nullptr, &count1);\n@@ -166,8 +166,8 @@\n-  jmethodID method0 = NULL;\n-  jmethodID method1 = NULL;\n-  char* name0 = NULL;\n-  char* name1 = NULL;\n-  char* sign0 = NULL;\n-  char* sign1 = NULL;\n-\n-  err = jvmti->GetFrameLocation(NULL, DEPTH, &method0, &loc0);\n+  jmethodID method0 = nullptr;\n+  jmethodID method1 = nullptr;\n+  char* name0 = nullptr;\n+  char* name1 = nullptr;\n+  char* sign0 = nullptr;\n+  char* sign1 = nullptr;\n+\n+  err = jvmti->GetFrameLocation(nullptr, DEPTH, &method0, &loc0);\n@@ -179,1 +179,1 @@\n-  err = jvmti->GetMethodName(method0, &name0, &sign0, NULL);\n+  err = jvmti->GetMethodName(method0, &name0, &sign0, nullptr);\n@@ -183,1 +183,1 @@\n-    err = jvmti->GetMethodName(method1, &name1, &sign1, NULL);\n+    err = jvmti->GetMethodName(method1, &name1, &sign1, nullptr);\n@@ -210,1 +210,1 @@\n-  err = jvmti->GetStackTrace(NULL, 0, MAX_FRAME_CNT, frames0, &count0);\n+  err = jvmti->GetStackTrace(nullptr, 0, MAX_FRAME_CNT, frames0, &count0);\n@@ -229,2 +229,2 @@\n-  jobject* monitors0 = NULL;\n-  jobject* monitors1 = NULL;\n+  jobject* monitors0 = nullptr;\n+  jobject* monitors1 = nullptr;\n@@ -266,2 +266,2 @@\n-  jvmtiMonitorStackDepthInfo* inf0 = NULL;\n-  jvmtiMonitorStackDepthInfo* inf1 = NULL;\n+  jvmtiMonitorStackDepthInfo* inf0 = nullptr;\n+  jvmtiMonitorStackDepthInfo* inf1 = nullptr;\n@@ -269,1 +269,1 @@\n-  err = jvmti->GetOwnedMonitorStackDepthInfo(NULL, &count0, &inf0);\n+  err = jvmti->GetOwnedMonitorStackDepthInfo(nullptr, &count0, &inf0);\n@@ -305,2 +305,2 @@\n-  jobject monitor0 = NULL;\n-  jobject monitor1 = NULL;\n+  jobject monitor0 = nullptr;\n+  jobject monitor1 = nullptr;\n@@ -308,1 +308,1 @@\n-  err = jvmti->GetCurrentContendedMonitor(NULL, &monitor0);\n+  err = jvmti->GetCurrentContendedMonitor(nullptr, &monitor0);\n@@ -324,1 +324,1 @@\n- * Execute JVMTI functions with NULL jthread and check the result is correct.\n+ * Execute JVMTI functions with nullptr jthread and check the result is correct.\n@@ -329,1 +329,1 @@\n-  jthread cur_thr = NULL;\n+  jthread cur_thr = nullptr;\n@@ -334,1 +334,1 @@\n-  LOG(\"Testing JMTI functions accepting NULL jthread as current thread\\n\");\n+  LOG(\"Testing JMTI functions accepting null jthread as current thread\\n\");\n@@ -398,1 +398,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, EXT_EVENT_VIRTUAL_THREAD_MOUNT, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, EXT_EVENT_VIRTUAL_THREAD_MOUNT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/NullAsCurrentThreadTest\/libNullAsCurrentThreadTest.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/PinnedTaskTest\/libPinnedTaskTest.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -117,1 +117,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -123,1 +123,1 @@\n-  if (mid_B == NULL) {\n+  if (mid_B == nullptr) {\n@@ -129,1 +129,1 @@\n-  set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/PopFrameTest\/libPopFrameTest.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/RawMonitorTest\/libRawMonitorTest.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -53,1 +53,1 @@\n-  check_jvmti_status(jni, jvmti->SuspendAllVirtualThreads(0, NULL), \"Error in SuspendAllVirtualThreads\");\n+  check_jvmti_status(jni, jvmti->SuspendAllVirtualThreads(0, nullptr), \"Error in SuspendAllVirtualThreads\");\n@@ -58,1 +58,1 @@\n-  check_jvmti_status(jni, jvmti->ResumeAllVirtualThreads(0, NULL), \"Error in ResumeAllVirtualThreads\");\n+  check_jvmti_status(jni, jvmti->ResumeAllVirtualThreads(0, nullptr), \"Error in ResumeAllVirtualThreads\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SelfSuspendDisablerTest\/libSelfSuspendDisablerTest.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,4 +31,4 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jmethodID mid_B = NULL;\n-static jobject exception_obj = NULL;\n-static jrawMonitorID monitor = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jmethodID mid_B = nullptr;\n+static jobject exception_obj = nullptr;\n+static jrawMonitorID monitor = nullptr;\n@@ -76,1 +76,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -121,1 +121,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -125,1 +125,1 @@\n-  if (exception_obj == NULL) {\n+  if (exception_obj == nullptr) {\n@@ -129,1 +129,1 @@\n-  if (mid_B == NULL) {\n+  if (mid_B == nullptr) {\n@@ -135,1 +135,1 @@\n-  set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/StopThreadTest\/libStopThreadTest.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- *      -Djava.util.concurrent.ForkJoinPool.common.parallelism=1\n+ *      -Djdk.virtualThreadScheduler.maxPoolSize=1\n@@ -44,1 +44,0 @@\n- *      -Djava.util.concurrent.ForkJoinPool.common.parallelism=1\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SuspendResume1\/SuspendResume1.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jrawMonitorID agent_event_lock = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jrawMonitorID agent_event_lock = nullptr;\n@@ -51,1 +51,1 @@\n-  jvmtiStackInfo* stack_info_arr = NULL;\n+  jvmtiStackInfo* stack_info_arr = nullptr;\n@@ -73,3 +73,3 @@\n-  jmethodID method = NULL;\n-  char* name = NULL;\n-  char* sign = NULL;\n+  jmethodID method = nullptr;\n+  char* name = nullptr;\n+  char* sign = nullptr;\n@@ -87,1 +87,1 @@\n-  err = jvmti->GetMethodName(method, &name, &sign, NULL);\n+  err = jvmti->GetMethodName(method, &name, &sign, nullptr);\n@@ -96,1 +96,1 @@\n-  jthread* tested_cthreads = NULL;\n+  jthread* tested_cthreads = nullptr;\n@@ -316,1 +316,1 @@\n-  jthread* tested_cthreads = NULL;\n+  jthread* tested_cthreads = nullptr;\n@@ -398,1 +398,1 @@\n-                                        JVMTI_EVENT_VIRTUAL_THREAD_START, NULL);\n+                                        JVMTI_EVENT_VIRTUAL_THREAD_START, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SuspendResume1\/libSuspendResume1.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- *      -Djava.util.concurrent.ForkJoinPool.common.parallelism=1\n+ *      -Djdk.virtualThreadScheduler.maxPoolSize=1\n@@ -43,1 +43,0 @@\n- *      -Djava.util.concurrent.ForkJoinPool.common.parallelism=1\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SuspendResume2\/SuspendResume2.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,3 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jrawMonitorID agent_event_lock = NULL;\n-static volatile jthread agent_thread = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jrawMonitorID agent_event_lock = nullptr;\n+static volatile jthread agent_thread = nullptr;\n@@ -47,1 +47,1 @@\n-  jthread* tested_cthreads = NULL;\n+  jthread* tested_cthreads = nullptr;\n@@ -109,1 +109,1 @@\n-  jthread exclude_list[EXCLUDE_CNT] = { NULL, NULL };\n+  jthread exclude_list[EXCLUDE_CNT] = { nullptr, nullptr };\n@@ -141,1 +141,1 @@\n-  jthread exclude_list[EXCLUDE_CNT] = { NULL, NULL };\n+  jthread exclude_list[EXCLUDE_CNT] = { nullptr, nullptr };\n@@ -227,1 +227,1 @@\n-  jthread* tested_cthreads = NULL;\n+  jthread* tested_cthreads = nullptr;\n@@ -313,1 +313,1 @@\n-                                        JVMTI_EVENT_VIRTUAL_THREAD_START, NULL);\n+                                        JVMTI_EVENT_VIRTUAL_THREAD_START, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SuspendResume2\/libSuspendResume2.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- *      -Djava.util.concurrent.ForkJoinPool.common.parallelism=1\n+ *      -Djdk.virtualThreadScheduler.maxPoolSize=1\n@@ -43,1 +43,0 @@\n- *      -Djava.util.concurrent.ForkJoinPool.common.parallelism=1\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SuspendResumeAll\/SuspendResumeAll.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,3 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jrawMonitorID agent_event_lock = NULL;\n-static volatile jthread agent_thread = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jrawMonitorID agent_event_lock = nullptr;\n+static volatile jthread agent_thread = nullptr;\n@@ -44,1 +44,1 @@\n-static jmethodID *test_methods = NULL;\n+static jmethodID *test_methods = nullptr;\n@@ -46,1 +46,1 @@\n-jclass test_class = NULL;\n+jclass test_class = nullptr;\n@@ -52,1 +52,1 @@\n-  jmethodID method = NULL;\n+  jmethodID method = nullptr;\n@@ -66,1 +66,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -112,1 +112,1 @@\n-  jthread* tested_cthreads = NULL;\n+  jthread* tested_cthreads = nullptr;\n@@ -174,1 +174,1 @@\n-  jthread exclude_list[EXCLUDE_CNT] = { NULL, NULL };\n+  jthread exclude_list[EXCLUDE_CNT] = { nullptr, nullptr };\n@@ -207,1 +207,1 @@\n-  jthread exclude_list[EXCLUDE_CNT] = { NULL, NULL };\n+  jthread exclude_list[EXCLUDE_CNT] = { nullptr, nullptr };\n@@ -267,1 +267,1 @@\n-  jthread* tested_cthreads = NULL;\n+  jthread* tested_cthreads = nullptr;\n@@ -371,1 +371,1 @@\n-                                        JVMTI_EVENT_VIRTUAL_THREAD_START, NULL);\n+                                        JVMTI_EVENT_VIRTUAL_THREAD_START, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SuspendResumeAll\/libSuspendResumeAll.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  jvmtiStackInfo* info = NULL;\n+  jvmtiStackInfo* info = nullptr;\n@@ -48,1 +48,1 @@\n-  jvmtiStackInfo* info = NULL;\n+  jvmtiStackInfo* info = nullptr;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ThreadListStackTracesTest\/libThreadListStackTracesTest.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-  jvmtiStackInfo* stackInfo = NULL;\n+  jvmtiStackInfo* stackInfo = nullptr;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ThreadStateTest\/libThreadStateTest.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jrawMonitorID agent_lock = NULL;\n+static jrawMonitorID agent_lock = nullptr;\n@@ -42,2 +42,2 @@\n-  jthread cthread = NULL;\n-  jthread vthread = NULL;\n+  jthread cthread = nullptr;\n+  jthread vthread = nullptr;\n@@ -55,1 +55,1 @@\n-  char* vtname = vthread == NULL ? NULL : get_thread_name(jvmti, jni, vthread);\n+  char* vtname = vthread == nullptr ? nullptr : get_thread_name(jvmti, jni, vthread);\n@@ -161,1 +161,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, nullptr);\n@@ -166,1 +166,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_END, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_END, nullptr);\n@@ -171,1 +171,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, nullptr);\n@@ -176,1 +176,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/ToggleNotifyJvmtiTest\/libToggleNotifyJvmtiTest.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jrawMonitorID agent_monitor = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jrawMonitorID agent_monitor = nullptr;\n@@ -43,2 +43,2 @@\n-static volatile jclass test_class_0 = NULL;\n-static volatile jclass test_class_2 = NULL;\n+static volatile jclass test_class_0 = nullptr;\n+static volatile jclass test_class_2 = nullptr;\n@@ -63,1 +63,1 @@\n-  if (test_class_0 == NULL) {\n+  if (test_class_0 == nullptr) {\n@@ -71,1 +71,1 @@\n-  if (test_class_2 == NULL) {\n+  if (test_class_2 == nullptr) {\n@@ -101,1 +101,1 @@\n-    print_stack_trace(jvmti, jni, NULL);\n+    print_stack_trace(jvmti, jni, nullptr);\n@@ -126,1 +126,1 @@\n-  jobject *owned_monitors = NULL;\n+  jobject *owned_monitors = nullptr;\n@@ -185,1 +185,1 @@\n-                          vthread, vtname, JNI_TRUE, monitor, NULL);\n+                          vthread, vtname, JNI_TRUE, monitor, nullptr);\n@@ -187,1 +187,1 @@\n-                          cthread,  ctname, JNI_FALSE, NULL, NULL);\n+                          cthread,  ctname, JNI_FALSE, nullptr, nullptr);\n@@ -207,1 +207,1 @@\n-                          vthread, vtname, JNI_TRUE, NULL, NULL);\n+                          vthread, vtname, JNI_TRUE, nullptr, nullptr);\n@@ -209,1 +209,1 @@\n-                          cthread, ctname, JNI_FALSE, NULL, NULL);\n+                          cthread, ctname, JNI_FALSE, nullptr, nullptr);\n@@ -229,1 +229,1 @@\n-  if (k == NULL) {\n+  if (k == nullptr) {\n@@ -243,1 +243,1 @@\n-  if (res != JNI_OK || jni == NULL) {\n+  if (res != JNI_OK || jni == nullptr) {\n@@ -251,1 +251,1 @@\n-  if (test_class_0 == NULL || test_class_2 == NULL) {\n+  if (test_class_0 == nullptr || test_class_2 == nullptr) {\n@@ -267,1 +267,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -318,1 +318,1 @@\n-                                        JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL);\n+                                        JVMTI_EVENT_MONITOR_CONTENDED_ENTER, nullptr);\n@@ -325,1 +325,1 @@\n-                                        JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL);\n+                                        JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadMonitorTest\/libVThreadMonitorTest.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jrawMonitorID event_mon = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jrawMonitorID event_mon = nullptr;\n@@ -40,1 +40,1 @@\n-static jmethodID *test_methods = NULL;\n+static jmethodID *test_methods = nullptr;\n@@ -42,1 +42,1 @@\n-jclass test_class = NULL;\n+jclass test_class = nullptr;\n@@ -44,1 +44,1 @@\n-static jmethodID *url_methods = NULL;\n+static jmethodID *url_methods = nullptr;\n@@ -46,1 +46,1 @@\n-jclass url_class = NULL;\n+jclass url_class = nullptr;\n@@ -53,2 +53,2 @@\n-  char* mname = NULL;\n-  char* msign = NULL;\n+  char* mname = nullptr;\n+  char* msign = nullptr;\n@@ -57,1 +57,1 @@\n-  err = jvmti->GetMethodName(method, &mname, &msign, NULL);\n+  err = jvmti->GetMethodName(method, &mname, &msign, nullptr);\n@@ -87,1 +87,1 @@\n-  jmethodID method = NULL;\n+  jmethodID method = nullptr;\n@@ -101,1 +101,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -240,1 +240,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, nullptr);\n@@ -271,1 +271,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadNotifyFramePopTest\/libVThreadNotifyFramePopTest.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,2 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jrawMonitorID events_monitor = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jrawMonitorID events_monitor = nullptr;\n@@ -49,1 +49,1 @@\n-  Tinfo* inf = NULL;\n+  Tinfo* inf = nullptr;\n@@ -55,1 +55,1 @@\n-    if (inf->tname == NULL) {\n+    if (inf->tname == nullptr) {\n@@ -81,2 +81,2 @@\n-    char* name = NULL;\n-    char* sign = NULL;\n+    char* name = nullptr;\n+    char* sign = nullptr;\n@@ -84,1 +84,1 @@\n-    err = jvmti->GetMethodName(method, &name, &sign, NULL);\n+    err = jvmti->GetMethodName(method, &name, &sign, nullptr);\n@@ -105,1 +105,1 @@\n-    if (inf->tname == NULL && strcmp(event_name, \"VirtualThreadEnd\") != 0) {\n+    if (inf->tname == nullptr && strcmp(event_name, \"VirtualThreadEnd\") != 0) {\n@@ -120,1 +120,1 @@\n-  jobject thread_vthread = NULL;\n+  jobject thread_vthread = nullptr;\n@@ -125,3 +125,3 @@\n-  \/\/ #1: Test JVMTI GetVirtualThread extension function NULL thread (current)\n-  err = GetVirtualThread(jvmti, jni, NULL, &thread_vthread);\n-  check_jvmti_status(jni, err, \"event handler: error in JVMTI GetVirtualThread with NULL thread (current)\");\n+  \/\/ #1: Test JVMTI GetVirtualThread extension function nullptr thread (current)\n+  err = GetVirtualThread(jvmti, jni, nullptr, &thread_vthread);\n+  check_jvmti_status(jni, err, \"event handler: error in JVMTI GetVirtualThread with null thread (current)\");\n@@ -129,2 +129,2 @@\n-  if (thread_vthread == NULL) {\n-    fatal(jni, \"event handler: JVMTI GetVirtualThread with NULL thread (current) failed to return non-NULL vthread\");\n+  if (thread_vthread == nullptr) {\n+    fatal(jni, \"event handler: JVMTI GetVirtualThread with nullptr thread (current) failed to return non-null vthread\");\n@@ -132,1 +132,1 @@\n-  LOG(\"JVMTI GetVirtualThread with NULL thread (current) returned non-NULL vthread as expected\\n\");\n+  LOG(\"JVMTI GetVirtualThread with nullptr thread (current) returned non-null vthread as expected\\n\");\n@@ -144,2 +144,2 @@\n-  if (thread_vthread == NULL) {\n-    fatal(jni, \"event handler: JVMTI GetVirtualThread with good thread failed to return non-NULL vthread\");\n+  if (thread_vthread == nullptr) {\n+    fatal(jni, \"event handler: JVMTI GetVirtualThread with good thread failed to return non-null vthread\");\n@@ -147,1 +147,1 @@\n-  LOG(\"JVMTI GetVirtualThread with good thread returned non-NULL vthread as expected\\n\");\n+  LOG(\"JVMTI GetVirtualThread with good thread returned non-null vthread as expected\\n\");\n@@ -152,1 +152,1 @@\n-  jthread vthread_thread = NULL;\n+  jthread vthread_thread = nullptr;\n@@ -157,2 +157,2 @@\n-  \/\/ #1: Test JVMTI GetCarrierThread extension function with NULL vthread\n-  err = GetCarrierThread(jvmti, jni, NULL, &vthread_thread);\n+  \/\/ #1: Test JVMTI GetCarrierThread extension function with nullptr vthread\n+  err = GetCarrierThread(jvmti, jni, nullptr, &vthread_thread);\n@@ -171,2 +171,2 @@\n-  if (vthread_thread == NULL) {\n-    fatal(jni, \"event handler: JVMTI GetCarrierThread with good vthread failed to return non-NULL carrier thread\");\n+  if (vthread_thread == nullptr) {\n+    fatal(jni, \"event handler: JVMTI GetCarrierThread with good vthread failed to return non-null carrier thread\");\n@@ -174,1 +174,1 @@\n-  LOG(\"JVMTI GetCarrierThread with good vthread returned non-NULL carrier thread as expected\\n\");\n+  LOG(\"JVMTI GetCarrierThread with good vthread returned non-null carrier thread as expected\\n\");\n@@ -183,1 +183,1 @@\n-  jclass* classes = NULL;\n+  jclass* classes = nullptr;\n@@ -210,2 +210,2 @@\n-    char* sign = NULL;\n-    err = jvmti->GetClassSignature(classes[idx], &sign, NULL);\n+    char* sign = nullptr;\n+    err = jvmti->GetClassSignature(classes[idx], &sign, nullptr);\n@@ -214,1 +214,1 @@\n-    if (strstr(sign, \"VThreadTest\") != NULL) {\n+    if (strstr(sign, \"VThreadTest\") != nullptr) {\n@@ -231,2 +231,2 @@\n-  \/\/ #1: Test JVMTI GetFrameCount function with NULL count_ptr pointer\n-  err = jvmti->GetFrameCount(vthread, NULL);\n+  \/\/ #1: Test JVMTI GetFrameCount function with nullptr count_ptr pointer\n+  err = jvmti->GetFrameCount(vthread, nullptr);\n@@ -234,2 +234,2 @@\n-    LOG(\"JVMTI GetFrameCount with NULL count_ptr returned error: %d\\n\", err);\n-    fatal(jni, \"event handler: JVMTI GetFrameCount with NULL count_ptr pointer failed to return JVMTI_ERROR_NULL_POINTER\");\n+    LOG(\"JVMTI GetFrameCount with null count_ptr returned error: %d\\n\", err);\n+    fatal(jni, \"event handler: JVMTI GetFrameCount with null count_ptr pointer failed to return JVMTI_ERROR_NULL_POINTER\");\n@@ -252,1 +252,1 @@\n-  jmethodID method = NULL;\n+  jmethodID method = nullptr;\n@@ -263,2 +263,2 @@\n-  \/\/ #2: Test JVMTI GetFrameLocation function with NULL method_ptr\n-  err = jvmti->GetFrameLocation(vthread, 0, NULL, &location);\n+  \/\/ #2: Test JVMTI GetFrameLocation function with nullptr method_ptr\n+  err = jvmti->GetFrameLocation(vthread, 0, nullptr, &location);\n@@ -266,2 +266,2 @@\n-    LOG(\"JVMTI GetFrameLocation with NULL method_ptr returned error: %d\\n\", err);\n-    fatal(jni, \"event handler: JVMTI GetFrameLocation with NULL method_ptr failed to return JVMTI_ERROR_NULL_POINTER\");\n+    LOG(\"JVMTI GetFrameLocation with null method_ptr returned error: %d\\n\", err);\n+    fatal(jni, \"event handler: JVMTI GetFrameLocation with null method_ptr failed to return JVMTI_ERROR_NULL_POINTER\");\n@@ -270,2 +270,2 @@\n-  \/\/ #3: Test JVMTI GetFrameLocation function with NULL location_ptr\n-  err = jvmti->GetFrameLocation(vthread, 0, &method, NULL);\n+  \/\/ #3: Test JVMTI GetFrameLocation function with nullptr location_ptr\n+  err = jvmti->GetFrameLocation(vthread, 0, &method, nullptr);\n@@ -273,2 +273,2 @@\n-    LOG(\"JVMTI GetFrameCount with NULL location_ptr returned error: %d\\n\", err);\n-    fatal(jni, \"event handler: JVMTI GetFrameLocation with NULL location_ptr failed to return JVMTI_ERROR_NULL_POINTER\");\n+    LOG(\"JVMTI GetFrameCount with null location_ptr returned error: %d\\n\", err);\n+    fatal(jni, \"event handler: JVMTI GetFrameLocation with null location_ptr failed to return JVMTI_ERROR_NULL_POINTER\");\n@@ -307,1 +307,1 @@\n-  jmethodID method = NULL;\n+  jmethodID method = nullptr;\n@@ -331,2 +331,2 @@\n-  \/\/ #3: Test JVMTI GetStackTrace function with NULL frame_buffer pointer\n-  err = jvmti->GetStackTrace(vthread, 0, MAX_FRAME_COUNT, NULL, &count);\n+  \/\/ #3: Test JVMTI GetStackTrace function with nullptr frame_buffer pointer\n+  err = jvmti->GetStackTrace(vthread, 0, MAX_FRAME_COUNT, nullptr, &count);\n@@ -334,2 +334,2 @@\n-    LOG(\"JVMTI GetStackTrace with NULL frame_buffer pointer returned error: %d\\n\", err);\n-    fatal(jni, \"event handler: JVMTI GetStackTrace witt NULL frame_buffer pointer failed to return JVMTI_ERROR_NULL_POINTER\");\n+    LOG(\"JVMTI GetStackTrace with null frame_buffer pointer returned error: %d\\n\", err);\n+    fatal(jni, \"event handler: JVMTI GetStackTrace witt null frame_buffer pointer failed to return JVMTI_ERROR_NULL_POINTER\");\n@@ -338,2 +338,2 @@\n-  \/\/ #4: Test JVMTI GetStackTrace function with NULL count_ptr pointer\n-  err = jvmti->GetStackTrace(vthread, 0, MAX_FRAME_COUNT, frames, NULL);\n+  \/\/ #4: Test JVMTI GetStackTrace function with nullptr count_ptr pointer\n+  err = jvmti->GetStackTrace(vthread, 0, MAX_FRAME_COUNT, frames, nullptr);\n@@ -341,2 +341,2 @@\n-    LOG(\"JVMTI GetStackTrace with NULL count_ptr pointer returned error: %d\\n\", err);\n-    fatal(jni, \"event handler: JVMTI GetStackTrace witt NULL count_ptr pointer failed to return JVMTI_ERROR_NULL_POINTER\");\n+    LOG(\"JVMTI GetStackTrace with null count_ptr pointer returned error: %d\\n\", err);\n+    fatal(jni, \"event handler: JVMTI GetStackTrace witt null count_ptr pointer failed to return JVMTI_ERROR_NULL_POINTER\");\n@@ -367,2 +367,2 @@\n-  jmethodID method = NULL;\n-  jobject obj = NULL;\n+  jmethodID method = nullptr;\n+  jobject obj = nullptr;\n@@ -426,2 +426,2 @@\n-  \/\/ #5: Test JVMTI GetLocalObject function with NULL value_ptr\n-  err = jvmti->GetLocalObject(vthread, depth, SlotObj, NULL);\n+  \/\/ #5: Test JVMTI GetLocalObject function with null value_ptr\n+  err = jvmti->GetLocalObject(vthread, depth, SlotObj, nullptr);\n@@ -429,2 +429,2 @@\n-    LOG(\"JVMTI GetLocalObject with NULL method_ptr returned error: %d\\n\", err);\n-    fatal(jni, \"JVMTI GetLocalObject with NULL method_ptr failed to return JVMTI_ERROR_NULL_POINTER\");\n+    LOG(\"JVMTI GetLocalObject with null method_ptr returned error: %d\\n\", err);\n+    fatal(jni, \"JVMTI GetLocalObject with null method_ptr failed to return JVMTI_ERROR_NULL_POINTER\");\n@@ -437,1 +437,1 @@\n-  const char* str = jni->GetStringUTFChars((jstring)obj, NULL);\n+  const char* str = jni->GetStringUTFChars((jstring)obj, nullptr);\n@@ -503,1 +503,1 @@\n-    return; \/\/ skip further testing as GetVirtualThread can return NULL\n+    return; \/\/ skip further testing as GetVirtualThread can return nullptr\n@@ -535,2 +535,2 @@\n-  JNIEnv* jni = NULL;\n-  jthread thread = NULL;\n+  JNIEnv* jni = nullptr;\n+  jthread thread = nullptr;\n@@ -552,2 +552,2 @@\n-  JNIEnv* jni = NULL;\n-  jthread thread = NULL;\n+  JNIEnv* jni = nullptr;\n+  jthread thread = nullptr;\n@@ -611,1 +611,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, nullptr);\n@@ -617,1 +617,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_END, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_END, nullptr);\n@@ -623,1 +623,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, EXT_EVENT_VIRTUAL_THREAD_MOUNT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, EXT_EVENT_VIRTUAL_THREAD_MOUNT, nullptr);\n@@ -629,1 +629,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, EXT_EVENT_VIRTUAL_THREAD_UNMOUNT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, EXT_EVENT_VIRTUAL_THREAD_UNMOUNT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadTest\/libVThreadTest.cpp","additions":67,"deletions":67,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -71,1 +71,1 @@\n-  void* local_storage_data = NULL;\n+  void* local_storage_data = nullptr;\n@@ -101,1 +101,1 @@\n-  err = jvmti->RunAgentThread(vthread, agent_proc, (const void*)NULL, JVMTI_THREAD_NORM_PRIORITY);\n+  err = jvmti->RunAgentThread(vthread, agent_proc, nullptr, JVMTI_THREAD_NORM_PRIORITY);\n@@ -124,2 +124,2 @@\n-  JNIEnv* jni = NULL;\n-  jthread thread = NULL;\n+  JNIEnv* jni = nullptr;\n+  jthread thread = nullptr;\n@@ -178,1 +178,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, EXT_EVENT_VIRTUAL_THREAD_MOUNT, NULL);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, EXT_EVENT_VIRTUAL_THREAD_MOUNT, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadUnsupportedTest\/libVThreadUnsupportedTest.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-  err = jvmti->GetStackTrace(NULL, 0, MAX_COUNT, frameInfo, &count);\n+  err = jvmti->GetStackTrace(nullptr, 0, MAX_COUNT, frameInfo, &count);\n@@ -47,3 +47,3 @@\n-    jclass declaringClass = NULL;\n-    char *clasSignature = NULL;\n-    char *methodName = NULL;\n+    jclass declaringClass = nullptr;\n+    char *clasSignature = nullptr;\n+    char *methodName = nullptr;\n@@ -54,1 +54,1 @@\n-    err = jvmti->GetClassSignature(declaringClass, &clasSignature, NULL);\n+    err = jvmti->GetClassSignature(declaringClass, &clasSignature, nullptr);\n@@ -57,1 +57,1 @@\n-    err = jvmti->GetMethodName(frameInfo[idx].method, &methodName, NULL, NULL);\n+    err = jvmti->GetMethodName(frameInfo[idx].method, &methodName, nullptr, nullptr);\n@@ -69,1 +69,1 @@\n-  jobjectArray methodNames = jni->NewObjectArray(count - skipped, jni->FindClass(\"java\/lang\/String\"), NULL);\n+  jobjectArray methodNames = jni->NewObjectArray(count - skipped, jni->FindClass(\"java\/lang\/String\"), nullptr);\n@@ -73,1 +73,1 @@\n-  print_stack_trace(jvmti, jni, NULL);\n+  print_stack_trace(jvmti, jni, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VirtualStackTraceTest\/libVirtualStackTraceTest.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-static jrawMonitorID agent_event_lock = NULL;\n+static jrawMonitorID agent_event_lock = nullptr;\n@@ -43,1 +43,1 @@\n-  if (tname != NULL && strncmp(tname, TESTED_TNAME_START, TESTED_TNAME_START_LEN) == 0) {\n+  if (tname != nullptr && strncmp(tname, TESTED_TNAME_START, TESTED_TNAME_START_LEN) == 0) {\n@@ -62,1 +62,1 @@\n-  if (tname != NULL && strncmp(tname, TESTED_TNAME_START, TESTED_TNAME_START_LEN) == 0) {\n+  if (tname != nullptr && strncmp(tname, TESTED_TNAME_START, TESTED_TNAME_START_LEN) == 0) {\n@@ -104,1 +104,1 @@\n-  if (options != NULL && strcmp(options, \"can_support_virtual_threads\") == 0) {\n+  if (options != nullptr && strcmp(options, \"can_support_virtual_threads\") == 0) {\n@@ -113,1 +113,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VIRTUAL_THREAD_START, nullptr);\n@@ -119,1 +119,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, nullptr);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VirtualThreadStartTest\/libVirtualThreadStartTest.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- *     -Djava.util.concurrent.ForkJoinPool.common.parallelism=1\n+ *     -Djdk.virtualThreadScheduler.maxPoolSize=1\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/WaitNotifySuspendedVThreadTest\/WaitNotifySuspendedVThreadTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -59,1 +59,1 @@\n-  err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  err = jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n@@ -140,1 +140,1 @@\n-  jvmtiEnv * jvmti = NULL;\n+  jvmtiEnv * jvmti = nullptr;\n@@ -148,1 +148,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/WaitNotifySuspendedVThreadTest\/libWaitNotifySuspendedVThread.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-static jvmtiEnv* jvmti = NULL;\n+static jvmtiEnv* jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-      if (monitor_ptr != NULL) {\n+      if (monitor_ptr != nullptr) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/monitoring\/ThreadInfo\/GetLockOwnerName\/libGetLockOwnerName.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-static jvmtiEnv* jvmti = NULL;\n+static jvmtiEnv* jvmti = nullptr;\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jvmti\/libJvmtiUtils.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,2 @@\n-  const char * classNameChar = env->GetStringUTFChars(className, NULL);\n-  jbyte * arrayContent = env->GetByteArrayElements(bytecode, NULL);\n+  const char * classNameChar = env->GetStringUTFChars(className, nullptr);\n+  jbyte * arrayContent = env->GetByteArrayElements(bytecode, nullptr);\n@@ -54,1 +54,1 @@\n-    printf(\"ERROR: DefineClass call returned NULL by some reason. Classloading failed.\\n\");\n+    printf(\"ERROR: DefineClass call returned null by some reason. Classloading failed.\\n\");\n@@ -104,1 +104,1 @@\n-    jbyte * class_bytes = env->GetByteArrayElements(classBytes, NULL);\n+    jbyte * class_bytes = env->GetByteArrayElements(classBytes, nullptr);\n@@ -170,1 +170,1 @@\n-    env->SetObjectField(thisObject, objectToKeepField, NULL);\n+    env->SetObjectField(thisObject, objectToKeepField, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/libdefine.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-                        env->SetObjectArrayElement(listHolder, i, NULL);\n+                        env->SetObjectArrayElement(listHolder, i, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/nativeGC03\/libnativeGC03.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -49,1 +49,1 @@\n-    if (optionsString == NULL) {\n+    if (optionsString == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/aod\/VirtualMachine\/VirtualMachine07\/agent00.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -52,1 +52,1 @@\n-    if (optionsString == NULL) {\n+    if (optionsString == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/aod\/VirtualMachine\/VirtualMachine07\/agent01.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -54,1 +54,1 @@\n-    if (optionsString == NULL) {\n+    if (optionsString == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/aod\/VirtualMachine\/VirtualMachine07\/agent02.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/aod\/VirtualMachine\/VirtualMachine07\/agent03.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,2 @@\n-    JNIEnv* jni = NULL;\n-    Options* options = NULL;\n+    JNIEnv* jni = nullptr;\n+    Options* options = nullptr;\n@@ -52,1 +52,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -58,1 +58,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/aod\/VirtualMachine\/VirtualMachine09\/agent00.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -271,1 +271,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -298,1 +298,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -306,1 +306,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -321,1 +321,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -336,1 +336,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AddCapabilities\/addcaps001\/addcaps001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -290,1 +290,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -317,1 +317,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -325,1 +325,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -340,1 +340,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -359,1 +359,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AddCapabilities\/addcaps002\/addcaps002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,1 +139,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -166,1 +166,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -174,1 +174,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -189,1 +189,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -208,1 +208,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AddCapabilities\/addcaps003\/addcaps003.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,2 @@\n-    if (jvm == NULL) {\n-        NSK_COMPLAIN1(\"First parameter 'vm' in JVM_OnLoad() is NULL: 0x%p\\n\", (void*)jvm);\n+    if (jvm == nullptr) {\n+        NSK_COMPLAIN1(\"First parameter 'vm' in JVM_OnLoad() is null: 0x%p\\n\", (void*)jvm);\n@@ -75,2 +75,2 @@\n-    if (options == NULL) {\n-        NSK_COMPLAIN1(\"Second parameter 'options' in JVM_OnLoad() is NULL: 0x%p\\n\", (void*)options);\n+    if (options == nullptr) {\n+        NSK_COMPLAIN1(\"Second parameter 'options' in JVM_OnLoad() is null: 0x%p\\n\", (void*)options);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Agent_OnLoad\/agentonload001\/agentonload001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-    if (options == NULL) {\n-        printf(\"# ERROR: Second parameter 'options' in JVM_OnLoad() is NULL: 0x%p\\n\",\n+    if (options == nullptr) {\n+        printf(\"# ERROR: Second parameter 'options' in JVM_OnLoad() is null: 0x%p\\n\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Agent_OnLoad\/agentonload002\/agentonload002.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-    if (options == NULL) {\n-        printf(\"# ERROR: Second parameter 'options' in JVM_OnLoad() is NULL: 0x%p\\n\",\n+    if (options == nullptr) {\n+        printf(\"# ERROR: Second parameter 'options' in JVM_OnLoad() is null: 0x%p\\n\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Agent_OnLoad\/agentonload003\/agentonload003.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -62,1 +62,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -74,1 +74,1 @@\n-    void *prev = NULL;\n+    void *prev = nullptr;\n@@ -78,1 +78,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -84,1 +84,1 @@\n-    err = jvmti->Allocate((jlong)1, NULL);\n+    err = jvmti->Allocate((jlong)1, nullptr);\n@@ -138,1 +138,1 @@\n-    while (prev != NULL) {\n+    while (prev != nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Allocate\/alloc001\/alloc001.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -155,1 +155,1 @@\n-    if (name != NULL) {\n+    if (name != nullptr) {\n@@ -161,1 +161,1 @@\n-        NSK_DISPLAY1(\"%s: ClassFileLoadHook event received for class with NULL name\\n\", agentName);\n+        NSK_DISPLAY1(\"%s: ClassFileLoadHook event received for class with null name\\n\", agentName);\n@@ -180,2 +180,2 @@\n-    jvmtiEnv* jvmti = NULL;\n-    JNIEnv* jni = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n+    JNIEnv* jni = nullptr;\n@@ -184,1 +184,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -190,1 +190,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -194,1 +194,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach002\/attach002Agent00.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -92,2 +92,2 @@\n-    jvmtiEnv* jvmti = NULL;\n-    JNIEnv* jni = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n+    JNIEnv* jni = nullptr;\n@@ -96,1 +96,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -102,1 +102,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -106,1 +106,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach002a\/attach002aAgent00.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -110,2 +110,2 @@\n-    jvmtiEnv* jvmti = NULL;\n-    JNIEnv* jni = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n+    JNIEnv* jni = nullptr;\n@@ -114,1 +114,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -120,1 +120,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -124,1 +124,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach008\/attach008Agent00.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -132,1 +132,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -138,1 +138,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -142,1 +142,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach009\/attach009Agent00.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,2 @@\n-    JNIEnv* jni = NULL;\n-    Options* options = NULL;\n+    JNIEnv* jni = nullptr;\n+    Options* options = nullptr;\n@@ -58,1 +58,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -64,1 +64,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -68,1 +68,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach012\/attach012Agent00.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -91,2 +91,2 @@\n-    jvmtiEnv* jvmti = NULL;\n-    JNIEnv* jni = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n+    JNIEnv* jni = nullptr;\n@@ -95,1 +95,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -101,1 +101,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -105,1 +105,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach014\/attach014Agent00.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -84,2 +84,2 @@\n-    jvmtiEnv* jvmti = NULL;\n-    JNIEnv* jni = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n+    JNIEnv* jni = nullptr;\n@@ -88,1 +88,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -94,1 +94,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -98,1 +98,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach015\/attach015Agent00.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -84,2 +84,2 @@\n-    jvmtiEnv* jvmti = NULL;\n-    JNIEnv* jni = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n+    JNIEnv* jni = nullptr;\n@@ -88,1 +88,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -94,1 +94,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -98,1 +98,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach015\/attach015Agent01.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -119,1 +119,1 @@\n-    if (!NSK_VERIFY(thread != NULL))\n+    if (!NSK_VERIFY(thread != nullptr))\n@@ -122,1 +122,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->RunAgentThread(thread, auxiliaryThreadFunction, NULL, JVMTI_THREAD_NORM_PRIORITY))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->RunAgentThread(thread, auxiliaryThreadFunction, nullptr, JVMTI_THREAD_NORM_PRIORITY))) {\n@@ -150,1 +150,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -156,1 +156,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -160,1 +160,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach020\/attach020Agent00.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -77,1 +77,1 @@\n-                                        NULL) != JVMTI_ERROR_NONE) {\n+                                        nullptr) != JVMTI_ERROR_NONE) {\n@@ -130,1 +130,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -136,1 +136,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -140,1 +140,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach021\/attach021Agent00.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -177,1 +177,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -183,1 +183,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -187,1 +187,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach022\/attach022Agent00.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -113,1 +113,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -119,1 +119,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -123,1 +123,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach037\/attach037Agent00.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -109,1 +109,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -115,1 +115,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -119,1 +119,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach038\/attach038Agent00.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -55,1 +55,1 @@\n-    if (!nsk_jvmti_aod_getThreadName(jvmti, NULL, threadName)) {\n+    if (!nsk_jvmti_aod_getThreadName(jvmti, nullptr, threadName)) {\n@@ -69,1 +69,1 @@\n-    if (!NSK_VERIFY(thread != NULL))\n+    if (!NSK_VERIFY(thread != nullptr))\n@@ -72,1 +72,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->RunAgentThread(thread, startedThreadFunction, NULL, JVMTI_THREAD_NORM_PRIORITY))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->RunAgentThread(thread, startedThreadFunction, nullptr, JVMTI_THREAD_NORM_PRIORITY))) {\n@@ -145,1 +145,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -151,1 +151,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -155,1 +155,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach039\/attach039Agent00.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -137,1 +137,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -143,1 +143,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -147,1 +147,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach040\/attach040Agent00.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -48,1 +48,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -50,1 +50,1 @@\n-    jthreadGroup* groups = NULL;\n+    jthreadGroup* groups = nullptr;\n@@ -163,1 +163,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -169,1 +169,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -173,1 +173,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach041\/attach041Agent00.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -61,1 +61,1 @@\n-        jthread* threads = NULL;\n+        jthread* threads = nullptr;\n@@ -127,1 +127,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -133,1 +133,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -137,1 +137,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach042\/attach042Agent00.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -101,1 +101,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -107,1 +107,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -111,1 +111,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach045\/attach045Agent00.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -112,1 +112,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -118,1 +118,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -122,1 +122,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach045\/attach045Agent01.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -132,1 +132,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -138,1 +138,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -142,1 +142,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach045\/attach045Agent02.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-static Options* options = NULL;\n+static Options* options = nullptr;\n@@ -122,1 +122,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -128,1 +128,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -132,1 +132,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach045\/attach045Agent03.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-    if (!NSK_VERIFY(options != NULL)) {\n+    if (!NSK_VERIFY(options != nullptr)) {\n@@ -99,2 +99,2 @@\n-    jvmtiEnv* jvmti = NULL;\n-    JNIEnv* jni = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n+    JNIEnv* jni = nullptr;\n@@ -105,1 +105,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -111,1 +111,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -115,1 +115,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach046\/attach046Agent00.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,2 @@\n-    JNIEnv* jni = NULL;\n-    Options* options = NULL;\n+    JNIEnv* jni = nullptr;\n+    Options* options = nullptr;\n@@ -62,1 +62,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -68,1 +68,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -72,1 +72,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach050\/attach050Agent00.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,2 +53,2 @@\n-    JNIEnv* jni = NULL;\n-    Options* options = NULL;\n+    JNIEnv* jni = nullptr;\n+    Options* options = nullptr;\n@@ -58,1 +58,1 @@\n-    if (!NSK_VERIFY(options != NULL))\n+    if (!NSK_VERIFY(options != nullptr))\n@@ -64,1 +64,1 @@\n-    if (jni == NULL)\n+    if (jni == nullptr)\n@@ -68,1 +68,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/sharedAgents\/simpleAgent00.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (name != NULL && (strcmp(name, CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, CLASS_NAME) == 0)) {\n@@ -90,1 +90,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -100,1 +100,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassFileLoadHook\/classfloadhk001\/classfloadhk001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-static unsigned char* origClassBytes = NULL;\n+static unsigned char* origClassBytes = nullptr;\n@@ -62,2 +62,2 @@\n-    if (bytes == NULL) {\n-        NSK_COMPLAIN2(\"Unexpected NULL pointer to %s bytecode in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+    if (bytes == nullptr) {\n+        NSK_COMPLAIN2(\"Unexpected null pointer to %s bytecode in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -118,2 +118,2 @@\n-    jfieldID fieldID = NULL;\n-    jbyteArray array = NULL;\n+    jfieldID fieldID = nullptr;\n+    jbyteArray array = nullptr;\n@@ -125,1 +125,1 @@\n-            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != NULL)) {\n+            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != nullptr)) {\n@@ -133,1 +133,1 @@\n-            jni->GetStaticObjectField(cls, fieldID)) != NULL)) {\n+            jni->GetStaticObjectField(cls, fieldID)) != nullptr)) {\n@@ -147,1 +147,1 @@\n-        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != NULL)) {\n+        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != nullptr)) {\n@@ -185,1 +185,1 @@\n-            jclass debugeeClass = NULL;\n+            jclass debugeeClass = nullptr;\n@@ -189,1 +189,1 @@\n-                    jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+                    jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -207,1 +207,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr)))\n@@ -219,1 +219,1 @@\n-            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL))) {\n+            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr))) {\n@@ -264,1 +264,1 @@\n-    if (name != NULL && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n@@ -269,2 +269,2 @@\n-        if (class_being_redefined != NULL) {\n-            NSK_COMPLAIN1(\"Unexpected not NULL class_being_redefined in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+        if (class_being_redefined != nullptr) {\n+            NSK_COMPLAIN1(\"Unexpected not null class_being_redefined in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -297,1 +297,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -307,1 +307,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -336,1 +336,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassFileLoadHook\/classfloadhk002\/classfloadhk002.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-static jobject classLoader = NULL;\n+static jobject classLoader = nullptr;\n@@ -50,1 +50,1 @@\n-static unsigned char* origClassBytes = NULL;\n+static unsigned char* origClassBytes = nullptr;\n@@ -67,2 +67,2 @@\n-    if (bytes == NULL) {\n-        NSK_COMPLAIN2(\"Unexpected NULL pointer to %s bytecode in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+    if (bytes == nullptr) {\n+        NSK_COMPLAIN2(\"Unexpected null pointer to %s bytecode in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -123,2 +123,2 @@\n-    jfieldID fieldID = NULL;\n-    jbyteArray array = NULL;\n+    jfieldID fieldID = nullptr;\n+    jbyteArray array = nullptr;\n@@ -130,1 +130,1 @@\n-            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != NULL)) {\n+            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != nullptr)) {\n@@ -138,1 +138,1 @@\n-            jni->GetStaticObjectField(cls, fieldID)) != NULL)) {\n+            jni->GetStaticObjectField(cls, fieldID)) != nullptr)) {\n@@ -152,1 +152,1 @@\n-        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != NULL)) {\n+        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != nullptr)) {\n@@ -181,2 +181,2 @@\n-    jfieldID fieldID = NULL;\n-    jobject obj = NULL;\n+    jfieldID fieldID = nullptr;\n+    jobject obj = nullptr;\n@@ -186,1 +186,1 @@\n-            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != NULL)) {\n+            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != nullptr)) {\n@@ -188,1 +188,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -193,1 +193,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetStaticObjectField(cls, fieldID)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetStaticObjectField(cls, fieldID)) != nullptr)) {\n@@ -195,1 +195,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -200,1 +200,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (obj = jni->NewGlobalRef(obj)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (obj = jni->NewGlobalRef(obj)) != nullptr)) {\n@@ -202,1 +202,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -221,1 +221,1 @@\n-            jclass debugeeClass = NULL;\n+            jclass debugeeClass = nullptr;\n@@ -226,1 +226,1 @@\n-                    jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+                    jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -235,1 +235,1 @@\n-                                                        TESTED_CLASSLOADER_SIG)) != NULL))\n+                                                        TESTED_CLASSLOADER_SIG)) != nullptr))\n@@ -251,1 +251,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr)))\n@@ -263,1 +263,1 @@\n-            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL))) {\n+            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr))) {\n@@ -311,1 +311,1 @@\n-    if (name != NULL && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n@@ -316,2 +316,2 @@\n-        if (class_being_redefined != NULL) {\n-            NSK_COMPLAIN1(\"Unexpected not NULL class_being_redefined in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+        if (class_being_redefined != nullptr) {\n+            NSK_COMPLAIN1(\"Unexpected not null class_being_redefined in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -323,2 +323,2 @@\n-        if (loader == NULL) {\n-            NSK_COMPLAIN1(\"Unexpected NULL classloader in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+        if (loader == nullptr) {\n+            NSK_COMPLAIN1(\"Unexpected null classloader in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -357,1 +357,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -367,1 +367,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -396,1 +396,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassFileLoadHook\/classfloadhk003\/classfloadhk003.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-static unsigned char* newClassBytes = NULL;\n+static unsigned char* newClassBytes = nullptr;\n@@ -57,2 +57,2 @@\n-    jfieldID fieldID = NULL;\n-    jbyteArray array = NULL;\n+    jfieldID fieldID = nullptr;\n+    jbyteArray array = nullptr;\n@@ -64,1 +64,1 @@\n-            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != NULL)) {\n+            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != nullptr)) {\n@@ -72,1 +72,1 @@\n-            jni->GetStaticObjectField(cls, fieldID)) != NULL)) {\n+            jni->GetStaticObjectField(cls, fieldID)) != nullptr)) {\n@@ -86,1 +86,1 @@\n-        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != NULL)) {\n+        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != nullptr)) {\n@@ -124,1 +124,1 @@\n-            jclass debugeeClass = NULL;\n+            jclass debugeeClass = nullptr;\n@@ -128,1 +128,1 @@\n-                    jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+                    jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -146,1 +146,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr)))\n@@ -158,1 +158,1 @@\n-            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL))) {\n+            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr))) {\n@@ -199,1 +199,1 @@\n-    if (name != NULL && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n@@ -210,2 +210,2 @@\n-        if (new_class_data_len == NULL) {\n-            NSK_COMPLAIN1(\"NULL new_class_data_len pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+        if (new_class_data_len == nullptr) {\n+            NSK_COMPLAIN1(\"null new_class_data_len pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -217,2 +217,2 @@\n-        if (new_class_data == NULL) {\n-            NSK_COMPLAIN1(\"NULL new_class_data pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+        if (new_class_data == nullptr) {\n+            NSK_COMPLAIN1(\"null new_class_data pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -223,1 +223,1 @@\n-        if (new_class_data_len != NULL && new_class_data != NULL) {\n+        if (new_class_data_len != nullptr && new_class_data != nullptr) {\n@@ -251,1 +251,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -261,1 +261,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -290,1 +290,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassFileLoadHook\/classfloadhk004\/classfloadhk004.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-static unsigned char* newClassBytes = NULL;\n+static unsigned char* newClassBytes = nullptr;\n@@ -63,2 +63,2 @@\n-    if (bytes == NULL) {\n-        NSK_COMPLAIN2(\"Unexpected NULL pointer to %s bytecode in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+    if (bytes == nullptr) {\n+        NSK_COMPLAIN2(\"Unexpected null pointer to %s bytecode in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -119,2 +119,2 @@\n-    jfieldID fieldID = NULL;\n-    jbyteArray array = NULL;\n+    jfieldID fieldID = nullptr;\n+    jbyteArray array = nullptr;\n@@ -126,1 +126,1 @@\n-            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != NULL)) {\n+            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != nullptr)) {\n@@ -134,1 +134,1 @@\n-            jni->GetStaticObjectField(cls, fieldID)) != NULL)) {\n+            jni->GetStaticObjectField(cls, fieldID)) != nullptr)) {\n@@ -148,1 +148,1 @@\n-        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != NULL)) {\n+        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != nullptr)) {\n@@ -186,1 +186,1 @@\n-            jclass debugeeClass = NULL;\n+            jclass debugeeClass = nullptr;\n@@ -190,1 +190,1 @@\n-                    jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+                    jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -208,1 +208,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr)))\n@@ -220,1 +220,1 @@\n-            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL))) {\n+            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr))) {\n@@ -261,1 +261,1 @@\n-    if (name != NULL && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n@@ -272,2 +272,2 @@\n-        if (new_class_data_len == NULL) {\n-            NSK_COMPLAIN1(\"NULL new_class_data_len pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+        if (new_class_data_len == nullptr) {\n+            NSK_COMPLAIN1(\"null new_class_data_len pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -279,2 +279,2 @@\n-        if (new_class_data == NULL) {\n-            NSK_COMPLAIN1(\"NULL new_class_data pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+        if (new_class_data == nullptr) {\n+            NSK_COMPLAIN1(\"null new_class_data pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -285,1 +285,1 @@\n-        if (new_class_data_len != NULL && new_class_data != NULL) {\n+        if (new_class_data_len != nullptr && new_class_data != nullptr) {\n@@ -313,1 +313,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -323,1 +323,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -352,1 +352,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassFileLoadHook\/classfloadhk005\/classfloadhk005.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-static jclass testedClass = NULL;\n+static jclass testedClass = nullptr;\n@@ -51,1 +51,1 @@\n-static unsigned char* redefClassBytes = NULL;\n+static unsigned char* redefClassBytes = nullptr;\n@@ -68,2 +68,2 @@\n-    if (bytes == NULL) {\n-        NSK_COMPLAIN2(\"Unexpected NULL pointer to %s bytecode in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+    if (bytes == nullptr) {\n+        NSK_COMPLAIN2(\"Unexpected null pointer to %s bytecode in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -124,2 +124,2 @@\n-    jfieldID fieldID = NULL;\n-    jbyteArray array = NULL;\n+    jfieldID fieldID = nullptr;\n+    jbyteArray array = nullptr;\n@@ -131,1 +131,1 @@\n-            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != NULL)) {\n+            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != nullptr)) {\n@@ -139,1 +139,1 @@\n-            jni->GetStaticObjectField(cls, fieldID)) != NULL)) {\n+            jni->GetStaticObjectField(cls, fieldID)) != nullptr)) {\n@@ -153,1 +153,1 @@\n-        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != NULL)) {\n+        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != nullptr)) {\n@@ -182,2 +182,2 @@\n-    jfieldID fieldID = NULL;\n-    jobject obj = NULL;\n+    jfieldID fieldID = nullptr;\n+    jobject obj = nullptr;\n@@ -187,1 +187,1 @@\n-            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != NULL)) {\n+            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != nullptr)) {\n@@ -189,1 +189,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -194,1 +194,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetStaticObjectField(cls, fieldID)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetStaticObjectField(cls, fieldID)) != nullptr)) {\n@@ -196,1 +196,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -201,1 +201,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (obj = jni->NewGlobalRef(obj)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (obj = jni->NewGlobalRef(obj)) != nullptr)) {\n@@ -203,1 +203,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -241,1 +241,1 @@\n-            jclass debugeeClass = NULL;\n+            jclass debugeeClass = nullptr;\n@@ -246,1 +246,1 @@\n-                    jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+                    jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -255,1 +255,1 @@\n-                                                        TESTED_CLASS_FIELD_SIG)) != NULL))\n+                                                        TESTED_CLASS_FIELD_SIG)) != nullptr))\n@@ -278,1 +278,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr)))\n@@ -286,1 +286,1 @@\n-            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL))) {\n+            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr))) {\n@@ -333,1 +333,1 @@\n-    if (name != NULL && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n@@ -338,2 +338,2 @@\n-        if (class_being_redefined == NULL) {\n-            NSK_COMPLAIN1(\"Unexpected NULL class_being_redefined in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+        if (class_being_redefined == nullptr) {\n+            NSK_COMPLAIN1(\"Unexpected null class_being_redefined in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -372,1 +372,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -382,1 +382,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -412,1 +412,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassFileLoadHook\/classfloadhk006\/classfloadhk006.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-static jobject classLoader = NULL;\n-static jclass testedClass = NULL;\n+static jobject classLoader = nullptr;\n+static jclass testedClass = nullptr;\n@@ -55,1 +55,1 @@\n-static unsigned char* redefClassBytes = NULL;\n+static unsigned char* redefClassBytes = nullptr;\n@@ -72,2 +72,2 @@\n-    if (bytes == NULL) {\n-        NSK_COMPLAIN2(\"Unexpected NULL pointer to %s bytecode in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+    if (bytes == nullptr) {\n+        NSK_COMPLAIN2(\"Unexpected null pointer to %s bytecode in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -128,2 +128,2 @@\n-    jfieldID fieldID = NULL;\n-    jbyteArray array = NULL;\n+    jfieldID fieldID = nullptr;\n+    jbyteArray array = nullptr;\n@@ -135,1 +135,1 @@\n-            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != NULL)) {\n+            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != nullptr)) {\n@@ -143,1 +143,1 @@\n-            jni->GetStaticObjectField(cls, fieldID)) != NULL)) {\n+            jni->GetStaticObjectField(cls, fieldID)) != nullptr)) {\n@@ -157,1 +157,1 @@\n-        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != NULL)) {\n+        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != nullptr)) {\n@@ -186,2 +186,2 @@\n-    jfieldID fieldID = NULL;\n-    jobject obj = NULL;\n+    jfieldID fieldID = nullptr;\n+    jobject obj = nullptr;\n@@ -191,1 +191,1 @@\n-            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != NULL)) {\n+            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != nullptr)) {\n@@ -193,1 +193,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -198,1 +198,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetStaticObjectField(cls, fieldID)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetStaticObjectField(cls, fieldID)) != nullptr)) {\n@@ -200,1 +200,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -205,1 +205,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (obj = jni->NewGlobalRef(obj)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (obj = jni->NewGlobalRef(obj)) != nullptr)) {\n@@ -207,1 +207,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -245,1 +245,1 @@\n-            jclass debugeeClass = NULL;\n+            jclass debugeeClass = nullptr;\n@@ -250,1 +250,1 @@\n-                    jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+                    jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -259,1 +259,1 @@\n-                                                        TESTED_CLASS_FIELD_SIG)) != NULL))\n+                                                        TESTED_CLASS_FIELD_SIG)) != nullptr))\n@@ -265,1 +265,1 @@\n-                                                        TESTED_CLASSLOADER_SIG)) != NULL))\n+                                                        TESTED_CLASSLOADER_SIG)) != nullptr))\n@@ -288,1 +288,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr)))\n@@ -296,1 +296,1 @@\n-            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL))) {\n+            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr))) {\n@@ -346,1 +346,1 @@\n-    if (name != NULL && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n@@ -351,2 +351,2 @@\n-        if (loader == NULL) {\n-            NSK_COMPLAIN1(\"Unexpected NULL classloader in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+        if (loader == nullptr) {\n+            NSK_COMPLAIN1(\"Unexpected null classloader in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -364,2 +364,2 @@\n-        if (class_being_redefined == NULL) {\n-            NSK_COMPLAIN1(\"Unexpected NULL class_being_redefined in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+        if (class_being_redefined == nullptr) {\n+            NSK_COMPLAIN1(\"Unexpected null class_being_redefined in CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -398,1 +398,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -408,1 +408,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -438,1 +438,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassFileLoadHook\/classfloadhk007\/classfloadhk007.cpp","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-static jclass testedClass = NULL;\n+static jclass testedClass = nullptr;\n@@ -52,1 +52,1 @@\n-static unsigned char* redefClassBytes = NULL;\n+static unsigned char* redefClassBytes = nullptr;\n@@ -55,1 +55,1 @@\n-static unsigned char* newClassBytes = NULL;\n+static unsigned char* newClassBytes = nullptr;\n@@ -66,2 +66,2 @@\n-    jfieldID fieldID = NULL;\n-    jbyteArray array = NULL;\n+    jfieldID fieldID = nullptr;\n+    jbyteArray array = nullptr;\n@@ -73,1 +73,1 @@\n-            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != NULL)) {\n+            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != nullptr)) {\n@@ -81,1 +81,1 @@\n-            jni->GetStaticObjectField(cls, fieldID)) != NULL)) {\n+            jni->GetStaticObjectField(cls, fieldID)) != nullptr)) {\n@@ -95,1 +95,1 @@\n-        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != NULL)) {\n+        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != nullptr)) {\n@@ -124,2 +124,2 @@\n-    jfieldID fieldID = NULL;\n-    jobject obj = NULL;\n+    jfieldID fieldID = nullptr;\n+    jobject obj = nullptr;\n@@ -129,1 +129,1 @@\n-            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != NULL)) {\n+            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != nullptr)) {\n@@ -131,1 +131,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -136,1 +136,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetStaticObjectField(cls, fieldID)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetStaticObjectField(cls, fieldID)) != nullptr)) {\n@@ -138,1 +138,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -143,1 +143,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (obj = jni->NewGlobalRef(obj)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (obj = jni->NewGlobalRef(obj)) != nullptr)) {\n@@ -145,1 +145,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -183,1 +183,1 @@\n-            jclass debugeeClass = NULL;\n+            jclass debugeeClass = nullptr;\n@@ -188,1 +188,1 @@\n-                    jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+                    jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -197,1 +197,1 @@\n-                                                        TESTED_CLASS_FIELD_SIG)) != NULL))\n+                                                        TESTED_CLASS_FIELD_SIG)) != nullptr))\n@@ -227,1 +227,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr)))\n@@ -235,1 +235,1 @@\n-            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL))) {\n+            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr))) {\n@@ -282,1 +282,1 @@\n-    if (name != NULL && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n@@ -293,2 +293,2 @@\n-        if (new_class_data_len == NULL) {\n-            NSK_COMPLAIN1(\"NULL new_class_data_len pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+        if (new_class_data_len == nullptr) {\n+            NSK_COMPLAIN1(\"null new_class_data_len pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -300,2 +300,2 @@\n-        if (new_class_data == NULL) {\n-            NSK_COMPLAIN1(\"NULL new_class_data pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+        if (new_class_data == nullptr) {\n+            NSK_COMPLAIN1(\"null new_class_data pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -306,1 +306,1 @@\n-        if (new_class_data_len != NULL && new_class_data != NULL) {\n+        if (new_class_data_len != nullptr && new_class_data != nullptr) {\n@@ -334,1 +334,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -344,1 +344,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -374,1 +374,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassFileLoadHook\/classfloadhk008\/classfloadhk008.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-static jclass testedClass = NULL;\n+static jclass testedClass = nullptr;\n@@ -52,1 +52,1 @@\n-static unsigned char* redefClassBytes = NULL;\n+static unsigned char* redefClassBytes = nullptr;\n@@ -55,1 +55,1 @@\n-static unsigned char* newClassBytes = NULL;\n+static unsigned char* newClassBytes = nullptr;\n@@ -66,2 +66,2 @@\n-    jfieldID fieldID = NULL;\n-    jbyteArray array = NULL;\n+    jfieldID fieldID = nullptr;\n+    jbyteArray array = nullptr;\n@@ -73,1 +73,1 @@\n-            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != NULL)) {\n+            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != nullptr)) {\n@@ -81,1 +81,1 @@\n-            jni->GetStaticObjectField(cls, fieldID)) != NULL)) {\n+            jni->GetStaticObjectField(cls, fieldID)) != nullptr)) {\n@@ -95,1 +95,1 @@\n-        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != NULL)) {\n+        if (!NSK_JNI_VERIFY(jni, (elements = jni->GetByteArrayElements(array, &isCopy)) != nullptr)) {\n@@ -124,2 +124,2 @@\n-    jfieldID fieldID = NULL;\n-    jobject obj = NULL;\n+    jfieldID fieldID = nullptr;\n+    jobject obj = nullptr;\n@@ -129,1 +129,1 @@\n-            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != NULL)) {\n+            jni->GetStaticFieldID(cls, fieldName, fieldSig)) != nullptr)) {\n@@ -131,1 +131,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -136,1 +136,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetStaticObjectField(cls, fieldID)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetStaticObjectField(cls, fieldID)) != nullptr)) {\n@@ -138,1 +138,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -143,1 +143,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (obj = jni->NewGlobalRef(obj)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (obj = jni->NewGlobalRef(obj)) != nullptr)) {\n@@ -145,1 +145,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -183,1 +183,1 @@\n-            jclass debugeeClass = NULL;\n+            jclass debugeeClass = nullptr;\n@@ -188,1 +188,1 @@\n-                    jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+                    jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -197,1 +197,1 @@\n-                                                        TESTED_CLASS_FIELD_SIG)) != NULL))\n+                                                        TESTED_CLASS_FIELD_SIG)) != nullptr))\n@@ -227,1 +227,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr)))\n@@ -235,1 +235,1 @@\n-            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL))) {\n+            if (NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr))) {\n@@ -282,1 +282,1 @@\n-    if (name != NULL && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, TESTED_CLASS_NAME) == 0)) {\n@@ -293,2 +293,2 @@\n-        if (new_class_data_len == NULL) {\n-            NSK_COMPLAIN1(\"NULL new_class_data_len pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+        if (new_class_data_len == nullptr) {\n+            NSK_COMPLAIN1(\"null new_class_data_len pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -300,2 +300,2 @@\n-        if (new_class_data == NULL) {\n-            NSK_COMPLAIN1(\"NULL new_class_data pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n+        if (new_class_data == nullptr) {\n+            NSK_COMPLAIN1(\"null new_class_data pointer passed to CLASS_FILE_LOAD_HOOK: 0x%p\\n\",\n@@ -306,1 +306,1 @@\n-        if (new_class_data_len != NULL && new_class_data != NULL) {\n+        if (new_class_data_len != nullptr && new_class_data != nullptr) {\n@@ -334,1 +334,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -344,1 +344,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -374,1 +374,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassFileLoadHook\/classfloadhk009\/classfloadhk009.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -65,1 +65,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -70,1 +70,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -105,1 +105,1 @@\n-            JVMTI_EVENT_BREAKPOINT, NULL);\n+            JVMTI_EVENT_BREAKPOINT, nullptr);\n@@ -121,1 +121,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -132,1 +132,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -141,1 +141,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -156,1 +156,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -165,1 +165,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -179,1 +179,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClearBreakpoint\/clrbrk001\/clrbrk001.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -101,1 +101,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -111,1 +111,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClearBreakpoint\/clrbrk002\/clrbrk002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -99,1 +99,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -117,1 +117,1 @@\n-    err = jvmti->ClearBreakpoint(NULL, 0);\n+    err = jvmti->ClearBreakpoint(nullptr, 0);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClearBreakpoint\/clrbrk005\/clrbrk005.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-static jfieldID thrown_fid = NULL;\n+static jfieldID thrown_fid = nullptr;\n@@ -50,2 +50,2 @@\n-    { \"nsk\/jvmti\/ClearFieldAccessWatch\/clrfldw001\", \"fld0\", \"I\", 0, NULL },\n-    { \"nsk\/jvmti\/ClearFieldAccessWatch\/clrfldw001\", \"fld1\", \"I\", 1, NULL },\n+    { \"nsk\/jvmti\/ClearFieldAccessWatch\/clrfldw001\", \"fld0\", \"I\", 0, nullptr },\n+    { \"nsk\/jvmti\/ClearFieldAccessWatch\/clrfldw001\", \"fld1\", \"I\", 1, nullptr },\n@@ -53,3 +53,3 @@\n-      \"Lnsk\/jvmti\/ClearFieldAccessWatch\/clrfldw001a;\", 0, NULL },\n-    { \"nsk\/jvmti\/ClearFieldAccessWatch\/clrfldw001a\", \"fld3\", \"[I\", 0, NULL },\n-    { \"nsk\/jvmti\/ClearFieldAccessWatch\/clrfldw001b\", \"fld4\", \"F\", 0, NULL },\n+      \"Lnsk\/jvmti\/ClearFieldAccessWatch\/clrfldw001a;\", 0, nullptr },\n+    { \"nsk\/jvmti\/ClearFieldAccessWatch\/clrfldw001a\", \"fld3\", \"[I\", 0, nullptr },\n+    { \"nsk\/jvmti\/ClearFieldAccessWatch\/clrfldw001b\", \"fld4\", \"F\", 0, nullptr },\n@@ -65,1 +65,1 @@\n-    if (fld.fid == NULL) {\n+    if (fld.fid == nullptr) {\n@@ -112,1 +112,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -148,1 +148,1 @@\n-                JVMTI_EVENT_FIELD_ACCESS, NULL);\n+                JVMTI_EVENT_FIELD_ACCESS, nullptr);\n@@ -185,1 +185,1 @@\n-        if (flag == JNI_FALSE && thrown_fid != NULL) {\n+        if (flag == JNI_FALSE && thrown_fid != nullptr) {\n@@ -194,1 +194,1 @@\n-        thrown_fid = NULL;\n+        thrown_fid = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClearFieldAccessWatch\/clrfldw001\/clrfldw001.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -99,1 +99,1 @@\n-                JVMTI_EVENT_FIELD_ACCESS, NULL);\n+                JVMTI_EVENT_FIELD_ACCESS, nullptr);\n@@ -128,1 +128,1 @@\n-        err = jvmti->ClearFieldAccessWatch(NULL, fid2);\n+        err = jvmti->ClearFieldAccessWatch(nullptr, fid2);\n@@ -135,1 +135,1 @@\n-        err = jvmti->ClearFieldAccessWatch(cls, NULL);\n+        err = jvmti->ClearFieldAccessWatch(cls, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClearFieldAccessWatch\/clrfldw002\/clrfldw002.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-static jfieldID thrown_fid = NULL;\n+static jfieldID thrown_fid = nullptr;\n@@ -50,2 +50,2 @@\n-    { \"nsk\/jvmti\/ClearFieldModificationWatch\/clrfmodw001\", \"fld0\", \"I\", 0, NULL },\n-    { \"nsk\/jvmti\/ClearFieldModificationWatch\/clrfmodw001\", \"fld1\", \"I\", 1, NULL },\n+    { \"nsk\/jvmti\/ClearFieldModificationWatch\/clrfmodw001\", \"fld0\", \"I\", 0, nullptr },\n+    { \"nsk\/jvmti\/ClearFieldModificationWatch\/clrfmodw001\", \"fld1\", \"I\", 1, nullptr },\n@@ -53,3 +53,3 @@\n-      \"Lnsk\/jvmti\/ClearFieldModificationWatch\/clrfmodw001a;\", 0, NULL },\n-    { \"nsk\/jvmti\/ClearFieldModificationWatch\/clrfmodw001a\", \"fld3\", \"[I\", 0, NULL },\n-    { \"nsk\/jvmti\/ClearFieldModificationWatch\/clrfmodw001b\", \"fld4\", \"F\", 0, NULL },\n+      \"Lnsk\/jvmti\/ClearFieldModificationWatch\/clrfmodw001a;\", 0, nullptr },\n+    { \"nsk\/jvmti\/ClearFieldModificationWatch\/clrfmodw001a\", \"fld3\", \"[I\", 0, nullptr },\n+    { \"nsk\/jvmti\/ClearFieldModificationWatch\/clrfmodw001b\", \"fld4\", \"F\", 0, nullptr },\n@@ -65,1 +65,1 @@\n-    if (fld.fid == NULL) {\n+    if (fld.fid == nullptr) {\n@@ -112,1 +112,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -148,1 +148,1 @@\n-                JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n+                JVMTI_EVENT_FIELD_MODIFICATION, nullptr);\n@@ -178,1 +178,1 @@\n-        if (flag == JNI_FALSE && thrown_fid != NULL) {\n+        if (flag == JNI_FALSE && thrown_fid != nullptr) {\n@@ -187,1 +187,1 @@\n-        thrown_fid = NULL;\n+        thrown_fid = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClearFieldModificationWatch\/clrfmodw001\/clrfmodw001.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -99,1 +99,1 @@\n-                JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n+                JVMTI_EVENT_FIELD_MODIFICATION, nullptr);\n@@ -130,1 +130,1 @@\n-        err = jvmti->ClearFieldModificationWatch(NULL, fid2);\n+        err = jvmti->ClearFieldModificationWatch(nullptr, fid2);\n@@ -137,1 +137,1 @@\n-        err = jvmti->ClearFieldModificationWatch(cls, NULL);\n+        err = jvmti->ClearFieldModificationWatch(cls, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClearFieldModificationWatch\/clrfmodw002\/clrfmodw002.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -116,1 +116,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -140,1 +140,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr)))\n@@ -142,1 +142,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/CompiledMethodLoad\/compmethload001\/compmethload001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -91,1 +91,1 @@\n-    err = jvmti_env->GetMethodName(method, &name, &sig, NULL);\n+    err = jvmti_env->GetMethodName(method, &name, &sig, nullptr);\n@@ -160,1 +160,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -185,1 +185,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr)))\n@@ -187,1 +187,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr)))\n@@ -189,1 +189,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_UNLOAD, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_UNLOAD, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/CompiledMethodUnload\/compmethunload001\/compmethunload001.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -60,1 +60,1 @@\n-        } else if (monitors[i] == NULL) {\n+        } else if (monitors[i] == nullptr) {\n@@ -82,1 +82,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -87,1 +87,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -101,1 +101,1 @@\n-            JVMTI_EVENT_VM_INIT, NULL);\n+            JVMTI_EVENT_VM_INIT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/CreateRawMonitor\/crrawmon001\/crrawmon001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -72,1 +72,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -80,1 +80,1 @@\n-    err = jvmti->CreateRawMonitor(NULL, &monitor);\n+    err = jvmti->CreateRawMonitor(nullptr, &monitor);\n@@ -90,1 +90,1 @@\n-    err = jvmti->CreateRawMonitor(\"dummy\", NULL);\n+    err = jvmti->CreateRawMonitor(\"dummy\", nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/CreateRawMonitor\/crrawmon002\/crrawmon002.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -109,1 +109,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL)) {\n+    if (!NSK_VERIFY(jvmti != nullptr)) {\n@@ -125,1 +125,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_DATA_DUMP_REQUEST, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_DATA_DUMP_REQUEST, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/DataDumpRequest\/datadumpreq001\/datadumpreq001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -71,1 +71,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -79,1 +79,1 @@\n-    err = jvmti->Deallocate(NULL);\n+    err = jvmti->Deallocate(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Deallocate\/dealloc001\/dealloc001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -61,1 +61,1 @@\n-        } else if (monitors[i] == NULL) {\n+        } else if (monitors[i] == nullptr) {\n@@ -97,1 +97,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -102,1 +102,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -116,1 +116,1 @@\n-            JVMTI_EVENT_VM_INIT, NULL);\n+            JVMTI_EVENT_VM_INIT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/DestroyRawMonitor\/drrawmon001\/drrawmon001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -72,1 +72,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/DestroyRawMonitor\/drrawmon003\/drrawmon003.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -71,1 +71,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -80,1 +80,1 @@\n-    err = jvmti->DestroyRawMonitor(NULL);\n+    err = jvmti->DestroyRawMonitor(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/DestroyRawMonitor\/drrawmon004\/drrawmon004.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -53,1 +53,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/DisposeEnvironment\/disposeenv001\/disposeenv001.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_VM_DEATH, NULL))) {\n+            jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_VM_DEATH, nullptr))) {\n@@ -82,1 +82,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -88,1 +88,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -102,1 +102,1 @@\n-                jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL))) {\n+                jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr))) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/DisposeEnvironment\/disposeenv002\/disposeenv002.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -114,1 +114,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -124,1 +124,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED, nullptr)))\n@@ -128,1 +128,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/DynamicCodeGenerated\/dyncodgen001\/dyncodgen001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -181,1 +181,1 @@\n-    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != NULL))\n+    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ForceEarlyReturn\/ForceEarlyReturn001\/ForceEarlyReturn001.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -83,1 +83,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -86,1 +86,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ForceGarbageCollection\/forcegc001\/forcegc001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL)))\n+        if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr)))\n@@ -63,1 +63,1 @@\n-        if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL)))\n+        if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr)))\n@@ -101,1 +101,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -109,1 +109,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -128,1 +128,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ForceGarbageCollection\/forcegc002\/forcegc002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -197,1 +197,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -221,1 +221,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr)))\n@@ -223,1 +223,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GarbageCollectionFinish\/gcfinish001\/gcfinish001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -117,1 +117,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -142,1 +142,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr)))\n@@ -144,1 +144,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_START, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_START, nullptr)))\n@@ -146,1 +146,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GarbageCollectionStart\/gcstart001\/gcstart001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -198,1 +198,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -222,1 +222,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr)))\n@@ -224,1 +224,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_START, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_START, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GarbageCollectionStart\/gcstart002\/gcstart002.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-        if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL)) {\n+        if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr)) {\n@@ -111,1 +111,1 @@\n-        if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL)) {\n+        if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr)) {\n@@ -177,1 +177,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -185,1 +185,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -188,1 +188,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GenerateEvents\/genevents001\/genevents001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -40,1 +40,1 @@\n-    jmethodID mid = NULL;\n+    jmethodID mid = nullptr;\n@@ -48,1 +48,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -79,1 +79,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetArgumentsSize\/argsize001\/argsize001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -79,1 +79,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -87,1 +87,1 @@\n-    err = jvmti->GetArgumentsSize(NULL, &size);\n+    err = jvmti->GetArgumentsSize(nullptr, &size);\n@@ -97,1 +97,1 @@\n-    err = jvmti->GetArgumentsSize(mid, NULL);\n+    err = jvmti->GetArgumentsSize(mid, nullptr);\n@@ -105,1 +105,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetArgumentsSize\/argsize002\/argsize002.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -142,1 +142,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -150,1 +150,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -165,1 +165,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -174,1 +174,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetAvailableProcessors\/getavailproc001\/getavailproc001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -73,1 +73,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -78,1 +78,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -120,1 +120,1 @@\n-    jmethodID mid = NULL;\n+    jmethodID mid = nullptr;\n@@ -122,1 +122,1 @@\n-    unsigned char *codes = NULL;\n+    unsigned char *codes = nullptr;\n@@ -125,1 +125,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -138,1 +138,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetBytecodes\/bytecodes001\/bytecodes001.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -108,1 +108,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -114,1 +114,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -122,1 +122,1 @@\n-    err = jvmti->GetBytecodes(NULL, &bytecodeCount, &bytecodes);\n+    err = jvmti->GetBytecodes(nullptr, &bytecodeCount, &bytecodes);\n@@ -134,1 +134,1 @@\n-    err = jvmti->GetBytecodes(mid, NULL, &bytecodes);\n+    err = jvmti->GetBytecodes(mid, nullptr, &bytecodes);\n@@ -146,1 +146,1 @@\n-    err = jvmti->GetBytecodes(mid, &bytecodeCount, NULL);\n+    err = jvmti->GetBytecodes(mid, &bytecodeCount, nullptr);\n@@ -156,1 +156,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetBytecodes\/bytecodes002\/bytecodes002.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -327,2 +327,2 @@\n-    sig = NULL;\n-    err = jvmti_env->GetClassSignature(cls, &sig, NULL);\n+    sig = nullptr;\n+    err = jvmti_env->GetClassSignature(cls, &sig, nullptr);\n@@ -350,1 +350,1 @@\n-        if (methods[i] == NULL) {\n+        if (methods[i] == nullptr) {\n@@ -355,4 +355,4 @@\n-            name = NULL;\n-            msig = NULL;\n-            bytecodes = NULL;\n-            err = jvmti_env->GetMethodName(methods[i], &name, &msig, NULL);\n+            name = nullptr;\n+            msig = nullptr;\n+            bytecodes = nullptr;\n+            err = jvmti_env->GetMethodName(methods[i], &name, &msig, nullptr);\n@@ -400,1 +400,1 @@\n-            if (name != NULL) {\n+            if (name != nullptr) {\n@@ -403,1 +403,1 @@\n-            if (msig != NULL) {\n+            if (msig != nullptr) {\n@@ -406,1 +406,1 @@\n-            if (bytecodes != NULL) {\n+            if (bytecodes != nullptr) {\n@@ -412,1 +412,1 @@\n-    if (methods != NULL) {\n+    if (methods != nullptr) {\n@@ -415,1 +415,1 @@\n-    if (sig != NULL) {\n+    if (sig != nullptr) {\n@@ -436,1 +436,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -441,1 +441,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -491,1 +491,1 @@\n-                JVMTI_EVENT_CLASS_PREPARE, NULL);\n+                JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -508,1 +508,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -515,1 +515,1 @@\n-                JVMTI_EVENT_CLASS_PREPARE, NULL);\n+                JVMTI_EVENT_CLASS_PREPARE, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetBytecodes\/bytecodes003\/bytecodes003.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -71,1 +71,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -79,1 +79,1 @@\n-    err = jvmti->GetCapabilities(NULL);\n+    err = jvmti->GetCapabilities(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCapabilities\/getcaps001\/getcaps001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,1 +255,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -282,1 +282,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -290,1 +290,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -305,1 +305,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -314,1 +314,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCapabilities\/getcaps002\/getcaps002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -81,1 +81,1 @@\n-    err = jvmti->GetClassFields(NULL, &fcount, &fields);\n+    err = jvmti->GetClassFields(nullptr, &fcount, &fields);\n@@ -91,1 +91,1 @@\n-    err = jvmti->GetClassFields(cls, NULL, &fields);\n+    err = jvmti->GetClassFields(cls, nullptr, &fields);\n@@ -101,1 +101,1 @@\n-    err = jvmti->GetClassFields(cls, &fcount, NULL);\n+    err = jvmti->GetClassFields(cls, &fcount, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassFields\/getclfld005\/getclfld005.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassFields\/getclfld006\/getclfld006.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -43,1 +43,1 @@\n-    const char* utf = env->GetStringUTFChars(jstr, NULL);\n+    const char* utf = env->GetStringUTFChars(jstr, nullptr);\n@@ -45,1 +45,1 @@\n-    if (utf != NULL) {\n+    if (utf != nullptr) {\n@@ -71,1 +71,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -87,1 +87,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -112,1 +112,1 @@\n-        if (fields[j] == NULL) {\n+        if (fields[j] == nullptr) {\n@@ -117,1 +117,1 @@\n-        err = jvmti->GetFieldName(clazz, fields[j], &name, &sig, NULL);\n+        err = jvmti->GetFieldName(clazz, fields[j], &name, &sig, nullptr);\n@@ -126,1 +126,1 @@\n-               (name == NULL || sig == NULL ||\n+               (name == nullptr || sig == nullptr ||\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassFields\/getclfld007\/getclfld007.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -72,1 +72,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -80,1 +80,1 @@\n-    err = jvmti->GetClassLoader(NULL, &classloader);\n+    err = jvmti->GetClassLoader(nullptr, &classloader);\n@@ -90,1 +90,1 @@\n-    err = jvmti->GetClassLoader(cls, NULL);\n+    err = jvmti->GetClassLoader(cls, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassLoader\/getclsldr001\/getclsldr001.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -74,1 +74,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -100,2 +100,2 @@\n-    if (classloader != NULL) {\n-        printf(\"(%d:%s) class loader is not NULL: 0x%p\\n\",\n+    if (classloader != nullptr) {\n+        printf(\"(%d:%s) class loader is not null: 0x%p\\n\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassLoader\/getclsldr002\/getclsldr002.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -74,1 +74,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassLoader\/getclsldr003\/getclsldr003.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -74,1 +74,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -90,1 +90,1 @@\n-    err = jvmti->GetClassLoaderClasses(NULL, &classCount, &classes);\n+    err = jvmti->GetClassLoaderClasses(nullptr, &classCount, &classes);\n@@ -100,1 +100,1 @@\n-    err = jvmti->GetClassLoaderClasses(classloader, NULL, &classes);\n+    err = jvmti->GetClassLoaderClasses(classloader, nullptr, &classes);\n@@ -110,1 +110,1 @@\n-    err = jvmti->GetClassLoaderClasses(classloader, &classCount, NULL);\n+    err = jvmti->GetClassLoaderClasses(classloader, &classCount, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassLoaderClasses\/clsldrclss001\/clsldrclss001.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,3 @@\n-static jobject testedClassLoader = NULL;\n-static jclass testedClass = NULL;\n-static jfieldID testedFieldID = NULL;\n+static jobject testedClassLoader = nullptr;\n+static jclass testedClass = nullptr;\n+static jfieldID testedFieldID = nullptr;\n@@ -61,1 +61,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedClass = jni->FindClass(CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedClass = jni->FindClass(CLASS_NAME)) != nullptr))\n@@ -64,1 +64,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass) jni->NewGlobalRef(testedClass)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass) jni->NewGlobalRef(testedClass)) != nullptr))\n@@ -69,1 +69,1 @@\n-            jni->GetStaticFieldID(testedClass, FIELD_NAME, FIELD_SIGNATURE)) != NULL))\n+            jni->GetStaticFieldID(testedClass, FIELD_NAME, FIELD_SIGNATURE)) != nullptr))\n@@ -85,1 +85,1 @@\n-        if (signature != NULL && strcmp(signature, exp_sig) == 0) {\n+        if (signature != nullptr && strcmp(signature, exp_sig) == 0) {\n@@ -90,1 +90,1 @@\n-        if (signature != NULL)\n+        if (signature != nullptr)\n@@ -93,1 +93,1 @@\n-        if (generic != NULL)\n+        if (generic != nullptr)\n@@ -118,1 +118,1 @@\n-            jni->GetStaticObjectField(testedClass, testedFieldID)) != NULL)) {\n+            jni->GetStaticObjectField(testedClass, testedFieldID)) != nullptr)) {\n@@ -130,1 +130,1 @@\n-    if (!NSK_VERIFY(classes != NULL)) {\n+    if (!NSK_VERIFY(classes != nullptr)) {\n@@ -139,1 +139,1 @@\n-    if (classes != NULL)\n+    if (classes != nullptr)\n@@ -149,1 +149,1 @@\n-            jni->GetStaticObjectField(testedClass, testedFieldID)) != NULL)) {\n+            jni->GetStaticObjectField(testedClass, testedFieldID)) != nullptr)) {\n@@ -161,1 +161,1 @@\n-    if (!NSK_VERIFY(classes != NULL)) {\n+    if (!NSK_VERIFY(classes != nullptr)) {\n@@ -177,1 +177,1 @@\n-    if (classes != NULL)\n+    if (classes != nullptr)\n@@ -201,1 +201,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -211,1 +211,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -214,1 +214,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassLoaderClasses\/clsldrclss002\/clsldrclss002.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -81,1 +81,1 @@\n-    err = jvmti->GetClassMethods(NULL, &mcount, &methods);\n+    err = jvmti->GetClassMethods(nullptr, &mcount, &methods);\n@@ -91,1 +91,1 @@\n-    err = jvmti->GetClassMethods(cls, NULL, &methods);\n+    err = jvmti->GetClassMethods(cls, nullptr, &methods);\n@@ -101,1 +101,1 @@\n-    err = jvmti->GetClassMethods(cls, &mcount, NULL);\n+    err = jvmti->GetClassMethods(cls, &mcount, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassMethods\/getclmthd005\/getclmthd005.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassMethods\/getclmthd006\/getclmthd006.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -127,1 +127,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -132,1 +132,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -150,1 +150,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -176,1 +176,1 @@\n-        if (methods[k] == NULL) {\n+        if (methods[k] == nullptr) {\n@@ -190,1 +190,1 @@\n-            if (methods[k] != NULL) {\n+            if (methods[k] != nullptr) {\n@@ -198,1 +198,1 @@\n-                    if (name != NULL && sig != NULL &&\n+                    if (name != nullptr && sig != nullptr &&\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassMethods\/getclmthd007\/getclmthd007.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -72,1 +72,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -80,1 +80,1 @@\n-    err = jvmti->GetClassModifiers(NULL, &modifiers);\n+    err = jvmti->GetClassModifiers(nullptr, &modifiers);\n@@ -90,1 +90,1 @@\n-    err = jvmti->GetClassModifiers(cls, NULL);\n+    err = jvmti->GetClassModifiers(cls, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassModifiers\/getclmdf004\/getclmdf004.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -60,1 +60,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -65,1 +65,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -78,1 +78,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassModifiers\/getclmdf005\/getclmdf005.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -63,1 +63,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -68,1 +68,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -93,1 +93,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassModifiers\/getclmdf006\/getclmdf006.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -63,1 +63,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -68,1 +68,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -94,1 +94,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassModifiers\/getclmdf007\/getclmdf007.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -66,1 +66,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -71,1 +71,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -85,1 +85,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassSignature\/getclsig004\/getclsig004.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -55,1 +55,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -60,1 +60,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -81,1 +81,1 @@\n-    err = jvmti->GetClassSignature(NULL, &sig, &generic);\n+    err = jvmti->GetClassSignature(nullptr, &sig, &generic);\n@@ -91,1 +91,1 @@\n-    err = jvmti->GetClassSignature(cls, NULL, &generic);\n+    err = jvmti->GetClassSignature(cls, nullptr, &generic);\n@@ -105,1 +105,1 @@\n-    err = jvmti->GetClassSignature(cls, &sig, NULL);\n+    err = jvmti->GetClassSignature(cls, &sig, nullptr);\n@@ -114,1 +114,1 @@\n-        if (sig == NULL || strcmp(sig, CLASS_SIGNATURE) != 0) {\n+        if (sig == nullptr || strcmp(sig, CLASS_SIGNATURE) != 0) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassSignature\/getclsig005\/getclsig005.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    { \"getclsig006\", \"Lnsk\/jvmti\/GetClassSignature\/getclsig006;\", \"NULL\" },\n+    { \"getclsig006\", \"Lnsk\/jvmti\/GetClassSignature\/getclsig006;\", \"null\" },\n@@ -54,1 +54,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -70,1 +70,1 @@\n-                strcmp(class_sig[idx][2], (gen_sign == NULL) ? \"NULL\" : gen_sign) != 0) {\n+                strcmp(class_sig[idx][2], (gen_sign == nullptr) ? \"null\" : gen_sign) != 0) {\n@@ -78,1 +78,1 @@\n-                sign, (gen_sign == NULL) ? \"NULL\" : gen_sign,\n+                sign, (gen_sign == nullptr) ? \"null\" : gen_sign,\n@@ -84,1 +84,1 @@\n-                sign, (gen_sign == NULL) ? \"NULL\" : gen_sign);\n+                sign, (gen_sign == nullptr) ? \"null\" : gen_sign);\n@@ -90,1 +90,1 @@\n-        if (gen_sign != NULL)\n+        if (gen_sign != nullptr)\n@@ -108,1 +108,1 @@\n-        if (!NSK_JNI_VERIFY(jni, (testedCls = jni->FindClass(class_sig[i][1])) != NULL)) {\n+        if (!NSK_JNI_VERIFY(jni, (testedCls = jni->FindClass(class_sig[i][1])) != nullptr)) {\n@@ -140,1 +140,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassSignature\/getclsig006\/getclsig006.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -72,1 +72,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -80,1 +80,1 @@\n-    err = jvmti->GetClassStatus(NULL, &status);\n+    err = jvmti->GetClassStatus(nullptr, &status);\n@@ -90,1 +90,1 @@\n-    err = jvmti->GetClassStatus(cls, NULL);\n+    err = jvmti->GetClassStatus(cls, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassStatus\/getclstat005\/getclstat005.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -63,1 +63,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -68,1 +68,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -81,1 +81,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassStatus\/getclstat006\/getclstat006.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetClassStatus\/getclstat007\/getclstat007.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-    if (prevTime != NULL) {\n+    if (prevTime != nullptr) {\n@@ -150,1 +150,1 @@\n-        if (!checkCpuTime(jvmti, testAgentThread, &prevAgentThreadTime, NULL, \"agent thread\")) {\n+        if (!checkCpuTime(jvmti, testAgentThread, &prevAgentThreadTime, nullptr, \"agent thread\")) {\n@@ -160,1 +160,1 @@\n-        if (nsk_jvmti_enableEvents(JVMTI_ENABLE, THREAD_EVENTS_COUNT, threadEvents, NULL)) {\n+        if (nsk_jvmti_enableEvents(JVMTI_ENABLE, THREAD_EVENTS_COUNT, threadEvents, nullptr)) {\n@@ -187,1 +187,1 @@\n-        if (nsk_jvmti_enableEvents(JVMTI_DISABLE, THREAD_EVENTS_COUNT, threadEvents, NULL)) {\n+        if (nsk_jvmti_enableEvents(JVMTI_DISABLE, THREAD_EVENTS_COUNT, threadEvents, nullptr)) {\n@@ -217,1 +217,1 @@\n-        if (!checkCpuTime(jvmti, thread, &time, NULL, \"VM_INIT callback\")) {\n+        if (!checkCpuTime(jvmti, thread, &time, nullptr, \"VM_INIT callback\")) {\n@@ -233,1 +233,1 @@\n-        if (!checkCpuTime(jvmti, NULL, &time, NULL, \"VM_DEATH callback\")) {\n+        if (!checkCpuTime(jvmti, nullptr, &time, nullptr, \"VM_DEATH callback\")) {\n@@ -240,1 +240,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -269,1 +269,1 @@\n-    if (threadInfo.name != NULL && strcmp(threadInfo.name, TESTED_THREAD_NAME) == 0) {\n+    if (threadInfo.name != nullptr && strcmp(threadInfo.name, TESTED_THREAD_NAME) == 0) {\n@@ -271,1 +271,1 @@\n-        if (!checkCpuTime(jvmti, thread, &prevTestedThreadTime, NULL, \"THREAD_START callback\")) {\n+        if (!checkCpuTime(jvmti, thread, &prevTestedThreadTime, nullptr, \"THREAD_START callback\")) {\n@@ -292,1 +292,1 @@\n-    if (threadInfo.name != NULL && strcmp(threadInfo.name, TESTED_THREAD_NAME) == 0) {\n+    if (threadInfo.name != nullptr && strcmp(threadInfo.name, TESTED_THREAD_NAME) == 0) {\n@@ -316,1 +316,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -328,1 +328,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -358,1 +358,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -362,1 +362,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentThreadCpuTime\/curthrcputime001\/curthrcputime001.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-    if (initInfo != NULL) {\n+    if (initInfo != nullptr) {\n@@ -135,1 +135,1 @@\n-        if (nsk_jvmti_enableEvents(JVMTI_ENABLE, THREAD_EVENTS_COUNT, threadEvents, NULL)) {\n+        if (nsk_jvmti_enableEvents(JVMTI_ENABLE, THREAD_EVENTS_COUNT, threadEvents, nullptr)) {\n@@ -146,1 +146,1 @@\n-        if (nsk_jvmti_enableEvents(JVMTI_DISABLE, THREAD_EVENTS_COUNT, threadEvents, NULL)) {\n+        if (nsk_jvmti_enableEvents(JVMTI_DISABLE, THREAD_EVENTS_COUNT, threadEvents, nullptr)) {\n@@ -166,1 +166,1 @@\n-        if (!checkTimerInfo(jvmti, &initInfo, NULL, \"VM_INIT callback\")) {\n+        if (!checkTimerInfo(jvmti, &initInfo, nullptr, \"VM_INIT callback\")) {\n@@ -186,1 +186,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -245,1 +245,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -253,1 +253,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -285,1 +285,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -289,1 +289,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentThreadCpuTimerInfo\/curthrtimerinfo001\/curthrtimerinfo001.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-    if (vm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1) != JNI_OK || jvmti == NULL) {\n+    if (vm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1) != JNI_OK || jvmti == nullptr) {\n@@ -112,1 +112,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetEnv\/GetEnv001\/GetEnv001.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    void* storage = NULL;\n+    void* storage = nullptr;\n@@ -61,2 +61,2 @@\n-    if (storage != NULL) {\n-        NSK_COMPLAIN2(\"GetEnvironmentLocalStorage() returned NOT NULL storage in %s:\\n\"\n+    if (storage != nullptr) {\n+        NSK_COMPLAIN2(\"GetEnvironmentLocalStorage() returned NOT null storage in %s:\\n\"\n@@ -116,1 +116,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -143,1 +143,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -151,1 +151,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -166,1 +166,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -175,1 +175,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetEnvironmentLocalStorage\/getenvstor001\/getenvstor001.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -256,1 +256,1 @@\n-    jvmtiEnv *jvmti = NULL;\n+    jvmtiEnv *jvmti = nullptr;\n@@ -268,1 +268,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -293,1 +293,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr)))\n@@ -298,1 +298,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n@@ -302,1 +302,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetErrorName\/geterrname001\/geterrname001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-                               jvmti->GetErrorName(JVMTI_ERROR_NONE, NULL)))\n+                               jvmti->GetErrorName(JVMTI_ERROR_NONE, nullptr)))\n@@ -79,1 +79,1 @@\n-    jvmtiEnv *jvmti = NULL;\n+    jvmtiEnv *jvmti = nullptr;\n@@ -92,1 +92,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -96,1 +96,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetErrorName\/geterrname002\/geterrname002.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    jvmtiExtensionEventInfo* extList = NULL;\n+    jvmtiExtensionEventInfo* extList = nullptr;\n@@ -64,2 +64,2 @@\n-        if (extList == NULL) {\n-            NSK_COMPLAIN3(\"In %s phase GetExtensionEvents() returned NULL pointer:\\n\"\n+        if (extList == nullptr) {\n+            NSK_COMPLAIN3(\"In %s phase GetExtensionEvents() returned null pointer:\\n\"\n@@ -83,1 +83,1 @@\n-            if (extList[i].params != NULL) {\n+            if (extList[i].params != nullptr) {\n@@ -97,4 +97,4 @@\n-            if (extList[i].id == NULL\n-                    || extList[i].short_description == NULL\n-                    || (extList[i].params == NULL && extList[i].param_count > 0)) {\n-                NSK_COMPLAIN9(\"In %s phase GetExtensionEvents() returned event #%d with NULL attribute(s):\\n\"\n+            if (extList[i].id == nullptr\n+                    || extList[i].short_description == nullptr\n+                    || (extList[i].params == nullptr && extList[i].param_count > 0)) {\n+                NSK_COMPLAIN9(\"In %s phase GetExtensionEvents() returned event #%d with null attribute(s):\\n\"\n@@ -114,1 +114,1 @@\n-            if (extList[i].id != NULL && strlen(extList[i].id) <= 0) {\n+            if (extList[i].id != nullptr && strlen(extList[i].id) <= 0) {\n@@ -126,1 +126,1 @@\n-            } else if (strstr(extList[i].id, NAME_PREFIX) == NULL) {\n+            } else if (strstr(extList[i].id, NAME_PREFIX) == nullptr) {\n@@ -140,1 +140,1 @@\n-            if (extList[i].short_description != NULL && strlen(extList[i].short_description) <= 0) {\n+            if (extList[i].short_description != nullptr && strlen(extList[i].short_description) <= 0) {\n@@ -154,1 +154,1 @@\n-            if (extList[i].param_count > 0 && extList[i].params != NULL) {\n+            if (extList[i].param_count > 0 && extList[i].params != nullptr) {\n@@ -156,1 +156,1 @@\n-                    if (extList[i].params[j].name == NULL\n+                    if (extList[i].params[j].name == nullptr\n@@ -265,1 +265,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -273,1 +273,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -283,1 +283,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetExtensionEvents\/extevents001\/extevents001.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-    jvmtiExtensionFunctionInfo* extList = NULL;\n+    jvmtiExtensionFunctionInfo* extList = nullptr;\n@@ -63,2 +63,2 @@\n-        if (extList == NULL) {\n-            NSK_COMPLAIN3(\"In %s phase GetExtensionFunctions() returned NULL pointer:\\n\"\n+        if (extList == nullptr) {\n+            NSK_COMPLAIN3(\"In %s phase GetExtensionFunctions() returned null pointer:\\n\"\n@@ -82,1 +82,1 @@\n-            if (extList[i].params != NULL) {\n+            if (extList[i].params != nullptr) {\n@@ -99,1 +99,1 @@\n-            if (extList[i].errors != NULL) {\n+            if (extList[i].errors != nullptr) {\n@@ -106,6 +106,6 @@\n-            if (extList[i].func == NULL\n-                    || extList[i].id == NULL\n-                    || extList[i].short_description == NULL\n-                    || (extList[i].params == NULL && extList[i].param_count > 0)\n-                    || (extList[i].errors == NULL && extList[i].error_count > 0)) {\n-                NSK_COMPLAIN9(\"In %s phase GetExtensionFunctions() returned function #%d with NULL attribute(s):\\n\"\n+            if (extList[i].func == nullptr\n+                    || extList[i].id == nullptr\n+                    || extList[i].short_description == nullptr\n+                    || (extList[i].params == nullptr && extList[i].param_count > 0)\n+                    || (extList[i].errors == nullptr && extList[i].error_count > 0)) {\n+                NSK_COMPLAIN9(\"In %s phase GetExtensionFunctions() returned function #%d with null attribute(s):\\n\"\n@@ -125,1 +125,1 @@\n-            if (extList[i].id != NULL && strlen(extList[i].id) <= 0) {\n+            if (extList[i].id != nullptr && strlen(extList[i].id) <= 0) {\n@@ -137,1 +137,1 @@\n-            } else if (strstr(extList[i].id, NAME_PREFIX) == NULL) {\n+            } else if (strstr(extList[i].id, NAME_PREFIX) == nullptr) {\n@@ -151,1 +151,1 @@\n-            if (extList[i].short_description != NULL && strlen(extList[i].short_description) <= 0) {\n+            if (extList[i].short_description != nullptr && strlen(extList[i].short_description) <= 0) {\n@@ -165,1 +165,1 @@\n-            if (extList[i].param_count > 0 && extList[i].params != NULL) {\n+            if (extList[i].param_count > 0 && extList[i].params != nullptr) {\n@@ -167,1 +167,1 @@\n-                    if (extList[i].params[j].name == NULL\n+                    if (extList[i].params[j].name == nullptr\n@@ -276,1 +276,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -284,1 +284,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -294,1 +294,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetExtensionFunctions\/extfuncs001\/extfuncs001.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -55,1 +55,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -60,1 +60,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -76,1 +76,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -87,1 +87,1 @@\n-    if (fid == NULL) {\n+    if (fid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFieldDeclaringClass\/getfldecl001\/getfldecl001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -55,1 +55,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -60,1 +60,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -76,1 +76,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -87,1 +87,1 @@\n-    if (fid == NULL) {\n+    if (fid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFieldDeclaringClass\/getfldecl002\/getfldecl002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -74,1 +74,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -79,1 +79,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -95,1 +95,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -106,1 +106,1 @@\n-    if (fid == NULL) {\n+    if (fid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFieldDeclaringClass\/getfldecl004\/getfldecl004.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -79,1 +79,1 @@\n-    if (fid == NULL) {\n+    if (fid == nullptr) {\n@@ -87,1 +87,1 @@\n-    err = jvmti->GetFieldModifiers(NULL, fid, &modifiers);\n+    err = jvmti->GetFieldModifiers(nullptr, fid, &modifiers);\n@@ -97,1 +97,1 @@\n-    err = jvmti->GetFieldModifiers(cls, NULL, &modifiers);\n+    err = jvmti->GetFieldModifiers(cls, nullptr, &modifiers);\n@@ -107,1 +107,1 @@\n-    err = jvmti->GetFieldModifiers(cls, fid, NULL);\n+    err = jvmti->GetFieldModifiers(cls, fid, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFieldModifiers\/getfldmdf003\/getfldmdf003.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -123,1 +123,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -128,1 +128,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -158,1 +158,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -169,1 +169,1 @@\n-    if (fid == NULL) {\n+    if (fid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFieldModifiers\/getfldmdf004\/getfldmdf004.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -79,1 +79,1 @@\n-    if (field == NULL) {\n+    if (field == nullptr) {\n@@ -87,1 +87,1 @@\n-    err = jvmti->GetFieldName(NULL, field, &name, &sig, &generic);\n+    err = jvmti->GetFieldName(nullptr, field, &name, &sig, &generic);\n@@ -97,1 +97,1 @@\n-    err = jvmti->GetFieldName(cls, NULL, &name, &sig, &generic);\n+    err = jvmti->GetFieldName(cls, nullptr, &name, &sig, &generic);\n@@ -107,1 +107,1 @@\n-    err = jvmti->GetFieldName(cls, field, NULL, &sig, &generic);\n+    err = jvmti->GetFieldName(cls, field, nullptr, &sig, &generic);\n@@ -116,1 +116,1 @@\n-        if (sig == NULL || strcmp(sig, \"I\") != 0) {\n+        if (sig == nullptr || strcmp(sig, \"I\") != 0) {\n@@ -125,1 +125,1 @@\n-    err = jvmti->GetFieldName(cls, field, &name, NULL, &generic);\n+    err = jvmti->GetFieldName(cls, field, &name, nullptr, &generic);\n@@ -134,1 +134,1 @@\n-        if (name == NULL || strcmp(name, \"fld\") != 0) {\n+        if (name == nullptr || strcmp(name, \"fld\") != 0) {\n@@ -143,1 +143,1 @@\n-    err = jvmti->GetFieldName(cls, field, &name, &sig, NULL);\n+    err = jvmti->GetFieldName(cls, field, &name, &sig, nullptr);\n@@ -152,1 +152,1 @@\n-        if (name == NULL || strcmp(name, \"fld\") != 0) {\n+        if (name == nullptr || strcmp(name, \"fld\") != 0) {\n@@ -156,1 +156,1 @@\n-        if (sig == NULL || strcmp(sig, \"I\") != 0) {\n+        if (sig == nullptr || strcmp(sig, \"I\") != 0) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFieldName\/getfldnm003\/getfldnm003.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -84,1 +84,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -89,1 +89,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -105,1 +105,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -118,1 +118,1 @@\n-        if (fid == NULL) {\n+        if (fid == nullptr) {\n@@ -134,1 +134,1 @@\n-        if (name == NULL || strcmp(name, fields[i].name) != 0) {\n+        if (name == nullptr || strcmp(name, fields[i].name) != 0) {\n@@ -139,1 +139,1 @@\n-        if (sig == NULL || strcmp(sig, fields[i].sig) != 0) {\n+        if (sig == nullptr || strcmp(sig, fields[i].sig) != 0) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFieldName\/getfldnm004\/getfldnm004.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-      \"Lnsk\/jvmti\/GetFieldName\/getfldnm005;\", \"NULL\" },\n+      \"Lnsk\/jvmti\/GetFieldName\/getfldnm005;\", \"null\" },\n@@ -62,1 +62,1 @@\n-      \"NULL\" },\n+      \"null\" },\n@@ -65,1 +65,1 @@\n-      \"NULL\" },\n+      \"null\" },\n@@ -83,1 +83,1 @@\n-      \"NULL\" }\n+      \"null\" }\n@@ -86,1 +86,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -104,1 +104,1 @@\n-                strcmp(fld_sig[idx][3], (gen_sign == NULL) ? \"NULL\" : gen_sign) != 0) {\n+                strcmp(fld_sig[idx][3], (gen_sign == nullptr) ? \"null\" : gen_sign) != 0) {\n@@ -113,1 +113,1 @@\n-                sign, (gen_sign == NULL) ? \"NULL\" : gen_sign,\n+                sign, (gen_sign == nullptr) ? \"null\" : gen_sign,\n@@ -119,1 +119,1 @@\n-                sign, (gen_sign == NULL) ? \"NULL\" : gen_sign);\n+                sign, (gen_sign == nullptr) ? \"null\" : gen_sign);\n@@ -126,1 +126,1 @@\n-        if (gen_sign != NULL)\n+        if (gen_sign != nullptr)\n@@ -138,1 +138,1 @@\n-    jfieldID testedFld = NULL;\n+    jfieldID testedFld = nullptr;\n@@ -148,1 +148,1 @@\n-            if (!NSK_JNI_VERIFY(jni, (testedFld = jni->GetFieldID(objCls, fld_sig[i][0], fld_sig[i][2])) != NULL)) {\n+            if (!NSK_JNI_VERIFY(jni, (testedFld = jni->GetFieldID(objCls, fld_sig[i][0], fld_sig[i][2])) != nullptr)) {\n@@ -156,1 +156,1 @@\n-            if (!NSK_JNI_VERIFY(jni, (testedFld = jni->GetStaticFieldID(objCls, fld_sig[i][0], fld_sig[i][2])) != NULL)) {\n+            if (!NSK_JNI_VERIFY(jni, (testedFld = jni->GetStaticFieldID(objCls, fld_sig[i][0], fld_sig[i][2])) != nullptr)) {\n@@ -192,1 +192,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFieldName\/getfldnm005\/getfldnm005.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -81,1 +81,1 @@\n-    err = jvmti->GetImplementedInterfaces(NULL, &icount, &interfaces);\n+    err = jvmti->GetImplementedInterfaces(nullptr, &icount, &interfaces);\n@@ -91,1 +91,1 @@\n-    err = jvmti->GetImplementedInterfaces(cls, NULL, &interfaces);\n+    err = jvmti->GetImplementedInterfaces(cls, nullptr, &interfaces);\n@@ -101,1 +101,1 @@\n-    err = jvmti->GetImplementedInterfaces(cls, &icount, NULL);\n+    err = jvmti->GetImplementedInterfaces(cls, &icount, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetImplementedInterfaces\/getintrf005\/getintrf005.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetImplementedInterfaces\/getintrf006\/getintrf006.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -71,2 +71,2 @@\n-    { \"InnerClass1\", 0, NULL },\n-    { \"InnerInterface1\", 0, NULL },\n+    { \"InnerClass1\", 0, nullptr },\n+    { \"InnerInterface1\", 0, nullptr },\n@@ -75,3 +75,3 @@\n-    { \"OuterClass1\", 0, NULL },\n-    { \"OuterClass2\", 0, NULL },\n-    { \"OuterInterface1\", 0, NULL },\n+    { \"OuterClass1\", 0, nullptr },\n+    { \"OuterClass2\", 0, nullptr },\n+    { \"OuterInterface1\", 0, nullptr },\n@@ -81,1 +81,1 @@\n-    { \"OuterClass5\", 0, NULL }\n+    { \"OuterClass5\", 0, nullptr }\n@@ -98,1 +98,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -103,1 +103,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -119,1 +119,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -144,1 +144,1 @@\n-        if (interfaces[j] == NULL) {\n+        if (interfaces[j] == nullptr) {\n@@ -156,1 +156,1 @@\n-                if ((j < classes[i].icount) && (sig == NULL ||\n+                if ((j < classes[i].icount) && (sig == nullptr ||\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetImplementedInterfaces\/getintrf007\/getintrf007.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,1 +159,1 @@\n-    jvmtiEnv *jvmti = NULL;\n+    jvmtiEnv *jvmti = nullptr;\n@@ -172,1 +172,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -202,1 +202,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr)))\n@@ -207,1 +207,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n@@ -211,1 +211,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetJLocationFormat\/getjlocfmt001\/getjlocfmt001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,2 +48,2 @@\n-    NSK_DISPLAY0(\"Check if GetJLocationFormat(NULL) returns JVMTI_ERROR_NULL_POINTER\\n\");\n-    if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_NULL_POINTER, jvmti->GetJLocationFormat(NULL)))\n+    NSK_DISPLAY0(\"Check if GetJLocationFormat(null) returns JVMTI_ERROR_NULL_POINTER\\n\");\n+    if (!NSK_JVMTI_VERIFY_CODE(JVMTI_ERROR_NULL_POINTER, jvmti->GetJLocationFormat(nullptr)))\n@@ -72,1 +72,1 @@\n-    jvmtiEnv *jvmti = NULL;\n+    jvmtiEnv *jvmti = nullptr;\n@@ -85,1 +85,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -89,1 +89,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetJLocationFormat\/getjlocfmt002\/getjlocfmt002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -48,1 +48,1 @@\n-static jniNativeInterface *orig_jni_functions = NULL;\n+static jniNativeInterface *orig_jni_functions = nullptr;\n@@ -51,1 +51,1 @@\n-static jniNativeInterface *redir_jni_functions = NULL;\n+static jniNativeInterface *redir_jni_functions = nullptr;\n@@ -123,1 +123,1 @@\n-    jniNativeInterface *tested_jni_functions = NULL;\n+    jniNativeInterface *tested_jni_functions = nullptr;\n@@ -159,1 +159,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -194,1 +194,1 @@\n-    if (options != NULL && strcmp(options, \"-verbose\") == 0)\n+    if (options != nullptr && strcmp(options, \"-verbose\") == 0)\n@@ -201,1 +201,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetJNIFunctionTable\/getjniftab001\/getjniftab001.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jniNativeInterface *orig_jni_functions = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jniNativeInterface *orig_jni_functions = nullptr;\n@@ -49,1 +49,1 @@\n-    err = jvmti->GetJNIFunctionTable((exError == JVMTI_ERROR_NULL_POINTER) ? NULL : &orig_jni_functions);\n+    err = jvmti->GetJNIFunctionTable((exError == JVMTI_ERROR_NULL_POINTER) ? nullptr : &orig_jni_functions);\n@@ -64,1 +64,1 @@\n-    JNIEnv *nextEnv = NULL;\n+    JNIEnv *nextEnv = nullptr;\n@@ -66,1 +66,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -118,1 +118,1 @@\n-    if (options != NULL && strcmp(options, \"-verbose\") == 0)\n+    if (options != nullptr && strcmp(options, \"-verbose\") == 0)\n@@ -125,1 +125,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetJNIFunctionTable\/getjniftab002\/getjniftab002.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,2 @@\n-    if (mid == NULL) {\n-        printf(\"Name = %s, sig = %s: mid = NULL\\n\", name, sig);\n+    if (mid == nullptr) {\n+        printf(\"Name = %s, sig = %s: mid = null\\n\", name, sig);\n@@ -135,1 +135,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetLineNumberTable\/linetab001\/linetab001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -101,1 +101,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -111,1 +111,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -119,1 +119,1 @@\n-    err = jvmti->GetLineNumberTable(NULL, &entryCount, &table);\n+    err = jvmti->GetLineNumberTable(nullptr, &entryCount, &table);\n@@ -129,1 +129,1 @@\n-    err = jvmti->GetLineNumberTable(mid, NULL, &table);\n+    err = jvmti->GetLineNumberTable(mid, nullptr, &table);\n@@ -139,1 +139,1 @@\n-    err = jvmti->GetLineNumberTable(mid, &entryCount, NULL);\n+    err = jvmti->GetLineNumberTable(mid, &entryCount, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetLineNumberTable\/linetab002\/linetab002.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -102,1 +102,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -112,1 +112,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetLineNumberTable\/linetab003\/linetab003.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -72,1 +72,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -80,1 +80,1 @@\n-    err = jvmti->GetLoadedClasses(NULL, &classes);\n+    err = jvmti->GetLoadedClasses(nullptr, &classes);\n@@ -90,1 +90,1 @@\n-    err = jvmti->GetLoadedClasses(&classCount, NULL);\n+    err = jvmti->GetLoadedClasses(&classCount, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetLoadedClasses\/loadedclss001\/loadedclss001.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,3 @@\n-static jobject testedClassLoader = NULL;\n-static jclass testedClass = NULL;\n-static jfieldID testedFieldID = NULL;\n+static jobject testedClassLoader = nullptr;\n+static jclass testedClass = nullptr;\n+static jfieldID testedFieldID = nullptr;\n@@ -66,1 +66,1 @@\n-        if (signature != NULL && strcmp(signature, exp_sig) == 0) {\n+        if (signature != nullptr && strcmp(signature, exp_sig) == 0) {\n@@ -71,1 +71,1 @@\n-        if (signature != NULL)\n+        if (signature != nullptr)\n@@ -74,1 +74,1 @@\n-        if (generic != NULL)\n+        if (generic != nullptr)\n@@ -103,1 +103,1 @@\n-    if (!NSK_VERIFY(classes != NULL)) {\n+    if (!NSK_VERIFY(classes != nullptr)) {\n@@ -124,1 +124,1 @@\n-    if (classes != NULL)\n+    if (classes != nullptr)\n@@ -146,1 +146,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -156,1 +156,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -159,1 +159,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetLoadedClasses\/loadedclss002\/loadedclss002.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,1 +149,1 @@\n-    jobject ob1 = NULL, ob2 = NULL;\n+    jobject ob1 = nullptr, ob2 = nullptr;\n@@ -174,1 +174,1 @@\n-            if (fid == NULL) {\n+            if (fid == nullptr) {\n@@ -287,1 +287,1 @@\n-    jvmtiLocalVariableEntry *table = NULL;\n+    jvmtiLocalVariableEntry *table = nullptr;\n@@ -310,1 +310,1 @@\n-            mid2 = NULL;\n+            mid2 = nullptr;\n@@ -323,1 +323,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -335,1 +335,1 @@\n-    jvmtiLocalVariableEntry *table = NULL;\n+    jvmtiLocalVariableEntry *table = nullptr;\n@@ -379,1 +379,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -403,1 +403,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -408,1 +408,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -477,1 +477,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, nullptr);\n@@ -490,1 +490,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetLocalVariable\/getlocal001\/getlocal001.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -41,1 +41,1 @@\n-static jmethodID mid = NULL;\n+static jmethodID mid = nullptr;\n@@ -55,1 +55,1 @@\n-            JVMTI_EVENT_METHOD_EXIT, NULL);\n+            JVMTI_EVENT_METHOD_EXIT, nullptr);\n@@ -101,1 +101,1 @@\n-                err = jvmti->GetLocalFloat(thr, 0, table[i].slot, NULL);\n+                err = jvmti->GetLocalFloat(thr, 0, table[i].slot, nullptr);\n@@ -132,1 +132,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -137,1 +137,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -184,1 +184,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -194,1 +194,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -201,1 +201,1 @@\n-        JVMTI_EVENT_METHOD_EXIT, NULL);\n+        JVMTI_EVENT_METHOD_EXIT, nullptr);\n@@ -218,1 +218,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -223,1 +223,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetLocalVariable\/getlocal002\/getlocal002.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,4 +45,4 @@\n-    { 0, 21, (char*) \"this\", (char*) \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab001;\", NULL, 0 },\n-    { 4, 17, (char*) \"l\",    (char*) \"J\", NULL, 1 },\n-    { 7, 14, (char*) \"f\",    (char*) \"F\", NULL, 2 },\n-    { 12, 9, (char*) \"d\",    (char*) \"D\", NULL, 3 }\n+    { 0, 21, (char*) \"this\", (char*) \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab001;\", nullptr, 0 },\n+    { 4, 17, (char*) \"l\",    (char*) \"J\", nullptr, 1 },\n+    { 7, 14, (char*) \"f\",    (char*) \"F\", nullptr, 2 },\n+    { 12, 9, (char*) \"d\",    (char*) \"D\", nullptr, 3 }\n@@ -51,7 +51,7 @@\n-    { 0, 32, (char*) \"this\", (char*) \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab001;\", NULL, 0 },\n-    { 0, 32, (char*) \"step\", (char*) \"I\", NULL, 1 },\n-    { 2, 29, (char*) \"i2\",   (char*) \"S\", NULL, 2 },\n-    { 4, 27, (char*) \"i3\",   (char*) \"C\", NULL, 3 },\n-    { 7, 24, (char*) \"i4\",   (char*) \"B\", NULL, 4 },\n-    { 10,21, (char*) \"i5\",   (char*) \"Z\", NULL, 5 },\n-    { 13,18, (char*) \"i1\",   (char*) \"I\", NULL, 6 }\n+    { 0, 32, (char*) \"this\", (char*) \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab001;\", nullptr, 0 },\n+    { 0, 32, (char*) \"step\", (char*) \"I\", nullptr, 1 },\n+    { 2, 29, (char*) \"i2\",   (char*) \"S\", nullptr, 2 },\n+    { 4, 27, (char*) \"i3\",   (char*) \"C\", nullptr, 3 },\n+    { 7, 24, (char*) \"i4\",   (char*) \"B\", nullptr, 4 },\n+    { 10,21, (char*) \"i5\",   (char*) \"Z\", nullptr, 5 },\n+    { 13,18, (char*) \"i1\",   (char*) \"I\", nullptr, 6 }\n@@ -60,5 +60,5 @@\n-    { 0, 70, (char*) \"ob\",  (char*) \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab001;\", NULL, 0 },\n-    { 2, 67, (char*) \"ob1\", (char*) \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab001;\", NULL, 1 },\n-    { 56,13, (char*) \"ob2\", (char*) \"[I\", NULL, 2 },\n-    { 61, 0, (char*) \"i\",   (char*) \"I\", NULL, 3 },\n-    { 64, 5, (char*) \"e\",   (char*) \"Ljava\/lang\/IndexOutOfBoundsException;\", NULL, 4 }\n+    { 0, 70, (char*) \"ob\",  (char*) \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab001;\", nullptr, 0 },\n+    { 2, 67, (char*) \"ob1\", (char*) \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab001;\", nullptr, 1 },\n+    { 56,13, (char*) \"ob2\", (char*) \"[I\", nullptr, 2 },\n+    { 61, 0, (char*) \"i\",   (char*) \"I\", nullptr, 3 },\n+    { 64, 5, (char*) \"e\",   (char*) \"Ljava\/lang\/IndexOutOfBoundsException;\", nullptr, 4 }\n@@ -67,8 +67,8 @@\n-    { 0, 33, (char*) \"i1\", (char*) \"I\", NULL, 0 },\n-    { 0, 33, (char*) \"l\",  (char*) \"J\", NULL, 1 },\n-    { 0, 33, (char*) \"i2\", (char*) \"S\", NULL, 2 },\n-    { 0, 33, (char*) \"d\",  (char*) \"D\", NULL, 3 },\n-    { 0, 33, (char*) \"i3\", (char*) \"C\", NULL, 4 },\n-    { 0, 33, (char*) \"f\",  (char*) \"F\", NULL, 5 },\n-    { 0, 33, (char*) \"i4\", (char*) \"B\", NULL, 6 },\n-    { 0, 33, (char*) \"b\",  (char*) \"Z\", NULL, 7 }\n+    { 0, 33, (char*) \"i1\", (char*) \"I\", nullptr, 0 },\n+    { 0, 33, (char*) \"l\",  (char*) \"J\", nullptr, 1 },\n+    { 0, 33, (char*) \"i2\", (char*) \"S\", nullptr, 2 },\n+    { 0, 33, (char*) \"d\",  (char*) \"D\", nullptr, 3 },\n+    { 0, 33, (char*) \"i3\", (char*) \"C\", nullptr, 4 },\n+    { 0, 33, (char*) \"f\",  (char*) \"F\", nullptr, 5 },\n+    { 0, 33, (char*) \"i4\", (char*) \"B\", nullptr, 6 },\n+    { 0, 33, (char*) \"b\",  (char*) \"Z\", nullptr, 7 }\n@@ -77,3 +77,3 @@\n-    { 0, 6, (char*) \"this\", (char*) \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab001;\", NULL, 0 },\n-    { 0, 6, (char*) \"i\",    (char*) \"I\", NULL, 1 },\n-    { 2, 4, (char*) \"i12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678\", (char*) \"I\", NULL, 2 }\n+    { 0, 6, (char*) \"this\", (char*) \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab001;\", nullptr, 0 },\n+    { 0, 6, (char*) \"i\",    (char*) \"I\", nullptr, 1 },\n+    { 2, 4, (char*) \"i12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678\", (char*) \"I\", nullptr, 2 }\n@@ -82,1 +82,1 @@\n-    { 0, 5, (char*) \"this\", (char*) \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab001;\", NULL, 0 },\n+    { 0, 5, (char*) \"this\", (char*) \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab001;\", nullptr, 0 },\n@@ -85,1 +85,1 @@\n-    { 0, NULL },\n+    { 0, nullptr },\n@@ -109,2 +109,2 @@\n-    if (mid == NULL) {\n-        printf(\"Name = %s, sig = %s: mid = NULL\\n\", name, sig);\n+    if (mid == nullptr) {\n+        printf(\"Name = %s, sig = %s: mid = null\\n\", name, sig);\n@@ -197,1 +197,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetLocalVariableTable\/localtab001\/localtab001.cpp","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -101,1 +101,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -109,1 +109,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -117,1 +117,1 @@\n-    err = jvmti->GetLocalVariableTable(NULL, &entryCount, &table);\n+    err = jvmti->GetLocalVariableTable(nullptr, &entryCount, &table);\n@@ -127,1 +127,1 @@\n-    err = jvmti->GetLocalVariableTable(mid, NULL, &table);\n+    err = jvmti->GetLocalVariableTable(mid, nullptr, &table);\n@@ -137,1 +137,1 @@\n-    err = jvmti->GetLocalVariableTable(mid, &entryCount, NULL);\n+    err = jvmti->GetLocalVariableTable(mid, &entryCount, nullptr);\n@@ -145,1 +145,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetLocalVariableTable\/localtab002\/localtab002.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -102,1 +102,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -110,1 +110,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetLocalVariableTable\/localtab003\/localtab003.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,3 +84,3 @@\n-    { 1, (char*) \"<init>\", (char*) \"()V\", 6, constr_lv, NULL },\n-    { 1, (char*) \"finMethod\", (char*) \"(CJIJ)V\", 7, finMeth_lv, NULL },\n-    { 0, (char*) \"statMethod\", (char*) \"(III)D\", 5, statMeth_lv, NULL }\n+    { 1, (char*) \"<init>\", (char*) \"()V\", 6, constr_lv, nullptr },\n+    { 1, (char*) \"finMethod\", (char*) \"(CJIJ)V\", 7, finMeth_lv, nullptr },\n+    { 0, (char*) \"statMethod\", (char*) \"(III)D\", 5, statMeth_lv, nullptr }\n@@ -89,1 +89,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -105,1 +105,1 @@\n-        if (methInfo[i].mid == NULL) {\n+        if (methInfo[i].mid == nullptr) {\n@@ -199,1 +199,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetLocalVariableTable\/localtab004\/localtab004.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    { \"this\", \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab005a;\", \"NULL\" },\n+    { \"this\", \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab005a;\", \"null\" },\n@@ -51,1 +51,1 @@\n-    { \"constr_i\", \"I\", \"NULL\" },\n+    { \"constr_i\", \"I\", \"null\" },\n@@ -54,2 +54,2 @@\n-    { \"constr_f\", \"F\", \"NULL\" },\n-    { \"constr_ch\", \"C\", \"NULL\" },\n+    { \"constr_f\", \"F\", \"null\" },\n+    { \"constr_ch\", \"C\", \"null\" },\n@@ -61,3 +61,3 @@\n-    { \"this\", \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab005a;\", \"NULL\" },\n-    { \"ins_c\", \"C\", \"NULL\" },\n-    { \"ins_i\", \"J\", \"NULL\" },\n+    { \"this\", \"Lnsk\/jvmti\/GetLocalVariableTable\/localtab005a;\", \"null\" },\n+    { \"ins_c\", \"C\", \"null\" },\n+    { \"ins_i\", \"J\", \"null\" },\n@@ -66,2 +66,2 @@\n-    { \"ins_k\", \"J\", \"NULL\" },\n-    { \"ins_l\", \"J\", \"NULL\" },\n+    { \"ins_k\", \"J\", \"null\" },\n+    { \"ins_l\", \"J\", \"null\" },\n@@ -73,4 +73,4 @@\n-    { \"stat_x\", \"I\", \"NULL\" },\n-    { \"stat_y\", \"I\", \"NULL\" },\n-    { \"stat_z\", \"I\", \"NULL\" },\n-    { \"stat_j\", \"D\", \"NULL\" },\n+    { \"stat_x\", \"I\", \"null\" },\n+    { \"stat_y\", \"I\", \"null\" },\n+    { \"stat_z\", \"I\", \"null\" },\n+    { \"stat_j\", \"D\", \"null\" },\n@@ -92,3 +92,3 @@\n-    { 1, (char*) \"<init>\", (char*) \"()V\", 7, constr_lv, NULL },\n-    { 1, (char*) \"insMethod\", (char*) \"(CJLnsk\/jvmti\/GetLocalVariableTable\/localtab005d;J)V\", 7, insMeth_lv, NULL },\n-    { 0, (char*) \"statMethod\", (char*) \"(III)D\", 5, statMeth_lv, NULL }\n+    { 1, (char*) \"<init>\", (char*) \"()V\", 7, constr_lv, nullptr },\n+    { 1, (char*) \"insMethod\", (char*) \"(CJLnsk\/jvmti\/GetLocalVariableTable\/localtab005d;J)V\", 7, insMeth_lv, nullptr },\n+    { 0, (char*) \"statMethod\", (char*) \"(III)D\", 5, statMeth_lv, nullptr }\n@@ -97,1 +97,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -113,1 +113,1 @@\n-        if (methInfo[i].mid == NULL) {\n+        if (methInfo[i].mid == nullptr) {\n@@ -140,1 +140,1 @@\n-                       (lv_table[j].generic_signature == NULL) ? \"NULL\" : lv_table[j].generic_signature);\n+                       (lv_table[j].generic_signature == nullptr) ? \"null\" : lv_table[j].generic_signature);\n@@ -158,1 +158,1 @@\n-                            (strcmp((lv_table[j].generic_signature == NULL) ? \"NULL\" : lv_table[j].generic_signature,\n+                            (strcmp((lv_table[j].generic_signature == nullptr) ? \"null\" : lv_table[j].generic_signature,\n@@ -168,1 +168,1 @@\n-                               (lv_table[j].generic_signature == NULL) ? \"NULL\" : lv_table[j].generic_signature,\n+                               (lv_table[j].generic_signature == nullptr) ? \"null\" : lv_table[j].generic_signature,\n@@ -170,1 +170,1 @@\n-                               (methInfo[i].vars[k].v_gen_sign == NULL) ? \"NULL\" : methInfo[i].vars[k].v_gen_sign);\n+                               (methInfo[i].vars[k].v_gen_sign == nullptr) ? \"null\" : methInfo[i].vars[k].v_gen_sign);\n@@ -178,1 +178,1 @@\n-                               (lv_table[j].generic_signature == NULL) ? \"NULL\" : lv_table[j].generic_signature);\n+                               (lv_table[j].generic_signature == nullptr) ? \"null\" : lv_table[j].generic_signature);\n@@ -223,1 +223,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetLocalVariableTable\/localtab005\/localtab005.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -41,1 +41,1 @@\n-    jmethodID mid = NULL;\n+    jmethodID mid = nullptr;\n@@ -49,1 +49,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -80,1 +80,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetMaxLocals\/maxloc001\/maxloc001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -79,1 +79,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -87,1 +87,1 @@\n-    err = jvmti->GetMaxLocals(NULL, &max);\n+    err = jvmti->GetMaxLocals(nullptr, &max);\n@@ -97,1 +97,1 @@\n-    err = jvmti->GetMaxLocals(mid, NULL);\n+    err = jvmti->GetMaxLocals(mid, nullptr);\n@@ -105,1 +105,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetMaxLocals\/maxloc002\/maxloc002.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,2 @@\n-    if (mid == NULL) {\n-        printf(\"%s.%s%s: mid = NULL\\n\", cl_name, name, sig);\n+    if (mid == nullptr) {\n+        printf(\"%s.%s%s: mid = null\\n\", cl_name, name, sig);\n@@ -98,1 +98,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetMethodDeclaringClass\/declcls001\/declcls001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -79,1 +79,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -87,1 +87,1 @@\n-    err = jvmti->GetMethodDeclaringClass(NULL, &declaringClass);\n+    err = jvmti->GetMethodDeclaringClass(nullptr, &declaringClass);\n@@ -97,1 +97,1 @@\n-    err = jvmti->GetMethodDeclaringClass(mid, NULL);\n+    err = jvmti->GetMethodDeclaringClass(mid, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetMethodDeclaringClass\/declcls002\/declcls002.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -58,2 +58,2 @@\n-    if (mid == NULL) {\n-        printf(\"%s.%s%s: mid = NULL\\n\", name, meth, sig);\n+    if (mid == nullptr) {\n+        printf(\"%s.%s%s: mid = null\\n\", name, meth, sig);\n@@ -108,1 +108,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -113,1 +113,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetMethodDeclaringClass\/declcls003\/declcls003.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,2 +62,2 @@\n-    if (mid == NULL) {\n-        printf(\"Name = %s, sig = %s: mid = NULL\\n\", name, sig);\n+    if (mid == nullptr) {\n+        printf(\"Name = %s, sig = %s: mid = null\\n\", name, sig);\n@@ -106,1 +106,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetMethodLocation\/methloc001\/methloc001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -74,1 +74,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -80,1 +80,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -88,1 +88,1 @@\n-    err = jvmti->GetMethodLocation(NULL, &startLocation, &endLocation);\n+    err = jvmti->GetMethodLocation(nullptr, &startLocation, &endLocation);\n@@ -98,1 +98,1 @@\n-    err = jvmti->GetMethodLocation(mid, NULL, &endLocation);\n+    err = jvmti->GetMethodLocation(mid, nullptr, &endLocation);\n@@ -108,1 +108,1 @@\n-    err = jvmti->GetMethodLocation(mid, &startLocation, NULL);\n+    err = jvmti->GetMethodLocation(mid, &startLocation, nullptr);\n@@ -116,1 +116,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetMethodLocation\/methloc002\/methloc002.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -73,1 +73,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -138,1 +138,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -143,1 +143,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -157,1 +157,1 @@\n-        JVMTI_EVENT_CLASS_LOAD, NULL);\n+        JVMTI_EVENT_CLASS_LOAD, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetMethodModifiers\/methmod001\/methmod001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -79,1 +79,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -87,1 +87,1 @@\n-    err = jvmti->GetMethodModifiers(NULL, &modifiers);\n+    err = jvmti->GetMethodModifiers(nullptr, &modifiers);\n@@ -97,1 +97,1 @@\n-    err = jvmti->GetMethodModifiers(mid, NULL);\n+    err = jvmti->GetMethodModifiers(mid, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetMethodModifiers\/methmod002\/methmod002.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -53,1 +53,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -118,1 +118,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -123,1 +123,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -137,1 +137,1 @@\n-        JVMTI_EVENT_CLASS_LOAD, NULL);\n+        JVMTI_EVENT_CLASS_LOAD, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetMethodName\/methname001\/methname001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -79,1 +79,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -87,1 +87,1 @@\n-    err = jvmti->GetMethodName(NULL, &name, &sig, &generic);\n+    err = jvmti->GetMethodName(nullptr, &name, &sig, &generic);\n@@ -97,1 +97,1 @@\n-    err = jvmti->GetMethodName(mid, NULL, &sig, &generic);\n+    err = jvmti->GetMethodName(mid, nullptr, &sig, &generic);\n@@ -106,1 +106,1 @@\n-        if (sig == NULL || strcmp(sig, \"()V\") != 0) {\n+        if (sig == nullptr || strcmp(sig, \"()V\") != 0) {\n@@ -115,1 +115,1 @@\n-    err = jvmti->GetMethodName(mid, &name, NULL, &generic);\n+    err = jvmti->GetMethodName(mid, &name, nullptr, &generic);\n@@ -124,1 +124,1 @@\n-        if (name == NULL || strcmp(name, \"<init>\") != 0) {\n+        if (name == nullptr || strcmp(name, \"<init>\") != 0) {\n@@ -133,1 +133,1 @@\n-    err = jvmti->GetMethodName(mid, &name, &sig, NULL);\n+    err = jvmti->GetMethodName(mid, &name, &sig, nullptr);\n@@ -142,1 +142,1 @@\n-        if (name == NULL || strcmp(name, \"<init>\") != 0) {\n+        if (name == nullptr || strcmp(name, \"<init>\") != 0) {\n@@ -146,1 +146,1 @@\n-        if (sig == NULL || strcmp(sig, \"()V\") != 0) {\n+        if (sig == nullptr || strcmp(sig, \"()V\") != 0) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetMethodName\/methname002\/methname002.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-        \"NULL\" },\n+        \"null\" },\n@@ -66,1 +66,1 @@\n-       \"NULL\" } },\n+       \"null\" } },\n@@ -70,1 +70,1 @@\n-        \"NULL\" },\n+        \"null\" },\n@@ -83,1 +83,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -101,1 +101,1 @@\n-                strcmp(meth_sig[clsIdx][methIdx][3], (gen_sign == NULL) ? \"NULL\" : gen_sign) != 0) {\n+                strcmp(meth_sig[clsIdx][methIdx][3], (gen_sign == nullptr) ? \"null\" : gen_sign) != 0) {\n@@ -105,1 +105,1 @@\n-                sign, (gen_sign == NULL) ? \"NULL\" : gen_sign,\n+                sign, (gen_sign == nullptr) ? \"null\" : gen_sign,\n@@ -111,1 +111,1 @@\n-                sign, (gen_sign == NULL) ? \"NULL\" : gen_sign);\n+                sign, (gen_sign == nullptr) ? \"null\" : gen_sign);\n@@ -120,1 +120,1 @@\n-        if (gen_sign != NULL)\n+        if (gen_sign != nullptr)\n@@ -133,1 +133,1 @@\n-    jmethodID testedMeth = NULL;\n+    jmethodID testedMeth = nullptr;\n@@ -143,1 +143,1 @@\n-            if (!NSK_JNI_VERIFY(jni, (testedMeth = jni->GetMethodID(objCls, meth_sig[clsIdx][i][0], meth_sig[clsIdx][i][2])) != NULL)) {\n+            if (!NSK_JNI_VERIFY(jni, (testedMeth = jni->GetMethodID(objCls, meth_sig[clsIdx][i][0], meth_sig[clsIdx][i][2])) != nullptr)) {\n@@ -151,1 +151,1 @@\n-            if (!NSK_JNI_VERIFY(jni, (testedMeth = jni->GetStaticMethodID(objCls, meth_sig[clsIdx][i][0], meth_sig[clsIdx][i][2])) != NULL)) {\n+            if (!NSK_JNI_VERIFY(jni, (testedMeth = jni->GetStaticMethodID(objCls, meth_sig[clsIdx][i][0], meth_sig[clsIdx][i][2])) != nullptr)) {\n@@ -187,1 +187,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetMethodName\/methname003\/methname003.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        jobject testedObject = NULL;\n+        jobject testedObject = nullptr;\n@@ -59,2 +59,2 @@\n-            jclass debugeeClass = NULL;\n-            jfieldID objectField = NULL;\n+            jclass debugeeClass = nullptr;\n+            jfieldID objectField = nullptr;\n@@ -63,1 +63,1 @@\n-            if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+            if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -71,1 +71,1 @@\n-                    jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, OBJECT_CLASS_SIG)) != NULL)) {\n+                    jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -79,1 +79,1 @@\n-                    jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+                    jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -86,1 +86,1 @@\n-            if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewGlobalRef(testedObject)) != NULL)) {\n+            if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewGlobalRef(testedObject)) != nullptr)) {\n@@ -183,1 +183,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -193,1 +193,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -197,1 +197,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectHashCode\/objhashcode001\/objhashcode001.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -120,1 +120,1 @@\n-        if (inf.owner == NULL) {\n+        if (inf.owner == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage001\/objmonusage001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -100,1 +100,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -108,1 +108,1 @@\n-    err = jvmti->GetObjectMonitorUsage(NULL, &inf);\n+    err = jvmti->GetObjectMonitorUsage(nullptr, &inf);\n@@ -121,1 +121,1 @@\n-    err = jvmti->GetObjectMonitorUsage(obj, NULL);\n+    err = jvmti->GetObjectMonitorUsage(obj, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage002\/objmonusage002.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -57,1 +57,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -62,1 +62,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -119,1 +119,1 @@\n-        if (inf.owner == NULL) {\n+        if (inf.owner == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage003\/objmonusage003.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -57,1 +57,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -62,1 +62,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -119,1 +119,1 @@\n-        if (inf.owner == NULL) {\n+        if (inf.owner == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage004\/objmonusage004.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage005\/objmonusage005.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectMonitorUsage\/objmonusage006\/objmonusage006.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-        jobject testedObject = NULL;\n+        jobject testedObject = nullptr;\n@@ -56,2 +56,2 @@\n-            jclass debugeeClass = NULL;\n-            jfieldID objectField = NULL;\n+            jclass debugeeClass = nullptr;\n+            jfieldID objectField = nullptr;\n@@ -60,1 +60,1 @@\n-            if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+            if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -68,1 +68,1 @@\n-                    jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, OBJECT_CLASS_SIG)) != NULL)) {\n+                    jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -76,1 +76,1 @@\n-                    jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+                    jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -83,1 +83,1 @@\n-            if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewGlobalRef(testedObject)) != NULL)) {\n+            if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewGlobalRef(testedObject)) != nullptr)) {\n@@ -183,1 +183,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -191,1 +191,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -194,1 +194,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectSize\/objsize001\/objsize001.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,3 +59,3 @@\n-    jclass debugeeClass = NULL;\n-    jfieldID objectField = NULL;\n-    jobjectArray arrayObject = NULL;\n+    jclass debugeeClass = nullptr;\n+    jfieldID objectField = nullptr;\n+    jobjectArray arrayObject = nullptr;\n@@ -81,1 +81,1 @@\n-            (*objects)[k] = NULL;\n+            (*objects)[k] = nullptr;\n@@ -90,1 +90,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -98,1 +98,1 @@\n-            jni->GetStaticFieldID(debugeeClass, OBJECTS_FIELD_NAME, OBJECTS_FIELD_SIG)) != NULL)) {\n+            jni->GetStaticFieldID(debugeeClass, OBJECTS_FIELD_NAME, OBJECTS_FIELD_SIG)) != nullptr)) {\n@@ -106,1 +106,1 @@\n-            jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+            jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -124,1 +124,1 @@\n-            jobject object = NULL;\n+            jobject object = nullptr;\n@@ -126,1 +126,1 @@\n-            if (!NSK_JNI_VERIFY(jni, (object = jni->GetObjectArrayElement(arrayObject, k)) != NULL)) {\n+            if (!NSK_JNI_VERIFY(jni, (object = jni->GetObjectArrayElement(arrayObject, k)) != nullptr)) {\n@@ -130,1 +130,1 @@\n-            if (!NSK_JNI_VERIFY(jni, (object = jni->NewGlobalRef(object)) != NULL)) {\n+            if (!NSK_JNI_VERIFY(jni, (object = jni->NewGlobalRef(object)) != nullptr)) {\n@@ -149,1 +149,1 @@\n-    if (objects == NULL)\n+    if (objects == nullptr)\n@@ -154,1 +154,1 @@\n-        if (objects[k] != NULL) {\n+        if (objects[k] != nullptr) {\n@@ -166,1 +166,1 @@\n-    if (tags == NULL)\n+    if (tags == nullptr)\n@@ -183,2 +183,2 @@\n-    jobject* taggedObjectsList = NULL;\n-    jlong* taggedObjectsTags = NULL;\n+    jobject* taggedObjectsList = nullptr;\n+    jlong* taggedObjectsTags = nullptr;\n@@ -204,2 +204,2 @@\n-    if (taggedObjectsList == NULL && taggedObjectsCount > 0) {\n-        NSK_COMPLAIN2(\"GetObjectsWithTags() returns NULL list of objects %s: 0x%p\\n\",\n+    if (taggedObjectsList == nullptr && taggedObjectsCount > 0) {\n+        NSK_COMPLAIN2(\"GetObjectsWithTags() returns null list of objects %s: 0x%p\\n\",\n@@ -211,2 +211,2 @@\n-    if (taggedObjectsTags == NULL && taggedObjectsCount > 0) {\n-        NSK_COMPLAIN2(\"GetObjectsWithTags() returns NULL list of tags for objects %s: 0x%p\\n\",\n+    if (taggedObjectsTags == nullptr && taggedObjectsCount > 0) {\n+        NSK_COMPLAIN2(\"GetObjectsWithTags() returns null list of tags for objects %s: 0x%p\\n\",\n@@ -226,2 +226,2 @@\n-        if (object == NULL) {\n-            NSK_COMPLAIN3(\"GetObjectsWithTags() returns NULL for object #%d %s: 0x%p\\n\",\n+        if (object == nullptr) {\n+            NSK_COMPLAIN3(\"GetObjectsWithTags() returns null for object #%d %s: 0x%p\\n\",\n@@ -309,2 +309,2 @@\n-        jobject* objects = NULL;\n-        jlong* tags = NULL;\n+        jobject* objects = nullptr;\n+        jlong* tags = nullptr;\n@@ -420,1 +420,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -436,1 +436,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -451,1 +451,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetObjectsWithTags\/objwithtags001\/objwithtags001.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -92,1 +92,1 @@\n-    jobject *owned_monitors = NULL;\n+    jobject *owned_monitors = nullptr;\n@@ -103,1 +103,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -109,1 +109,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -126,1 +126,1 @@\n-    if (monitors == NULL) {\n+    if (monitors == nullptr) {\n@@ -140,1 +140,1 @@\n-    if (monitors == NULL) {\n+    if (monitors == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetOwnedMonitorInfo\/ownmoninf001\/ownmoninf001.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetOwnedMonitorInfo\/ownmoninf002\/ownmoninf002.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -101,1 +101,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -123,1 +123,1 @@\n-    err = jvmti->GetOwnedMonitorInfo(thr, NULL, &owned_monitors);\n+    err = jvmti->GetOwnedMonitorInfo(thr, nullptr, &owned_monitors);\n@@ -136,1 +136,1 @@\n-    err = jvmti->GetOwnedMonitorInfo(thr, &owned_monitor_count, NULL);\n+    err = jvmti->GetOwnedMonitorInfo(thr, &owned_monitor_count, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetOwnedMonitorInfo\/ownmoninf003\/ownmoninf003.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -271,1 +271,1 @@\n-    jvmtiEnv *jvmti = NULL;\n+    jvmtiEnv *jvmti = nullptr;\n@@ -287,1 +287,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -322,1 +322,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, nullptr)))\n@@ -327,1 +327,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr)))\n@@ -332,1 +332,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, nullptr)))\n@@ -337,1 +337,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n@@ -342,1 +342,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr)))\n@@ -346,1 +346,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetPhase\/getphase001\/getphase001.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    NSK_DISPLAY0(\"Check if GetPhase(NULL) returns JVMTI_ERROR_NULL_POINTER\\n\");\n+    NSK_DISPLAY0(\"Check if GetPhase(null) returns JVMTI_ERROR_NULL_POINTER\\n\");\n@@ -50,1 +50,1 @@\n-            jvmti->GetPhase(NULL)))\n+            jvmti->GetPhase(nullptr)))\n@@ -73,1 +73,1 @@\n-    jvmtiEnv *jvmti = NULL;\n+    jvmtiEnv *jvmti = nullptr;\n@@ -86,1 +86,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -90,1 +90,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetPhase\/getphase002\/getphase002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,1 +191,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -218,1 +218,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -226,1 +226,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -242,1 +242,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -251,1 +251,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetPotentialCapabilities\/getpotcaps001\/getpotcaps001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -93,1 +93,1 @@\n-    char *srcDebugX = NULL;\n+    char *srcDebugX = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetSourceDebugExtension\/srcdebugex001\/srcdebugex001.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -93,1 +93,1 @@\n-    char *srcDebugX = NULL;\n+    char *srcDebugX = nullptr;\n@@ -99,2 +99,2 @@\n-        case 1: \/* NULL pointer in test debug mode *\/\n-            printf(\"\\nInvoke GetSourceDebugExtension() with NULL pointer...\\n\");\n+        case 1: \/* nullptr pointer in test debug mode *\/\n+            printf(\"\\nInvoke GetSourceDebugExtension() with null pointer...\\n\");\n@@ -103,2 +103,2 @@\n-        case 0: \/* NULL pointer *\/\n-            err = jvmti->GetSourceDebugExtension(cls, NULL);\n+        case 0: \/* nullptr pointer *\/\n+            err = jvmti->GetSourceDebugExtension(cls, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetSourceDebugExtension\/srcdebugex002\/srcdebugex002.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -95,1 +95,1 @@\n-    char *srcDebugX = NULL;\n+    char *srcDebugX = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetSourceDebugExtension\/srcdebugex003\/srcdebugex003.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (code != JNI_OK || jvmti == NULL) {\n+    if (code != JNI_OK || jvmti == nullptr) {\n@@ -99,1 +99,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -107,1 +107,1 @@\n-    err = jvmti->GetSourceFileName(NULL, &name);\n+    err = jvmti->GetSourceFileName(nullptr, &name);\n@@ -121,1 +121,1 @@\n-    err = jvmti->GetSourceFileName(cls, NULL);\n+    err = jvmti->GetSourceFileName(cls, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetSourceFileName\/getsrcfn004\/getsrcfn004.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (code != JNI_OK || jvmti == NULL) {\n+    if (code != JNI_OK || jvmti == nullptr) {\n@@ -99,1 +99,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetSourceFileName\/getsrcfn005\/getsrcfn005.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -62,1 +62,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -67,1 +67,1 @@\n-    if (code != JNI_OK || jvmti == NULL) {\n+    if (code != JNI_OK || jvmti == nullptr) {\n@@ -105,1 +105,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetSourceFileName\/getsrcfn006\/getsrcfn006.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    char** properties = NULL;\n+    char** properties = nullptr;\n@@ -59,2 +59,2 @@\n-    if (properties == NULL) {\n-        NSK_COMPLAIN2(\"In %s phase GetSystemProperties() returned NULL pointer for properties list: 0x%p\\n\",\n+    if (properties == nullptr) {\n+        NSK_COMPLAIN2(\"In %s phase GetSystemProperties() returned null pointer for properties list: 0x%p\\n\",\n@@ -69,2 +69,2 @@\n-            if (properties[i] == NULL) {\n-                NSK_COMPLAIN3(\"In %s phase GetSystemProperties() returned NULL for property #%d: 0x%p\\n\",\n+            if (properties[i] == nullptr) {\n+                NSK_COMPLAIN3(\"In %s phase GetSystemProperties() returned null for property #%d: 0x%p\\n\",\n@@ -121,1 +121,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -129,1 +129,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -137,1 +137,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetSystemProperties\/getsysprops001\/getsysprops001.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-    char** properties = NULL;\n+    char** properties = nullptr;\n@@ -64,1 +64,1 @@\n-    if (!NSK_VERIFY(properties != NULL)) {\n+    if (!NSK_VERIFY(properties != nullptr)) {\n@@ -80,1 +80,1 @@\n-            if (properties[i] != NULL) {\n+            if (properties[i] != nullptr) {\n@@ -153,1 +153,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -161,1 +161,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -169,1 +169,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetSystemProperties\/getsysprops002\/getsysprops002.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    char** properties = NULL;\n+    char** properties = nullptr;\n@@ -50,1 +50,1 @@\n-    if (!NSK_VERIFY(properties != NULL)) {\n+    if (!NSK_VERIFY(properties != nullptr)) {\n@@ -59,1 +59,1 @@\n-            char* value = NULL;\n+            char* value = nullptr;\n@@ -62,1 +62,1 @@\n-            if (!NSK_VERIFY(properties[i] != NULL)) {\n+            if (!NSK_VERIFY(properties[i] != nullptr)) {\n@@ -74,2 +74,2 @@\n-            if (value == NULL) {\n-                NSK_COMPLAIN4(\"In %s phase GetSystemProperty() returned NULL for property #%d:\\n\"\n+            if (value == nullptr) {\n+                NSK_COMPLAIN4(\"In %s phase GetSystemProperty() returned null for property #%d:\\n\"\n@@ -134,1 +134,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -142,1 +142,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -150,1 +150,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetSystemProperty\/getsysprop001\/getsysprop001.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-    char* value = NULL;\n+    char* value = nullptr;\n@@ -61,2 +61,2 @@\n-    if (value == NULL) {\n-        NSK_COMPLAIN4(\"In %s phase GetSystemProperty() returned NULL value for property:\\n\"\n+    if (value == nullptr) {\n+        NSK_COMPLAIN4(\"In %s phase GetSystemProperty() returned null value for property:\\n\"\n@@ -133,1 +133,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -141,1 +141,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -149,1 +149,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetSystemProperty\/getsysprop002\/getsysprop002.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        jobject testedObject = NULL;\n+        jobject testedObject = nullptr;\n@@ -59,2 +59,2 @@\n-            jclass debugeeClass = NULL;\n-            jfieldID objectField = NULL;\n+            jclass debugeeClass = nullptr;\n+            jfieldID objectField = nullptr;\n@@ -64,1 +64,1 @@\n-                    jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+                    jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -72,1 +72,1 @@\n-                    jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, OBJECT_CLASS_SIG)) != NULL)) {\n+                    jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -80,1 +80,1 @@\n-                    jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+                    jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -88,1 +88,1 @@\n-                    jni->NewGlobalRef(testedObject)) != NULL)) {\n+                    jni->NewGlobalRef(testedObject)) != nullptr)) {\n@@ -145,1 +145,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -155,1 +155,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -171,1 +171,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetTag\/gettag001\/gettag001.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-    NSK_DISPLAY1(\"GetThreadCpuTime() for current thread (passing NULL): 0x%p\\n\", (void*)thread);\n+    NSK_DISPLAY1(\"GetThreadCpuTime() for current thread (passing null): 0x%p\\n\", (void*)thread);\n@@ -74,1 +74,1 @@\n-            jvmti->GetThreadCpuTime(NULL, (jlong *)time))) {\n+            jvmti->GetThreadCpuTime(nullptr, (jlong *)time))) {\n@@ -84,1 +84,1 @@\n-    if (prevTime != NULL) {\n+    if (prevTime != nullptr) {\n@@ -151,1 +151,1 @@\n-        if (!checkCpuTime(jvmti, testAgentThread, &prevAgentThreadTime, NULL, \"agent thread\")) {\n+        if (!checkCpuTime(jvmti, testAgentThread, &prevAgentThreadTime, nullptr, \"agent thread\")) {\n@@ -161,1 +161,1 @@\n-        if (nsk_jvmti_enableEvents(JVMTI_ENABLE, THREAD_EVENTS_COUNT, threadEvents, NULL)) {\n+        if (nsk_jvmti_enableEvents(JVMTI_ENABLE, THREAD_EVENTS_COUNT, threadEvents, nullptr)) {\n@@ -188,1 +188,1 @@\n-        if (nsk_jvmti_enableEvents(JVMTI_DISABLE, THREAD_EVENTS_COUNT, threadEvents, NULL)) {\n+        if (nsk_jvmti_enableEvents(JVMTI_DISABLE, THREAD_EVENTS_COUNT, threadEvents, nullptr)) {\n@@ -218,1 +218,1 @@\n-        if (!checkCpuTime(jvmti, thread, &time, NULL, \"VM_INIT callback\")) {\n+        if (!checkCpuTime(jvmti, thread, &time, nullptr, \"VM_INIT callback\")) {\n@@ -234,1 +234,1 @@\n-        if (!checkCpuTime(jvmti, NULL, &time, NULL, \"VM_DEATH callback\")) {\n+        if (!checkCpuTime(jvmti, nullptr, &time, nullptr, \"VM_DEATH callback\")) {\n@@ -241,1 +241,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -271,1 +271,1 @@\n-    if (threadInfo.name != NULL && strcmp(threadInfo.name, TESTED_THREAD_NAME) == 0) {\n+    if (threadInfo.name != nullptr && strcmp(threadInfo.name, TESTED_THREAD_NAME) == 0) {\n@@ -273,1 +273,1 @@\n-        if (!checkCpuTime(jvmti, thread, &prevTestedThreadTime, NULL, \"THREAD_START callback\")) {\n+        if (!checkCpuTime(jvmti, thread, &prevTestedThreadTime, nullptr, \"THREAD_START callback\")) {\n@@ -295,1 +295,1 @@\n-    if (threadInfo.name != NULL && strcmp(threadInfo.name, TESTED_THREAD_NAME) == 0) {\n+    if (threadInfo.name != nullptr && strcmp(threadInfo.name, TESTED_THREAD_NAME) == 0) {\n@@ -319,1 +319,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -331,1 +331,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -363,1 +363,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -367,1 +367,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadCpuTime\/thrcputime001\/thrcputime001.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,2 +58,2 @@\n-static jthread testedThread = NULL;\n-static jthread testAgentThread = NULL;\n+static jthread testedThread = nullptr;\n+static jthread testAgentThread = nullptr;\n@@ -86,1 +86,1 @@\n-    if (prevTime != NULL) {\n+    if (prevTime != nullptr) {\n@@ -153,1 +153,1 @@\n-        if (!checkCpuTime(jvmti, testAgentThread, &prevAgentThreadTime, NULL, \"agent thread\")) {\n+        if (!checkCpuTime(jvmti, testAgentThread, &prevAgentThreadTime, nullptr, \"agent thread\")) {\n@@ -163,1 +163,1 @@\n-        if (nsk_jvmti_enableEvents(JVMTI_ENABLE, THREAD_EVENTS_COUNT, threadEvents, NULL)) {\n+        if (nsk_jvmti_enableEvents(JVMTI_ENABLE, THREAD_EVENTS_COUNT, threadEvents, nullptr)) {\n@@ -183,1 +183,1 @@\n-        if (testedThread != NULL) {\n+        if (testedThread != nullptr) {\n@@ -201,1 +201,1 @@\n-        if (nsk_jvmti_enableEvents(JVMTI_DISABLE, THREAD_EVENTS_COUNT, threadEvents, NULL)) {\n+        if (nsk_jvmti_enableEvents(JVMTI_DISABLE, THREAD_EVENTS_COUNT, threadEvents, nullptr)) {\n@@ -231,1 +231,1 @@\n-        if (!checkCpuTime(jvmti, thread, &time, NULL, \"VM_INIT callback\")) {\n+        if (!checkCpuTime(jvmti, thread, &time, nullptr, \"VM_INIT callback\")) {\n@@ -245,1 +245,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -282,2 +282,2 @@\n-    if (threadInfo.name != NULL && strcmp(threadInfo.name, TESTED_THREAD_NAME) == 0) {\n-        if (!NSK_JNI_VERIFY(jni, (testedThread = jni->NewGlobalRef(thread)) != NULL)) {\n+    if (threadInfo.name != nullptr && strcmp(threadInfo.name, TESTED_THREAD_NAME) == 0) {\n+        if (!NSK_JNI_VERIFY(jni, (testedThread = jni->NewGlobalRef(thread)) != nullptr)) {\n@@ -288,1 +288,1 @@\n-        if (!checkCpuTime(jvmti, thread, &prevTestedThreadTime, NULL, \"THREAD_START callback\")) {\n+        if (!checkCpuTime(jvmti, thread, &prevTestedThreadTime, nullptr, \"THREAD_START callback\")) {\n@@ -317,1 +317,1 @@\n-    if (threadInfo.name != NULL && strcmp(threadInfo.name, TESTED_THREAD_NAME) == 0) {\n+    if (threadInfo.name != nullptr && strcmp(threadInfo.name, TESTED_THREAD_NAME) == 0) {\n@@ -324,1 +324,1 @@\n-        testedThread = NULL;\n+        testedThread = nullptr;\n@@ -343,1 +343,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -355,1 +355,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -385,1 +385,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -389,1 +389,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadCpuTime\/thrcputime002\/thrcputime002.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-    if (initInfo != NULL) {\n+    if (initInfo != nullptr) {\n@@ -135,1 +135,1 @@\n-        if (nsk_jvmti_enableEvents(JVMTI_ENABLE, THREAD_EVENTS_COUNT, threadEvents, NULL)) {\n+        if (nsk_jvmti_enableEvents(JVMTI_ENABLE, THREAD_EVENTS_COUNT, threadEvents, nullptr)) {\n@@ -146,1 +146,1 @@\n-        if (nsk_jvmti_enableEvents(JVMTI_DISABLE, THREAD_EVENTS_COUNT, threadEvents, NULL)) {\n+        if (nsk_jvmti_enableEvents(JVMTI_DISABLE, THREAD_EVENTS_COUNT, threadEvents, nullptr)) {\n@@ -166,1 +166,1 @@\n-        if (!checkTimerInfo(jvmti, &initInfo, NULL, \"VM_INIT callback\")) {\n+        if (!checkTimerInfo(jvmti, &initInfo, nullptr, \"VM_INIT callback\")) {\n@@ -186,1 +186,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -245,1 +245,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -253,1 +253,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -285,1 +285,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -289,1 +289,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadCpuTimerInfo\/thrtimerinfo001\/thrtimerinfo001.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -72,4 +72,4 @@\n-        jthreadGroup rootGroup = NULL;\n-        jthreadGroup runningGroup = NULL;\n-        jthreadGroup notStartedGroup = NULL;\n-        jthreadGroup finishedGroup = NULL;\n+        jthreadGroup rootGroup = nullptr;\n+        jthreadGroup runningGroup = nullptr;\n+        jthreadGroup notStartedGroup = nullptr;\n+        jthreadGroup finishedGroup = nullptr;\n@@ -80,1 +80,1 @@\n-            jthreadGroup* topGroups = NULL;\n+            jthreadGroup* topGroups = nullptr;\n@@ -90,1 +90,1 @@\n-            if (!NSK_VERIFY(topGroupsCount > 0 && topGroups != NULL))\n+            if (!NSK_VERIFY(topGroupsCount > 0 && topGroups != nullptr))\n@@ -96,1 +96,1 @@\n-                                            topGroupsCount, topGroups)) != NULL)) {\n+                                            topGroupsCount, topGroups)) != nullptr)) {\n@@ -108,2 +108,2 @@\n-            jthread* threads = NULL;\n-            jthreadGroup* groups = NULL;\n+            jthread* threads = nullptr;\n+            jthreadGroup* groups = nullptr;\n@@ -153,1 +153,1 @@\n-                            if (runningGroup != NULL) {\n+                            if (runningGroup != nullptr) {\n@@ -171,1 +171,1 @@\n-                            if (notStartedGroup != NULL) {\n+                            if (notStartedGroup != nullptr) {\n@@ -189,1 +189,1 @@\n-                            if (finishedGroup != NULL) {\n+                            if (finishedGroup != nullptr) {\n@@ -246,1 +246,1 @@\n-    if (group == NULL) {\n+    if (group == nullptr) {\n@@ -256,2 +256,2 @@\n-        jthread* threads = NULL;\n-        jthreadGroup* groups = NULL;\n+        jthread* threads = nullptr;\n+        jthreadGroup* groups = nullptr;\n@@ -299,1 +299,1 @@\n-                if (info.name == NULL ||\n+                if (info.name == nullptr ||\n@@ -330,1 +330,1 @@\n-    jthreadGroup foundGroup = NULL;\n+    jthreadGroup foundGroup = nullptr;\n@@ -333,1 +333,1 @@\n-    for (i = 0; i < count && foundGroup == NULL; i++) {\n+    for (i = 0; i < count && foundGroup == nullptr; i++) {\n@@ -336,2 +336,2 @@\n-        jthread* threads = NULL;\n-        jthreadGroup * groups = NULL;\n+        jthread* threads = nullptr;\n+        jthreadGroup * groups = nullptr;\n@@ -342,1 +342,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -348,2 +348,2 @@\n-            if (!NSK_VERIFY(groups != NULL))\n-                return NULL;\n+            if (!NSK_VERIFY(groups != nullptr))\n+                return nullptr;\n@@ -354,1 +354,1 @@\n-                if (groups[j] != NULL) {\n+                if (groups[j] != nullptr) {\n@@ -369,1 +369,1 @@\n-            if (foundGroup == NULL) {\n+            if (foundGroup == nullptr) {\n@@ -403,1 +403,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -418,1 +418,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -422,1 +422,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadGroupChildren\/getthrdgrpchld001\/getthrdgrpchld001.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -75,1 +75,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -100,1 +100,1 @@\n-    if (inf.name == NULL || strcmp(inf.name, expName) != 0) {\n+    if (inf.name == nullptr || strcmp(inf.name, expName) != 0) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadGroupInfo\/thrgrpinfo001\/thrgrpinfo001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -74,1 +74,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -92,1 +92,1 @@\n-    err = jvmti->GetThreadGroupInfo(NULL, &inf);\n+    err = jvmti->GetThreadGroupInfo(nullptr, &inf);\n@@ -102,1 +102,1 @@\n-    err = jvmti->GetThreadGroupInfo(*groups, NULL);\n+    err = jvmti->GetThreadGroupInfo(*groups, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadGroupInfo\/thrgrpinfo002\/thrgrpinfo002.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-        jthread testedThread = NULL;\n-        void* storage = NULL;\n+        jthread testedThread = nullptr;\n+        void* storage = nullptr;\n@@ -56,1 +56,1 @@\n-                nsk_jvmti_threadByName(THREAD_NAME)) != NULL))\n+                nsk_jvmti_threadByName(THREAD_NAME)) != nullptr))\n@@ -68,3 +68,3 @@\n-        NSK_DISPLAY0(\"Check obtained storage pointer against NULL\\n\");\n-        if (storage != NULL) {\n-            NSK_COMPLAIN2(\"GetThreadLocalStorage() returned NOT NULL storage for tested thread:\\n\"\n+        NSK_DISPLAY0(\"Check obtained storage pointer against null\\n\");\n+        if (storage != nullptr) {\n+            NSK_COMPLAIN2(\"GetThreadLocalStorage() returned NOT null storage for tested thread:\\n\"\n@@ -79,1 +79,1 @@\n-                jvmti->GetThreadLocalStorage(NULL, &storage))) {\n+                jvmti->GetThreadLocalStorage(nullptr, &storage))) {\n@@ -85,3 +85,3 @@\n-        NSK_DISPLAY0(\"Check obtained storage pointer against NULL\\n\");\n-        if (storage != NULL) {\n-            NSK_COMPLAIN1(\"GetThreadLocalStorage() returned NOT NULL storage for current agent thread:\\n\"\n+        NSK_DISPLAY0(\"Check obtained storage pointer against null\\n\");\n+        if (storage != nullptr) {\n+            NSK_COMPLAIN1(\"GetThreadLocalStorage() returned NOT null storage for current agent thread:\\n\"\n@@ -117,1 +117,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -127,1 +127,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -131,1 +131,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadLocalStorage\/getthrdstor001\/getthrdstor001.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-    if (prevTime != NULL) {\n+    if (prevTime != nullptr) {\n@@ -144,1 +144,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -171,1 +171,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -179,1 +179,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -195,1 +195,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -200,1 +200,1 @@\n-        if (!checkTime(jvmti, &prevTime, NULL, \"Agent_OnLoad()\")) {\n+        if (!checkTime(jvmti, &prevTime, nullptr, \"Agent_OnLoad()\")) {\n@@ -206,1 +206,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetTime\/gettime001\/gettime001.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-    if (initInfo != NULL) {\n+    if (initInfo != nullptr) {\n@@ -161,1 +161,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -188,1 +188,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -196,1 +196,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -212,1 +212,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -217,1 +217,1 @@\n-        if (!checkTimerInfo(jvmti, &initInfo, NULL, \"Agent_OnLoad()\")) {\n+        if (!checkTimerInfo(jvmti, &initInfo, nullptr, \"Agent_OnLoad()\")) {\n@@ -223,1 +223,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetTimerInfo\/timerinfo001\/timerinfo001.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -71,1 +71,1 @@\n-    jthreadGroup *groups = NULL;\n+    jthreadGroup *groups = nullptr;\n@@ -74,1 +74,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -108,1 +108,1 @@\n-            if (inf.parent != NULL) {\n+            if (inf.parent != nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetTopThreadGroups\/topthrgrp001\/topthrgrp001.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -81,1 +81,1 @@\n-    err = jvmti->GetTopThreadGroups(NULL, &groups);\n+    err = jvmti->GetTopThreadGroups(nullptr, &groups);\n@@ -91,1 +91,1 @@\n-    err = jvmti->GetTopThreadGroups(&groupCount, NULL);\n+    err = jvmti->GetTopThreadGroups(&groupCount, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetTopThreadGroups\/topthrgrp002\/topthrgrp002.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -71,1 +71,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -93,1 +93,1 @@\n-    err = jvmti->GetVersionNumber(NULL);\n+    err = jvmti->GetVersionNumber(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetVersionNumber\/getvern001\/getvern001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,3 +41,3 @@\n-static jthread runningThread = NULL;\n-static jthread waitingThread = NULL;\n-static jthread sleepingThread = NULL;\n+static jthread runningThread = nullptr;\n+static jthread waitingThread = nullptr;\n+static jthread sleepingThread = nullptr;\n@@ -52,1 +52,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -63,1 +63,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -68,1 +68,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -79,1 +79,1 @@\n-        if (info.name != NULL) {\n+        if (info.name != nullptr) {\n@@ -112,1 +112,1 @@\n-    if (!NSK_VERIFY(runningThread != NULL)) {\n+    if (!NSK_VERIFY(runningThread != nullptr)) {\n@@ -120,1 +120,1 @@\n-    if (!NSK_VERIFY(waitingThread != NULL)) {\n+    if (!NSK_VERIFY(waitingThread != nullptr)) {\n@@ -128,1 +128,1 @@\n-    if (!NSK_VERIFY(sleepingThread != NULL)) {\n+    if (!NSK_VERIFY(sleepingThread != nullptr)) {\n@@ -154,1 +154,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -165,1 +165,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -168,1 +168,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd001\/intrpthrd001.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd002\/intrpthrd002.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd003\/intrpthrd003.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -72,1 +72,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -80,1 +80,1 @@\n-    err = jvmti->IsArrayClass(NULL, &isArrayClass);\n+    err = jvmti->IsArrayClass(nullptr, &isArrayClass);\n@@ -90,1 +90,1 @@\n-    err = jvmti->IsArrayClass(cls, NULL);\n+    err = jvmti->IsArrayClass(cls, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IsArrayClass\/isarray004\/isarray004.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -78,1 +78,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IsArrayClass\/isarray005\/isarray005.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -100,1 +100,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -106,1 +106,1 @@\n-    if (fid == NULL) {\n+    if (fid == nullptr) {\n@@ -114,1 +114,1 @@\n-    err = jvmti->IsFieldSynthetic(NULL, fid, &isSynthetic);\n+    err = jvmti->IsFieldSynthetic(nullptr, fid, &isSynthetic);\n@@ -127,1 +127,1 @@\n-    err = jvmti->IsFieldSynthetic(cls, NULL, &isSynthetic);\n+    err = jvmti->IsFieldSynthetic(cls, nullptr, &isSynthetic);\n@@ -140,1 +140,1 @@\n-    err = jvmti->IsFieldSynthetic(cls, fid, NULL);\n+    err = jvmti->IsFieldSynthetic(cls, fid, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IsFieldSynthetic\/isfldsin002\/isfldsin002.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -67,1 +67,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -72,1 +72,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -117,1 +117,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -124,1 +124,1 @@\n-        if (fid == NULL) {\n+        if (fid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IsFieldSynthetic\/isfldsin003\/isfldsin003.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -72,1 +72,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -80,1 +80,1 @@\n-    err = jvmti->IsInterface(NULL, &isInterface);\n+    err = jvmti->IsInterface(nullptr, &isInterface);\n@@ -90,1 +90,1 @@\n-    err = jvmti->IsInterface(cls, NULL);\n+    err = jvmti->IsInterface(cls, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IsInterface\/isintrf004\/isintrf004.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -77,1 +77,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IsInterface\/isintrf005\/isintrf005.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -82,1 +82,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -119,1 +119,1 @@\n-    if (clsId == NULL) {\n+    if (clsId == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IsMethodNative\/isnative001\/isnative001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -79,1 +79,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -87,1 +87,1 @@\n-    err = jvmti->IsMethodNative(NULL, &isNative);\n+    err = jvmti->IsMethodNative(nullptr, &isNative);\n@@ -97,1 +97,1 @@\n-    err = jvmti->IsMethodNative(mid, NULL);\n+    err = jvmti->IsMethodNative(mid, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IsMethodNative\/isnative002\/isnative002.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,4 +98,4 @@\n-            char* name = NULL;\n-            char* signature = NULL;\n-            char* generic = NULL;\n-            char* kind = NULL;\n+            char* name = nullptr;\n+            char* signature = nullptr;\n+            char* generic = nullptr;\n+            char* kind = nullptr;\n@@ -113,1 +113,1 @@\n-            if (name != NULL\n+            if (name != nullptr\n@@ -169,3 +169,3 @@\n-    jclass debugeeClass = NULL;\n-    jfieldID fieldID = NULL;\n-    jbyteArray array = NULL;\n+    jclass debugeeClass = nullptr;\n+    jfieldID fieldID = nullptr;\n+    jbyteArray array = nullptr;\n@@ -177,1 +177,1 @@\n-            jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -185,1 +185,1 @@\n-            jni->GetStaticFieldID(debugeeClass, CLASSFILE_FIELD_NAME, CLASSFILE_FIELD_SIG)) != NULL)) {\n+            jni->GetStaticFieldID(debugeeClass, CLASSFILE_FIELD_NAME, CLASSFILE_FIELD_SIG)) != nullptr)) {\n@@ -193,1 +193,1 @@\n-            jni->GetStaticObjectField(debugeeClass, fieldID)) != NULL)) {\n+            jni->GetStaticObjectField(debugeeClass, fieldID)) != nullptr)) {\n@@ -209,1 +209,1 @@\n-                jni->GetByteArrayElements(array, &isCopy)) != NULL)) {\n+                jni->GetByteArrayElements(array, &isCopy)) != nullptr)) {\n@@ -245,5 +245,5 @@\n-        jclass testedClass = NULL;\n-        jobject testedThread = NULL;\n-        jmethodID staticMethodID = NULL;\n-        jmethodID instanceMethodID = NULL;\n-        unsigned char* classfileBytes = NULL;\n+        jclass testedClass = nullptr;\n+        jobject testedThread = nullptr;\n+        jmethodID staticMethodID = nullptr;\n+        jmethodID instanceMethodID = nullptr;\n+        unsigned char* classfileBytes = nullptr;\n@@ -262,1 +262,1 @@\n-                    jni->FindClass(TESTED_CLASS_NAME)) != NULL)) {\n+                    jni->FindClass(TESTED_CLASS_NAME)) != nullptr)) {\n@@ -270,1 +270,1 @@\n-                    jni->NewGlobalRef(testedClass)) != NULL)) {\n+                    jni->NewGlobalRef(testedClass)) != nullptr)) {\n@@ -278,1 +278,1 @@\n-                    jni->GetStaticMethodID(testedClass, STATIC_METHOD_NAME, STATIC_METHOD_SIG)) != NULL)) {\n+                    jni->GetStaticMethodID(testedClass, STATIC_METHOD_NAME, STATIC_METHOD_SIG)) != nullptr)) {\n@@ -286,1 +286,1 @@\n-                    jni->GetMethodID(testedClass, INSTANCE_METHOD_NAME, INSTANCE_METHOD_SIG)) != NULL)) {\n+                    jni->GetMethodID(testedClass, INSTANCE_METHOD_NAME, INSTANCE_METHOD_SIG)) != nullptr)) {\n@@ -294,1 +294,1 @@\n-                    nsk_jvmti_threadByName(TESTED_THREAD_NAME)) != NULL)) {\n+                    nsk_jvmti_threadByName(TESTED_THREAD_NAME)) != nullptr)) {\n@@ -370,1 +370,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -380,1 +380,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -396,1 +396,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IsMethodObsolete\/isobsolete001\/isobsolete001.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -79,1 +79,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -84,1 +84,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -142,1 +142,1 @@\n-        if (mid == NULL) {\n+        if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IsMethodSynthetic\/issynth001\/issynth001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -100,1 +100,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -106,1 +106,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -114,1 +114,1 @@\n-    err = jvmti->IsMethodSynthetic(NULL, &isSynthetic);\n+    err = jvmti->IsMethodSynthetic(nullptr, &isSynthetic);\n@@ -127,1 +127,1 @@\n-    err = jvmti->IsMethodSynthetic(mid, NULL);\n+    err = jvmti->IsMethodSynthetic(mid, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IsMethodSynthetic\/issynth002\/issynth002.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-static ObjectDesc* objectDescList = NULL;\n+static ObjectDesc* objectDescList = nullptr;\n@@ -85,1 +85,1 @@\n-    jobject obj = NULL;\n+    jobject obj = nullptr;\n@@ -95,1 +95,1 @@\n-            jni->GetObjectField(firstObject, firstField)) != NULL)) {\n+            jni->GetObjectField(firstObject, firstField)) != nullptr)) {\n@@ -121,3 +121,3 @@\n-    jclass debugeeClass = NULL;\n-    jclass rootObjectClass = NULL;\n-    jclass chainObjectClass = NULL;\n+    jclass debugeeClass = nullptr;\n+    jclass rootObjectClass = nullptr;\n+    jclass chainObjectClass = nullptr;\n@@ -125,4 +125,4 @@\n-    jfieldID objectField = NULL;\n-    jfieldID reachableChainField = NULL;\n-    jfieldID unreachableChainField = NULL;\n-    jfieldID tailField = NULL;\n+    jfieldID objectField = nullptr;\n+    jfieldID reachableChainField = nullptr;\n+    jfieldID unreachableChainField = nullptr;\n+    jfieldID tailField = nullptr;\n@@ -130,1 +130,1 @@\n-    jobject rootObject = NULL;\n+    jobject rootObject = nullptr;\n@@ -154,1 +154,1 @@\n-            jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -162,1 +162,1 @@\n-            jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -170,1 +170,1 @@\n-            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -178,1 +178,1 @@\n-            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -186,1 +186,1 @@\n-            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -194,1 +194,1 @@\n-            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -202,1 +202,1 @@\n-            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -210,1 +210,1 @@\n-            jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+            jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -305,1 +305,1 @@\n-    if (objectDescList != NULL) {\n+    if (objectDescList != nullptr) {\n@@ -325,1 +325,1 @@\n-                        (long)(tag_ptr == NULL ? (jlong)0 : *tag_ptr));\n+                        (long)(tag_ptr == nullptr ? (jlong)0 : *tag_ptr));\n@@ -327,1 +327,1 @@\n-                    tag_ptr != NULL && *tag_ptr != 0) {\n+                    tag_ptr != nullptr && *tag_ptr != 0) {\n@@ -344,2 +344,2 @@\n-    if (tag_ptr == NULL) {\n-        NSK_COMPLAIN3(\"NULL tag_ptr is passed to heapObjectCallback:\\n\"\n+    if (tag_ptr == nullptr) {\n+        NSK_COMPLAIN3(\"null tag_ptr is passed to heapObjectCallback:\\n\"\n@@ -414,1 +414,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr)))\n@@ -435,1 +435,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr)))\n@@ -490,1 +490,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -499,1 +499,1 @@\n-        if (infoOpt != NULL) {\n+        if (infoOpt != nullptr) {\n@@ -526,1 +526,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -550,1 +550,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverHeap\/iterheap001\/iterheap001.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-static ObjectDesc* objectDescList = NULL;\n+static ObjectDesc* objectDescList = nullptr;\n@@ -85,1 +85,1 @@\n-    jobject obj = NULL;\n+    jobject obj = nullptr;\n@@ -95,1 +95,1 @@\n-            jni->GetObjectField(firstObject, firstField)) != NULL)) {\n+            jni->GetObjectField(firstObject, firstField)) != nullptr)) {\n@@ -121,3 +121,3 @@\n-    jclass debugeeClass = NULL;\n-    jclass rootObjectClass = NULL;\n-    jclass chainObjectClass = NULL;\n+    jclass debugeeClass = nullptr;\n+    jclass rootObjectClass = nullptr;\n+    jclass chainObjectClass = nullptr;\n@@ -125,4 +125,4 @@\n-    jfieldID objectField = NULL;\n-    jfieldID reachableChainField = NULL;\n-    jfieldID unreachableChainField = NULL;\n-    jfieldID tailField = NULL;\n+    jfieldID objectField = nullptr;\n+    jfieldID reachableChainField = nullptr;\n+    jfieldID unreachableChainField = nullptr;\n+    jfieldID tailField = nullptr;\n@@ -130,1 +130,1 @@\n-    jobject rootObject = NULL;\n+    jobject rootObject = nullptr;\n@@ -154,1 +154,1 @@\n-            jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -162,1 +162,1 @@\n-            jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -170,1 +170,1 @@\n-            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -178,1 +178,1 @@\n-            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -186,1 +186,1 @@\n-            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -194,1 +194,1 @@\n-            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -202,1 +202,1 @@\n-            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -210,1 +210,1 @@\n-            jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+            jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -305,1 +305,1 @@\n-    if (objectDescList != NULL) {\n+    if (objectDescList != nullptr) {\n@@ -325,1 +325,1 @@\n-                        (long)(tag_ptr == NULL ? (jlong)0 : *tag_ptr));\n+                        (long)(tag_ptr == nullptr ? (jlong)0 : *tag_ptr));\n@@ -327,1 +327,1 @@\n-                    tag_ptr != NULL && *tag_ptr != 0) {\n+                    tag_ptr != nullptr && *tag_ptr != 0) {\n@@ -344,2 +344,2 @@\n-    if (tag_ptr == NULL) {\n-        NSK_COMPLAIN3(\"NULL tag_ptr is passed to heapObjectCallback:\\n\"\n+    if (tag_ptr == nullptr) {\n+        NSK_COMPLAIN3(\"null tag_ptr is passed to heapObjectCallback:\\n\"\n@@ -422,1 +422,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr)))\n@@ -443,1 +443,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr)))\n@@ -498,1 +498,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -507,1 +507,1 @@\n-        if (infoOpt != NULL) {\n+        if (infoOpt != nullptr) {\n@@ -534,1 +534,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -558,1 +558,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverHeap\/iterheap002\/iterheap002.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-static ObjectDesc* objectDescList = NULL;\n+static ObjectDesc* objectDescList = nullptr;\n@@ -85,1 +85,1 @@\n-    jobject obj = NULL;\n+    jobject obj = nullptr;\n@@ -95,1 +95,1 @@\n-            jni->GetObjectField(firstObject, firstField)) != NULL)) {\n+            jni->GetObjectField(firstObject, firstField)) != nullptr)) {\n@@ -121,3 +121,3 @@\n-    jclass debugeeClass = NULL;\n-    jclass rootObjectClass = NULL;\n-    jclass chainObjectClass = NULL;\n+    jclass debugeeClass = nullptr;\n+    jclass rootObjectClass = nullptr;\n+    jclass chainObjectClass = nullptr;\n@@ -125,4 +125,4 @@\n-    jfieldID objectField = NULL;\n-    jfieldID reachableChainField = NULL;\n-    jfieldID unreachableChainField = NULL;\n-    jfieldID tailField = NULL;\n+    jfieldID objectField = nullptr;\n+    jfieldID reachableChainField = nullptr;\n+    jfieldID unreachableChainField = nullptr;\n+    jfieldID tailField = nullptr;\n@@ -130,1 +130,1 @@\n-    jobject rootObject = NULL;\n+    jobject rootObject = nullptr;\n@@ -154,1 +154,1 @@\n-            jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -162,1 +162,1 @@\n-            jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -170,1 +170,1 @@\n-            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -178,1 +178,1 @@\n-            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -186,1 +186,1 @@\n-            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -194,1 +194,1 @@\n-            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -202,1 +202,1 @@\n-            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -210,1 +210,1 @@\n-            jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+            jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -305,1 +305,1 @@\n-    if (objectDescList != NULL) {\n+    if (objectDescList != nullptr) {\n@@ -325,1 +325,1 @@\n-                        (long)(tag_ptr == NULL ? (jlong)0 : *tag_ptr));\n+                        (long)(tag_ptr == nullptr ? (jlong)0 : *tag_ptr));\n@@ -327,1 +327,1 @@\n-                    tag_ptr != NULL && *tag_ptr != 0) {\n+                    tag_ptr != nullptr && *tag_ptr != 0) {\n@@ -344,2 +344,2 @@\n-    if (tag_ptr == NULL) {\n-        NSK_COMPLAIN3(\"NULL tag_ptr is passed to heapObjectCallback:\\n\"\n+    if (tag_ptr == nullptr) {\n+        NSK_COMPLAIN3(\"null tag_ptr is passed to heapObjectCallback:\\n\"\n@@ -423,1 +423,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr)))\n@@ -444,1 +444,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr)))\n@@ -499,1 +499,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -508,1 +508,1 @@\n-        if (infoOpt != NULL) {\n+        if (infoOpt != nullptr) {\n@@ -535,1 +535,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -559,1 +559,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverHeap\/iterheap003\/iterheap003.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -129,1 +129,1 @@\n-            objectDescList = NULL;\n+            objectDescList = nullptr;\n@@ -173,1 +173,1 @@\n-            if (!NSK_VERIFY(objectDesc == NULL)) {\n+            if (!NSK_VERIFY(objectDesc == nullptr)) {\n@@ -245,1 +245,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -261,1 +261,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverHeap\/iterheap004\/iterheap004.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv* st_jvmti = NULL;\n+static jvmtiEnv* st_jvmti = nullptr;\n@@ -47,1 +47,1 @@\n-    jrawMonitorID monitor_ptr = NULL;\n+    jrawMonitorID monitor_ptr = nullptr;\n@@ -153,1 +153,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -161,1 +161,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -178,1 +178,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverHeap\/iterheap005\/iterheap005.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv* st_jvmti = NULL;\n+static jvmtiEnv* st_jvmti = nullptr;\n@@ -37,1 +37,1 @@\n-static void *storage_ptr = NULL;\n+static void *storage_ptr = nullptr;\n@@ -114,1 +114,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -122,1 +122,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -139,1 +139,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverHeap\/iterheap006\/iterheap006.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv* st_jvmti = NULL;\n+static jvmtiEnv* st_jvmti = nullptr;\n@@ -138,1 +138,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -146,1 +146,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -163,1 +163,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverHeap\/iterheap007\/iterheap007.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-static ObjectDesc* objectDescList = NULL;\n+static ObjectDesc* objectDescList = nullptr;\n@@ -85,1 +85,1 @@\n-    jobject obj = NULL;\n+    jobject obj = nullptr;\n@@ -95,1 +95,1 @@\n-            jni->GetObjectField(firstObject, firstField)) != NULL)) {\n+            jni->GetObjectField(firstObject, firstField)) != nullptr)) {\n@@ -122,3 +122,3 @@\n-    jclass debugeeClass = NULL;\n-    jclass rootObjectClass = NULL;\n-    jclass chainObjectClass = NULL;\n+    jclass debugeeClass = nullptr;\n+    jclass rootObjectClass = nullptr;\n+    jclass chainObjectClass = nullptr;\n@@ -126,4 +126,4 @@\n-    jfieldID objectField = NULL;\n-    jfieldID reachableChainField = NULL;\n-    jfieldID unreachableChainField = NULL;\n-    jfieldID tailField = NULL;\n+    jfieldID objectField = nullptr;\n+    jfieldID reachableChainField = nullptr;\n+    jfieldID unreachableChainField = nullptr;\n+    jfieldID tailField = nullptr;\n@@ -131,1 +131,1 @@\n-    jobject rootObject = NULL;\n+    jobject rootObject = nullptr;\n@@ -156,1 +156,1 @@\n-            jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -164,1 +164,1 @@\n-            jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -172,1 +172,1 @@\n-            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -180,1 +180,1 @@\n-            jni->NewGlobalRef(chainObjectClass)) != NULL)) {\n+            jni->NewGlobalRef(chainObjectClass)) != nullptr)) {\n@@ -188,1 +188,1 @@\n-            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -196,1 +196,1 @@\n-            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -204,1 +204,1 @@\n-            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -212,1 +212,1 @@\n-            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -220,1 +220,1 @@\n-            jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+            jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -323,1 +323,1 @@\n-    if (testedClass != NULL) {\n+    if (testedClass != nullptr) {\n@@ -328,1 +328,1 @@\n-    if (objectDescList != NULL) {\n+    if (objectDescList != nullptr) {\n@@ -348,1 +348,1 @@\n-                        (long)(tag_ptr == NULL ? (jlong)0 : *tag_ptr));\n+                        (long)(tag_ptr == nullptr ? (jlong)0 : *tag_ptr));\n@@ -362,2 +362,2 @@\n-    if (tag_ptr == NULL) {\n-        NSK_COMPLAIN3(\"NULL tag_ptr is passed to heapObjectCallback:\\n\"\n+    if (tag_ptr == nullptr) {\n+        NSK_COMPLAIN3(\"null tag_ptr is passed to heapObjectCallback:\\n\"\n@@ -422,1 +422,1 @@\n-        jclass testedClass = NULL;\n+        jclass testedClass = nullptr;\n@@ -434,1 +434,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr)))\n@@ -455,1 +455,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr)))\n@@ -511,1 +511,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -520,1 +520,1 @@\n-        if (infoOpt != NULL) {\n+        if (infoOpt != nullptr) {\n@@ -545,1 +545,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -569,1 +569,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverInstancesOfClass\/iterinstcls001\/iterinstcls001.cpp","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-static ObjectDesc* objectDescList = NULL;\n+static ObjectDesc* objectDescList = nullptr;\n@@ -85,1 +85,1 @@\n-    jobject obj = NULL;\n+    jobject obj = nullptr;\n@@ -95,1 +95,1 @@\n-            jni->GetObjectField(firstObject, firstField)) != NULL)) {\n+            jni->GetObjectField(firstObject, firstField)) != nullptr)) {\n@@ -122,3 +122,3 @@\n-    jclass debugeeClass = NULL;\n-    jclass rootObjectClass = NULL;\n-    jclass chainObjectClass = NULL;\n+    jclass debugeeClass = nullptr;\n+    jclass rootObjectClass = nullptr;\n+    jclass chainObjectClass = nullptr;\n@@ -126,4 +126,4 @@\n-    jfieldID objectField = NULL;\n-    jfieldID reachableChainField = NULL;\n-    jfieldID unreachableChainField = NULL;\n-    jfieldID tailField = NULL;\n+    jfieldID objectField = nullptr;\n+    jfieldID reachableChainField = nullptr;\n+    jfieldID unreachableChainField = nullptr;\n+    jfieldID tailField = nullptr;\n@@ -131,1 +131,1 @@\n-    jobject rootObject = NULL;\n+    jobject rootObject = nullptr;\n@@ -156,1 +156,1 @@\n-            jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -164,1 +164,1 @@\n-            jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -172,1 +172,1 @@\n-            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -180,1 +180,1 @@\n-            jni->NewGlobalRef(chainObjectClass)) != NULL)) {\n+            jni->NewGlobalRef(chainObjectClass)) != nullptr)) {\n@@ -188,1 +188,1 @@\n-            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -196,1 +196,1 @@\n-            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -204,1 +204,1 @@\n-            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -212,1 +212,1 @@\n-            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -220,1 +220,1 @@\n-            jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+            jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -323,1 +323,1 @@\n-    if (testedClass != NULL) {\n+    if (testedClass != nullptr) {\n@@ -328,1 +328,1 @@\n-    if (objectDescList != NULL) {\n+    if (objectDescList != nullptr) {\n@@ -348,1 +348,1 @@\n-                        (long)(tag_ptr == NULL ? (jlong)0 : *tag_ptr));\n+                        (long)(tag_ptr == nullptr ? (jlong)0 : *tag_ptr));\n@@ -362,2 +362,2 @@\n-    if (tag_ptr == NULL) {\n-        NSK_COMPLAIN3(\"NULL tag_ptr is passed to heapObjectCallback:\\n\"\n+    if (tag_ptr == nullptr) {\n+        NSK_COMPLAIN3(\"null tag_ptr is passed to heapObjectCallback:\\n\"\n@@ -430,1 +430,1 @@\n-        jclass testedClass = NULL;\n+        jclass testedClass = nullptr;\n@@ -442,1 +442,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr)))\n@@ -463,1 +463,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr)))\n@@ -519,1 +519,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -528,1 +528,1 @@\n-        if (infoOpt != NULL) {\n+        if (infoOpt != nullptr) {\n@@ -553,1 +553,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -577,1 +577,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverInstancesOfClass\/iterinstcls002\/iterinstcls002.cpp","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-static ObjectDesc* objectDescList = NULL;\n+static ObjectDesc* objectDescList = nullptr;\n@@ -85,1 +85,1 @@\n-    jobject obj = NULL;\n+    jobject obj = nullptr;\n@@ -95,1 +95,1 @@\n-            jni->GetObjectField(firstObject, firstField)) != NULL)) {\n+            jni->GetObjectField(firstObject, firstField)) != nullptr)) {\n@@ -122,3 +122,3 @@\n-    jclass debugeeClass = NULL;\n-    jclass rootObjectClass = NULL;\n-    jclass chainObjectClass = NULL;\n+    jclass debugeeClass = nullptr;\n+    jclass rootObjectClass = nullptr;\n+    jclass chainObjectClass = nullptr;\n@@ -126,4 +126,4 @@\n-    jfieldID objectField = NULL;\n-    jfieldID reachableChainField = NULL;\n-    jfieldID unreachableChainField = NULL;\n-    jfieldID tailField = NULL;\n+    jfieldID objectField = nullptr;\n+    jfieldID reachableChainField = nullptr;\n+    jfieldID unreachableChainField = nullptr;\n+    jfieldID tailField = nullptr;\n@@ -131,1 +131,1 @@\n-    jobject rootObject = NULL;\n+    jobject rootObject = nullptr;\n@@ -156,1 +156,1 @@\n-            jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -164,1 +164,1 @@\n-            jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -172,1 +172,1 @@\n-            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -180,1 +180,1 @@\n-            jni->NewGlobalRef(chainObjectClass)) != NULL)) {\n+            jni->NewGlobalRef(chainObjectClass)) != nullptr)) {\n@@ -188,1 +188,1 @@\n-            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -196,1 +196,1 @@\n-            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -204,1 +204,1 @@\n-            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -212,1 +212,1 @@\n-            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -220,1 +220,1 @@\n-            jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+            jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -323,1 +323,1 @@\n-    if (testedClass != NULL) {\n+    if (testedClass != nullptr) {\n@@ -328,1 +328,1 @@\n-    if (objectDescList != NULL) {\n+    if (objectDescList != nullptr) {\n@@ -348,1 +348,1 @@\n-                        (long)(tag_ptr == NULL ? (jlong)0 : *tag_ptr));\n+                        (long)(tag_ptr == nullptr ? (jlong)0 : *tag_ptr));\n@@ -362,2 +362,2 @@\n-    if (tag_ptr == NULL) {\n-        NSK_COMPLAIN3(\"NULL tag_ptr is passed to heapObjectCallback:\\n\"\n+    if (tag_ptr == nullptr) {\n+        NSK_COMPLAIN3(\"null tag_ptr is passed to heapObjectCallback:\\n\"\n@@ -431,1 +431,1 @@\n-        jclass testedClass = NULL;\n+        jclass testedClass = nullptr;\n@@ -443,1 +443,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr)))\n@@ -464,1 +464,1 @@\n-            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL)))\n+            if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr)))\n@@ -520,1 +520,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -529,1 +529,1 @@\n-        if (infoOpt != NULL) {\n+        if (infoOpt != nullptr) {\n@@ -554,1 +554,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -578,1 +578,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverInstancesOfClass\/iterinstcls003\/iterinstcls003.cpp","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-static jvmtiEnv* st_jvmti = NULL;\n+static jvmtiEnv* st_jvmti = nullptr;\n@@ -102,1 +102,1 @@\n-        jclass debugeeClass = NULL;\n+        jclass debugeeClass = nullptr;\n@@ -107,1 +107,1 @@\n-            if (debugeeClass == NULL) {\n+            if (debugeeClass == nullptr) {\n@@ -170,1 +170,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -178,1 +178,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -195,1 +195,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverInstancesOfClass\/iterinstcls004\/iterinstcls004.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv* st_jvmti = NULL;\n+static jvmtiEnv* st_jvmti = nullptr;\n@@ -48,1 +48,1 @@\n-    jrawMonitorID monitor_ptr = NULL;\n+    jrawMonitorID monitor_ptr = nullptr;\n@@ -109,1 +109,1 @@\n-        jclass debugeeClass = NULL;\n+        jclass debugeeClass = nullptr;\n@@ -113,1 +113,1 @@\n-        if (debugeeClass == NULL) {\n+        if (debugeeClass == nullptr) {\n@@ -155,1 +155,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -163,1 +163,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -179,1 +179,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverInstancesOfClass\/iterinstcls005\/iterinstcls005.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv* st_jvmti = NULL;\n+static jvmtiEnv* st_jvmti = nullptr;\n@@ -37,1 +37,1 @@\n-static void *storage_ptr = NULL;\n+static void *storage_ptr = nullptr;\n@@ -71,1 +71,1 @@\n-        jclass debugeeClass = NULL;\n+        jclass debugeeClass = nullptr;\n@@ -75,1 +75,1 @@\n-        if (debugeeClass == NULL) {\n+        if (debugeeClass == nullptr) {\n@@ -124,1 +124,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -132,1 +132,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -148,1 +148,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverInstancesOfClass\/iterinstcls006\/iterinstcls006.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv* st_jvmti = NULL;\n+static jvmtiEnv* st_jvmti = nullptr;\n@@ -112,1 +112,1 @@\n-            jclass debugeeClass = NULL;\n+            jclass debugeeClass = nullptr;\n@@ -116,1 +116,1 @@\n-            if (debugeeClass == NULL) {\n+            if (debugeeClass == nullptr) {\n@@ -151,1 +151,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -159,1 +159,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -176,1 +176,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverInstancesOfClass\/iterinstcls007\/iterinstcls007.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-static ObjectDesc* objectDescList = NULL;\n+static ObjectDesc* objectDescList = nullptr;\n@@ -79,1 +79,1 @@\n-    jobject obj = NULL;\n+    jobject obj = nullptr;\n@@ -88,1 +88,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetObjectField(firstObject, firstField)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetObjectField(firstObject, firstField)) != nullptr)) {\n@@ -113,3 +113,3 @@\n-    jclass debugeeClass = NULL;\n-    jclass rootObjectClass = NULL;\n-    jclass chainObjectClass = NULL;\n+    jclass debugeeClass = nullptr;\n+    jclass rootObjectClass = nullptr;\n+    jclass chainObjectClass = nullptr;\n@@ -117,4 +117,4 @@\n-    jfieldID objectField = NULL;\n-    jfieldID reachableChainField = NULL;\n-    jfieldID unreachableChainField = NULL;\n-    jfieldID tailField = NULL;\n+    jfieldID objectField = nullptr;\n+    jfieldID reachableChainField = nullptr;\n+    jfieldID unreachableChainField = nullptr;\n+    jfieldID tailField = nullptr;\n@@ -144,1 +144,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -151,1 +151,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (rootObjectClass = jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (rootObjectClass = jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -159,1 +159,1 @@\n-            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -167,1 +167,1 @@\n-            debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != NULL)) {\n+            debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -175,1 +175,1 @@\n-            rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -183,1 +183,1 @@\n-            rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -191,1 +191,1 @@\n-            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -199,1 +199,1 @@\n-            jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+            jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -205,1 +205,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (*rootObject = jni->NewGlobalRef(*rootObject)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (*rootObject = jni->NewGlobalRef(*rootObject)) != nullptr)) {\n@@ -293,1 +293,1 @@\n-    if (rootObject != NULL) {\n+    if (rootObject != nullptr) {\n@@ -298,1 +298,1 @@\n-    if (objectDescList != NULL) {\n+    if (objectDescList != nullptr) {\n@@ -321,1 +321,1 @@\n-                        (long)(tag_ptr == NULL ? (jlong)0 : *tag_ptr),\n+                        (long)(tag_ptr == nullptr ? (jlong)0 : *tag_ptr),\n@@ -325,2 +325,2 @@\n-    if (tag_ptr == NULL) {\n-        NSK_COMPLAIN6(\"NULL tag_ptr is passed to objectReferenceCallback:\\n\"\n+    if (tag_ptr == nullptr) {\n+        NSK_COMPLAIN6(\"null tag_ptr is passed to objectReferenceCallback:\\n\"\n@@ -342,1 +342,1 @@\n-    if (tag_ptr != NULL && *tag_ptr != 0) {\n+    if (tag_ptr != nullptr && *tag_ptr != 0) {\n@@ -415,1 +415,1 @@\n-        jobject rootObject = NULL;\n+        jobject rootObject = nullptr;\n@@ -477,1 +477,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -486,1 +486,1 @@\n-        if (infoOpt != NULL) {\n+        if (infoOpt != nullptr) {\n@@ -511,1 +511,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -524,1 +524,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverObjectsReachableFromObject\/iterobjreachobj001\/iterobjreachobj001.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-static jvmtiEnv* st_jvmti = NULL;\n+static jvmtiEnv* st_jvmti = nullptr;\n@@ -111,3 +111,3 @@\n-        jclass debugeeClass = NULL;\n-        jfieldID objectField = NULL;\n-        jobject object = NULL;\n+        jclass debugeeClass = nullptr;\n+        jfieldID objectField = nullptr;\n+        jobject object = nullptr;\n@@ -118,1 +118,1 @@\n-            if (debugeeClass == NULL) {\n+            if (debugeeClass == nullptr) {\n@@ -125,1 +125,1 @@\n-                    debugeeClass, objectFieldName, debugeeClassSignature)) != NULL)) {\n+                    debugeeClass, objectFieldName, debugeeClassSignature)) != nullptr)) {\n@@ -132,1 +132,1 @@\n-                    jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+                    jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -193,1 +193,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -201,1 +201,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -217,1 +217,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverObjectsReachableFromObject\/iterobjreachobj002\/iterobjreachobj002.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv* st_jvmti = NULL;\n+static jvmtiEnv* st_jvmti = nullptr;\n@@ -52,1 +52,1 @@\n-    jrawMonitorID monitor_ptr = NULL;\n+    jrawMonitorID monitor_ptr = nullptr;\n@@ -113,3 +113,3 @@\n-        jclass debugeeClass = NULL;\n-        jfieldID objectField = NULL;\n-        jobject object = NULL;\n+        jclass debugeeClass = nullptr;\n+        jfieldID objectField = nullptr;\n+        jobject object = nullptr;\n@@ -119,1 +119,1 @@\n-        if (debugeeClass == NULL) {\n+        if (debugeeClass == nullptr) {\n@@ -126,1 +126,1 @@\n-                debugeeClass, objectFieldName, debugeeClassSignature)) != NULL)) {\n+                debugeeClass, objectFieldName, debugeeClassSignature)) != nullptr)) {\n@@ -133,1 +133,1 @@\n-                jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+                jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -172,1 +172,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -180,1 +180,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -196,1 +196,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverObjectsReachableFromObject\/iterobjreachobj003\/iterobjreachobj003.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv* st_jvmti = NULL;\n+static jvmtiEnv* st_jvmti = nullptr;\n@@ -38,1 +38,1 @@\n-static void *storage_ptr = NULL;\n+static void *storage_ptr = nullptr;\n@@ -78,3 +78,3 @@\n-        jclass debugeeClass = NULL;\n-        jfieldID objectField = NULL;\n-        jobject object = NULL;\n+        jclass debugeeClass = nullptr;\n+        jfieldID objectField = nullptr;\n+        jobject object = nullptr;\n@@ -84,1 +84,1 @@\n-        if (debugeeClass == NULL) {\n+        if (debugeeClass == nullptr) {\n@@ -91,1 +91,1 @@\n-                debugeeClass, objectFieldName, debugeeClassSignature)) != NULL)) {\n+                debugeeClass, objectFieldName, debugeeClassSignature)) != nullptr)) {\n@@ -98,1 +98,1 @@\n-                jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+                jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -149,1 +149,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -157,1 +157,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -173,1 +173,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverObjectsReachableFromObject\/iterobjreachobj004\/iterobjreachobj004.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv* st_jvmti = NULL;\n+static jvmtiEnv* st_jvmti = nullptr;\n@@ -118,3 +118,3 @@\n-            jclass debugeeClass = NULL;\n-            jfieldID objectField = NULL;\n-            jobject object = NULL;\n+            jclass debugeeClass = nullptr;\n+            jfieldID objectField = nullptr;\n+            jobject object = nullptr;\n@@ -124,1 +124,1 @@\n-            if (debugeeClass == NULL) {\n+            if (debugeeClass == nullptr) {\n@@ -131,1 +131,1 @@\n-                    debugeeClass, objectFieldName, debugeeClassSignature)) != NULL)) {\n+                    debugeeClass, objectFieldName, debugeeClassSignature)) != nullptr)) {\n@@ -138,1 +138,1 @@\n-                    jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+                    jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -178,1 +178,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -186,1 +186,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -203,1 +203,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverObjectsReachableFromObject\/iterobjreachobj005\/iterobjreachobj005.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-static ObjectDesc* objectDescList = NULL;\n+static ObjectDesc* objectDescList = nullptr;\n@@ -81,1 +81,1 @@\n-    jobject obj = NULL;\n+    jobject obj = nullptr;\n@@ -90,1 +90,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetObjectField(firstObject, firstField)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetObjectField(firstObject, firstField)) != nullptr)) {\n@@ -115,3 +115,3 @@\n-    jclass debugeeClass = NULL;\n-    jclass rootObjectClass = NULL;\n-    jclass chainObjectClass = NULL;\n+    jclass debugeeClass = nullptr;\n+    jclass rootObjectClass = nullptr;\n+    jclass chainObjectClass = nullptr;\n@@ -119,4 +119,4 @@\n-    jfieldID objectField = NULL;\n-    jfieldID reachableChainField = NULL;\n-    jfieldID unreachableChainField = NULL;\n-    jfieldID tailField = NULL;\n+    jfieldID objectField = nullptr;\n+    jfieldID reachableChainField = nullptr;\n+    jfieldID unreachableChainField = nullptr;\n+    jfieldID tailField = nullptr;\n@@ -124,1 +124,1 @@\n-    jobject rootObject = NULL;\n+    jobject rootObject = nullptr;\n@@ -148,1 +148,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -155,1 +155,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (rootObjectClass = jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (rootObjectClass = jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -163,1 +163,1 @@\n-            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -171,1 +171,1 @@\n-            debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != NULL)) {\n+            debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -179,1 +179,1 @@\n-            rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -187,1 +187,1 @@\n-            rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -195,1 +195,1 @@\n-            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -203,1 +203,1 @@\n-            jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+            jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -279,1 +279,1 @@\n-    if (objectDescList != NULL) {\n+    if (objectDescList != nullptr) {\n@@ -300,1 +300,1 @@\n-                        (long)(tag_ptr == NULL ? (jlong)0 : *tag_ptr));\n+                        (long)(tag_ptr == nullptr ? (jlong)0 : *tag_ptr));\n@@ -303,2 +303,2 @@\n-    if (tag_ptr == NULL) {\n-        NSK_COMPLAIN4(\"NULL tag_ptr is passed to heapRootCallback:\\n\"\n+    if (tag_ptr == nullptr) {\n+        NSK_COMPLAIN4(\"null tag_ptr is passed to heapRootCallback:\\n\"\n@@ -316,1 +316,1 @@\n-    if (tag_ptr != NULL && *tag_ptr != 0) {\n+    if (tag_ptr != nullptr && *tag_ptr != 0) {\n@@ -392,1 +392,1 @@\n-                        (long)(tag_ptr == NULL ? (jlong)0 : *tag_ptr),\n+                        (long)(tag_ptr == nullptr ? (jlong)0 : *tag_ptr),\n@@ -396,2 +396,2 @@\n-    if (tag_ptr == NULL) {\n-        NSK_COMPLAIN8(\"NULL tag_ptr is passed to stackReferenceCallback:\\n\"\n+    if (tag_ptr == nullptr) {\n+        NSK_COMPLAIN8(\"null tag_ptr is passed to stackReferenceCallback:\\n\"\n@@ -417,1 +417,1 @@\n-    if (tag_ptr != NULL && *tag_ptr != 0) {\n+    if (tag_ptr != nullptr && *tag_ptr != 0) {\n@@ -517,1 +517,1 @@\n-                        (long)(tag_ptr == NULL ? (jlong)0 : *tag_ptr),\n+                        (long)(tag_ptr == nullptr ? (jlong)0 : *tag_ptr),\n@@ -521,2 +521,2 @@\n-    if (tag_ptr == NULL) {\n-        NSK_COMPLAIN6(\"NULL tag_ptr is passed to objectReferenceCallback:\\n\"\n+    if (tag_ptr == nullptr) {\n+        NSK_COMPLAIN6(\"null tag_ptr is passed to objectReferenceCallback:\\n\"\n@@ -538,1 +538,1 @@\n-    if (tag_ptr != NULL && *tag_ptr != 0) {\n+    if (tag_ptr != nullptr && *tag_ptr != 0) {\n@@ -673,1 +673,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -682,1 +682,1 @@\n-        if (infoOpt != NULL) {\n+        if (infoOpt != nullptr) {\n@@ -707,1 +707,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -720,1 +720,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverReachableObjects\/iterreachobj001\/iterreachobj001.cpp","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -449,1 +449,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -480,1 +480,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -484,1 +484,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverReachableObjects\/iterreachobj002\/iterreachobj002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv* st_jvmti = NULL;\n+static jvmtiEnv* st_jvmti = nullptr;\n@@ -53,1 +53,1 @@\n-    jrawMonitorID monitor_ptr = NULL;\n+    jrawMonitorID monitor_ptr = nullptr;\n@@ -117,1 +117,1 @@\n-    jrawMonitorID monitor_ptr = NULL;\n+    jrawMonitorID monitor_ptr = nullptr;\n@@ -180,1 +180,1 @@\n-    jrawMonitorID monitor_ptr = NULL;\n+    jrawMonitorID monitor_ptr = nullptr;\n@@ -288,1 +288,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -296,1 +296,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -312,1 +312,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverReachableObjects\/iterreachobj003\/iterreachobj003.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv* st_jvmti = NULL;\n+static jvmtiEnv* st_jvmti = nullptr;\n@@ -40,1 +40,1 @@\n-static void *storage_ptr = NULL;\n+static void *storage_ptr = nullptr;\n@@ -229,1 +229,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -237,1 +237,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -253,1 +253,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverReachableObjects\/iterreachobj004\/iterreachobj004.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv* st_jvmti = NULL;\n+static jvmtiEnv* st_jvmti = nullptr;\n@@ -298,1 +298,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -306,1 +306,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -323,1 +323,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateOverReachableObjects\/iterreachobj005\/iterreachobj005.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-  if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL))) {\n+  if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr))) {\n@@ -98,1 +98,1 @@\n-  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(0, NULL, &primitive_callbacks, &invocations))) {\n+  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(0, nullptr, &primitive_callbacks, &invocations))) {\n@@ -130,1 +130,1 @@\n-  if (!NSK_VERIFY(jvmti != NULL)) {\n+  if (!NSK_VERIFY(jvmti != nullptr)) {\n@@ -151,1 +151,1 @@\n-  if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agent, NULL))) {\n+  if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agent, nullptr))) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateThroughHeap\/abort\/Abort.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -371,1 +371,1 @@\n-  if (!NSK_VERIFY(NULL != (debugee = jni->FindClass(className))))\n+  if (!NSK_VERIFY(nullptr != (debugee = jni->FindClass(className))))\n@@ -374,1 +374,1 @@\n-  if (!NSK_VERIFY(NULL != (testObjectsField = jni->GetStaticFieldID(debugee, fieldName, fieldSig))))\n+  if (!NSK_VERIFY(nullptr != (testObjectsField = jni->GetStaticFieldID(debugee, fieldName, fieldSig))))\n@@ -377,1 +377,1 @@\n-  if (!NSK_VERIFY(NULL != (testObjects = (jobjectArray)(jni->GetStaticObjectField(\n+  if (!NSK_VERIFY(nullptr != (testObjects = (jobjectArray)(jni->GetStaticObjectField(\n@@ -389,1 +389,1 @@\n-    if (!NSK_VERIFY(NULL != (target = jni->GetObjectArrayElement(testObjects, object))))\n+    if (!NSK_VERIFY(nullptr != (target = jni->GetObjectArrayElement(testObjects, object))))\n@@ -392,1 +392,1 @@\n-    if (!NSK_VERIFY(NULL != (targetClass = jni->GetObjectClass(target))))\n+    if (!NSK_VERIFY(nullptr != (targetClass = jni->GetObjectClass(target))))\n@@ -395,1 +395,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(targetClass, &(objects_info[object].name), NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(targetClass, &(objects_info[object].name), nullptr)))\n@@ -410,1 +410,1 @@\n-                                                NULL)))\n+                                                nullptr)))\n@@ -423,1 +423,1 @@\n-          if (!NSK_VERIFY(NULL != (value = jni->GetStaticObjectField(targetClass,\n+          if (!NSK_VERIFY(nullptr != (value = jni->GetStaticObjectField(targetClass,\n@@ -428,1 +428,1 @@\n-          if (!NSK_VERIFY(NULL != (value = jni->GetObjectField(target, targetFields[field])))) {\n+          if (!NSK_VERIFY(nullptr != (value = jni->GetObjectField(target, targetFields[field])))) {\n@@ -518,1 +518,1 @@\n-  if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL))) {\n+  if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr))) {\n@@ -537,1 +537,1 @@\n-  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(0, NULL, &primitive_callbacks, NULL))) {\n+  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(0, nullptr, &primitive_callbacks, nullptr))) {\n@@ -554,1 +554,1 @@\n-  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(0, NULL, &primitive_callbacks, NULL))) {\n+  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(0, nullptr, &primitive_callbacks, nullptr))) {\n@@ -562,1 +562,1 @@\n-  if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, NULL))) {\n+  if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_DISABLE, 1, &event, nullptr))) {\n@@ -589,1 +589,1 @@\n-  if (!NSK_VERIFY(jvmti != NULL)) {\n+  if (!NSK_VERIFY(jvmti != nullptr)) {\n@@ -611,1 +611,1 @@\n-  if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agent, NULL))) {\n+  if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agent, nullptr))) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateThroughHeap\/callbacks\/Callbacks.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,1 +155,1 @@\n-  if (!NSK_VERIFY(NULL != (debugee = jni->FindClass(className))))\n+  if (!NSK_VERIFY(nullptr != (debugee = jni->FindClass(className))))\n@@ -158,1 +158,1 @@\n-  if (!NSK_VERIFY(NULL != (testObjectField = jni->GetStaticFieldID(debugee, fieldName, fieldSig))))\n+  if (!NSK_VERIFY(nullptr != (testObjectField = jni->GetStaticFieldID(debugee, fieldName, fieldSig))))\n@@ -161,1 +161,1 @@\n-  if (!NSK_VERIFY(NULL != (testObject = (jni->GetStaticObjectField(debugee, testObjectField)))))\n+  if (!NSK_VERIFY(nullptr != (testObject = (jni->GetStaticObjectField(debugee, testObjectField)))))\n@@ -164,1 +164,1 @@\n-  if (!NSK_VERIFY(NULL != (testObjectClass = (jni->GetObjectClass(testObject)))))\n+  if (!NSK_VERIFY(nullptr != (testObjectClass = (jni->GetObjectClass(testObject)))))\n@@ -200,1 +200,1 @@\n-  if (!NSK_VERIFY(NULL != (klass = jni->FindClass(testClassName)))) {\n+  if (!NSK_VERIFY(nullptr != (klass = jni->FindClass(testClassName)))) {\n@@ -207,1 +207,1 @@\n-  if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL))) {\n+  if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr))) {\n@@ -226,1 +226,1 @@\n-  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(0, klass, &primitive_callbacks, NULL))) {\n+  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(0, klass, &primitive_callbacks, nullptr))) {\n@@ -243,1 +243,1 @@\n-  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(0, klass, &primitive_callbacks, NULL))) {\n+  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(0, klass, &primitive_callbacks, nullptr))) {\n@@ -272,1 +272,1 @@\n-  if (!NSK_VERIFY(jvmti != NULL)) {\n+  if (!NSK_VERIFY(jvmti != nullptr)) {\n@@ -294,1 +294,1 @@\n-  if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agent, NULL))) {\n+  if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agent, nullptr))) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateThroughHeap\/concrete-klass-filter\/ConcreteKlassFilter.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -297,1 +297,1 @@\n-  if (!NSK_VERIFY(NULL != (debugee = jni->FindClass(className))))\n+  if (!NSK_VERIFY(nullptr != (debugee = jni->FindClass(className))))\n@@ -300,1 +300,1 @@\n-  if (!NSK_VERIFY(NULL != (testObjectsField = jni->GetStaticFieldID(debugee, fieldName, fieldSig))))\n+  if (!NSK_VERIFY(nullptr != (testObjectsField = jni->GetStaticFieldID(debugee, fieldName, fieldSig))))\n@@ -303,1 +303,1 @@\n-  if (!NSK_VERIFY(NULL != (testObjects = (jobjectArray)(jni->GetStaticObjectField(\n+  if (!NSK_VERIFY(nullptr != (testObjects = (jobjectArray)(jni->GetStaticObjectField(\n@@ -316,1 +316,1 @@\n-    if (!NSK_VERIFY(NULL != (target = jni->GetObjectArrayElement(testObjects, object))))\n+    if (!NSK_VERIFY(nullptr != (target = jni->GetObjectArrayElement(testObjects, object))))\n@@ -319,1 +319,1 @@\n-    if (!NSK_VERIFY(NULL != (targetClass = jni->GetObjectClass(target))))\n+    if (!NSK_VERIFY(nullptr != (targetClass = jni->GetObjectClass(target))))\n@@ -322,1 +322,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(targetClass, &(objects_info[object].name), NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(targetClass, &(objects_info[object].name), nullptr)))\n@@ -340,1 +340,1 @@\n-                                                NULL)))\n+                                                nullptr)))\n@@ -365,1 +365,1 @@\n-          if (!NSK_VERIFY(NULL != (value = jni->GetStaticObjectField(\n+          if (!NSK_VERIFY(nullptr != (value = jni->GetStaticObjectField(\n@@ -370,1 +370,1 @@\n-          if (!NSK_VERIFY(NULL != (value = jni->GetObjectField(target, targetFields[field])))) {\n+          if (!NSK_VERIFY(nullptr != (value = jni->GetObjectField(target, targetFields[field])))) {\n@@ -459,1 +459,1 @@\n-  if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL))) {\n+  if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr))) {\n@@ -478,1 +478,1 @@\n-  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(filter_type, NULL, &primitive_callbacks, NULL))) {\n+  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(filter_type, nullptr, &primitive_callbacks, nullptr))) {\n@@ -495,1 +495,1 @@\n-  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(filter_type, NULL, &primitive_callbacks, NULL))) {\n+  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(filter_type, nullptr, &primitive_callbacks, nullptr))) {\n@@ -536,1 +536,1 @@\n-  if (!NSK_VERIFY(jvmti != NULL)) {\n+  if (!NSK_VERIFY(jvmti != nullptr)) {\n@@ -543,1 +543,1 @@\n-  if (type != NULL) {\n+  if (type != nullptr) {\n@@ -577,1 +577,1 @@\n-  if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agent, NULL))) {\n+  if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agent, nullptr))) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateThroughHeap\/filter-tagged\/HeapFilter.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,1 +144,1 @@\n-  if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, NULL))) {\n+  if (!NSK_VERIFY(nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, &event, nullptr))) {\n@@ -159,1 +159,1 @@\n-    if (!NSK_VERIFY(NULL != (klass = jni->FindClass(types[i])))) {\n+    if (!NSK_VERIFY(nullptr != (klass = jni->FindClass(types[i])))) {\n@@ -165,1 +165,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(0, klass, &primitive_callbacks, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(0, klass, &primitive_callbacks, nullptr))) {\n@@ -173,1 +173,1 @@\n-  if (!NSK_VERIFY(NULL != (klass = jni->FindClass(\"java\/lang\/Class\")))) {\n+  if (!NSK_VERIFY(nullptr != (klass = jni->FindClass(\"java\/lang\/Class\")))) {\n@@ -178,1 +178,1 @@\n-  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(0, klass, &primitive_callbacks, NULL))) {\n+  if (!NSK_JVMTI_VERIFY(jvmti->IterateThroughHeap(0, klass, &primitive_callbacks, nullptr))) {\n@@ -212,1 +212,1 @@\n-  if (!NSK_VERIFY(jvmti != NULL)) {\n+  if (!NSK_VERIFY(jvmti != nullptr)) {\n@@ -233,1 +233,1 @@\n-  if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agent, NULL))) {\n+  if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agent, nullptr))) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/IterateThroughHeap\/non-concrete-klass-filter\/NonConcreteKlassFilter.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -42,3 +42,3 @@\n-static jthread currThread = NULL, popThread = NULL;\n-static jclass currClass = NULL, popClass = NULL;\n-static jmethodID currMethod = NULL, popMethod = NULL;\n+static jthread currThread = nullptr, popThread = nullptr;\n+static jclass currClass = nullptr, popClass = nullptr;\n+static jmethodID currMethod = nullptr, popMethod = nullptr;\n@@ -136,1 +136,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -193,1 +193,1 @@\n-            JVMTI_EVENT_FRAME_POP, NULL);\n+            JVMTI_EVENT_FRAME_POP, nullptr);\n@@ -203,1 +203,1 @@\n-    if (mid1 == NULL) {\n+    if (mid1 == nullptr) {\n@@ -210,1 +210,1 @@\n-    if (mid2 == NULL) {\n+    if (mid2 == nullptr) {\n@@ -218,1 +218,1 @@\n-            JVMTI_EVENT_EXCEPTION_CATCH, NULL);\n+            JVMTI_EVENT_EXCEPTION_CATCH, nullptr);\n@@ -248,1 +248,1 @@\n-    if (currClass == NULL) {\n+    if (currClass == nullptr) {\n@@ -256,1 +256,1 @@\n-    if (currMethod == NULL) {\n+    if (currMethod == nullptr) {\n@@ -322,3 +322,3 @@\n-    currThread = NULL; popThread = NULL;\n-    currClass = NULL; popClass = NULL;\n-    currMethod = NULL; popMethod = NULL;\n+    currThread = nullptr; popThread = nullptr;\n+    currClass = nullptr; popClass = nullptr;\n+    currMethod = nullptr; popMethod = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NotifyFramePop\/nframepop001\/nframepop001.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -94,1 +94,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NotifyFramePop\/nframepop002\/nframepop002.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -94,1 +94,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NotifyFramePop\/nframepop003\/nframepop003.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -134,1 +134,1 @@\n-    LocalStorage* obtainedData = NULL;\n+    LocalStorage* obtainedData = nullptr;\n@@ -256,1 +256,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -285,1 +285,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -289,1 +289,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ObjectFree\/objfree001\/objfree001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -164,1 +164,1 @@\n-    LocalStorage* obtainedData = NULL;\n+    LocalStorage* obtainedData = nullptr;\n@@ -276,1 +276,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -305,1 +305,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -309,1 +309,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ObjectFree\/objfree002\/objfree002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -178,1 +178,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe001\/popframe001.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-    \/* NULL pointer to the thread*\/\n+    \/* nullptr pointer to the thread*\/\n@@ -107,1 +107,1 @@\n-        printf(\"\\nInvoke PopFrame() with NULL pointer to a thread...\\n\");\n+        printf(\"\\nInvoke PopFrame() with null pointer to a thread...\\n\");\n@@ -110,1 +110,1 @@\n-        err = (jvmti->PopFrame(NULL)); \/* explode the bomb *\/\n+        err = (jvmti->PopFrame(nullptr)); \/* explode the bomb *\/\n@@ -196,1 +196,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe002\/popframe002.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,1 +180,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe003\/popframe003.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,1 +222,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -289,1 +289,1 @@\n-    jmethodID mid = NULL;\n+    jmethodID mid = nullptr;\n@@ -292,1 +292,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe004\/popframe004.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-    if (p != NULL)                 \\\n+    if (p != nullptr)                 \\\n@@ -109,1 +109,1 @@\n-            if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(klass, &class_signature, NULL)))\n+            if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(klass, &class_signature, nullptr)))\n@@ -114,1 +114,1 @@\n-            if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(method, &entry_name, &entry_sig, NULL)))\n+            if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(method, &entry_name, &entry_sig, nullptr)))\n@@ -122,1 +122,1 @@\n-                    , thr_info.name == NULL ? \"<Unnamed>\" : thr_info.name\n+                    , thr_info.name == nullptr ? \"<Unnamed>\" : thr_info.name\n@@ -257,1 +257,1 @@\n-            (jvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != NULL\n+            (jvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != nullptr\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe005\/popframe005.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -112,1 +112,1 @@\n-    if (sigClass == NULL || strcmp(sigClass, checks[i].cls) != 0) {\n+    if (sigClass == nullptr || strcmp(sigClass, checks[i].cls) != 0) {\n@@ -117,1 +117,1 @@\n-    if (name == NULL || strcmp(name, checks[i].name) != 0) {\n+    if (name == nullptr || strcmp(name, checks[i].name) != 0) {\n@@ -122,1 +122,1 @@\n-    if (sig == NULL || strcmp(sig, checks[i].sig) != 0) {\n+    if (sig == nullptr || strcmp(sig, checks[i].sig) != 0) {\n@@ -352,1 +352,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -357,1 +357,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -412,1 +412,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -427,1 +427,1 @@\n-    if (clazz == NULL) {\n+    if (clazz == nullptr) {\n@@ -434,1 +434,1 @@\n-    if (mid_run == NULL) {\n+    if (mid_run == nullptr) {\n@@ -441,1 +441,1 @@\n-    if (mid_A == NULL) {\n+    if (mid_A == nullptr) {\n@@ -448,1 +448,1 @@\n-    if (mid_B == NULL) {\n+    if (mid_B == nullptr) {\n@@ -455,1 +455,1 @@\n-    if (mid_C == NULL) {\n+    if (mid_C == nullptr) {\n@@ -470,1 +470,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n@@ -484,1 +484,1 @@\n-        JVMTI_EVENT_FRAME_POP, NULL);\n+        JVMTI_EVENT_FRAME_POP, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe006\/popframe006.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -89,1 +89,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -94,1 +94,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -145,1 +145,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -156,1 +156,1 @@\n-    if (clazz == NULL) {\n+    if (clazz == nullptr) {\n@@ -163,1 +163,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -178,1 +178,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n@@ -193,1 +193,1 @@\n-    if (mid != NULL) {\n+    if (mid != nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe007\/popframe007.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -48,2 +48,2 @@\n-static jmethodID midD = NULL;\n-static jmethodID midRun = NULL;\n+static jmethodID midD = nullptr;\n+static jmethodID midRun = nullptr;\n@@ -86,1 +86,1 @@\n-    if (sigClass == NULL || strcmp(sigClass, frames[i].cls) != 0) {\n+    if (sigClass == nullptr || strcmp(sigClass, frames[i].cls) != 0) {\n@@ -91,1 +91,1 @@\n-    if (name == NULL || strcmp(name, frames[i].name) != 0) {\n+    if (name == nullptr || strcmp(name, frames[i].name) != 0) {\n@@ -96,1 +96,1 @@\n-    if (sig == NULL || strcmp(sig, frames[i].sig) != 0) {\n+    if (sig == nullptr || strcmp(sig, frames[i].sig) != 0) {\n@@ -198,1 +198,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -203,1 +203,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -256,1 +256,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -269,1 +269,1 @@\n-    if (clazz == NULL) {\n+    if (clazz == nullptr) {\n@@ -276,1 +276,1 @@\n-    if (midD == NULL) {\n+    if (midD == nullptr) {\n@@ -283,1 +283,1 @@\n-    if (midRun == NULL) {\n+    if (midRun == nullptr) {\n@@ -298,1 +298,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe008\/popframe008.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -40,3 +40,3 @@\n-static jrawMonitorID breakpointLock = NULL;\n-static jrawMonitorID popFrameLock = NULL;\n-static jrawMonitorID suspendLock = NULL;\n+static jrawMonitorID breakpointLock = nullptr;\n+static jrawMonitorID popFrameLock = nullptr;\n+static jrawMonitorID suspendLock = nullptr;\n@@ -46,2 +46,2 @@\n-static jmethodID midCheckPoint = NULL;\n-static jmethodID midRun = NULL;\n+static jmethodID midCheckPoint = nullptr;\n+static jmethodID midRun = nullptr;\n@@ -168,1 +168,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -173,1 +173,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -228,1 +228,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -241,1 +241,1 @@\n-    if (midCheckPoint == NULL) {\n+    if (midCheckPoint == nullptr) {\n@@ -264,1 +264,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n@@ -334,1 +334,1 @@\n-    jmethodID method = NULL;\n+    jmethodID method = nullptr;\n@@ -341,1 +341,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -415,1 +415,1 @@\n-    if (midFibonacci == NULL) {\n+    if (midFibonacci == nullptr) {\n@@ -421,1 +421,1 @@\n-    if (clazz == NULL) {\n+    if (clazz == nullptr) {\n@@ -427,1 +427,1 @@\n-    if (midRun == NULL) {\n+    if (midRun == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe009\/popframe009.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -41,2 +41,2 @@\n-static jmethodID midCheckPoint = NULL;\n-static jmethodID midRun = NULL;\n+static jmethodID midCheckPoint = nullptr;\n+static jmethodID midRun = nullptr;\n@@ -55,1 +55,1 @@\n-    jvmtiLocalVariableEntry *table = NULL;\n+    jvmtiLocalVariableEntry *table = nullptr;\n@@ -88,1 +88,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -108,1 +108,1 @@\n-    if (sigClass == NULL || strcmp(sigClass, cls_exp) != 0) {\n+    if (sigClass == nullptr || strcmp(sigClass, cls_exp) != 0) {\n@@ -113,1 +113,1 @@\n-    if (name == NULL || strcmp(name, name_exp) != 0) {\n+    if (name == nullptr || strcmp(name, name_exp) != 0) {\n@@ -118,1 +118,1 @@\n-    if (sig == NULL || strcmp(sig, sig_exp) != 0) {\n+    if (sig == nullptr || strcmp(sig, sig_exp) != 0) {\n@@ -135,1 +135,1 @@\n-    if (sigClass != NULL) {\n+    if (sigClass != nullptr) {\n@@ -138,1 +138,1 @@\n-    if (name != NULL) {\n+    if (name != nullptr) {\n@@ -141,1 +141,1 @@\n-    if (sig != NULL) {\n+    if (sig != nullptr) {\n@@ -144,1 +144,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -235,1 +235,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -240,1 +240,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -291,1 +291,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -304,1 +304,1 @@\n-    if (midRun == NULL) {\n+    if (midRun == nullptr) {\n@@ -311,1 +311,1 @@\n-    if (midCheckPoint == NULL) {\n+    if (midCheckPoint == nullptr) {\n@@ -326,1 +326,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe010\/popframe010.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-\/* NULL pointer to the thread in debug mode *\/\n+\/* nullptr pointer to the thread in debug mode *\/\n@@ -116,1 +116,1 @@\n-        printf(\"\\nInvoke PopFrame() with NULL pointer to a thread...\\n\");\n+        printf(\"\\nInvoke PopFrame() with null pointer to a thread...\\n\");\n@@ -119,1 +119,1 @@\n-\/* NULL pointer to the thread *\/\n+\/* nullptr pointer to the thread *\/\n@@ -122,1 +122,1 @@\n-        popframe_err = (jvmti->PopFrame(NULL)); \/* explode the bomb *\/\n+        popframe_err = (jvmti->PopFrame(nullptr)); \/* explode the bomb *\/\n@@ -248,1 +248,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/PopFrame\/popframe011\/popframe011.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -105,1 +105,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -110,1 +110,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -124,1 +124,1 @@\n-            JVMTI_EVENT_VM_INIT, NULL);\n+            JVMTI_EVENT_VM_INIT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorEnter\/rawmonenter001\/rawmonenter001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -71,1 +71,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -80,1 +80,1 @@\n-    err = jvmti->RawMonitorEnter(NULL);\n+    err = jvmti->RawMonitorEnter(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorEnter\/rawmonenter002\/rawmonenter002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorEnter\/rawmonenter003\/rawmonenter003.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -60,1 +60,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -65,1 +65,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -107,1 +107,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -134,1 +134,1 @@\n-        err = jvmti->RunAgentThread(thr, increment_thread, NULL,\n+        err = jvmti->RunAgentThread(thr, increment_thread, nullptr,\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorEnter\/rawmonenter004\/rawmonenter004.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -118,1 +118,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -123,1 +123,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -137,1 +137,1 @@\n-            JVMTI_EVENT_VM_INIT, NULL);\n+            JVMTI_EVENT_VM_INIT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorExit\/rawmonexit001\/rawmonexit001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -71,1 +71,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -80,1 +80,1 @@\n-    err = jvmti->RawMonitorExit(NULL);\n+    err = jvmti->RawMonitorExit(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorExit\/rawmonexit002\/rawmonexit002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorExit\/rawmonexit003\/rawmonexit003.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -72,1 +72,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorExit\/rawmonexit005\/rawmonexit005.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -131,1 +131,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -136,1 +136,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -150,1 +150,1 @@\n-            JVMTI_EVENT_VM_INIT, NULL);\n+            JVMTI_EVENT_VM_INIT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorNotify\/rawmnntfy001\/rawmnntfy001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -71,1 +71,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -80,1 +80,1 @@\n-    err = jvmti->RawMonitorNotify(NULL);\n+    err = jvmti->RawMonitorNotify(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorNotify\/rawmnntfy002\/rawmnntfy002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorNotify\/rawmnntfy003\/rawmnntfy003.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -72,1 +72,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorNotify\/rawmnntfy004\/rawmnntfy004.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -131,1 +131,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -136,1 +136,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -150,1 +150,1 @@\n-            JVMTI_EVENT_VM_INIT, NULL);\n+            JVMTI_EVENT_VM_INIT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorNotifyAll\/rawmnntfyall001\/rawmnntfyall001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -71,1 +71,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -80,1 +80,1 @@\n-    err = jvmti->RawMonitorNotifyAll(NULL);\n+    err = jvmti->RawMonitorNotifyAll(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorNotifyAll\/rawmnntfyall002\/rawmnntfyall002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorNotifyAll\/rawmnntfyall003\/rawmnntfyall003.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -72,1 +72,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorNotifyAll\/rawmnntfyall004\/rawmnntfyall004.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -132,1 +132,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -137,1 +137,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -151,1 +151,1 @@\n-            JVMTI_EVENT_VM_INIT, NULL);\n+            JVMTI_EVENT_VM_INIT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorWait\/rawmnwait001\/rawmnwait001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -55,1 +55,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -60,1 +60,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -72,1 +72,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -81,1 +81,1 @@\n-    err = jvmti->RawMonitorWait(NULL, MONITOR_WAIT_TIMEOUT);\n+    err = jvmti->RawMonitorWait(nullptr, MONITOR_WAIT_TIMEOUT);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorWait\/rawmnwait002\/rawmnwait002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -57,1 +57,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -62,1 +62,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -74,1 +74,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorWait\/rawmnwait003\/rawmnwait003.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -55,1 +55,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -60,1 +60,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -73,1 +73,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorWait\/rawmnwait004\/rawmnwait004.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -60,1 +60,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -65,1 +65,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -209,1 +209,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -264,1 +264,1 @@\n-    err = jvmti->RunAgentThread(thr, test_thread, NULL,\n+    err = jvmti->RunAgentThread(thr, test_thread, nullptr,\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorWait\/rawmnwait005\/rawmnwait005.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -83,1 +83,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -95,1 +95,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/StressRedefine\/stressRedefine.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -94,1 +94,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -106,1 +106,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass001\/redefclass001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -136,1 +136,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -148,1 +148,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass002\/redefclass002.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -97,1 +97,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -109,1 +109,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, nullptr);\n@@ -143,1 +143,1 @@\n-    if (fid == NULL) {\n+    if (fid == nullptr) {\n@@ -151,1 +151,1 @@\n-    if (fid == NULL) {\n+    if (fid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass003\/redefclass003.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -102,1 +102,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -114,1 +114,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, nullptr);\n@@ -149,1 +149,1 @@\n-    const char *strFld = NULL;\n+    const char *strFld = nullptr;\n@@ -153,1 +153,1 @@\n-    if (fid == NULL) {\n+    if (fid == nullptr) {\n@@ -162,1 +162,1 @@\n-    if (fid == NULL) {\n+    if (fid == nullptr) {\n@@ -171,1 +171,1 @@\n-    if (fid == NULL) {\n+    if (fid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass004\/redefclass004.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -62,1 +62,1 @@\n-    if (watch_ev && class_being_redefined != NULL) {\n+    if (watch_ev && class_being_redefined != nullptr) {\n@@ -167,1 +167,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -183,1 +183,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n@@ -205,1 +205,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass005\/redefclass005.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -93,1 +93,1 @@\n-    jvmtiClassDefinition* classDefPtr = NULL;\n+    jvmtiClassDefinition* classDefPtr = nullptr;\n@@ -95,1 +95,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -105,1 +105,1 @@\n-\/* NULL pointer to the jvmtiClassDefinition *\/\n+\/* nullptr pointer to the jvmtiClassDefinition *\/\n@@ -108,1 +108,1 @@\n-\/* NULL pointer to the jvmtiClassDefinition in debug mode *\/\n+\/* nullptr pointer to the jvmtiClassDefinition in debug mode *\/\n@@ -110,1 +110,1 @@\n-            printf(\"Invoke RedefineClasses() with NULL pointer to the structure jvmtiClassDefinition\\n\");\n+            printf(\"Invoke RedefineClasses() with null pointer to the structure jvmtiClassDefinition\\n\");\n@@ -113,1 +113,1 @@\n-\/* NULL pointer to the jvmtiClassDefinition->class_bytes in debug mode *\/\n+\/* nullptr pointer to the jvmtiClassDefinition->class_bytes in debug mode *\/\n@@ -115,1 +115,1 @@\n-            printf(\"Invoke RedefineClasses() with NULL pointer to the field jvmtiClassDefinition->class_bytes\\n\");\n+            printf(\"Invoke RedefineClasses() with null pointer to the field jvmtiClassDefinition->class_bytes\\n\");\n@@ -118,1 +118,1 @@\n-\/* NULL pointer to the jvmtiClassDefinition->class_bytes *\/\n+\/* nullptr pointer to the jvmtiClassDefinition->class_bytes *\/\n@@ -123,1 +123,1 @@\n-            classDef.class_bytes = NULL;\n+            classDef.class_bytes = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass006\/redefclass006.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,5 +48,5 @@\n-    { 1, (char*) \"checkIt\", (char*) \"(Ljava\/io\/PrintStream;Z)I\", 0, NULL },\n-    { 1, (char*) \"finMethod\", (char*) \"(JIJ)V\", 5, NULL },\n-    { 1, (char*) \"finMethod\", (char*) \"(JIJ)V\", 4, NULL },\n-    { 1, (char*) \"checkIt\", (char*) \"(Ljava\/io\/PrintStream;Z)I\", 1, NULL },\n-    { 0, (char*) \"statMethod\", (char*) \"(III)I\", 1, NULL }\n+    { 1, (char*) \"checkIt\", (char*) \"(Ljava\/io\/PrintStream;Z)I\", 0, nullptr },\n+    { 1, (char*) \"finMethod\", (char*) \"(JIJ)V\", 5, nullptr },\n+    { 1, (char*) \"finMethod\", (char*) \"(JIJ)V\", 4, nullptr },\n+    { 1, (char*) \"checkIt\", (char*) \"(Ljava\/io\/PrintStream;Z)I\", 1, nullptr },\n+    { 0, (char*) \"statMethod\", (char*) \"(III)I\", 1, nullptr }\n@@ -57,1 +57,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -144,1 +144,1 @@\n-            if (breakpoints[i].mid == NULL) {\n+            if (breakpoints[i].mid == nullptr) {\n@@ -153,1 +153,1 @@\n-            if (breakpoints[i].mid == NULL) {\n+            if (breakpoints[i].mid == nullptr) {\n@@ -177,1 +177,1 @@\n-        err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+        err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n@@ -196,1 +196,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -208,1 +208,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, nullptr);\n@@ -246,1 +246,1 @@\n-            if (breakpoints[i].mid == NULL) {\n+            if (breakpoints[i].mid == nullptr) {\n@@ -256,1 +256,1 @@\n-            if (breakpoints[i].mid == NULL) {\n+            if (breakpoints[i].mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass008\/redefclass008.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-\/* list of original methods with NULL pointers to localVar *\/\n+\/* list of original methods with nullptr pointers to localVar *\/\n@@ -85,4 +85,4 @@\n-    { 1, (char*) \"<init>\", (char*) \"()V\", 1, NULL, NULL },\n-    { 1, (char*) \"checkIt\", (char*) \"(Ljava\/io\/PrintStream;Z)I\", 4, NULL, NULL },\n-    { 1, (char*) \"finMethod\", (char*) \"(CJIJ)V\", 5, NULL, NULL },\n-    { 0, (char*) \"statMethod\", (char*) \"(III)D\", 3, NULL, NULL }\n+    { 1, (char*) \"<init>\", (char*) \"()V\", 1, nullptr, nullptr },\n+    { 1, (char*) \"checkIt\", (char*) \"(Ljava\/io\/PrintStream;Z)I\", 4, nullptr, nullptr },\n+    { 1, (char*) \"finMethod\", (char*) \"(CJIJ)V\", 5, nullptr, nullptr },\n+    { 0, (char*) \"statMethod\", (char*) \"(III)D\", 3, nullptr, nullptr }\n@@ -93,4 +93,4 @@\n-    { 1, (char*) \"<init>\", (char*) \"()V\", 6, constr_lv, NULL },\n-    { 1, (char*) \"checkIt\", (char*) \"(Ljava\/io\/PrintStream;Z)I\", 3, checkIt_lv, NULL },\n-    { 1, (char*) \"finMethod\", (char*) \"(CJIJ)V\", 7, finMeth_lv, NULL },\n-    { 0, (char*) \"statMethod\", (char*) \"(III)D\", 5, statMeth_lv, NULL }\n+    { 1, (char*) \"<init>\", (char*) \"()V\", 6, constr_lv, nullptr },\n+    { 1, (char*) \"checkIt\", (char*) \"(Ljava\/io\/PrintStream;Z)I\", 3, checkIt_lv, nullptr },\n+    { 1, (char*) \"finMethod\", (char*) \"(CJIJ)V\", 7, finMeth_lv, nullptr },\n+    { 0, (char*) \"statMethod\", (char*) \"(III)D\", 5, statMeth_lv, nullptr }\n@@ -99,1 +99,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -177,1 +177,1 @@\n-        if (methodsInfo[i].mid == NULL) {\n+        if (methodsInfo[i].mid == nullptr) {\n@@ -253,1 +253,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -265,1 +265,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass009\/redefclass009.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,4 +64,4 @@\n-    { 1, (char*) \"<init>\", (char*) \"()V\", 1, NULL },\n-    { 1, (char*) \"checkIt\", (char*) \"(Ljava\/io\/PrintStream;Z)I\", 3, NULL },\n-    { 1, (char*) \"finMethod\", (char*) \"(CJIJ)V\", 1, NULL },\n-    { 0, (char*) \"statMethod\", (char*) \"(III)D\", 5, NULL }\n+    { 1, (char*) \"<init>\", (char*) \"()V\", 1, nullptr },\n+    { 1, (char*) \"checkIt\", (char*) \"(Ljava\/io\/PrintStream;Z)I\", 3, nullptr },\n+    { 1, (char*) \"finMethod\", (char*) \"(CJIJ)V\", 1, nullptr },\n+    { 0, (char*) \"statMethod\", (char*) \"(III)D\", 5, nullptr }\n@@ -72,4 +72,4 @@\n-    { 1, (char*) \"<init>\", (char*) \"()V\", 8, NULL },\n-    { 1, (char*) \"checkIt\", (char*) \"(Ljava\/io\/PrintStream;Z)I\", 3, NULL },\n-    { 1, (char*) \"finMethod\", (char*) \"(CJIJ)V\", 7, NULL },\n-    { 0, (char*) \"statMethod\", (char*) \"(III)D\", 1, NULL }\n+    { 1, (char*) \"<init>\", (char*) \"()V\", 8, nullptr },\n+    { 1, (char*) \"checkIt\", (char*) \"(Ljava\/io\/PrintStream;Z)I\", 3, nullptr },\n+    { 1, (char*) \"finMethod\", (char*) \"(CJIJ)V\", 7, nullptr },\n+    { 0, (char*) \"statMethod\", (char*) \"(III)D\", 1, nullptr }\n@@ -78,1 +78,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -155,1 +155,1 @@\n-        if (methodsInfo[i].mid == NULL) {\n+        if (methodsInfo[i].mid == nullptr) {\n@@ -230,1 +230,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -242,1 +242,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass010\/redefclass010.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -100,1 +100,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -105,1 +105,1 @@\n-    classDef.klass = NULL;\n+    classDef.klass = nullptr;\n@@ -107,1 +107,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass011\/redefclass011.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -101,1 +101,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -108,1 +108,1 @@\n-    bytes = (unsigned char *) env->GetByteArrayElements(jbytes, NULL);\n+    bytes = (unsigned char *) env->GetByteArrayElements(jbytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass012\/redefclass012.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -101,1 +101,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -108,1 +108,1 @@\n-    bytes = (unsigned char *) env->GetByteArrayElements(jbytes, NULL);\n+    bytes = (unsigned char *) env->GetByteArrayElements(jbytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass013\/redefclass013.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -99,1 +99,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -114,1 +114,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass014\/redefclass014.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -100,1 +100,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -107,1 +107,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass015\/redefclass015.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -41,1 +41,1 @@\n-static jmethodID mid = NULL;\n+static jmethodID mid = nullptr;\n@@ -51,1 +51,1 @@\n-    jvmtiLocalVariableEntry *table = NULL;\n+    jvmtiLocalVariableEntry *table = nullptr;\n@@ -80,1 +80,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -105,1 +105,1 @@\n-    if (sigClass != NULL) {\n+    if (sigClass != nullptr) {\n@@ -108,1 +108,1 @@\n-    if (name != NULL) {\n+    if (name != nullptr) {\n@@ -111,1 +111,1 @@\n-    if (sig != NULL) {\n+    if (sig != nullptr) {\n@@ -114,1 +114,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -151,1 +151,1 @@\n-    bytes = (unsigned char *) env->GetByteArrayElements(classBytes, NULL);\n+    bytes = (unsigned char *) env->GetByteArrayElements(classBytes, nullptr);\n@@ -205,1 +205,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -210,1 +210,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -267,1 +267,1 @@\n-    jvmtiLineNumberEntry *lines = NULL;\n+    jvmtiLineNumberEntry *lines = nullptr;\n@@ -270,1 +270,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -282,1 +282,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -298,1 +298,1 @@\n-    if (lines != NULL && entryCount > 0) {\n+    if (lines != nullptr && entryCount > 0) {\n@@ -321,1 +321,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass016\/redefclass016.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -41,1 +41,1 @@\n-static jmethodID mid = NULL;\n+static jmethodID mid = nullptr;\n@@ -67,1 +67,1 @@\n-        env->GetByteArrayElements(classBytes, NULL);\n+        env->GetByteArrayElements(classBytes, nullptr);\n@@ -96,1 +96,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -101,1 +101,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -151,1 +151,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -161,1 +161,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -178,1 +178,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass017\/redefclass017.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -52,1 +52,1 @@\n-            JVMTI_EVENT_EXCEPTION, NULL);\n+            JVMTI_EVENT_EXCEPTION, nullptr);\n@@ -69,1 +69,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, nullptr);\n@@ -98,1 +98,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -103,1 +103,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -154,1 +154,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass018\/redefclass018.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -57,2 +57,2 @@\n-static jmethodID midCheckPoint = NULL;\n-static jmethodID midRun = NULL;\n+static jmethodID midCheckPoint = nullptr;\n+static jmethodID midRun = nullptr;\n@@ -99,1 +99,1 @@\n-    char *sigClass, *name = NULL, *sig = NULL, *generic;\n+    char *sigClass, *name = nullptr, *sig = nullptr, *generic;\n@@ -101,2 +101,2 @@\n-    jvmtiLineNumberEntry *lines = NULL;\n-    jvmtiLocalVariableEntry *table = NULL;\n+    jvmtiLineNumberEntry *lines = nullptr;\n+    jvmtiLocalVariableEntry *table = nullptr;\n@@ -138,1 +138,1 @@\n-    if (sigClass == NULL || strcmp(sigClass, cls_exp) != 0) {\n+    if (sigClass == nullptr || strcmp(sigClass, cls_exp) != 0) {\n@@ -141,1 +141,1 @@\n-        if (sigClass != NULL) {\n+        if (sigClass != nullptr) {\n@@ -170,1 +170,1 @@\n-        if (name == NULL || strcmp(name, frames[i].name) != 0) {\n+        if (name == nullptr || strcmp(name, frames[i].name) != 0) {\n@@ -175,1 +175,1 @@\n-        if (sig == NULL || strcmp(sig, frames[i].sig) != 0) {\n+        if (sig == nullptr || strcmp(sig, frames[i].sig) != 0) {\n@@ -190,1 +190,1 @@\n-        if (lines != NULL && entryCount > 0) {\n+        if (lines != nullptr && entryCount > 0) {\n@@ -219,1 +219,1 @@\n-        if (table != NULL) {\n+        if (table != nullptr) {\n@@ -259,1 +259,1 @@\n-    if (sigClass != NULL) {\n+    if (sigClass != nullptr) {\n@@ -262,1 +262,1 @@\n-    if (name != NULL) {\n+    if (name != nullptr) {\n@@ -265,1 +265,1 @@\n-    if (sig != NULL) {\n+    if (sig != nullptr) {\n@@ -268,1 +268,1 @@\n-    if (lines != NULL) {\n+    if (lines != nullptr) {\n@@ -271,1 +271,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -314,1 +314,1 @@\n-        env->GetByteArrayElements(classBytes, NULL);\n+        env->GetByteArrayElements(classBytes, nullptr);\n@@ -371,1 +371,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -376,1 +376,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -436,1 +436,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -451,1 +451,1 @@\n-    if (midRun == NULL) {\n+    if (midRun == nullptr) {\n@@ -458,1 +458,1 @@\n-    if (midCheckPoint == NULL) {\n+    if (midCheckPoint == nullptr) {\n@@ -473,1 +473,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n@@ -482,1 +482,1 @@\n-        JVMTI_EVENT_FRAME_POP, NULL);\n+        JVMTI_EVENT_FRAME_POP, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass019\/redefclass019.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -100,1 +100,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -107,1 +107,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass020\/redefclass020.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -100,1 +100,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -107,1 +107,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass021\/redefclass021.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -100,1 +100,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -107,1 +107,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass022\/redefclass022.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -100,1 +100,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -107,1 +107,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass023\/redefclass023.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -100,1 +100,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -107,1 +107,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass024\/redefclass024.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -100,1 +100,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -107,1 +107,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass025\/redefclass025.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -100,1 +100,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -107,1 +107,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(bytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass026\/redefclass026.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -59,5 +59,5 @@\n-static jmethodID midRun = NULL;\n-static jmethodID mid1 = NULL;\n-static jmethodID mid2 = NULL;\n-static jfieldID fid1 = NULL;\n-static jfieldID fid2 = NULL;\n+static jmethodID midRun = nullptr;\n+static jmethodID mid1 = nullptr;\n+static jmethodID mid2 = nullptr;\n+static jfieldID fid1 = nullptr;\n+static jfieldID fid2 = nullptr;\n@@ -121,1 +121,1 @@\n-    char *sigClass, *name = NULL, *sig = NULL, *generic;\n+    char *sigClass, *name = nullptr, *sig = nullptr, *generic;\n@@ -124,2 +124,2 @@\n-    jvmtiLineNumberEntry *lines = NULL;\n-    jvmtiLocalVariableEntry *table = NULL;\n+    jvmtiLineNumberEntry *lines = nullptr;\n+    jvmtiLocalVariableEntry *table = nullptr;\n@@ -147,1 +147,1 @@\n-    if (sigClass == NULL || strcmp(sigClass, cls_exp) != 0) {\n+    if (sigClass == nullptr || strcmp(sigClass, cls_exp) != 0) {\n@@ -150,1 +150,1 @@\n-        if (sigClass != NULL) {\n+        if (sigClass != nullptr) {\n@@ -179,1 +179,1 @@\n-        if (name == NULL || strcmp(name, frames[i].name) != 0) {\n+        if (name == nullptr || strcmp(name, frames[i].name) != 0) {\n@@ -184,1 +184,1 @@\n-        if (sig == NULL || strcmp(sig, frames[i].sig) != 0) {\n+        if (sig == nullptr || strcmp(sig, frames[i].sig) != 0) {\n@@ -198,1 +198,1 @@\n-        if (lines != NULL && entryCount > 0) {\n+        if (lines != nullptr && entryCount > 0) {\n@@ -226,1 +226,1 @@\n-        if (table != NULL) {\n+        if (table != nullptr) {\n@@ -275,1 +275,1 @@\n-    if (sigClass != NULL) {\n+    if (sigClass != nullptr) {\n@@ -278,1 +278,1 @@\n-    if (name != NULL) {\n+    if (name != nullptr) {\n@@ -281,1 +281,1 @@\n-    if (sig != NULL) {\n+    if (sig != nullptr) {\n@@ -284,1 +284,1 @@\n-    if (lines != NULL) {\n+    if (lines != nullptr) {\n@@ -287,1 +287,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -302,1 +302,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, nullptr);\n@@ -534,1 +534,1 @@\n-            JVMTI_EVENT_FRAME_POP, NULL);\n+            JVMTI_EVENT_FRAME_POP, nullptr);\n@@ -599,1 +599,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -604,1 +604,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -690,1 +690,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -703,1 +703,1 @@\n-    if (midRun == NULL) {\n+    if (midRun == nullptr) {\n@@ -709,1 +709,1 @@\n-    if (mid1 == NULL) {\n+    if (mid1 == nullptr) {\n@@ -715,1 +715,1 @@\n-    if (mid2 == NULL) {\n+    if (mid2 == nullptr) {\n@@ -720,1 +720,1 @@\n-    if (caps.can_generate_breakpoint_events && midRun != NULL) {\n+    if (caps.can_generate_breakpoint_events && midRun != nullptr) {\n@@ -728,1 +728,1 @@\n-                JVMTI_EVENT_BREAKPOINT, NULL);\n+                JVMTI_EVENT_BREAKPOINT, nullptr);\n@@ -740,1 +740,1 @@\n-    if (fid1 == NULL) {\n+    if (fid1 == nullptr) {\n@@ -745,1 +745,1 @@\n-    if (caps.can_generate_field_modification_events && fid1 != NULL) {\n+    if (caps.can_generate_field_modification_events && fid1 != nullptr) {\n@@ -753,1 +753,1 @@\n-                JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n+                JVMTI_EVENT_FIELD_MODIFICATION, nullptr);\n@@ -765,1 +765,1 @@\n-    if (fid2 == NULL) {\n+    if (fid2 == nullptr) {\n@@ -770,1 +770,1 @@\n-    if (caps.can_generate_field_access_events && fid2 != NULL) {\n+    if (caps.can_generate_field_access_events && fid2 != nullptr) {\n@@ -778,1 +778,1 @@\n-                JVMTI_EVENT_FIELD_ACCESS, NULL);\n+                JVMTI_EVENT_FIELD_ACCESS, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass027\/redefclass027.cpp","additions":37,"deletions":37,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -103,1 +103,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &sig, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &sig, nullptr))) {\n@@ -136,1 +136,1 @@\n-    err = jvmti_env->GetMethodName(method, &name, &sig, NULL);\n+    err = jvmti_env->GetMethodName(method, &name, &sig, nullptr);\n@@ -191,1 +191,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(decl_cls, &cls_sig, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(decl_cls, &cls_sig, nullptr))) {\n@@ -252,1 +252,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -272,1 +272,1 @@\n-            eventsList, NULL))\n+            eventsList, nullptr))\n@@ -277,1 +277,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass028\/redefclass028.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -102,1 +102,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &sig, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &sig, nullptr))) {\n@@ -135,1 +135,1 @@\n-    err = jvmti_env->GetMethodName(method, &name, &sig, NULL);\n+    err = jvmti_env->GetMethodName(method, &name, &sig, nullptr);\n@@ -190,1 +190,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(decl_cls, &cls_sig, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(decl_cls, &cls_sig, nullptr))) {\n@@ -251,1 +251,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -271,1 +271,1 @@\n-            eventsList, NULL))\n+            eventsList, nullptr))\n@@ -276,1 +276,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass029\/redefclass029.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -103,1 +103,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &sig, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &sig, nullptr))) {\n@@ -136,1 +136,1 @@\n-    err = jvmti_env->GetMethodName(method, &name, &sig, NULL);\n+    err = jvmti_env->GetMethodName(method, &name, &sig, nullptr);\n@@ -191,1 +191,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(decl_cls, &cls_sig, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(decl_cls, &cls_sig, nullptr))) {\n@@ -252,1 +252,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -272,1 +272,1 @@\n-            eventsList, NULL))\n+            eventsList, nullptr))\n@@ -277,1 +277,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass030\/redefclass030.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -42,1 +42,1 @@\n-static jthread test_thread = NULL;\n+static jthread test_thread = nullptr;\n@@ -57,1 +57,1 @@\n-    } else if (test_thread != NULL) {\n+    } else if (test_thread != nullptr) {\n@@ -59,1 +59,1 @@\n-        test_thread = NULL;\n+        test_thread = nullptr;\n@@ -88,1 +88,1 @@\n-                if (inf.thread_group != NULL) {\n+                if (inf.thread_group != nullptr) {\n@@ -91,1 +91,1 @@\n-                if (inf.context_class_loader != NULL) {\n+                if (inf.context_class_loader != nullptr) {\n@@ -171,1 +171,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -180,1 +180,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, nullptr);\n@@ -190,1 +190,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RedefineClasses\/redefclass031\/redefclass031.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,1 +305,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -332,1 +332,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -340,1 +340,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -355,1 +355,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -378,1 +378,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RelinquishCapabilities\/relcaps001\/relcaps001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -304,1 +304,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -331,1 +331,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -339,1 +339,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -354,1 +354,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -367,1 +367,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RelinquishCapabilities\/relcaps002\/relcaps002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv* gJvmti = NULL;\n+static jvmtiEnv* gJvmti = nullptr;\n@@ -83,1 +83,1 @@\n-    if (!NSK_VERIFY((gJvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != NULL))\n+    if (!NSK_VERIFY((gJvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != nullptr))\n@@ -99,1 +99,1 @@\n-                                                           NULL)))\n+                                                           nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ResourceExhausted\/resexhausted.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-        jthread testedThread = NULL;\n+        jthread testedThread = nullptr;\n@@ -56,1 +56,1 @@\n-                nsk_jvmti_threadByName(THREAD_NAME)) != NULL))\n+                nsk_jvmti_threadByName(THREAD_NAME)) != nullptr))\n@@ -121,1 +121,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -131,1 +131,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -144,1 +144,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ResumeThread\/resumethrd001\/resumethrd001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-static jthread testedThread = NULL;\n+static jthread testedThread = nullptr;\n@@ -65,1 +65,1 @@\n-                nsk_jvmti_threadByName(THREAD_NAME)) != NULL))\n+                nsk_jvmti_threadByName(THREAD_NAME)) != nullptr))\n@@ -71,1 +71,1 @@\n-        if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL))\n+        if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -105,1 +105,1 @@\n-        if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL))\n+        if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -127,1 +127,1 @@\n-    if (thread != NULL &&\n+    if (thread != nullptr &&\n@@ -151,1 +151,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -161,1 +161,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -183,1 +183,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ResumeThread\/resumethrd002\/resumethrd002.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,2 @@\n-        jthread* threads = NULL;\n-        jvmtiError* results = NULL;\n+        jthread* threads = nullptr;\n+        jvmtiError* results = nullptr;\n@@ -141,1 +141,1 @@\n-            if (threads[i] != NULL)\n+            if (threads[i] != nullptr)\n@@ -167,1 +167,1 @@\n-    jthread* threads = NULL;\n+    jthread* threads = nullptr;\n@@ -174,1 +174,1 @@\n-        foundThreads[i] = NULL;\n+        foundThreads[i] = nullptr;\n@@ -191,1 +191,1 @@\n-        if (info.name != NULL && strncmp(name, info.name, len) == 0) {\n+        if (info.name != nullptr && strncmp(name, info.name, len) == 0) {\n@@ -219,1 +219,1 @@\n-                    jni->NewGlobalRef(foundThreads[i])) != NULL)) {\n+                    jni->NewGlobalRef(foundThreads[i])) != nullptr)) {\n@@ -244,1 +244,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -259,1 +259,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -272,1 +272,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ResumeThreadList\/resumethrdlst001\/resumethrdlst001.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-static jthread* threads = NULL;\n+static jthread* threads = nullptr;\n@@ -70,1 +70,1 @@\n-        jvmtiError* results = NULL;\n+        jvmtiError* results = nullptr;\n@@ -109,1 +109,1 @@\n-        if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL))\n+        if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -148,1 +148,1 @@\n-        if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL))\n+        if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -157,1 +157,1 @@\n-            if (threads[i] != NULL)\n+            if (threads[i] != nullptr)\n@@ -183,1 +183,1 @@\n-    jthread* threads = NULL;\n+    jthread* threads = nullptr;\n@@ -190,1 +190,1 @@\n-        foundThreads[i] = NULL;\n+        foundThreads[i] = nullptr;\n@@ -207,1 +207,1 @@\n-        if (info.name != NULL && strncmp(name, info.name, len) == 0) {\n+        if (info.name != nullptr && strncmp(name, info.name, len) == 0) {\n@@ -235,1 +235,1 @@\n-                    jni->NewGlobalRef(foundThreads[i])) != NULL)) {\n+                    jni->NewGlobalRef(foundThreads[i])) != nullptr)) {\n@@ -260,1 +260,1 @@\n-        if (thread != NULL &&\n+        if (thread != nullptr &&\n@@ -288,1 +288,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -303,1 +303,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -332,1 +332,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ResumeThreadList\/resumethrdlst002\/resumethrdlst002.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -104,1 +104,1 @@\n-                (jvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != NULL\n+                (jvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != nullptr\n@@ -128,1 +128,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RetransformClasses\/retransform002\/retransform002.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -96,1 +96,1 @@\n-    if (name == NULL || strncmp(TRIGGER, name,strlen(name) < strlen(TRIGGER) ? strlen(name) : strlen(TRIGGER)))\n+    if (name == nullptr || strncmp(TRIGGER, name,strlen(name) < strlen(TRIGGER) ? strlen(name) : strlen(TRIGGER)))\n@@ -102,1 +102,1 @@\n-    if (!NSK_VERIFY((loader_class = jni->GetObjectClass(loader)) != NULL))\n+    if (!NSK_VERIFY((loader_class = jni->GetObjectClass(loader)) != nullptr))\n@@ -106,1 +106,1 @@\n-            loader_class, \"loadClass\", \"(Ljava\/lang\/String;)Ljava\/lang\/Class;\")) != NULL))\n+            loader_class, \"loadClass\", \"(Ljava\/lang\/String;)Ljava\/lang\/Class;\")) != nullptr))\n@@ -109,1 +109,1 @@\n-    if (!NSK_VERIFY((class_name_string = jni->NewStringUTF(CALLBACK_CLASS_NAME)) != NULL))\n+    if (!NSK_VERIFY((class_name_string = jni->NewStringUTF(CALLBACK_CLASS_NAME)) != nullptr))\n@@ -113,1 +113,1 @@\n-            loader, method_id, class_name_string)) != NULL))\n+            loader, method_id, class_name_string)) != nullptr))\n@@ -117,1 +117,1 @@\n-            callback_class, \"callback\", \"(Ljava\/lang\/String;I)V\")) != NULL))\n+            callback_class, \"callback\", \"(Ljava\/lang\/String;I)V\")) != nullptr))\n@@ -120,1 +120,1 @@\n-    if (!NSK_VERIFY((class_name_string = jni->NewStringUTF(name)) != NULL))\n+    if (!NSK_VERIFY((class_name_string = jni->NewStringUTF(name)) != nullptr))\n@@ -154,1 +154,1 @@\n-    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != NULL))\n+    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != nullptr))\n@@ -182,1 +182,1 @@\n-                                                NULL)))\n+                                                nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RetransformClasses\/retransform003\/retransform003.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -109,1 +109,1 @@\n-                (jvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != NULL\n+                (jvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != nullptr\n@@ -134,1 +134,1 @@\n-                                                NULL)))\n+                                                nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RetransformClasses\/retransform004\/retransform004.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -95,1 +95,1 @@\n-    err = jvmti->RunAgentThread(jthr(jni), sys_thread_4, NULL,\n+    err = jvmti->RunAgentThread(jthr(jni), sys_thread_4, nullptr,\n@@ -181,1 +181,1 @@\n-            JVMTI_EVENT_THREAD_START, NULL);\n+            JVMTI_EVENT_THREAD_START, nullptr);\n@@ -209,1 +209,1 @@\n-            sys_thread_1, NULL, JVMTI_THREAD_MAX_PRIORITY);\n+            sys_thread_1, nullptr, JVMTI_THREAD_MAX_PRIORITY);\n@@ -216,1 +216,1 @@\n-            sys_thread_2, NULL, JVMTI_THREAD_NORM_PRIORITY);\n+            sys_thread_2, nullptr, JVMTI_THREAD_NORM_PRIORITY);\n@@ -223,1 +223,1 @@\n-            sys_thread_3, NULL, JVMTI_THREAD_MIN_PRIORITY);\n+            sys_thread_3, nullptr, JVMTI_THREAD_MIN_PRIORITY);\n@@ -247,1 +247,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -252,1 +252,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -274,1 +274,1 @@\n-            JVMTI_EVENT_VM_INIT, NULL);\n+            JVMTI_EVENT_VM_INIT, nullptr);\n@@ -288,1 +288,1 @@\n-    err = jvmti->RunAgentThread(jthr(env), sys_thread_5, NULL,\n+    err = jvmti->RunAgentThread(jthr(env), sys_thread_5, nullptr,\n@@ -311,1 +311,1 @@\n-            JVMTI_EVENT_THREAD_START, NULL);\n+            JVMTI_EVENT_THREAD_START, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RunAgentThread\/agentthr001\/agentthr001.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -55,1 +55,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -60,1 +60,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -97,1 +97,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -112,1 +112,1 @@\n-    err = jvmti->RunAgentThread(thr, debug_thread, NULL,\n+    err = jvmti->RunAgentThread(thr, debug_thread, nullptr,\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RunAgentThread\/agentthr002\/agentthr002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -78,1 +78,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -86,1 +86,1 @@\n-    err = jvmti->RunAgentThread(NULL, agent_thread, NULL,\n+    err = jvmti->RunAgentThread(nullptr, agent_thread, nullptr,\n@@ -97,1 +97,1 @@\n-    err = jvmti->RunAgentThread(thr, NULL, NULL,\n+    err = jvmti->RunAgentThread(thr, nullptr, nullptr,\n@@ -108,1 +108,1 @@\n-    err = jvmti->RunAgentThread(thr, agent_thread, NULL,\n+    err = jvmti->RunAgentThread(thr, agent_thread, nullptr,\n@@ -119,1 +119,1 @@\n-    err = jvmti->RunAgentThread(thr, agent_thread, NULL,\n+    err = jvmti->RunAgentThread(thr, agent_thread, nullptr,\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RunAgentThread\/agentthr003\/agentthr003.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -100,1 +100,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -110,1 +110,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetBreakpoint\/setbrk002\/setbrk002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -99,1 +99,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -109,1 +109,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetBreakpoint\/setbrk003\/setbrk003.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -99,1 +99,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -109,1 +109,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetBreakpoint\/setbrk005\/setbrk005.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -99,1 +99,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -117,1 +117,1 @@\n-    err = jvmti->SetBreakpoint(NULL, 0);\n+    err = jvmti->SetBreakpoint(nullptr, 0);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetBreakpoint\/setbrk007\/setbrk007.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -85,1 +85,1 @@\n-    if (name == NULL || strcmp(cls_sig, exp_csig) != 0) {\n+    if (name == nullptr || strcmp(cls_sig, exp_csig) != 0) {\n@@ -90,1 +90,1 @@\n-    if (name == NULL || strcmp(name, exp_name) != 0) {\n+    if (name == nullptr || strcmp(name, exp_name) != 0) {\n@@ -95,1 +95,1 @@\n-    if (sig == NULL || strcmp(sig, exp_sig) != 0) {\n+    if (sig == nullptr || strcmp(sig, exp_sig) != 0) {\n@@ -122,1 +122,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -127,1 +127,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -174,1 +174,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -185,1 +185,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -204,1 +204,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetBreakpoint\/setbrk008\/setbrk008.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-    StorageStructure* storage = NULL;\n+    StorageStructure* storage = nullptr;\n@@ -173,1 +173,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -200,1 +200,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -208,1 +208,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -223,1 +223,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -240,1 +240,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetEnvironmentLocalStorage\/setenvstor001\/setenvstor001.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-    StorageStructure* storage = NULL;\n+    StorageStructure* storage = nullptr;\n@@ -178,1 +178,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -205,1 +205,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -213,1 +213,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -228,1 +228,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -235,1 +235,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetEnvironmentLocalStorage\/setenvstor002\/setenvstor002.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-    StorageStructure* storage = NULL;\n+    StorageStructure* storage = nullptr;\n@@ -181,1 +181,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -208,1 +208,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -216,1 +216,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -231,1 +231,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -238,1 +238,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetEnvironmentLocalStorage\/setenvstor003\/setenvstor003.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-    nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL);\n+    nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr);\n@@ -149,1 +149,1 @@\n-            nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT - 1, eventsList + 1, NULL);\n+            nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT - 1, eventsList + 1, nullptr);\n@@ -169,1 +169,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -177,1 +177,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -180,1 +180,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -194,1 +194,1 @@\n-            nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, eventsList, NULL);\n+            nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, eventsList, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetEventCallbacks\/setevntcallb001\/setevntcallb001.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-            NSK_COMPLAIN2(\"# %s event callback was invoked after SetEventCallbacks(NULL):\\n\"\n+            NSK_COMPLAIN2(\"# %s event callback was invoked after SetEventCallbacks(null):\\n\"\n@@ -111,1 +111,1 @@\n-    nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL);\n+    nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr);\n@@ -146,1 +146,1 @@\n-    NSK_DISPLAY0(\">>> Testcase #2: Set NULL for events callbacks\\n\");\n+    NSK_DISPLAY0(\">>> Testcase #2: Set null for events callbacks\\n\");\n@@ -148,1 +148,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(NULL, 0))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(nullptr, 0))) {\n@@ -152,1 +152,1 @@\n-        nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT - 1, eventsList + 1, NULL);\n+        nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT - 1, eventsList + 1, nullptr);\n@@ -171,1 +171,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -179,1 +179,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -182,1 +182,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -198,1 +198,1 @@\n-            nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, eventsList, NULL);\n+            nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, eventsList, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetEventCallbacks\/setevntcallb002\/setevntcallb002.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-    nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL);\n+    nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr);\n@@ -158,1 +158,1 @@\n-        nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT - 1, eventsList + 1, NULL);\n+        nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT - 1, eventsList + 1, nullptr);\n@@ -177,1 +177,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -185,1 +185,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -188,1 +188,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -202,1 +202,1 @@\n-            nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, eventsList, NULL);\n+            nsk_jvmti_enableEvents(JVMTI_ENABLE, 1, eventsList, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetEventCallbacks\/setevntcallb003\/setevntcallb003.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -41,1 +41,1 @@\n-static jobject notifyFramePopThread = NULL;\n+static jobject notifyFramePopThread = nullptr;\n@@ -81,1 +81,1 @@\n-        JVMTI_DISABLE, kind, NULL);\n+        JVMTI_DISABLE, kind, nullptr);\n@@ -102,1 +102,1 @@\n-        JVMTI_ENABLE, kind, NULL);\n+        JVMTI_ENABLE, kind, nullptr);\n@@ -124,2 +124,2 @@\n-    if (mid == NULL) {\n-      printf(\"(GetStaticMethodID) returns NULL\");\n+    if (mid == nullptr) {\n+      printf(\"(GetStaticMethodID) returns null\");\n@@ -312,1 +312,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -320,1 +320,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetEventNotificationMode\/setnotif001\/setnotif001.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    jvmtiExtensionEventInfo* extList = NULL;\n+    jvmtiExtensionEventInfo* extList = nullptr;\n@@ -61,1 +61,1 @@\n-        if (!NSK_VERIFY(extList != NULL))\n+        if (!NSK_VERIFY(extList != nullptr))\n@@ -79,1 +79,1 @@\n-            NSK_DISPLAY1(\"    ... clearing callback: 0x%p\\n\", (void*)NULL);\n+            NSK_DISPLAY1(\"    ... clearing callback: 0x%p\\n\", nullptr);\n@@ -81,1 +81,1 @@\n-                    jvmti->SetExtensionEventCallback(extList[i].extension_event_index, NULL))) {\n+                    jvmti->SetExtensionEventCallback(extList[i].extension_event_index, nullptr))) {\n@@ -133,1 +133,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -141,1 +141,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -151,1 +151,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetExtensionEventCallback\/setextevent001\/setextevent001.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-    { \"nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\", \"fld0\", \"I\", 0, NULL, NULL },\n-    { \"nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\", \"fld1\", \"I\", 1, NULL, NULL },\n+    { \"nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\", \"fld0\", \"I\", 0, nullptr, nullptr },\n+    { \"nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\", \"fld1\", \"I\", 1, nullptr, nullptr },\n@@ -54,3 +54,3 @@\n-      \"Lnsk\/jvmti\/SetFieldAccessWatch\/setfldw001a;\", 0, NULL, NULL },\n-    { \"nsk\/jvmti\/SetFieldAccessWatch\/setfldw001a\", \"fld3\", \"[I\", 0, NULL, NULL },\n-    { \"nsk\/jvmti\/SetFieldAccessWatch\/setfldw001b\", \"fld4\", \"F\", 0, NULL, NULL },\n+      \"Lnsk\/jvmti\/SetFieldAccessWatch\/setfldw001a;\", 0, nullptr, nullptr },\n+    { \"nsk\/jvmti\/SetFieldAccessWatch\/setfldw001a\", \"fld3\", \"[I\", 0, nullptr, nullptr },\n+    { \"nsk\/jvmti\/SetFieldAccessWatch\/setfldw001b\", \"fld4\", \"F\", 0, nullptr, nullptr },\n@@ -65,1 +65,1 @@\n-    if (cls == NULL) {\n+    if (cls == nullptr) {\n@@ -70,1 +70,1 @@\n-    if (fld.fid == NULL) {\n+    if (fld.fid == nullptr) {\n@@ -93,1 +93,1 @@\n-    char *fld_name = NULL;\n+    char *fld_name = nullptr;\n@@ -97,1 +97,1 @@\n-                                                &fld_name, NULL, NULL);\n+                                                &fld_name, nullptr, nullptr);\n@@ -103,2 +103,2 @@\n-    if (fld_name == NULL) {\n-        printf(\"GetFieldName returned NULL field name\\n\");\n+    if (fld_name == nullptr) {\n+        printf(\"GetFieldName returned null field name\\n\");\n@@ -136,1 +136,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -172,1 +172,1 @@\n-                JVMTI_EVENT_FIELD_ACCESS, NULL);\n+                JVMTI_EVENT_FIELD_ACCESS, nullptr);\n@@ -206,1 +206,1 @@\n-        if (flag == JNI_FALSE && thrown_fid != NULL) {\n+        if (flag == JNI_FALSE && thrown_fid != nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\/setfldw001.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -98,1 +98,1 @@\n-                JVMTI_EVENT_FIELD_ACCESS, NULL);\n+                JVMTI_EVENT_FIELD_ACCESS, nullptr);\n@@ -126,1 +126,1 @@\n-        err = jvmti->SetFieldAccessWatch(NULL, fid);\n+        err = jvmti->SetFieldAccessWatch(nullptr, fid);\n@@ -133,1 +133,1 @@\n-        err = jvmti->SetFieldAccessWatch(cls, NULL);\n+        err = jvmti->SetFieldAccessWatch(cls, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw002\/setfldw002.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n-static jfieldID actual_fid = NULL;\n-static jfieldID fids[4] = { NULL, NULL, NULL, NULL };\n+static jfieldID actual_fid = nullptr;\n+static jfieldID fids[4] = { nullptr, nullptr, nullptr, nullptr };\n@@ -69,1 +69,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -74,1 +74,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -129,1 +129,1 @@\n-        if (fids[i] == NULL) {\n+        if (fids[i] == nullptr) {\n@@ -145,1 +145,1 @@\n-        JVMTI_EVENT_FIELD_ACCESS, NULL);\n+        JVMTI_EVENT_FIELD_ACCESS, nullptr);\n@@ -164,1 +164,1 @@\n-    actual_fid = NULL;\n+    actual_fid = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw003\/setfldw003.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n-static jfieldID actual_fid = NULL;\n-static jfieldID fids[4] = { NULL, NULL, NULL, NULL };\n+static jfieldID actual_fid = nullptr;\n+static jfieldID fids[4] = { nullptr, nullptr, nullptr, nullptr };\n@@ -69,1 +69,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -74,1 +74,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -136,1 +136,1 @@\n-        if (fids[i] == NULL) {\n+        if (fids[i] == nullptr) {\n@@ -152,1 +152,1 @@\n-        JVMTI_EVENT_FIELD_ACCESS, NULL);\n+        JVMTI_EVENT_FIELD_ACCESS, nullptr);\n@@ -171,1 +171,1 @@\n-    actual_fid = NULL;\n+    actual_fid = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw004\/setfldw004.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-static jfieldID actual_fid = NULL;\n+static jfieldID actual_fid = nullptr;\n@@ -52,16 +52,16 @@\n-    { \"fld0\", \"J\", JNI_TRUE, NULL, \"static long\" },\n-    { \"fld1\", \"J\", JNI_FALSE, NULL, \"long\" },\n-    { \"fld2\", \"F\", JNI_TRUE, NULL, \"static float\" },\n-    { \"fld3\", \"F\", JNI_FALSE, NULL, \"float\" },\n-    { \"fld4\", \"D\", JNI_TRUE, NULL, \"static double\" },\n-    { \"fld5\", \"D\", JNI_FALSE, NULL, \"double\" },\n-    { \"fld6\", \"Ljava\/lang\/Object;\", JNI_TRUE, NULL, \"static Object\" },\n-    { \"fld7\", \"Ljava\/lang\/Object;\", JNI_FALSE, NULL, \"Object\" },\n-    { \"fld8\", \"Z\", JNI_TRUE, NULL, \"static boolean\" },\n-    { \"fld9\", \"Z\", JNI_FALSE, NULL, \"boolean\" },\n-    { \"fld10\", \"B\", JNI_TRUE, NULL, \"static byte\" },\n-    { \"fld11\", \"B\", JNI_FALSE, NULL, \"byte\" },\n-    { \"fld12\", \"S\", JNI_TRUE, NULL, \"static short\" },\n-    { \"fld13\", \"S\", JNI_FALSE, NULL, \"short\" },\n-    { \"fld14\", \"C\", JNI_TRUE, NULL, \"static char\" },\n-    { \"fld15\", \"C\", JNI_FALSE, NULL, \"char\" }\n+    { \"fld0\", \"J\", JNI_TRUE, nullptr, \"static long\" },\n+    { \"fld1\", \"J\", JNI_FALSE, nullptr, \"long\" },\n+    { \"fld2\", \"F\", JNI_TRUE, nullptr, \"static float\" },\n+    { \"fld3\", \"F\", JNI_FALSE, nullptr, \"float\" },\n+    { \"fld4\", \"D\", JNI_TRUE, nullptr, \"static double\" },\n+    { \"fld5\", \"D\", JNI_FALSE, nullptr, \"double\" },\n+    { \"fld6\", \"Ljava\/lang\/Object;\", JNI_TRUE, nullptr, \"static Object\" },\n+    { \"fld7\", \"Ljava\/lang\/Object;\", JNI_FALSE, nullptr, \"Object\" },\n+    { \"fld8\", \"Z\", JNI_TRUE, nullptr, \"static boolean\" },\n+    { \"fld9\", \"Z\", JNI_FALSE, nullptr, \"boolean\" },\n+    { \"fld10\", \"B\", JNI_TRUE, nullptr, \"static byte\" },\n+    { \"fld11\", \"B\", JNI_FALSE, nullptr, \"byte\" },\n+    { \"fld12\", \"S\", JNI_TRUE, nullptr, \"static short\" },\n+    { \"fld13\", \"S\", JNI_FALSE, nullptr, \"short\" },\n+    { \"fld14\", \"C\", JNI_TRUE, nullptr, \"static char\" },\n+    { \"fld15\", \"C\", JNI_FALSE, nullptr, \"char\" }\n@@ -94,1 +94,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -99,1 +99,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -162,1 +162,1 @@\n-        if (fields[i].fid == NULL) {\n+        if (fields[i].fid == nullptr) {\n@@ -179,1 +179,1 @@\n-        JVMTI_EVENT_FIELD_ACCESS, NULL);\n+        JVMTI_EVENT_FIELD_ACCESS, nullptr);\n@@ -198,1 +198,1 @@\n-    actual_fid = NULL;\n+    actual_fid = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw005\/setfldw005.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -53,21 +53,21 @@\n-    { NULL, \"staticBoolean\", \"Z\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticByte\", \"B\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticShort\", \"S\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticInt\", \"I\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticLong\", \"J\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticFloat\", \"F\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticDouble\", \"D\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticChar\", \"C\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticArrInt\", \"[I\", JNI_TRUE, 0, 0 },\n-\n-    { NULL, \"instanceBoolean\", \"Z\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceByte\", \"B\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceShort\", \"S\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceInt\", \"I\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceLong\", \"J\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceFloat\", \"F\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceDouble\", \"D\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceChar\", \"C\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceArrInt\", \"[I\", JNI_FALSE, 0, 0 }\n+    { nullptr, \"staticBoolean\", \"Z\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticByte\", \"B\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticShort\", \"S\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticInt\", \"I\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticLong\", \"J\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticFloat\", \"F\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticDouble\", \"D\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticChar\", \"C\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticArrInt\", \"[I\", JNI_TRUE, 0, 0 },\n+\n+    { nullptr, \"instanceBoolean\", \"Z\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceByte\", \"B\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceShort\", \"S\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceInt\", \"I\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceLong\", \"J\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceFloat\", \"F\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceDouble\", \"D\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceChar\", \"C\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceArrInt\", \"[I\", JNI_FALSE, 0, 0 }\n@@ -106,1 +106,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -111,1 +111,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -165,1 +165,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -194,1 +194,1 @@\n-        JVMTI_EVENT_FIELD_ACCESS, NULL);\n+        JVMTI_EVENT_FIELD_ACCESS, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw006\/setfldw006.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-    { \"nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\", \"fld0\", \"I\", 0, NULL, NULL },\n-    { \"nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\", \"fld1\", \"I\", 1, NULL, NULL },\n+    { \"nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\", \"fld0\", \"I\", 0, nullptr, nullptr },\n+    { \"nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\", \"fld1\", \"I\", 1, nullptr, nullptr },\n@@ -54,3 +54,3 @@\n-      \"Lnsk\/jvmti\/SetFieldModificationWatch\/setfmodw001a;\", 0, NULL, NULL },\n-    { \"nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001a\", \"fld3\", \"[I\", 0, NULL, NULL },\n-    { \"nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001b\", \"fld4\", \"F\", 0, NULL, NULL },\n+      \"Lnsk\/jvmti\/SetFieldModificationWatch\/setfmodw001a;\", 0, nullptr, nullptr },\n+    { \"nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001a\", \"fld3\", \"[I\", 0, nullptr, nullptr },\n+    { \"nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001b\", \"fld4\", \"F\", 0, nullptr, nullptr },\n@@ -64,1 +64,1 @@\n-    if (fields[ind].fid == NULL) {\n+    if (fields[ind].fid == nullptr) {\n@@ -87,1 +87,1 @@\n-    char *fld_name = NULL;\n+    char *fld_name = nullptr;\n@@ -91,1 +91,1 @@\n-                                                &fld_name, NULL, NULL);\n+                                                &fld_name, nullptr, nullptr);\n@@ -97,2 +97,2 @@\n-    if (fld_name == NULL) {\n-        printf(\"GetFieldName returned NULL field name\\n\");\n+    if (fld_name == nullptr) {\n+        printf(\"GetFieldName returned null field name\\n\");\n@@ -130,1 +130,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -166,1 +166,1 @@\n-                JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n+                JVMTI_EVENT_FIELD_MODIFICATION, nullptr);\n@@ -198,1 +198,1 @@\n-        if (flag == JNI_FALSE && thrown_fid != NULL) {\n+        if (flag == JNI_FALSE && thrown_fid != nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/setfmodw001.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -98,1 +98,1 @@\n-                JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n+                JVMTI_EVENT_FIELD_MODIFICATION, nullptr);\n@@ -118,2 +118,2 @@\n-    if (fid == NULL) {\n-      printf(\"(GetStaticFieldID) returns NULL\");\n+    if (fid == nullptr) {\n+      printf(\"(GetStaticFieldID) returns null\");\n@@ -132,1 +132,1 @@\n-        err = jvmti->SetFieldModificationWatch(NULL, fid);\n+        err = jvmti->SetFieldModificationWatch(nullptr, fid);\n@@ -139,1 +139,1 @@\n-        err = jvmti->SetFieldModificationWatch(cls, NULL);\n+        err = jvmti->SetFieldModificationWatch(cls, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw002\/setfmodw002.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-static jfieldID actual_fid = NULL;\n+static jfieldID actual_fid = nullptr;\n@@ -54,4 +54,4 @@\n-    { \"fld0\", 'I', JNI_TRUE, 42, NULL },\n-    { \"fld1\", 'I', JNI_TRUE, 43, NULL },\n-    { \"fld2\", 'I', JNI_FALSE, 44, NULL },\n-    { \"fld3\", 'I', JNI_FALSE, 45, NULL }\n+    { \"fld0\", 'I', JNI_TRUE, 42, nullptr },\n+    { \"fld1\", 'I', JNI_TRUE, 43, nullptr },\n+    { \"fld2\", 'I', JNI_FALSE, 44, nullptr },\n+    { \"fld3\", 'I', JNI_FALSE, 45, nullptr }\n@@ -87,1 +87,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -92,1 +92,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -149,1 +149,1 @@\n-        if (flds[i].fid == NULL) {\n+        if (flds[i].fid == nullptr) {\n@@ -165,1 +165,1 @@\n-        JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n+        JVMTI_EVENT_FIELD_MODIFICATION, nullptr);\n@@ -198,1 +198,1 @@\n-    actual_fid = NULL;\n+    actual_fid = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw003\/setfmodw003.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-static jfieldID actual_fid = NULL;\n+static jfieldID actual_fid = nullptr;\n@@ -54,4 +54,4 @@\n-    { \"fld0\", 'I', JNI_TRUE, 96, NULL },\n-    { \"fld1\", 'I', JNI_TRUE, 97, NULL },\n-    { \"fld2\", 'I', JNI_FALSE, 98, NULL },\n-    { \"fld3\", 'I', JNI_FALSE, 99, NULL }\n+    { \"fld0\", 'I', JNI_TRUE, 96, nullptr },\n+    { \"fld1\", 'I', JNI_TRUE, 97, nullptr },\n+    { \"fld2\", 'I', JNI_FALSE, 98, nullptr },\n+    { \"fld3\", 'I', JNI_FALSE, 99, nullptr }\n@@ -87,1 +87,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -92,1 +92,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -147,1 +147,1 @@\n-        if (flds[i].fid == NULL) {\n+        if (flds[i].fid == nullptr) {\n@@ -163,1 +163,1 @@\n-        JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n+        JVMTI_EVENT_FIELD_MODIFICATION, nullptr);\n@@ -196,1 +196,1 @@\n-    actual_fid = NULL;\n+    actual_fid = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw004\/setfmodw004.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-static jfieldID actual_fid = NULL;\n+static jfieldID actual_fid = nullptr;\n@@ -55,16 +55,16 @@\n-    { \"fld0\", \"J\", JNI_TRUE, \"static long\", NULL, {} },\n-    { \"fld1\", \"J\", JNI_FALSE, \"long\", NULL, {} },\n-    { \"fld2\", \"F\", JNI_TRUE, \"static float\", NULL, {} },\n-    { \"fld3\", \"F\", JNI_FALSE, \"float\", NULL, {} },\n-    { \"fld4\", \"D\", JNI_TRUE, \"static double\", NULL, {} },\n-    { \"fld5\", \"D\", JNI_FALSE, \"double\", NULL, {} },\n-    { \"fld6\", \"Ljava\/lang\/Object;\", JNI_TRUE, \"static Object\", NULL, {} },\n-    { \"fld7\", \"Ljava\/lang\/Object;\", JNI_FALSE, \"Object\", NULL, {} },\n-    { \"fld8\", \"Z\", JNI_TRUE, \"static boolean\", NULL, {} },\n-    { \"fld9\", \"Z\", JNI_FALSE, \"boolean\", NULL, {} },\n-    { \"fld10\", \"B\", JNI_TRUE, \"static byte\", NULL, {} },\n-    { \"fld11\", \"B\", JNI_FALSE, \"byte\", NULL, {} },\n-    { \"fld12\", \"S\", JNI_TRUE, \"static short\", NULL, {} },\n-    { \"fld13\", \"S\", JNI_FALSE, \"short\", NULL, {} },\n-    { \"fld14\", \"C\", JNI_TRUE, \"static char\", NULL, {} },\n-    { \"fld15\", \"C\", JNI_FALSE, \"char\", NULL, {} }\n+    { \"fld0\", \"J\", JNI_TRUE, \"static long\", nullptr, {} },\n+    { \"fld1\", \"J\", JNI_FALSE, \"long\", nullptr, {} },\n+    { \"fld2\", \"F\", JNI_TRUE, \"static float\", nullptr, {} },\n+    { \"fld3\", \"F\", JNI_FALSE, \"float\", nullptr, {} },\n+    { \"fld4\", \"D\", JNI_TRUE, \"static double\", nullptr, {} },\n+    { \"fld5\", \"D\", JNI_FALSE, \"double\", nullptr, {} },\n+    { \"fld6\", \"Ljava\/lang\/Object;\", JNI_TRUE, \"static Object\", nullptr, {} },\n+    { \"fld7\", \"Ljava\/lang\/Object;\", JNI_FALSE, \"Object\", nullptr, {} },\n+    { \"fld8\", \"Z\", JNI_TRUE, \"static boolean\", nullptr, {} },\n+    { \"fld9\", \"Z\", JNI_FALSE, \"boolean\", nullptr, {} },\n+    { \"fld10\", \"B\", JNI_TRUE, \"static byte\", nullptr, {} },\n+    { \"fld11\", \"B\", JNI_FALSE, \"byte\", nullptr, {} },\n+    { \"fld12\", \"S\", JNI_TRUE, \"static short\", nullptr, {} },\n+    { \"fld13\", \"S\", JNI_FALSE, \"short\", nullptr, {} },\n+    { \"fld14\", \"C\", JNI_TRUE, \"static char\", nullptr, {} },\n+    { \"fld15\", \"C\", JNI_FALSE, \"char\", nullptr, {} }\n@@ -136,1 +136,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -141,1 +141,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -219,1 +219,1 @@\n-        if (flds[i].fid == NULL) {\n+        if (flds[i].fid == nullptr) {\n@@ -236,1 +236,1 @@\n-        JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n+        JVMTI_EVENT_FIELD_MODIFICATION, nullptr);\n@@ -369,1 +369,1 @@\n-    actual_fid = NULL;\n+    actual_fid = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw005\/setfmodw005.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -53,21 +53,21 @@\n-    { NULL, \"staticBoolean\", \"Z\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticByte\", \"B\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticShort\", \"S\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticInt\", \"I\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticLong\", \"J\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticFloat\", \"F\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticDouble\", \"D\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticChar\", \"C\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE, 0, 0 },\n-    { NULL, \"staticArrInt\", \"[I\", JNI_TRUE, 0, 0 },\n-\n-    { NULL, \"instanceBoolean\", \"Z\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceByte\", \"B\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceShort\", \"S\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceInt\", \"I\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceLong\", \"J\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceFloat\", \"F\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceDouble\", \"D\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceChar\", \"C\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE, 0, 0 },\n-    { NULL, \"instanceArrInt\", \"[I\", JNI_FALSE, 0, 0 }\n+    { nullptr, \"staticBoolean\", \"Z\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticByte\", \"B\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticShort\", \"S\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticInt\", \"I\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticLong\", \"J\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticFloat\", \"F\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticDouble\", \"D\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticChar\", \"C\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE, 0, 0 },\n+    { nullptr, \"staticArrInt\", \"[I\", JNI_TRUE, 0, 0 },\n+\n+    { nullptr, \"instanceBoolean\", \"Z\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceByte\", \"B\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceShort\", \"S\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceInt\", \"I\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceLong\", \"J\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceFloat\", \"F\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceDouble\", \"D\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceChar\", \"C\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE, 0, 0 },\n+    { nullptr, \"instanceArrInt\", \"[I\", JNI_FALSE, 0, 0 }\n@@ -106,1 +106,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -111,1 +111,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -158,1 +158,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -188,1 +188,1 @@\n-        JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n+        JVMTI_EVENT_FIELD_MODIFICATION, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw006\/setfmodw006.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -62,1 +62,1 @@\n-static jniNativeInterface *orig_jni_functions = NULL;\n+static jniNativeInterface *orig_jni_functions = nullptr;\n@@ -65,1 +65,1 @@\n-static jniNativeInterface *redir_jni_functions = NULL;\n+static jniNativeInterface *redir_jni_functions = nullptr;\n@@ -281,1 +281,1 @@\n-        if (THREAD_start(waitThr[i]) == NULL) {\n+        if (THREAD_start(waitThr[i]) == nullptr) {\n@@ -326,1 +326,1 @@\n-    JNIEnv *nextEnv = NULL; \/* JNI env used to verify the assertion *\/\n+    JNIEnv *nextEnv = nullptr; \/* JNI env used to verify the assertion *\/\n@@ -328,1 +328,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -335,1 +335,1 @@\n-    if (clsObj == NULL) {\n+    if (clsObj == nullptr) {\n@@ -385,1 +385,1 @@\n-    doRestore((nextEnv == NULL) ? env : nextEnv);\n+    doRestore((nextEnv == nullptr) ? env : nextEnv);\n@@ -388,1 +388,1 @@\n-    doExec((nextEnv == NULL) ? env : nextEnv, 0);\n+    doExec((nextEnv == nullptr) ? env : nextEnv, 0);\n@@ -416,1 +416,1 @@\n-    if (options != NULL && strcmp(options, \"-verbose\") == 0)\n+    if (options != nullptr && strcmp(options, \"-verbose\") == 0)\n@@ -423,1 +423,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetJNIFunctionTable\/setjniftab001\/setjniftab001.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -48,1 +48,1 @@\n-    err = jvmti->SetJNIFunctionTable(NULL);\n+    err = jvmti->SetJNIFunctionTable(nullptr);\n@@ -63,1 +63,1 @@\n-    JNIEnv *nextEnv = NULL;\n+    JNIEnv *nextEnv = nullptr;\n@@ -65,1 +65,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -117,1 +117,1 @@\n-    if (options != NULL && strcmp(options, \"-verbose\") == 0)\n+    if (options != nullptr && strcmp(options, \"-verbose\") == 0)\n@@ -124,1 +124,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetJNIFunctionTable\/setjniftab002\/setjniftab002.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -53,1 +53,1 @@\n-    jvmtiLocalVariableEntry *table = NULL;\n+    jvmtiLocalVariableEntry *table = nullptr;\n@@ -237,1 +237,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -262,1 +262,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -311,1 +311,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -341,1 +341,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetLocalVariable\/setlocal001\/setlocal001.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -102,1 +102,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -112,1 +112,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetLocalVariable\/setlocal002\/setlocal002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -142,1 +142,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -147,1 +147,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -195,1 +195,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -205,1 +205,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -219,1 +219,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetLocalVariable\/setlocal003\/setlocal003.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -148,1 +148,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -153,1 +153,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -201,1 +201,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -225,1 +225,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetLocalVariable\/setlocal004\/setlocal004.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -123,1 +123,1 @@\n-    char *str = NULL;\n+    char *str = nullptr;\n@@ -125,2 +125,2 @@\n-    if (prefix != NULL) {\n-        if (!NSK_VERIFY((str = (char *) jni->GetStringUTFChars(prefix, 0)) != NULL))\n+    if (prefix != nullptr) {\n+        if (!NSK_VERIFY((str = (char *) jni->GetStringUTFChars(prefix, 0)) != nullptr))\n@@ -133,1 +133,1 @@\n-    if (str != NULL) {\n+    if (str != nullptr) {\n@@ -142,1 +142,1 @@\n-    if (str != NULL) {\n+    if (str != nullptr) {\n@@ -159,1 +159,1 @@\n-    char *str = NULL;\n+    char *str = nullptr;\n@@ -161,2 +161,2 @@\n-    if (prefix != NULL) {\n-        if (!NSK_VERIFY((str = (char *) jni->GetStringUTFChars(prefix, 0)) != NULL))\n+    if (prefix != nullptr) {\n+        if (!NSK_VERIFY((str = (char *) jni->GetStringUTFChars(prefix, 0)) != nullptr))\n@@ -173,1 +173,1 @@\n-        prefixes[0] = NULL;\n+        prefixes[0] = nullptr;\n@@ -182,1 +182,1 @@\n-    if (str != NULL) {\n+    if (str != nullptr) {\n@@ -212,1 +212,1 @@\n-    if (!NSK_VERIFY((method.name = (char *) jni->GetStringUTFChars(method_name_obj, 0)) != NULL)) {\n+    if (!NSK_VERIFY((method.name = (char *) jni->GetStringUTFChars(method_name_obj, 0)) != nullptr)) {\n@@ -216,1 +216,1 @@\n-    if (!NSK_VERIFY((method.signature = (char *) jni->GetStringUTFChars(method_sig_obj, 0)) != NULL)) {\n+    if (!NSK_VERIFY((method.signature = (char *) jni->GetStringUTFChars(method_sig_obj, 0)) != nullptr)) {\n@@ -229,1 +229,1 @@\n-        if (jni->ExceptionOccurred() != NULL) {\n+        if (jni->ExceptionOccurred() != nullptr) {\n@@ -240,1 +240,1 @@\n-    if (method.name != NULL) {\n+    if (method.name != nullptr) {\n@@ -244,1 +244,1 @@\n-    if (method.signature != NULL) {\n+    if (method.signature != nullptr) {\n@@ -276,1 +276,1 @@\n-                (jvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != NULL\n+                (jvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != nullptr\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetNativeMethodPrefix\/SetNativeMethodPrefix001\/SetNativeMethodPrefix001.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static char *prefix = NULL;\n+static char *prefix = nullptr;\n@@ -45,1 +45,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -98,1 +98,1 @@\n-    if (prefix != NULL) {\n+    if (prefix != nullptr) {\n@@ -106,1 +106,1 @@\n-                (jvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != NULL\n+                (jvmti = nsk_jvmti_createJVMTIEnv(vm, reserved)) != nullptr\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetNativeMethodPrefix\/SetNativeMethodPrefix002\/SetNativeMethodPrefix002.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-    char* value = NULL;\n+    char* value = nullptr;\n@@ -84,1 +84,1 @@\n-    if (value == NULL\n+    if (value == nullptr\n@@ -177,1 +177,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -185,1 +185,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -193,1 +193,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetSystemProperty\/setsysprop002\/setsysprop002.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -90,1 +90,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetSystemProperty\/setsysprop003\/setsysprop003.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        jobject testedObject = NULL;\n+        jobject testedObject = nullptr;\n@@ -59,2 +59,2 @@\n-            jclass debugeeClass = NULL;\n-            jfieldID objectField = NULL;\n+            jclass debugeeClass = nullptr;\n+            jfieldID objectField = nullptr;\n@@ -64,1 +64,1 @@\n-                    jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+                    jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -72,1 +72,1 @@\n-                    jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, OBJECT_CLASS_SIG)) != NULL)) {\n+                    jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -80,1 +80,1 @@\n-                    jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+                    jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -87,1 +87,1 @@\n-            if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewGlobalRef(testedObject)) != NULL)) {\n+            if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewGlobalRef(testedObject)) != nullptr)) {\n@@ -183,1 +183,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -193,1 +193,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -208,1 +208,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetTag\/settag001\/settag001.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-        jthread testedThread = NULL;\n+        jthread testedThread = nullptr;\n@@ -64,1 +64,1 @@\n-        StorageStructure* obtainedStorage = NULL;\n+        StorageStructure* obtainedStorage = nullptr;\n@@ -70,1 +70,1 @@\n-                nsk_jvmti_threadByName(THREAD_NAME)) != NULL))\n+                nsk_jvmti_threadByName(THREAD_NAME)) != nullptr))\n@@ -151,1 +151,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -161,1 +161,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -165,1 +165,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetThreadLocalStorage\/setthrdstor001\/setthrdstor001.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-        StorageStructure* obtainedStorage = NULL;\n+        StorageStructure* obtainedStorage = nullptr;\n@@ -69,1 +69,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetThreadLocalStorage(NULL, (void*)initialStorage))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetThreadLocalStorage(nullptr, (void*)initialStorage))) {\n@@ -83,1 +83,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->GetThreadLocalStorage(NULL, (void**)&obtainedStorage))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->GetThreadLocalStorage(nullptr, (void**)&obtainedStorage))) {\n@@ -136,1 +136,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -146,1 +146,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -150,1 +150,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetThreadLocalStorage\/setthrdstor002\/setthrdstor002.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-        if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL))\n+        if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -93,1 +93,1 @@\n-        if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL))\n+        if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -120,1 +120,1 @@\n-    if (thread != NULL) {\n+    if (thread != nullptr) {\n@@ -128,1 +128,1 @@\n-        if (info.name != NULL && strcmp(info.name, THREAD_NAME) == 0) {\n+        if (info.name != nullptr && strcmp(info.name, THREAD_NAME) == 0) {\n@@ -135,1 +135,1 @@\n-            if (!NSK_JVMTI_VERIFY(jvmti->SetThreadLocalStorage(NULL, (void*)initialStorage))) {\n+            if (!NSK_JVMTI_VERIFY(jvmti->SetThreadLocalStorage(nullptr, (void*)initialStorage))) {\n@@ -148,1 +148,1 @@\n-    if (thread != NULL) {\n+    if (thread != nullptr) {\n@@ -156,1 +156,1 @@\n-        if (info.name != NULL && strcmp(info.name, THREAD_NAME) == 0) {\n+        if (info.name != nullptr && strcmp(info.name, THREAD_NAME) == 0) {\n@@ -163,1 +163,1 @@\n-                StorageStructure* obtainedStorage = NULL;\n+                StorageStructure* obtainedStorage = nullptr;\n@@ -167,1 +167,1 @@\n-                        jvmti->GetThreadLocalStorage(NULL, (void**)&obtainedStorage))) {\n+                        jvmti->GetThreadLocalStorage(nullptr, (void**)&obtainedStorage))) {\n@@ -222,1 +222,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -232,1 +232,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -246,1 +246,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetThreadLocalStorage\/setthrdstor003\/setthrdstor003.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,1 +160,1 @@\n-    jvmtiEnv *jvmti = NULL;\n+    jvmtiEnv *jvmti = nullptr;\n@@ -172,1 +172,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -197,1 +197,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr)))\n@@ -202,1 +202,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n@@ -206,1 +206,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetVerboseFlag\/setvrbflag001\/setvrbflag001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-    jvmtiEnv *jvmti = NULL;\n+    jvmtiEnv *jvmti = nullptr;\n@@ -86,1 +86,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -90,1 +90,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetVerboseFlag\/setvrbflag002\/setvrbflag002.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,1 +56,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -61,1 +61,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -99,1 +99,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -107,1 +107,1 @@\n-    err = jvmti->StopThread(NULL, ex);\n+    err = jvmti->StopThread(nullptr, ex);\n@@ -120,1 +120,1 @@\n-    err = jvmti->StopThread(thr, NULL);\n+    err = jvmti->StopThread(thr, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/StopThread\/stopthrd006\/stopthrd006.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,4 +41,4 @@\n-static jobject threadDeath = NULL;\n-static jthread runningThread = NULL;\n-static jthread waitingThread = NULL;\n-static jthread sleepingThread = NULL;\n+static jobject threadDeath = nullptr;\n+static jthread runningThread = nullptr;\n+static jthread waitingThread = nullptr;\n+static jthread sleepingThread = nullptr;\n@@ -56,1 +56,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -58,2 +58,2 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n@@ -68,1 +68,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -73,1 +73,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -83,1 +83,1 @@\n-        if (info.name != NULL) {\n+        if (info.name != nullptr) {\n@@ -99,1 +99,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -103,1 +103,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -106,1 +106,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (threadDeath = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (threadDeath = jni->NewObject(cls, ctor)) != nullptr))\n@@ -127,1 +127,1 @@\n-    if (!NSK_VERIFY(runningThread != NULL)) {\n+    if (!NSK_VERIFY(runningThread != nullptr)) {\n@@ -135,1 +135,1 @@\n-    if (!NSK_VERIFY(waitingThread != NULL)) {\n+    if (!NSK_VERIFY(waitingThread != nullptr)) {\n@@ -143,1 +143,1 @@\n-    if (!NSK_VERIFY(sleepingThread != NULL)) {\n+    if (!NSK_VERIFY(sleepingThread != nullptr)) {\n@@ -169,1 +169,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -180,1 +180,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -183,1 +183,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/StopThread\/stopthrd007\/stopthrd007.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-        jthread testedThread = NULL;\n+        jthread testedThread = nullptr;\n@@ -56,1 +56,1 @@\n-                nsk_jvmti_threadByName(THREAD_NAME)) != NULL))\n+                nsk_jvmti_threadByName(THREAD_NAME)) != nullptr))\n@@ -121,1 +121,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -131,1 +131,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -144,1 +144,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SuspendThread\/suspendthrd001\/suspendthrd001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-static jthread testedThread = NULL;\n+static jthread testedThread = nullptr;\n@@ -68,1 +68,1 @@\n-                nsk_jvmti_threadByName(THREAD_NAME)) != NULL))\n+                nsk_jvmti_threadByName(THREAD_NAME)) != nullptr))\n@@ -74,1 +74,1 @@\n-        if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL))\n+        if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -102,1 +102,1 @@\n-        if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL))\n+        if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -129,1 +129,1 @@\n-    if (thread != NULL &&\n+    if (thread != nullptr &&\n@@ -153,1 +153,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -163,1 +163,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -185,1 +185,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SuspendThread\/suspendthrd002\/suspendthrd002.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-        jthread testedThread = NULL;\n+        jthread testedThread = nullptr;\n@@ -59,1 +59,1 @@\n-                nsk_jvmti_threadByName(THREAD_NAME)) != NULL))\n+                nsk_jvmti_threadByName(THREAD_NAME)) != nullptr))\n@@ -153,1 +153,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -163,1 +163,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -176,1 +176,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SuspendThread\/suspendthrd003\/suspendthrd003.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,2 @@\n-        jthread* threads = NULL;\n-        jvmtiError* results = NULL;\n+        jthread* threads = nullptr;\n+        jvmtiError* results = nullptr;\n@@ -133,1 +133,1 @@\n-            if (threads[i] != NULL)\n+            if (threads[i] != nullptr)\n@@ -159,1 +159,1 @@\n-    jthread* threads = NULL;\n+    jthread* threads = nullptr;\n@@ -166,1 +166,1 @@\n-        foundThreads[i] = NULL;\n+        foundThreads[i] = nullptr;\n@@ -183,1 +183,1 @@\n-        if (info.name != NULL && strncmp(name, info.name, len) == 0) {\n+        if (info.name != nullptr && strncmp(name, info.name, len) == 0) {\n@@ -211,1 +211,1 @@\n-                    jni->NewGlobalRef(foundThreads[i])) != NULL)) {\n+                    jni->NewGlobalRef(foundThreads[i])) != nullptr)) {\n@@ -236,1 +236,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -251,1 +251,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -264,1 +264,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SuspendThreadList\/suspendthrdlst001\/suspendthrdlst001.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-static jthread* threads = NULL;\n+static jthread* threads = nullptr;\n@@ -72,1 +72,1 @@\n-        jvmtiError* results = NULL;\n+        jvmtiError* results = nullptr;\n@@ -111,1 +111,1 @@\n-        if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL))\n+        if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -134,1 +134,1 @@\n-        if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL))\n+        if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -149,1 +149,1 @@\n-            if (threads[i] != NULL)\n+            if (threads[i] != nullptr)\n@@ -175,1 +175,1 @@\n-    jthread* threads = NULL;\n+    jthread* threads = nullptr;\n@@ -182,1 +182,1 @@\n-        foundThreads[i] = NULL;\n+        foundThreads[i] = nullptr;\n@@ -199,1 +199,1 @@\n-        if (info.name != NULL && strncmp(name, info.name, len) == 0) {\n+        if (info.name != nullptr && strncmp(name, info.name, len) == 0) {\n@@ -227,1 +227,1 @@\n-                    jni->NewGlobalRef(foundThreads[i])) != NULL)) {\n+                    jni->NewGlobalRef(foundThreads[i])) != nullptr)) {\n@@ -246,1 +246,1 @@\n-        if (thread != NULL &&\n+        if (thread != nullptr &&\n@@ -272,1 +272,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -287,1 +287,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -309,1 +309,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SuspendThreadList\/suspendthrdlst002\/suspendthrdlst002.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -84,1 +84,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -94,1 +94,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/VMDeath\/vmdeath001\/vmdeath001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -55,1 +55,1 @@\n-            JVMTI_EVENT_THREAD_START, NULL);\n+            JVMTI_EVENT_THREAD_START, nullptr);\n@@ -110,1 +110,1 @@\n-    if (inf.name != NULL && strcmp(name, inf.name) == 0) {\n+    if (inf.name != nullptr && strcmp(name, inf.name) == 0) {\n@@ -135,1 +135,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -140,1 +140,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -155,1 +155,1 @@\n-            JVMTI_EVENT_VM_INIT, NULL);\n+            JVMTI_EVENT_VM_INIT, nullptr);\n@@ -167,1 +167,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/VMInit\/vminit001\/vminit001.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -149,2 +149,2 @@\n-    if (!NSK_JNI_VERIFY(jni, (cid = jni->GetMethodID(cls, \"<init>\", \"()V\")) != NULL)) {\n-         NSK_COMPLAIN0(\"newObject: GetMethodID returned NULL\\n\\n\");\n+    if (!NSK_JNI_VERIFY(jni, (cid = jni->GetMethodID(cls, \"<init>\", \"()V\")) != nullptr)) {\n+         NSK_COMPLAIN0(\"newObject: GetMethodID returned null\\n\\n\");\n@@ -152,1 +152,1 @@\n-         return NULL;\n+         return nullptr;\n@@ -155,1 +155,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (result = jni->NewObject(cls, cid)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (result = jni->NewObject(cls, cid)) != nullptr)) {\n@@ -157,1 +157,1 @@\n-         NSK_COMPLAIN0(\"newObject: NewObject returned NULL\\n\\n\");\n+         NSK_COMPLAIN0(\"newObject: NewObject returned null\\n\\n\");\n@@ -159,1 +159,1 @@\n-         return NULL;\n+         return nullptr;\n@@ -170,1 +170,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cid = jni->GetMethodID(cls, \"<init>\", \"()V\")) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (cid = jni->GetMethodID(cls, \"<init>\", \"()V\")) != nullptr)) {\n@@ -172,1 +172,1 @@\n-         NSK_COMPLAIN0(\"allocObject: GetMethodID returned NULL\\n\\n\");\n+         NSK_COMPLAIN0(\"allocObject: GetMethodID returned null\\n\\n\");\n@@ -174,1 +174,1 @@\n-         return NULL;\n+         return nullptr;\n@@ -177,1 +177,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (result = jni->AllocObject(cls)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (result = jni->AllocObject(cls)) != nullptr)) {\n@@ -179,1 +179,1 @@\n-         NSK_COMPLAIN0(\"allocObject: AllocObject returned NULL\\n\\n\");\n+         NSK_COMPLAIN0(\"allocObject: AllocObject returned null\\n\\n\");\n@@ -181,1 +181,1 @@\n-         return NULL;\n+         return nullptr;\n@@ -188,1 +188,1 @@\n-         return NULL;\n+         return nullptr;\n@@ -199,1 +199,1 @@\n-                                                          NULL))) {\n+                                                          nullptr))) {\n@@ -207,1 +207,1 @@\n-    jclass debugeeClass = NULL;\n+    jclass debugeeClass = nullptr;\n@@ -215,1 +215,1 @@\n-    if (debugeeClass == NULL) {\n+    if (debugeeClass == nullptr) {\n@@ -316,1 +316,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -346,1 +346,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -350,1 +350,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -354,1 +354,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP01\/ap01t001\/ap01t001.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -53,1 +53,1 @@\n-static jclass testedClass = NULL;\n+static jclass testedClass = nullptr;\n@@ -145,1 +145,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->IterateOverReachableObjects(NULL \/*heapRootCallback*\/,\n+    if (!NSK_JVMTI_VERIFY(jvmti->IterateOverReachableObjects(nullptr \/*heapRootCallback*\/,\n@@ -147,1 +147,1 @@\n-                                                             NULL \/*objectReferenceCallback*\/,\n+                                                             nullptr \/*objectReferenceCallback*\/,\n@@ -176,1 +176,1 @@\n-    if (testedClass == NULL) {\n+    if (testedClass == nullptr) {\n@@ -181,1 +181,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass)jni->NewGlobalRef(testedClass)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass)jni->NewGlobalRef(testedClass)) != nullptr))\n@@ -225,1 +225,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -239,1 +239,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP02\/ap02t001\/ap02t001.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -101,1 +101,1 @@\n-    jclass debugeeClass = NULL;\n+    jclass debugeeClass = nullptr;\n@@ -113,1 +113,1 @@\n-        if (debugeeClass == NULL) {\n+        if (debugeeClass == nullptr) {\n@@ -163,1 +163,1 @@\n-                jni->GetStaticFieldID(debugeeClass, \"catcher\", DEBUGEE_SIGNATURE)) != NULL)) {\n+                jni->GetStaticFieldID(debugeeClass, \"catcher\", DEBUGEE_SIGNATURE)) != nullptr)) {\n@@ -169,2 +169,2 @@\n-                jni->GetStaticObjectField(debugeeClass, fid)) != NULL)) {\n-            NSK_COMPLAIN0(\"GetStaticObjectField returned NULL for 'catcher' field value\\n\\n\");\n+                jni->GetStaticObjectField(debugeeClass, fid)) != nullptr)) {\n+            NSK_COMPLAIN0(\"GetStaticObjectField returned null for 'catcher' field value\\n\\n\");\n@@ -218,1 +218,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -247,1 +247,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -251,1 +251,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP03\/ap03t001\/ap03t001.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -55,3 +55,3 @@\n-static jclass debugeeClass = NULL;\n-static jfieldID rootFieldID = NULL;\n-static jmethodID unlockSecondaryID = NULL;\n+static jclass debugeeClass = nullptr;\n+static jfieldID rootFieldID = nullptr;\n+static jmethodID unlockSecondaryID = nullptr;\n@@ -65,1 +65,1 @@\n-static jrawMonitorID counterMonitor_ptr = NULL;\n+static jrawMonitorID counterMonitor_ptr = nullptr;\n@@ -272,1 +272,1 @@\n-                                                 NULL \/*user_data*\/))) {\n+                                                 nullptr \/*user_data*\/))) {\n@@ -301,1 +301,1 @@\n-                                                             NULL \/*user_data*\/))) {\n+                                                             nullptr \/*user_data*\/))) {\n@@ -330,1 +330,1 @@\n-                                                             NULL \/*user_data*\/))) {\n+                                                             nullptr \/*user_data*\/))) {\n@@ -350,1 +350,1 @@\n-    jobject root = NULL;\n+    jobject root = nullptr;\n@@ -354,2 +354,2 @@\n-            jni->GetStaticObjectField(debugeeClass, rootFieldID)) != NULL)) {\n-        NSK_COMPLAIN0(\"GetStaticObjectField returned NULL for 'root' field value\\n\\n\");\n+            jni->GetStaticObjectField(debugeeClass, rootFieldID)) != nullptr)) {\n+        NSK_COMPLAIN0(\"GetStaticObjectField returned null for 'root' field value\\n\\n\");\n@@ -370,1 +370,1 @@\n-                                                                       NULL \/*user_data*\/))) {\n+                                                                       nullptr \/*user_data*\/))) {\n@@ -395,1 +395,1 @@\n-    if (debugeeClass == NULL) {\n+    if (debugeeClass == nullptr) {\n@@ -400,1 +400,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = (jclass)jni->NewGlobalRef(debugeeClass)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = (jclass)jni->NewGlobalRef(debugeeClass)) != nullptr))\n@@ -405,1 +405,1 @@\n-            jni->GetStaticFieldID(debugeeClass, \"root\", ROOT_SIGNATURE)) != NULL)) {\n+            jni->GetStaticFieldID(debugeeClass, \"root\", ROOT_SIGNATURE)) != nullptr)) {\n@@ -412,1 +412,1 @@\n-            jni->GetStaticMethodID(debugeeClass, \"unlockSecondary\", \"()V\")) != NULL)) {\n+            jni->GetStaticMethodID(debugeeClass, \"unlockSecondary\", \"()V\")) != nullptr)) {\n@@ -426,1 +426,1 @@\n-    nsk_jvmti_enableEvents(JVMTI_DISABLE, eventsCount, events, NULL);\n+    nsk_jvmti_enableEvents(JVMTI_DISABLE, eventsCount, events, nullptr);\n@@ -454,1 +454,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -492,1 +492,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, eventsCount, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, eventsCount, events, nullptr)) {\n@@ -497,1 +497,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP04\/ap04t001\/ap04t001.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -52,1 +52,1 @@\n-static jclass debugeeClass = NULL;\n+static jclass debugeeClass = nullptr;\n@@ -58,1 +58,1 @@\n-static jrawMonitorID counterMonitor_ptr = NULL;\n+static jrawMonitorID counterMonitor_ptr = nullptr;\n@@ -252,1 +252,1 @@\n-                                                 NULL \/*user_data*\/))) {\n+                                                 nullptr \/*user_data*\/))) {\n@@ -282,1 +282,1 @@\n-                                                             NULL \/*user_data*\/))) {\n+                                                             nullptr \/*user_data*\/))) {\n@@ -312,1 +312,1 @@\n-                                                             NULL \/*user_data*\/))) {\n+                                                             nullptr \/*user_data*\/))) {\n@@ -332,1 +332,1 @@\n-    jobject root = NULL;\n+    jobject root = nullptr;\n@@ -336,2 +336,2 @@\n-                jni->GetStaticObjectField(debugeeClass, rootFieldID)) != NULL)) {\n-        NSK_COMPLAIN0(\"GetStaticObjectField returned NULL for 'root' field value\\n\\n\");\n+                jni->GetStaticObjectField(debugeeClass, rootFieldID)) != nullptr)) {\n+        NSK_COMPLAIN0(\"GetStaticObjectField returned null for 'root' field value\\n\\n\");\n@@ -349,1 +349,1 @@\n-                                                                       NULL \/*user_data*\/))) {\n+                                                                       nullptr \/*user_data*\/))) {\n@@ -375,1 +375,1 @@\n-    if (debugeeClass == NULL) {\n+    if (debugeeClass == nullptr) {\n@@ -380,1 +380,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = (jclass)jni->NewGlobalRef(debugeeClass)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = (jclass)jni->NewGlobalRef(debugeeClass)) != nullptr))\n@@ -385,1 +385,1 @@\n-            jni->GetStaticFieldID(debugeeClass, \"root\", ROOT_SIGNATURE)) != NULL)) {\n+            jni->GetStaticFieldID(debugeeClass, \"root\", ROOT_SIGNATURE)) != nullptr)) {\n@@ -392,1 +392,1 @@\n-            jni->GetStaticFieldID(debugeeClass, \"modified\", \"I\")) != NULL)) {\n+            jni->GetStaticFieldID(debugeeClass, \"modified\", \"I\")) != nullptr)) {\n@@ -437,1 +437,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -472,1 +472,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -476,1 +476,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP04\/ap04t002\/ap04t002.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -48,1 +48,1 @@\n-static jclass debugeeClass = NULL;\n+static jclass debugeeClass = nullptr;\n@@ -51,3 +51,3 @@\n-static jrawMonitorID startLock = NULL;\n-static jrawMonitorID runLock = NULL;\n-static jrawMonitorID endLock = NULL;\n+static jrawMonitorID startLock = nullptr;\n+static jrawMonitorID runLock = nullptr;\n+static jrawMonitorID endLock = nullptr;\n@@ -60,1 +60,1 @@\n-static jrawMonitorID counterMonitor_ptr = NULL;\n+static jrawMonitorID counterMonitor_ptr = nullptr;\n@@ -213,1 +213,1 @@\n-    jobject* taggedObjectsList = NULL;\n+    jobject* taggedObjectsList = nullptr;\n@@ -222,1 +222,1 @@\n-                1, &tag, &taggedObjectsCount, &taggedObjectsList, NULL))) {\n+                1, &tag, &taggedObjectsCount, &taggedObjectsList, nullptr))) {\n@@ -318,1 +318,1 @@\n-            jvmti->RunAgentThread(threadObj, agent_start, NULL, JVMTI_THREAD_NORM_PRIORITY))) {\n+            jvmti->RunAgentThread(threadObj, agent_start, nullptr, JVMTI_THREAD_NORM_PRIORITY))) {\n@@ -351,1 +351,1 @@\n-    jthread threadObj = NULL;\n+    jthread threadObj = nullptr;\n@@ -411,1 +411,1 @@\n-                                                 NULL \/*user_data*\/))) {\n+                                                 nullptr \/*user_data*\/))) {\n@@ -442,1 +442,1 @@\n-                                                             NULL \/*user_data*\/))) {\n+                                                             nullptr \/*user_data*\/))) {\n@@ -473,1 +473,1 @@\n-                                                             NULL \/*user_data*\/))) {\n+                                                             nullptr \/*user_data*\/))) {\n@@ -495,1 +495,1 @@\n-    jobject root = NULL;\n+    jobject root = nullptr;\n@@ -507,1 +507,1 @@\n-                                                                       NULL \/*user_data*\/))) {\n+                                                                       nullptr \/*user_data*\/))) {\n@@ -534,1 +534,1 @@\n-    if (debugeeClass == NULL) {\n+    if (debugeeClass == nullptr) {\n@@ -582,1 +582,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -611,1 +611,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP04\/ap04t003\/ap04t003.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -44,1 +44,1 @@\n-static jobject referrer = NULL;\n+static jobject referrer = nullptr;\n@@ -115,1 +115,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (referrer = jni->NewGlobalRef(ref)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (referrer = jni->NewGlobalRef(ref)) != nullptr))\n@@ -122,1 +122,1 @@\n-    jclass debugeeClass = NULL;\n+    jclass debugeeClass = nullptr;\n@@ -135,1 +135,1 @@\n-                                                                 NULL \/*user_data*\/))) {\n+                                                                 nullptr \/*user_data*\/))) {\n@@ -157,1 +157,1 @@\n-                    referrer, objectReferenceCallback, NULL \/*user_data*\/))) {\n+                    referrer, objectReferenceCallback, nullptr \/*user_data*\/))) {\n@@ -203,1 +203,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -218,1 +218,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP05\/ap05t001\/ap05t001.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -44,1 +44,1 @@\n-static jobject referrer = NULL;\n+static jobject referrer = nullptr;\n@@ -114,1 +114,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (referrer = jni->NewGlobalRef(ref)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (referrer = jni->NewGlobalRef(ref)) != nullptr))\n@@ -125,1 +125,1 @@\n-                                                             NULL \/*user_data*\/))) {\n+                                                             nullptr \/*user_data*\/))) {\n@@ -144,1 +144,1 @@\n-                                                                       NULL \/*user_data*\/))) {\n+                                                                       nullptr \/*user_data*\/))) {\n@@ -162,1 +162,1 @@\n-    jclass debugeeClass = NULL;\n+    jclass debugeeClass = nullptr;\n@@ -207,1 +207,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -222,1 +222,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP05\/ap05t002\/ap05t002.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -137,1 +137,1 @@\n-    jclass debugeeClass = NULL;\n+    jclass debugeeClass = nullptr;\n@@ -150,1 +150,1 @@\n-        if (debugeeClass == NULL) {\n+        if (debugeeClass == nullptr) {\n@@ -156,1 +156,1 @@\n-                jni->GetStaticFieldID(debugeeClass, \"thread\", THREAD_CLS_SIGNATURE)) != NULL)) {\n+                jni->GetStaticFieldID(debugeeClass, \"thread\", THREAD_CLS_SIGNATURE)) != nullptr)) {\n@@ -162,2 +162,2 @@\n-                jni->GetStaticObjectField(debugeeClass, fid)) != NULL)) {\n-            NSK_COMPLAIN0(\"GetStaticObjectField returned NULL for 'thread' field value\\n\\n\");\n+                jni->GetStaticObjectField(debugeeClass, fid)) != nullptr)) {\n+            NSK_COMPLAIN0(\"GetStaticObjectField returned null for 'thread' field value\\n\\n\");\n@@ -168,1 +168,1 @@\n-        if (!NSK_JNI_VERIFY(jni, (globalRefThread = jni->NewGlobalRef(localRefThread)) != NULL))\n+        if (!NSK_JNI_VERIFY(jni, (globalRefThread = jni->NewGlobalRef(localRefThread)) != nullptr))\n@@ -175,1 +175,1 @@\n-                                                                 NULL \/*user_data*\/))) {\n+                                                                 nullptr \/*user_data*\/))) {\n@@ -223,1 +223,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -238,1 +238,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP06\/ap06t001\/ap06t001.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -44,1 +44,1 @@\n-static jobject root = NULL;\n+static jobject root = nullptr;\n@@ -121,1 +121,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (root = jni->NewGlobalRef(obj)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (root = jni->NewGlobalRef(obj)) != nullptr))\n@@ -128,1 +128,1 @@\n-    jclass debugeeClass = NULL;\n+    jclass debugeeClass = nullptr;\n@@ -140,1 +140,1 @@\n-                                                                 NULL \/*user_data*\/))) {\n+                                                                 nullptr \/*user_data*\/))) {\n@@ -148,1 +148,1 @@\n-                    root, objectReferenceCallback, NULL \/*user_data*\/))) {\n+                    root, objectReferenceCallback, nullptr \/*user_data*\/))) {\n@@ -181,1 +181,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -196,1 +196,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP07\/ap07t001\/ap07t001.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -44,1 +44,1 @@\n-static jobject root = NULL;\n+static jobject root = nullptr;\n@@ -122,1 +122,1 @@\n-    jclass debugeeClass = NULL;\n+    jclass debugeeClass = nullptr;\n@@ -134,1 +134,1 @@\n-                                                                 NULL \/*user_data*\/))) {\n+                                                                 nullptr \/*user_data*\/))) {\n@@ -164,1 +164,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -179,1 +179,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP07\/ap07t002\/ap07t002.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -44,1 +44,1 @@\n-static jobject referrer = NULL;\n+static jobject referrer = nullptr;\n@@ -142,1 +142,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (referrer = jni->NewGlobalRef(ref)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (referrer = jni->NewGlobalRef(ref)) != nullptr))\n@@ -149,1 +149,1 @@\n-    jclass debugeeClass = NULL;\n+    jclass debugeeClass = nullptr;\n@@ -159,1 +159,1 @@\n-                                                                           NULL \/*user_data*\/))) {\n+                                                                           nullptr \/*user_data*\/))) {\n@@ -217,1 +217,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -234,1 +234,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP09\/ap09t001\/ap09t001.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -59,1 +59,1 @@\n-    LocalStorage* obtainedData = NULL;\n+    LocalStorage* obtainedData = nullptr;\n@@ -262,1 +262,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -299,1 +299,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -303,1 +303,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -307,1 +307,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -311,1 +311,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP10\/ap10t001\/ap10t001.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-        if (signature != NULL && strcmp(signature, exp_sig) == 0) {\n+        if (signature != nullptr && strcmp(signature, exp_sig) == 0) {\n@@ -53,1 +53,1 @@\n-        if (signature != NULL)\n+        if (signature != nullptr)\n@@ -56,1 +56,1 @@\n-        if (generic != NULL)\n+        if (generic != nullptr)\n@@ -144,1 +144,1 @@\n-        if (classes != NULL)\n+        if (classes != nullptr)\n@@ -177,1 +177,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -180,1 +180,1 @@\n-    if (generic != NULL)\n+    if (generic != nullptr)\n@@ -213,1 +213,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -226,1 +226,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -242,1 +242,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, nullptr)))\n@@ -246,1 +246,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP11\/ap11t001\/ap11t001.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -92,1 +92,1 @@\n-                                                          NULL))) {\n+                                                          nullptr))) {\n@@ -100,1 +100,1 @@\n-    jclass debugeeClass = NULL;\n+    jclass debugeeClass = nullptr;\n@@ -135,1 +135,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -165,1 +165,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -169,1 +169,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -173,1 +173,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP12\/ap12t001\/ap12t001.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -109,1 +109,1 @@\n-    if (name == NULL || strcmp(name, TESTED_CLASS_NAME)) {\n+    if (name == nullptr || strcmp(name, TESTED_CLASS_NAME)) {\n@@ -178,1 +178,1 @@\n-                                                          NULL))) {\n+                                                          nullptr))) {\n@@ -243,1 +243,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -270,1 +270,1 @@\n-                                                          NULL))) {\n+                                                          nullptr))) {\n@@ -275,1 +275,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/bcinstr\/BI01\/bi01t001\/bi01t001.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -112,1 +112,1 @@\n-    if (name == NULL || strcmp(name, TESTED_CLASS_NAME)) {\n+    if (name == nullptr || strcmp(name, TESTED_CLASS_NAME)) {\n@@ -186,1 +186,1 @@\n-                                                          NULL))) {\n+                                                          nullptr))) {\n@@ -256,1 +256,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -283,1 +283,1 @@\n-                                                          NULL))) {\n+                                                          nullptr))) {\n@@ -288,1 +288,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/bcinstr\/BI01\/bi01t002\/bi01t002.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-static jclass debugeeClass = NULL;\n-static jbyteArray classBytes = NULL;\n+static jclass debugeeClass = nullptr;\n+static jbyteArray classBytes = nullptr;\n@@ -58,1 +58,1 @@\n-    if (name != NULL && (strcmp(name, CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, CLASS_NAME) == 0)) {\n@@ -62,1 +62,1 @@\n-        if (class_being_redefined == NULL) {\n+        if (class_being_redefined == nullptr) {\n@@ -72,1 +72,1 @@\n-                    jni_env->GetByteArrayElements(classBytes, NULL)) != NULL)) {\n+                    jni_env->GetByteArrayElements(classBytes, nullptr)) != nullptr)) {\n@@ -85,1 +85,1 @@\n-    jfieldID field = NULL;\n+    jfieldID field = nullptr;\n@@ -88,1 +88,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr))\n@@ -91,1 +91,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = (jclass)jni->NewGlobalRef(debugeeClass)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = (jclass)jni->NewGlobalRef(debugeeClass)) != nullptr))\n@@ -95,1 +95,1 @@\n-            jni->GetStaticFieldID(debugeeClass, \"newClassBytes\", \"[B\")) != NULL))\n+            jni->GetStaticFieldID(debugeeClass, \"newClassBytes\", \"[B\")) != nullptr))\n@@ -99,1 +99,1 @@\n-            jni->GetStaticObjectField(debugeeClass, field)) != NULL))\n+            jni->GetStaticObjectField(debugeeClass, field)) != nullptr))\n@@ -102,1 +102,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (classBytes = (jbyteArray)jni->NewGlobalRef(classBytes)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (classBytes = (jbyteArray)jni->NewGlobalRef(classBytes)) != nullptr))\n@@ -107,1 +107,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -140,1 +140,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -165,1 +165,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -177,1 +177,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -185,1 +185,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/bcinstr\/BI02\/bi02t001\/bi02t001.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,3 +41,3 @@\n-static jclass debugeeClass = NULL;\n-static jclass testedClass = NULL;\n-static jbyteArray classBytes = NULL;\n+static jclass debugeeClass = nullptr;\n+static jclass testedClass = nullptr;\n+static jbyteArray classBytes = nullptr;\n@@ -52,1 +52,1 @@\n-    jfieldID field = NULL;\n+    jfieldID field = nullptr;\n@@ -55,1 +55,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr))\n@@ -58,1 +58,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = (jclass)jni->NewGlobalRef(debugeeClass)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = (jclass)jni->NewGlobalRef(debugeeClass)) != nullptr))\n@@ -62,1 +62,1 @@\n-            jni->GetStaticFieldID(debugeeClass, \"newClassBytes\", \"[B\")) != NULL))\n+            jni->GetStaticFieldID(debugeeClass, \"newClassBytes\", \"[B\")) != nullptr))\n@@ -66,1 +66,1 @@\n-            jni->GetStaticObjectField(debugeeClass, field)) != NULL))\n+            jni->GetStaticObjectField(debugeeClass, field)) != nullptr))\n@@ -69,1 +69,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (classBytes = (jbyteArray)jni->NewGlobalRef(classBytes)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (classBytes = (jbyteArray)jni->NewGlobalRef(classBytes)) != nullptr))\n@@ -73,1 +73,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedClass = jni->FindClass(CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedClass = jni->FindClass(CLASS_NAME)) != nullptr))\n@@ -76,1 +76,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass)jni->NewGlobalRef(testedClass)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass)jni->NewGlobalRef(testedClass)) != nullptr))\n@@ -93,1 +93,1 @@\n-            jni->GetByteArrayElements(classBytes, NULL)) != NULL))\n+            jni->GetByteArrayElements(classBytes, nullptr)) != nullptr))\n@@ -149,1 +149,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -160,1 +160,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -168,1 +168,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/bcinstr\/BI02\/bi02t002\/bi02t002.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-static jclass debugeeClass = NULL;\n-static jbyteArray classBytes = NULL;\n+static jclass debugeeClass = nullptr;\n+static jbyteArray classBytes = nullptr;\n@@ -58,1 +58,1 @@\n-    if (name != NULL && (strcmp(name, CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, CLASS_NAME) == 0)) {\n@@ -62,1 +62,1 @@\n-        if (class_being_redefined == NULL) {\n+        if (class_being_redefined == nullptr) {\n@@ -72,1 +72,1 @@\n-                    jni_env->GetByteArrayElements(classBytes, NULL)) != NULL)) {\n+                    jni_env->GetByteArrayElements(classBytes, nullptr)) != nullptr)) {\n@@ -85,1 +85,1 @@\n-    jfieldID field = NULL;\n+    jfieldID field = nullptr;\n@@ -88,1 +88,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr))\n@@ -91,1 +91,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = (jclass)jni->NewGlobalRef(debugeeClass)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = (jclass)jni->NewGlobalRef(debugeeClass)) != nullptr))\n@@ -95,1 +95,1 @@\n-            jni->GetStaticFieldID(debugeeClass, \"newClassBytes\", \"[B\")) != NULL))\n+            jni->GetStaticFieldID(debugeeClass, \"newClassBytes\", \"[B\")) != nullptr))\n@@ -99,1 +99,1 @@\n-            jni->GetStaticObjectField(debugeeClass, field)) != NULL))\n+            jni->GetStaticObjectField(debugeeClass, field)) != nullptr))\n@@ -102,1 +102,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (classBytes = (jbyteArray)jni->NewGlobalRef(classBytes)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (classBytes = (jbyteArray)jni->NewGlobalRef(classBytes)) != nullptr))\n@@ -107,1 +107,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -140,1 +140,1 @@\n-                                                          NULL)))\n+                                                          nullptr)))\n@@ -165,1 +165,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -177,1 +177,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -185,1 +185,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/bcinstr\/BI03\/bi03t001\/bi03t001.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,3 +41,3 @@\n-static jclass debugeeClass = NULL;\n-static jclass testedClass = NULL;\n-static jbyteArray classBytes = NULL;\n+static jclass debugeeClass = nullptr;\n+static jclass testedClass = nullptr;\n+static jbyteArray classBytes = nullptr;\n@@ -52,1 +52,1 @@\n-    jfieldID field = NULL;\n+    jfieldID field = nullptr;\n@@ -55,1 +55,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr))\n@@ -58,1 +58,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = (jclass)jni->NewGlobalRef(debugeeClass)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = (jclass)jni->NewGlobalRef(debugeeClass)) != nullptr))\n@@ -62,1 +62,1 @@\n-            jni->GetStaticFieldID(debugeeClass, \"newClassBytes\", \"[B\")) != NULL))\n+            jni->GetStaticFieldID(debugeeClass, \"newClassBytes\", \"[B\")) != nullptr))\n@@ -66,1 +66,1 @@\n-            jni->GetStaticObjectField(debugeeClass, field)) != NULL))\n+            jni->GetStaticObjectField(debugeeClass, field)) != nullptr))\n@@ -69,1 +69,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (classBytes = (jbyteArray)jni->NewGlobalRef(classBytes)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (classBytes = (jbyteArray)jni->NewGlobalRef(classBytes)) != nullptr))\n@@ -73,1 +73,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedClass = jni->FindClass(CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedClass = jni->FindClass(CLASS_NAME)) != nullptr))\n@@ -76,1 +76,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass)jni->NewGlobalRef(testedClass)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass)jni->NewGlobalRef(testedClass)) != nullptr))\n@@ -93,1 +93,1 @@\n-            jni->GetByteArrayElements(classBytes, NULL)) != NULL))\n+            jni->GetByteArrayElements(classBytes, nullptr)) != nullptr))\n@@ -149,1 +149,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -160,1 +160,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -168,1 +168,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/bcinstr\/BI03\/bi03t002\/bi03t002.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    if (bytecode == NULL) {\n+    if (bytecode == nullptr) {\n@@ -140,1 +140,1 @@\n-    jvmtiEnv *jvmti = NULL;\n+    jvmtiEnv *jvmti = nullptr;\n@@ -148,1 +148,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -164,1 +164,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/bcinstr\/BI04\/bi04t002\/bi04t002.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -65,4 +65,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -75,1 +75,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -85,1 +85,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -90,1 +90,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -100,1 +100,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -110,1 +110,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -114,1 +114,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -119,1 +119,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -159,3 +159,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -163,1 +163,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -167,1 +167,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -170,1 +170,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -189,1 +189,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -202,1 +202,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -254,2 +254,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -298,1 +298,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -368,1 +368,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -396,1 +396,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -568,1 +568,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -572,1 +572,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t001\/cm01t001.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,2 +53,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -58,4 +58,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -68,1 +68,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -78,1 +78,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -83,1 +83,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -93,1 +93,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -102,1 +102,1 @@\n-    if (thread == NULL) {\n+    if (thread == nullptr) {\n@@ -108,1 +108,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -112,1 +112,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -117,1 +117,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -157,3 +157,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -161,1 +161,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -165,1 +165,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -168,1 +168,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -187,1 +187,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -200,1 +200,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -252,2 +252,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -306,1 +306,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -376,1 +376,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -404,1 +404,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -577,1 +577,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -581,1 +581,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t002\/cm01t002.cpp","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -60,4 +60,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -70,1 +70,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -80,1 +80,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -85,1 +85,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -95,1 +95,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -105,1 +105,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -109,1 +109,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -114,1 +114,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -154,3 +154,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -158,1 +158,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -162,1 +162,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -165,1 +165,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -184,1 +184,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -197,1 +197,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -249,2 +249,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -303,1 +303,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -373,1 +373,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -401,1 +401,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -571,1 +571,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -575,1 +575,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t003\/cm01t003.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,2 +53,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -58,4 +58,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -68,1 +68,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -78,1 +78,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -83,1 +83,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -93,1 +93,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -103,1 +103,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -107,1 +107,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -112,1 +112,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -152,3 +152,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -156,1 +156,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -160,1 +160,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -163,1 +163,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -182,1 +182,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -194,1 +194,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -246,2 +246,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -300,1 +300,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -370,1 +370,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -398,1 +398,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -570,1 +570,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -574,1 +574,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t004\/cm01t004.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,2 +53,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -58,4 +58,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -68,1 +68,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -78,1 +78,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -83,1 +83,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -93,1 +93,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -103,1 +103,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -107,1 +107,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -112,1 +112,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -152,3 +152,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -156,1 +156,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -160,1 +160,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -163,1 +163,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -182,1 +182,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -195,1 +195,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -246,2 +246,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -300,1 +300,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -370,1 +370,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -398,1 +398,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -570,1 +570,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -574,1 +574,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t005\/cm01t005.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,2 +53,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -58,4 +58,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -68,1 +68,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -78,1 +78,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -83,1 +83,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -93,1 +93,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -103,1 +103,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -107,1 +107,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -112,1 +112,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -152,3 +152,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -156,1 +156,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -160,1 +160,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -163,1 +163,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -182,1 +182,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -195,1 +195,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -247,2 +247,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -301,1 +301,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -371,1 +371,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -399,1 +399,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -570,1 +570,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -574,1 +574,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t006\/cm01t006.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,2 +53,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -58,4 +58,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -68,1 +68,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -78,1 +78,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -83,1 +83,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -93,1 +93,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -103,1 +103,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -107,1 +107,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -111,1 +111,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"waitingFlag\", \"Z\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"waitingFlag\", \"Z\")) != nullptr))\n@@ -151,3 +151,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -155,1 +155,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -159,1 +159,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -162,1 +162,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -181,1 +181,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -194,1 +194,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -268,2 +268,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -324,1 +324,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -394,1 +394,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -422,1 +422,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -594,1 +594,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -598,1 +598,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t007\/cm01t007.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -60,4 +60,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -65,1 +65,1 @@\n-static unsigned char *klass_bytes = NULL;\n+static unsigned char *klass_bytes = nullptr;\n@@ -72,1 +72,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -82,1 +82,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -87,1 +87,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -97,1 +97,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -107,1 +107,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -111,1 +111,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -116,1 +116,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -156,3 +156,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -160,1 +160,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -164,1 +164,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -167,1 +167,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -186,1 +186,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -199,1 +199,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -251,2 +251,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -305,1 +305,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -375,1 +375,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -508,1 +508,1 @@\n-    if (name != NULL && (strcmp(name, CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, CLASS_NAME) == 0)) {\n@@ -517,1 +517,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL));\n+            jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr));\n@@ -603,1 +603,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -607,1 +607,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -677,1 +677,1 @@\n-        jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+        jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t008\/cm01t008.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -60,4 +60,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -70,1 +70,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -80,1 +80,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -85,1 +85,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -95,1 +95,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -105,1 +105,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -109,1 +109,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -114,1 +114,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -154,3 +154,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -158,1 +158,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -162,1 +162,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -165,1 +165,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -183,1 +183,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -196,1 +196,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -248,2 +248,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -302,1 +302,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -372,1 +372,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -400,1 +400,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -572,1 +572,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -576,1 +576,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t009\/cm01t009.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -59,4 +59,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -69,1 +69,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -79,1 +79,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -84,1 +84,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -94,1 +94,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -104,1 +104,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -108,1 +108,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -113,1 +113,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -153,3 +153,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -157,1 +157,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -161,1 +161,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -164,1 +164,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -183,1 +183,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -196,1 +196,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -248,2 +248,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -302,1 +302,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -372,1 +372,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -399,1 +399,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -571,1 +571,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -575,1 +575,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t010\/cm01t010.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,2 +64,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -69,4 +69,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -79,1 +79,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -89,1 +89,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -94,1 +94,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -104,1 +104,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -114,1 +114,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -118,1 +118,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -123,1 +123,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -163,3 +163,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -167,1 +167,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -171,1 +171,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -174,1 +174,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -193,1 +193,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -206,1 +206,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -258,2 +258,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -312,1 +312,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -402,1 +402,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -430,1 +430,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -602,1 +602,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -606,1 +606,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t011\/cm01t011.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -62,4 +62,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -72,1 +72,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -82,1 +82,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -87,1 +87,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -97,1 +97,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -107,1 +107,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -111,1 +111,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -116,1 +116,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -154,3 +154,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -158,1 +158,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -162,1 +162,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -165,1 +165,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -184,1 +184,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -197,1 +197,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -249,2 +249,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -303,1 +303,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -373,1 +373,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -401,1 +401,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -573,1 +573,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -577,1 +577,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t012\/cm01t012.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -59,4 +59,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -69,1 +69,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -79,1 +79,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -84,1 +84,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -94,1 +94,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -104,1 +104,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -108,1 +108,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -113,1 +113,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -153,3 +153,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -157,1 +157,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -161,1 +161,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -164,1 +164,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -183,1 +183,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -196,1 +196,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -248,2 +248,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -302,1 +302,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -372,1 +372,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -399,1 +399,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -571,1 +571,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -575,1 +575,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t013\/cm01t013.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -60,4 +60,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -70,1 +70,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -80,1 +80,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -85,1 +85,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -95,1 +95,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -105,1 +105,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -109,1 +109,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -114,1 +114,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -219,3 +219,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -223,1 +223,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -227,1 +227,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -230,1 +230,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -249,1 +249,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -262,1 +262,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -314,2 +314,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -368,1 +368,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -438,1 +438,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -466,1 +466,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -697,1 +697,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -701,1 +701,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t014\/cm01t014.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -62,4 +62,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -72,1 +72,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -82,1 +82,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -87,1 +87,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -97,1 +97,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -107,1 +107,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -111,1 +111,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -116,1 +116,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -221,3 +221,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -225,1 +225,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -229,1 +229,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -232,1 +232,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -251,1 +251,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -264,1 +264,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -316,2 +316,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -370,1 +370,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -440,1 +440,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -468,1 +468,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -701,1 +701,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -705,1 +705,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t015\/cm01t015.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -60,4 +60,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -70,1 +70,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -80,1 +80,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -85,1 +85,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -95,1 +95,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -105,1 +105,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -109,1 +109,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -114,1 +114,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -219,3 +219,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -223,1 +223,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -227,1 +227,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -230,1 +230,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -249,1 +249,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -262,1 +262,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -314,2 +314,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -368,1 +368,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -438,1 +438,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -466,1 +466,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -695,1 +695,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -699,1 +699,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t016\/cm01t016.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -62,4 +62,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -72,1 +72,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -82,1 +82,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -87,1 +87,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -97,1 +97,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -107,1 +107,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -111,1 +111,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -116,1 +116,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -221,3 +221,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -225,1 +225,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -229,1 +229,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -232,1 +232,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -262,1 +262,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -275,1 +275,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -327,2 +327,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -381,1 +381,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -451,1 +451,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -479,1 +479,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -702,1 +702,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -706,1 +706,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t017\/cm01t017.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,2 +59,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -64,4 +64,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -74,1 +74,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -84,1 +84,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -89,1 +89,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -99,1 +99,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -109,1 +109,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -113,1 +113,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -118,1 +118,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -243,3 +243,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -247,1 +247,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -251,1 +251,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -254,1 +254,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -273,1 +273,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -286,1 +286,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -338,2 +338,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -392,1 +392,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -462,1 +462,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -490,1 +490,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -713,1 +713,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -717,1 +717,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t018\/cm01t018.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -59,4 +59,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -69,1 +69,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -79,1 +79,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -84,1 +84,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -94,1 +94,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -104,1 +104,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -108,1 +108,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -113,1 +113,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -153,3 +153,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -157,1 +157,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -161,1 +161,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -164,1 +164,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -183,1 +183,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -196,1 +196,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -248,2 +248,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -302,1 +302,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -372,1 +372,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -400,1 +400,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -572,1 +572,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -576,1 +576,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t019\/cm01t019.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -60,4 +60,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -70,1 +70,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -80,1 +80,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -85,1 +85,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -95,1 +95,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -105,1 +105,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -109,1 +109,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -114,1 +114,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -154,3 +154,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -158,1 +158,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -162,1 +162,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -165,1 +165,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -184,1 +184,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -197,1 +197,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -249,2 +249,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -303,1 +303,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -373,1 +373,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -401,1 +401,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -571,1 +571,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -575,1 +575,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t020\/cm01t020.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -60,4 +60,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -70,1 +70,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -80,1 +80,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -85,1 +85,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -95,1 +95,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -105,1 +105,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -109,1 +109,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -114,1 +114,1 @@\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n+            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != nullptr))\n@@ -154,3 +154,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -158,1 +158,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -162,1 +162,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -165,1 +165,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -184,1 +184,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -197,1 +197,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -249,2 +249,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -303,1 +303,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -373,1 +373,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -401,1 +401,1 @@\n-    class_def.class_bytes = NULL;\n+    class_def.class_bytes = nullptr;\n@@ -571,1 +571,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -575,1 +575,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM01\/cm01t021\/cm01t021.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,3 +61,3 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jobject testedObject = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jobject testedObject = nullptr;\n@@ -101,2 +101,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -106,1 +106,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -112,1 +112,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -114,1 +114,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -121,2 +121,2 @@\n-    char *name = NULL;\n-    char *sig = NULL;\n+    char *name = nullptr;\n+    char *sig = nullptr;\n@@ -128,1 +128,1 @@\n-    err = jvmti_env->GetMethodName(method, &name, &sig, NULL);\n+    err = jvmti_env->GetMethodName(method, &name, &sig, nullptr);\n@@ -209,1 +209,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(object_klass, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(object_klass, &signature, nullptr))) {\n@@ -214,1 +214,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -222,2 +222,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -235,1 +235,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -242,1 +242,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -244,1 +244,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -277,1 +277,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -287,1 +287,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -292,1 +292,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -302,1 +302,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -307,1 +307,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != nullptr))\n@@ -315,1 +315,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -369,1 +369,1 @@\n-    jobject *monitors = NULL;\n+    jobject *monitors = nullptr;\n@@ -381,1 +381,1 @@\n-    jobject monitor = NULL;\n+    jobject monitor = nullptr;\n@@ -436,1 +436,1 @@\n-    _jni->PopLocalFrame(NULL);\n+    _jni->PopLocalFrame(nullptr);\n@@ -443,2 +443,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -449,1 +449,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewStringUTF(\"abcde\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewStringUTF(\"abcde\")) != nullptr))\n@@ -471,2 +471,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -496,2 +496,2 @@\n-    jobject *res_objects = NULL;\n-    jlong *res_tags = NULL;\n+    jobject *res_objects = nullptr;\n+    jlong *res_tags = nullptr;\n@@ -740,1 +740,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -753,1 +753,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -794,1 +794,1 @@\n-            JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+            JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n@@ -797,1 +797,1 @@\n-            JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL)))\n+            JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr)))\n@@ -800,1 +800,1 @@\n-            JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_UNLOAD, NULL)))\n+            JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_UNLOAD, nullptr)))\n@@ -803,1 +803,1 @@\n-            JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL)))\n+            JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, nullptr)))\n@@ -806,1 +806,1 @@\n-            JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL)))\n+            JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, nullptr)))\n@@ -809,1 +809,1 @@\n-            JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)))\n+            JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, nullptr)))\n@@ -812,1 +812,1 @@\n-            JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)))\n+            JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, nullptr)))\n@@ -815,1 +815,1 @@\n-            JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, NULL)))\n+            JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, nullptr)))\n@@ -818,1 +818,1 @@\n-            JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, NULL)))\n+            JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, nullptr)))\n@@ -821,1 +821,1 @@\n-            JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_START, NULL)))\n+            JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_START, nullptr)))\n@@ -824,1 +824,1 @@\n-            JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, NULL)))\n+            JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, nullptr)))\n@@ -827,1 +827,1 @@\n-            JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, NULL)))\n+            JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, nullptr)))\n@@ -831,1 +831,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM02\/cm02t001\/cm02t001.cpp","additions":50,"deletions":50,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,4 +65,4 @@\n-static jthread thread = NULL;\n-static jclass klass = NULL;\n-static jmethodID method = NULL;\n-static jfieldID field = NULL;\n+static jthread thread = nullptr;\n+static jclass klass = nullptr;\n+static jmethodID method = nullptr;\n+static jfieldID field = nullptr;\n@@ -70,1 +70,1 @@\n-static unsigned char *klass_bytes = NULL;\n+static unsigned char *klass_bytes = nullptr;\n@@ -96,1 +96,1 @@\n-    if (name != NULL && (strcmp(name, CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, CLASS_NAME) == 0)) {\n@@ -106,1 +106,1 @@\n-                JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL));\n+                JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr));\n@@ -114,2 +114,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -122,1 +122,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetFieldName(field_klass, field, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetFieldName(field_klass, field, &name, &signature, nullptr))) {\n@@ -127,1 +127,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -129,1 +129,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -138,2 +138,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -143,1 +143,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetFieldName(field_klass, field, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetFieldName(field_klass, field, &name, &signature, nullptr))) {\n@@ -148,1 +148,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -150,1 +150,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -157,2 +157,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -164,1 +164,1 @@\n-            JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, NULL));\n+            JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, nullptr));\n@@ -166,1 +166,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -171,1 +171,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -173,1 +173,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -181,2 +181,2 @@\n-    jclass klass = NULL;\n-    char *signature = NULL;\n+    jclass klass = nullptr;\n+    char *signature = nullptr;\n@@ -186,1 +186,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != nullptr)) {\n@@ -190,1 +190,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, nullptr))) {\n@@ -195,1 +195,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -202,2 +202,2 @@\n-    jclass klass = NULL;\n-    char *signature = NULL;\n+    jclass klass = nullptr;\n+    char *signature = nullptr;\n@@ -207,1 +207,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != nullptr)) {\n@@ -211,1 +211,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, nullptr))) {\n@@ -216,1 +216,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -223,2 +223,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -227,1 +227,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -232,1 +232,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -234,1 +234,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -244,2 +244,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -248,1 +248,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -253,1 +253,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -255,1 +255,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -262,2 +262,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -266,1 +266,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -271,1 +271,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -273,1 +273,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -281,2 +281,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -285,1 +285,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -290,1 +290,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -292,1 +292,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -301,1 +301,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -311,1 +311,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -316,1 +316,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -326,1 +326,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -331,1 +331,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != nullptr))\n@@ -339,1 +339,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -343,1 +343,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = (jclass)jni->NewGlobalRef(klass)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = (jclass)jni->NewGlobalRef(klass)) != nullptr))\n@@ -347,1 +347,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"delay\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"delay\", \"()V\")) != nullptr))\n@@ -351,1 +351,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"waitingFlag\", \"Z\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"waitingFlag\", \"Z\")) != nullptr))\n@@ -361,1 +361,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"letItGo\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"letItGo\", \"()V\")) != nullptr))\n@@ -365,1 +365,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"waitingFlag\", \"Z\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"waitingFlag\", \"Z\")) != nullptr))\n@@ -379,1 +379,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, nullptr)))\n@@ -382,1 +382,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, nullptr)))\n@@ -385,1 +385,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION_CATCH, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION_CATCH, nullptr)))\n@@ -486,1 +486,1 @@\n-    if (!NSK_VERIFY(klass_byte_count != 0 && klass_bytes != NULL))\n+    if (!NSK_VERIFY(klass_byte_count != 0 && klass_bytes != nullptr))\n@@ -519,1 +519,1 @@\n-    jvmtiLineNumberEntry *line_number_table = NULL;\n+    jvmtiLineNumberEntry *line_number_table = nullptr;\n@@ -545,1 +545,1 @@\n-    jvmtiLocalVariableEntry *local_variable_table = NULL;\n+    jvmtiLocalVariableEntry *local_variable_table = nullptr;\n@@ -683,3 +683,3 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n-    jobject exception = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n+    jobject exception = nullptr;\n@@ -687,1 +687,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -691,1 +691,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -694,1 +694,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (exception = jni->NewObject(cls, ctor)) != nullptr))\n@@ -851,1 +851,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -864,1 +864,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -907,1 +907,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n@@ -910,1 +910,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, nullptr)))\n@@ -913,1 +913,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_MODIFICATION, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_MODIFICATION, nullptr)))\n@@ -916,1 +916,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr)))\n@@ -919,1 +919,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, nullptr)))\n@@ -923,1 +923,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM03\/cm03t001\/cm03t001.cpp","additions":85,"deletions":85,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,3 @@\n-static jthread thread = NULL;\n-static jobject object_M1 = NULL;\n-static jobject object_M2 = NULL;\n+static jthread thread = nullptr;\n+static jobject object_M1 = nullptr;\n+static jobject object_M2 = nullptr;\n@@ -48,1 +48,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -50,2 +50,2 @@\n-    jfieldID field = NULL;\n-    jclass klass = NULL;\n+    jfieldID field = nullptr;\n+    jclass klass = nullptr;\n@@ -60,1 +60,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -65,1 +65,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -75,1 +75,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -79,1 +79,1 @@\n-        if (info.name != NULL) {\n+        if (info.name != nullptr) {\n@@ -90,1 +90,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -94,1 +94,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"M1\", FIELD_SIG)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"M1\", FIELD_SIG)) != nullptr))\n@@ -97,1 +97,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (object_M1 = jni->GetObjectField(thread, field)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (object_M1 = jni->GetObjectField(thread, field)) != nullptr))\n@@ -101,1 +101,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"M2\", FIELD_SIG)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"M2\", FIELD_SIG)) != nullptr))\n@@ -104,1 +104,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (object_M2 = jni->GetObjectField(thread, field)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (object_M2 = jni->GetObjectField(thread, field)) != nullptr))\n@@ -124,1 +124,1 @@\n-        if (inf.owner == NULL) {\n+        if (inf.owner == nullptr) {\n@@ -131,1 +131,1 @@\n-                if (tinf.name != NULL) {\n+                if (tinf.name != nullptr) {\n@@ -148,1 +148,1 @@\n-                    if (tinf.name != NULL) {\n+                    if (tinf.name != nullptr) {\n@@ -165,1 +165,1 @@\n-                    if (tinf.name != NULL) {\n+                    if (tinf.name != nullptr) {\n@@ -188,1 +188,1 @@\n-    if (inf.waiters != NULL) {\n+    if (inf.waiters != nullptr) {\n@@ -192,1 +192,1 @@\n-    if (inf.notify_waiters != NULL) {\n+    if (inf.notify_waiters != nullptr) {\n@@ -245,1 +245,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -257,1 +257,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -267,1 +267,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/contention\/TC01\/tc01t001\/tc01t001.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-static jthread thread = NULL;\n-static jobject object_M = NULL;\n+static jthread thread = nullptr;\n+static jobject object_M = nullptr;\n@@ -48,1 +48,1 @@\n-    jmethodID method = NULL;\n+    jmethodID method = nullptr;\n@@ -50,1 +50,1 @@\n-    jvmtiLineNumberEntry* table = NULL;\n+    jvmtiLineNumberEntry* table = nullptr;\n@@ -58,1 +58,1 @@\n-    if (!NSK_VERIFY(method != NULL))\n+    if (!NSK_VERIFY(method != nullptr))\n@@ -67,1 +67,1 @@\n-    if (!NSK_VERIFY(table != NULL))\n+    if (!NSK_VERIFY(table != nullptr))\n@@ -81,1 +81,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -95,1 +95,1 @@\n-    if (!NSK_VERIFY(thr != NULL)) {\n+    if (!NSK_VERIFY(thr != nullptr)) {\n@@ -101,1 +101,1 @@\n-    if (!NSK_VERIFY(obj != NULL)) {\n+    if (!NSK_VERIFY(obj != nullptr)) {\n@@ -140,1 +140,1 @@\n-    if (!NSK_VERIFY(thr != NULL)) {\n+    if (!NSK_VERIFY(thr != nullptr)) {\n@@ -146,1 +146,1 @@\n-    if (!NSK_VERIFY(obj != NULL)) {\n+    if (!NSK_VERIFY(obj != nullptr)) {\n@@ -187,1 +187,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -189,2 +189,2 @@\n-    jfieldID field = NULL;\n-    jclass klass = NULL;\n+    jfieldID field = nullptr;\n+    jclass klass = nullptr;\n@@ -199,1 +199,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -204,1 +204,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -214,1 +214,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -218,1 +218,1 @@\n-        if (info.name != NULL) {\n+        if (info.name != nullptr) {\n@@ -228,1 +228,1 @@\n-    if (thread == NULL) {\n+    if (thread == nullptr) {\n@@ -234,1 +234,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != nullptr))\n@@ -238,1 +238,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -242,1 +242,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"M\", FIELD_SIG)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"M\", FIELD_SIG)) != nullptr))\n@@ -245,1 +245,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (object_M = jni->GetObjectField(thread, field)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (object_M = jni->GetObjectField(thread, field)) != nullptr))\n@@ -249,1 +249,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (object_M = jni->NewGlobalRef(object_M)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (object_M = jni->NewGlobalRef(object_M)) != nullptr))\n@@ -255,1 +255,1 @@\n-                JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL)))\n+                JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, nullptr)))\n@@ -261,1 +261,1 @@\n-                JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL)))\n+                JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, nullptr)))\n@@ -272,1 +272,1 @@\n-                JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL)))\n+                JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, nullptr)))\n@@ -337,1 +337,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -350,1 +350,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -367,1 +367,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/contention\/TC02\/tc02t001\/tc02t001.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-static threadDesc *threadList = NULL;\n+static threadDesc *threadList = nullptr;\n@@ -51,2 +51,2 @@\n-    jobject monitor = NULL;\n-    jclass klass = NULL;\n+    jobject monitor = nullptr;\n+    jclass klass = nullptr;\n@@ -63,2 +63,2 @@\n-        if (monitor != NULL) {\n-            if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(monitor)) != NULL))\n+        if (monitor != nullptr) {\n+            if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(monitor)) != nullptr))\n@@ -66,1 +66,1 @@\n-            if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(klass, &name, NULL)))\n+            if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(klass, &name, nullptr)))\n@@ -75,1 +75,1 @@\n-        if (usageInfo.owner == NULL)\n+        if (usageInfo.owner == nullptr)\n@@ -81,1 +81,1 @@\n-        if (usageInfo.waiters != NULL) {\n+        if (usageInfo.waiters != nullptr) {\n@@ -84,1 +84,1 @@\n-        if (usageInfo.notify_waiters != NULL) {\n+        if (usageInfo.notify_waiters != nullptr) {\n@@ -100,2 +100,2 @@\n-    jthread *threads = NULL;\n-    jobject monitor = NULL;\n+    jthread *threads = nullptr;\n+    jobject monitor = nullptr;\n@@ -113,1 +113,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -121,1 +121,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -147,1 +147,1 @@\n-                if (monitor == NULL)\n+                if (monitor == nullptr)\n@@ -151,1 +151,1 @@\n-                if (usageInfo.owner == NULL)\n+                if (usageInfo.owner == nullptr)\n@@ -157,1 +157,1 @@\n-                if (usageInfo.waiters != NULL) {\n+                if (usageInfo.waiters != nullptr) {\n@@ -160,1 +160,1 @@\n-                if (usageInfo.notify_waiters != NULL) {\n+                if (usageInfo.notify_waiters != nullptr) {\n@@ -183,1 +183,1 @@\n-        if (threadList[i].name != NULL) {\n+        if (threadList[i].name != nullptr) {\n@@ -231,1 +231,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -243,1 +243,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -254,1 +254,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/contention\/TC03\/tc03t001\/tc03t001.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-static threadDesc *threadList = NULL;\n+static threadDesc *threadList = nullptr;\n@@ -51,2 +51,2 @@\n-    jobject monitor = NULL;\n-    jclass klass = NULL;\n+    jobject monitor = nullptr;\n+    jclass klass = nullptr;\n@@ -63,2 +63,2 @@\n-        if (monitor != NULL) {\n-            if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(monitor)) != NULL))\n+        if (monitor != nullptr) {\n+            if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(monitor)) != nullptr))\n@@ -66,1 +66,1 @@\n-            if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(klass, &name, NULL)))\n+            if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(klass, &name, nullptr)))\n@@ -75,1 +75,1 @@\n-        if (usageInfo.owner == NULL)\n+        if (usageInfo.owner == nullptr)\n@@ -81,1 +81,1 @@\n-        if (usageInfo.waiters != NULL) {\n+        if (usageInfo.waiters != nullptr) {\n@@ -84,1 +84,1 @@\n-        if (usageInfo.notify_waiters != NULL) {\n+        if (usageInfo.notify_waiters != nullptr) {\n@@ -100,2 +100,2 @@\n-    jthread *threads = NULL;\n-    jobject monitor = NULL;\n+    jthread *threads = nullptr;\n+    jobject monitor = nullptr;\n@@ -113,1 +113,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -121,1 +121,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -147,1 +147,1 @@\n-                if (monitor == NULL)\n+                if (monitor == nullptr)\n@@ -151,1 +151,1 @@\n-                if (usageInfo.owner == NULL)\n+                if (usageInfo.owner == nullptr)\n@@ -157,1 +157,1 @@\n-                if (usageInfo.waiters != NULL) {\n+                if (usageInfo.waiters != nullptr) {\n@@ -160,1 +160,1 @@\n-                if (usageInfo.notify_waiters != NULL) {\n+                if (usageInfo.notify_waiters != nullptr) {\n@@ -183,1 +183,1 @@\n-        if (threadList[i].name != NULL) {\n+        if (threadList[i].name != nullptr) {\n@@ -231,1 +231,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -243,1 +243,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -254,1 +254,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/contention\/TC03\/tc03t002\/tc03t002.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jclass object_M = NULL;\n+static jclass object_M = nullptr;\n@@ -43,1 +43,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -65,1 +65,1 @@\n-    if (!NSK_VERIFY(thr != NULL)) {\n+    if (!NSK_VERIFY(thr != nullptr)) {\n@@ -70,1 +70,1 @@\n-    if (!NSK_VERIFY(obj != NULL)) {\n+    if (!NSK_VERIFY(obj != nullptr)) {\n@@ -88,1 +88,1 @@\n-    if (!NSK_VERIFY(thr != NULL)) {\n+    if (!NSK_VERIFY(thr != nullptr)) {\n@@ -93,1 +93,1 @@\n-    if (!NSK_VERIFY(obj != NULL)) {\n+    if (!NSK_VERIFY(obj != nullptr)) {\n@@ -110,1 +110,1 @@\n-    if (!NSK_VERIFY(thr != NULL)) {\n+    if (!NSK_VERIFY(thr != nullptr)) {\n@@ -115,1 +115,1 @@\n-    if (!NSK_VERIFY(obj != NULL)) {\n+    if (!NSK_VERIFY(obj != nullptr)) {\n@@ -132,1 +132,1 @@\n-    if (!NSK_VERIFY(thr != NULL)) {\n+    if (!NSK_VERIFY(thr != nullptr)) {\n@@ -137,1 +137,1 @@\n-    if (!NSK_VERIFY(obj != NULL)) {\n+    if (!NSK_VERIFY(obj != nullptr)) {\n@@ -158,1 +158,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (object_M = jni->FindClass(CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (object_M = jni->FindClass(CLASS_NAME)) != nullptr))\n@@ -161,1 +161,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (object_M = (jclass)jni->NewGlobalRef(object_M)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (object_M = (jclass)jni->NewGlobalRef(object_M)) != nullptr))\n@@ -169,1 +169,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, nullptr)))\n@@ -174,1 +174,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, nullptr)))\n@@ -180,1 +180,1 @@\n-                JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL)))\n+                JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, nullptr)))\n@@ -186,1 +186,1 @@\n-                JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL)))\n+                JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, nullptr)))\n@@ -196,1 +196,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAIT, nullptr)))\n@@ -201,1 +201,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAITED, nullptr)))\n@@ -207,1 +207,1 @@\n-                JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL)))\n+                JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, nullptr)))\n@@ -213,1 +213,1 @@\n-                JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL)))\n+                JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, nullptr)))\n@@ -299,1 +299,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -312,1 +312,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -332,1 +332,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/contention\/TC04\/tc04t001\/tc04t001.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,2 @@\n-static jthread thread = NULL;\n-static jobject object_M = NULL;\n+static jthread thread = nullptr;\n+static jobject object_M = nullptr;\n@@ -68,1 +68,1 @@\n-    if (!NSK_VERIFY(thr != NULL)) {\n+    if (!NSK_VERIFY(thr != nullptr)) {\n@@ -73,1 +73,1 @@\n-    if (!NSK_VERIFY(obj != NULL)) {\n+    if (!NSK_VERIFY(obj != nullptr)) {\n@@ -107,1 +107,1 @@\n-    if (!NSK_VERIFY(thr != NULL)) {\n+    if (!NSK_VERIFY(thr != nullptr)) {\n@@ -112,1 +112,1 @@\n-    if (!NSK_VERIFY(obj != NULL)) {\n+    if (!NSK_VERIFY(obj != nullptr)) {\n@@ -143,1 +143,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -145,2 +145,2 @@\n-    jfieldID field = NULL;\n-    jclass klass = NULL;\n+    jfieldID field = nullptr;\n+    jclass klass = nullptr;\n@@ -155,1 +155,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -160,1 +160,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -170,1 +170,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -174,1 +174,1 @@\n-        if (info.name != NULL) {\n+        if (info.name != nullptr) {\n@@ -184,1 +184,1 @@\n-    if (thread == NULL) {\n+    if (thread == nullptr) {\n@@ -190,1 +190,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != nullptr))\n@@ -194,1 +194,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -198,1 +198,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"M\", FIELD_SIG)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"M\", FIELD_SIG)) != nullptr))\n@@ -201,1 +201,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (object_M = jni->GetObjectField(thread, field)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (object_M = jni->GetObjectField(thread, field)) != nullptr))\n@@ -205,1 +205,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (object_M = jni->NewGlobalRef(object_M)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (object_M = jni->NewGlobalRef(object_M)) != nullptr))\n@@ -210,1 +210,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, nullptr)))\n@@ -215,1 +215,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, nullptr)))\n@@ -225,1 +225,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAIT, nullptr)))\n@@ -230,1 +230,1 @@\n-            jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)))\n+            jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAITED, nullptr)))\n@@ -313,1 +313,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -326,1 +326,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -343,1 +343,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/contention\/TC05\/tc05t001\/tc05t001.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -40,1 +40,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -130,1 +130,1 @@\n-    if (generic != NULL)\n+    if (generic != nullptr)\n@@ -181,1 +181,1 @@\n-    if (generic != NULL)\n+    if (generic != nullptr)\n@@ -285,1 +285,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(enable, event, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(enable, event, nullptr))) {\n@@ -430,1 +430,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -455,1 +455,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM01\/em01t001\/em01t001.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -40,1 +40,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -190,1 +190,1 @@\n-    if (generic != NULL)\n+    if (generic != nullptr)\n@@ -242,1 +242,1 @@\n-    if (generic != NULL)\n+    if (generic != nullptr)\n@@ -353,1 +353,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(enable, event, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(enable, event, nullptr))) {\n@@ -497,1 +497,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -522,1 +522,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM01\/em01t002\/em01t002.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -40,1 +40,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -51,4 +51,4 @@\n-static jthread mainThread = NULL;\n-static jthread debuggeeThread = NULL;\n-static jobject startObject = NULL;\n-static jobject endObject = NULL;\n+static jthread mainThread = nullptr;\n+static jthread debuggeeThread = nullptr;\n+static jobject startObject = nullptr;\n+static jobject endObject = nullptr;\n@@ -66,1 +66,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -68,1 +68,1 @@\n-    jthread returnValue = NULL;\n+    jthread returnValue = nullptr;\n@@ -73,1 +73,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -75,2 +75,2 @@\n-    if (!NSK_VERIFY(threads != NULL))\n-        return NULL;\n+    if (!NSK_VERIFY(threads != nullptr))\n+        return nullptr;\n@@ -80,1 +80,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -88,1 +88,1 @@\n-        if (info.name != NULL && (strcmp(info.name, threadName) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, threadName) == 0)) {\n@@ -95,1 +95,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -108,1 +108,1 @@\n-    jclass klass = NULL;\n+    jclass klass = nullptr;\n@@ -121,1 +121,1 @@\n-    if (!NSK_VERIFY(mainThread != NULL)) {\n+    if (!NSK_VERIFY(mainThread != nullptr)) {\n@@ -129,1 +129,1 @@\n-    if (!NSK_VERIFY(startObject != NULL))\n+    if (!NSK_VERIFY(startObject != nullptr))\n@@ -136,1 +136,1 @@\n-    if (!NSK_VERIFY(endObject != NULL))\n+    if (!NSK_VERIFY(endObject != nullptr))\n@@ -145,1 +145,1 @@\n-    if (!NSK_VERIFY(debuggeeThread != NULL))\n+    if (!NSK_VERIFY(debuggeeThread != nullptr))\n@@ -161,1 +161,1 @@\n-                JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL)))\n+                JVMTI_DISABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, nullptr)))\n@@ -170,4 +170,4 @@\n-    startObject = NULL;\n-    endObject = NULL;\n-    debuggeeThread = NULL;\n-    mainThread = NULL;\n+    startObject = nullptr;\n+    endObject = nullptr;\n+    debuggeeThread = nullptr;\n+    mainThread = nullptr;\n@@ -399,1 +399,1 @@\n-    if (expectedThread == NULL || expectedObject == NULL)\n+    if (expectedThread == nullptr || expectedObject == nullptr)\n@@ -486,1 +486,1 @@\n-    if (expectedThread == NULL || expectedObject == NULL)\n+    if (expectedThread == nullptr || expectedObject == nullptr)\n@@ -556,1 +556,1 @@\n-                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -562,1 +562,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -746,1 +746,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -773,1 +773,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t001\/em02t001.cpp","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -38,1 +38,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -347,1 +347,1 @@\n-                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -353,1 +353,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -512,1 +512,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -539,1 +539,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t002\/em02t002.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -38,1 +38,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -283,1 +283,1 @@\n-    if (genc != NULL)\n+    if (genc != nullptr)\n@@ -349,1 +349,1 @@\n-    if (genc != NULL)\n+    if (genc != nullptr)\n@@ -381,1 +381,1 @@\n-                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -387,1 +387,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -551,1 +551,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -578,1 +578,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t003\/em02t003.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -38,1 +38,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -337,1 +337,1 @@\n-    if (genc != NULL)\n+    if (genc != nullptr)\n@@ -377,1 +377,1 @@\n-    if (genc != NULL)\n+    if (genc != nullptr)\n@@ -390,1 +390,1 @@\n-                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -396,1 +396,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -557,1 +557,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -584,1 +584,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t004\/em02t004.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -38,1 +38,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -329,1 +329,1 @@\n-    if (gen_ptr != NULL)\n+    if (gen_ptr != nullptr)\n@@ -369,1 +369,1 @@\n-    if (gen_ptr != NULL)\n+    if (gen_ptr != nullptr)\n@@ -382,1 +382,1 @@\n-                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -388,1 +388,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -537,1 +537,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -563,1 +563,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t005\/em02t005.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -38,1 +38,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -331,1 +331,1 @@\n-                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -337,1 +337,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -488,1 +488,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -514,1 +514,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t006\/em02t006.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -38,1 +38,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -203,1 +203,1 @@\n-    if (genc != NULL)\n+    if (genc != nullptr)\n@@ -233,1 +233,1 @@\n-    if (genc != NULL)\n+    if (genc != nullptr)\n@@ -360,1 +360,1 @@\n-                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -366,1 +366,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -524,1 +524,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -549,1 +549,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t007\/em02t007.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -38,1 +38,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -380,1 +380,1 @@\n-                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -386,1 +386,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -536,1 +536,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -561,1 +561,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t008\/em02t008.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -38,1 +38,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -246,1 +246,1 @@\n-    if (genc != NULL)\n+    if (genc != nullptr)\n@@ -288,1 +288,1 @@\n-    if (genc != NULL)\n+    if (genc != nullptr)\n@@ -387,1 +387,1 @@\n-                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -393,1 +393,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -543,1 +543,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -569,1 +569,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t009\/em02t009.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -39,1 +39,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -343,1 +343,1 @@\n-                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -349,1 +349,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -519,1 +519,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -545,1 +545,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t010\/em02t010.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -39,1 +39,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -329,1 +329,1 @@\n-                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -335,1 +335,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -500,1 +500,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -525,1 +525,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t011\/em02t011.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -40,1 +40,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -333,1 +333,1 @@\n-                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+                jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -339,1 +339,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -506,1 +506,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -532,1 +532,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t012\/em02t012.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -40,1 +40,1 @@\n-const void *plist = NULL;\n+const void *plist = nullptr;\n@@ -51,1 +51,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -125,1 +125,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(enable, event, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(enable, event, nullptr))) {\n@@ -215,1 +215,1 @@\n-    if (!NSK_VERIFY(jvmti != NULL))\n+    if (!NSK_VERIFY(jvmti != nullptr))\n@@ -224,1 +224,1 @@\n-    if (!NSK_VERIFY(plist != NULL))\n+    if (!NSK_VERIFY(plist != nullptr))\n@@ -239,1 +239,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM04\/em04t001\/em04t001.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -68,2 +68,2 @@\n-    { \"javaMethod\", \"(I)I\", NULL, 0, 0, 0 },\n-    { \"nativeMethod\", \"(I)I\", NULL, 0, 0, 0 }\n+    { \"javaMethod\", \"(I)I\", nullptr, 0, 0, 0 },\n+    { \"nativeMethod\", \"(I)I\", nullptr, 0, 0, 0 }\n@@ -130,1 +130,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(enable, eventsList[i], NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(enable, eventsList[i], nullptr))) {\n@@ -145,4 +145,4 @@\n-    jclass debugeeClass = NULL;\n-    jclass threadClass = NULL;\n-    jfieldID threadFieldID = NULL;\n-    jthread thread = NULL;\n+    jclass debugeeClass = nullptr;\n+    jclass threadClass = nullptr;\n+    jfieldID threadFieldID = nullptr;\n+    jthread thread = nullptr;\n@@ -152,1 +152,1 @@\n-        methodsDesc[i].method = (jmethodID)NULL;\n+        methodsDesc[i].method = (jmethodID)nullptr;\n@@ -157,1 +157,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr))\n@@ -161,1 +161,1 @@\n-            jni->GetStaticFieldID(debugeeClass, THREAD_FIELD_NAME, THREAD_FIELD_SIG)) != NULL))\n+            jni->GetStaticFieldID(debugeeClass, THREAD_FIELD_NAME, THREAD_FIELD_SIG)) != nullptr))\n@@ -165,1 +165,1 @@\n-            jni->GetStaticObjectField(debugeeClass, threadFieldID)) != NULL))\n+            jni->GetStaticObjectField(debugeeClass, threadFieldID)) != nullptr))\n@@ -168,1 +168,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (threadClass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (threadClass = jni->GetObjectClass(thread)) != nullptr))\n@@ -174,1 +174,1 @@\n-                jni->GetMethodID(threadClass, methodsDesc[i].methodName, methodsDesc[i].methodSig)) != NULL))\n+                jni->GetMethodID(threadClass, methodsDesc[i].methodName, methodsDesc[i].methodSig)) != nullptr))\n@@ -181,1 +181,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL))\n+    if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -223,1 +223,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL))\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -317,1 +317,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -337,1 +337,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM05\/em05t001\/em05t001.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -74,2 +74,2 @@\n-    { \"javaMethod\", \"(I)I\", NULL, 0, {}, {} },\n-    { \"nativeMethod\", \"(I)I\", NULL, 0, {}, {} }\n+    { \"javaMethod\", \"(I)I\", nullptr, 0, {}, {} },\n+    { \"nativeMethod\", \"(I)I\", nullptr, 0, {}, {} }\n@@ -169,4 +169,4 @@\n-    jclass debugeeClass = NULL;\n-    jclass threadClass = NULL;\n-    jfieldID threadFieldID = NULL;\n-    jthread thread = NULL;\n+    jclass debugeeClass = nullptr;\n+    jclass threadClass = nullptr;\n+    jfieldID threadFieldID = nullptr;\n+    jthread thread = nullptr;\n@@ -177,1 +177,1 @@\n-        methodsDesc[i].method = (jmethodID)NULL;\n+        methodsDesc[i].method = (jmethodID)nullptr;\n@@ -185,1 +185,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr))\n@@ -189,1 +189,1 @@\n-            jni->GetStaticFieldID(debugeeClass, THREAD_FIELD_NAME, THREAD_FIELD_SIG)) != NULL))\n+            jni->GetStaticFieldID(debugeeClass, THREAD_FIELD_NAME, THREAD_FIELD_SIG)) != nullptr))\n@@ -193,1 +193,1 @@\n-            jni->GetStaticObjectField(debugeeClass, threadFieldID)) != NULL))\n+            jni->GetStaticObjectField(debugeeClass, threadFieldID)) != nullptr))\n@@ -196,1 +196,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (threadClass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (threadClass = jni->GetObjectClass(thread)) != nullptr))\n@@ -202,1 +202,1 @@\n-                jni->GetMethodID(threadClass, methodsDesc[i].methodName, methodsDesc[i].methodSig)) != NULL))\n+                jni->GetMethodID(threadClass, methodsDesc[i].methodName, methodsDesc[i].methodSig)) != nullptr))\n@@ -209,1 +209,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL))\n+    if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -285,1 +285,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL))\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -386,1 +386,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -406,1 +406,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM05\/em05t002\/em05t002.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -39,1 +39,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -63,1 +63,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (classObject = jni_env->GetObjectClass(klass)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni_env, (classObject = jni_env->GetObjectClass(klass)) != nullptr)) {\n@@ -69,1 +69,1 @@\n-            jni_env->GetMethodID(classObject, \"getName\", \"()Ljava\/lang\/String;\")) != NULL)) {\n+            jni_env->GetMethodID(classObject, \"getName\", \"()Ljava\/lang\/String;\")) != nullptr)) {\n@@ -78,1 +78,1 @@\n-    if (className != NULL && (strcmp(className, EXPECTED_CLASS_NAME) == 0)) {\n+    if (className != nullptr && (strcmp(className, EXPECTED_CLASS_NAME) == 0)) {\n@@ -117,1 +117,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(enable, event, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(enable, event, nullptr))) {\n@@ -252,1 +252,1 @@\n-    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -255,1 +255,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM06\/em06t001\/em06t001.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n-static jvmtiEnv *jvmti = NULL;\n-static jrawMonitorID syncLock = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n+static jrawMonitorID syncLock = nullptr;\n@@ -236,1 +236,1 @@\n-                    jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, NULL))) {\n+                    jvmti->SetEventNotificationMode(JVMTI_ENABLE, event, nullptr))) {\n@@ -358,1 +358,1 @@\n-    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -376,1 +376,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM07\/em07t001\/em07t001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -40,1 +40,1 @@\n-static jrawMonitorID syncLock = NULL;\n+static jrawMonitorID syncLock = nullptr;\n@@ -46,1 +46,1 @@\n-const void *plist = NULL;\n+const void *plist = nullptr;\n@@ -112,1 +112,1 @@\n-    if (genc != NULL)\n+    if (genc != nullptr)\n@@ -158,1 +158,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(enable, event, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(enable, event, nullptr))) {\n@@ -267,1 +267,1 @@\n-    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -275,1 +275,1 @@\n-    if (!NSK_VERIFY((plist = (const void *)nsk_list_create()) != NULL))\n+    if (!NSK_VERIFY((plist = (const void *)nsk_list_create()) != nullptr))\n@@ -296,1 +296,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM07\/em07t002\/em07t002.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n-static JNIEnv *jni = NULL;\n-static jvmtiEnv* jvmti = NULL;\n+static JNIEnv *jni = nullptr;\n+static jvmtiEnv* jvmti = nullptr;\n@@ -45,1 +45,1 @@\n-    JNIEnv *jni_env = NULL;\n+    JNIEnv *jni_env = nullptr;\n@@ -54,1 +54,1 @@\n-    if (name == NULL) {\n+    if (name == nullptr) {\n@@ -56,1 +56,1 @@\n-        NSK_COMPLAIN0(\"ClassUnload: 'name' input parameter is NULL.\\n\");\n+        NSK_COMPLAIN0(\"ClassUnload: 'name' input parameter is null.\\n\");\n@@ -155,1 +155,1 @@\n-                                                     enable ? (jvmtiExtensionEvent)ClassUnload : NULL))) {\n+                                                     enable ? (jvmtiExtensionEvent)ClassUnload : nullptr))) {\n@@ -160,1 +160,1 @@\n-                    jvmti->SetEventNotificationMode(mode, (jvmtiEvent)extList[i].extension_event_index, NULL))) {\n+                    jvmti->SetEventNotificationMode(mode, (jvmtiEvent)extList[i].extension_event_index, nullptr))) {\n@@ -284,1 +284,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -291,1 +291,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/extension\/EX03\/ex03t001\/ex03t001.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,1 +175,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -188,1 +188,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr)))\n@@ -190,1 +190,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/general_functions\/GF01\/gf01t001\/gf01t001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-static const char* segment = NULL;\n+static const char* segment = nullptr;\n@@ -52,1 +52,1 @@\n-    void* storage = NULL;\n+    void* storage = nullptr;\n@@ -100,1 +100,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_LOAD, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_LOAD, nullptr))) {\n@@ -126,1 +126,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_PREPARE, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_PREPARE, nullptr))) {\n@@ -151,1 +151,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -158,2 +158,2 @@\n-    segment = nsk_jvmti_findOptionStringValue(\"segment\", NULL);\n-    if (!NSK_VERIFY(segment != NULL))\n+    segment = nsk_jvmti_findOptionStringValue(\"segment\", nullptr);\n+    if (!NSK_VERIFY(segment != nullptr))\n@@ -163,1 +163,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -189,1 +189,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, nullptr))) {\n@@ -194,1 +194,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, nullptr))) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/general_functions\/GF04\/gf04t001\/gf04t001.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-    void* storage = NULL;\n+    void* storage = nullptr;\n@@ -83,2 +83,2 @@\n-    if (storage != NULL) {\n-        NSK_COMPLAIN2(\"GetEnvironmentLocalStorage() returned NOT NULL storage in %s:\\n\"\n+    if (storage != nullptr) {\n+        NSK_COMPLAIN2(\"GetEnvironmentLocalStorage() returned NOT null storage in %s:\\n\"\n@@ -137,1 +137,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -152,1 +152,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, NULL)) {\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, events, nullptr)) {\n@@ -180,1 +180,1 @@\n-    jvmtiEnv* jvmti_1 = NULL;\n+    jvmtiEnv* jvmti_1 = nullptr;\n@@ -202,1 +202,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -229,1 +229,1 @@\n-    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, NULL)) {\n+    if (nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, events, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/general_functions\/GF06\/gf06t001\/gf06t001.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-static const char* setVerboseMode = NULL;\n+static const char* setVerboseMode = nullptr;\n@@ -57,1 +57,1 @@\n-    jvmtiEnv *jvmti = NULL;\n+    jvmtiEnv *jvmti = nullptr;\n@@ -67,1 +67,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -70,1 +70,1 @@\n-    setVerboseMode = nsk_jvmti_findOptionStringValue(\"setVerboseMode\", NULL);\n+    setVerboseMode = nsk_jvmti_findOptionStringValue(\"setVerboseMode\", nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/general_functions\/GF08\/gf08t001\/gf08t001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-static const char* setVerboseMode = NULL;\n+static const char* setVerboseMode = nullptr;\n@@ -57,1 +57,1 @@\n-    jvmtiEnv *jvmti = NULL;\n+    jvmtiEnv *jvmti = nullptr;\n@@ -67,1 +67,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -70,1 +70,1 @@\n-    setVerboseMode = nsk_jvmti_findOptionStringValue(\"setVerboseMode\", NULL);\n+    setVerboseMode = nsk_jvmti_findOptionStringValue(\"setVerboseMode\", nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/general_functions\/GF08\/gf08t002\/gf08t002.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-static const char* setVerboseMode = NULL;\n+static const char* setVerboseMode = nullptr;\n@@ -57,1 +57,1 @@\n-    jvmtiEnv *jvmti = NULL;\n+    jvmtiEnv *jvmti = nullptr;\n@@ -67,1 +67,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -70,1 +70,1 @@\n-    setVerboseMode = nsk_jvmti_findOptionStringValue(\"setVerboseMode\", NULL);\n+    setVerboseMode = nsk_jvmti_findOptionStringValue(\"setVerboseMode\", nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/general_functions\/GF08\/gf08t003\/gf08t003.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    setRedefinitionFailed = jni->GetStaticMethodID(testClass, \"setRedefinitionFailed\", \"()V\")) != NULL))\n+    setRedefinitionFailed = jni->GetStaticMethodID(testClass, \"setRedefinitionFailed\", \"()V\")) != nullptr))\n@@ -66,1 +66,1 @@\n-    setRedefinitionDone = jni->GetStaticMethodID(testClass, \"setRedefinitionDone\", \"()V\")) != NULL))\n+    setRedefinitionDone = jni->GetStaticMethodID(testClass, \"setRedefinitionDone\", \"()V\")) != nullptr))\n@@ -145,1 +145,1 @@\n-  if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(clas, \"<init>\", \"(Ljava\/lang\/String;)V\")) != NULL)) {\n+  if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(clas, \"<init>\", \"(Ljava\/lang\/String;)V\")) != nullptr)) {\n@@ -152,1 +152,1 @@\n-  err = jvmti->RunAgentThread(testAgentThread, &doRedefineInNativeThread, NULL,\n+  err = jvmti->RunAgentThread(testAgentThread, &doRedefineInNativeThread, nullptr,\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS103\/hs103t002\/hs103t002.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-            if (nsk_jvmti_disableNotification(jvmti,JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+            if (nsk_jvmti_disableNotification(jvmti,JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n@@ -99,1 +99,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS104\/hs104t001\/hs104t001.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cla = jni->FindClass(SEARCH_NAME)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (cla = jni->FindClass(SEARCH_NAME)) != nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS104\/hs104t002\/hs104t002.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -67,1 +67,1 @@\n-            jni_env->GetStaticFieldID(testClass, \"currentStep\", \"I\")) != NULL)) {\n+            jni_env->GetStaticFieldID(testClass, \"currentStep\", \"I\")) != nullptr)) {\n@@ -105,1 +105,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, nullptr))) {\n@@ -168,1 +168,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (mid = jni_env->GetMethodID(klass, METHOD_NAME, METHOD_SIG)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni_env, (mid = jni_env->GetMethodID(klass, METHOD_NAME, METHOD_SIG)) != nullptr))\n@@ -203,1 +203,1 @@\n-    if (generic != NULL)\n+    if (generic != nullptr)\n@@ -235,1 +235,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &methodName, NULL, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &methodName, nullptr, nullptr))) {\n@@ -247,1 +247,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(declaringClass, &declaringClassName, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(declaringClass, &declaringClassName, nullptr))) {\n@@ -338,1 +338,1 @@\n-        if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != NULL)) {\n+        if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != nullptr)) {\n@@ -369,1 +369,1 @@\n-        if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != NULL)) {\n+        if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != nullptr)) {\n@@ -400,1 +400,1 @@\n-    if (bytecode == NULL) {\n+    if (bytecode == nullptr) {\n@@ -433,1 +433,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(thread)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(thread)) != nullptr)) {\n@@ -439,1 +439,1 @@\n-            jni_env->GetMethodID(klass, \"getName\", \"()Ljava\/lang\/String;\")) != NULL)) {\n+            jni_env->GetMethodID(klass, \"getName\", \"()Ljava\/lang\/String;\")) != nullptr)) {\n@@ -465,1 +465,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(object)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(object)) != nullptr)) {\n@@ -481,1 +481,1 @@\n-    if (generic != NULL)\n+    if (generic != nullptr)\n@@ -494,1 +494,1 @@\n-    jvmtiLocalVariableEntry *table = NULL;\n+    jvmtiLocalVariableEntry *table = nullptr;\n@@ -504,1 +504,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -543,1 +543,1 @@\n-    if (!NSK_JNI_VERIFY(env, (testClass = (jclass) env->NewGlobalRef(cls)) != NULL))\n+    if (!NSK_JNI_VERIFY(env, (testClass = (jclass) env->NewGlobalRef(cls)) != nullptr))\n@@ -546,1 +546,1 @@\n-    if (!NSK_JNI_VERIFY(env, (testedThread = env->NewGlobalRef(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(env, (testedThread = env->NewGlobalRef(thread)) != nullptr))\n@@ -635,1 +635,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -673,1 +673,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t001\/hs201t001.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -69,1 +69,1 @@\n-            jni_env->GetStaticFieldID(testClass, \"currentStep\", \"I\")) != NULL)) {\n+            jni_env->GetStaticFieldID(testClass, \"currentStep\", \"I\")) != nullptr)) {\n@@ -108,1 +108,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, nullptr))) {\n@@ -173,1 +173,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (mid = jni_env->GetMethodID(klass, METHOD_NAME, METHOD_SIG)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni_env, (mid = jni_env->GetMethodID(klass, METHOD_NAME, METHOD_SIG)) != nullptr))\n@@ -192,1 +192,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, nullptr))) {\n@@ -233,1 +233,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &methodName, NULL, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &methodName, nullptr, nullptr))) {\n@@ -245,1 +245,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(declaringClass, &declaringClassName, NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(declaringClass, &declaringClassName, nullptr))) {\n@@ -350,1 +350,1 @@\n-    if (className != NULL && strcmp(EXPECTED_CLASS_SIGN, className) == 0) {\n+    if (className != nullptr && strcmp(EXPECTED_CLASS_SIGN, className) == 0) {\n@@ -355,1 +355,1 @@\n-            className, threadName != NULL ? threadName : \"NULL\");\n+            className, threadName != nullptr ? threadName : \"null\");\n@@ -357,1 +357,1 @@\n-        if (threadName != NULL) {\n+        if (threadName != nullptr) {\n@@ -362,1 +362,1 @@\n-        if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != NULL)) {\n+        if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != nullptr)) {\n@@ -393,1 +393,1 @@\n-    if (bytecode == NULL) {\n+    if (bytecode == nullptr) {\n@@ -411,1 +411,1 @@\n-        *newClassBytes = NULL;\n+        *newClassBytes = nullptr;\n@@ -425,1 +425,1 @@\n-    unsigned char *result = NULL;\n+    unsigned char *result = nullptr;\n@@ -428,1 +428,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(thread)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(thread)) != nullptr)) {\n@@ -430,1 +430,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -434,1 +434,1 @@\n-            jni_env->GetMethodID(klass, \"getName\", \"()Ljava\/lang\/String;\")) != NULL)) {\n+            jni_env->GetMethodID(klass, \"getName\", \"()Ljava\/lang\/String;\")) != nullptr)) {\n@@ -436,1 +436,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -445,1 +445,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -464,1 +464,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(object)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(object)) != nullptr)) {\n@@ -466,1 +466,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -469,1 +469,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, nullptr))) {\n@@ -471,1 +471,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -482,1 +482,1 @@\n-    jvmtiLocalVariableEntry *table = NULL;\n+    jvmtiLocalVariableEntry *table = nullptr;\n@@ -492,1 +492,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -531,1 +531,1 @@\n-    if (!NSK_JNI_VERIFY(env, (testClass = (jclass) env->NewGlobalRef(cls)) != NULL))\n+    if (!NSK_JNI_VERIFY(env, (testClass = (jclass) env->NewGlobalRef(cls)) != nullptr))\n@@ -534,1 +534,1 @@\n-    if (!NSK_JNI_VERIFY(env, (testedThread = env->NewGlobalRef(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(env, (testedThread = env->NewGlobalRef(thread)) != nullptr))\n@@ -627,1 +627,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -660,1 +660,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t002\/hs201t002.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -77,1 +77,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &sig, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &sig, nullptr))) {\n@@ -110,1 +110,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(decl_cls, &cls_sig, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(decl_cls, &cls_sig, nullptr))) {\n@@ -146,1 +146,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(tMethodID, &name, &sig, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(tMethodID, &name, &sig, nullptr))) {\n@@ -199,1 +199,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_ENTRY, NULL)))\n+        if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_ENTRY, nullptr)))\n@@ -301,1 +301,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -327,1 +327,1 @@\n-            eventsList, NULL))\n+            eventsList, nullptr))\n@@ -333,1 +333,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS201\/hs201t003\/hs201t003.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-        if (method == NULL) {\n+        if (method == nullptr) {\n@@ -76,1 +76,1 @@\n-                    if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_BREAKPOINT, NULL)) {\n+                    if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_BREAKPOINT, nullptr)) {\n@@ -119,1 +119,1 @@\n-    if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_SINGLE_STEP, NULL)) {\n+    if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_SINGLE_STEP, nullptr)) {\n@@ -123,1 +123,1 @@\n-            JVMTI_EVENT_BREAKPOINT, NULL);\n+            JVMTI_EVENT_BREAKPOINT, nullptr);\n@@ -175,1 +175,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS202\/hs202t001\/hs202t001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-static jvmtiEnv * jvmti = NULL;\n+static jvmtiEnv * jvmti = nullptr;\n@@ -122,1 +122,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_METHOD_EXIT, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_METHOD_EXIT, nullptr)) {\n@@ -163,1 +163,1 @@\n-    if (nsk_jvmti_disableNotification(jvmti,JVMTI_EVENT_METHOD_EXIT, NULL)) {\n+    if (nsk_jvmti_disableNotification(jvmti,JVMTI_EVENT_METHOD_EXIT, nullptr)) {\n@@ -197,1 +197,1 @@\n-    \/\/ No errors possible here: thread is valid, and state is not NULL\n+    \/\/ No errors possible here: thread is valid, and state is not nullptr\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS202\/hs202t002\/hs202t002.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-            if (method != NULL) {\n+            if (method != nullptr) {\n@@ -169,2 +169,2 @@\n-        if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_LOAD, NULL) &&\n-                nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_BREAKPOINT,NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_LOAD, nullptr) &&\n+                nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_BREAKPOINT,nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS203\/hs203t001\/hs203t001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-        if (method != NULL) {\n+        if (method != nullptr) {\n@@ -171,2 +171,2 @@\n-        if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_LOAD, NULL) &&\n-                nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_BREAKPOINT, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_LOAD, nullptr) &&\n+                nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_BREAKPOINT, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS203\/hs203t002\/hs203t002.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,2 +61,2 @@\n-    className=NULL;\n-    generic=NULL;\n+    className=nullptr;\n+    generic=nullptr;\n@@ -70,1 +70,1 @@\n-            if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, FIELDNAME, TYPE)) != NULL)) {\n+            if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, FIELDNAME, TYPE)) != nullptr)) {\n@@ -96,1 +96,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (clas = jni->FindClass(SEARCH_NAME)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (clas = jni->FindClass(SEARCH_NAME)) != nullptr)) {\n@@ -158,2 +158,2 @@\n-        if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_PREPARE, NULL) &&\n-                nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_FIELD_ACCESS, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_PREPARE, nullptr) &&\n+                nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_FIELD_ACCESS, nullptr)) {\n@@ -205,1 +205,1 @@\n-                        jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FIELD_ACCESS, NULL))) {\n+                        jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FIELD_ACCESS, nullptr))) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS203\/hs203t003\/hs203t003.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    className=NULL;\n+    className=nullptr;\n@@ -48,1 +48,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &className, nullptr))) {\n@@ -53,1 +53,1 @@\n-            if (nsk_jvmti_enableNotification(jvmti_env, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL)) {\n+            if (nsk_jvmti_enableNotification(jvmti_env, JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr)) {\n@@ -86,2 +86,2 @@\n-            className = NULL;\n-            methodName = NULL;\n+            className = nullptr;\n+            methodName = nullptr;\n@@ -89,1 +89,1 @@\n-            if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(threadClass, &className, NULL))) {\n+            if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(threadClass, &className, nullptr))) {\n@@ -95,1 +95,1 @@\n-            if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &methodName, NULL, NULL))) {\n+            if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &methodName, nullptr, nullptr))) {\n@@ -118,1 +118,1 @@\n-            if (className != NULL) {\n+            if (className != nullptr) {\n@@ -124,1 +124,1 @@\n-            if (methodName != NULL) {\n+            if (methodName != nullptr) {\n@@ -174,1 +174,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n@@ -217,1 +217,1 @@\n-                                                        JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL))) {\n+                                                        JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr))) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS203\/hs203t004\/hs203t004.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-        if (cls == NULL) {\n+        if (cls == nullptr) {\n@@ -65,1 +65,1 @@\n-            if (method == NULL) {\n+            if (method == nullptr) {\n@@ -161,2 +161,2 @@\n-        nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE , NULL);\n-        nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_BREAKPOINT, NULL);\n+        nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE , nullptr);\n+        nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS204\/hs204t002\/hs204t002.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-    className = NULL;\n-    generic   = NULL;\n+    className = nullptr;\n+    generic   = nullptr;\n@@ -60,1 +60,1 @@\n-            if (!NSK_JNI_VERIFY(jni, (fieldId = jni->GetStaticFieldID(klass, FIELDNAME, TYPE)) != NULL)) {\n+            if (!NSK_JNI_VERIFY(jni, (fieldId = jni->GetStaticFieldID(klass, FIELDNAME, TYPE)) != nullptr)) {\n@@ -68,2 +68,2 @@\n-                    nsk_jvmti_enableNotification(jvmti_env, JVMTI_EVENT_FIELD_ACCESS, NULL);\n-                    if (!NSK_JNI_VERIFY(jni, (watchFieldClass = (jclass) jni->NewGlobalRef(klass)) != NULL)) {\n+                    nsk_jvmti_enableNotification(jvmti_env, JVMTI_EVENT_FIELD_ACCESS, nullptr);\n+                    if (!NSK_JNI_VERIFY(jni, (watchFieldClass = (jclass) jni->NewGlobalRef(klass)) != nullptr)) {\n@@ -80,1 +80,1 @@\n-    if (className != NULL) {\n+    if (className != nullptr) {\n@@ -87,1 +87,1 @@\n-    if (generic != NULL) {\n+    if (generic != nullptr) {\n@@ -108,2 +108,2 @@\n-    className = NULL;\n-    generic   = NULL;\n+    className = nullptr;\n+    generic   = nullptr;\n@@ -142,1 +142,1 @@\n-    if (className != NULL) {\n+    if (className != nullptr) {\n@@ -149,1 +149,1 @@\n-    if (generic != NULL) {\n+    if (generic != nullptr) {\n@@ -195,1 +195,1 @@\n-        nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+        nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -222,1 +222,1 @@\n-                    if (!NSK_JNI_VERIFY(jni, fieldId != NULL)) {\n+                    if (!NSK_JNI_VERIFY(jni, fieldId != nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS204\/hs204t003\/hs204t003.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-        if (klass != NULL) {\n+        if (klass != nullptr) {\n@@ -62,1 +62,1 @@\n-            if (method != NULL) {\n+            if (method != nullptr) {\n@@ -161,2 +161,2 @@\n-          nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_LOAD, NULL);\n-          nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_BREAKPOINT, NULL);\n+          nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_CLASS_LOAD, nullptr);\n+          nsk_jvmti_enableNotification(jvmti,JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS204\/hs204t004\/hs204t004.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-    if (!NSK_JNI_VERIFY(jni, cls != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, cls != nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS301\/hs301t001\/hs301t001.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(SEARCH_NAME)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(SEARCH_NAME)) != nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS301\/hs301t002\/hs301t002.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-                  JVMTI_EVENT_CLASS_LOAD, NULL);\n+                  JVMTI_EVENT_CLASS_LOAD, nullptr);\n@@ -95,1 +95,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS301\/hs301t003\/hs301t003.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-            nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+            nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -96,1 +96,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS301\/hs301t004\/hs301t004.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-        nsk_jvmti_disableNotification(jvmti, JVMTI_EVENT_CLASS_LOAD, NULL);\n+        nsk_jvmti_disableNotification(jvmti, JVMTI_EVENT_CLASS_LOAD, nullptr);\n@@ -91,1 +91,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS301\/hs301t005\/hs301t005.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+    nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -91,1 +91,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS302\/hs302t001\/hs302t001.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-      nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+      nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -97,1 +97,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS302\/hs302t002\/hs302t002.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-      nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+      nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -96,1 +96,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS302\/hs302t003\/hs302t003.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+    nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -91,1 +91,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS302\/hs302t004\/hs302t004.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+    nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -93,1 +93,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS302\/hs302t005\/hs302t005.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-        nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+        nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -92,1 +92,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS302\/hs302t006\/hs302t006.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-        nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+        nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -89,1 +89,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS302\/hs302t007\/hs302t007.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-    nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+    nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -92,1 +92,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS302\/hs302t008\/hs302t008.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-        nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+        nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -92,1 +92,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS302\/hs302t009\/hs302t009.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-        nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+        nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -91,1 +91,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS302\/hs302t010\/hs302t010.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-        nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+        nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -92,1 +92,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS302\/hs302t011\/hs302t011.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-        nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+        nsk_jvmti_disableNotification(jvmti_env, JVMTI_EVENT_CLASS_PREPARE, nullptr);\n@@ -94,1 +94,1 @@\n-        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, NULL)) {\n+        if (nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS302\/hs302t012\/hs302t012.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -49,1 +49,1 @@\n-static jthread testThread = NULL;\n+static jthread testThread = nullptr;\n@@ -52,1 +52,1 @@\n-static jniNativeInterface *orig_jni_functions = NULL;\n+static jniNativeInterface *orig_jni_functions = nullptr;\n@@ -55,1 +55,1 @@\n-static jniNativeInterface *redir_jni_functions = NULL;\n+static jniNativeInterface *redir_jni_functions = nullptr;\n@@ -61,1 +61,1 @@\n-    jthread curThread = NULL;\n+    jthread curThread = nullptr;\n@@ -68,1 +68,1 @@\n-     testThread = NULL;\n+     testThread = nullptr;\n@@ -72,1 +72,1 @@\n-    jthread curThread = NULL;\n+    jthread curThread = nullptr;\n@@ -332,1 +332,1 @@\n-    if (!NSK_VERIFY(jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1) == JNI_OK && jvmti != NULL))\n+    if (!NSK_VERIFY(jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1) == JNI_OK && jvmti != nullptr))\n@@ -357,1 +357,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr)))\n@@ -361,1 +361,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI01\/ji01t001\/ji01t001.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -43,1 +43,1 @@\n-static jniNativeInterface *orig_jni_functions = NULL;\n+static jniNativeInterface *orig_jni_functions = nullptr;\n@@ -46,1 +46,1 @@\n-static jniNativeInterface *redir_jni_functions = NULL;\n+static jniNativeInterface *redir_jni_functions = nullptr;\n@@ -118,1 +118,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -186,1 +186,1 @@\n-    if (options != NULL && strcmp(options, \"-verbose\") == 0)\n+    if (options != nullptr && strcmp(options, \"-verbose\") == 0)\n@@ -193,1 +193,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI03\/ji03t001\/ji03t001.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -56,2 +56,2 @@\n-    { 0, \"statMeth\", \"(I)D\", NULL, \"statMeth_calls\", NULL, 0, 0 },\n-    { 1, \"voidMeth\", \"()V\", NULL, \"voidMeth_calls\", NULL, 0, 0 }\n+    { 0, \"statMeth\", \"(I)D\", nullptr, \"statMeth_calls\", nullptr, 0, 0 },\n+    { 1, \"voidMeth\", \"()V\", nullptr, \"voidMeth_calls\", nullptr, 0, 0 }\n@@ -61,1 +61,1 @@\n-static jniNativeInterface *orig_jni_functions = NULL;\n+static jniNativeInterface *orig_jni_functions = nullptr;\n@@ -64,1 +64,1 @@\n-static jniNativeInterface *redir_jni_functions = NULL;\n+static jniNativeInterface *redir_jni_functions = nullptr;\n@@ -130,1 +130,1 @@\n-        if (meth_info[i].mid == NULL) {\n+        if (meth_info[i].mid == nullptr) {\n@@ -273,1 +273,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -312,1 +312,1 @@\n-    if (options != NULL && strcmp(options, \"-verbose\") == 0)\n+    if (options != nullptr && strcmp(options, \"-verbose\") == 0)\n@@ -319,1 +319,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI03\/ji03t002\/ji03t002.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -43,1 +43,1 @@\n-static jthread testThread = NULL;\n+static jthread testThread = nullptr;\n@@ -50,1 +50,1 @@\n-static jniNativeInterface *orig_jni_functions = NULL;\n+static jniNativeInterface *orig_jni_functions = nullptr;\n@@ -53,1 +53,1 @@\n-static jniNativeInterface *redir_jni_functions = NULL;\n+static jniNativeInterface *redir_jni_functions = nullptr;\n@@ -61,1 +61,1 @@\n-    jthread curThread = NULL;\n+    jthread curThread = nullptr;\n@@ -68,1 +68,1 @@\n-     testThread = NULL;\n+     testThread = nullptr;\n@@ -72,1 +72,1 @@\n-    jthread curThread = NULL;\n+    jthread curThread = nullptr;\n@@ -293,1 +293,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -360,1 +360,1 @@\n-    if (options != NULL && strcmp(options, \"-verbose\") == 0)\n+    if (options != nullptr && strcmp(options, \"-verbose\") == 0)\n@@ -367,1 +367,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI03\/ji03t003\/ji03t003.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -47,1 +47,1 @@\n-static jniNativeInterface *orig_jni_functions = NULL;\n+static jniNativeInterface *orig_jni_functions = nullptr;\n@@ -50,1 +50,1 @@\n-static jniNativeInterface *redir_jni_functions = NULL;\n+static jniNativeInterface *redir_jni_functions = nullptr;\n@@ -137,1 +137,1 @@\n-    if (allObj == NULL) {\n+    if (allObj == nullptr) {\n@@ -153,1 +153,1 @@\n-    if (newObj == NULL) {\n+    if (newObj == nullptr) {\n@@ -211,1 +211,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -218,1 +218,1 @@\n-    if (objCls == NULL) {\n+    if (objCls == nullptr) {\n@@ -225,1 +225,1 @@\n-    if (ctorId == NULL) {\n+    if (ctorId == nullptr) {\n@@ -262,1 +262,1 @@\n-    if (options != NULL && strcmp(options, \"-verbose\") == 0)\n+    if (options != nullptr && strcmp(options, \"-verbose\") == 0)\n@@ -269,1 +269,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI03\/ji03t004\/ji03t004.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,1 +182,1 @@\n-    if (res != JNI_OK || jvmti[indx] == NULL) {\n+    if (res != JNI_OK || jvmti[indx] == nullptr) {\n@@ -210,1 +210,1 @@\n-    err = jvmti[indx]->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+    err = jvmti[indx]->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n@@ -230,1 +230,1 @@\n-    if (THREAD_start(agentThr[indx]) == NULL) {\n+    if (THREAD_start(agentThr[indx]) == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI05\/ji05t001\/ji05t001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -75,1 +75,1 @@\n-static jniNativeInterface *orig_jni_functions = NULL;\n+static jniNativeInterface *orig_jni_functions = nullptr;\n@@ -78,1 +78,1 @@\n-static jniNativeInterface *redir_jni_functions = NULL;\n+static jniNativeInterface *redir_jni_functions = nullptr;\n@@ -318,2 +318,2 @@\n-    void *ownThr = NULL;\n-    void *redirThr = NULL;\n+    void *ownThr = nullptr;\n+    void *redirThr = nullptr;\n@@ -325,1 +325,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -332,1 +332,1 @@\n-    if (clsObj == NULL) {\n+    if (clsObj == nullptr) {\n@@ -340,1 +340,1 @@\n-    if (THREAD_start(ownThr) == NULL) {\n+    if (THREAD_start(ownThr) == nullptr) {\n@@ -363,1 +363,1 @@\n-        if (THREAD_start(waitThr[i]) == NULL) {\n+        if (THREAD_start(waitThr[i]) == nullptr) {\n@@ -387,1 +387,1 @@\n-    if (THREAD_start(redirThr) == NULL) {\n+    if (THREAD_start(redirThr) == nullptr) {\n@@ -434,1 +434,1 @@\n-    if (THREAD_start(waitThr[MAX_THREADS-1]) == NULL) {\n+    if (THREAD_start(waitThr[MAX_THREADS-1]) == nullptr) {\n@@ -485,1 +485,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/jni_interception\/JI06\/ji06t001\/ji06t001.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -74,1 +74,1 @@\n-    const char* name = NULL;\n+    const char* name = nullptr;\n@@ -100,1 +100,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -103,1 +103,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA01\/ma01t001\/ma01t001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -74,1 +74,1 @@\n-    const char* name = NULL;\n+    const char* name = nullptr;\n@@ -100,1 +100,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -103,1 +103,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA01\/ma01t001\/ma01t001a.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -105,1 +105,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -108,1 +108,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -117,1 +117,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr)))\n@@ -120,1 +120,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA02\/ma02t001\/ma02t001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -105,1 +105,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -108,1 +108,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -117,1 +117,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr)))\n@@ -120,1 +120,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA02\/ma02t001\/ma02t001a.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -116,1 +116,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -119,1 +119,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -129,1 +129,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr)))\n@@ -132,1 +132,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr)))\n@@ -135,1 +135,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA03\/ma03t001\/ma03t001.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -117,1 +117,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -120,1 +120,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA03\/ma03t001\/ma03t001a.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-static jobject testedObject = NULL;\n+static jobject testedObject = nullptr;\n@@ -50,2 +50,2 @@\n-    jclass cls = NULL;\n-    jfieldID fid = NULL;\n+    jclass cls = nullptr;\n+    jfieldID fid = nullptr;\n@@ -56,1 +56,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(CLASS_NAME)) != nullptr))\n@@ -61,1 +61,1 @@\n-            jni->GetStaticFieldID(cls, FIELD_NAME, FIELD_SIGNATURE)) != NULL))\n+            jni->GetStaticFieldID(cls, FIELD_NAME, FIELD_SIGNATURE)) != nullptr))\n@@ -64,1 +64,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->GetStaticObjectField(cls, fid)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->GetStaticObjectField(cls, fid)) != nullptr))\n@@ -67,1 +67,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewGlobalRef(testedObject)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewGlobalRef(testedObject)) != nullptr))\n@@ -203,1 +203,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -215,1 +215,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -224,1 +224,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA04\/ma04t001\/ma04t001.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-static jobject testedObject = NULL;\n+static jobject testedObject = nullptr;\n@@ -50,2 +50,2 @@\n-    jclass cls = NULL;\n-    jfieldID fid = NULL;\n+    jclass cls = nullptr;\n+    jfieldID fid = nullptr;\n@@ -56,1 +56,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(CLASS_NAME)) != nullptr))\n@@ -61,1 +61,1 @@\n-            jni->GetStaticFieldID(cls, FIELD_NAME, FIELD_SIGNATURE)) != NULL))\n+            jni->GetStaticFieldID(cls, FIELD_NAME, FIELD_SIGNATURE)) != nullptr))\n@@ -64,1 +64,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->GetStaticObjectField(cls, fid)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->GetStaticObjectField(cls, fid)) != nullptr))\n@@ -67,1 +67,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewGlobalRef(testedObject)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewGlobalRef(testedObject)) != nullptr))\n@@ -203,1 +203,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -215,1 +215,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -224,1 +224,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA04\/ma04t001\/ma04t001a.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,3 +42,3 @@\n-static jobject testedObject = NULL;\n-static jobject testedInstance = NULL;\n-static jclass testedClass = NULL;\n+static jobject testedObject = nullptr;\n+static jobject testedInstance = nullptr;\n+static jclass testedClass = nullptr;\n@@ -79,1 +79,1 @@\n-    jfieldID fid = NULL;\n+    jfieldID fid = nullptr;\n@@ -84,1 +84,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedClass = jni->FindClass(CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedClass = jni->FindClass(CLASS_NAME)) != nullptr))\n@@ -87,1 +87,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass) jni->NewGlobalRef(testedClass)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass) jni->NewGlobalRef(testedClass)) != nullptr))\n@@ -92,1 +92,1 @@\n-            jni->GetStaticFieldID(testedClass, FIELD_NAME, FIELD_SIGNATURE)) != NULL))\n+            jni->GetStaticFieldID(testedClass, FIELD_NAME, FIELD_SIGNATURE)) != nullptr))\n@@ -95,1 +95,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->GetStaticObjectField(testedClass, fid)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->GetStaticObjectField(testedClass, fid)) != nullptr))\n@@ -101,1 +101,1 @@\n-            jni->GetStaticFieldID(testedClass, INSTANCE_NAME, INSTANCE_SIGNATURE)) != NULL))\n+            jni->GetStaticFieldID(testedClass, INSTANCE_NAME, INSTANCE_SIGNATURE)) != nullptr))\n@@ -105,1 +105,1 @@\n-            jni->GetStaticObjectField(testedClass, fid)) != NULL))\n+            jni->GetStaticObjectField(testedClass, fid)) != nullptr))\n@@ -308,1 +308,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -320,1 +320,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -330,1 +330,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -337,1 +337,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA04\/ma04t002\/ma04t002.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,3 +42,3 @@\n-static jobject testedObject = NULL;\n-static jobject testedInstance = NULL;\n-static jclass testedClass = NULL;\n+static jobject testedObject = nullptr;\n+static jobject testedInstance = nullptr;\n+static jclass testedClass = nullptr;\n@@ -79,1 +79,1 @@\n-    jfieldID fid = NULL;\n+    jfieldID fid = nullptr;\n@@ -84,1 +84,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedClass = jni->FindClass(CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedClass = jni->FindClass(CLASS_NAME)) != nullptr))\n@@ -87,1 +87,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass) jni->NewGlobalRef(testedClass)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass) jni->NewGlobalRef(testedClass)) != nullptr))\n@@ -92,1 +92,1 @@\n-            jni->GetStaticFieldID(testedClass, FIELD_NAME, FIELD_SIGNATURE)) != NULL))\n+            jni->GetStaticFieldID(testedClass, FIELD_NAME, FIELD_SIGNATURE)) != nullptr))\n@@ -95,1 +95,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->GetStaticObjectField(testedClass, fid)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->GetStaticObjectField(testedClass, fid)) != nullptr))\n@@ -101,1 +101,1 @@\n-            jni->GetStaticFieldID(testedClass, INSTANCE_NAME, INSTANCE_SIGNATURE)) != NULL))\n+            jni->GetStaticFieldID(testedClass, INSTANCE_NAME, INSTANCE_SIGNATURE)) != nullptr))\n@@ -105,1 +105,1 @@\n-            jni->GetStaticObjectField(testedClass, fid)) != NULL))\n+            jni->GetStaticObjectField(testedClass, fid)) != nullptr))\n@@ -306,1 +306,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -318,1 +318,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -328,1 +328,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -335,1 +335,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA04\/ma04t002\/ma04t002a.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-static jobject testedObject = NULL;\n+static jobject testedObject = nullptr;\n@@ -85,2 +85,2 @@\n-    jclass cls = NULL;\n-    jfieldID fid = NULL;\n+    jclass cls = nullptr;\n+    jfieldID fid = nullptr;\n@@ -91,1 +91,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(CLASS_NAME)) != nullptr))\n@@ -96,1 +96,1 @@\n-            jni->GetStaticFieldID(cls, FIELD_NAME, FIELD_SIGNATURE)) != NULL))\n+            jni->GetStaticFieldID(cls, FIELD_NAME, FIELD_SIGNATURE)) != nullptr))\n@@ -99,1 +99,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->GetStaticObjectField(cls, fid)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->GetStaticObjectField(cls, fid)) != nullptr))\n@@ -102,1 +102,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewGlobalRef(testedObject)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewGlobalRef(testedObject)) != nullptr))\n@@ -149,1 +149,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -161,1 +161,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -171,1 +171,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -180,1 +180,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, nullptr)))\n@@ -183,1 +183,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA04\/ma04t003\/ma04t003.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-static jobject testedObject = NULL;\n+static jobject testedObject = nullptr;\n@@ -85,2 +85,2 @@\n-    jclass cls = NULL;\n-    jfieldID fid = NULL;\n+    jclass cls = nullptr;\n+    jfieldID fid = nullptr;\n@@ -91,1 +91,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(CLASS_NAME)) != nullptr))\n@@ -96,1 +96,1 @@\n-            jni->GetStaticFieldID(cls, FIELD_NAME, FIELD_SIGNATURE)) != NULL))\n+            jni->GetStaticFieldID(cls, FIELD_NAME, FIELD_SIGNATURE)) != nullptr))\n@@ -99,1 +99,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->GetStaticObjectField(cls, fid)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->GetStaticObjectField(cls, fid)) != nullptr))\n@@ -102,1 +102,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewGlobalRef(testedObject)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedObject = jni->NewGlobalRef(testedObject)) != nullptr))\n@@ -149,1 +149,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -161,1 +161,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -171,1 +171,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -180,1 +180,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, nullptr)))\n@@ -183,1 +183,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA04\/ma04t003\/ma04t003a.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-static jthread thread = NULL;\n-static jmethodID method = NULL;\n+static jthread thread = nullptr;\n+static jmethodID method = nullptr;\n@@ -53,2 +53,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -57,1 +57,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -63,1 +63,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -65,1 +65,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -96,2 +96,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -100,1 +100,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -107,1 +107,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -109,1 +109,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -118,2 +118,2 @@\n-    jthread *threads = NULL;\n-    jclass klass = NULL;\n+    jthread *threads = nullptr;\n+    jclass klass = nullptr;\n@@ -129,1 +129,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -134,1 +134,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -144,1 +144,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -148,1 +148,1 @@\n-        if (info.name != NULL) {\n+        if (info.name != nullptr) {\n@@ -158,1 +158,1 @@\n-    if (thread == NULL) {\n+    if (thread == nullptr) {\n@@ -163,1 +163,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != nullptr))\n@@ -167,1 +167,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -171,1 +171,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"checkPoint\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"checkPoint\", \"()V\")) != nullptr))\n@@ -178,1 +178,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr)))\n@@ -180,1 +180,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, nullptr)))\n@@ -215,1 +215,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FRAME_POP, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FRAME_POP, nullptr)))\n@@ -240,1 +240,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -252,1 +252,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -261,1 +261,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA05\/ma05t001\/ma05t001.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-static jthread thread = NULL;\n-static jmethodID midCheckPoint = NULL;\n+static jthread thread = nullptr;\n+static jmethodID midCheckPoint = nullptr;\n@@ -53,2 +53,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -60,1 +60,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -67,1 +67,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -69,1 +69,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -85,1 +85,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FRAME_POP, NULL)))\n+        if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_FRAME_POP, nullptr)))\n@@ -102,2 +102,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -106,1 +106,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -113,1 +113,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -115,1 +115,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -145,2 +145,2 @@\n-    jthread *threads = NULL;\n-    jclass klass = NULL;\n+    jthread *threads = nullptr;\n+    jclass klass = nullptr;\n@@ -156,1 +156,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -161,1 +161,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -171,1 +171,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -175,1 +175,1 @@\n-        if (info.name != NULL) {\n+        if (info.name != nullptr) {\n@@ -185,1 +185,1 @@\n-    if (thread == NULL) {\n+    if (thread == nullptr) {\n@@ -190,1 +190,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != nullptr))\n@@ -194,1 +194,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -198,1 +198,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (midCheckPoint = jni->GetMethodID(klass, \"checkPoint\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (midCheckPoint = jni->GetMethodID(klass, \"checkPoint\", \"()V\")) != nullptr))\n@@ -202,1 +202,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, nullptr)))\n@@ -204,1 +204,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, nullptr)))\n@@ -236,1 +236,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_ENTRY, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_METHOD_ENTRY, nullptr)))\n@@ -258,1 +258,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -270,1 +270,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -279,1 +279,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA05\/ma05t001\/ma05t001a.cpp","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static jclass testedClass = NULL;\n+static jclass testedClass = nullptr;\n@@ -43,1 +43,1 @@\n-static unsigned char *klass_bytes = NULL;\n+static unsigned char *klass_bytes = nullptr;\n@@ -62,1 +62,1 @@\n-    if (name != NULL && (strcmp(name, CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, CLASS_NAME) == 0)) {\n@@ -66,1 +66,1 @@\n-        if (class_being_redefined == NULL) {\n+        if (class_being_redefined == nullptr) {\n@@ -96,1 +96,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedClass = jni->FindClass(CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedClass = jni->FindClass(CLASS_NAME)) != nullptr))\n@@ -99,1 +99,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass) jni->NewGlobalRef(testedClass)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass) jni->NewGlobalRef(testedClass)) != nullptr))\n@@ -110,1 +110,1 @@\n-    if (!NSK_VERIFY(klass_byte_count != 0 && klass_bytes != NULL))\n+    if (!NSK_VERIFY(klass_byte_count != 0 && klass_bytes != nullptr))\n@@ -181,1 +181,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n@@ -205,1 +205,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -217,1 +217,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -225,1 +225,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -233,1 +233,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA06\/ma06t001\/ma06t001.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static jclass testedClass = NULL;\n+static jclass testedClass = nullptr;\n@@ -43,1 +43,1 @@\n-static unsigned char *klass_bytes = NULL;\n+static unsigned char *klass_bytes = nullptr;\n@@ -62,1 +62,1 @@\n-    if (name != NULL && (strcmp(name, CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, CLASS_NAME) == 0)) {\n@@ -66,1 +66,1 @@\n-        if (class_being_redefined == NULL) {\n+        if (class_being_redefined == nullptr) {\n@@ -96,1 +96,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedClass = jni->FindClass(CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedClass = jni->FindClass(CLASS_NAME)) != nullptr))\n@@ -99,1 +99,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass) jni->NewGlobalRef(testedClass)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (testedClass = (jclass) jni->NewGlobalRef(testedClass)) != nullptr))\n@@ -110,1 +110,1 @@\n-    if (!NSK_VERIFY(klass_byte_count != 0 && klass_bytes != NULL))\n+    if (!NSK_VERIFY(klass_byte_count != 0 && klass_bytes != nullptr))\n@@ -181,1 +181,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n@@ -205,1 +205,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -217,1 +217,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -225,1 +225,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -233,1 +233,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA06\/ma06t001\/ma06t001a.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-static unsigned char *klass_bytes = NULL;\n+static unsigned char *klass_bytes = nullptr;\n@@ -65,1 +65,1 @@\n-    if (name != NULL && (strcmp(name, CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, CLASS_NAME) == 0)) {\n@@ -69,1 +69,1 @@\n-        if (!NSK_VERIFY(class_being_redefined == NULL)) {\n+        if (!NSK_VERIFY(class_being_redefined == nullptr)) {\n@@ -154,1 +154,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -165,1 +165,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -168,1 +168,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -176,1 +176,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA07\/ma07t001\/ma07t001.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-static unsigned char *klass_bytes = NULL;\n+static unsigned char *klass_bytes = nullptr;\n@@ -65,1 +65,1 @@\n-    if (name != NULL && (strcmp(name, CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, CLASS_NAME) == 0)) {\n@@ -69,1 +69,1 @@\n-        if (!NSK_VERIFY(class_being_redefined == NULL)) {\n+        if (!NSK_VERIFY(class_being_redefined == nullptr)) {\n@@ -155,1 +155,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -166,1 +166,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -169,1 +169,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -177,1 +177,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA07\/ma07t001\/ma07t001a.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,3 +41,3 @@\n-static jobject threadDeath = NULL;\n-static jthread threadForStop = NULL;\n-static jthread threadForInterrupt = NULL;\n+static jobject threadDeath = nullptr;\n+static jthread threadForStop = nullptr;\n+static jthread threadForInterrupt = nullptr;\n@@ -54,1 +54,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -56,2 +56,2 @@\n-    jclass cls = NULL;\n-    jmethodID ctor = NULL;\n+    jclass cls = nullptr;\n+    jmethodID ctor = nullptr;\n@@ -66,1 +66,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -71,1 +71,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -81,1 +81,1 @@\n-        if (info.name != NULL) {\n+        if (info.name != nullptr) {\n@@ -94,1 +94,1 @@\n-    if (threadForStop == NULL) {\n+    if (threadForStop == nullptr) {\n@@ -99,1 +99,1 @@\n-    if (threadForInterrupt == NULL) {\n+    if (threadForInterrupt == nullptr) {\n@@ -106,1 +106,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (cls = jni->FindClass(THREAD_DEATH_CLASS_NAME)) != nullptr))\n@@ -110,1 +110,1 @@\n-            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != NULL))\n+            jni->GetMethodID(cls, THREAD_DEATH_CTOR_NAME, THREAD_DEATH_CTOR_SIGNATURE)) != nullptr))\n@@ -113,1 +113,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (threadDeath = jni->NewObject(cls, ctor)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (threadDeath = jni->NewObject(cls, ctor)) != nullptr))\n@@ -134,1 +134,1 @@\n-    if (!NSK_VERIFY(threadForStop != NULL)) {\n+    if (!NSK_VERIFY(threadForStop != nullptr)) {\n@@ -142,1 +142,1 @@\n-    if (!NSK_VERIFY(threadForInterrupt != NULL)) {\n+    if (!NSK_VERIFY(threadForInterrupt != nullptr)) {\n@@ -174,1 +174,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -186,1 +186,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -189,1 +189,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA08\/ma08t001\/ma08t001.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-static jthread threadForStop = NULL;\n-static jthread threadForInterrupt = NULL;\n+static jthread threadForStop = nullptr;\n+static jthread threadForInterrupt = nullptr;\n@@ -56,2 +56,2 @@\n-    jclass klass = NULL;\n-    char *signature = NULL;\n+    jclass klass = nullptr;\n+    char *signature = nullptr;\n@@ -59,1 +59,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != nullptr)) {\n@@ -64,1 +64,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, nullptr))) {\n@@ -69,1 +69,1 @@\n-    if (!NSK_VERIFY(signature != NULL)) {\n+    if (!NSK_VERIFY(signature != nullptr)) {\n@@ -103,1 +103,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -113,1 +113,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -118,1 +118,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -128,1 +128,1 @@\n-        if (info.name != NULL) {\n+        if (info.name != nullptr) {\n@@ -141,1 +141,1 @@\n-    if (threadForStop == NULL) {\n+    if (threadForStop == nullptr) {\n@@ -146,1 +146,1 @@\n-    if (threadForInterrupt == NULL) {\n+    if (threadForInterrupt == nullptr) {\n@@ -151,1 +151,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (threadForStop = jni->NewGlobalRef(threadForStop)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (threadForStop = jni->NewGlobalRef(threadForStop)) != nullptr))\n@@ -154,1 +154,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (threadForInterrupt = jni->NewGlobalRef(threadForInterrupt)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (threadForInterrupt = jni->NewGlobalRef(threadForInterrupt)) != nullptr))\n@@ -158,1 +158,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, nullptr)))\n@@ -194,1 +194,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_EXCEPTION, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_EXCEPTION, nullptr)))\n@@ -219,1 +219,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -231,1 +231,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -234,1 +234,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA08\/ma08t001\/ma08t001a.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    if (info->thread_group != NULL) {\n+    if (info->thread_group != nullptr) {\n@@ -54,1 +54,1 @@\n-    if (info->context_class_loader != NULL) {\n+    if (info->context_class_loader != nullptr) {\n@@ -83,2 +83,2 @@\n-    jclass klass = NULL;\n-    char *signature = NULL;\n+    jclass klass = nullptr;\n+    char *signature = nullptr;\n@@ -92,1 +92,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != nullptr)) {\n@@ -96,1 +96,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, nullptr))) {\n@@ -101,1 +101,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -108,2 +108,2 @@\n-    jclass klass = NULL;\n-    char *signature = NULL;\n+    jclass klass = nullptr;\n+    char *signature = nullptr;\n@@ -117,1 +117,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != nullptr)) {\n@@ -121,1 +121,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, nullptr))) {\n@@ -126,1 +126,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -139,1 +139,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, nullptr)))\n@@ -141,1 +141,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION_CATCH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION_CATCH, nullptr)))\n@@ -150,1 +150,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_EXCEPTION, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_EXCEPTION, nullptr)))\n@@ -152,1 +152,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_EXCEPTION_CATCH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_EXCEPTION_CATCH, nullptr)))\n@@ -184,1 +184,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -196,1 +196,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -199,1 +199,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t001\/ma10t001.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,2 @@\n-    jclass klass = NULL;\n-    char *signature = NULL;\n+    jclass klass = nullptr;\n+    char *signature = nullptr;\n@@ -57,1 +57,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != nullptr)) {\n@@ -61,1 +61,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, nullptr))) {\n@@ -66,1 +66,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -73,2 +73,2 @@\n-    jclass klass = NULL;\n-    char *signature = NULL;\n+    jclass klass = nullptr;\n+    char *signature = nullptr;\n@@ -78,1 +78,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != nullptr)) {\n@@ -82,1 +82,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, nullptr))) {\n@@ -87,1 +87,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -135,1 +135,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -147,1 +147,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -150,1 +150,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t001\/ma10t001a.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static jthread thread = NULL;\n+static jthread thread = nullptr;\n@@ -53,2 +53,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -57,1 +57,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -62,1 +62,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -64,1 +64,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -73,1 +73,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -83,1 +83,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -88,1 +88,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -98,1 +98,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -103,1 +103,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != nullptr))\n@@ -162,1 +162,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -174,1 +174,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -177,1 +177,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t002\/ma10t002.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,2 +50,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -54,1 +54,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -59,1 +59,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -61,1 +61,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -104,1 +104,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -116,1 +116,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -119,1 +119,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t002\/ma10t002a.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static jthread thread = NULL;\n+static jthread thread = nullptr;\n@@ -54,2 +54,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -58,1 +58,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -63,1 +63,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -65,1 +65,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -74,1 +74,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -84,1 +84,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -89,1 +89,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -99,1 +99,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -104,1 +104,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != nullptr))\n@@ -163,1 +163,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -175,1 +175,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -178,1 +178,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t003\/ma10t003.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -55,1 +55,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -60,1 +60,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -62,1 +62,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -105,1 +105,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -117,1 +117,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -120,1 +120,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t003\/ma10t003a.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-static jthread thread = NULL;\n+static jthread thread = nullptr;\n@@ -53,2 +53,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -59,1 +59,1 @@\n-    NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, NULL));\n+    NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, nullptr));\n@@ -61,1 +61,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -67,1 +67,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -69,1 +69,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -78,1 +78,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -88,1 +88,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -93,1 +93,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -103,1 +103,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -108,1 +108,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != nullptr))\n@@ -167,1 +167,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -179,1 +179,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -182,1 +182,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t004\/ma10t004.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,2 +50,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -56,1 +56,1 @@\n-    NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, NULL));\n+    NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, nullptr));\n@@ -58,1 +58,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -64,1 +64,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -66,1 +66,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -109,1 +109,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -121,1 +121,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -124,1 +124,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t004\/ma10t004a.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(object_klass, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(object_klass, &signature, nullptr))) {\n@@ -60,1 +60,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -97,1 +97,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -109,1 +109,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -112,1 +112,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -126,1 +126,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t005\/ma10t005.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(object_klass, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(object_klass, &signature, nullptr))) {\n@@ -60,1 +60,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -97,1 +97,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -109,1 +109,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -112,1 +112,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t005\/ma10t005a.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -57,1 +57,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -63,1 +63,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -65,1 +65,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -72,2 +72,2 @@\n-    char *name = NULL;\n-    char *sig = NULL;\n+    char *name = nullptr;\n+    char *sig = nullptr;\n@@ -79,1 +79,1 @@\n-    err = jvmti_env->GetMethodName(method, &name, &sig, NULL);\n+    err = jvmti_env->GetMethodName(method, &name, &sig, nullptr);\n@@ -130,1 +130,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -142,1 +142,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -145,1 +145,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -160,1 +160,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr)))\n@@ -162,1 +162,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_UNLOAD, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_UNLOAD, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t006\/ma10t006.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -57,1 +57,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -63,1 +63,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -65,1 +65,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -72,2 +72,2 @@\n-    char *name = NULL;\n-    char *sig = NULL;\n+    char *name = nullptr;\n+    char *sig = nullptr;\n@@ -80,1 +80,1 @@\n-    err = jvmti_env->GetMethodName(method, &name, &sig, NULL);\n+    err = jvmti_env->GetMethodName(method, &name, &sig, nullptr);\n@@ -127,1 +127,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -139,1 +139,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -142,1 +142,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t006\/ma10t006a.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -110,1 +110,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -113,1 +113,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -128,1 +128,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_START, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_START, nullptr)))\n@@ -130,1 +130,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t007\/ma10t007.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -110,1 +110,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -113,1 +113,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t007\/ma10t007a.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -180,1 +180,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -183,1 +183,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -201,1 +201,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, nullptr)))\n@@ -203,1 +203,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, nullptr)))\n@@ -205,1 +205,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, nullptr)))\n@@ -207,1 +207,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t008\/ma10t008.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -180,1 +180,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -183,1 +183,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA10\/ma10t008\/ma10t008a.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -117,3 +117,3 @@\n-    jclass debugeeClass = NULL;\n-    jfieldID threadsFieldID = NULL;\n-    jobjectArray threadsArray = NULL;\n+    jclass debugeeClass = nullptr;\n+    jfieldID threadsFieldID = nullptr;\n+    jobjectArray threadsArray = nullptr;\n@@ -124,1 +124,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr))\n@@ -129,1 +129,1 @@\n-            jni->GetStaticFieldID(debugeeClass, THREADS_FIELD_NAME, THREADS_FIELD_SIG)) != NULL))\n+            jni->GetStaticFieldID(debugeeClass, THREADS_FIELD_NAME, THREADS_FIELD_SIG)) != nullptr))\n@@ -134,1 +134,1 @@\n-            jni->GetStaticObjectField(debugeeClass, threadsFieldID)) != NULL))\n+            jni->GetStaticObjectField(debugeeClass, threadsFieldID)) != nullptr))\n@@ -145,1 +145,1 @@\n-                jni->GetObjectArrayElement(threadsArray, i)) != NULL))\n+                jni->GetObjectArrayElement(threadsArray, i)) != nullptr))\n@@ -152,1 +152,1 @@\n-                jni->NewGlobalRef(threadsList[i])) != NULL))\n+                jni->NewGlobalRef(threadsList[i])) != nullptr))\n@@ -263,1 +263,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -267,1 +267,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP01\/sp01t001\/sp01t001.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -145,1 +145,1 @@\n-    jthread *allThreadsList = NULL;\n+    jthread *allThreadsList = nullptr;\n@@ -154,1 +154,1 @@\n-        threadsList[i] = NULL;\n+        threadsList[i] = nullptr;\n@@ -161,1 +161,1 @@\n-    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != NULL))\n+    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != nullptr))\n@@ -168,1 +168,1 @@\n-        if (!NSK_VERIFY(allThreadsList[i] != NULL))\n+        if (!NSK_VERIFY(allThreadsList[i] != nullptr))\n@@ -176,1 +176,1 @@\n-        if (threadInfo.name != NULL) {\n+        if (threadInfo.name != nullptr) {\n@@ -196,1 +196,1 @@\n-        if (threadsList[i] == NULL) {\n+        if (threadsList[i] == nullptr) {\n@@ -208,1 +208,1 @@\n-        if (!NSK_JNI_VERIFY(jni, (threadsList[i] = jni->NewGlobalRef(threadsList[i])) != NULL))\n+        if (!NSK_JNI_VERIFY(jni, (threadsList[i] = jni->NewGlobalRef(threadsList[i])) != nullptr))\n@@ -437,1 +437,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -450,1 +450,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP01\/sp01t002\/sp01t002.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -145,1 +145,1 @@\n-    jthread *allThreadsList = NULL;\n+    jthread *allThreadsList = nullptr;\n@@ -154,1 +154,1 @@\n-        threadsList[i] = NULL;\n+        threadsList[i] = nullptr;\n@@ -161,1 +161,1 @@\n-    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != NULL))\n+    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != nullptr))\n@@ -168,1 +168,1 @@\n-        if (!NSK_VERIFY(allThreadsList[i] != NULL))\n+        if (!NSK_VERIFY(allThreadsList[i] != nullptr))\n@@ -176,1 +176,1 @@\n-        if (threadInfo.name != NULL) {\n+        if (threadInfo.name != nullptr) {\n@@ -196,1 +196,1 @@\n-        if (threadsList[i] == NULL) {\n+        if (threadsList[i] == nullptr) {\n@@ -208,1 +208,1 @@\n-        if (!NSK_JNI_VERIFY(jni, (threadsList[i] = jni->NewGlobalRef(threadsList[i])) != NULL))\n+        if (!NSK_JNI_VERIFY(jni, (threadsList[i] = jni->NewGlobalRef(threadsList[i])) != nullptr))\n@@ -448,1 +448,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -461,1 +461,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP01\/sp01t003\/sp01t003.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -53,6 +53,6 @@\n-    { \"threadRunning\", 2, NULL },\n-    { \"threadEntering\", 2, NULL },\n-    { \"threadWaiting\", 2, NULL },\n-    { \"threadSleeping\", 2, NULL },\n-    { \"threadRunningInterrupted\", 2, NULL },\n-    { \"threadRunningNative\", 2, NULL }\n+    { \"threadRunning\", 2, nullptr },\n+    { \"threadEntering\", 2, nullptr },\n+    { \"threadWaiting\", 2, nullptr },\n+    { \"threadSleeping\", 2, nullptr },\n+    { \"threadRunningInterrupted\", 2, nullptr },\n+    { \"threadRunningNative\", 2, nullptr }\n@@ -126,1 +126,1 @@\n-    jthread *allThreadsList = NULL;\n+    jthread *allThreadsList = nullptr;\n@@ -135,1 +135,1 @@\n-        threadsDesc[i].thread = (jthread)NULL;\n+        threadsDesc[i].thread = (jthread)nullptr;\n@@ -142,1 +142,1 @@\n-    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != NULL))\n+    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != nullptr))\n@@ -149,1 +149,1 @@\n-        if (!NSK_VERIFY(allThreadsList[i] != NULL))\n+        if (!NSK_VERIFY(allThreadsList[i] != nullptr))\n@@ -157,1 +157,1 @@\n-        if (threadInfo.name != NULL) {\n+        if (threadInfo.name != nullptr) {\n@@ -177,1 +177,1 @@\n-        if (threadsDesc[i].thread == NULL) {\n+        if (threadsDesc[i].thread == nullptr) {\n@@ -190,1 +190,1 @@\n-                jni->NewGlobalRef(threadsDesc[i].thread)) != NULL))\n+                jni->NewGlobalRef(threadsDesc[i].thread)) != nullptr))\n@@ -359,1 +359,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -372,1 +372,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP02\/sp02t001\/sp02t001.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -57,6 +57,6 @@\n-    { \"threadRunning\", \"testedMethod\", \"()V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION },\n-    { \"threadEntering\", \"testedMethod\", \"()V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION },\n-    { \"threadWaiting\", \"testedMethod\", \"()V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION },\n-    { \"threadSleeping\", \"testedMethod\", \"()V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION },\n-    { \"threadRunningInterrupted\", \"testedMethod\", \"()V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION },\n-    { \"threadRunningNative\", \"testedMethod\", \"()V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION }\n+    { \"threadRunning\", \"testedMethod\", \"()V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION },\n+    { \"threadEntering\", \"testedMethod\", \"()V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION },\n+    { \"threadWaiting\", \"testedMethod\", \"()V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION },\n+    { \"threadSleeping\", \"testedMethod\", \"()V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION },\n+    { \"threadRunningInterrupted\", \"testedMethod\", \"()V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION },\n+    { \"threadRunningNative\", \"testedMethod\", \"()V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION }\n@@ -146,1 +146,1 @@\n-    jthread *allThreadsList = NULL;\n+    jthread *allThreadsList = nullptr;\n@@ -155,2 +155,2 @@\n-        threadsDesc[i].thread = (jthread)NULL;\n-        threadsDesc[i].method = (jmethodID)NULL;\n+        threadsDesc[i].thread = (jthread)nullptr;\n+        threadsDesc[i].method = (jmethodID)nullptr;\n@@ -164,1 +164,1 @@\n-    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != NULL))\n+    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != nullptr))\n@@ -171,1 +171,1 @@\n-        if (!NSK_VERIFY(allThreadsList[i] != NULL))\n+        if (!NSK_VERIFY(allThreadsList[i] != nullptr))\n@@ -179,1 +179,1 @@\n-        if (threadInfo.name != NULL) {\n+        if (threadInfo.name != nullptr) {\n@@ -199,1 +199,1 @@\n-        if (threadsDesc[i].thread == NULL) {\n+        if (threadsDesc[i].thread == nullptr) {\n@@ -214,1 +214,1 @@\n-                jni->GetObjectClass(threadsDesc[i].thread)) != NULL))\n+                jni->GetObjectClass(threadsDesc[i].thread)) != nullptr))\n@@ -218,1 +218,1 @@\n-                jni->GetMethodID(threadsDesc[i].cls, threadsDesc[i].methodName, threadsDesc[i].methodSig)) != NULL))\n+                jni->GetMethodID(threadsDesc[i].cls, threadsDesc[i].methodName, threadsDesc[i].methodSig)) != nullptr))\n@@ -230,1 +230,1 @@\n-                jni->NewGlobalRef(threadsDesc[i].thread)) != NULL))\n+                jni->NewGlobalRef(threadsDesc[i].thread)) != nullptr))\n@@ -233,1 +233,1 @@\n-                jni->NewGlobalRef(threadsDesc[i].cls)) != NULL))\n+                jni->NewGlobalRef(threadsDesc[i].cls)) != nullptr))\n@@ -316,2 +316,2 @@\n-            if (frameStack[j].method == NULL) {\n-                NSK_COMPLAIN3(\"NULL methodID in stack for %s thread #%d (%s)\\n\",\n+            if (frameStack[j].method == nullptr) {\n+                NSK_COMPLAIN3(\"null methodID in stack for %s thread #%d (%s)\\n\",\n@@ -422,1 +422,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -435,1 +435,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP02\/sp02t002\/sp02t002.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -57,6 +57,6 @@\n-    { \"threadRunning\", \"testedMethod\", \"()V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION },\n-    { \"threadEntering\", \"testedMethod\", \"()V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION },\n-    { \"threadWaiting\", \"testedMethod\", \"()V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION },\n-    { \"threadSleeping\", \"testedMethod\", \"()V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION },\n-    { \"threadRunningInterrupted\", \"testedMethod\", \"()V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION },\n-    { \"threadRunningNative\", \"testedMethod\", \"()V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION }\n+    { \"threadRunning\", \"testedMethod\", \"()V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION },\n+    { \"threadEntering\", \"testedMethod\", \"()V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION },\n+    { \"threadWaiting\", \"testedMethod\", \"()V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION },\n+    { \"threadSleeping\", \"testedMethod\", \"()V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION },\n+    { \"threadRunningInterrupted\", \"testedMethod\", \"()V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION },\n+    { \"threadRunningNative\", \"testedMethod\", \"()V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION }\n@@ -147,1 +147,1 @@\n-    jthread *allThreadsList = NULL;\n+    jthread *allThreadsList = nullptr;\n@@ -156,2 +156,2 @@\n-        threadsDesc[i].thread = (jthread)NULL;\n-        threadsDesc[i].method = (jmethodID)NULL;\n+        threadsDesc[i].thread = (jthread)nullptr;\n+        threadsDesc[i].method = (jmethodID)nullptr;\n@@ -165,1 +165,1 @@\n-    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != NULL))\n+    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != nullptr))\n@@ -172,1 +172,1 @@\n-        if (!NSK_VERIFY(allThreadsList[i] != NULL))\n+        if (!NSK_VERIFY(allThreadsList[i] != nullptr))\n@@ -180,1 +180,1 @@\n-        if (threadInfo.name != NULL) {\n+        if (threadInfo.name != nullptr) {\n@@ -200,1 +200,1 @@\n-        if (threadsDesc[i].thread == NULL) {\n+        if (threadsDesc[i].thread == nullptr) {\n@@ -215,1 +215,1 @@\n-                jni->GetObjectClass(threadsDesc[i].thread)) != NULL))\n+                jni->GetObjectClass(threadsDesc[i].thread)) != nullptr))\n@@ -219,1 +219,1 @@\n-                jni->GetMethodID(threadsDesc[i].cls, threadsDesc[i].methodName, threadsDesc[i].methodSig)) != NULL))\n+                jni->GetMethodID(threadsDesc[i].cls, threadsDesc[i].methodName, threadsDesc[i].methodSig)) != nullptr))\n@@ -231,1 +231,1 @@\n-                jni->NewGlobalRef(threadsDesc[i].thread)) != NULL))\n+                jni->NewGlobalRef(threadsDesc[i].thread)) != nullptr))\n@@ -234,1 +234,1 @@\n-                jni->NewGlobalRef(threadsDesc[i].cls)) != NULL))\n+                jni->NewGlobalRef(threadsDesc[i].cls)) != nullptr))\n@@ -300,1 +300,1 @@\n-            jmethodID qMethod = (jmethodID)NULL;\n+            jmethodID qMethod = (jmethodID)nullptr;\n@@ -435,1 +435,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -447,1 +447,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP02\/sp02t003\/sp02t003.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -149,1 +149,1 @@\n-    jthread *allThreadsList = NULL;\n+    jthread *allThreadsList = nullptr;\n@@ -159,1 +159,1 @@\n-        threadsList[i] = NULL;\n+        threadsList[i] = nullptr;\n@@ -166,1 +166,1 @@\n-            threadsList[i][j] = NULL;\n+            threadsList[i][j] = nullptr;\n@@ -174,1 +174,1 @@\n-    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != NULL))\n+    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != nullptr))\n@@ -181,1 +181,1 @@\n-        if (!NSK_VERIFY(allThreadsList[i] != NULL))\n+        if (!NSK_VERIFY(allThreadsList[i] != nullptr))\n@@ -189,1 +189,1 @@\n-        if (threadInfo.name != NULL) {\n+        if (threadInfo.name != nullptr) {\n@@ -225,1 +225,1 @@\n-                    jni->NewGlobalRef(threadsList[i][j])) != NULL))\n+                    jni->NewGlobalRef(threadsList[i][j])) != nullptr))\n@@ -238,1 +238,1 @@\n-    jvmtiError* results = NULL;\n+    jvmtiError* results = nullptr;\n@@ -371,1 +371,1 @@\n-        threadsList[i] = NULL;\n+        threadsList[i] = nullptr;\n@@ -446,1 +446,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -459,1 +459,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP03\/sp03t001\/sp03t001.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -152,1 +152,1 @@\n-    jthread *allThreadsList = NULL;\n+    jthread *allThreadsList = nullptr;\n@@ -162,1 +162,1 @@\n-        threadsList[i] = NULL;\n+        threadsList[i] = nullptr;\n@@ -169,1 +169,1 @@\n-            threadsList[i][j] = NULL;\n+            threadsList[i][j] = nullptr;\n@@ -177,1 +177,1 @@\n-    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != NULL))\n+    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != nullptr))\n@@ -184,1 +184,1 @@\n-        if (!NSK_VERIFY(allThreadsList[i] != NULL))\n+        if (!NSK_VERIFY(allThreadsList[i] != nullptr))\n@@ -192,1 +192,1 @@\n-        if (threadInfo.name != NULL) {\n+        if (threadInfo.name != nullptr) {\n@@ -228,1 +228,1 @@\n-                    jni->NewGlobalRef(threadsList[i][j])) != NULL))\n+                    jni->NewGlobalRef(threadsList[i][j])) != nullptr))\n@@ -241,1 +241,1 @@\n-    jvmtiError* results = NULL;\n+    jvmtiError* results = nullptr;\n@@ -374,1 +374,1 @@\n-        threadsList[i] = NULL;\n+        threadsList[i] = nullptr;\n@@ -449,1 +449,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -462,1 +462,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP03\/sp03t002\/sp03t002.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -149,1 +149,1 @@\n-    jthread *allThreadsList = NULL;\n+    jthread *allThreadsList = nullptr;\n@@ -159,1 +159,1 @@\n-        threadsList[i] = NULL;\n+        threadsList[i] = nullptr;\n@@ -166,1 +166,1 @@\n-            threadsList[i][j] = NULL;\n+            threadsList[i][j] = nullptr;\n@@ -174,1 +174,1 @@\n-    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != NULL))\n+    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != nullptr))\n@@ -181,1 +181,1 @@\n-        if (!NSK_VERIFY(allThreadsList[i] != NULL))\n+        if (!NSK_VERIFY(allThreadsList[i] != nullptr))\n@@ -189,1 +189,1 @@\n-        if (threadInfo.name != NULL) {\n+        if (threadInfo.name != nullptr) {\n@@ -225,1 +225,1 @@\n-                    jni->NewGlobalRef(threadsList[i][j])) != NULL))\n+                    jni->NewGlobalRef(threadsList[i][j])) != nullptr))\n@@ -238,1 +238,1 @@\n-    jvmtiError* results = NULL;\n+    jvmtiError* results = nullptr;\n@@ -371,1 +371,1 @@\n-        threadsList[i] = NULL;\n+        threadsList[i] = nullptr;\n@@ -446,1 +446,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -459,1 +459,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP04\/sp04t001\/sp04t001.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -149,1 +149,1 @@\n-    jthread *allThreadsList = NULL;\n+    jthread *allThreadsList = nullptr;\n@@ -159,1 +159,1 @@\n-        threadsList[i] = NULL;\n+        threadsList[i] = nullptr;\n@@ -166,1 +166,1 @@\n-            threadsList[i][j] = NULL;\n+            threadsList[i][j] = nullptr;\n@@ -174,1 +174,1 @@\n-    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != NULL))\n+    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != nullptr))\n@@ -181,1 +181,1 @@\n-        if (!NSK_VERIFY(allThreadsList[i] != NULL))\n+        if (!NSK_VERIFY(allThreadsList[i] != nullptr))\n@@ -189,1 +189,1 @@\n-        if (threadInfo.name != NULL) {\n+        if (threadInfo.name != nullptr) {\n@@ -225,1 +225,1 @@\n-                    jni->NewGlobalRef(threadsList[i][j])) != NULL))\n+                    jni->NewGlobalRef(threadsList[i][j])) != nullptr))\n@@ -238,1 +238,1 @@\n-    jvmtiError* results = NULL;\n+    jvmtiError* results = nullptr;\n@@ -371,1 +371,1 @@\n-        threadsList[i] = NULL;\n+        threadsList[i] = nullptr;\n@@ -446,1 +446,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -459,1 +459,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP04\/sp04t002\/sp04t002.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -146,1 +146,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(enable, eventsList[i], NULL))) {\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(enable, eventsList[i], nullptr))) {\n@@ -162,3 +162,3 @@\n-    jclass debugeeClass = NULL;\n-    jfieldID threadsFieldID = NULL;\n-    jobjectArray threadsArray = NULL;\n+    jclass debugeeClass = nullptr;\n+    jfieldID threadsFieldID = nullptr;\n+    jobjectArray threadsArray = nullptr;\n@@ -169,1 +169,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr))\n@@ -174,1 +174,1 @@\n-            jni->GetStaticFieldID(debugeeClass, THREADS_FIELD_NAME, THREADS_FIELD_SIG)) != NULL))\n+            jni->GetStaticFieldID(debugeeClass, THREADS_FIELD_NAME, THREADS_FIELD_SIG)) != nullptr))\n@@ -179,1 +179,1 @@\n-            jni->GetStaticObjectField(debugeeClass, threadsFieldID)) != NULL))\n+            jni->GetStaticObjectField(debugeeClass, threadsFieldID)) != nullptr))\n@@ -190,1 +190,1 @@\n-                jni->GetObjectArrayElement(threadsArray, i)) != NULL))\n+                jni->GetObjectArrayElement(threadsArray, i)) != nullptr))\n@@ -197,1 +197,1 @@\n-                jni->NewGlobalRef(threadsList[i])) != NULL))\n+                jni->NewGlobalRef(threadsList[i])) != nullptr))\n@@ -282,2 +282,2 @@\n-    \/* check if thread is not NULL *\/\n-    if (!NSK_VERIFY(thread != NULL)) {\n+    \/* check if thread is not nullptr *\/\n+    if (!NSK_VERIFY(thread != nullptr)) {\n@@ -309,2 +309,2 @@\n-    \/* check if thread is not NULL *\/\n-    if (!NSK_VERIFY(thread != NULL)) {\n+    \/* check if thread is not nullptr *\/\n+    if (!NSK_VERIFY(thread != nullptr)) {\n@@ -391,1 +391,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -405,1 +405,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP05\/sp05t002\/sp05t002.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -103,1 +103,1 @@\n-                    jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL))) {\n+                    jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, nullptr))) {\n@@ -124,1 +124,1 @@\n-                    jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_THREAD_START, NULL))) {\n+                    jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_THREAD_START, nullptr))) {\n@@ -153,1 +153,1 @@\n-                    jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, NULL))) {\n+                    jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, nullptr))) {\n@@ -174,1 +174,1 @@\n-                    jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_THREAD_END, NULL))) {\n+                    jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_THREAD_END, nullptr))) {\n@@ -234,3 +234,3 @@\n-    jclass debugeeClass = NULL;\n-    jfieldID threadsFieldID = NULL;\n-    jobjectArray threadsArray = NULL;\n+    jclass debugeeClass = nullptr;\n+    jfieldID threadsFieldID = nullptr;\n+    jobjectArray threadsArray = nullptr;\n@@ -241,1 +241,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr))\n@@ -246,1 +246,1 @@\n-            jni->GetStaticFieldID(debugeeClass, THREADS_FIELD_NAME, THREADS_FIELD_SIG)) != NULL))\n+            jni->GetStaticFieldID(debugeeClass, THREADS_FIELD_NAME, THREADS_FIELD_SIG)) != nullptr))\n@@ -251,1 +251,1 @@\n-            jni->GetStaticObjectField(debugeeClass, threadsFieldID)) != NULL))\n+            jni->GetStaticObjectField(debugeeClass, threadsFieldID)) != nullptr))\n@@ -262,1 +262,1 @@\n-                jni->GetObjectArrayElement(threadsArray, i)) != NULL))\n+                jni->GetObjectArrayElement(threadsArray, i)) != nullptr))\n@@ -269,1 +269,1 @@\n-                jni->NewGlobalRef(threadsList[i])) != NULL))\n+                jni->NewGlobalRef(threadsList[i])) != nullptr))\n@@ -365,2 +365,2 @@\n-    \/* check if thread is not NULL *\/\n-    if (!NSK_VERIFY(thread != NULL)) {\n+    \/* check if thread is not nullptr *\/\n+    if (!NSK_VERIFY(thread != nullptr)) {\n@@ -400,2 +400,2 @@\n-    \/* check if thread is not NULL *\/\n-    if (!NSK_VERIFY(thread != NULL)) {\n+    \/* check if thread is not nullptr *\/\n+    if (!NSK_VERIFY(thread != nullptr)) {\n@@ -490,1 +490,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -513,1 +513,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP05\/sp05t003\/sp05t003.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -65,6 +65,6 @@\n-    { \"threadRunning\", \"testedMethod\", \"(ZI)V\", 2, NULL, NULL, NULL, NSK_FALSE },\n-    { \"threadEntering\", \"testedMethod\", \"(ZI)V\", 2, NULL, NULL, NULL, NSK_FALSE },\n-    { \"threadWaiting\", \"testedMethod\", \"(ZI)V\", 2, NULL, NULL, NULL, NSK_FALSE },\n-    { \"threadSleeping\", \"testedMethod\", \"(ZI)V\", 2, NULL, NULL, NULL, NSK_FALSE },\n-    { \"threadRunningInterrupted\", \"testedMethod\", \"(ZI)V\", 2, NULL, NULL, NULL, NSK_FALSE },\n-    { \"threadRunningNative\", \"testedMethod\", \"(ZI)V\", 2, NULL, NULL, NULL, NSK_FALSE }\n+    { \"threadRunning\", \"testedMethod\", \"(ZI)V\", 2, nullptr, nullptr, nullptr, NSK_FALSE },\n+    { \"threadEntering\", \"testedMethod\", \"(ZI)V\", 2, nullptr, nullptr, nullptr, NSK_FALSE },\n+    { \"threadWaiting\", \"testedMethod\", \"(ZI)V\", 2, nullptr, nullptr, nullptr, NSK_FALSE },\n+    { \"threadSleeping\", \"testedMethod\", \"(ZI)V\", 2, nullptr, nullptr, nullptr, NSK_FALSE },\n+    { \"threadRunningInterrupted\", \"testedMethod\", \"(ZI)V\", 2, nullptr, nullptr, nullptr, NSK_FALSE },\n+    { \"threadRunningNative\", \"testedMethod\", \"(ZI)V\", 2, nullptr, nullptr, nullptr, NSK_FALSE }\n@@ -155,1 +155,1 @@\n-    jthread *allThreadsList = NULL;\n+    jthread *allThreadsList = nullptr;\n@@ -164,2 +164,2 @@\n-        threadsDesc[i].thread = (jthread)NULL;\n-        threadsDesc[i].method = (jmethodID)NULL;\n+        threadsDesc[i].thread = (jthread)nullptr;\n+        threadsDesc[i].method = (jmethodID)nullptr;\n@@ -173,1 +173,1 @@\n-    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != NULL))\n+    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != nullptr))\n@@ -180,1 +180,1 @@\n-        if (!NSK_VERIFY(allThreadsList[i] != NULL))\n+        if (!NSK_VERIFY(allThreadsList[i] != nullptr))\n@@ -186,1 +186,1 @@\n-        if (threadInfo.name != NULL) {\n+        if (threadInfo.name != nullptr) {\n@@ -206,1 +206,1 @@\n-        if (threadsDesc[i].thread == NULL) {\n+        if (threadsDesc[i].thread == nullptr) {\n@@ -221,1 +221,1 @@\n-                jni->GetObjectClass(threadsDesc[i].thread)) != NULL))\n+                jni->GetObjectClass(threadsDesc[i].thread)) != nullptr))\n@@ -225,1 +225,1 @@\n-                jni->GetMethodID(threadsDesc[i].cls, threadsDesc[i].methodName, threadsDesc[i].methodSig)) != NULL))\n+                jni->GetMethodID(threadsDesc[i].cls, threadsDesc[i].methodName, threadsDesc[i].methodSig)) != nullptr))\n@@ -237,1 +237,1 @@\n-                jni->NewGlobalRef(threadsDesc[i].thread)) != NULL))\n+                jni->NewGlobalRef(threadsDesc[i].thread)) != nullptr))\n@@ -240,1 +240,1 @@\n-                jni->NewGlobalRef(threadsDesc[i].cls)) != NULL))\n+                jni->NewGlobalRef(threadsDesc[i].cls)) != nullptr))\n@@ -245,1 +245,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL))\n+    if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -346,1 +346,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL))\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -477,1 +477,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -498,1 +498,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP06\/sp06t001\/sp06t001.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -65,6 +65,6 @@\n-    { \"threadRunning\", \"testedMethod\", \"(ZI)V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n-    { \"threadEntering\", \"testedMethod\", \"(ZI)V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n-    { \"threadWaiting\", \"testedMethod\", \"(ZI)V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n-    { \"threadSleeping\", \"testedMethod\", \"(ZI)V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n-    { \"threadRunningInterrupted\", \"testedMethod\", \"(ZI)V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n-    { \"threadRunningNative\", \"testedMethod\", \"(ZI)V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE }\n+    { \"threadRunning\", \"testedMethod\", \"(ZI)V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n+    { \"threadEntering\", \"testedMethod\", \"(ZI)V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n+    { \"threadWaiting\", \"testedMethod\", \"(ZI)V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n+    { \"threadSleeping\", \"testedMethod\", \"(ZI)V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n+    { \"threadRunningInterrupted\", \"testedMethod\", \"(ZI)V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n+    { \"threadRunningNative\", \"testedMethod\", \"(ZI)V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE }\n@@ -163,1 +163,1 @@\n-    jthread *allThreadsList = NULL;\n+    jthread *allThreadsList = nullptr;\n@@ -172,2 +172,2 @@\n-        threadsDesc[i].thread = (jthread)NULL;\n-        threadsDesc[i].method = (jmethodID)NULL;\n+        threadsDesc[i].thread = (jthread)nullptr;\n+        threadsDesc[i].method = (jmethodID)nullptr;\n@@ -182,1 +182,1 @@\n-    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != NULL))\n+    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != nullptr))\n@@ -189,1 +189,1 @@\n-        if (!NSK_VERIFY(allThreadsList[i] != NULL))\n+        if (!NSK_VERIFY(allThreadsList[i] != nullptr))\n@@ -195,1 +195,1 @@\n-        if (threadInfo.name != NULL) {\n+        if (threadInfo.name != nullptr) {\n@@ -215,1 +215,1 @@\n-        if (threadsDesc[i].thread == NULL) {\n+        if (threadsDesc[i].thread == nullptr) {\n@@ -230,1 +230,1 @@\n-                jni->GetObjectClass(threadsDesc[i].thread)) != NULL))\n+                jni->GetObjectClass(threadsDesc[i].thread)) != nullptr))\n@@ -234,1 +234,1 @@\n-                jni->GetMethodID(threadsDesc[i].cls, threadsDesc[i].methodName, threadsDesc[i].methodSig)) != NULL))\n+                jni->GetMethodID(threadsDesc[i].cls, threadsDesc[i].methodName, threadsDesc[i].methodSig)) != nullptr))\n@@ -246,1 +246,1 @@\n-                jni->NewGlobalRef(threadsDesc[i].thread)) != NULL))\n+                jni->NewGlobalRef(threadsDesc[i].thread)) != nullptr))\n@@ -249,1 +249,1 @@\n-                jni->NewGlobalRef(threadsDesc[i].cls)) != NULL))\n+                jni->NewGlobalRef(threadsDesc[i].cls)) != nullptr))\n@@ -254,1 +254,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL))\n+    if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -340,2 +340,2 @@\n-            if (frameStack[j].method == NULL) {\n-                NSK_COMPLAIN3(\"NULL methodID in stack for %s thread #%d (%s)\\n\",\n+            if (frameStack[j].method == nullptr) {\n+                NSK_COMPLAIN3(\"null methodID in stack for %s thread #%d (%s)\\n\",\n@@ -375,1 +375,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL))\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -506,1 +506,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -527,1 +527,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP06\/sp06t002\/sp06t002.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n+static JNIEnv* jni = nullptr;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -65,6 +65,6 @@\n-    { \"threadRunning\", \"testedMethod\", \"(ZI)V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n-    { \"threadEntering\", \"testedMethod\", \"(ZI)V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n-    { \"threadWaiting\", \"testedMethod\", \"(ZI)V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n-    { \"threadSleeping\", \"testedMethod\", \"(ZI)V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n-    { \"threadRunningInterrupted\", \"testedMethod\", \"(ZI)V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n-    { \"threadRunningNative\", \"testedMethod\", \"(ZI)V\", NULL, NULL, NULL, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE }\n+    { \"threadRunning\", \"testedMethod\", \"(ZI)V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n+    { \"threadEntering\", \"testedMethod\", \"(ZI)V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n+    { \"threadWaiting\", \"testedMethod\", \"(ZI)V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n+    { \"threadSleeping\", \"testedMethod\", \"(ZI)V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n+    { \"threadRunningInterrupted\", \"testedMethod\", \"(ZI)V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE },\n+    { \"threadRunningNative\", \"testedMethod\", \"(ZI)V\", nullptr, nullptr, nullptr, NSK_JVMTI_INVALID_JLOCATION, NSK_FALSE }\n@@ -163,1 +163,1 @@\n-    jthread *allThreadsList = NULL;\n+    jthread *allThreadsList = nullptr;\n@@ -172,2 +172,2 @@\n-        threadsDesc[i].thread = (jthread)NULL;\n-        threadsDesc[i].method = (jmethodID)NULL;\n+        threadsDesc[i].thread = (jthread)nullptr;\n+        threadsDesc[i].method = (jmethodID)nullptr;\n@@ -182,1 +182,1 @@\n-    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != NULL))\n+    if (!NSK_VERIFY(allThreadsCount > 0 && allThreadsList != nullptr))\n@@ -189,1 +189,1 @@\n-        if (!NSK_VERIFY(allThreadsList[i] != NULL))\n+        if (!NSK_VERIFY(allThreadsList[i] != nullptr))\n@@ -195,1 +195,1 @@\n-        if (threadInfo.name != NULL) {\n+        if (threadInfo.name != nullptr) {\n@@ -215,1 +215,1 @@\n-        if (threadsDesc[i].thread == NULL) {\n+        if (threadsDesc[i].thread == nullptr) {\n@@ -230,1 +230,1 @@\n-                jni->GetObjectClass(threadsDesc[i].thread)) != NULL))\n+                jni->GetObjectClass(threadsDesc[i].thread)) != nullptr))\n@@ -234,1 +234,1 @@\n-                jni->GetMethodID(threadsDesc[i].cls, threadsDesc[i].methodName, threadsDesc[i].methodSig)) != NULL))\n+                jni->GetMethodID(threadsDesc[i].cls, threadsDesc[i].methodName, threadsDesc[i].methodSig)) != nullptr))\n@@ -246,1 +246,1 @@\n-                jni->NewGlobalRef(threadsDesc[i].thread)) != NULL))\n+                jni->NewGlobalRef(threadsDesc[i].thread)) != nullptr))\n@@ -249,1 +249,1 @@\n-                jni->NewGlobalRef(threadsDesc[i].cls)) != NULL))\n+                jni->NewGlobalRef(threadsDesc[i].cls)) != nullptr))\n@@ -254,1 +254,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, NULL))\n+    if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -323,1 +323,1 @@\n-            jmethodID qMethod = (jmethodID)NULL;\n+            jmethodID qMethod = (jmethodID)nullptr;\n@@ -387,1 +387,1 @@\n-    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, NULL))\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr))\n@@ -518,1 +518,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -539,1 +539,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP06\/sp06t003\/sp06t003.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,3 +44,3 @@\n-static jthread thread = NULL;\n-static jrawMonitorID waitLock = NULL;\n-static jrawMonitorID frameLock = NULL;\n+static jthread thread = nullptr;\n+static jrawMonitorID waitLock = nullptr;\n+static jrawMonitorID frameLock = nullptr;\n@@ -58,1 +58,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -68,1 +68,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -73,1 +73,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -83,1 +83,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -87,1 +87,1 @@\n-        if (info.name != NULL) {\n+        if (info.name != nullptr) {\n@@ -97,1 +97,1 @@\n-    if (thread == NULL) {\n+    if (thread == nullptr) {\n@@ -126,2 +126,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -129,1 +129,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(frameBuffer[frameCount-1-i].method, &name, &signature, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(frameBuffer[frameCount-1-i].method, &name, &signature, nullptr)))\n@@ -134,1 +134,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -136,1 +136,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -139,1 +139,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(sampleStack[i].method, &name, &signature, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(sampleStack[i].method, &name, &signature, nullptr)))\n@@ -144,1 +144,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -146,1 +146,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -154,2 +154,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -157,1 +157,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(frameBuffer[frameCount-1-i].method, &name, &signature, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(frameBuffer[frameCount-1-i].method, &name, &signature, nullptr)))\n@@ -162,1 +162,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -164,1 +164,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -167,1 +167,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(sampleStack[i].method, &name, &signature, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(sampleStack[i].method, &name, &signature, nullptr)))\n@@ -172,1 +172,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -174,1 +174,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -260,2 +260,2 @@\n-    jclass klass = NULL;\n-    jmethodID method = NULL;\n+    jclass klass = nullptr;\n+    jmethodID method = nullptr;\n@@ -272,1 +272,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetFrameLocation(NULL, 1, &sampleStack[depth].method, &sampleStack[depth].location))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->GetFrameLocation(nullptr, 1, &sampleStack[depth].method, &sampleStack[depth].location))) {\n@@ -279,1 +279,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetFrameLocation(NULL, 0, &sampleStack[depth].method, &sampleStack[depth].location))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->GetFrameLocation(nullptr, 0, &sampleStack[depth].method, &sampleStack[depth].location))) {\n@@ -289,1 +289,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(obj)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(obj)) != nullptr)) {\n@@ -294,1 +294,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"fibonacci\", \"(I)I\")) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (method = jni->GetMethodID(klass, \"fibonacci\", \"(I)I\")) != nullptr)) {\n@@ -328,1 +328,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -339,1 +339,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -346,1 +346,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP07\/sp07t001\/sp07t001.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,6 +44,6 @@\n-static jthread thread = NULL;\n-static jrawMonitorID waitLock = NULL;\n-static jfieldID field = NULL;\n-static jmethodID methodRun = NULL;\n-static jmethodID methodCatcher = NULL;\n-static jmethodID methodThrower = NULL;\n+static jthread thread = nullptr;\n+static jrawMonitorID waitLock = nullptr;\n+static jfieldID field = nullptr;\n+static jmethodID methodRun = nullptr;\n+static jmethodID methodCatcher = nullptr;\n+static jmethodID methodThrower = nullptr;\n@@ -60,1 +60,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -62,2 +62,2 @@\n-    jclass klass = NULL;\n-    jfieldID fid = NULL;\n+    jclass klass = nullptr;\n+    jfieldID fid = nullptr;\n@@ -72,1 +72,1 @@\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n+    if (!NSK_VERIFY(threads_count > 0 && threads != nullptr))\n@@ -77,1 +77,1 @@\n-        if (!NSK_VERIFY(threads[i] != NULL))\n+        if (!NSK_VERIFY(threads[i] != nullptr))\n@@ -87,1 +87,1 @@\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+        if (info.name != nullptr && (strcmp(info.name, THREAD_NAME) == 0)) {\n@@ -91,1 +91,1 @@\n-        if (info.name != NULL) {\n+        if (info.name != nullptr) {\n@@ -101,1 +101,1 @@\n-    if (thread == NULL) {\n+    if (thread == nullptr) {\n@@ -107,1 +107,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != nullptr))\n@@ -111,1 +111,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (fid = jni->GetStaticFieldID(klass, \"MAX_LADDER\", \"I\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (fid = jni->GetStaticFieldID(klass, \"MAX_LADDER\", \"I\")) != nullptr))\n@@ -118,1 +118,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"depth\", \"I\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (field = jni->GetFieldID(klass, \"depth\", \"I\")) != nullptr))\n@@ -122,1 +122,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (methodRun = jni->GetMethodID(klass, \"run\", \"()V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (methodRun = jni->GetMethodID(klass, \"run\", \"()V\")) != nullptr))\n@@ -127,1 +127,1 @@\n-            jni->GetMethodID(klass, \"catcher\", \"(II)V\")) != NULL))\n+            jni->GetMethodID(klass, \"catcher\", \"(II)V\")) != nullptr))\n@@ -131,1 +131,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (methodThrower= jni->GetMethodID(klass, \"thrower\", \"(I)V\")) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (methodThrower= jni->GetMethodID(klass, \"thrower\", \"(I)V\")) != nullptr))\n@@ -158,2 +158,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -161,1 +161,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(frameBuffer[frameCount-1-i].method, &name, &signature, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(frameBuffer[frameCount-1-i].method, &name, &signature, nullptr)))\n@@ -166,1 +166,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -168,1 +168,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -176,2 +176,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -179,1 +179,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(frameBuffer[frameCount-1-i].method, &name, &signature, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(frameBuffer[frameCount-1-i].method, &name, &signature, nullptr)))\n@@ -184,1 +184,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -186,1 +186,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -189,1 +189,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(method, &name, &signature, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->GetMethodName(method, &name, &signature, nullptr)))\n@@ -199,1 +199,1 @@\n-    jmethodID method = NULL;\n+    jmethodID method = nullptr;\n@@ -291,1 +291,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -303,1 +303,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -312,1 +312,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP07\/sp07t002\/sp07t002.cpp","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-static ObjectDesc* objectDescList = NULL;\n+static ObjectDesc* objectDescList = nullptr;\n@@ -98,2 +98,0 @@\n-#define DEREF(ptr) (((ptr) == NULL ? 0 : *(ptr)))\n-\n@@ -178,1 +176,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (*debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (*debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -187,1 +185,1 @@\n-            jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -203,1 +201,1 @@\n-            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -230,1 +228,1 @@\n-    jfieldID rootObjectField = NULL;\n+    jfieldID rootObjectField = nullptr;\n@@ -233,1 +231,1 @@\n-            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -242,1 +240,1 @@\n-            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -251,1 +249,1 @@\n-            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -261,1 +259,1 @@\n-            jni->GetFieldID(chainObjectClass, NEXT_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(chainObjectClass, NEXT_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -270,1 +268,1 @@\n-            jni->GetStaticObjectField(debugeeClass, rootObjectField)) != NULL)) {\n+            jni->GetStaticObjectField(debugeeClass, rootObjectField)) != nullptr)) {\n@@ -277,1 +275,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (*rootObjectPtr = jni->NewGlobalRef(*rootObjectPtr)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (*rootObjectPtr = jni->NewGlobalRef(*rootObjectPtr)) != nullptr)) {\n@@ -299,1 +297,1 @@\n-    jobject nextObj = NULL;\n+    jobject nextObj = nullptr;\n@@ -309,1 +307,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (nextObj = jni->GetObjectField(currObj, refField)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (nextObj = jni->GetObjectField(currObj, refField)) != nullptr)) {\n@@ -353,3 +351,3 @@\n-    jclass   debugeeClass          = NULL;\n-    jclass   rootObjectClass       = NULL;\n-    jclass   chainObjectClass      = NULL;\n+    jclass   debugeeClass          = nullptr;\n+    jclass   rootObjectClass       = nullptr;\n+    jclass   chainObjectClass      = nullptr;\n@@ -357,3 +355,3 @@\n-    jfieldID reachableChainField   = NULL;\n-    jfieldID unreachableChainField = NULL;\n-    jfieldID nextField             = NULL;\n+    jfieldID reachableChainField   = nullptr;\n+    jfieldID unreachableChainField = nullptr;\n+    jfieldID nextField             = nullptr;\n@@ -507,1 +505,1 @@\n-    if (rootObject != NULL) {\n+    if (rootObject != nullptr) {\n@@ -512,1 +510,1 @@\n-    if (objectDescList != NULL) {\n+    if (objectDescList != nullptr) {\n@@ -580,1 +578,1 @@\n-    if (tag_ptr != NULL && *tag_ptr != 0) {\n+    if (tag_ptr != nullptr && *tag_ptr != 0) {\n@@ -727,1 +725,1 @@\n-    jobject rootObject = NULL;\n+    jobject rootObject = nullptr;\n@@ -763,1 +761,1 @@\n-                                                  (jclass) NULL, \/* class          *\/\n+                                                  (jclass) nullptr, \/* class          *\/\n@@ -806,1 +804,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -817,1 +815,1 @@\n-    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL)) {\n+    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr)) {\n@@ -832,1 +830,1 @@\n-    heapCallbacks.heap_iteration_callback         = NULL;\n+    heapCallbacks.heap_iteration_callback         = nullptr;\n@@ -838,1 +836,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL))) {\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr))) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref001\/followref001.cpp","additions":29,"deletions":31,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-static ObjectDesc* objectDescList = NULL;\n+static ObjectDesc* objectDescList = nullptr;\n@@ -95,2 +95,0 @@\n-#define DEREF(ptr) (((ptr) == NULL ? 0 : *(ptr)))\n-\n@@ -113,1 +111,1 @@\n-    jobject obj = NULL;\n+    jobject obj = nullptr;\n@@ -122,1 +120,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetObjectField(firstObject, firstField)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetObjectField(firstObject, firstField)) != nullptr)) {\n@@ -162,3 +160,3 @@\n-    jclass debugeeClass = NULL;\n-    jclass rootObjectClass = NULL;\n-    jclass chainObjectClass = NULL;\n+    jclass debugeeClass = nullptr;\n+    jclass rootObjectClass = nullptr;\n+    jclass chainObjectClass = nullptr;\n@@ -166,4 +164,4 @@\n-    jfieldID objectField = NULL;\n-    jfieldID reachableChainField = NULL;\n-    jfieldID unreachableChainField = NULL;\n-    jfieldID tailField = NULL;\n+    jfieldID objectField = nullptr;\n+    jfieldID reachableChainField = nullptr;\n+    jfieldID unreachableChainField = nullptr;\n+    jfieldID tailField = nullptr;\n@@ -197,1 +195,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -205,1 +203,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (rootObjectClass = jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (rootObjectClass = jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -219,1 +217,1 @@\n-            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -233,1 +231,1 @@\n-            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -242,1 +240,1 @@\n-            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -251,1 +249,1 @@\n-            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -260,1 +258,1 @@\n-            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -269,1 +267,1 @@\n-            jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+            jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -276,1 +274,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (*rootObject = jni->NewGlobalRef(*rootObject)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (*rootObject = jni->NewGlobalRef(*rootObject)) != nullptr)) {\n@@ -397,1 +395,1 @@\n-    if (rootObject != NULL) {\n+    if (rootObject != nullptr) {\n@@ -402,1 +400,1 @@\n-    if (objectDescList != NULL) {\n+    if (objectDescList != nullptr) {\n@@ -463,2 +461,2 @@\n-    if (tag_ptr == NULL) {\n-        NSK_COMPLAIN1(\"NULL tag_ptr is passed to heapReferenceCallback:\"\n+    if (tag_ptr == nullptr) {\n+        NSK_COMPLAIN1(\"null tag_ptr is passed to heapReferenceCallback:\"\n@@ -469,1 +467,1 @@\n-    if (tag_ptr != NULL && *tag_ptr != 0) {\n+    if (tag_ptr != nullptr && *tag_ptr != 0) {\n@@ -604,1 +602,1 @@\n-    jobject rootObject = NULL;\n+    jobject rootObject = nullptr;\n@@ -638,1 +636,1 @@\n-                                                      (jclass) NULL, \/* class          *\/\n+                                                      (jclass) nullptr, \/* class          *\/\n@@ -671,1 +669,1 @@\n-                                                      (jclass) NULL, \/* class          *\/\n+                                                      (jclass) nullptr, \/* class          *\/\n@@ -717,1 +715,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -729,1 +727,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -743,1 +741,1 @@\n-    heapCallbacks.heap_iteration_callback         = NULL;\n+    heapCallbacks.heap_iteration_callback         = nullptr;\n@@ -749,1 +747,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref002\/followref002.cpp","additions":32,"deletions":34,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-static ObjectDesc* objectDescList = NULL;\n+static ObjectDesc* objectDescList = nullptr;\n@@ -121,3 +121,0 @@\n-#define DEREF(ptr) (((ptr) == NULL ? 0 : *(ptr)))\n-\n-\n@@ -132,1 +129,1 @@\n-    jobject obj = NULL;\n+    jobject obj = nullptr;\n@@ -141,1 +138,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetObjectField(firstObject, firstField)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (obj = jni->GetObjectField(firstObject, firstField)) != nullptr)) {\n@@ -167,3 +164,3 @@\n-    jclass debugeeClass = NULL;\n-    jclass rootObjectClass = NULL;\n-    jclass chainObjectClass = NULL;\n+    jclass debugeeClass = nullptr;\n+    jclass rootObjectClass = nullptr;\n+    jclass chainObjectClass = nullptr;\n@@ -171,4 +168,4 @@\n-    jfieldID objectField = NULL;\n-    jfieldID reachableChainField = NULL;\n-    jfieldID unreachableChainField = NULL;\n-    jfieldID tailField = NULL;\n+    jfieldID objectField = nullptr;\n+    jfieldID reachableChainField = nullptr;\n+    jfieldID unreachableChainField = nullptr;\n+    jfieldID tailField = nullptr;\n@@ -201,1 +198,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (debugeeClass = jni->FindClass(DEBUGEE_CLASS_NAME)) != nullptr)) {\n@@ -209,1 +206,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (rootObjectClass = jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (rootObjectClass = jni->FindClass(ROOT_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -224,1 +221,1 @@\n-            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(CHAIN_OBJECT_CLASS_NAME)) != nullptr)) {\n@@ -240,1 +237,1 @@\n-            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetStaticFieldID(debugeeClass, OBJECT_FIELD_NAME, ROOT_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -249,1 +246,1 @@\n-            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, REACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -258,1 +255,1 @@\n-            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(rootObjectClass, UNREACHABLE_CHAIN_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -267,1 +264,1 @@\n-            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != NULL)) {\n+            jni->GetFieldID(chainObjectClass, TAIL_FIELD_NAME, CHAIN_OBJECT_CLASS_SIG)) != nullptr)) {\n@@ -276,1 +273,1 @@\n-            jni->GetStaticObjectField(debugeeClass, objectField)) != NULL)) {\n+            jni->GetStaticObjectField(debugeeClass, objectField)) != nullptr)) {\n@@ -283,1 +280,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (*rootObject = jni->NewGlobalRef(*rootObject)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (*rootObject = jni->NewGlobalRef(*rootObject)) != nullptr)) {\n@@ -397,1 +394,1 @@\n-    if (rootObject != NULL) {\n+    if (rootObject != nullptr) {\n@@ -402,1 +399,1 @@\n-    if (objectDescList != NULL) {\n+    if (objectDescList != nullptr) {\n@@ -472,2 +469,2 @@\n-    if (method == NULL && ref_kind != JVMTI_HEAP_REFERENCE_JNI_LOCAL) {\n-        NSK_COMPLAIN0(\"methodID must not be NULL\\n\");\n+    if (method == nullptr && ref_kind != JVMTI_HEAP_REFERENCE_JNI_LOCAL) {\n+        NSK_COMPLAIN0(\"methodID must not be null\\n\");\n@@ -593,1 +590,1 @@\n-    jmethodID method   = (jmethodID) NULL;\n+    jmethodID method   = (jmethodID) nullptr;\n@@ -673,2 +670,2 @@\n-    if (tag_ptr == NULL) {\n-        NSK_COMPLAIN1(\"NULL tag_ptr is passed to heapReferenceCallback:\"\n+    if (tag_ptr == nullptr) {\n+        NSK_COMPLAIN1(\"null tag_ptr is passed to heapReferenceCallback:\"\n@@ -679,1 +676,1 @@\n-    if (tag_ptr != NULL && tag != 0) {\n+    if (tag_ptr != nullptr && tag != 0) {\n@@ -881,1 +878,1 @@\n-    jthread *threads = NULL;\n+    jthread *threads = nullptr;\n@@ -894,1 +891,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -905,1 +902,1 @@\n-    jobject rootObject = NULL;\n+    jobject rootObject = nullptr;\n@@ -942,2 +939,2 @@\n-                                                      (jclass)  NULL, \/* class          *\/\n-                                                      (jobject) NULL, \/* initial_object *\/\n+                                                      (jclass)  nullptr, \/* class          *\/\n+                                                      (jobject) nullptr, \/* initial_object *\/\n@@ -980,2 +977,2 @@\n-                                                      (jclass)  NULL, \/* class          *\/\n-                                                      (jobject) NULL, \/* initial_object *\/\n+                                                      (jclass)  nullptr, \/* class          *\/\n+                                                      (jobject) nullptr, \/* initial_object *\/\n@@ -1029,1 +1026,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -1038,1 +1035,1 @@\n-        if (infoOpt != NULL) {\n+        if (infoOpt != nullptr) {\n@@ -1064,1 +1061,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -1078,1 +1075,1 @@\n-    heapCallbacks.heap_iteration_callback         = NULL;\n+    heapCallbacks.heap_iteration_callback         = nullptr;\n@@ -1084,1 +1081,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref003\/followref003.cpp","additions":40,"deletions":43,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,1 +149,1 @@\n-    if  (!NSK_JNI_VERIFY(jni, (klass = jni->FindClass(JAVA_LANG_STRING_CLASS_NAME)) != NULL)) {\n+    if  (!NSK_JNI_VERIFY(jni, (klass = jni->FindClass(JAVA_LANG_STRING_CLASS_NAME)) != nullptr)) {\n@@ -154,1 +154,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (g_jniGlobalRef = jni->NewGlobalRef(klass)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (g_jniGlobalRef = jni->NewGlobalRef(klass)) != nullptr)) {\n@@ -158,1 +158,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (g_jniWeakGlobalRef = jni->NewWeakGlobalRef(klass)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (g_jniWeakGlobalRef = jni->NewWeakGlobalRef(klass)) != nullptr)) {\n@@ -183,2 +183,2 @@\n-                                      NULL,                     \/* class *\/\n-                                      NULL,                     \/* inital object *\/\n+                                      nullptr,                     \/* class *\/\n+                                      nullptr,                     \/* inital object *\/\n@@ -221,1 +221,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -229,1 +229,1 @@\n-    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL)) {\n+    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr)) {\n@@ -235,1 +235,1 @@\n-    g_heapCallbacks.heap_iteration_callback         = NULL;\n+    g_heapCallbacks.heap_iteration_callback         = nullptr;\n@@ -253,1 +253,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL))) {\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr))) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref004\/followref004.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,2 @@\n-                                      NULL,                     \/* class *\/\n-                                      NULL,                     \/* inital object *\/\n+                                      nullptr,                     \/* class *\/\n+                                      nullptr,                     \/* inital object *\/\n@@ -60,1 +60,1 @@\n-                                        NULL,                     \/* class *\/\n+                                        nullptr,                     \/* class *\/\n@@ -118,1 +118,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -126,1 +126,1 @@\n-    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL)) {\n+    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr)) {\n@@ -140,1 +140,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL))) {\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr))) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref005\/followref005.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-                                      NULL,                     \/* inital object *\/\n+                                      nullptr,                     \/* inital object *\/\n@@ -66,1 +66,1 @@\n-    \/\/ Or it may treat the object as NULL, and follow all references.\n+    \/\/ Or it may treat the object as nullptr, and follow all references.\n@@ -71,5 +71,5 @@\n-    emptyHeapCallbacks.heap_iteration_callback = NULL;\n-    emptyHeapCallbacks.heap_reference_callback = NULL;\n-    emptyHeapCallbacks.primitive_field_callback = NULL;\n-    emptyHeapCallbacks.array_primitive_value_callback = NULL;\n-    emptyHeapCallbacks.string_primitive_value_callback = NULL;\n+    emptyHeapCallbacks.heap_iteration_callback = nullptr;\n+    emptyHeapCallbacks.heap_reference_callback = nullptr;\n+    emptyHeapCallbacks.primitive_field_callback = nullptr;\n+    emptyHeapCallbacks.array_primitive_value_callback = nullptr;\n+    emptyHeapCallbacks.string_primitive_value_callback = nullptr;\n@@ -77,1 +77,1 @@\n-                                      NULL,                   \/\/ class\n+                                      nullptr,                   \/\/ class\n@@ -90,3 +90,3 @@\n-                                      NULL,         \/* class *\/\n-                                      NULL,         \/* inital object *\/\n-                                      NULL,\n+                                      nullptr,         \/* class *\/\n+                                      nullptr,         \/* inital object *\/\n+                                      nullptr,\n@@ -108,1 +108,1 @@\n-    NSK_DISPLAY0(\"GetTag: NULL object pointer:\");\n+    NSK_DISPLAY0(\"GetTag: null object pointer:\");\n@@ -110,1 +110,1 @@\n-    retCode = jvmti->GetTag(NULL, &tag);\n+    retCode = jvmti->GetTag(nullptr, &tag);\n@@ -116,1 +116,1 @@\n-    NSK_DISPLAY0(\"GetTag: NULL tag pointer:\");\n+    NSK_DISPLAY0(\"GetTag: null tag pointer:\");\n@@ -118,1 +118,1 @@\n-    retCode = jvmti->GetTag((jobject) &g_wrongHeapCallbacks, NULL);\n+    retCode = jvmti->GetTag((jobject) &g_wrongHeapCallbacks, nullptr);\n@@ -134,1 +134,1 @@\n-    NSK_DISPLAY0(\"SetTag: NULL object pointer:\");\n+    NSK_DISPLAY0(\"SetTag: null object pointer:\");\n@@ -136,1 +136,1 @@\n-    retCode = jvmti->GetTag(NULL, &tag);\n+    retCode = jvmti->GetTag(nullptr, &tag);\n@@ -142,1 +142,1 @@\n-    NSK_DISPLAY0(\"GetTag: NULL tag pointer:\");\n+    NSK_DISPLAY0(\"GetTag: null tag pointer:\");\n@@ -154,1 +154,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->FindClass(szClassName)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->FindClass(szClassName)) != nullptr)) {\n@@ -161,1 +161,1 @@\n-                                      NULL,         \/* inital object *\/\n+                                      nullptr,         \/* inital object *\/\n@@ -214,1 +214,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -222,1 +222,1 @@\n-    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL)) {\n+    if (!NSK_VERIFY((jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr)) {\n@@ -238,1 +238,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL))) {\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr))) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/FollowReferences\/followref006\/followref006.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-static jmethodID midActiveMethod = NULL;\n+static jmethodID midActiveMethod = nullptr;\n@@ -87,1 +87,1 @@\n-    if (clazz == NULL) {\n+    if (clazz == nullptr) {\n@@ -93,1 +93,1 @@\n-    if (midActiveMethod == NULL) {\n+    if (midActiveMethod == nullptr) {\n@@ -140,1 +140,1 @@\n-        JVMTI_EVENT_METHOD_EXIT, NULL);\n+        JVMTI_EVENT_METHOD_EXIT, nullptr);\n@@ -150,1 +150,1 @@\n-        JVMTI_EVENT_FRAME_POP, NULL);\n+        JVMTI_EVENT_FRAME_POP, nullptr);\n@@ -200,1 +200,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretbase\/earlyretbase.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -44,4 +44,4 @@\n-static jmethodID midCheckPoint      = NULL;\n-static jmethodID midRun             = NULL;\n-static jmethodID midCountDownFloat  = NULL;\n-static jmethodID midCountDownDouble = NULL;\n+static jmethodID midCheckPoint      = nullptr;\n+static jmethodID midRun             = nullptr;\n+static jmethodID midCountDownFloat  = nullptr;\n+static jmethodID midCountDownDouble = nullptr;\n@@ -73,1 +73,1 @@\n-    jvmtiLocalVariableEntry *table = NULL;\n+    jvmtiLocalVariableEntry *table = nullptr;\n@@ -108,1 +108,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -128,1 +128,1 @@\n-    if (sigClass == NULL || strcmp(sigClass, cls_exp) != 0) {\n+    if (sigClass == nullptr || strcmp(sigClass, cls_exp) != 0) {\n@@ -133,1 +133,1 @@\n-    if (name == NULL || strcmp(name, name_exp[methidx]) != 0) {\n+    if (name == nullptr || strcmp(name, name_exp[methidx]) != 0) {\n@@ -138,1 +138,1 @@\n-    if (sig == NULL || strcmp(sig, sig_exp[methidx]) != 0) {\n+    if (sig == nullptr || strcmp(sig, sig_exp[methidx]) != 0) {\n@@ -156,1 +156,1 @@\n-    if (sigClass != NULL) {\n+    if (sigClass != nullptr) {\n@@ -159,1 +159,1 @@\n-    if (name != NULL) {\n+    if (name != nullptr) {\n@@ -162,1 +162,1 @@\n-    if (sig != NULL) {\n+    if (sig != nullptr) {\n@@ -165,1 +165,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -310,1 +310,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -317,1 +317,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -373,1 +373,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -386,1 +386,1 @@\n-    if (midRun == NULL) {\n+    if (midRun == nullptr) {\n@@ -392,1 +392,1 @@\n-    if (midCheckPoint == NULL) {\n+    if (midCheckPoint == nullptr) {\n@@ -398,1 +398,1 @@\n-    if (midCountDownFloat == NULL) {\n+    if (midCountDownFloat == nullptr) {\n@@ -404,1 +404,1 @@\n-    if (midCountDownDouble == NULL) {\n+    if (midCountDownDouble == nullptr) {\n@@ -417,1 +417,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretfp\/earlyretfp.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -44,2 +44,2 @@\n-static jmethodID midCheckPoint = NULL;\n-static jmethodID midRun        = NULL;\n+static jmethodID midCheckPoint = nullptr;\n+static jmethodID midRun        = nullptr;\n@@ -47,5 +47,5 @@\n-static jmethodID midCountDownInt     = NULL;\n-static jmethodID midCountDownShort   = NULL;\n-static jmethodID midCountDownChar    = NULL;\n-static jmethodID midCountDownByte    = NULL;\n-static jmethodID midCountDownBoolean = NULL;\n+static jmethodID midCountDownInt     = nullptr;\n+static jmethodID midCountDownShort   = nullptr;\n+static jmethodID midCountDownChar    = nullptr;\n+static jmethodID midCountDownByte    = nullptr;\n+static jmethodID midCountDownBoolean = nullptr;\n@@ -81,1 +81,1 @@\n-    jvmtiLocalVariableEntry *table = NULL;\n+    jvmtiLocalVariableEntry *table = nullptr;\n@@ -109,1 +109,1 @@\n-    if (sigClass == NULL || strcmp(sigClass, cls_exp) != 0) {\n+    if (sigClass == nullptr || strcmp(sigClass, cls_exp) != 0) {\n@@ -114,1 +114,1 @@\n-    if (name == NULL || strcmp(name, name_exp[methidx]) != 0) {\n+    if (name == nullptr || strcmp(name, name_exp[methidx]) != 0) {\n@@ -119,1 +119,1 @@\n-    if (sig == NULL || strcmp(sig, sign_exp[methidx]) != 0) {\n+    if (sig == nullptr || strcmp(sig, sign_exp[methidx]) != 0) {\n@@ -139,1 +139,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -165,1 +165,1 @@\n-    if (sigClass != NULL) {\n+    if (sigClass != nullptr) {\n@@ -168,1 +168,1 @@\n-    if (name != NULL) {\n+    if (name != nullptr) {\n@@ -171,1 +171,1 @@\n-    if (sig != NULL) {\n+    if (sig != nullptr) {\n@@ -174,1 +174,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -316,1 +316,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -323,1 +323,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -378,1 +378,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -391,1 +391,1 @@\n-    if (midRun == NULL) {\n+    if (midRun == nullptr) {\n@@ -397,1 +397,1 @@\n-    if (midCheckPoint == NULL) {\n+    if (midCheckPoint == nullptr) {\n@@ -403,1 +403,1 @@\n-    if (midCheckPoint == NULL) {\n+    if (midCheckPoint == nullptr) {\n@@ -409,1 +409,1 @@\n-    if (midCountDownShort == NULL) {\n+    if (midCountDownShort == nullptr) {\n@@ -415,1 +415,1 @@\n-    if (midCountDownChar == NULL) {\n+    if (midCountDownChar == nullptr) {\n@@ -421,1 +421,1 @@\n-    if (midCountDownByte == NULL) {\n+    if (midCountDownByte == nullptr) {\n@@ -427,1 +427,1 @@\n-    if (midCountDownBoolean == NULL) {\n+    if (midCountDownBoolean == nullptr) {\n@@ -440,1 +440,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretint\/earlyretint.cpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -45,3 +45,3 @@\n-static jmethodID midRun            = NULL;\n-static jmethodID midCountDownLong  = NULL;\n-static jmethodID midCheckPoint     = NULL;\n+static jmethodID midRun            = nullptr;\n+static jmethodID midCountDownLong  = nullptr;\n+static jmethodID midCheckPoint     = nullptr;\n@@ -67,1 +67,1 @@\n-    jvmtiLocalVariableEntry *table = NULL;\n+    jvmtiLocalVariableEntry *table = nullptr;\n@@ -102,1 +102,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -122,1 +122,1 @@\n-    if (sigClass == NULL || strcmp(sigClass, cls_exp) != 0) {\n+    if (sigClass == nullptr || strcmp(sigClass, cls_exp) != 0) {\n@@ -127,1 +127,1 @@\n-    if (name == NULL || strcmp(name, name_exp) != 0) {\n+    if (name == nullptr || strcmp(name, name_exp) != 0) {\n@@ -132,1 +132,1 @@\n-    if (sig == NULL || strcmp(sig, sig_exp) != 0) {\n+    if (sig == nullptr || strcmp(sig, sig_exp) != 0) {\n@@ -149,1 +149,1 @@\n-    if (sigClass != NULL) {\n+    if (sigClass != nullptr) {\n@@ -152,1 +152,1 @@\n-    if (name != NULL) {\n+    if (name != nullptr) {\n@@ -155,1 +155,1 @@\n-    if (sig != NULL) {\n+    if (sig != nullptr) {\n@@ -158,1 +158,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -297,1 +297,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -304,1 +304,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -360,1 +360,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -373,1 +373,1 @@\n-    if (midRun == NULL) {\n+    if (midRun == nullptr) {\n@@ -379,1 +379,1 @@\n-    if (midCheckPoint == NULL) {\n+    if (midCheckPoint == nullptr) {\n@@ -385,1 +385,1 @@\n-    if (midCountDownLong == NULL) {\n+    if (midCountDownLong == nullptr) {\n@@ -398,1 +398,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretlong\/earlyretlong.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -45,3 +45,3 @@\n-static jmethodID midRun             = NULL;\n-static jmethodID midCountDownObject = NULL;\n-static jmethodID midCheckPoint      = NULL;\n+static jmethodID midRun             = nullptr;\n+static jmethodID midCountDownObject = nullptr;\n+static jmethodID midCheckPoint      = nullptr;\n@@ -55,1 +55,1 @@\n-static jobject val_exp = NULL;\n+static jobject val_exp = nullptr;\n@@ -67,1 +67,1 @@\n-    jvmtiLocalVariableEntry *table = NULL;\n+    jvmtiLocalVariableEntry *table = nullptr;\n@@ -102,1 +102,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -122,1 +122,1 @@\n-    if (sigClass == NULL || strcmp(sigClass, cls_exp) != 0) {\n+    if (sigClass == nullptr || strcmp(sigClass, cls_exp) != 0) {\n@@ -127,1 +127,1 @@\n-    if (name == NULL || strcmp(name, name_exp) != 0) {\n+    if (name == nullptr || strcmp(name, name_exp) != 0) {\n@@ -132,1 +132,1 @@\n-    if (sig == NULL || strcmp(sig, sig_exp) != 0) {\n+    if (sig == nullptr || strcmp(sig, sig_exp) != 0) {\n@@ -149,1 +149,1 @@\n-    if (sigClass != NULL) {\n+    if (sigClass != nullptr) {\n@@ -152,1 +152,1 @@\n-    if (name != NULL) {\n+    if (name != nullptr) {\n@@ -155,1 +155,1 @@\n-    if (sig != NULL) {\n+    if (sig != nullptr) {\n@@ -158,1 +158,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -295,1 +295,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -302,1 +302,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -357,1 +357,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -370,1 +370,1 @@\n-    if (midRun == NULL) {\n+    if (midRun == nullptr) {\n@@ -376,1 +376,1 @@\n-    if (midCheckPoint == NULL) {\n+    if (midCheckPoint == nullptr) {\n@@ -382,1 +382,1 @@\n-    if (midCountDownObject == NULL) {\n+    if (midCountDownObject == nullptr) {\n@@ -395,1 +395,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretobj\/earlyretobj.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -44,3 +44,3 @@\n-static jmethodID midRun             = NULL;\n-static jmethodID midCountDownString = NULL;\n-static jmethodID midCheckPoint      = NULL;\n+static jmethodID midRun             = nullptr;\n+static jmethodID midCountDownString = nullptr;\n+static jmethodID midCheckPoint      = nullptr;\n@@ -54,1 +54,1 @@\n-static jstring str_exp = NULL;\n+static jstring str_exp = nullptr;\n@@ -66,1 +66,1 @@\n-    jvmtiLocalVariableEntry *table = NULL;\n+    jvmtiLocalVariableEntry *table = nullptr;\n@@ -101,1 +101,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -121,1 +121,1 @@\n-    if (sigClass == NULL || strcmp(sigClass, cls_exp) != 0) {\n+    if (sigClass == nullptr || strcmp(sigClass, cls_exp) != 0) {\n@@ -126,1 +126,1 @@\n-    if (name == NULL || strcmp(name, name_exp) != 0) {\n+    if (name == nullptr || strcmp(name, name_exp) != 0) {\n@@ -131,1 +131,1 @@\n-    if (sig == NULL || strcmp(sig, sig_exp) != 0) {\n+    if (sig == nullptr || strcmp(sig, sig_exp) != 0) {\n@@ -148,1 +148,1 @@\n-    if (sigClass != NULL) {\n+    if (sigClass != nullptr) {\n@@ -151,1 +151,1 @@\n-    if (name != NULL) {\n+    if (name != nullptr) {\n@@ -154,1 +154,1 @@\n-    if (sig != NULL) {\n+    if (sig != nullptr) {\n@@ -157,1 +157,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -294,1 +294,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -301,1 +301,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -356,1 +356,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -369,1 +369,1 @@\n-    if (midRun == NULL) {\n+    if (midRun == nullptr) {\n@@ -375,1 +375,1 @@\n-    if (midCheckPoint == NULL) {\n+    if (midCheckPoint == nullptr) {\n@@ -381,1 +381,1 @@\n-    if (midCountDownString == NULL) {\n+    if (midCountDownString == nullptr) {\n@@ -394,1 +394,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretstr\/earlyretstr.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -43,2 +43,2 @@\n-static jmethodID midCheckPoint = NULL;\n-static jmethodID midRun = NULL;\n+static jmethodID midCheckPoint = nullptr;\n+static jmethodID midRun = nullptr;\n@@ -60,1 +60,1 @@\n-    jvmtiLocalVariableEntry *table = NULL;\n+    jvmtiLocalVariableEntry *table = nullptr;\n@@ -95,1 +95,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -115,1 +115,1 @@\n-    if (sigClass == NULL || strcmp(sigClass, cls_exp) != 0) {\n+    if (sigClass == nullptr || strcmp(sigClass, cls_exp) != 0) {\n@@ -120,1 +120,1 @@\n-    if (name == NULL || strcmp(name, name_exp) != 0) {\n+    if (name == nullptr || strcmp(name, name_exp) != 0) {\n@@ -125,1 +125,1 @@\n-    if (sig == NULL || strcmp(sig, sig_exp) != 0) {\n+    if (sig == nullptr || strcmp(sig, sig_exp) != 0) {\n@@ -142,1 +142,1 @@\n-    if (sigClass != NULL) {\n+    if (sigClass != nullptr) {\n@@ -145,1 +145,1 @@\n-    if (name != NULL) {\n+    if (name != nullptr) {\n@@ -148,1 +148,1 @@\n-    if (sig != NULL) {\n+    if (sig != nullptr) {\n@@ -151,1 +151,1 @@\n-    if (table != NULL) {\n+    if (table != nullptr) {\n@@ -244,1 +244,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -251,1 +251,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -303,1 +303,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -315,1 +315,1 @@\n-    if (midRun == NULL) {\n+    if (midRun == nullptr) {\n@@ -321,1 +321,1 @@\n-    if (midCheckPoint == NULL) {\n+    if (midCheckPoint == nullptr) {\n@@ -334,1 +334,1 @@\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n+        JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/ForceEarlyReturn\/earlyretvoid\/earlyretvoid.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,4 +67,4 @@\n-static jvmtiStackInfo  *stack_buf1    = NULL;\n-static jvmtiStackInfo  *stack_buf2    = NULL;\n-static jthread         *thread_list   = NULL;\n-static jvmtiThreadInfo *thread_info   = NULL;\n+static jvmtiStackInfo  *stack_buf1    = nullptr;\n+static jvmtiStackInfo  *stack_buf2    = nullptr;\n+static jthread         *thread_list   = nullptr;\n+static jvmtiThreadInfo *thread_info   = nullptr;\n@@ -194,1 +194,1 @@\n-    if (thr_info->name != NULL) {\n+    if (thr_info->name != nullptr) {\n@@ -197,1 +197,1 @@\n-        printf(\"compare stack #%d: thread is NULL\\n\", ti);\n+        printf(\"compare stack #%d: thread is null\\n\", ti);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/GetAllStackTraces\/getallstktr001\/getallstktr001.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n-static jvmtiEnv *jvmti         = NULL;\n-static jmethodID midCheckPoint = NULL;\n+static jvmtiEnv *jvmti         = nullptr;\n+static jmethodID midCheckPoint = nullptr;\n@@ -54,1 +54,1 @@\n-    unsigned char *cp_bytes    = NULL;\n+    unsigned char *cp_bytes    = nullptr;\n@@ -105,1 +105,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -154,1 +154,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -166,1 +166,1 @@\n-    if (midCheckPoint == NULL) {\n+    if (midCheckPoint == nullptr) {\n@@ -178,1 +178,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/GetConstantPool\/getcpool001\/getcpool001.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -59,1 +59,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -64,1 +64,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -100,1 +100,1 @@\n-    jvmtiLineNumberEntry *table = NULL;\n+    jvmtiLineNumberEntry *table = nullptr;\n@@ -135,1 +135,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -148,1 +148,1 @@\n-    if (interf == NULL) {\n+    if (interf == nullptr) {\n@@ -154,1 +154,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -162,1 +162,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -173,1 +173,1 @@\n-    if (abstr == NULL) {\n+    if (abstr == nullptr) {\n@@ -179,1 +179,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -187,1 +187,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -198,1 +198,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -206,1 +206,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -214,1 +214,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -225,1 +225,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -233,1 +233,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/GetLineNumberTable\/linetab004\/linetab004.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -41,2 +41,2 @@\n-static jmethodID mid = NULL;\n-static jvmtiLocalVariableEntry *table = NULL;\n+static jmethodID mid = nullptr;\n+static jvmtiLocalVariableEntry *table = nullptr;\n@@ -143,1 +143,1 @@\n-    jmethodID frame_method = NULL;\n+    jmethodID frame_method = nullptr;\n@@ -184,1 +184,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -189,1 +189,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -236,1 +236,1 @@\n-    jobject obj = NULL;\n+    jobject obj = nullptr;\n@@ -241,1 +241,1 @@\n-    err = jvmti->GetLocalInstance(NULL, 0, &obj);\n+    err = jvmti->GetLocalInstance(nullptr, 0, &obj);\n@@ -253,1 +253,1 @@\n-    err = jvmti->GetLocalInstance(NULL, 1, &obj);\n+    err = jvmti->GetLocalInstance(nullptr, 1, &obj);\n@@ -269,1 +269,1 @@\n-    jobject obj = NULL;\n+    jobject obj = nullptr;\n@@ -273,1 +273,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -280,1 +280,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -294,1 +294,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, nullptr);\n@@ -302,1 +302,1 @@\n-    err = jvmti->GetLocalInstance(NULL, 0, &obj);\n+    err = jvmti->GetLocalInstance(nullptr, 0, &obj);\n@@ -310,1 +310,1 @@\n-    err = jvmti->GetLocalInstance(NULL, 1, &obj);\n+    err = jvmti->GetLocalInstance(nullptr, 1, &obj);\n@@ -332,1 +332,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -340,1 +340,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/GetLocalVariable\/getlocal003\/getlocal003.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -64,1 +64,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -69,1 +69,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -108,1 +108,1 @@\n-    jmethodID mid = NULL;\n+    jmethodID mid = nullptr;\n@@ -110,1 +110,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -117,1 +117,1 @@\n-    if (mid == NULL) {\n+    if (mid == nullptr) {\n@@ -159,1 +159,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/GetLocalVariable\/getlocal004\/getlocal004.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -57,1 +57,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -62,1 +62,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -105,3 +105,3 @@\n-    jmethodID* methods_ptr = NULL;\n-    char* name_ptr = NULL;\n-    char* sign_ptr = NULL;\n+    jmethodID* methods_ptr = nullptr;\n+    char* name_ptr = nullptr;\n+    char* sign_ptr = nullptr;\n@@ -121,1 +121,1 @@\n-                                    &sign_ptr, (char **) NULL);\n+                                    &sign_ptr, nullptr);\n@@ -163,3 +163,3 @@\n-    jfieldID* fields_ptr = NULL;\n-    char* name_ptr = NULL;\n-    char* sign_ptr = NULL;\n+    jfieldID* fields_ptr = nullptr;\n+    char* name_ptr = nullptr;\n+    char* sign_ptr = nullptr;\n@@ -168,1 +168,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -184,1 +184,1 @@\n-                                    &sign_ptr, (char **) NULL);\n+                                    &sign_ptr, nullptr);\n@@ -225,1 +225,1 @@\n-    char* class_sign = NULL;\n+    char* class_sign = nullptr;\n@@ -231,1 +231,1 @@\n-    err = jvmti->GetClassSignature(cls, &class_sign, (char **) NULL);\n+    err = jvmti->GetClassSignature(cls, &class_sign, nullptr);\n@@ -252,1 +252,1 @@\n-    err = jvmti->GetClassSignature(klass, &class_sign, (char **) NULL);\n+    err = jvmti->GetClassSignature(klass, &class_sign, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/IsSynthetic\/issynth001\/issynth001.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-  const char* sname = env->GetStringUTFChars(name, NULL);\n+  const char* sname = env->GetStringUTFChars(name, nullptr);\n@@ -105,1 +105,1 @@\n-    ret = jvmti_env->GetMethodName(mid, &mname, &signature, NULL);\n+    ret = jvmti_env->GetMethodName(mid, &mname, &signature, nullptr);\n@@ -164,1 +164,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n@@ -167,1 +167,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n@@ -170,1 +170,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, nullptr);\n@@ -278,1 +278,1 @@\n-    ret = jvmti->GetClassSignature(klass, &clname, NULL);\n+    ret = jvmti->GetClassSignature(klass, &clname, nullptr);\n@@ -285,1 +285,1 @@\n-    ret = jvmti->GetMethodName(mid, &mname, &signature, NULL);\n+    ret = jvmti->GetMethodName(mid, &mname, &signature, nullptr);\n@@ -299,1 +299,1 @@\n-    jvmtiFrameInfo *stack_buffer = NULL;\n+    jvmtiFrameInfo *stack_buffer = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/MethodBind\/JvmtiTest\/JvmtiTest.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,2 +198,2 @@\n-    jvmtiFrameInfo *stack_buffer = NULL;\n-    jvmtiFrameInfo *compare_buffer = NULL;\n+    jvmtiFrameInfo *stack_buffer = nullptr;\n+    jvmtiFrameInfo *compare_buffer = nullptr;\n@@ -294,1 +294,1 @@\n-        ret = jvmti->GetClassSignature(klass, &clname, NULL);\n+        ret = jvmti->GetClassSignature(klass, &clname, nullptr);\n@@ -301,1 +301,1 @@\n-        ret = jvmti->GetMethodName(stack_buffer[i].method, &mname, &signature, NULL);\n+        ret = jvmti->GetMethodName(stack_buffer[i].method, &mname, &signature, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/StackTrace\/JvmtiTest\/JvmtiTest.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -124,1 +124,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -130,1 +130,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -143,1 +143,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/agentthr\/agentthr.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -54,1 +54,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -59,1 +59,1 @@\n-    if (res != JNI_OK || jvmti == NULL) {\n+    if (res != JNI_OK || jvmti == nullptr) {\n@@ -77,1 +77,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -89,2 +89,2 @@\n-    if (appClassloader == NULL) {\n-        printf(\"(GetClassLoader app) unexpected loader - NULL\\n\");\n+    if (appClassloader == nullptr) {\n+        printf(\"(GetClassLoader app) unexpected loader - null\\n\");\n@@ -102,2 +102,2 @@\n-    if (objClassloader != NULL) {\n-        printf(\"(GetClassLoader obj) unexpected loader - !NULL\\n\");\n+    if (objClassloader != nullptr) {\n+        printf(\"(GetClassLoader obj) unexpected loader - !null\\n\");\n@@ -120,1 +120,1 @@\n-          err = jvmti->GetClassSignature(k, &classSig, NULL);\n+          err = jvmti->GetClassSignature(k, &classSig, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/clsldrclss00x\/clsldrclss00x.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -66,1 +66,1 @@\n-    if (name != NULL && (strcmp(name, CLASS_NAME) == 0)) {\n+    if (name != nullptr && (strcmp(name, CLASS_NAME) == 0)) {\n@@ -71,1 +71,1 @@\n-        if (redefined_class != NULL) {\n+        if (redefined_class != nullptr) {\n@@ -109,1 +109,1 @@\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -153,1 +153,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n@@ -160,1 +160,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n@@ -176,1 +176,1 @@\n-    if (jvmti == NULL) {\n+    if (jvmti == nullptr) {\n@@ -188,1 +188,1 @@\n-    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, NULL);\n+    classDef.class_bytes = (unsigned char *) env->GetByteArrayElements(classBytes, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/events\/redefineCFLH\/JvmtiTest\/JvmtiTest.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-                enable ? (jvmtiExtensionEvent)ClassUnload : NULL);\n+                enable ? (jvmtiExtensionEvent)ClassUnload : nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/extmech\/extmech.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,1 +146,1 @@\n-    if (name != NULL && (strcmp(name, BOOT_CLASS) == 0)) {\n+    if (name != nullptr && (strcmp(name, BOOT_CLASS) == 0)) {\n@@ -152,1 +152,1 @@\n-      if (loader == NULL) {\n+      if (loader == nullptr) {\n@@ -195,1 +195,1 @@\n-        if (idx != NULL) *idx = 0;\n+        if (idx != nullptr) *idx = 0;\n@@ -217,1 +217,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, nullptr);\n@@ -220,1 +220,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n@@ -223,1 +223,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, nullptr);\n@@ -226,1 +226,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n@@ -229,1 +229,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/functions\/AddToBootstrapClassLoaderSearch\/JvmtiTest\/JvmtiTest.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/functions\/Dispose\/JvmtiTest\/JvmtiTest.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n@@ -140,1 +140,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n@@ -143,1 +143,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_START, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_START, nullptr);\n@@ -146,1 +146,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/functions\/ForceGarbageCollection\/gc\/gc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n@@ -140,1 +140,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/functions\/nosuspendMonitorInfo\/JvmtiTest\/JvmtiTest.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n@@ -139,1 +139,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n@@ -236,1 +236,1 @@\n-    jvmtiFrameInfo *stack_buffer = NULL;\n+    jvmtiFrameInfo *stack_buffer = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/functions\/nosuspendStackTrace\/JvmtiTest\/JvmtiTest.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,1 +225,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n@@ -228,1 +228,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n@@ -231,1 +231,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/functions\/rawmonitor\/rawmonitor.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -73,2 +73,2 @@\n-static MyTag *fakeRoot = NULL;\n-static MyTag *missed = NULL;\n+static MyTag *fakeRoot = nullptr;\n+static MyTag *missed = nullptr;\n@@ -85,1 +85,1 @@\n-  MyTag* new_tag = NULL;\n+  MyTag* new_tag = nullptr;\n@@ -88,1 +88,1 @@\n-  if (NULL == new_tag) {\n+  if (nullptr == new_tag) {\n@@ -98,1 +98,1 @@\n-  new_tag->ref = NULL;\n+  new_tag->ref = nullptr;\n@@ -106,2 +106,2 @@\n-  MyTag *new_tag = NULL;\n-  MyTag *class_tag = NULL;\n+  MyTag *new_tag = nullptr;\n+  MyTag *class_tag = nullptr;\n@@ -110,1 +110,1 @@\n-  jclass obj_class = NULL;\n+  jclass obj_class = nullptr;\n@@ -127,1 +127,1 @@\n-  if (class_tag != NULL && class_tag->kind != rclass) {\n+  if (class_tag != nullptr && class_tag->kind != rclass) {\n@@ -145,1 +145,1 @@\n-  if (NULL == new_ref) {\n+  if (nullptr == new_ref) {\n@@ -218,1 +218,1 @@\n-  const char* const cname = ctag != NULL ? ctag->name : \"\";\n+  const char* const cname = ctag != nullptr ? ctag->name : \"\";\n@@ -261,1 +261,1 @@\n-  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+  if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -266,1 +266,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -284,1 +284,1 @@\n-  const MyTag* const tag = newTag(rmark, (const MyTag*)(intptr_t)class_tag, size, NULL);\n+  const MyTag* const tag = newTag(rmark, (const MyTag*)(intptr_t)class_tag, size, nullptr);\n@@ -303,1 +303,1 @@\n-    MyTag* tag = newTag(kind, (MyTag*)(intptr_t)class_tag, size, NULL);\n+    MyTag* tag = newTag(kind, (MyTag*)(intptr_t)class_tag, size, nullptr);\n@@ -329,1 +329,1 @@\n-    MyTag* tag = newTag(kind, (MyTag*)(intptr_t)class_tag, size, NULL);\n+    MyTag* tag = newTag(kind, (MyTag*)(intptr_t)class_tag, size, nullptr);\n@@ -350,1 +350,1 @@\n-  MyTag* referrer = NULL;\n+  MyTag* referrer = nullptr;\n@@ -360,1 +360,1 @@\n-    MyTag* tag = newTag(kind, (MyTag*)(intptr_t)class_tag, size, NULL);\n+    MyTag* tag = newTag(kind, (MyTag*)(intptr_t)class_tag, size, nullptr);\n@@ -385,1 +385,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -390,2 +390,2 @@\n-  fakeRoot = newTag(rother, (const MyTag *)NULL, 0, \"FAKE_ROOT\");\n-  missed = newTag(rother, (const MyTag *)NULL, 0, \"MISSED\");\n+  fakeRoot = newTag(rother, nullptr, 0, \"FAKE_ROOT\");\n+  missed = newTag(rother, nullptr, 0, \"MISSED\");\n@@ -407,1 +407,1 @@\n-    err = jvmti->GetClassSignature(k, &classSig, NULL);\n+    err = jvmti->GetClassSignature(k, &classSig, nullptr);\n@@ -417,1 +417,1 @@\n-      if (*classSig == 'L' && slash != NULL) {\n+      if (*classSig == 'L' && slash != nullptr) {\n@@ -442,1 +442,1 @@\n-  env->PopLocalFrame(NULL);\n+  env->PopLocalFrame(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/heapref\/heapref.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jvmtiEnv *jvmti = NULL;\n+static jvmtiEnv *jvmti = nullptr;\n@@ -73,2 +73,2 @@\n-static MyTag *fakeRoot = NULL;\n-static MyTag *missed = NULL;\n+static MyTag *fakeRoot = nullptr;\n+static MyTag *missed = nullptr;\n@@ -85,1 +85,1 @@\n-  MyTag* new_tag = NULL;\n+  MyTag* new_tag = nullptr;\n@@ -88,1 +88,1 @@\n-  if (NULL == new_tag) {\n+  if (nullptr == new_tag) {\n@@ -98,1 +98,1 @@\n-  new_tag->ref = NULL;\n+  new_tag->ref = nullptr;\n@@ -106,2 +106,2 @@\n-  MyTag *new_tag = NULL;\n-  MyTag *class_tag = NULL;\n+  MyTag *new_tag = nullptr;\n+  MyTag *class_tag = nullptr;\n@@ -110,1 +110,1 @@\n-  jclass obj_class = NULL;\n+  jclass obj_class = nullptr;\n@@ -127,1 +127,1 @@\n-  if (class_tag != NULL && class_tag->kind != rclass) {\n+  if (class_tag != nullptr && class_tag->kind != rclass) {\n@@ -145,1 +145,1 @@\n-  if (NULL == new_ref) {\n+  if (nullptr == new_ref) {\n@@ -218,1 +218,1 @@\n-  const char* const cname = ctag != NULL ? ctag->name : \"\";\n+  const char* const cname = ctag != nullptr ? ctag->name : \"\";\n@@ -259,1 +259,1 @@\n-  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+  if (options != nullptr && strcmp(options, \"printdump\") == 0) {\n@@ -264,1 +264,1 @@\n-  if (res != JNI_OK || jvmti == NULL) {\n+  if (res != JNI_OK || jvmti == nullptr) {\n@@ -282,1 +282,1 @@\n-  const MyTag* const tag = newTag(rmark, (const MyTag*)(intptr_t)class_tag, size, NULL);\n+  const MyTag* const tag = newTag(rmark, (const MyTag*)(intptr_t)class_tag, size, nullptr);\n@@ -301,1 +301,1 @@\n-    MyTag* tag = newTag(kind, (MyTag*)(intptr_t)class_tag, size, NULL);\n+    MyTag* tag = newTag(kind, (MyTag*)(intptr_t)class_tag, size, nullptr);\n@@ -327,1 +327,1 @@\n-    MyTag* tag = newTag(kind, (MyTag*)(intptr_t)class_tag, size, NULL);\n+    MyTag* tag = newTag(kind, (MyTag*)(intptr_t)class_tag, size, nullptr);\n@@ -348,1 +348,1 @@\n-  MyTag* referrer = NULL;\n+  MyTag* referrer = nullptr;\n@@ -358,1 +358,1 @@\n-    MyTag* tag = newTag(kind, (MyTag*)(intptr_t)class_tag, size, NULL);\n+    MyTag* tag = newTag(kind, (MyTag*)(intptr_t)class_tag, size, nullptr);\n@@ -383,1 +383,1 @@\n-  if (jvmti == NULL) {\n+  if (jvmti == nullptr) {\n@@ -388,2 +388,2 @@\n-  fakeRoot = newTag(rother, (const MyTag *)NULL, 0, \"FAKE_ROOT\");\n-  missed = newTag(rother, (const MyTag *)NULL, 0, \"MISSED\");\n+  fakeRoot = newTag(rother, nullptr, 0, \"FAKE_ROOT\");\n+  missed = newTag(rother, nullptr, 0, \"MISSED\");\n@@ -405,1 +405,1 @@\n-    err = jvmti->GetClassSignature(k, &classSig, NULL);\n+    err = jvmti->GetClassSignature(k, &classSig, nullptr);\n@@ -415,1 +415,1 @@\n-      if (*classSig == 'L' && slash != NULL) {\n+      if (*classSig == 'L' && slash != nullptr) {\n@@ -440,1 +440,1 @@\n-  env->PopLocalFrame(NULL);\n+  env->PopLocalFrame(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/refignore\/refignore.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-           value to be set to NULL.\n+           value to be set to nullptr.\n@@ -108,1 +108,1 @@\n-  check_val(get_thread_local(NULL), 0, \"thread initial\");\n+  check_val(get_thread_local(nullptr), 0, \"thread initial\");\n@@ -111,2 +111,2 @@\n-  check_val(get_thread_local(NULL), 35, \"thread set non-zero\");\n-  set_thread_local(NULL, 0);\n+  check_val(get_thread_local(nullptr), 35, \"thread set non-zero\");\n+  set_thread_local(nullptr, 0);\n@@ -114,1 +114,1 @@\n-  check_val(get_thread_local(NULL), 0, \"thread set zero\");\n+  check_val(get_thread_local(nullptr), 0, \"thread set zero\");\n@@ -164,1 +164,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT,NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT,nullptr);\n@@ -178,1 +178,1 @@\n-  check_val(get_thread_local(NULL), 0, \"thread check\");\n+  check_val(get_thread_local(nullptr), 0, \"thread check\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/setNullVMInit\/JvmtiTest\/JvmtiTest.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,1 +146,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr);\n@@ -149,1 +149,1 @@\n-    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+    res = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/unit\/timers\/JvmtiTest\/JvmtiTest.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-            env->GetObjectClass(_obj)) != NULL))\\\n+            env->GetObjectClass(_obj)) != nullptr))\\\n@@ -42,1 +42,1 @@\n-            env->GetStaticMethodID(_class, _methodName, _sig)) != NULL))\\\n+            env->GetStaticMethodID(_class, _methodName, _sig)) != nullptr))\\\n@@ -47,1 +47,1 @@\n-            env->GetMethodID(_class, _methodName, _sig)) != NULL))\\\n+            env->GetMethodID(_class, _methodName, _sig)) != nullptr))\\\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/share\/StackTraceController.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-            env->FindClass(_className)) != NULL))\\\n+            env->FindClass(_className)) != nullptr))\\\n@@ -39,1 +39,1 @@\n-            env->GetObjectClass(_obj)) != NULL))\\\n+            env->GetObjectClass(_obj)) != nullptr))\\\n@@ -44,1 +44,1 @@\n-            env->GetStaticFieldID(_class, _fieldName, _fieldSig)) != NULL))\\\n+            env->GetStaticFieldID(_class, _fieldName, _fieldSig)) != nullptr))\\\n@@ -57,1 +57,1 @@\n-            env->GetFieldID(_class, _fieldName, _fieldSig)) != NULL))\\\n+            env->GetFieldID(_class, _fieldName, _fieldSig)) != nullptr))\\\n@@ -93,1 +93,1 @@\n-            env->GetStaticMethodID(_class, _methodName, _sig)) != NULL))\\\n+            env->GetStaticMethodID(_class, _methodName, _sig)) != nullptr))\\\n@@ -98,1 +98,1 @@\n-            env->GetMethodID(_class, _methodName, _sig)) != NULL))\\\n+            env->GetMethodID(_class, _methodName, _sig)) != nullptr))\\\n@@ -137,1 +137,1 @@\n-            env->NewObject(_class, method, _params)) != NULL))\\\n+            env->NewObject(_class, method, _params)) != nullptr))\\\n@@ -490,1 +490,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -494,1 +494,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -498,1 +498,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -502,2 +502,2 @@\n-        if (!NSK_JNI_VERIFY(env, (ThreadState = env->FindClass(\"java\/lang\/Thread$State\")) != NULL))\n-            return NULL;\n+        if (!NSK_JNI_VERIFY(env, (ThreadState = env->FindClass(\"java\/lang\/Thread$State\")) != nullptr))\n+            return nullptr;\n@@ -505,2 +505,2 @@\n-        if (!NSK_JNI_VERIFY(env, (method = env->GetStaticMethodID(ThreadState, \"valueOf\", \"(Ljava\/lang\/String;)Ljava\/lang\/Thread$State;\")) != NULL))\n-            return NULL;\n+        if (!NSK_JNI_VERIFY(env, (method = env->GetStaticMethodID(ThreadState, \"valueOf\", \"(Ljava\/lang\/String;)Ljava\/lang\/Thread$State;\")) != nullptr))\n+            return nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/share\/ThreadController.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-             env->FindClass(_className)) != NULL))\\\n+             env->FindClass(_className)) != nullptr))\\\n@@ -35,1 +35,1 @@\n-             env->GetObjectClass(_obj)) != NULL))\\\n+             env->GetObjectClass(_obj)) != nullptr))\\\n@@ -44,1 +44,1 @@\n-             env->GetFieldID(_class, _fieldName, _fieldSig)) != NULL))\\\n+             env->GetFieldID(_class, _fieldName, _fieldSig)) != nullptr))\\\n@@ -49,1 +49,1 @@\n-             env->GetMethodID(_class, _methodName, _sig)) != NULL)) \\\n+             env->GetMethodID(_class, _methodName, _sig)) != nullptr)) \\\n@@ -75,1 +75,1 @@\n-        if (step1 == NULL) {\n+        if (step1 == nullptr) {\n@@ -80,1 +80,1 @@\n-        if (step2 == NULL) {\n+        if (step2 == nullptr) {\n@@ -85,1 +85,1 @@\n-        if (step3 == NULL) {\n+        if (step3 == nullptr) {\n@@ -91,1 +91,1 @@\n-                if (inner == NULL) {\n+                if (inner == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/share\/thread\/Deadlock.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-             env->FindClass(_className)) != NULL))\\\n+             env->FindClass(_className)) != nullptr))\\\n@@ -35,1 +35,1 @@\n-             env->GetObjectClass(_obj)) != NULL))\\\n+             env->GetObjectClass(_obj)) != nullptr))\\\n@@ -44,1 +44,1 @@\n-             env->GetFieldID(_class, _fieldName, _fieldSig)) != NULL))\\\n+             env->GetFieldID(_class, _fieldName, _fieldSig)) != nullptr))\\\n@@ -49,1 +49,1 @@\n-             env->GetMethodID(_class, _methodName, _sig)) != NULL))\\\n+             env->GetMethodID(_class, _methodName, _sig)) != nullptr))\\\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/share\/thread\/LockingThreads.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-            env->FindClass(_className)) != NULL))\\\n+            env->FindClass(_className)) != nullptr))\\\n@@ -37,1 +37,1 @@\n-            env->GetObjectClass(_obj)) != NULL))\\\n+            env->GetObjectClass(_obj)) != nullptr))\\\n@@ -42,1 +42,1 @@\n-            env->GetStaticFieldID(_class, _fieldName, _fieldSig)) != NULL))\\\n+            env->GetStaticFieldID(_class, _fieldName, _fieldSig)) != nullptr))\\\n@@ -55,1 +55,1 @@\n-            env->GetFieldID(_class, _fieldName, _fieldSig)) != NULL))\\\n+            env->GetFieldID(_class, _fieldName, _fieldSig)) != nullptr))\\\n@@ -87,1 +87,1 @@\n-            env->GetStaticMethodID(_class, _methodName, _sig)) != NULL))\\\n+            env->GetStaticMethodID(_class, _methodName, _sig)) != nullptr))\\\n@@ -92,1 +92,1 @@\n-            env->GetMethodID(_class, _methodName, _sig)) != NULL))\\\n+            env->GetMethodID(_class, _methodName, _sig)) != nullptr))\\\n@@ -127,1 +127,1 @@\n-            env->NewObject(_class, method, _params)) != NULL))\\\n+            env->NewObject(_class, method, _params)) != nullptr))\\\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/share\/thread\/RecursiveMonitoringThread.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-    \"JNI method GetFieldID : Return is NULL from exceptionjni001.cpp : \";\n+    \"JNI method GetFieldID : Return is null from exceptionjni001.cpp : \";\n@@ -38,1 +38,1 @@\n-    \"JNI method GetFieldID : Return is NULL from Unknown File : \";\n+    \"JNI method GetFieldID : Return is null from Unknown File : \";\n@@ -55,1 +55,1 @@\n-  char* end_ptr = NULL;\n+  char* end_ptr = nullptr;\n@@ -58,2 +58,2 @@\n-  if (end_ptr == NULL || *end_ptr != '\\0') {\n-    fprintf(stderr, \"end_ptr == NULL or *end_ptr terminating from %s\\n\", message);\n+  if (end_ptr == nullptr || *end_ptr != '\\0') {\n+    fprintf(stderr, \"end_ptr == null or *end_ptr terminating from %s\\n\", message);\n@@ -104,1 +104,1 @@\n-  ec_jni->GetFieldID(cls, \"whatever\", \"does not matter\", __LINE__, NULL);\n+  ec_jni->GetFieldID(cls, \"whatever\", \"does not matter\", __LINE__, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/ExceptionCheckingJniEnv\/exceptionjni001\/exceptionjni001.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,169 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jvmdi.h\"\n-#include \"JVMDITools.h\"\n-\n-extern \"C\" {\n-\n-char const *TranslateEvent(jint kind) {\n-    switch (kind) {\n-    case JVMDI_EVENT_SINGLE_STEP:\n-        return (\"JVMDI_EVENT_SINGLE_STEP\");\n-    case JVMDI_EVENT_BREAKPOINT:\n-        return (\"JVMDI_EVENT_BREAKPOINT\");\n-    case JVMDI_EVENT_FRAME_POP:\n-        return (\"JVMDI_EVENT_FRAME_POP\");\n-    case JVMDI_EVENT_EXCEPTION:\n-        return (\"JVMDI_EVENT_EXCEPTION\");\n-    case JVMDI_EVENT_USER_DEFINED:\n-        return (\"JVMDI_EVENT_USER_DEFINED\");\n-    case JVMDI_EVENT_THREAD_START:\n-        return (\"JVMDI_EVENT_THREAD_START\");\n-    case JVMDI_EVENT_THREAD_END:\n-        return (\"JVMDI_EVENT_THREAD_END\");\n-    case JVMDI_EVENT_CLASS_PREPARE:\n-        return (\"JVMDI_EVENT_CLASS_PREPARE\");\n-    case JVMDI_EVENT_CLASS_UNLOAD:\n-        return (\"JVMDI_EVENT_CLASS_UNLOAD\");\n-    case JVMDI_EVENT_CLASS_LOAD:\n-        return (\"JVMDI_EVENT_CLASS_LOAD\");\n-    case JVMDI_EVENT_FIELD_ACCESS:\n-        return (\"JVMDI_EVENT_FIELD_ACCESS\");\n-    case JVMDI_EVENT_FIELD_MODIFICATION:\n-        return (\"JVMDI_EVENT_FIELD_MODIFICATION\");\n-    case JVMDI_EVENT_EXCEPTION_CATCH:\n-        return (\"JVMDI_EVENT_EXCEPTION_CATCH\");\n-    case JVMDI_EVENT_METHOD_ENTRY:\n-        return (\"JVMDI_EVENT_METHOD_ENTRY\");\n-    case JVMDI_EVENT_METHOD_EXIT:\n-        return (\"JVMDI_EVENT_METHOD_EXIT\");\n-    case JVMDI_EVENT_VM_INIT:\n-        return (\"JVMDI_EVENT_VM_INIT\");\n-    case JVMDI_EVENT_VM_DEATH:\n-        return (\"JVMDI_EVENT_VM_DEATH\");\n-    default:\n-        return (\"<Unknown Event>\");\n-    }\n-}\n-\n-char const *TranslateError(jvmdiError err) {\n-    switch (err) {\n-    case JVMDI_ERROR_NONE:\n-        return (\"JVMDI_ERROR_NONE\");\n-    case JVMDI_ERROR_OUT_OF_MEMORY:\n-        return (\"JVMDI_ERROR_OUT_OF_MEMORY\");\n-    case JVMDI_ERROR_ACCESS_DENIED:\n-        return (\"JVMDI_ERROR_ACCESS_DENIED\");\n-    case JVMDI_ERROR_UNATTACHED_THREAD:\n-        return (\"JVMDI_ERROR_UNATTACHED_THREAD\");\n-    case JVMDI_ERROR_VM_DEAD:\n-        return (\"JVMDI_ERROR_VM_DEAD\");\n-    case JVMDI_ERROR_INTERNAL:\n-        return (\"JVMDI_ERROR_INTERNAL\");\n-    case JVMDI_ERROR_INVALID_THREAD:\n-        return (\"JVMDI_ERROR_INVALID_THREAD\");\n-    case JVMDI_ERROR_INVALID_FIELDID:\n-        return (\"JVMDI_ERROR_INVALID_FIELDID\");\n-    case JVMDI_ERROR_INVALID_METHODID:\n-        return (\"JVMDI_ERROR_INVALID_METHODID\");\n-    case JVMDI_ERROR_INVALID_LOCATION:\n-        return (\"JVMDI_ERROR_INVALID_LOCATION\");\n-    case JVMDI_ERROR_INVALID_FRAMEID:\n-        return (\"JVMDI_ERROR_INVALID_FRAMEID\");\n-    case JVMDI_ERROR_NO_MORE_FRAMES:\n-        return (\"JVMDI_ERROR_NO_MORE_FRAMES\");\n-    case JVMDI_ERROR_OPAQUE_FRAME:\n-        return (\"JVMDI_ERROR_OPAQUE_FRAME\");\n-    case JVMDI_ERROR_NOT_CURRENT_FRAME:\n-        return (\"JVMDI_ERROR_NOT_CURRENT_FRAME\");\n-    case JVMDI_ERROR_TYPE_MISMATCH:\n-        return (\"JVMDI_ERROR_TYPE_MISMATCH\");\n-    case JVMDI_ERROR_INVALID_SLOT:\n-        return (\"JVMDI_ERROR_INVALID_SLOT\");\n-    case JVMDI_ERROR_DUPLICATE:\n-        return (\"JVMDI_ERROR_DUPLICATE\");\n-    case JVMDI_ERROR_THREAD_NOT_SUSPENDED:\n-        return (\"JVMDI_ERROR_THREAD_NOT_SUSPENDED\");\n-    case JVMDI_ERROR_THREAD_SUSPENDED:\n-        return (\"JVMDI_ERROR_THREAD_SUSPENDED\");\n-    case JVMDI_ERROR_INVALID_OBJECT:\n-        return (\"JVMDI_ERROR_INVALID_OBJECT\");\n-    case JVMDI_ERROR_INVALID_CLASS:\n-        return (\"JVMDI_ERROR_INVALID_CLASS\");\n-    case JVMDI_ERROR_CLASS_NOT_PREPARED:\n-        return (\"JVMDI_ERROR_CLASS_NOT_PREPARED\");\n-    case JVMDI_ERROR_NULL_POINTER:\n-        return (\"JVMDI_ERROR_NULL_POINTER\");\n-    case JVMDI_ERROR_ABSENT_INFORMATION:\n-        return (\"JVMDI_ERROR_ABSENT_INFORMATION\");\n-    case JVMDI_ERROR_INVALID_EVENT_TYPE:\n-        return (\"JVMDI_ERROR_INVALID_EVENT_TYPE\");\n-    case JVMDI_ERROR_NOT_IMPLEMENTED:\n-        return (\"JVMDI_ERROR_NOT_IMPLEMENTED\");\n-    case JVMDI_ERROR_INVALID_THREAD_GROUP:\n-        return (\"JVMDI_ERROR_INVALID_THREAD_GROUP\");\n-    case JVMDI_ERROR_INVALID_PRIORITY:\n-        return (\"JVMDI_ERROR_INVALID_PRIORITY\");\n-    case JVMDI_ERROR_NOT_FOUND:\n-        return (\"JVMDI_ERROR_NOT_FOUND\");\n-    case JVMDI_ERROR_INVALID_MONITOR:\n-        return (\"JVMDI_ERROR_INVALID_MONITOR\");\n-    case JVMDI_ERROR_ILLEGAL_ARGUMENT:\n-        return (\"JVMDI_ERROR_ILLEGAL_ARGUMENT\");\n-    case JVMDI_ERROR_NOT_MONITOR_OWNER:\n-        return (\"JVMDI_ERROR_NOT_MONITOR_OWNER\");\n-    case JVMDI_ERROR_INTERRUPT:\n-        return (\"JVMDI_ERROR_INTERRUPT\");\n-    case JVMDI_ERROR_INVALID_TYPESTATE:\n-        return (\"JVMDI_ERROR_INVALID_TYPESTATE\");\n-    case JVMDI_ERROR_INVALID_CLASS_FORMAT:\n-        return (\"JVMDI_ERROR_INVALID_CLASS_FORMAT\");\n-    case JVMDI_ERROR_CIRCULAR_CLASS_DEFINITION:\n-        return (\"JVMDI_ERROR_CIRCULAR_CLASS_DEFINITION\");\n-    case JVMDI_ERROR_ADD_METHOD_NOT_IMPLEMENTED:\n-        return (\"JVMDI_ERROR_ADD_METHOD_NOT_IMPLEMENTED\");\n-    case JVMDI_ERROR_SCHEMA_CHANGE_NOT_IMPLEMENTED:\n-        return (\"JVMDI_ERROR_SCHEMA_CHANGE_NOT_IMPLEMENTED\");\n-    case JVMDI_ERROR_FAILS_VERIFICATION:\n-        return (\"JVMDI_ERROR_FAILS_VERIFICATION\");\n-#ifdef JVMDI_VERSION_1_2\n-    case JVMDI_ERROR_UNSUPPORTED_VERSION:\n-        return (\"JVMDI_ERROR_UNSUPPORTED_VERSION\");\n-    case JVMDI_ERROR_HIERARCHY_CHANGE_NOT_IMPLEMENTED:\n-        return (\"JVMDI_ERROR_HIERARCHY_CHANGE_NOT_IMPLEMENTED\");\n-    case JVMDI_ERROR_DELETE_METHOD_NOT_IMPLEMENTED:\n-        return (\"JVMDI_ERROR_DELETE_METHOD_NOT_IMPLEMENTED\");\n-    case JVMDI_ERROR_NAMES_DONT_MATCH:\n-        return (\"JVMDI_ERROR_NAMES_DONT_MATCH\");\n-    case JVMDI_ERROR_CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED:\n-        return (\"JVMDI_ERROR_CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED\");\n-    case JVMDI_ERROR_METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED:\n-        return (\"JVMDI_ERROR_METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED\");\n-#endif\n-    default:\n-        return (\"<Unknown Error>\");\n-    }\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/JVMDITools.cpp","additions":0,"deletions":169,"binary":false,"changes":169,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-extern \"C\" {\n-\n-char const *TranslateEvent(jint kind);\n-char const *TranslateError(jvmdiError err);\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/JVMDITools.h","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-static jvmtiEnv *jvmti = NULL; \/* JVMTI env *\/\n+static jvmtiEnv *jvmti = nullptr; \/* JVMTI env *\/\n@@ -109,1 +109,1 @@\n-static const char *shortTestName = NULL; \/* name of the test without package prefix *\/\n+static const char *shortTestName = nullptr; \/* name of the test without package prefix *\/\n@@ -111,1 +111,1 @@\n-static class_info *clsInfo = NULL, *clsInfoFst = NULL;\n+static class_info *clsInfo = nullptr, *clsInfoFst = nullptr;\n@@ -163,1 +163,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &cls_sig, \/*&generic*\/NULL)))\n+        if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &cls_sig, \/*&generic*\/nullptr)))\n@@ -166,2 +166,2 @@\n-            if (shortTestName != NULL) {\n-                if (strstr((const char*) cls_sig, shortTestName) != NULL) {\n+            if (shortTestName != nullptr) {\n+                if (strstr((const char*) cls_sig, shortTestName) != nullptr) {\n@@ -201,1 +201,1 @@\n-    getVerdict(NULL, \"CompiledMethodLoad\");\n+    getVerdict(nullptr, \"CompiledMethodLoad\");\n@@ -210,1 +210,1 @@\n-    getVerdict(NULL, \"CompiledMethodUnload\");\n+    getVerdict(nullptr, \"CompiledMethodUnload\");\n@@ -218,1 +218,1 @@\n-    getVerdict(NULL, \"DataDumpRequest\");\n+    getVerdict(nullptr, \"DataDumpRequest\");\n@@ -229,1 +229,1 @@\n-    getVerdict(NULL, \"DynamicCodeGenerated\");\n+    getVerdict(nullptr, \"DynamicCodeGenerated\");\n@@ -289,1 +289,1 @@\n-    getVerdict(NULL, \"GarbageCollectionFinish\");\n+    getVerdict(nullptr, \"GarbageCollectionFinish\");\n@@ -297,1 +297,1 @@\n-    getVerdict(NULL, \"GarbageCollectionStart\");\n+    getVerdict(nullptr, \"GarbageCollectionStart\");\n@@ -350,1 +350,1 @@\n-    getVerdict(NULL, \"ObjectFree\");\n+    getVerdict(nullptr, \"ObjectFree\");\n@@ -492,1 +492,1 @@\n-    jmethodID mid = NULL;\n+    jmethodID mid = nullptr;\n@@ -494,2 +494,2 @@\n-    if (jvmti == NULL) {\n-        printf(\"ERROR(%s,%d): JVMTIagent was not properly loaded: JVMTI env = NULL\\n\",\n+    if (jvmti == nullptr) {\n+        printf(\"ERROR(%s,%d): JVMTIagent was not properly loaded: JVMTI env = null\\n\",\n@@ -557,1 +557,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (shortTestName = jni_env->GetStringUTFChars(shortName, NULL)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni_env, (shortTestName = jni_env->GetStringUTFChars(shortName, nullptr)) != nullptr)) {\n@@ -564,1 +564,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (rasCls = jni_env->NewGlobalRef(cls)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni_env, (rasCls = jni_env->NewGlobalRef(cls)) != nullptr)) {\n@@ -579,2 +579,2 @@\n-    class_info *_clsInfo = NULL;\n-    jmethodID mid = NULL;\n+    class_info *_clsInfo = nullptr;\n+    jmethodID mid = nullptr;\n@@ -585,1 +585,1 @@\n-    if (_clsInfo == NULL)\n+    if (_clsInfo == nullptr)\n@@ -591,1 +591,1 @@\n-    if (!NSK_JNI_VERIFY(jni_env, ((*_clsInfo).cls = jni_env->NewGlobalRef(clazz)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni_env, ((*_clsInfo).cls = jni_env->NewGlobalRef(clazz)) != nullptr)) {\n@@ -600,1 +600,1 @@\n-        jni_env->GetStaticMethodID(rasCls, \"loadFromClassFile\", \"(Ljava\/lang\/String;)[B\")) != NULL))\n+        jni_env->GetStaticMethodID(rasCls, \"loadFromClassFile\", \"(Ljava\/lang\/String;)[B\")) != nullptr))\n@@ -612,1 +612,1 @@\n-    _clsInfo->next = NULL;\n+    _clsInfo->next = nullptr;\n@@ -614,1 +614,1 @@\n-    if (clsInfo != NULL) {\n+    if (clsInfo != nullptr) {\n@@ -630,1 +630,1 @@\n-    while (clsInfoCurr != NULL) {\n+    while (clsInfoCurr != nullptr) {\n@@ -643,1 +643,1 @@\n-    clsInfoFst = NULL;\n+    clsInfoFst = nullptr;\n@@ -648,1 +648,1 @@\n-    char *clazzsig = NULL;\n+    char *clazzsig = nullptr;\n@@ -652,1 +652,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(clazz, &clazzsig, \/*&generic*\/NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(clazz, &clazzsig, \/*&generic*\/nullptr)))\n@@ -662,1 +662,1 @@\n-        while (clsInfoCurr != NULL) {\n+        while (clsInfoCurr != nullptr) {\n@@ -738,1 +738,1 @@\n-            if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, NULL)))\n+            if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, nullptr)))\n@@ -754,1 +754,1 @@\n-            if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, NULL)))\n+            if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, nullptr)))\n@@ -764,1 +764,1 @@\n-            if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, NULL)))\n+            if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_EXIT, nullptr)))\n@@ -780,1 +780,1 @@\n-            if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION_CATCH, NULL)))\n+            if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION_CATCH, nullptr)))\n@@ -825,1 +825,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr)))\n@@ -834,1 +834,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n@@ -843,1 +843,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, nullptr)))\n@@ -852,1 +852,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, nullptr)))\n@@ -861,1 +861,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr)))\n@@ -870,1 +870,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_UNLOAD, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_UNLOAD, nullptr)))\n@@ -879,1 +879,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_DATA_DUMP_REQUEST, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_DATA_DUMP_REQUEST, nullptr)))\n@@ -888,1 +888,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_DYNAMIC_CODE_GENERATED, nullptr)))\n@@ -897,1 +897,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, nullptr)))\n@@ -906,1 +906,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_ACCESS, nullptr)))\n@@ -915,1 +915,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_MODIFICATION, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FIELD_MODIFICATION, nullptr)))\n@@ -924,1 +924,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, nullptr)))\n@@ -933,1 +933,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_FINISH, nullptr)))\n@@ -942,1 +942,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_START, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_GARBAGE_COLLECTION_START, nullptr)))\n@@ -951,1 +951,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, nullptr)))\n@@ -960,1 +960,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, nullptr)))\n@@ -969,1 +969,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, nullptr)))\n@@ -978,1 +978,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, nullptr)))\n@@ -987,1 +987,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, nullptr)))\n@@ -996,1 +996,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, nullptr)))\n@@ -1005,1 +1005,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END, nullptr)))\n@@ -1014,1 +1014,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, nullptr)))\n@@ -1023,1 +1023,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr)))\n@@ -1032,1 +1032,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, nullptr)))\n@@ -1041,1 +1041,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, nullptr)))\n@@ -1050,1 +1050,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, nullptr)))\n@@ -1156,1 +1156,1 @@\n-        if (jni_env == NULL) { \/* some event callbacks have no pointer to jni *\/\n+        if (jni_env == nullptr) { \/* some event callbacks have no pointer to jni *\/\n@@ -1184,1 +1184,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -1201,1 +1201,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/JVMTIagent.cpp","additions":64,"deletions":64,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -62,2 +62,0 @@\n-    JVMDI tests support:\n-        JVMDITools.h, JVMDITools.c\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/README","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  if (options != NULL) {\n+  if (options != nullptr) {\n@@ -50,1 +50,1 @@\n-      if (options->names[i] != NULL) {\n+      if (options->names[i] != nullptr) {\n@@ -53,1 +53,1 @@\n-      if (options->values[i] != NULL) {\n+      if (options->values[i] != nullptr) {\n@@ -74,1 +74,1 @@\n-    if (optionsString == NULL) {\n+    if (optionsString == nullptr) {\n@@ -76,1 +76,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -82,1 +82,1 @@\n-    while (name != NULL && i < NSK_AOD_MAX_OPTIONS) {\n+    while (name != nullptr && i < NSK_AOD_MAX_OPTIONS) {\n@@ -84,1 +84,1 @@\n-      if (sep == NULL) { \/\/ name not found\n+      if (sep == nullptr) { \/\/ name not found\n@@ -87,1 +87,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -95,1 +95,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -98,1 +98,1 @@\n-      if (sep != NULL) {\n+      if (sep != nullptr) {\n@@ -108,1 +108,1 @@\n-        name = NULL;\n+        name = nullptr;\n@@ -111,1 +111,1 @@\n-    if (name != NULL) {\n+    if (name != nullptr) {\n@@ -122,2 +122,2 @@\n-    if (!NSK_VERIFY((options = (Options*) nsk_aod_createOptionsObject(optionsString)) != NULL))\n-        return NULL;\n+    if (!NSK_VERIFY((options = (Options*) nsk_aod_createOptionsObject(optionsString)) != nullptr))\n+        return nullptr;\n@@ -127,1 +127,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -146,3 +146,3 @@\n-    if (!NSK_VERIFY(options != NULL)) {\n-        NSK_COMPLAIN0(\"Options NULL\\n\");\n-        return NULL;\n+    if (!NSK_VERIFY(options != nullptr)) {\n+        NSK_COMPLAIN0(\"Options null\\n\");\n+        return nullptr;\n@@ -159,1 +159,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -165,2 +165,2 @@\n-    if (!NSK_VERIFY(options != NULL)) {\n-        NSK_COMPLAIN0(\"Options NULL\\n\");\n+    if (!NSK_VERIFY(options != nullptr)) {\n+        NSK_COMPLAIN0(\"Options null\\n\");\n@@ -191,3 +191,3 @@\n-static jclass targetAppClass = NULL;\n-static jmethodID agentLoadedMethod = NULL;\n-static jmethodID agentFinishedMethod = NULL;\n+static jclass targetAppClass = nullptr;\n+static jmethodID agentLoadedMethod = nullptr;\n+static jmethodID agentFinishedMethod = nullptr;\n@@ -201,1 +201,1 @@\n-    if (targetAppClass == NULL) {\n+    if (targetAppClass == nullptr) {\n@@ -208,1 +208,1 @@\n-            jni->FindClass(TARGET_APP_CLASS_NAME)) != NULL)) {\n+            jni->FindClass(TARGET_APP_CLASS_NAME)) != nullptr)) {\n@@ -213,1 +213,1 @@\n-            jni->NewGlobalRef(localTargetAppClass)) != NULL)) {\n+            jni->NewGlobalRef(localTargetAppClass)) != nullptr)) {\n@@ -218,1 +218,1 @@\n-    if (agentLoadedMethod == NULL) {\n+    if (agentLoadedMethod == nullptr) {\n@@ -220,1 +220,1 @@\n-            jni->GetStaticMethodID(targetAppClass, AGENT_LOADED_METHOD_NAME, AGENT_LOADED_METHOD_SIGNATURE)) != NULL))\n+            jni->GetStaticMethodID(targetAppClass, AGENT_LOADED_METHOD_NAME, AGENT_LOADED_METHOD_SIGNATURE)) != nullptr))\n@@ -225,1 +225,1 @@\n-        jni->NewStringUTF(agentName)) != NULL))\n+        jni->NewStringUTF(agentName)) != nullptr))\n@@ -255,1 +255,1 @@\n-    if (agentFinishedMethod == NULL) {\n+    if (agentFinishedMethod == nullptr) {\n@@ -257,1 +257,1 @@\n-            jni->GetStaticMethodID(targetAppClass, AGENT_FINISHED_METHOD_NAME, AGENT_FINISHED_METHOD_SIGNATURE)) != NULL))\n+            jni->GetStaticMethodID(targetAppClass, AGENT_FINISHED_METHOD_NAME, AGENT_FINISHED_METHOD_SIGNATURE)) != nullptr))\n@@ -261,1 +261,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (agentNameString = jni->NewStringUTF(agentName)) != NULL))\n+    if (!NSK_JNI_VERIFY(jni, (agentNameString = jni->NewStringUTF(agentName)) != nullptr))\n@@ -279,1 +279,1 @@\n-    NSK_VERIFY(jni != NULL);\n+    NSK_VERIFY(jni != nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/aod\/aod.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jfieldID objFieldId = NULL;\n+static jfieldID objFieldId = nullptr;\n@@ -48,1 +48,1 @@\n-  if (objFieldId == NULL) {\n+  if (objFieldId == nullptr) {\n@@ -53,1 +53,1 @@\n-  ec_jni->SetObjectField(o, objFieldId, NULL, TRACE_JNI_CALL);\n+  ec_jni->SetObjectField(o, objFieldId, nullptr, TRACE_JNI_CALL);\n@@ -56,1 +56,1 @@\n-  start_time = time(NULL);\n+  start_time = time(nullptr);\n@@ -61,2 +61,2 @@\n-    pa = (jboolean*) ec_jni->GetPrimitiveArrayCritical(arr, NULL, TRACE_JNI_CALL);\n-    if (pa != NULL) {\n+    pa = (jboolean*) ec_jni->GetPrimitiveArrayCritical(arr, nullptr, TRACE_JNI_CALL);\n+    if (pa != nullptr) {\n@@ -67,1 +67,1 @@\n-      jni_env->FatalError(\"GetPrimitiveArrayCritical returned NULL\");\n+      jni_env->FatalError(\"GetPrimitiveArrayCritical returned null\");\n@@ -72,1 +72,1 @@\n-    current_time = time(NULL);\n+    current_time = time(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/jni\/BooleanArrayCriticalLocker.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jfieldID objFieldId = NULL;\n+static jfieldID objFieldId = nullptr;\n@@ -47,1 +47,1 @@\n-  if (objFieldId == NULL) {\n+  if (objFieldId == nullptr) {\n@@ -52,1 +52,1 @@\n-  ec_jni->SetObjectField(o, objFieldId, NULL, TRACE_JNI_CALL);\n+  ec_jni->SetObjectField(o, objFieldId, nullptr, TRACE_JNI_CALL);\n@@ -55,1 +55,1 @@\n-  start_time = time(NULL);\n+  start_time = time(nullptr);\n@@ -60,2 +60,2 @@\n-    pa = (jbyte*) ec_jni->GetPrimitiveArrayCritical(arr, NULL, TRACE_JNI_CALL);\n-    if (pa != NULL) {\n+    pa = (jbyte*) ec_jni->GetPrimitiveArrayCritical(arr, nullptr, TRACE_JNI_CALL);\n+    if (pa != nullptr) {\n@@ -66,1 +66,1 @@\n-      jni_env->FatalError(\"GetPrimitiveArrayCritical returned NULL\");\n+      jni_env->FatalError(\"GetPrimitiveArrayCritical returned null\");\n@@ -71,1 +71,1 @@\n-    current_time = time(NULL);\n+    current_time = time(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/jni\/ByteArrayCriticalLocker.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jfieldID objFieldId = NULL;\n+static jfieldID objFieldId = nullptr;\n@@ -48,1 +48,1 @@\n-  if (objFieldId == NULL) {\n+  if (objFieldId == nullptr) {\n@@ -53,1 +53,1 @@\n-  ec_jni->SetObjectField(o, objFieldId, NULL, TRACE_JNI_CALL);\n+  ec_jni->SetObjectField(o, objFieldId, nullptr, TRACE_JNI_CALL);\n@@ -56,1 +56,1 @@\n-  start_time = time(NULL);\n+  start_time = time(nullptr);\n@@ -61,2 +61,2 @@\n-    pa = (jchar*) ec_jni->GetPrimitiveArrayCritical(arr, NULL, TRACE_JNI_CALL);\n-    if (pa != NULL) {\n+    pa = (jchar*) ec_jni->GetPrimitiveArrayCritical(arr, nullptr, TRACE_JNI_CALL);\n+    if (pa != nullptr) {\n@@ -67,1 +67,1 @@\n-      jni_env->FatalError(\"GetPrimitiveArrayCritical returned NULL\");\n+      jni_env->FatalError(\"GetPrimitiveArrayCritical returned null\");\n@@ -72,1 +72,1 @@\n-    current_time = time(NULL);\n+    current_time = time(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/jni\/CharArrayCriticalLocker.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jfieldID objFieldId = NULL;\n+static jfieldID objFieldId = nullptr;\n@@ -48,1 +48,1 @@\n-  if (objFieldId == NULL) {\n+  if (objFieldId == nullptr) {\n@@ -53,1 +53,1 @@\n-  ec_jni->SetObjectField(o, objFieldId, NULL, TRACE_JNI_CALL);\n+  ec_jni->SetObjectField(o, objFieldId, nullptr, TRACE_JNI_CALL);\n@@ -56,1 +56,1 @@\n-  start_time = time(NULL);\n+  start_time = time(nullptr);\n@@ -61,2 +61,2 @@\n-    pa = (jdouble*) ec_jni->GetPrimitiveArrayCritical(arr, NULL, TRACE_JNI_CALL);\n-    if (pa != NULL) {\n+    pa = (jdouble*) ec_jni->GetPrimitiveArrayCritical(arr, nullptr, TRACE_JNI_CALL);\n+    if (pa != nullptr) {\n@@ -67,1 +67,1 @@\n-      jni_env->FatalError(\"GetPrimitiveArrayCritical returned NULL\");\n+      jni_env->FatalError(\"GetPrimitiveArrayCritical returned null\");\n@@ -72,1 +72,1 @@\n-    current_time = time(NULL);\n+    current_time = time(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/jni\/DoubleArrayCriticalLocker.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jfieldID objFieldId = NULL;\n+static jfieldID objFieldId = nullptr;\n@@ -48,1 +48,1 @@\n-  if (objFieldId == NULL) {\n+  if (objFieldId == nullptr) {\n@@ -53,1 +53,1 @@\n-  ec_jni->SetObjectField(o, objFieldId, NULL, TRACE_JNI_CALL);\n+  ec_jni->SetObjectField(o, objFieldId, nullptr, TRACE_JNI_CALL);\n@@ -56,1 +56,1 @@\n-  start_time = time(NULL);\n+  start_time = time(nullptr);\n@@ -61,2 +61,2 @@\n-    pa = (jfloat*) ec_jni->GetPrimitiveArrayCritical(arr, NULL, TRACE_JNI_CALL);\n-    if (pa != NULL) {\n+    pa = (jfloat*) ec_jni->GetPrimitiveArrayCritical(arr, nullptr, TRACE_JNI_CALL);\n+    if (pa != nullptr) {\n@@ -67,1 +67,1 @@\n-      jni_env->FatalError(\"GetPrimitiveArrayCritical returned NULL\");\n+      jni_env->FatalError(\"GetPrimitiveArrayCritical returned null\");\n@@ -72,1 +72,1 @@\n-    current_time = time(NULL);\n+    current_time = time(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/jni\/FloatArrayCriticalLocker.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jfieldID objFieldId = NULL;\n+static jfieldID objFieldId = nullptr;\n@@ -48,1 +48,1 @@\n-  if (objFieldId == NULL) {\n+  if (objFieldId == nullptr) {\n@@ -53,1 +53,1 @@\n-  ec_jni->SetObjectField(o, objFieldId, NULL, TRACE_JNI_CALL);\n+  ec_jni->SetObjectField(o, objFieldId, nullptr, TRACE_JNI_CALL);\n@@ -56,1 +56,1 @@\n-  start_time = time(NULL);\n+  start_time = time(nullptr);\n@@ -61,2 +61,2 @@\n-    pa = (jint*) ec_jni->GetPrimitiveArrayCritical(arr, NULL, TRACE_JNI_CALL);\n-    if (pa != NULL) {\n+    pa = (jint*) ec_jni->GetPrimitiveArrayCritical(arr, nullptr, TRACE_JNI_CALL);\n+    if (pa != nullptr) {\n@@ -67,1 +67,1 @@\n-      jni_env->FatalError(\"GetPrimitiveArrayCritical returned NULL\");\n+      jni_env->FatalError(\"GetPrimitiveArrayCritical returned null\");\n@@ -72,1 +72,1 @@\n-    current_time = time(NULL);\n+    current_time = time(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/jni\/IntArrayCriticalLocker.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jfieldID objFieldId = NULL;\n+static jfieldID objFieldId = nullptr;\n@@ -48,1 +48,1 @@\n-  if (objFieldId == NULL) {\n+  if (objFieldId == nullptr) {\n@@ -53,1 +53,1 @@\n-  ec_jni->SetObjectField(o, objFieldId, NULL, TRACE_JNI_CALL);\n+  ec_jni->SetObjectField(o, objFieldId, nullptr, TRACE_JNI_CALL);\n@@ -56,1 +56,1 @@\n-  start_time = time(NULL);\n+  start_time = time(nullptr);\n@@ -61,2 +61,2 @@\n-    pa = (jlong*) ec_jni->GetPrimitiveArrayCritical(arr, NULL, TRACE_JNI_CALL);\n-    if (pa != NULL) {\n+    pa = (jlong*) ec_jni->GetPrimitiveArrayCritical(arr, nullptr, TRACE_JNI_CALL);\n+    if (pa != nullptr) {\n@@ -67,1 +67,1 @@\n-      jni_env->FatalError(\"GetPrimitiveArrayCritical returned NULL\");\n+      jni_env->FatalError(\"GetPrimitiveArrayCritical returned null\");\n@@ -72,1 +72,1 @@\n-    current_time = time(NULL);\n+    current_time = time(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/jni\/LongArrayCriticalLocker.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jfieldID objFieldId = NULL;\n+static jfieldID objFieldId = nullptr;\n@@ -48,1 +48,1 @@\n-  if (objFieldId == NULL) {\n+  if (objFieldId == nullptr) {\n@@ -53,1 +53,1 @@\n-  ec_jni->SetObjectField(o, objFieldId, NULL, TRACE_JNI_CALL);\n+  ec_jni->SetObjectField(o, objFieldId, nullptr, TRACE_JNI_CALL);\n@@ -56,1 +56,1 @@\n-  start_time = time(NULL);\n+  start_time = time(nullptr);\n@@ -61,2 +61,2 @@\n-    pa = (jshort*) ec_jni->GetPrimitiveArrayCritical(arr, NULL, TRACE_JNI_CALL);\n-    if (pa != NULL) {\n+    pa = (jshort*) ec_jni->GetPrimitiveArrayCritical(arr, nullptr, TRACE_JNI_CALL);\n+    if (pa != nullptr) {\n@@ -67,1 +67,1 @@\n-      jni_env->FatalError(\"GetPrimitiveArrayCritical returned NULL\");\n+      jni_env->FatalError(\"GetPrimitiveArrayCritical returned null\");\n@@ -72,1 +72,1 @@\n-    current_time = time(NULL);\n+    current_time = time(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/jni\/ShortArrayCriticalLocker.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jfieldID objFieldId = NULL;\n+static jfieldID objFieldId = nullptr;\n@@ -48,1 +48,1 @@\n-  if (objFieldId == NULL) {\n+  if (objFieldId == nullptr) {\n@@ -53,1 +53,1 @@\n-  ec_jni->SetObjectField(o, objFieldId, NULL, TRACE_JNI_CALL);\n+  ec_jni->SetObjectField(o, objFieldId, nullptr, TRACE_JNI_CALL);\n@@ -56,1 +56,1 @@\n-  start_time = time(NULL);\n+  start_time = time(nullptr);\n@@ -61,2 +61,2 @@\n-    pa = ec_jni->GetStringCritical(str, NULL, TRACE_JNI_CALL);\n-    if (pa != NULL) {\n+    pa = ec_jni->GetStringCritical(str, nullptr, TRACE_JNI_CALL);\n+    if (pa != nullptr) {\n@@ -67,1 +67,1 @@\n-      jni_env->FatalError(\"GetStringCritical returned NULL\");\n+      jni_env->FatalError(\"GetStringCritical returned null\");\n@@ -72,1 +72,1 @@\n-    current_time = time(NULL);\n+    current_time = time(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/jni\/StringCriticalLocker.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-static jfieldID objFieldId = NULL;\n+static jfieldID objFieldId = nullptr;\n@@ -47,1 +47,1 @@\n-        if (objFieldId == NULL) {\n+        if (objFieldId == nullptr) {\n@@ -52,2 +52,2 @@\n-        ec_jni->SetObjectField(o, objFieldId, NULL, TRACE_JNI_CALL);\n-        start_time = time(NULL);\n+        ec_jni->SetObjectField(o, objFieldId, nullptr, TRACE_JNI_CALL);\n+        start_time = time(nullptr);\n@@ -61,1 +61,1 @@\n-                current_time = time(NULL);\n+                current_time = time(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/jniref\/JNIGlobalRefLocker.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jfieldID objFieldId = NULL;\n+static jfieldID objFieldId = nullptr;\n@@ -46,1 +46,1 @@\n-        if (objFieldId == NULL) {\n+        if (objFieldId == nullptr) {\n@@ -51,2 +51,2 @@\n-        ec_jni->SetObjectField(o, objFieldId, NULL, TRACE_JNI_CALL);\n-        start_time = time(NULL);\n+        ec_jni->SetObjectField(o, objFieldId, nullptr, TRACE_JNI_CALL);\n+        start_time = time(nullptr);\n@@ -60,1 +60,1 @@\n-                current_time = time(NULL);\n+                current_time = time(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/jniref\/JNILocalRefLocker.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jfieldID objFieldId = NULL;\n+static jfieldID objFieldId = nullptr;\n@@ -46,1 +46,1 @@\n-        if (objFieldId == NULL) {\n+        if (objFieldId == nullptr) {\n@@ -52,1 +52,1 @@\n-        ec_jni->SetObjectField(o, objFieldId, NULL, TRACE_JNI_CALL);\n+        ec_jni->SetObjectField(o, objFieldId, nullptr, TRACE_JNI_CALL);\n@@ -54,1 +54,1 @@\n-        start_time = time(NULL);\n+        start_time = time(nullptr);\n@@ -66,1 +66,1 @@\n-                current_time = time(NULL);\n+                current_time = time(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/jniref\/JNIRefLocker.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-static jfieldID objFieldId = NULL;\n+static jfieldID objFieldId = nullptr;\n@@ -46,1 +46,1 @@\n-        if (objFieldId == NULL) {\n+        if (objFieldId == nullptr) {\n@@ -51,1 +51,1 @@\n-        ec_jni->SetObjectField(o, objFieldId, NULL, TRACE_JNI_CALL);\n+        ec_jni->SetObjectField(o, objFieldId, nullptr, TRACE_JNI_CALL);\n@@ -53,1 +53,1 @@\n-        start_time = time(NULL);\n+        start_time = time(nullptr);\n@@ -61,1 +61,1 @@\n-                current_time = time(NULL);\n+                current_time = time(nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/gc\/lock\/jniref\/JNIWeakGlobalRefLocker.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n-  if (fullname == NULL) {\n-    return NULL;\n+  if (fullname == nullptr) {\n+    return nullptr;\n@@ -55,1 +55,1 @@\n-      : _env(env), _base_message(base_message), _error_message(NULL),\n+      : _env(env), _base_message(base_message), _error_message(nullptr),\n@@ -64,1 +64,1 @@\n-      : _env(env), _base_message(base_message), _error_message(NULL),\n+      : _env(env), _base_message(base_message), _error_message(nullptr),\n@@ -74,1 +74,1 @@\n-      : _env(env), _base_message(base_message), _error_message(NULL),\n+      : _env(env), _base_message(base_message), _error_message(nullptr),\n@@ -83,1 +83,1 @@\n-      : _env(env), _base_message(base_message), _error_message(NULL),\n+      : _env(env), _base_message(base_message), _error_message(nullptr),\n@@ -96,1 +96,1 @@\n-    if (_error_message != NULL) {\n+    if (_error_message != nullptr) {\n@@ -176,1 +176,1 @@\n-    if (full_message == NULL) {\n+    if (full_message == nullptr) {\n@@ -202,2 +202,2 @@\n-    if (ptr == NULL) {\n-      _error_message = \"Return is NULL\";\n+    if (ptr == nullptr) {\n+      _error_message = \"Return is null\";\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jni\/ExceptionCheckingJniEnv.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,2 @@\n- *  if (klass == NULL) {\n- *      printf(\"Error: GetObjectClass returned NULL\\n\");\n+ *  if (klass == nullptr) {\n+ *      printf(\"Error: GetObjectClass returned null\\n\");\n@@ -51,1 +51,1 @@\n- *  Where now the JNI Exception checking and the NULL return checking are done\n+ *  Where now the JNI Exception checking and the null return checking are done\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jni\/ExceptionCheckingJniEnv.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n-static jobject* globalReferences = NULL;\n-static jweak* weakReferences = NULL;\n+static jobject* globalReferences = nullptr;\n+static jweak* weakReferences = nullptr;\n@@ -40,1 +40,1 @@\n-        if (globalReferences == NULL)\n+        if (globalReferences == nullptr)\n@@ -44,1 +44,1 @@\n-                if (globalReferences == NULL)\n+                if (globalReferences == nullptr)\n@@ -46,1 +46,1 @@\n-                        NSK_COMPLAIN0(\"malloc return NULL\\n\");\n+                        NSK_COMPLAIN0(\"malloc return null\\n\");\n@@ -52,1 +52,1 @@\n-                        globalReferences[i] = NULL;\n+                        globalReferences[i] = nullptr;\n@@ -60,1 +60,1 @@\n-                if (reference == NULL)\n+                if (reference == nullptr)\n@@ -64,1 +64,1 @@\n-                        if (reference == NULL)\n+                        if (reference == nullptr)\n@@ -66,1 +66,1 @@\n-                                NSK_COMPLAIN0(\"NewGlobalRef return NULL\\n\");\n+                                NSK_COMPLAIN0(\"NewGlobalRef return null\\n\");\n@@ -70,1 +70,1 @@\n-                                    \"NewGlobalRef return NULL\");\n+                                    \"NewGlobalRef return null\");\n@@ -90,1 +90,1 @@\n-        if (reference == NULL)\n+        if (reference == nullptr)\n@@ -92,1 +92,1 @@\n-                NSK_COMPLAIN1(\"globalReferences[%d] = NULL, possible wrong index is passed\\n\", index);\n+                NSK_COMPLAIN1(\"globalReferences[%d] = null, possible wrong index is passed\\n\", index);\n@@ -96,1 +96,1 @@\n-                    \"Requested globalReferences[] element is NULL, possible wrong index is passed\");\n+                    \"Requested globalReferences[] element is null, possible wrong index is passed\");\n@@ -101,1 +101,1 @@\n-        globalReferences[index] = NULL;\n+        globalReferences[index] = nullptr;\n@@ -112,1 +112,1 @@\n-        if (reference == NULL)\n+        if (reference == nullptr)\n@@ -114,1 +114,1 @@\n-                NSK_COMPLAIN0(\"NewLocalRef return NULL\\n\");\n+                NSK_COMPLAIN0(\"NewLocalRef return null\\n\");\n@@ -118,1 +118,1 @@\n-                    \"NewLocalRef return NULL\");\n+                    \"NewLocalRef return null\");\n@@ -139,1 +139,1 @@\n-        if (weakReferences == NULL)\n+        if (weakReferences == nullptr)\n@@ -143,1 +143,1 @@\n-                if (weakReferences == NULL)\n+                if (weakReferences == nullptr)\n@@ -145,1 +145,1 @@\n-                        NSK_COMPLAIN0(\"malloc return NULL\\n\");\n+                        NSK_COMPLAIN0(\"malloc return null\\n\");\n@@ -152,1 +152,1 @@\n-                        weakReferences[i] = NULL;\n+                        weakReferences[i] = nullptr;\n@@ -160,1 +160,1 @@\n-                if (reference == NULL)\n+                if (reference == nullptr)\n@@ -164,1 +164,1 @@\n-                        if (reference == NULL)\n+                        if (reference == nullptr)\n@@ -166,1 +166,1 @@\n-                                NSK_COMPLAIN0(\"NewWeakGlobalRef return NULL\\n\");\n+                                NSK_COMPLAIN0(\"NewWeakGlobalRef return null\\n\");\n@@ -170,1 +170,1 @@\n-                                    \"NewWeakGlobalRef return NULL\");\n+                                    \"NewWeakGlobalRef return null\");\n@@ -190,1 +190,1 @@\n-        if (reference == NULL)\n+        if (reference == nullptr)\n@@ -192,1 +192,1 @@\n-                NSK_COMPLAIN1(\"weakReferences[%d] = NULL, possible wrong index is passed\\n\", index);\n+                NSK_COMPLAIN1(\"weakReferences[%d] = null, possible wrong index is passed\\n\", index);\n@@ -196,1 +196,1 @@\n-                    \"Requested weakReferences[] element is NULL, possible wrong index is passed\");\n+                    \"Requested weakReferences[] element is null, possible wrong index is passed\");\n@@ -199,1 +199,1 @@\n-        if (env->IsSameObject(reference, NULL) == JNI_TRUE)\n+        if (env->IsSameObject(reference, nullptr) == JNI_TRUE)\n@@ -210,1 +210,1 @@\n-        weakReferences[index] = NULL;\n+        weakReferences[index] = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jni\/JNIreferences.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-    if (throwable != NULL) {\n+    if (throwable != nullptr) {\n@@ -110,1 +110,1 @@\n-   select(0, NULL, NULL, NULL, &timeout);\n+   select(0, nullptr, nullptr, nullptr, &timeout);\n@@ -134,1 +134,1 @@\n-   JavaVMOption *options = NULL;\n+   JavaVMOption *options = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jni\/jni_tools.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,2 +159,2 @@\n-    jvmti = NULL;\n-    p_segment1 = p_segment2 = phase_to_check = NULL;\n+    jvmti = nullptr;\n+    p_segment1 = p_segment2 = phase_to_check = nullptr;\n@@ -167,2 +167,2 @@\n-    p_segment1 = nsk_jvmti_findOptionStringValue(\"segment1\", NULL);\n-    if (!NSK_VERIFY(p_segment1 != NULL)) {\n+    p_segment1 = nsk_jvmti_findOptionStringValue(\"segment1\", nullptr);\n+    if (!NSK_VERIFY(p_segment1 != nullptr)) {\n@@ -176,2 +176,2 @@\n-    p_segment2 = nsk_jvmti_findOptionStringValue(\"segment2\", NULL);\n-    if (p_segment2 != NULL) {\n+    p_segment2 = nsk_jvmti_findOptionStringValue(\"segment2\", nullptr);\n+    if (p_segment2 != nullptr) {\n@@ -184,1 +184,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -188,2 +188,2 @@\n-    phase_to_check = nsk_jvmti_findOptionStringValue(\"phasetocheck\", NULL);\n-    if (!NSK_VERIFY(phase_to_check != NULL)) {\n+    phase_to_check = nsk_jvmti_findOptionStringValue(\"phasetocheck\", nullptr);\n+    if (!NSK_VERIFY(phase_to_check != nullptr)) {\n@@ -230,1 +230,1 @@\n-                     JVMTI_ENABLE, sizeof(eventsList)\/sizeof(jvmtiEvent), eventsList, NULL))) {\n+                     JVMTI_ENABLE, sizeof(eventsList)\/sizeof(jvmtiEvent), eventsList, nullptr))) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/AddToBootstrapClassLoaderSearch\/bootclssearch_agent.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,2 +159,2 @@\n-    jvmti = NULL;\n-    p_segment1 = p_segment2 = phase_to_check = NULL;\n+    jvmti = nullptr;\n+    p_segment1 = p_segment2 = phase_to_check = nullptr;\n@@ -167,2 +167,2 @@\n-    p_segment1 = nsk_jvmti_findOptionStringValue(\"segment1\", NULL);\n-    if (!NSK_VERIFY(p_segment1 != NULL)) {\n+    p_segment1 = nsk_jvmti_findOptionStringValue(\"segment1\", nullptr);\n+    if (!NSK_VERIFY(p_segment1 != nullptr)) {\n@@ -176,2 +176,2 @@\n-    p_segment2 = nsk_jvmti_findOptionStringValue(\"segment2\", NULL);\n-    if (p_segment2 != NULL) {\n+    p_segment2 = nsk_jvmti_findOptionStringValue(\"segment2\", nullptr);\n+    if (p_segment2 != nullptr) {\n@@ -184,1 +184,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -188,2 +188,2 @@\n-    phase_to_check = nsk_jvmti_findOptionStringValue(\"phasetocheck\", NULL);\n-    if (!NSK_VERIFY(phase_to_check != NULL)) {\n+    phase_to_check = nsk_jvmti_findOptionStringValue(\"phasetocheck\", nullptr);\n+    if (!NSK_VERIFY(phase_to_check != nullptr)) {\n@@ -230,1 +230,1 @@\n-                     JVMTI_ENABLE, sizeof(eventsList)\/sizeof(jvmtiEvent), eventsList, NULL))) {\n+                     JVMTI_ENABLE, sizeof(eventsList)\/sizeof(jvmtiEvent), eventsList, nullptr))) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/AddToSystemClassLoaderSearch\/systemclssearch_agent.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -224,1 +224,1 @@\n-        if (!NSK_VERIFY(constantPool != NULL)) {\n+        if (!NSK_VERIFY(constantPool != nullptr)) {\n@@ -265,1 +265,1 @@\n-                if (!NSK_VERIFY(utf8 != NULL)) {\n+                if (!NSK_VERIFY(utf8 != nullptr)) {\n@@ -298,1 +298,1 @@\n-            if (constantPool[i] != NULL) {\n+            if (constantPool[i] != nullptr) {\n@@ -1141,1 +1141,1 @@\n-        if (!NSK_VERIFY(gen != NULL)) {\n+        if (!NSK_VERIFY(gen != nullptr)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/Injector.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,3 +40,3 @@\n-static jthread agentThread = NULL;\n-static jvmtiStartFunction agentThreadProc = NULL;\n-static void* agentThreadArg = NULL;\n+static jthread agentThread = nullptr;\n+static jvmtiStartFunction agentThreadProc = nullptr;\n+static void* agentThreadArg = nullptr;\n@@ -55,3 +55,3 @@\n-static jvmtiEnv* jvmti_env = NULL;\n-static JavaVM* jvm = NULL;\n-static JNIEnv* jni_env = NULL;\n+static jvmtiEnv* jvmti_env = nullptr;\n+static JavaVM* jvm = nullptr;\n+static JNIEnv* jni_env = nullptr;\n@@ -104,1 +104,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -109,1 +109,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -117,1 +117,1 @@\n-    if (jvmti_env != NULL) {\n+    if (jvmti_env != nullptr) {\n@@ -156,1 +156,1 @@\n-    agentThread = NULL;\n+    agentThread = nullptr;\n@@ -170,5 +170,5 @@\n-    jobject threadName = NULL;\n-    jclass threadClass = NULL;\n-    jmethodID threadCtor = NULL;\n-    jobject threadObject = NULL;\n-    jobject threadGlobalRef = NULL;\n+    jobject threadName = nullptr;\n+    jclass threadClass = nullptr;\n+    jmethodID threadCtor = nullptr;\n+    jobject threadObject = nullptr;\n+    jobject threadGlobalRef = nullptr;\n@@ -176,2 +176,2 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (threadClass = jni_env->FindClass(THREAD_CLASS_NAME)) != NULL)) {\n-        return NULL;\n+    if (!NSK_JNI_VERIFY(jni_env, (threadClass = jni_env->FindClass(THREAD_CLASS_NAME)) != nullptr)) {\n+        return nullptr;\n@@ -181,2 +181,2 @@\n-            jni_env->GetMethodID(threadClass, THREAD_CTOR_NAME, THREAD_CTOR_SIGNATURE)) != NULL))\n-        return NULL;\n+            jni_env->GetMethodID(threadClass, THREAD_CTOR_NAME, THREAD_CTOR_SIGNATURE)) != nullptr))\n+        return nullptr;\n@@ -184,2 +184,2 @@\n-    if (!NSK_JNI_VERIFY(jni_env, (threadName = jni_env->NewStringUTF(THREAD_NAME)) != NULL))\n-        return NULL;\n+    if (!NSK_JNI_VERIFY(jni_env, (threadName = jni_env->NewStringUTF(THREAD_NAME)) != nullptr))\n+        return nullptr;\n@@ -188,2 +188,2 @@\n-            jni_env->NewObject(threadClass, threadCtor, threadName)) != NULL))\n-        return NULL;\n+            jni_env->NewObject(threadClass, threadCtor, threadName)) != nullptr))\n+        return nullptr;\n@@ -192,1 +192,1 @@\n-            jni_env->NewGlobalRef(threadObject)) != NULL)) {\n+            jni_env->NewGlobalRef(threadObject)) != nullptr)) {\n@@ -194,1 +194,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -202,1 +202,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -223,1 +223,1 @@\n-    if (thread == NULL) {\n+    if (thread == nullptr) {\n@@ -225,1 +225,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -250,1 +250,1 @@\n-        if (nsk_jvmti_runAgentThread(jni_env, jvmti_env) == NULL)\n+        if (nsk_jvmti_runAgentThread(jni_env, jvmti_env) == nullptr)\n@@ -374,1 +374,1 @@\n-    jclass* classes = NULL;\n+    jclass* classes = nullptr;\n@@ -376,1 +376,1 @@\n-    jclass foundClass = NULL;\n+    jclass foundClass = nullptr;\n@@ -379,1 +379,1 @@\n-    if (!NSK_VERIFY(signature != NULL)) {\n+    if (!NSK_VERIFY(signature != nullptr)) {\n@@ -381,1 +381,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -386,1 +386,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -390,2 +390,2 @@\n-        char* sig = NULL;\n-        char* generic = NULL;\n+        char* sig = nullptr;\n+        char* generic = nullptr;\n@@ -398,1 +398,1 @@\n-        if (sig != NULL && strcmp(signature, sig) == 0) {\n+        if (sig != nullptr && strcmp(signature, sig) == 0) {\n@@ -408,1 +408,1 @@\n-        if (foundClass != NULL)\n+        if (foundClass != nullptr)\n@@ -414,1 +414,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -418,1 +418,1 @@\n-                jni_env->NewGlobalRef(foundClass)) != NULL)) {\n+                jni_env->NewGlobalRef(foundClass)) != nullptr)) {\n@@ -420,1 +420,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -428,1 +428,1 @@\n-    jthread* threads = NULL;\n+    jthread* threads = nullptr;\n@@ -430,1 +430,1 @@\n-    jthread foundThread = NULL;\n+    jthread foundThread = nullptr;\n@@ -433,1 +433,1 @@\n-    if (!NSK_VERIFY(name != NULL)) {\n+    if (!NSK_VERIFY(name != nullptr)) {\n@@ -435,1 +435,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -440,1 +440,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -451,1 +451,1 @@\n-        if (info.name != NULL && strcmp(name, info.name) == 0) {\n+        if (info.name != nullptr && strcmp(name, info.name) == 0) {\n@@ -456,1 +456,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -458,1 +458,1 @@\n-        if (foundThread != NULL) {\n+        if (foundThread != nullptr) {\n@@ -465,1 +465,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -469,1 +469,1 @@\n-                jni_env->NewGlobalRef(foundThread)) != NULL)) {\n+                jni_env->NewGlobalRef(foundThread)) != nullptr)) {\n@@ -471,1 +471,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -510,1 +510,1 @@\n-    jvmtiLineNumberEntry* table = NULL;\n+    jvmtiLineNumberEntry* table = nullptr;\n@@ -577,1 +577,1 @@\n-static checkStatus_type checkStatus_func = NULL;\n+static checkStatus_type checkStatus_func = nullptr;\n@@ -603,3 +603,3 @@\n-    char *class_sig = NULL;\n-    char *name = NULL;\n-    char *sig = NULL;\n+    char *class_sig = nullptr;\n+    char *name = nullptr;\n+    char *sig = nullptr;\n@@ -615,1 +615,1 @@\n-    if (NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(mid, &name, &sig, NULL))) {\n+    if (NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(mid, &name, &sig, nullptr))) {\n@@ -620,1 +620,1 @@\n-             && NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(cls, &class_sig, NULL))\n+             && NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(cls, &class_sig, nullptr))\n@@ -629,1 +629,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -632,1 +632,1 @@\n-    if (sig != NULL)\n+    if (sig != nullptr)\n@@ -635,1 +635,1 @@\n-    if (class_sig != NULL)\n+    if (class_sig != nullptr)\n@@ -645,2 +645,2 @@\n-    if (callbacks == NULL) {\n-        NSK_COMPLAIN0(\"callbacks should not be NULL\\n\");\n+    if (callbacks == nullptr) {\n+        NSK_COMPLAIN0(\"callbacks should not be null\\n\");\n@@ -651,2 +651,2 @@\n-    if (callbacks->NativeMethodBind != NULL) {\n-        NSK_COMPLAIN0(\"callbacks.NativeMethodBind should be NULL\\n\");\n+    if (callbacks->NativeMethodBind != nullptr) {\n+        NSK_COMPLAIN0(\"callbacks.NativeMethodBind should be null\\n\");\n@@ -670,1 +670,1 @@\n-            jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, NULL)))\n+            jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_NATIVE_METHOD_BIND, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/agent_tools.cpp","additions":68,"deletions":68,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -104,1 +104,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(klass, &className, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(klass, &className, nullptr))) {\n@@ -164,1 +164,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->FindClass(\"java\/lang\/Thread\")) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->FindClass(\"java\/lang\/Thread\")) != nullptr)) {\n@@ -166,1 +166,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -169,1 +169,1 @@\n-            (threadConstructor = jni->GetMethodID(klass, \"<init>\", \"()V\")) != NULL)) {\n+            (threadConstructor = jni->GetMethodID(klass, \"<init>\", \"()V\")) != nullptr)) {\n@@ -171,1 +171,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -175,1 +175,1 @@\n-            (thread = jni->NewObject(klass, threadConstructor, NULL)) != NULL)) {\n+            (thread = jni->NewObject(klass, threadConstructor, nullptr)) != nullptr)) {\n@@ -177,1 +177,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -180,1 +180,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != nullptr)) {\n@@ -182,1 +182,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -194,2 +194,2 @@\n-    if (!NSK_JNI_VERIFY(jni, (threadNameString = jni->NewStringUTF(threadName)) != NULL))\n-        return NULL;\n+    if (!NSK_JNI_VERIFY(jni, (threadNameString = jni->NewStringUTF(threadName)) != nullptr))\n+        return nullptr;\n@@ -197,1 +197,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->FindClass(\"java\/lang\/Thread\")) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (klass = jni->FindClass(\"java\/lang\/Thread\")) != nullptr)) {\n@@ -199,1 +199,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -202,1 +202,1 @@\n-            (threadConstructor = jni->GetMethodID(klass, \"<init>\", \"(Ljava\/lang\/String;)V\")) != NULL)) {\n+            (threadConstructor = jni->GetMethodID(klass, \"<init>\", \"(Ljava\/lang\/String;)V\")) != nullptr)) {\n@@ -204,1 +204,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -208,1 +208,1 @@\n-            (thread = jni->NewObject(klass, threadConstructor, threadNameString)) != NULL)) {\n+            (thread = jni->NewObject(klass, threadConstructor, threadNameString)) != nullptr)) {\n@@ -210,1 +210,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -213,1 +213,1 @@\n-    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != NULL)) {\n+    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != nullptr)) {\n@@ -215,1 +215,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -233,2 +233,2 @@\n-    if (fileName == NULL) {\n-        NSK_COMPLAIN0(\"File name is NULL\\n\");\n+    if (fileName == nullptr) {\n+        NSK_COMPLAIN0(\"File name is null\\n\");\n@@ -253,1 +253,1 @@\n-            if (bytecode == NULL) {\n+            if (bytecode == nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/aod\/jvmti_aod.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,2 +62,2 @@\n-static jclass profile_klass = NULL;\n-static jfieldID count_field = NULL;\n+static jclass profile_klass = nullptr;\n+static jfieldID count_field = nullptr;\n@@ -67,3 +67,3 @@\n-static char** names = NULL;\n-static jvmtiClassDefinition* old_class_def = NULL;\n-static jvmtiClassDefinition* new_class_def = NULL;\n+static char** names = nullptr;\n+static jvmtiClassDefinition* old_class_def = nullptr;\n+static jvmtiClassDefinition* new_class_def = nullptr;\n@@ -72,1 +72,1 @@\n-static jrawMonitorID classLoadLock = NULL;\n+static jrawMonitorID classLoadLock = nullptr;\n@@ -102,2 +102,2 @@\n-    if (name != NULL &&\n-            class_being_redefined == NULL &&\n+    if (name != nullptr &&\n+            class_being_redefined == nullptr &&\n@@ -142,2 +142,2 @@\n-    char *name = NULL;\n-    char *signature = NULL;\n+    char *name = nullptr;\n+    char *signature = nullptr;\n@@ -147,1 +147,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, NULL))) {\n+    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &name, &signature, nullptr))) {\n@@ -153,1 +153,1 @@\n-    if (name != NULL)\n+    if (name != nullptr)\n@@ -155,1 +155,1 @@\n-    if (signature != NULL)\n+    if (signature != nullptr)\n@@ -178,2 +178,2 @@\n-            jclass klass = NULL;\n-            char *signature = NULL;\n+            jclass klass = nullptr;\n+            char *signature = nullptr;\n@@ -181,1 +181,1 @@\n-            if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != NULL)) {\n+            if (!NSK_JNI_VERIFY(jni_env, (klass = jni_env->GetObjectClass(exception)) != nullptr)) {\n@@ -185,1 +185,1 @@\n-            if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, NULL))) {\n+            if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &signature, nullptr))) {\n@@ -191,1 +191,1 @@\n-            if (signature != NULL)\n+            if (signature != nullptr)\n@@ -203,1 +203,1 @@\n-                    JVMTI_EVENT_SINGLE_STEP, NULL)))\n+                    JVMTI_EVENT_SINGLE_STEP, nullptr)))\n@@ -220,1 +220,1 @@\n-static jrawMonitorID waitLock = NULL;\n+static jrawMonitorID waitLock = nullptr;\n@@ -225,1 +225,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n@@ -229,1 +229,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, NULL)))\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, nullptr)))\n@@ -238,1 +238,1 @@\n-        if (!NSK_JNI_VERIFY(jni, (old_class_def[i].klass = jni->FindClass(names[i])) != NULL))\n+        if (!NSK_JNI_VERIFY(jni, (old_class_def[i].klass = jni->FindClass(names[i])) != nullptr))\n@@ -242,1 +242,1 @@\n-                jni->NewGlobalRef(old_class_def[i].klass)) != NULL))\n+                jni->NewGlobalRef(old_class_def[i].klass)) != nullptr))\n@@ -248,1 +248,1 @@\n-        if (!NSK_JNI_VERIFY(jni, (profile_klass = jni->FindClass(PROFILE_CLASS_NAME)) != NULL))\n+        if (!NSK_JNI_VERIFY(jni, (profile_klass = jni->FindClass(PROFILE_CLASS_NAME)) != nullptr))\n@@ -252,1 +252,1 @@\n-                jni->NewGlobalRef(profile_klass)) != NULL))\n+                jni->NewGlobalRef(profile_klass)) != nullptr))\n@@ -258,1 +258,1 @@\n-                                      \"I\")) != NULL))\n+                                      \"I\")) != nullptr))\n@@ -276,1 +276,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, NULL)))\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, nullptr)))\n@@ -321,1 +321,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_EXCEPTION, NULL)))\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_EXCEPTION, nullptr)))\n@@ -336,1 +336,1 @@\n-                        JVMTI_EVENT_SINGLE_STEP, NULL)))\n+                        JVMTI_EVENT_SINGLE_STEP, nullptr)))\n@@ -351,1 +351,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, NULL)))\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, nullptr)))\n@@ -363,1 +363,1 @@\n-    jvmtiEnv* jvmti = NULL;\n+    jvmtiEnv* jvmti = nullptr;\n@@ -391,1 +391,1 @@\n-    if (!NSK_VERIFY(package_name != NULL))\n+    if (!NSK_VERIFY(package_name != nullptr))\n@@ -406,1 +406,1 @@\n-    if (optValue != NULL) {\n+    if (optValue != nullptr) {\n@@ -420,1 +420,1 @@\n-    if (optValue != NULL) {\n+    if (optValue != nullptr) {\n@@ -440,1 +440,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n@@ -467,1 +467,1 @@\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n@@ -484,1 +484,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr)))\n@@ -486,1 +486,1 @@\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, NULL)))\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/hotswap\/HotSwap.cpp","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,1 +134,1 @@\n-        if (!NSK_VERIFY((s = jni->GetStringUTFChars(sInfo, &fCopy)) != NULL)) {\n+        if (!NSK_VERIFY((s = jni->GetStringUTFChars(sInfo, &fCopy)) != nullptr)) {\n@@ -140,1 +140,1 @@\n-            NSK_COMPLAIN1(\"Can't get string at %#p: NULL\\n\", sInfo);\n+            NSK_COMPLAIN1(\"Can't get string at %#p: null\\n\", sInfo);\n@@ -196,1 +196,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -241,1 +241,1 @@\n-    if (pRefRec != NULL) {\n+    if (pRefRec != nullptr) {\n@@ -254,1 +254,1 @@\n-    if (pRefRec != NULL) {\n+    if (pRefRec != nullptr) {\n@@ -383,1 +383,1 @@\n-    g_wrongHeapCallbacks.heap_iteration_callback         = NULL;\n+    g_wrongHeapCallbacks.heap_iteration_callback         = nullptr;\n@@ -389,2 +389,2 @@\n-    Java_nsk_jvmti_unit_FollowReferences_FollowRefObjects_resetTags(NULL, NULL);\n-    Java_nsk_jvmti_unit_FollowReferences_FollowRefObjects_resetRefsToVerify(NULL, NULL);\n+    Java_nsk_jvmti_unit_FollowReferences_FollowRefObjects_resetTags(nullptr, nullptr);\n+    Java_nsk_jvmti_unit_FollowReferences_FollowRefObjects_resetRefsToVerify(nullptr, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/jvmti_FollowRefObjects.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-            char* end = NULL;\n+            char* end = nullptr;\n@@ -105,1 +105,1 @@\n-            if (end == NULL || end == value || *end != '\\0') {\n+            if (end == nullptr || end == value || *end != '\\0') {\n@@ -143,1 +143,1 @@\n-    if (name == NULL || value == NULL) {\n+    if (name == nullptr || value == nullptr) {\n@@ -169,1 +169,1 @@\n-        if (name != NULL)\n+        if (name != nullptr)\n@@ -171,1 +171,1 @@\n-        if (value != NULL)\n+        if (value != nullptr)\n@@ -187,1 +187,1 @@\n-    if (context.options.string != NULL) {\n+    if (context.options.string != nullptr) {\n@@ -189,1 +189,1 @@\n-        context.options.string = NULL;\n+        context.options.string = nullptr;\n@@ -201,2 +201,2 @@\n-  if (s == NULL || *s == NULL) {\n-    return NULL;\n+  if (s == nullptr || *s == nullptr) {\n+    return nullptr;\n@@ -206,1 +206,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -212,1 +212,1 @@\n-    *s = NULL;\n+    *s = nullptr;\n@@ -221,3 +221,3 @@\n-    char *str = NULL;\n-    char *name = NULL;\n-    char *value = NULL;\n+    char *str = nullptr;\n+    char *name = nullptr;\n+    char *value = nullptr;\n@@ -225,1 +225,1 @@\n-    if (options == NULL)\n+    if (options == nullptr)\n@@ -236,1 +236,1 @@\n-    while ((name = token(&str, delimiters)) != NULL) {\n+    while ((name = token(&str, delimiters)) != nullptr) {\n@@ -239,1 +239,1 @@\n-        if (value != NULL) {\n+        if (value != nullptr) {\n@@ -251,1 +251,1 @@\n-    if (str != NULL) {\n+    if (str != nullptr) {\n@@ -260,2 +260,2 @@\n- * Returns value of given option name; or NULL if no such option found.\n- * If search name is NULL then complains an error and returns NULL.\n+ * Returns value of given option name; or nullptr if no such option found.\n+ * If search name is nullptr then complains an error and returns nullptr.\n@@ -266,3 +266,3 @@\n-    if (name == NULL) {\n-        nsk_complain(\"nsk_jvmti_findOptionValue(): option name is NULL\\n\");\n-        return NULL;\n+    if (name == nullptr) {\n+        nsk_complain(\"nsk_jvmti_findOptionValue(): option name is null\\n\");\n+        return nullptr;\n@@ -275,1 +275,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -280,1 +280,1 @@\n- * If options is specified but has empty value then complains an error and returns NULL.\n+ * If options is specified but has empty value then complains an error and returns nullptr.\n@@ -285,3 +285,3 @@\n-    if (name == NULL) {\n-        nsk_complain(\"nsk_jvmti_findOptionStringValue(): option name is NULL\\n\");\n-        return NULL;\n+    if (name == nullptr) {\n+        nsk_complain(\"nsk_jvmti_findOptionStringValue(): option name is null\\n\");\n+        return nullptr;\n@@ -291,1 +291,1 @@\n-    if (value == NULL) {\n+    if (value == nullptr) {\n@@ -298,1 +298,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -310,2 +310,2 @@\n-    if (name == NULL) {\n-        nsk_complain(\"nsk_jvmti_findOptionIntValue(): option name is NULL\\n\");\n+    if (name == nullptr) {\n+        nsk_complain(\"nsk_jvmti_findOptionIntValue(): option name is null\\n\");\n@@ -316,1 +316,1 @@\n-    if (value == NULL) {\n+    if (value == nullptr) {\n@@ -327,1 +327,1 @@\n-        char* endptr = NULL;\n+        char* endptr = nullptr;\n@@ -330,1 +330,1 @@\n-        if (endptr == NULL || *endptr != '\\0') {\n+        if (endptr == nullptr || *endptr != '\\0') {\n@@ -348,1 +348,1 @@\n- * If no such option then complains an error and returns NULL.\n+ * If no such option then complains an error and returns nullptr.\n@@ -353,1 +353,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -360,1 +360,1 @@\n- * If no such option then complains an error and returns NULL.\n+ * If no such option then complains an error and returns nullptr.\n@@ -365,1 +365,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -417,1 +417,1 @@\n-    jstring str_obj = NULL;\n+    jstring str_obj = nullptr;\n@@ -419,2 +419,2 @@\n-    if (!NSK_JNI_VERIFY(jni, (str_obj = jni->NewStringUTF(context.options.string)) != NULL)) {\n-        return NULL;\n+    if (!NSK_JNI_VERIFY(jni, (str_obj = jni->NewStringUTF(context.options.string)) != nullptr)) {\n+        return nullptr;\n@@ -456,1 +456,1 @@\n-    if (nsk_jvmti_findOptionValue(NSK_JVMTI_OPT_PATH_TO_NEW_BYTE_CODE) == NULL) {\n+    if (nsk_jvmti_findOptionValue(NSK_JVMTI_OPT_PATH_TO_NEW_BYTE_CODE) == nullptr) {\n@@ -462,1 +462,1 @@\n-    if (fileName == NULL) {\n+    if (fileName == nullptr) {\n@@ -482,1 +482,1 @@\n-            if (bytecode == NULL) {\n+            if (bytecode == nullptr) {\n@@ -597,1 +597,1 @@\n-    jmethodID method = NULL;\n+    jmethodID method = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/jvmti_tools.cpp","additions":47,"deletions":47,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    if (object_free_callback != NULL) {\n+    if (object_free_callback != nullptr) {\n@@ -61,3 +61,3 @@\n-static jvmtiHeapRootCallback heap_root_callback = NULL;\n-static jvmtiStackReferenceCallback stack_ref_callback = NULL;\n-static jvmtiObjectReferenceCallback object_ref_callback = NULL;\n+static jvmtiHeapRootCallback heap_root_callback = nullptr;\n+static jvmtiStackReferenceCallback stack_ref_callback = nullptr;\n+static jvmtiObjectReferenceCallback object_ref_callback = nullptr;\n@@ -185,1 +185,1 @@\n-    if (object_results_ref != NULL) {\n+    if (object_results_ref != nullptr) {\n@@ -187,1 +187,1 @@\n-        object_results_ref = NULL;\n+        object_results_ref = nullptr;\n@@ -189,1 +189,1 @@\n-    if (tag_results_ref != NULL) {\n+    if (tag_results_ref != nullptr) {\n@@ -191,1 +191,1 @@\n-        tag_results_ref = NULL;\n+        tag_results_ref = nullptr;\n@@ -213,1 +213,1 @@\n-    object_array = env->NewObjectArray(count, cls, NULL);\n+    object_array = env->NewObjectArray(count, cls, nullptr);\n@@ -336,1 +336,1 @@\n-        if (method == NULL) {\n+        if (method == nullptr) {\n@@ -365,2 +365,2 @@\n-    stack_ref_callback = NULL;\n-    object_ref_callback = NULL;\n+    stack_ref_callback = nullptr;\n+    object_ref_callback = nullptr;\n@@ -372,1 +372,1 @@\n-    heap_root_callback = NULL;\n+    heap_root_callback = nullptr;\n@@ -374,1 +374,1 @@\n-    object_ref_callback = NULL;\n+    object_ref_callback = nullptr;\n@@ -380,2 +380,2 @@\n-    heap_root_callback = NULL;\n-    stack_ref_callback = NULL;\n+    heap_root_callback = nullptr;\n+    stack_ref_callback = nullptr;\n@@ -453,1 +453,1 @@\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, NULL);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_OBJECT_FREE, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/unit\/Heap.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n- * Return a new thread mirror, or NULL if failed.\n+ * Return a new thread mirror, or nullptr if failed.\n@@ -80,2 +80,2 @@\n-    if (thread == NULL)\n-        return NULL;\n+    if (thread == nullptr)\n+        return nullptr;\n@@ -105,1 +105,1 @@\n- * Return the thread if started OK, or NULL if failed.\n+ * Return the thread if started OK, or nullptr if failed.\n@@ -109,2 +109,2 @@\n-    if (thread == NULL)\n-        return NULL;\n+    if (thread == nullptr)\n+        return nullptr;\n@@ -112,1 +112,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -119,1 +119,1 @@\n-    uintptr_t result = _beginthreadex(NULL,0,procedure,thread,0,&(thread->id));\n+    uintptr_t result = _beginthreadex(nullptr,0,procedure,thread,0,&(thread->id));\n@@ -122,1 +122,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -125,1 +125,1 @@\n-    int result = thr_create(NULL,0,procedure,thread,0,&(thread->id));\n+    int result = thr_create(nullptr,0,procedure,thread,0,&(thread->id));\n@@ -128,1 +128,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -138,1 +138,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -150,1 +150,1 @@\n- * or -1 if thread == NULL.\n+ * or -1 if thread == nullptr.\n@@ -154,1 +154,1 @@\n-    if (thread == NULL)\n+    if (thread == nullptr)\n@@ -162,1 +162,1 @@\n- * or -1 if thread == NULL.\n+ * or -1 if thread == nullptr.\n@@ -166,1 +166,1 @@\n-    if (thread == NULL)\n+    if (thread == nullptr)\n@@ -174,1 +174,1 @@\n- * or retuen -1 if thread == NULL.\n+ * or retuen -1 if thread == nullptr.\n@@ -178,1 +178,1 @@\n-    if (thread == NULL)\n+    if (thread == nullptr)\n@@ -187,1 +187,1 @@\n- * or return immediately, if thread == NULL.\n+ * or return immediately, if thread == nullptr.\n@@ -191,1 +191,1 @@\n-    if (thread == NULL)\n+    if (thread == nullptr)\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/native\/native_thread.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-    if (list_info == NULL) {\n-        return NULL;\n+    if (list_info == nullptr) {\n+        return nullptr;\n@@ -58,1 +58,1 @@\n-    if (list_info->arr == NULL) {\n+    if (list_info->arr == nullptr) {\n@@ -60,1 +60,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -87,1 +87,1 @@\n-        if (list_info->arr == NULL) {\n+        if (list_info->arr == nullptr) {\n@@ -134,1 +134,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/native\/nsk_list.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-                pthread_mutex_init((pthread_mutex_t*)mutex, NULL);\n+                pthread_mutex_init((pthread_mutex_t*)mutex, nullptr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/native\/nsk_mutex.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,2 @@\n-    if (fullname == NULL)\n-        return NULL;\n+    if (fullname == nullptr)\n+        return nullptr;\n@@ -85,1 +85,1 @@\n-    nsk_lvdisplay(NULL,0,format,ap);\n+    nsk_lvdisplay(nullptr,0,format,ap);\n@@ -97,1 +97,1 @@\n-    nsk_lvdisplay(NULL,0,format,ap);\n+    nsk_lvdisplay(nullptr,0,format,ap);\n@@ -104,1 +104,1 @@\n-    if (file != NULL)\n+    if (file != nullptr)\n@@ -114,1 +114,1 @@\n-    nsk_lvcomplain(NULL,0,format,ap);\n+    nsk_lvcomplain(nullptr,0,format,ap);\n@@ -127,1 +127,1 @@\n-    nsk_lvcomplain(NULL,0,format,ap);\n+    nsk_lvcomplain(nullptr,0,format,ap);\n@@ -160,1 +160,1 @@\n-      if (nl_ptr != NULL) {\n+      if (nl_ptr != nullptr) {\n@@ -168,1 +168,1 @@\n-      if (file != NULL) {\n+      if (file != nullptr) {\n@@ -175,1 +175,1 @@\n-    if (file != NULL) {\n+    if (file != nullptr) {\n@@ -268,1 +268,1 @@\n-    if (size <= 0 || bytes == NULL)\n+    if (size <= 0 || bytes == nullptr)\n@@ -301,1 +301,1 @@\n-    return (str == NULL)? \"<NULL>\" : str;\n+    return (str == nullptr)? \"<null>\" : str;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/native\/nsk_tools.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,2 @@\n-  jchar *nativeStr = NULL;                                                  \\\n-  type *nativeArray = NULL;                                                 \\\n+  jchar *nativeStr = nullptr;                                                  \\\n+  type *nativeArray = nullptr;                                                 \\\n@@ -46,1 +46,1 @@\n-  nativeArray = (type *)env->GetPrimitiveArrayCritical(array, NULL); CE     \\\n+  nativeArray = (type *)env->GetPrimitiveArrayCritical(array, nullptr); CE     \\\n@@ -49,1 +49,1 @@\n-  nativeStr = (jchar *)env->GetStringCritical(str, NULL); CE                \\\n+  nativeStr = (jchar *)env->GetStringCritical(str, nullptr); CE                \\\n@@ -55,1 +55,1 @@\n-  nativeStr = (jchar *)env->GetStringCritical(str, NULL); CE                \\\n+  nativeStr = (jchar *)env->GetStringCritical(str, nullptr); CE                \\\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/gclocker\/libgcl001.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,2 +111,2 @@\n-        element->str[j] = NULL;\n-        element->checkstr[j] = NULL;\n+        element->str[j] = nullptr;\n+        element->checkstr[j] = nullptr;\n@@ -220,2 +220,2 @@\n-        javachars->str[j] = NULL;\n-        javachars->checkstr[j] = NULL;\n+        javachars->str[j] = nullptr;\n+        javachars->checkstr[j] = nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress001.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,2 +144,2 @@\n-  if ((orig == NULL) || (clone == NULL)) {\n-    fprintf(stderr, \"JNI received a NULL array from Java\\n\");\n+  if ((orig == nullptr) || (clone == nullptr)) {\n+    fprintf(stderr, \"JNI received a null array from Java\\n\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/libjnistress003.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    if (stackOverflowErrorClass == NULL) {\n+    if (stackOverflowErrorClass == nullptr) {\n@@ -59,1 +59,1 @@\n-        if (stackOverflowErrorClass != NULL) {\n+        if (stackOverflowErrorClass != nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace005.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    if (stackOverflowErrorClass == NULL) {\n+    if (stackOverflowErrorClass == nullptr) {\n@@ -61,1 +61,1 @@\n-        if (stackOverflowErrorClass != NULL) {\n+        if (stackOverflowErrorClass != nullptr) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace006.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv* gJvmtiEnv = NULL;\n+static jvmtiEnv* gJvmtiEnv = nullptr;\n@@ -91,1 +91,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, NULL)))\n+        if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, nullptr)))\n@@ -97,1 +97,1 @@\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, NULL)))\n+        if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, nullptr)))\n@@ -135,1 +135,1 @@\n-    free(mn); mn = NULL;\n+    free(mn); mn = nullptr;\n@@ -171,1 +171,1 @@\n-    if (locStr == NULL) {\n+    if (locStr == nullptr) {\n@@ -189,1 +189,1 @@\n-    if (!NSK_VERIFY((gJvmtiEnv = nsk_jvmti_createJVMTIEnv(vm, reserved)) != NULL))\n+    if (!NSK_VERIFY((gJvmtiEnv = nsk_jvmti_createJVMTIEnv(vm, reserved)) != nullptr))\n@@ -213,1 +213,1 @@\n-    if (!NSK_JVMTI_VERIFY(gJvmtiEnv->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, NULL)))\n+    if (!NSK_JVMTI_VERIFY(gJvmtiEnv->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, nullptr)))\n@@ -216,1 +216,1 @@\n-    if (!NSK_JVMTI_VERIFY(gJvmtiEnv->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, NULL)))\n+    if (!NSK_JVMTI_VERIFY(gJvmtiEnv->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/indy\/func\/jvmti\/share\/IndyRedefineClass.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-static jvmtiEnv* gJvmtiEnv = NULL;\n+static jvmtiEnv* gJvmtiEnv = nullptr;\n@@ -92,1 +92,1 @@\n-                NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, NULL));\n+                NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, nullptr));\n@@ -111,1 +111,1 @@\n-    if (locStr == NULL) {\n+    if (locStr == nullptr) {\n@@ -119,1 +119,1 @@\n-    NSK_JVMTI_VERIFY(gJvmtiEnv->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, NULL));\n+    NSK_JVMTI_VERIFY(gJvmtiEnv->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, nullptr));\n@@ -125,1 +125,1 @@\n-        NSK_JVMTI_VERIFY(gJvmtiEnv->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL));\n+        NSK_JVMTI_VERIFY(gJvmtiEnv->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, nullptr));\n@@ -153,1 +153,1 @@\n-    if (locStr == NULL) {\n+    if (locStr == nullptr) {\n@@ -162,1 +162,1 @@\n-    NSK_JVMTI_VERIFY(gJvmtiEnv->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_BREAKPOINT, NULL));\n+    NSK_JVMTI_VERIFY(gJvmtiEnv->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_BREAKPOINT, nullptr));\n@@ -176,1 +176,1 @@\n-    if (!NSK_VERIFY((gJvmtiEnv = nsk_jvmti_createJVMTIEnv(vm, reserved)) != NULL))\n+    if (!NSK_VERIFY((gJvmtiEnv = nsk_jvmti_createJVMTIEnv(vm, reserved)) != nullptr))\n@@ -201,1 +201,1 @@\n-    if (!NSK_JVMTI_VERIFY(gJvmtiEnv->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, NULL)))\n+    if (!NSK_JVMTI_VERIFY(gJvmtiEnv->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, nullptr)))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/indy\/func\/jvmti\/stepBreakPopReturn\/stepBreakPopReturn.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-    if (!NSK_JNI_VERIFY(pEnv, (mhClass = pEnv->GetObjectClass(mhToCall)) != NULL))\n-        return NULL;\n+    if (!NSK_JNI_VERIFY(pEnv, (mhClass = pEnv->GetObjectClass(mhToCall)) != nullptr))\n+        return nullptr;\n@@ -54,2 +54,2 @@\n-    if (!NSK_JNI_VERIFY(pEnv, NULL != (mid = pEnv->GetMethodID(mhClass, \"invokeWithArguments\", \"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\"))))\n-        return NULL;\n+    if (!NSK_JNI_VERIFY(pEnv, nullptr != (mid = pEnv->GetMethodID(mhClass, \"invokeWithArguments\", \"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\"))))\n+        return nullptr;\n@@ -57,1 +57,1 @@\n-    NSK_JNI_VERIFY(pEnv, NULL != (objectClass = pEnv->FindClass(\"java\/lang\/Object\")));\n+    NSK_JNI_VERIFY(pEnv, nullptr != (objectClass = pEnv->FindClass(\"java\/lang\/Object\")));\n@@ -59,2 +59,2 @@\n-    if (!NSK_JNI_VERIFY(pEnv, NULL != (arguments = pEnv->NewObjectArray(ARGS_COUNT, objectClass, NULL))))\n-        return NULL;\n+    if (!NSK_JNI_VERIFY(pEnv, nullptr != (arguments = pEnv->NewObjectArray(ARGS_COUNT, objectClass, nullptr))))\n+        return nullptr;\n@@ -70,1 +70,1 @@\n-    NSK_JNI_VERIFY(pEnv, NULL != (result = pEnv->CallObjectMethod(mhToCall, mid, arguments)));\n+    NSK_JNI_VERIFY(pEnv, nullptr != (result = pEnv->CallObjectMethod(mhToCall, mid, arguments)));\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/stress\/jni\/nativeAndMH\/nativeAndMH.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-    if (!NSK_VERIFY((pStr = pEnv->GetStringUTFChars(src, NULL)) != NULL)) {\n+    if (!NSK_VERIFY((pStr = pEnv->GetStringUTFChars(src, nullptr)) != nullptr)) {\n@@ -73,2 +73,2 @@\n-    if (!NSK_JVMTI_VERIFY(pJvmtiEnv->GetMethodName(method, &szName, NULL, NULL))) {\n-        return NULL;\n+    if (!NSK_JVMTI_VERIFY(pJvmtiEnv->GetMethodName(method, &szName, nullptr, nullptr))) {\n+        return nullptr;\n@@ -80,1 +80,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -83,2 +83,2 @@\n-    if (!NSK_JVMTI_VERIFY(pJvmtiEnv->GetClassSignature(clazz, &szSignature, NULL))) {\n-        return NULL;\n+    if (!NSK_JVMTI_VERIFY(pJvmtiEnv->GetClassSignature(clazz, &szSignature, nullptr))) {\n+        return nullptr;\n@@ -91,1 +91,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -95,2 +95,2 @@\n-    if (mn == NULL) {\n-      return NULL;\n+    if (mn == nullptr) {\n+      return nullptr;\n@@ -118,1 +118,1 @@\n-    len = snprintf(NULL, 0, format, pMN->classSig, pMN->methodName, location) + 1;\n+    len = snprintf(nullptr, 0, format, pMN->classSig, pMN->methodName, location) + 1;\n@@ -122,1 +122,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -126,1 +126,1 @@\n-    if (result == NULL) {\n+    if (result == nullptr) {\n@@ -128,1 +128,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -140,1 +140,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -143,2 +143,2 @@\n-        if (!NSK_VERIFY((tls = malloc(sizeToAllocate)) != NULL))\n-            return NULL;\n+        if (!NSK_VERIFY((tls = malloc(sizeToAllocate)) != nullptr))\n+            return nullptr;\n@@ -149,1 +149,1 @@\n-            return NULL;\n+            return nullptr;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/share\/mlvmJvmtiUtils.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-static jvmtiEnv *test_jvmti = NULL;\n+static jvmtiEnv *test_jvmti = nullptr;\n@@ -53,1 +53,1 @@\n-    if (!NSK_VERIFY(env != NULL) || !NSK_VERIFY(clazzToRedefine != NULL) || !NSK_VERIFY(bytecodeArray != NULL)) {\n+    if (!NSK_VERIFY(env != nullptr) || !NSK_VERIFY(clazzToRedefine != nullptr) || !NSK_VERIFY(bytecodeArray != nullptr)) {\n@@ -64,1 +64,1 @@\n-            (classDef.class_bytes = (const unsigned char *) \/* jbyte* *\/ env->GetByteArrayElements(bytecodeArray, NULL)) != NULL)) {\n+            (classDef.class_bytes = (const unsigned char *) \/* jbyte* *\/ env->GetByteArrayElements(bytecodeArray, nullptr)) != nullptr)) {\n@@ -89,1 +89,1 @@\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/shared\/redefineClasses.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-                                NULL,\n+                                nullptr,\n@@ -57,1 +57,1 @@\n-                                NULL\n+                                nullptr\n@@ -85,1 +85,1 @@\n-                                NULL,\n+                                nullptr,\n@@ -90,1 +90,1 @@\n-                                NULL\n+                                nullptr\n@@ -114,1 +114,1 @@\n-                                NULL,\n+                                nullptr,\n@@ -119,1 +119,1 @@\n-                                NULL);\n+                                nullptr);\n@@ -155,1 +155,1 @@\n-                if (dbghelp == NULL)\n+                if (dbghelp == nullptr)\n@@ -162,1 +162,1 @@\n-        if (dbghelp == NULL) {\n+        if (dbghelp == nullptr) {\n@@ -168,1 +168,1 @@\n-                        if (dbghelp == NULL) {\n+                        if (dbghelp == nullptr) {\n@@ -173,1 +173,1 @@\n-        if (dbghelp == NULL) {\n+        if (dbghelp == nullptr) {\n@@ -183,1 +183,1 @@\n-        if (_MiniDumpWriteDump == NULL) {\n+        if (_MiniDumpWriteDump == nullptr) {\n@@ -196,1 +196,1 @@\n-        dumpFile = CreateFile(\"core.mdmp\", GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n+        dumpFile = CreateFile(\"core.mdmp\", GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);\n@@ -202,1 +202,1 @@\n-        pmei = NULL;\n+        pmei = nullptr;\n@@ -207,2 +207,2 @@\n-        if (_MiniDumpWriteDump(hProcess, processId, dumpFile, dumpType, pmei, NULL, NULL) == FALSE &&\n-                        _MiniDumpWriteDump(hProcess, processId, dumpFile, (MINIDUMP_TYPE)MiniDumpWithFullMemory, pmei, NULL, NULL) == FALSE) {\n+        if (_MiniDumpWriteDump(hProcess, processId, dumpFile, dumpType, pmei, nullptr, nullptr) == FALSE &&\n+                        _MiniDumpWriteDump(hProcess, processId, dumpFile, (MINIDUMP_TYPE)MiniDumpWithFullMemory, pmei, nullptr, nullptr) == FALSE) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/ProcessUtils.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -446,2 +446,2 @@\n-java\/awt\/GridLayout\/ComponentPreferredSize\/ComponentPreferredSize.java 8238720 windows-all\n-java\/awt\/GridLayout\/ChangeGridSize\/ChangeGridSize.java   8238720 windows-all\n+java\/awt\/GridLayout\/ComponentPreferredSize\/ComponentPreferredSize.java 8238720,8324782 windows-all,macosx-all\n+java\/awt\/GridLayout\/ChangeGridSize\/ChangeGridSize.java   8238720,8324782 windows-all,macosx-all\n@@ -475,0 +475,3 @@\n+# This test fails on macOS 14\n+java\/awt\/Choice\/SelectNewItemTest\/SelectNewItemTest.java 8324782 macosx-all\n+\n@@ -688,0 +691,3 @@\n+# This test fails on macOS 14\n+javax\/swing\/plaf\/synth\/7158712\/bug7158712.java 8324782 macosx-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-\n-\n@@ -47,1 +45,1 @@\n- * @run main ShapeNotSetSometimes\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 ShapeNotSetSometimes\n@@ -58,1 +56,0 @@\n-    private final Rectangle bounds = new Rectangle(220, 400, 300, 300);\n@@ -63,0 +60,2 @@\n+    private static final int DIM = 300;\n+    private static final int DELTA = 2;\n@@ -67,1 +66,1 @@\n-        robot.delay(1000);\n+        robot.delay(500);\n@@ -73,1 +72,2 @@\n-        backgroundFrame.setBounds(bounds);\n+        backgroundFrame.setSize(DIM, DIM);\n+        backgroundFrame.setLocationRelativeTo(null);\n@@ -84,1 +84,1 @@\n-\n+        \/\/ point at the center of white ellipse\n@@ -86,0 +86,2 @@\n+\n+        \/\/ mid points on the 4 sides - on the green background frame\n@@ -93,0 +95,1 @@\n+        \/\/ points just outside the ellipse (opposite side of diagonal)\n@@ -100,1 +103,2 @@\n-        window.setBounds(bounds);\n+        window.setSize(DIM, DIM);\n+        window.setLocationRelativeTo(null);\n@@ -111,1 +115,1 @@\n-            g.fillRect(0, 0, 300, 300);\n+            g.fillRect(0, 0, DIM, DIM);\n@@ -123,1 +127,1 @@\n-            g.fillRect(0, 0, bounds.width, bounds.height);\n+            g.fillRect(0, 0, DIM, DIM);\n@@ -158,2 +162,6 @@\n-                backgroundFrame.dispose();\n-                window.dispose();\n+                if (backgroundFrame != null) {\n+                    backgroundFrame.dispose();\n+                }\n+                if (window != null) {\n+                    window.dispose();\n+                }\n@@ -165,1 +173,0 @@\n-\n@@ -169,0 +176,4 @@\n+        robot.mouseMove(screenX, screenY);\n+        robot.waitForIdle();\n+        robot.delay(50);\n+\n@@ -179,1 +190,1 @@\n-        if (mustBeExpectedColor != expectedColor.equals(actualColor)) {\n+        if (mustBeExpectedColor != colorCompare(expectedColor, actualColor)) {\n@@ -193,0 +204,9 @@\n+    private static boolean colorCompare(Color expected, Color actual) {\n+        if (Math.abs(expected.getRed() - actual.getRed()) <= DELTA\n+                && Math.abs(expected.getGreen() - actual.getGreen()) <= DELTA\n+                && Math.abs(expected.getBlue() - actual.getBlue()) <= DELTA) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n","filename":"test\/jdk\/java\/awt\/Frame\/ShapeNotSetSometimes\/ShapeNotSetSometimes.java","additions":34,"deletions":14,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,2 @@\n-    if (ds == NULL) {\n-        printf(\"NULL drawing surface\\n\");\n+    if (ds == nullptr) {\n+        printf(\"null drawing surface\\n\");\n@@ -70,1 +70,1 @@\n-    if (dsi == NULL) {\n+    if (dsi == nullptr) {\n","filename":"test\/jdk\/java\/awt\/JAWT\/myfile.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.Menu;\n+import java.awt.MenuItem;\n+import java.awt.PopupMenu;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+\/*\n+ * @test\n+ * @bug 5090643\n+ * @key headful\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Menus added to the popup menu are truncated on XToolkit\n+ * @run main\/manual TruncatedPopupMenuTest\n+ *\/\n+\n+public class TruncatedPopupMenuTest {\n+    private static final String INSTRUCTIONS =\n+            \"1. Right-click on the Test Window.\\n\\n\" +\n+            \"2. Look at the appeared popup menu.\\n\\n\" +\n+            \"3. It should consist of one menu item (\\\"First simple menu item\\\")\\n\" +\n+            \"and one submenu (\\\"Just simple menu for the test\\\").\\n\\n\" +\n+            \"4. The submenu should not be truncated. The submenu title text should\\n\" +\n+            \"be followed by a triangle. On the whole, menu should be good-looking.\\n\\n\" +\n+            \"5. Left-click on the submenu (\\\"Just simple menu for the test\\\").\\n\" +\n+            \"After this operation, a submenu should popup. It should consist of\\n\"+\n+            \"one menu item (\\\"Second simple menu item \\\") and one submenu (\\\"Other Menu\\\").\\n\\n\" +\n+            \"6. The submenu should not be truncated. The \\\"Other Menu\\\" text should be followed by\\n\" +\n+            \"a triangle.\\n\\n\" +\n+            \"On the whole, menu should be good-looking.\\n\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                      .instructions(INSTRUCTIONS)\n+                      .rows(20)\n+                      .columns(55)\n+                      .testUI(TruncatedPopupMenuTest::createTestUI)\n+                      .build()\n+                      .awaitAndCheck();\n+    }\n+\n+    private static Frame createTestUI() {\n+        Menu subMenu = new Menu(\"Just simple menu for the test\");\n+        subMenu.add(new MenuItem(\"Second simple menu item\"));\n+        subMenu.add(new Menu(\"Other Menu\"));\n+\n+        PopupMenu popup = new PopupMenu();\n+        popup.add(new MenuItem(\"First simple menu item\"));\n+        popup.add(subMenu);\n+\n+        Frame testUI = new Frame(\"TruncatedPopupMenuTest\");\n+        testUI.add(popup);\n+        testUI.addMouseListener(new MouseAdapter() {\n+            public void mousePressed(MouseEvent me) {\n+                if (me.isPopupTrigger()) {\n+                    popup.show(me.getComponent(), me.getX(), me.getY());\n+                }\n+            }\n+            public void mouseReleased(MouseEvent me) {\n+                if (me.isPopupTrigger()) {\n+                    popup.show(me.getComponent(), me.getX(), me.getY());\n+                }\n+            }\n+        });\n+\n+        testUI.setSize(400, 400);\n+        return testUI;\n+   }\n+}\n","filename":"test\/jdk\/java\/awt\/PopupMenu\/TruncatedPopupMenuTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -314,0 +314,36 @@\n+    @Test\n+    public void testGroupElementIndexToString() {\n+        PathElement e = PathElement.groupElement(2);\n+        assertEquals(e.toString(), \"groupElement(2)\");\n+    }\n+\n+    @Test\n+    public void testGroupElementNameToString() {\n+        PathElement e = PathElement.groupElement(\"x\");\n+        assertEquals(e.toString(), \"groupElement(\\\"x\\\")\");\n+    }\n+\n+    @Test\n+    public void testSequenceElementToString() {\n+        PathElement e = PathElement.sequenceElement();\n+        assertEquals(e.toString(), \"sequenceElement()\");\n+    }\n+\n+    @Test\n+    public void testSequenceElementIndexToString() {\n+        PathElement e = PathElement.sequenceElement(2);\n+        assertEquals(e.toString(), \"sequenceElement(2)\");\n+    }\n+\n+    @Test\n+    public void testSequenceElementRangeToString() {\n+        PathElement e = PathElement.sequenceElement(2, 4);\n+        assertEquals(e.toString(), \"sequenceElement(2, 4)\");\n+    }\n+\n+    @Test\n+    public void testDerefereceElementToString() {\n+        PathElement e = PathElement.dereferenceElement();\n+        assertEquals(e.toString(), \"dereferenceElement()\");\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-    jvm->AttachCurrentThread((void**)&env, NULL);\n+    jvm->AttachCurrentThread((void**)&env, nullptr);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/unnamed\/libLinkerInvokerUnnamed.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    context->jvm->AttachCurrentThread((void**)&env, NULL);\n+    context->jvm->AttachCurrentThread((void**)&env, nullptr);\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/libLinkerInvokerModule.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-    context->jvm->AttachCurrentThread((void**)&env, NULL);\n+    context->jvm->AttachCurrentThread((void**)&env, nullptr);\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/libLoaderLookupInvoker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,0 +99,2 @@\n+                new Object[] { \"\\u0130\", false, 0, \"I\", 0, 1, false },\n+                new Object[] { \"\\u0130\", true,  0, \"I\", 0, 1, true },\n@@ -102,0 +104,2 @@\n+                new Object[] { \"\\u0131\", false, 0, \"I\", 0, 1, false },\n+                new Object[] { \"\\u0131\", true,  0, \"I\", 0, 1, true },\n","filename":"test\/jdk\/java\/lang\/String\/CompactString\/RegionMatches.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.io.Serializable;\n+import java.lang.Enum.EnumDesc;\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.runtime.ExactConversionsSupport;\n+import java.lang.runtime.SwitchBootstraps;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * @test\n+ * @bug 8304487\n+ * @summary Verify boundary and special cases of exact conversion predicates\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ * @compile ExactnessConversionsSupportTest.java\n+ * @run testng\/othervm ExactnessConversionsSupportTest\n+ *\/\n+@Test\n+public class ExactnessConversionsSupportTest {\n+\n+    public static void main(String[] args) {\n+        testByte();\n+        testShort();\n+        testChar();\n+        testInt();\n+        testLong();\n+        testFloat();\n+        testDouble();\n+    }\n+\n+    public static void testByte() {\n+        assertEquals(true,  ExactConversionsSupport.isIntToByteExact((byte) (Byte.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToByteExact((byte) (0)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToByteExact((byte) (Byte.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isIntToByteExact((short) (Short.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToByteExact((short) (0)));\n+        assertEquals(false, ExactConversionsSupport.isIntToByteExact((short) (Short.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isIntToByteExact((char) (Character.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToByteExact((char) (Character.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isIntToByteExact(Integer.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isIntToByteExact(0));\n+        assertEquals(false, ExactConversionsSupport.isIntToByteExact(Integer.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isLongToByteExact(Long.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isLongToByteExact(0L));\n+        assertEquals(false, ExactConversionsSupport.isLongToByteExact(Long.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isFloatToByteExact(Float.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToByteExact((float) 0));\n+        assertEquals(false, ExactConversionsSupport.isFloatToByteExact(Float.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isFloatToByteExact(Float.NaN));\n+        assertEquals(false, ExactConversionsSupport.isFloatToByteExact(Float.POSITIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isFloatToByteExact(Float.NEGATIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isFloatToByteExact(-0.0f));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToByteExact(+0.0f));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToByteExact(Double.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToByteExact(0d));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToByteExact(Double.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToByteExact(Double.NaN));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToByteExact(Double.POSITIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToByteExact(Double.NEGATIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToByteExact(-0.0d));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToByteExact(+0.0d));\n+    }\n+    public static void testShort() {\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((byte) (Byte.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((byte) (0)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((byte) (Byte.MIN_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((short) (Short.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((short) (0)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((short) (Short.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isIntToShortExact((char) (Character.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((char) (Character.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isIntToShortExact((Integer.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((0)));\n+        assertEquals(false, ExactConversionsSupport.isIntToShortExact((Integer.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isLongToShortExact(Long.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isLongToShortExact(0L));\n+        assertEquals(false, ExactConversionsSupport.isLongToShortExact(Long.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isFloatToShortExact(Float.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToShortExact(0f));\n+        assertEquals(false, ExactConversionsSupport.isFloatToShortExact(Float.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isFloatToShortExact(Float.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isFloatToShortExact(Float.NaN));\n+        assertEquals(false, ExactConversionsSupport.isFloatToShortExact(Float.POSITIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isFloatToShortExact(Float.NEGATIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isFloatToShortExact(-0.0f));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToShortExact(+0.0f));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToShortExact(Double.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToShortExact((double) 0));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToShortExact(Double.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToShortExact(Double.NaN));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToShortExact(Double.POSITIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToShortExact(Double.NEGATIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToShortExact(-0.0d));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToShortExact(+0.0d));\n+    }\n+    public static void testChar() {\n+        assertEquals(true,  ExactConversionsSupport.isIntToCharExact((byte) (Byte.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToCharExact((byte) (0)));\n+        assertEquals(false, ExactConversionsSupport.isIntToCharExact((byte) (Byte.MIN_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToCharExact((short) (Short.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToCharExact((short) (0)));\n+        assertEquals(false, ExactConversionsSupport.isIntToCharExact((short) (Short.MIN_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToCharExact((char) (Character.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToCharExact((char) (Character.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isIntToCharExact (Integer.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isIntToCharExact(0));\n+        assertEquals(false, ExactConversionsSupport.isIntToCharExact(Integer.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isLongToCharExact(Long.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isLongToCharExact(0l));\n+        assertEquals(false, ExactConversionsSupport.isLongToCharExact(Long.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isFloatToCharExact(Float.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToCharExact((float) 0));\n+        assertEquals(false, ExactConversionsSupport.isFloatToCharExact(Float.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isFloatToCharExact(Float.NaN));\n+        assertEquals(false, ExactConversionsSupport.isFloatToCharExact(Float.POSITIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isFloatToCharExact(Float.NEGATIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isFloatToCharExact(-0.0f));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToCharExact(+0.0f));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToCharExact(Double.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToCharExact((double) 0));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToCharExact(Double.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToCharExact(Double.NaN));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToCharExact(Double.POSITIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToCharExact(Double.NEGATIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToCharExact(-0.0d));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToCharExact(+0.0d));\n+    }\n+    public static void testInt() {\n+        assertEquals(false, ExactConversionsSupport.isLongToIntExact((Long.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isLongToIntExact((0L)));\n+        assertEquals(false, ExactConversionsSupport.isLongToIntExact((Long.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToIntExact((Float.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToIntExact(((float) 0)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToIntExact((Float.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToIntExact((Float.NaN)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToIntExact((Float.POSITIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToIntExact((Float.NEGATIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToIntExact((-0.0f)));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToIntExact((+0.0f)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToIntExact((Double.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToIntExact(((double) 0)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToIntExact((Double.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToIntExact((Double.NaN)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToIntExact((Double.POSITIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToIntExact((Double.NEGATIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToIntExact((-0.0d)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToIntExact((+0.0d)));\n+    }\n+    public static void testLong() {\n+        assertEquals(false, ExactConversionsSupport.isFloatToLongExact((Float.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToLongExact(((float) 0)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToLongExact((Float.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToLongExact((Float.NaN)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToLongExact((Float.POSITIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToLongExact((Float.NEGATIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToLongExact((-0.0f)));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToLongExact((+0.0f)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToLongExact((Double.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToLongExact(((double) 0)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToLongExact((Double.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToLongExact((Double.NaN)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToLongExact((Double.POSITIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToLongExact((Double.NEGATIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToLongExact((-0.0d)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToLongExact((+0.0d)));\n+    }\n+    public static void testFloat() {\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((byte) (Byte.MAX_VALUE))));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((byte) (0))));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((byte) (Byte.MIN_VALUE))));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((short) (Short.MAX_VALUE))));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((short) (0))));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((short) (Short.MIN_VALUE))));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((char) (Character.MAX_VALUE))));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((char) (Character.MIN_VALUE))));\n+        assertEquals(false, ExactConversionsSupport.isIntToFloatExact( (Integer.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact((0)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact((Integer.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isLongToFloatExact((Long.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isLongToFloatExact((0l)));\n+        assertEquals(true,  ExactConversionsSupport.isLongToFloatExact((Long.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToFloatExact((Double.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToFloatExact(((double) 0)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToFloatExact((Double.MIN_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToFloatExact((Double.NaN)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToFloatExact((Double.POSITIVE_INFINITY)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToFloatExact((Double.NEGATIVE_INFINITY)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToFloatExact((-0.0d)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToFloatExact((+0.0d)));\n+    }\n+    public static void testDouble() {\n+        assertEquals(false, ExactConversionsSupport.isLongToDoubleExact((Long.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isLongToDoubleExact((0L)));\n+        assertEquals(true,  ExactConversionsSupport.isLongToDoubleExact((Long.MIN_VALUE)));\n+    }\n+\n+    static void assertEquals(boolean expected, boolean actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/runtime\/ExactnessConversionsSupportTest.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -49,0 +49,1 @@\n+ * @modules java.base\/jdk.internal.classfile\n@@ -114,6 +115,3 @@\n-        try {\n-            testType(1, 0, 1, 1.0, Integer.class);\n-            fail(\"Didn't get the expected exception.\");\n-        } catch (IllegalArgumentException ex) {\n-            \/\/OK\n-        }\n+        testType(1, 0, 1, 1.0d, Integer.class);\n+        testType(1, 0, 1, 1.0f, Integer.class);\n+        testType(1, 0, 1, true, Integer.class);\n@@ -127,0 +125,9 @@\n+        testType(new Object() {\n+            @Override\n+            public boolean equals(Object obj) {\n+                if (obj instanceof Long i) {\n+                    return i == 1;\n+                }\n+                return super.equals(obj);\n+            }\n+        }, 0, 1, 1L);\n@@ -181,1 +188,0 @@\n-            MethodType.methodType(int.class, double.class, int.class),\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng\/othervm -ea -esa MaxStreams\n+ * @run testng\/othervm MaxStreams\n@@ -47,1 +47,0 @@\n-import java.util.concurrent.Semaphore;\n@@ -74,1 +73,0 @@\n-    volatile CountDownLatch latch;\n@@ -76,1 +74,0 @@\n-    final Semaphore canStartTestRun = new Semaphore(1);\n@@ -98,1 +95,1 @@\n-    @Test(dataProvider = \"uris\", timeOut=20000)\n+    @Test(dataProvider = \"uris\")\n@@ -100,3 +97,1 @@\n-        System.err.println(\"Semaphore acquire\");\n-        canStartTestRun.acquire();\n-        latch = new CountDownLatch(1);\n+        CountDownLatch latch = new CountDownLatch(1);\n@@ -209,1 +204,0 @@\n-            int c = -1;\n@@ -214,1 +208,1 @@\n-                c = counter.getAndIncrement();\n+                int c = counter.getAndIncrement();\n@@ -223,0 +217,6 @@\n+                } else if (c == MAX_STREAMS + 1) {\n+                    \/\/ client issues MAX_STREAMS + 3 requests in total\n+                    \/\/ but server should only see MAX_STREAMS + 2 in total. One is rejected by client\n+                    \/\/ counter c captured before increment so final value is MAX_STREAMS + 1\n+                    System.err.println(\"Counter reset\");\n+                    counter.set(0);\n@@ -226,9 +226,0 @@\n-            } finally {\n-                \/\/ client issues MAX_STREAMS + 3 requests in total\n-                \/\/ but server should only see MAX_STREAMS + 2 in total. One is rejected by client\n-                \/\/ counter c captured before increment so final value is MAX_STREAMS + 1\n-                if (c == MAX_STREAMS + 1) {\n-                    System.err.println(\"Semaphore release\");\n-                    counter.set(0);\n-                    canStartTestRun.release();\n-                }\n","filename":"test\/jdk\/java\/net\/httpclient\/MaxStreams.java","additions":10,"deletions":19,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import org.junit.jupiter.api.Test;\n+\n+import javax.script.ScriptEngineFactory;\n@@ -25,0 +28,3 @@\n+import java.util.Optional;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -26,0 +32,8 @@\n+\/*\n+ * @test\n+ * @bug 8196959 8320712\n+ * @summary Verify that ScriptEngineManager can load BadFactory without throwing NPE\n+ * @build BadFactory BadFactoryTest\n+ * @run junit\/othervm BadFactoryTest\n+ * @run junit\/othervm -Djava.security.manager=allow BadFactoryTest\n+ *\/\n@@ -27,1 +41,5 @@\n-    public static void main(String[] args) {\n+\n+    @Test\n+    public void scriptEngineManagerShouldLoadBadFactory() {\n+        \/\/ Check that ScriptEngineManager initializes even in the\n+        \/\/ presence of a ScriptEngineFactory returning nulls\n@@ -29,0 +47,6 @@\n+\n+        \/\/ Sanity check that ScriptEngineManager actually found the BadFactory\n+        Optional<ScriptEngineFactory> badFactory = m.getEngineFactories().stream()\n+                .filter(fac -> fac.getClass() == BadFactory.class)\n+                .findAny();\n+        assertTrue(badFactory.isPresent(), \"BadFactory not found\");\n","filename":"test\/jdk\/javax\/script\/JDK_8196959\/BadFactoryTest.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-#\n-# Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# @test\n-# @bug 8196959\n-# @summary BadFactory that results in NPE being thrown from ScriptEngineManager\n-#\n-# @build BadFactory BadFactoryTest\n-# @run shell BadFactoryTest.sh\n-\n-if [ \"${TESTSRC}\" = \"\" ]\n-then\n-  echo \"TESTSRC not set.  Test cannot execute.  Failed.\"\n-  exit 1\n-fi\n-\n-. ${TESTSRC}\/..\/CommonSetup.sh\n-\n-echo \"Creating JAR file ...\"\n-\n-$JAR ${TESTTOOLVMOPTS} -cf ${TESTCLASSES}\/badfactory.jar \\\n-    -C ${TESTCLASSES} BadFactory.class \\\n-    -C ${TESTCLASSES} BadFactoryTest.class \\\n-    -C \"${TESTSRC}\" META-INF\/services\/javax.script.ScriptEngineFactory\n-\n-echo \"Running test with security manager ...\"\n-$JAVA ${TESTVMOPTS} -Djava.security.manager -classpath \\\n-  \"${TESTCLASSES}${PS}${TESTCLASSES}\/badfactory.jar\" \\\n-  BadFactoryTest\n-\n-ret=$?\n-if [ $ret -ne 0 ]\n-then\n-  exit $ret\n-fi\n-\n-echo \"Running test without security manager ...\"\n-$JAVA ${TESTVMOPTS} -classpath \\\n-  \"${TESTCLASSES}${PS}${TESTCLASSES}\/badfactory.jar\" \\\n-  BadFactoryTest\n","filename":"test\/jdk\/javax\/script\/JDK_8196959\/BadFactoryTest.sh","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -25,1 +26,1 @@\n- * @bug 8170349\n+ * @bug 8170349 8259550\n@@ -29,0 +30,1 @@\n+ * @run main\/othervm\/manual -Dswing.defaultlaf=javax.swing.plaf.nimbus.NimbusLookAndFeel PrintManualTest_FitWidthMultiple\n@@ -61,1 +63,1 @@\n-    public PrintManualTest_FitWidthMultiple(CountDownLatch latch){\n+    public PrintManualTest_FitWidthMultiple(CountDownLatch latch) {\n@@ -78,1 +80,1 @@\n-        final MessageFormat header=new MessageFormat(\"JTable Printing Header {0}\");\n+        final MessageFormat header = new MessageFormat(\"JTable Printing Header {0}\");\n@@ -94,2 +96,2 @@\n-                instructFrame=new JFrame(\"PrintManualTest_NormalSingle\");\n-                JPanel panel=new JPanel(new BorderLayout());\n+                instructFrame = new JFrame(\"PrintManualTest_NormalSingle\");\n+                JPanel panel = new JPanel(new BorderLayout());\n@@ -111,1 +113,1 @@\n-                panel.add(addInfo(info),BorderLayout.CENTER);\n+                panel.add(addInfo(info), BorderLayout.CENTER);\n@@ -114,1 +116,1 @@\n-                instructFrame.setBounds(600,100,350,350);\n+                instructFrame.setBounds(600, 100, 350, 350);\n@@ -117,1 +119,1 @@\n-                final JButton printButton=new JButton(\"Print\");\n+                final JButton printButton = new JButton(\"Print\");\n@@ -120,1 +122,1 @@\n-                final TableModel datamodel=new AbstractTableModel(){\n+                final TableModel datamodel = new AbstractTableModel(){\n@@ -122,1 +124,3 @@\n-                    public int getColumnCount() { return 50;}\n+                    public int getColumnCount() {\n+                        return 50;\n+                    }\n@@ -124,1 +128,3 @@\n-                    public int getRowCount() { return 50; }\n+                    public int getRowCount() {\n+                        return 50;\n+                    }\n@@ -126,1 +132,3 @@\n-                    public Object getValueAt(int row, int column){ return new Integer(row*column);}\n+                    public Object getValueAt(int row, int column) {\n+                        return Integer.valueOf(row*column);\n+                    }\n@@ -130,1 +138,1 @@\n-                final JTable table=new JTable(datamodel);\n+                final JTable table = new JTable(datamodel);\n@@ -133,1 +141,1 @@\n-                JScrollPane scrollpane=new JScrollPane(table);\n+                JScrollPane scrollpane = new JScrollPane(table);\n@@ -138,1 +146,1 @@\n-                JPanel btnpanel=new JPanel();\n+                JPanel btnpanel = new JPanel();\n@@ -140,3 +148,3 @@\n-                fr.getContentPane().add(btnpanel,BorderLayout.SOUTH);\n-                fr.setBounds(0,0,400,400);\n-                fr.setSize(500,500);\n+                fr.getContentPane().add(btnpanel, BorderLayout.SOUTH);\n+                fr.setBounds(0, 0, 400, 400);\n+                fr.setSize(500, 500);\n@@ -146,1 +154,1 @@\n-                fr.getRootPane().getActionMap().put(\"printButton\", new AbstractAction(){\n+                fr.getRootPane().getActionMap().put(\"printButton\", new AbstractAction() {\n@@ -148,1 +156,1 @@\n-                    public void actionPerformed(ActionEvent e){\n+                    public void actionPerformed(ActionEvent e) {\n@@ -164,1 +172,1 @@\n-                final PrintRequestAttributeSet prattr=new HashPrintRequestAttributeSet();\n+                final PrintRequestAttributeSet prattr = new HashPrintRequestAttributeSet();\n@@ -167,1 +175,1 @@\n-                printButton.addActionListener(new ActionListener(){\n+                printButton.addActionListener(new ActionListener() {\n@@ -169,3 +177,3 @@\n-                    public void actionPerformed(ActionEvent ae){\n-                        try{\n-                            table.print(JTable.PrintMode.FIT_WIDTH, header,footer,true,prattr,true);\n+                    public void actionPerformed(ActionEvent ae) {\n+                        try {\n+                            table.print(JTable.PrintMode.FIT_WIDTH, header, footer, true, prattr, true);\n@@ -187,1 +195,1 @@\n-        JTextArea jta = new JTextArea(info,8,20);\n+        JTextArea jta = new JTextArea(info, 8, 20);\n","filename":"test\/jdk\/javax\/swing\/JTable\/PrintManualTest_FitWidthMultiple.java","additions":35,"deletions":27,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-        classname(cname), method(mname), signature(sig), m(NULL), env(e) {\n+        classname(cname), method(mname), signature(sig), m(nullptr), env(e) {\n@@ -42,1 +42,1 @@\n-        assert (c != NULL);\n+        assert (c != nullptr);\n@@ -56,1 +56,1 @@\n-        if (obj != NULL) {\n+        if (obj != nullptr) {\n@@ -64,1 +64,1 @@\n-        if (obj == NULL) {\n+        if (obj == nullptr) {\n@@ -72,1 +72,1 @@\n-        if (env->ExceptionOccurred() != NULL) {\n+        if (env->ExceptionOccurred() != nullptr) {\n@@ -82,1 +82,1 @@\n-         assert(expected != NULL);\n+         assert(expected != nullptr);\n@@ -109,1 +109,1 @@\n-        assert(m != NULL);\n+        assert(m != nullptr);\n@@ -171,1 +171,1 @@\n-        assert(m != NULL);\n+        assert(m != nullptr);\n","filename":"test\/jdk\/jni\/nullCaller\/CallHelper.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,1 +134,1 @@\n-    assert(class_OpenResources != NULL);\n+    assert(class_OpenResources != nullptr);\n@@ -136,1 +136,1 @@\n-    assert(class_ClosedResources != NULL);\n+    assert(class_ClosedResources != nullptr);\n@@ -205,1 +205,1 @@\n-    pthread_join(id, NULL);\n+    pthread_join(id, nullptr);\n","filename":"test\/jdk\/jni\/nullCaller\/exeNullCallerTest.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug      4632553 4973607 8026567\n+ * @bug      4632553 4973607 8026567 8242564\n@@ -31,1 +31,3 @@\n- * @library  ..\/..\/lib\n+ *           Make sure class tree handles undefined types in the class\n+ *           hierarchy.\n+ * @library  \/tools\/lib ..\/..\/lib\n@@ -33,1 +35,1 @@\n- * @build    javadoc.tester.*\n+ * @build    toolbox.ToolBox javadoc.tester.*\n@@ -37,0 +39,3 @@\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n@@ -38,0 +43,1 @@\n+import toolbox.ToolBox;\n@@ -41,0 +47,2 @@\n+    private final ToolBox tb = new ToolBox();\n+\n@@ -46,0 +54,45 @@\n+    \/**\n+     * Given badpkg package containing class ChildClass with UndefinedClass\n+     *       base class, implementing UndefinedInterface and a defined\n+     *       interface\n+     * When the javadoc is generated with '--ignore-source-errors option'\n+     * Then javadoc exits successfully\n+     * And generates html for the ChildClass with UndefinedClass base class\n+     * And UndefinedInterface is not present in html\n+     *\/\n+    @Test\n+    public void testBadPkg(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package badpkg;\n+                    public class ChildClass extends UndefinedClass\n+                        implements UndefinedInterface, Iterable {\n+\n+                    }\n+                    \"\"\"\n+        );\n+\n+        javadoc(\"--ignore-source-errors\",\n+                \"-d\", base.resolve(\"badout\").toString(),\n+                \"--no-platform-links\",\n+                \"-sourcepath\", src.toString(),\n+                \"badpkg\");\n+\n+\n+        checkExit(Exit.OK);\n+        checkOutput(\"badpkg\/package-tree.html\", true,\n+                \"\"\"\n+                    <li class=\"circle\">badpkg.<a href=\"ChildClass.html\" class=\"type-name-link\" title=\"\\\n+                    class in badpkg\">ChildClass<\/a> (implements java.lang.Iterable&lt;T&gt;)<\/li>\n+                    \"\"\");\n+        checkOutput(\"badpkg\/ChildClass.html\", true,\n+                \"\"\"\n+                    <div class=\"type-signature\"><span class=\"modifiers\">public class <\/span>\\\n+                    <span class=\"element-name type-name-label\">ChildClass<\/span>\n+                    <span class=\"extends-implements\">extends UndefinedClass\n+                    implements java.lang.Iterable<\/span><\/div>\n+                    \"\"\");\n+        checkOutput(\"badpkg\/ChildClass.html\", false, \"UndefinedInterface\");\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testClassTree\/TestClassTree.java","additions":57,"deletions":4,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -399,0 +399,5 @@\n+\n+    public void testInstanceOf() {\n+        assertStatus(\"i instanceof Integer\", COMPLETE, \"i instanceof Integer\");\n+        assertStatus(\"i instanceof int\", COMPLETE, \"i instanceof int\");\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/CompletenessTest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @build KullaTesting TestingInputStream\n+ * @run testng PrimitiveInstanceOfTest\n+ *\/\n+import jdk.jshell.JShell;\n+import org.testng.annotations.Test;\n+\n+import java.util.function.Consumer;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class PrimitiveInstanceOfTest extends KullaTesting {\n+\n+    public void testInstanceOf() {\n+        assertEval(\"int i = 42;\");\n+        assertEval(\"i instanceof Integer\");\n+        assertEval(\"i instanceof int\");\n+    }\n+\n+    public void testInstanceOfRef() {\n+        assertEval(\"Integer i = 42;\");\n+        assertEval(\"i instanceof Integer\");\n+        assertEval(\"i instanceof Number\");\n+    }\n+\n+    @org.testng.annotations.BeforeMethod\n+    public void setUp() {\n+        super.setUp(bc -> bc.compilerOptions(\"--source\", System.getProperty(\"java.specification.version\"), \"--enable-preview\").remoteVMOptions(\"--enable-preview\"));\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/PrimitiveInstanceOfTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.default.and.both.boolean.values\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --source 23\n+public class DefaultAndBothBoolean {\n+    private int test(boolean sel) {\n+        return switch (sel) {\n+            case true -> 1;\n+            case false -> 2;\n+            default -> 3;\n+        };\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DefaultAndBothBoolean.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.misc.not.applicable.types\n-\/\/ key: compiler.err.prob.found.req\n-\n-class NotApplicableTypes {\n-    void t(int i) {\n-        switch (i) {\n-            case Integer j -> {}\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotApplicableTypes.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.misc.feature.primitive.patterns\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class PrimitivePatternMatching {\n+    boolean m(Object o) {\n+        return o instanceof int s;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PrimitivePatternMatching.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.selector.type.not.allowed\n-\n-public class SelectorTypeNotAllowed {\n-    private void noLong(long sel) {\n-        switch (sel) {\n-            default -> {}\n-        }\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SelectorTypeNotAllowed.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -30,1 +30,9 @@\n-    boolean b = (this instanceof int);\n+    interface Sig {\n+        void m(int s);\n+    }\n+\n+    Sig consume(Sig s) { return s; }\n+\n+    public void meth() {\n+        Sig s = consume(int::new);\n+    }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/TypeReqClassArray.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,3 @@\n-    int i;\n-    boolean b = (i instanceof Object);\n+\n+    void method(Inner<int> in) {}\n+    class Inner<T> {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/TypeReqRef.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.unconditional.pattern.and.both.boolean.values\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --source 23\n+public class UnconditionalPatternAndBothBoolean {\n+    private int test(boolean sel) {\n+        return switch (sel) {\n+            case true -> 1;\n+            case false -> 2;\n+            case boolean b -> 3;\n+        };\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnconditionalPatternAndBothBoolean.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javax.lang.model.type.*;\n@@ -325,0 +326,69 @@\n+\n+    \/**\n+     * Vacuous implementation of javax.lang.model.util.Types to aid\n+     * in test development. Methods with defaults in the interface are\n+     * *not* overridden to allow them to be tested.\n+     *\/\n+    public static class VacuousTypes implements Types {\n+        public VacuousTypes() {}\n+\n+        @Override\n+        public Element asElement(TypeMirror t) {return null;}\n+\n+        @Override\n+        public boolean isSameType(TypeMirror t1, TypeMirror t2) {return false;}\n+\n+        @Override\n+        public boolean isSubtype(TypeMirror t1, TypeMirror t2) {return false;};\n+\n+        @Override\n+        public boolean isAssignable(TypeMirror t1, TypeMirror t2) {return false;};\n+\n+        @Override\n+        public boolean contains(TypeMirror t1, TypeMirror t2) {return false;};\n+\n+        @Override\n+        public boolean isSubsignature(ExecutableType m1, ExecutableType m2) {return false;}\n+\n+        @Override\n+        public List<? extends TypeMirror> directSupertypes(TypeMirror t) {return null;}\n+\n+        @Override\n+        public TypeMirror erasure(TypeMirror t) {return null;}\n+\n+        @Override\n+        public TypeElement boxedClass(PrimitiveType p) {return null;}\n+\n+        @Override\n+        public PrimitiveType unboxedType(TypeMirror t) {return null;}\n+\n+        @Override\n+        public TypeMirror capture(TypeMirror t) {return null;}\n+\n+        @Override\n+        public PrimitiveType getPrimitiveType(TypeKind kind) {return null;}\n+\n+        @Override\n+        public NullType getNullType() {return null;}\n+\n+        @Override\n+        public NoType getNoType(TypeKind kind) {return null;}\n+\n+        @Override\n+        public ArrayType getArrayType(TypeMirror componentType) {return null;}\n+\n+        @Override\n+        public WildcardType getWildcardType(TypeMirror extendsBound,\n+                                 TypeMirror superBound) {return null;}\n+\n+        @Override\n+        public DeclaredType getDeclaredType(TypeElement typeElem, TypeMirror... typeArgs) {return null;}\n+\n+\n+        @Override\n+        public DeclaredType getDeclaredType(DeclaredType containing,\n+                                 TypeElement typeElem, TypeMirror... typeArgs) {return null;}\n+\n+        @Override\n+        public TypeMirror asMemberOf(DeclaredType containing, Element element) {return null;}\n+    }\n","filename":"test\/langtools\/tools\/javac\/lib\/JavacTestingAbstractProcessor.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n- *\/\n+ * @compile --enable-preview --source ${jdk.version} CastConversionMatch.java *\/\n","filename":"test\/langtools\/tools\/javac\/patterns\/CastConversionMatch.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CastConversionMatch.java:11:26: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n+CastConversionMatch.java:11:26: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\n","filename":"test\/langtools\/tools\/javac\/patterns\/CastConversionMatch.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,7 +30,0 @@\n-        if (p instanceof P7(byte b)); \/\/incorrect pattern type\n-        if (p instanceof P7(long l)); \/\/incorrect pattern type\n-        switch (p) {\n-            case P7(byte b) -> {} \/\/incorrect pattern type - no exception should occur\n-            case P7(long l) -> {} \/\/incorrect pattern type - no exception should occur\n-            default -> {}\n-        }\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,4 +1,4 @@\n-DeconstructionPatternErrors.java:42:37: compiler.err.illegal.start.of.type\n-DeconstructionPatternErrors.java:44:28: compiler.err.illegal.start.of.type\n-DeconstructionPatternErrors.java:46:42: compiler.err.expected: ';'\n-DeconstructionPatternErrors.java:46:43: compiler.err.not.stmt\n+DeconstructionPatternErrors.java:35:37: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:37:28: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:39:42: compiler.err.expected: ';'\n+DeconstructionPatternErrors.java:39:43: compiler.err.not.stmt\n@@ -23,5 +23,1 @@\n-DeconstructionPatternErrors.java:30:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n-DeconstructionPatternErrors.java:31:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n-DeconstructionPatternErrors.java:33:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n-DeconstructionPatternErrors.java:34:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n-26 errors\n\\ No newline at end of file\n+22 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.out","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.file\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @build combo.ComboTestHelper\n+ * @compile PrimitiveInstanceOfComboTest.java\n+ * @run main PrimitiveInstanceOfComboTest\n+ *\/\n+\n+import combo.ComboInstance;\n+import combo.ComboParameter;\n+import combo.ComboTask;\n+import combo.ComboTestHelper;\n+import toolbox.ToolBox;\n+\n+public class PrimitiveInstanceOfComboTest extends ComboInstance<PrimitiveInstanceOfComboTest> {\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    protected ToolBox tb;\n+\n+    PrimitiveInstanceOfComboTest() {\n+        super();\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new ComboTestHelper<PrimitiveInstanceOfComboTest>()\n+                .withDimension(\"TYPE1\", (x, type1) -> x.type1 = type1, Type.values())\n+                .withDimension(\"TYPE2\", (x, type2) -> x.type2 = type2, Type.values())\n+                .withFailMode(ComboTestHelper.FailMode.FAIL_FAST)\n+                .run(PrimitiveInstanceOfComboTest::new);\n+    }\n+\n+    private Type type1;\n+    private Type type2;\n+\n+    private static final String test1 =\n+            \"\"\"\n+            public class Test {\n+                public static void doTest(#{TYPE1} in) {\n+                    var r = (#{TYPE2}) in;\n+                }\n+            }\n+            \"\"\";\n+\n+    private static final String test2 =\n+            \"\"\"\n+            public class Test {\n+                public static void doTest(#{TYPE1} in) {\n+                    var r = in instanceof #{TYPE2};\n+                }\n+            }\n+            \"\"\";\n+\n+    @Override\n+    protected void doWork() throws Throwable {\n+        ComboTask task1 = newCompilationTask()\n+                .withSourceFromTemplate(test1.replace(\"#{TYPE1}\", type1.code).replace(\"#{TYPE2}\", type2.code))\n+                .withOption(\"--enable-preview\")\n+                .withOption(\"-source\").withOption(JAVA_VERSION);;\n+\n+        ComboTask task2 = newCompilationTask()\n+                .withSourceFromTemplate(test2.replace(\"#{TYPE1}\", type1.code).replace(\"#{TYPE2}\", type2.code))\n+                .withOption(\"--enable-preview\")\n+                .withOption(\"-source\").withOption(JAVA_VERSION);;\n+\n+        task1.generate(result1 -> {\n+            task2.generate(result2 -> {\n+                if (result1.hasErrors() ^ result2.hasErrors()) {\n+                    throw new AssertionError(\"Unexpected result: \" +\n+                            \"\\n task1: \" + result1.hasErrors() + \", info: \" + result1.compilationInfo() +\n+                            \"\\n task1: \" + result2.hasErrors() + \", info: \" + result2.compilationInfo());\n+                }\n+            });\n+        });\n+    }\n+\n+    public enum Type implements ComboParameter {\n+        BYTE(\"byte\"),\n+        SHORT(\"short\"),\n+        CHAR(\"char\"),\n+        INT(\"int\"),\n+        LONG(\"long\"),\n+        FLOAT(\"float\"),\n+        DOUBLE(\"double\"),\n+        BOOLEAN(\"boolean\"),\n+\n+        BYTE_r(\"Byte\"),\n+        SHORT_r(\"Short\"),\n+        CHAR_r(\"Character\"),\n+        INTEGER_r(\"Integer\"),\n+        LONG_r(\"Long\"),\n+        FLOAT_r(\"Float\"),\n+        DOUBLE_r(\"Double\"),\n+        BOOLEAN_r(\"Boolean\");\n+\n+        private final String code;\n+\n+        Type(String code) {\n+            this.code = code;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            throw new UnsupportedOperationException(\"Not supported.\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfComboTest.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @enablePreview\n+ * @compile\/fail\/ref=PrimitiveInstanceOfErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW PrimitiveInstanceOfErrors.java\n+ *\/\n+public class PrimitiveInstanceOfErrors {\n+    public static boolean unboxingAndNarrowingPrimitiveNotAllowedPerCastingConversion() {\n+        Long l_within_int_range = 42L;\n+        Long l_outside_int_range = 999999999999999999L;\n+\n+        return l_within_int_range instanceof int && !(l_outside_int_range instanceof int);\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxingAndNarrowingPrimitive(T i) {\n+        return i instanceof byte;\n+    }\n+\n+    public static void boxingConversionsBetweenIncompatibleTypes() {\n+        int i = 42;\n+\n+        boolean ret1 = i instanceof Integer; \/\/ (Integer) i \/\/ OK and true\n+        boolean ret2 = i instanceof Double;  \/\/ error: incompatible types\n+        boolean ret3 = i instanceof Short;   \/\/ error: incompatible types\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfErrors.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+PrimitiveInstanceOfErrors.java:13:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Long, int)\n+PrimitiveInstanceOfErrors.java:13:55: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Long, int)\n+PrimitiveInstanceOfErrors.java:17:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: T, byte)\n+PrimitiveInstanceOfErrors.java:24:24: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.Double)\n+PrimitiveInstanceOfErrors.java:25:24: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.Short)\n+- compiler.note.preview.filename: PrimitiveInstanceOfErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+5 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfErrors.out","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,275 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @enablePreview\n+ * @compile PrimitiveInstanceOfNumericValueTests.java\n+ * @run main\/othervm PrimitiveInstanceOfNumericValueTests\n+ *\/\n+public class PrimitiveInstanceOfNumericValueTests {\n+\n+    public static void main(String[] args) {\n+        testByte();\n+        testShort();\n+        testChar();\n+        testInt();\n+        testLong();\n+        testFloat();\n+        testDouble();\n+    }\n+\n+    public static void testByte() {\n+        assertEquals(true,  ((byte) (Byte.MAX_VALUE)) instanceof byte);\n+        assertEquals(true,  ((byte) (0)) instanceof byte);\n+        assertEquals(true,  ((byte) (Byte.MIN_VALUE)) instanceof byte);\n+        assertEquals(false, ((short) (Short.MAX_VALUE)) instanceof byte);\n+        assertEquals(true,  ((short) (0)) instanceof byte);\n+        assertEquals(false, ((short) (Short.MIN_VALUE)) instanceof byte);\n+        assertEquals(false, ((char) (Character.MAX_VALUE)) instanceof byte);\n+        assertEquals(true,  ((char) (Character.MIN_VALUE)) instanceof byte);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  (0) instanceof byte);\n+        assertEquals(false, (Integer.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  (0L) instanceof byte);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  ((float) 0) instanceof byte);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Float.NaN) instanceof byte);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (-0.0f) instanceof byte);\n+        assertEquals(true,  (+0.0f) instanceof byte);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  ((double) 0) instanceof byte);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Double.NaN) instanceof byte);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (-0.0d) instanceof byte);\n+        assertEquals(true,  (+0.0d) instanceof byte);\n+    }\n+    public static void testShort() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof short);\n+        assertEquals(true, ((byte) (0)) instanceof short);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof short);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof short);\n+        assertEquals(true, ((short) (0)) instanceof short);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof short);\n+        assertEquals(false, ((char) (Character.MAX_VALUE)) instanceof short);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof short);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof short);\n+        assertEquals(true, (0) instanceof short);\n+        assertEquals(false, (Integer.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof short);\n+        assertEquals(true, (0L) instanceof short);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof short);\n+        assertEquals(true, ((float) 0) instanceof short);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Float.NaN) instanceof short);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof short);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof short);\n+        assertEquals(false, (-0.0f) instanceof short);\n+        assertEquals(true, (+0.0f) instanceof short);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof short);\n+        assertEquals(true, ((double) 0) instanceof short);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Double.NaN) instanceof short);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof short);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof short);\n+        assertEquals(false, (-0.0d) instanceof short);\n+        assertEquals(true, (+0.0d) instanceof short);\n+    }\n+    public static void testChar() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof char);\n+        assertEquals(true, ((byte) (0)) instanceof char);\n+        assertEquals(false, ((byte) (Byte.MIN_VALUE)) instanceof char);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof char);\n+        assertEquals(true, ((short) (0)) instanceof char);\n+        assertEquals(false, ((short) (Short.MIN_VALUE)) instanceof char);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof char);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof char);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof char);\n+        assertEquals(true, (0) instanceof char);\n+        assertEquals(false, (Integer.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof char);\n+        assertEquals(true, (0L) instanceof char);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof char);\n+        assertEquals(true, ((float) 0) instanceof char);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Float.NaN) instanceof char);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof char);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof char);\n+        assertEquals(false, (-0.0f) instanceof char);\n+        assertEquals(true, (+0.0f) instanceof char);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof char);\n+        assertEquals(true, ((double) 0) instanceof char);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Double.NaN) instanceof char);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof char);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof char);\n+        assertEquals(false, (-0.0d) instanceof char);\n+        assertEquals(true, (+0.0d) instanceof char);\n+    }\n+    public static void testInt() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof int);\n+        assertEquals(true, ((byte) (0)) instanceof int);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof int);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof int);\n+        assertEquals(true, ((short) (0)) instanceof int);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof int);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof int);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof int);\n+        assertEquals(true, (Integer.MAX_VALUE) instanceof int);\n+        assertEquals(true, (0) instanceof int);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof int);\n+        assertEquals(true, (0L) instanceof int);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof int);\n+        assertEquals(true, ((float) 0) instanceof int);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Float.NaN) instanceof int);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof int);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof int);\n+        assertEquals(false, (-0.0f) instanceof int);\n+        assertEquals(true, (+0.0f) instanceof int);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof int);\n+        assertEquals(true, ((double) 0) instanceof int);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Double.NaN) instanceof int);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof int);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof int);\n+        assertEquals(false, (-0.0d) instanceof int);\n+        assertEquals(true, (+0.0d) instanceof int);\n+    }\n+    public static void testLong() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof long);\n+        assertEquals(true, ((byte) (0)) instanceof long);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof long);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof long);\n+        assertEquals(true, ((short) (0)) instanceof long);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof long);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof long);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof long);\n+        assertEquals(true, (Integer.MAX_VALUE) instanceof long);\n+        assertEquals(true, (0L) instanceof long);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof long);\n+        assertEquals(true, (Long.MAX_VALUE) instanceof long);\n+        assertEquals(true, (0) instanceof long);\n+        assertEquals(true, (Long.MIN_VALUE) instanceof long);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof long);\n+        assertEquals(true, ((float) 0) instanceof long);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof long);\n+        assertEquals(false, (Float.NaN) instanceof long);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof long);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof long);\n+        assertEquals(false, (-0.0f) instanceof long);\n+        assertEquals(true, (+0.0f) instanceof long);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof long);\n+        assertEquals(true, ((double) 0) instanceof long);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof long);\n+        assertEquals(false, (Double.NaN) instanceof long);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof long);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof long);\n+        assertEquals(false, (-0.0d) instanceof long);\n+        assertEquals(true, (+0.0d) instanceof long);\n+    }\n+    public static void testFloat() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof float);\n+        assertEquals(true, ((byte) (0) instanceof float));\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof float);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof float);\n+        assertEquals(true, ((short) (0)) instanceof float);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof float);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof float);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof float);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof float);\n+        assertEquals(true, (0) instanceof float);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof float);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof float);\n+        assertEquals(true, (0L) instanceof float);\n+        assertEquals(true, (Long.MIN_VALUE) instanceof float);\n+        assertEquals(true, (Float.MAX_VALUE) instanceof float);\n+        assertEquals(true, ((float) 0) instanceof float);\n+        assertEquals(true, (Float.MIN_VALUE) instanceof float);\n+        assertEquals(true, (Float.NaN) instanceof float);\n+        assertEquals(true, (Float.POSITIVE_INFINITY) instanceof float);\n+        assertEquals(true, (Float.NEGATIVE_INFINITY) instanceof float);\n+        assertEquals(true, (-0.0f) instanceof float);\n+        assertEquals(true, (+0.0f) instanceof float);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof float);\n+        assertEquals(true, ((double) 0) instanceof float);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof float);\n+        assertEquals(true, (Double.NaN) instanceof float);\n+        assertEquals(true, (Double.POSITIVE_INFINITY) instanceof float);\n+        assertEquals(true, (Double.NEGATIVE_INFINITY) instanceof float);\n+        assertEquals(true, (-0.0d) instanceof float);\n+        assertEquals(true, (+0.0d) instanceof float);\n+    }\n+    public static void testDouble() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof double);\n+        assertEquals(true, ((byte) (0)) instanceof double);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof double);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof double);\n+        assertEquals(true, ((short) (0)) instanceof double);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof double);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof double);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof double);\n+        assertEquals(true, (Integer.MAX_VALUE) instanceof double);\n+        assertEquals(true, (0) instanceof double);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof double);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof double);\n+        assertEquals(true, (0L) instanceof double);\n+        assertEquals(true, (Long.MIN_VALUE) instanceof double);\n+        assertEquals(true, (Float.MAX_VALUE) instanceof double);\n+        assertEquals(true, ((float) 0) instanceof double);\n+        assertEquals(true, (Float.MIN_VALUE) instanceof double);\n+        assertEquals(true, (Float.NaN) instanceof double);\n+        assertEquals(true, (Float.POSITIVE_INFINITY) instanceof double);\n+        assertEquals(true, (Float.NEGATIVE_INFINITY) instanceof double);\n+        assertEquals(true, (-0.0f) instanceof double);\n+        assertEquals(true, (+0.0f) instanceof double);\n+        assertEquals(true, (Double.MAX_VALUE) instanceof double);\n+        assertEquals(true, ((double) 0) instanceof double);\n+        assertEquals(true, (Double.MIN_VALUE) instanceof double);\n+        assertEquals(true, (Double.NaN) instanceof double);\n+        assertEquals(true, (Double.POSITIVE_INFINITY) instanceof double);\n+        assertEquals(true, (Double.NEGATIVE_INFINITY) instanceof double);\n+        assertEquals(true, (-0.0d) instanceof double);\n+        assertEquals(true, (+0.0d) instanceof double);\n+    }\n+\n+    static void assertEquals(boolean expected, boolean actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfNumericValueTests.java","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @enablePreview\n+ * @compile PrimitiveInstanceOfPatternOpWithRecordPatterns.java\n+ * @run main\/othervm PrimitiveInstanceOfPatternOpWithRecordPatterns\n+ *\/\n+public class PrimitiveInstanceOfPatternOpWithRecordPatterns {\n+\n+    public static void main(String[] args) {\n+        assertEquals(true,  identityPrimitiveConversion());\n+        assertEquals(true,  wideningPrimitiveConversion());\n+        assertEquals(true,  narrowingPrimitiveConversion());\n+        assertEquals(true,  wideningAndNarrowingPrimitiveConversion());\n+        assertEquals(true,  boxingConversion());\n+        assertEquals(true,  boxingAndWideningReferenceConversion());\n+        assertEquals(true,  unboxing());\n+        assertEquals(true,  unboxingWithObject());\n+        assertEquals(true,  wideningReferenceConversionUnboxing());\n+        assertEquals(true,  wideningReferenceConversionUnboxingAndWideningPrimitive());\n+        assertEquals(true,  unboxingAndWideningPrimitiveExact());\n+        assertEquals(false, unboxingAndWideningPrimitiveNotExact());\n+        assertEquals(true,  unboxingWhenNullAndWideningPrimitive());\n+        assertEquals(true,  narrowingAndUnboxing());\n+    }\n+\n+    public static boolean identityPrimitiveConversion() {\n+        R_int r = new R_int(42);\n+        return r instanceof R_int(int _);\n+    }\n+\n+    public static boolean wideningPrimitiveConversion() {\n+        R_byte b = new R_byte((byte) 42);\n+        R_short s = new R_short((short) 42);\n+        R_char c = new R_char('a');\n+\n+        return b instanceof R_byte(int _) && s instanceof R_short(int _) && c instanceof R_char(int _);\n+    }\n+\n+    public static boolean narrowingPrimitiveConversion() {\n+        R_long l_within_int_range = new R_long(42L);\n+        R_long l_outside_int_range = new R_long(999999999999999999L);\n+\n+        return l_within_int_range instanceof R_long(int _) && !(l_outside_int_range instanceof R_long(int _));\n+    }\n+\n+    public static boolean wideningAndNarrowingPrimitiveConversion() {\n+        R_byte b = new R_byte((byte) 42);\n+        R_byte b2 = new R_byte((byte) -42);\n+        R_char c = new R_char((char) 42);\n+        return b instanceof R_byte(char _) && c instanceof R_char(byte _) && !(b2 instanceof R_byte(char _));\n+    }\n+\n+    public static boolean boxingConversion() {\n+        R_int i = new R_int(42);\n+\n+        return i instanceof R_int(Integer _);\n+    }\n+\n+    public static boolean boxingAndWideningReferenceConversion() {\n+        R_int i = new R_int(42);\n+        return i instanceof R_int(Object _) &&\n+                i instanceof R_int(Number _) &&\n+                i instanceof R_int(Comparable _);\n+    }\n+\n+    public static boolean unboxing() {\n+        R_Integer i = new R_Integer(Integer.valueOf(1));\n+        return i instanceof R_Integer(int _);\n+    }\n+\n+    public static boolean unboxingWithObject() {\n+        R_Object o1 = new R_Object((int) 42);\n+        R_Object o2 = new R_Object((byte) 42);\n+\n+        return o1 instanceof R_Object(int i1) &&\n+                o2 instanceof R_Object(byte b1) &&\n+                !(o1 instanceof R_Object(byte b2) &&\n+                !(o2 instanceof R_Object(int i2)));\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxing() {\n+        R_generic i = new R_generic(42);\n+        return i instanceof R_generic(int _);\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxingAndWideningPrimitive() {\n+        R_generic i = new R_generic(42);\n+        return i instanceof R_generic(double _);\n+    }\n+\n+    public static boolean unboxingAndWideningPrimitiveExact() {\n+        R_ByteValue b = new R_ByteValue(Byte.valueOf((byte)42));\n+        R_ShortValue s = new R_ShortValue(Short.valueOf((short)42));\n+        R_CharacterValue c = new R_CharacterValue(Character.valueOf('a'));\n+\n+        return (b instanceof R_ByteValue(int _)) && (s instanceof R_ShortValue(int _)) && (c instanceof R_CharacterValue(int _));\n+    }\n+\n+    public static boolean unboxingAndWideningPrimitiveNotExact() {\n+        int smallestIntNotRepresentable = 16777217; \/\/ 2^24 + 1\n+        R_Integer i = new R_Integer(Integer.valueOf(smallestIntNotRepresentable));\n+\n+        return i instanceof R_Integer(float _);\n+    }\n+\n+    public static boolean unboxingWhenNullAndWideningPrimitive() {\n+        R_ByteValue b = new R_ByteValue(null);\n+        R_ShortValue s = new R_ShortValue(null);\n+        R_CharacterValue c = new R_CharacterValue(null);\n+\n+        return !(b instanceof R_ByteValue(int _)) && !(s instanceof R_ShortValue(int _)) && !(c instanceof R_CharacterValue(int _));\n+    }\n+\n+    public static boolean narrowingAndUnboxing() {\n+        R_Number n = new R_Number(Byte.valueOf((byte) 42));\n+\n+        return n instanceof R_Number(byte _);\n+    }\n+\n+    static void assertEquals(boolean expected, boolean actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+\n+    record R_int(int i) {}\n+    record R_byte(byte b) {}\n+    record R_short(short b) {}\n+    record R_char(char c) {}\n+    record R_long(long l) {}\n+    record R_Integer(Integer i) {}\n+    record R_Object(Object i) {}\n+    record R_generic<T extends Integer>(int i) {}\n+    record R_ByteValue(Byte b) {}\n+    record R_ShortValue(Short s) {}\n+    record R_CharacterValue(Character s) {}\n+    record R_Number(Number s) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfPatternOpWithRecordPatterns.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @enablePreview\n+ * @compile PrimitiveInstanceOfTypeComparisonOp.java\n+ * @run main\/othervm PrimitiveInstanceOfTypeComparisonOp\n+ *\/\n+public class PrimitiveInstanceOfTypeComparisonOp {\n+\n+    public static void main(String[] args) {\n+        assertEquals(true,  identityPrimitiveConversion());\n+        assertEquals(true,  wideningPrimitiveConversion());\n+        assertEquals(true,  narrowingPrimitiveConversion());\n+        assertEquals(true,  wideningAndNarrowingPrimitiveConversion());\n+        assertEquals(true,  boxingConversion());\n+        assertEquals(true,  boxingAndWideningReferenceConversion());\n+        assertEquals(true,  unboxing());\n+        assertEquals(true,  unboxingWithObject());\n+        assertEquals(true,  wideningReferenceConversionUnboxing(42));\n+        assertEquals(true,  wideningReferenceConversionUnboxingAndWideningPrimitive(42));\n+        assertEquals(true,  unboxingAndWideningPrimitiveExact());\n+        assertEquals(false, unboxingAndWideningPrimitiveNotExact());\n+        assertEquals(true,  unboxingWhenNullAndWideningPrimitive());\n+        assertEquals(true,  narrowingAndUnboxing());\n+        assertEquals(true,  patternExtractRecordComponent());\n+        assertEquals(true,  exprMethod());\n+        assertEquals(true,  exprStaticallyQualified());\n+    }\n+\n+    public static boolean identityPrimitiveConversion() {\n+        int i = 42;\n+        return i instanceof int;\n+    }\n+\n+    public static boolean wideningPrimitiveConversion() {\n+        byte b = (byte) 42;\n+        short s = (short) 42;\n+        char c = 'a';\n+\n+        return b instanceof int && s instanceof int && c instanceof int;\n+    }\n+\n+    public static boolean narrowingPrimitiveConversion() {\n+        long l_within_int_range = 42L;\n+        long l_outside_int_range = 999999999999999999L;\n+\n+        return l_within_int_range instanceof int && !(l_outside_int_range instanceof int);\n+    }\n+\n+    public static boolean wideningAndNarrowingPrimitiveConversion() {\n+        byte b = (byte) 42;\n+        byte b2 = (byte) -42;\n+        char c = (char) 42;\n+        return b instanceof char && c instanceof byte && !(b2 instanceof char);\n+    }\n+\n+    public static boolean boxingConversion() {\n+        int i = 42;\n+\n+        return i instanceof Integer;\n+    }\n+\n+    public static boolean boxingAndWideningReferenceConversion() {\n+        int i = 42;\n+        return i instanceof Object &&\n+                i instanceof Number &&\n+                i instanceof Comparable;\n+    }\n+\n+    public static boolean unboxing() {\n+        Integer i = Integer.valueOf(1);\n+        return i instanceof int;\n+    }\n+\n+    public static boolean unboxingWithObject() {\n+        Object o1 = (int) 42;\n+        Object o2 = (byte) 42;\n+\n+        return o1 instanceof int i1 &&\n+                o2 instanceof byte b1 &&\n+                !(o1 instanceof byte b2 &&\n+                !(o2 instanceof int i2));\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxing(T i) {\n+        return i instanceof int;\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxingAndWideningPrimitive(T i) {\n+        return i instanceof double;\n+    }\n+\n+    public static boolean unboxingAndWideningPrimitiveExact() {\n+        Byte b = Byte.valueOf((byte)42);\n+        Short s = Short.valueOf((short)42);\n+        Character c = Character.valueOf('a');\n+\n+        return (b instanceof int) && (s instanceof int) && (c instanceof int);\n+    }\n+\n+    public static boolean unboxingAndWideningPrimitiveNotExact() {\n+        int smallestIntNotRepresentable = 16777217; \/\/ 2^24 + 1\n+        Integer i = Integer.valueOf(smallestIntNotRepresentable);\n+\n+        return i instanceof float;\n+    }\n+\n+    public static boolean unboxingWhenNullAndWideningPrimitive() {\n+        Byte b = null;\n+        Short s = null;\n+        Character c = null;\n+\n+        return !(b instanceof int) && !(s instanceof int) && !(c instanceof int);\n+    }\n+\n+    public static boolean narrowingAndUnboxing() {\n+        Number n = Byte.valueOf((byte) 42);\n+\n+        return n instanceof byte;\n+    }\n+\n+    public record P(int i) { }\n+    public static boolean patternExtractRecordComponent() {\n+        Object p = new P(42);\n+        if (p instanceof P(byte b)) {\n+            return b == 42;\n+        }\n+        return false;\n+    }\n+\n+    public static int meth() {return 42;}\n+    public static boolean exprMethod() {\n+        return meth() instanceof int;\n+    }\n+\n+    public class A1 {\n+        public static int i = 42;\n+    }\n+    public static boolean exprStaticallyQualified() {\n+        return A1.i instanceof int;\n+    }\n+\n+    static void assertEquals(boolean expected, boolean actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfTypeComparisonOp.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,597 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @enablePreview\n+ * @compile PrimitivePatternsSwitch.java\n+ * @run main\/othervm PrimitivePatternsSwitch\n+ *\/\n+public class PrimitivePatternsSwitch {\n+    public static void main(String[] args) {\n+        assertEquals(1,  primitiveSwitch(42));\n+        assertEquals(2,  primitiveSwitch(123));\n+        assertEquals(1,  primitiveSwitchUnnamed(42));\n+        assertEquals(2,  primitiveSwitchUnnamed(123));\n+        assertEquals(42, primitiveSwitch2());\n+        assertEquals(42, primitiveSwitch3());\n+        assertEquals(1,  primitiveSwitch4(0.0f));\n+        assertEquals(2,  primitiveSwitch4(1.0f));\n+        assertEquals(1,  primitiveSwitchUnconditionallyExact(Byte.MAX_VALUE));\n+        assertEquals(42, exhaustive0());\n+        assertEquals(1,  exhaustive1WithDefault());\n+        assertEquals(2,  exhaustive2WithDefault());\n+        assertEquals(1,  exhaustive1());\n+        assertEquals(1,  exhaustive2());\n+        assertEquals(1,  exhaustive3());\n+        assertEquals(1,  exhaustive4());\n+        assertEquals(2,  exhaustive5());\n+        assertEquals(1,  exhaustive6());\n+        assertEquals(1,  exhaustive7(true));\n+        assertEquals(1,  exhaustive7s(true));\n+        assertEquals(1,  exhaustive8(true));\n+        assertEquals(1,  exhaustive9(true));\n+        assertEquals(1,  exhaustive9(false));\n+        assertEquals(1,  exhaustiveWithRecords1());\n+        assertEquals(1,  exhaustiveWithRecords2());\n+        assertEquals(1,  exhaustiveWithRecords4());\n+        assertEquals(1,  exhaustiveWithRecords5());\n+        assertEquals(1,  exhaustiveWithRecords6());\n+        assertEquals(2,  ensureProperSelectionWithRecords());\n+        assertEquals(1,  ensureProperSelectionWithRecords2());\n+        assertEquals(3,  ensureProperSelectionWithRecords3());\n+        assertEquals(42, switchAndDowncastFromObjectPrimitive());\n+        assertEquals(42, dominationBetweenBoxedAndPrimitive());\n+        assertEquals(2,  wideningAndUnboxing());\n+        assertEquals(2,  wideningAndUnboxingInRecord());\n+        assertEquals(2,  wideningAndInferredUnboxingInRecord());\n+        assertEquals(5f, switchOverBoxedFloat(0f));\n+        assertEquals(7f, switchOverBoxedFloat(1f));\n+        assertEquals(9f, switchOverBoxedFloat(2f));\n+        assertEquals(9f, switchOverBoxedFloat(2f));\n+        assertEquals(5f, switchOverPrimitiveDouble(0d));\n+        assertEquals(7f, switchOverPrimitiveDouble(1d));\n+        assertEquals(9f, switchOverPrimitiveDouble(2d));\n+        assertEquals(1, switchOverPrimitiveChar('a'));\n+        assertEquals(-1, switchOverPrimitiveChar('x'));\n+        assertTrue(switchOverBoxedBooleanWithUnconditional(Boolean.valueOf(true)));\n+        assertTrue(switchOverBoxedBooleanWithUnconditional(true));\n+        assertTrue(!switchOverBoxedBooleanWithUnconditional(false));\n+        assertEquals(1, switchOverPrimitiveBooleanWithDefault(true));\n+        assertEquals(2, switchOverPrimitiveBooleanWithDefault(false));\n+        assertEquals(1, switchOverPrimitiveBoolean(true));\n+        assertEquals(2, switchOverPrimitiveBoolean(false));\n+        assertEquals(1, switchOverPrimitiveFloat(0.0f\/0.0f));\n+        assertEquals(2, switchOverPrimitiveFloat((float) Math.pow(0.0f\/0.0f, 0)));\n+        assertEquals(3, switchOverPrimitiveFloat(0.0f));\n+        assertEquals(4, switchOverPrimitiveFloat(-0.0f));\n+        assertEquals(1, switchRedirectedExactnessMethods1('a'));\n+        assertEquals(-1, switchRedirectedExactnessMethods1('\\u03A9'));\n+        assertEquals(1, switchRedirectedExactnessMethods2('\\u03A9'));\n+        assertEquals(-1, switchRedirectedExactnessMethods2('\\uFFFF'));\n+        assertEquals(1, switchLongAndUnconditional(32778L));\n+        assertEquals(2, switchLongAndUnconditional(42L));\n+        assertEquals(1, switchByte((byte) 128));\n+        assertEquals(2, switchByte((byte) 42));\n+        assertEquals(1, switchShort((short) 32778));\n+        assertEquals(2, switchShort((short) 42));\n+        assertEquals(1, switchInt(32778));\n+        assertEquals(2, switchInt(42));\n+        assertEquals(1, switchChar( '\\u0010'));\n+        assertEquals(2, switchChar('a'));\n+        assertEquals(1, testIntInNonEnhancedSwitchStatement(1));\n+        assertEquals(0, testIntInNonEnhancedSwitchStatement(0));\n+        assertEquals(1, testFloatInEnhancedSwitchStatement(1.0f));\n+        assertEquals(0, testFloatInEnhancedSwitchStatement(0.0f));\n+        assertEquals(1, testDoubleInEnhancedSwitchStatement(1.0d));\n+        assertEquals(0, testDoubleInEnhancedSwitchStatement(0.0d));\n+        assertEquals(1, testLongInEnhancedSwitchStatement(1l));\n+        assertEquals(0, testLongInEnhancedSwitchStatement(0l));\n+        assertEquals(1, testBooleanInEnhancedSwitchStatement(true));\n+        assertEquals(0, testBooleanInEnhancedSwitchStatement(false));\n+        assertEquals(1, testByteWrapperToIntUnconditionallyExact());\n+        assertEquals(1, testIntegerWrapperToFloat());\n+        assertEquals(-1, testIntegerWrapperToFloatInexact());\n+    }\n+\n+    public static int primitiveSwitch(int i) {\n+        return switch (i) {\n+            case int j when j == 42-> 1;\n+            case int j -> 2;\n+        };\n+    }\n+\n+    public static int primitiveSwitchUnnamed(int i) {\n+        return switch (i) {\n+            case int _ when i == 42-> 1;\n+            case int _ -> 2;\n+        };\n+    }\n+\n+    public static int primitiveSwitch2() {\n+        Object o = Integer.valueOf(42);\n+        switch (o) {\n+            case int i: return i;\n+            default: break;\n+        }\n+        return -1;\n+    }\n+\n+    public static int primitiveSwitch3() {\n+        int i = 42;\n+        switch (i) {\n+            case Integer ii: return ii;\n+        }\n+    }\n+\n+    public static int primitiveSwitch4(float f) {\n+        return switch (f) {\n+            case 0.0f -> 1;\n+            case Float fi when fi == 1f -> 2;\n+            case Float fi -> 3;\n+        };\n+    }\n+\n+    public static int primitiveSwitchUnconditionallyExact(byte c) {\n+        return switch (c) {\n+            case short _ -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive0() {\n+        Integer i = 42;\n+        switch (i) {\n+            case int j: return j;\n+        }\n+    }\n+\n+    public static int exhaustive1WithDefault() {\n+        int i = 42;\n+        return switch (i) {\n+            case byte  b -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    public static int exhaustive2WithDefault() {\n+        int i = 30000;\n+        return switch (i) {\n+            case byte  b -> 1;\n+            case short s -> 2;\n+            default -> 3;\n+        };\n+    }\n+\n+    public static int exhaustive1() {\n+        int i = 42;\n+        return switch (i) {\n+            case Integer p -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive2() {\n+        int i = 42;\n+        return switch (i) {\n+            case long d -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive3() {\n+        int i = 42;\n+        return switch (i) {\n+            case double d -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive4() {\n+        int i = 127;\n+        return switch (i) {\n+            case byte b -> 1;\n+            case double d -> 2;\n+        };\n+    }\n+\n+    public static int exhaustive5() {\n+        int i = 127 + 1;\n+        return switch (i) {\n+            case byte b -> 1;\n+            case double d -> 2;\n+        };\n+    }\n+\n+    public static int exhaustive6() {\n+        Integer i = Integer.valueOf(42);\n+        return switch (i) {\n+            case int p -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive7(Boolean b) {\n+        switch (b) {\n+            case true: return 1;\n+            case false: return 2;  \/\/ with reminder, null, OK\n+        }\n+    }\n+\n+    public static int exhaustive7s(Boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            case false -> 2;      \/\/ with reminder, null, OK\n+        };\n+    }\n+\n+    public static int exhaustive8(Boolean b) {\n+        switch (b) {\n+            case boolean bb: return 1;\n+        }\n+    }\n+\n+    public static int exhaustive9(boolean b) {\n+        switch (b) {\n+            case Boolean bb: return 1;\n+        }\n+    }\n+\n+    public static int exhaustiveWithRecords1() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because Integer exhaustive at type int\n+            case R_int(Integer x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords2() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because double unconditional at int\n+            case R_int(double x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords4() {\n+        R_Integer r = new R_Integer(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because R_Integer(int) exhaustive at type R_Integer(Integer), because int exhaustive at type Integer\n+            case R_Integer(int x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords5() {\n+        R_Integer r = new R_Integer(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because double exhaustive at Integer\n+            case R_Integer(double x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords6() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            case R_int(byte x) -> 1;\n+            case R_int(int x) -> 2;\n+        };\n+    }\n+\n+    public static int ensureProperSelectionWithRecords() {\n+        R_int r = new R_int(4242);\n+        return switch (r) {\n+            case R_int(byte x) -> 1;\n+            case R_int(int x) -> 2;\n+        };\n+    }\n+\n+    public static int ensureProperSelectionWithRecords2() {\n+        R_double r = new R_double(42);\n+        switch (r) {\n+            case R_double(int i):\n+                return meth_int(i);\n+            case R_double(double x):\n+                return meth_double(x);\n+        }\n+    }\n+\n+    public static int ensureProperSelectionWithRecords3() {\n+        R_int r = new R_int(4242);\n+        return switch (r) {\n+            case R_int(byte x) -> 1;\n+            case R_int(int x) when x == 236 -> 2;\n+            case R_int(int x) -> 3;\n+        };\n+    }\n+\n+    public static int meth_int(int i) { return 1; }\n+    public static int meth_double(double d) { return 2;}\n+\n+    public static int switchAndDowncastFromObjectPrimitive() {\n+        Object i = 42;\n+        return switch (i) {\n+            case Integer ib  -> ib;\n+            default -> -1;\n+        };\n+    }\n+\n+    public static int dominationBetweenBoxedAndPrimitive() {\n+        Object i = 42;\n+        return switch (i) {\n+            case Integer ib  -> ib;\n+            case byte ip     -> ip;\n+            default -> -1;\n+        };\n+    }\n+\n+    static int wideningAndUnboxing() {\n+        Number o = Integer.valueOf(42);\n+        return switch (o) {\n+            case byte b -> 1;\n+            case int i -> 2;\n+            case float f -> 3;\n+            default -> 4;\n+        };\n+    }\n+\n+    static int wideningAndUnboxingInRecord() {\n+        Box<Number> box = new Box<>(Integer.valueOf(42));\n+        return switch (box) {\n+            case Box<Number>(byte b) -> 1;\n+            case Box<Number>(int i) -> 2;\n+            case Box<Number>(float f) -> 3;\n+            default -> 4;\n+        };\n+    }\n+\n+    static int wideningAndInferredUnboxingInRecord() {\n+        Box<Number> box = new Box<>(Integer.valueOf(42));\n+        return switch (box) {\n+            case Box(byte b) -> 1;\n+            case Box(int i) -> 2;\n+            case Box(float f) -> 3;\n+            default -> 4;\n+        };\n+    }\n+\n+    public static float switchOverBoxedFloat(Float f) {\n+        return switch (f) {\n+            case 0f -> 5f + 0f;\n+            case Float fi when fi == 1f -> 6f + fi;\n+            case Float fi -> 7f + fi;\n+        };\n+    }\n+\n+    public static double switchOverPrimitiveDouble(Double d) {\n+        return switch (d) {\n+            case 0d -> 5d + 0d;\n+            case Double di when di == 1d -> 6d + di;\n+            case Double di -> 7d + di;\n+        };\n+    }\n+\n+    public static boolean switchOverBoxedBooleanWithUnconditional(Boolean b) {\n+        return switch (b) {\n+            case true -> true;\n+            case Boolean bi -> bi;\n+        };\n+    }\n+\n+    public static int switchOverPrimitiveBooleanWithDefault(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    public static int switchOverPrimitiveBoolean(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            case false -> 2;\n+        };\n+    }\n+\n+    public static int switchOverPrimitiveChar(char c) {\n+        return switch (c) {\n+            case 'a' -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    public static final float NaNconstant = Float.NaN;\n+    public static int switchOverPrimitiveFloat(float f) {\n+        return switch (f) {\n+            case NaNconstant -> 1;\n+            case 1.0f -> 2;\n+            case 0.0f -> 3;\n+            case -0.0f -> 4;\n+            default -> -1;\n+        };\n+    }\n+\n+    \/\/ tests that Exactness.char_byte is properly redirected to int_byte\n+    public static int switchRedirectedExactnessMethods1(char c) {\n+        return switch (c) {\n+            case byte _ -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    \/\/ tests that Exactness.char_short is properly redirected to int_short\n+    public static int switchRedirectedExactnessMethods2(char c) {\n+        return switch (c) {\n+            case short _ -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    \/\/ tests that Exactness.short_byte is properly redirected to int_byte\n+    public static int switchRedirectedExactnessMethods2(short c) {\n+        return switch (c) {\n+            case byte _ -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    public static int switchLongAndUnconditional(long l) {\n+        return switch (l) {\n+            case 32778L -> 1;\n+            case long c -> 2;\n+        };\n+    }\n+\n+    public static int switchByte(byte b) {\n+        return switch (b) {\n+            case (byte)128 -> 1;\n+            case byte c -> 2;\n+        };\n+    }\n+\n+    public static int switchShort(short s) {\n+        return switch (s) {\n+            case (short)32778 -> 1;\n+            case short c -> 2;\n+        };\n+    }\n+\n+    public static int switchInt(int i) {\n+        return switch (i) {\n+            case 32778 -> 1;\n+            case int c -> 2;\n+        };\n+    }\n+\n+    public static int switchChar(char c) {\n+        return switch (c) {\n+            case '\\u0010' -> 1;\n+            case char cc -> 2;\n+        };\n+    }\n+\n+    public static int testIntInNonEnhancedSwitchStatement(int v1) {\n+        int i = 0;\n+        switch (v1) {\n+            case 1:\n+                i = 1;\n+                break;\n+        }\n+        return i;\n+    }\n+\n+    public static int testFloatInEnhancedSwitchStatement(float v1) {\n+        int i = 0;\n+        switch (v1) {\n+            case 1.0f:\n+                i = 1;\n+                break;\n+            default:\n+                i = 0;\n+        }\n+        return i;\n+    }\n+\n+    public static int testDoubleInEnhancedSwitchStatement(double v1) {\n+        int i = 0;\n+        switch (v1) {\n+            case 1d:\n+                i = 1;\n+                break;\n+            default:\n+                i = 0;\n+        }\n+        return i;\n+    }\n+\n+    public static int testLongInEnhancedSwitchStatement(long v1) {\n+        int i = 0;\n+        switch (v1) {\n+            case 1l:\n+                i = 1;\n+                break;\n+            default:\n+                i = 0;\n+        }\n+        return i;\n+    }\n+\n+    public static int testBooleanInEnhancedSwitchStatement(boolean v1) {\n+        int i = 0;\n+        switch (v1) {\n+            case true:\n+                i = 1;\n+                break;\n+            default:\n+                i = 0;\n+        }\n+        return i;\n+    }\n+\n+    public static int testByteWrapperToIntUnconditionallyExact() {\n+        Byte b = Byte.valueOf((byte) 42);\n+        return switch (b) {\n+            case int p -> 1;\n+        };\n+    }\n+\n+    public static int testIntegerWrapperToFloat() {\n+        Integer i = Integer.valueOf(42);\n+        return switch (i) {\n+            case float p -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    public static int testIntegerWrapperToFloatInexact() {\n+        Integer i = Integer.valueOf(Integer.MAX_VALUE);\n+        return switch (i) {\n+            case float p -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+\n+    record R_Integer(Integer x) {}\n+    record R_int(int x) {}\n+    record R_double(double x) {}\n+    record Box<N extends Number>(N num) {}\n+\n+    static void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+\n+    static void assertEquals(float expected, float actual) {\n+        if (Float.compare(expected, actual) != 0) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+    static void assertEquals(double expected, double actual) {\n+        if (Double.compare(expected, actual) != 0) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+    static void assertTrue(boolean actual) {\n+        if (!actual) {\n+            throw new AssertionError(\"Expected: true, but got false\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitch.java","additions":597,"deletions":0,"binary":false,"changes":597,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @enablePreview\n+ * @compile\/fail\/ref=PrimitivePatternsSwitchErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW PrimitivePatternsSwitchErrors.java\n+ *\/\n+public class PrimitivePatternsSwitchErrors {\n+    record R_int(int x) {}\n+\n+    public static void dominationBetweenPrimitivePatterns() {\n+        int i = 42;\n+        switch (i) {\n+            case short s -> System.out.println(\"its a short\");\n+            case byte b  -> System.out.println(\"its a byte\"); \/\/ Error - dominated!\n+            default      -> System.out.println(\"any other integral value\");\n+        }\n+    }\n+\n+    public static int dominationWithRecordPatterns() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            case R_int(int x) -> 1;\n+            case R_int(byte x) -> 2;  \/\/ Error - dominated!\n+        };\n+    }\n+\n+    public static int inconvertibleNestedComponent() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            case R_int(Long x) -> 1; \/\/ inconvertible\n+        };\n+    }\n+\n+    public static int nonExhaustive1() {\n+        int i = 42;\n+        return switch (i) {  \/\/ Error - not exhaustive\n+            case short s -> s;\n+        };\n+    }\n+\n+    public static int nonExhaustive2() {\n+        int i = 42;\n+        return switch (i) { \/\/ Error - not exhaustive\n+            case byte  b -> 1;\n+            case short s -> 2;\n+        };\n+    }\n+\n+    public static int nonExhaustive3() {\n+        int i = 42;\n+        return switch (i) { \/\/ Error - not exhaustive\n+            case byte  b -> 1;\n+            case float f -> 2;\n+        };\n+    }\n+\n+    public static int dominationBetweenBoxedAndPrimitive() {\n+        int i = 42;\n+        return switch (i) {\n+            case Integer ib  -> ib;\n+            case byte ip     -> ip; \/\/ Error - dominated!\n+        };\n+    }\n+\n+    public static int constantDominatedWithPrimitivePattern() {\n+        int i = 42;\n+        return switch (i) {\n+            case int j -> 42;\n+            case 43    -> -1;   \/\/ Error - dominated!\n+        };\n+    }\n+\n+    public static int constantDominatedWithFloatPrimitivePattern() {\n+        float f = 42.0f;\n+        return switch (f) {\n+            case Float ff -> 42;\n+            case 43.0f    -> -1;   \/\/ Error - dominated!\n+        };\n+    }\n+\n+    void switchLongOverByte(byte b) {\n+        switch (b) {\n+            case 0L: return ;\n+        }\n+    }\n+\n+    void switchOverPrimitiveFloatFromInt(float f) {\n+        switch (f) {\n+            case 16777216:\n+                break;\n+            case 16777217:\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    void switchOverNotRepresentableFloat(Float f) {\n+        switch (f) {\n+            case 1.0f:\n+                break;\n+            case 0.999999999f:\n+                break;\n+            case Float fi:\n+                break;\n+        }\n+    }\n+\n+    int switchOverPrimitiveBooleanExhaustiveWithNonPermittedDefault(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            case false -> 2;\n+            default -> 3;\n+        };\n+    }\n+\n+    int switchOverPrimitiveBooleanExhaustiveWithNonPermittedDefaultStatement(boolean b) {\n+        switch (b) {\n+            case true: return 1;\n+            case false: return 2;\n+            default: return 3;\n+        }\n+    }\n+\n+    int switchOverPrimitiveBooleanExhaustiveWithNonPermittedUnconditionalStatement(boolean b) {\n+        switch (b) {\n+            case true: return 1;\n+            case false: return 2;\n+            case boolean bb: return 3; \/\/ error\n+        }\n+    }\n+\n+    void switchCombinationsNonIntegral() {\n+        float f = 0f;\n+        long l = 0L;\n+        double d = 0d;\n+        Float fB = 0F;\n+        Long lB = 0L;\n+        Double dB = 0D;\n+\n+        switch (f) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+\n+        switch (l) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+\n+        switch (d) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+\n+        switch (fB) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+\n+        switch (lB) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+\n+        switch (dB) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+    }\n+\n+    int switchOverPrimitiveBooleanExhaustiveWithNonPermittedUnconditional(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            case false -> 2;\n+            case boolean bb -> 3; \/\/ error\n+        };\n+    }\n+\n+    int duplicateUnconditionalWithPrimitives(int i) {\n+        return switch (i) {\n+            case int ii -> 1;\n+            case long l -> 2; \/\/ error\n+        };\n+    }\n+\n+    int booleanSingleCase1(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+        };\n+    }\n+\n+    int booleanSingleCase2(boolean b) {\n+        switch (b) {\n+            case true: return 1;\n+        }\n+    }\n+\n+    void nullAndPrimitive() {\n+        int i = 42;\n+        switch (i) {\n+            case short s -> System.out.println(\"its a short\");\n+            case null    -> System.out.println(\"oops\");\n+            default      -> System.out.println(\"any other integral value\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+PrimitivePatternsSwitchErrors.java:15:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:24:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:31:24: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.Long)\n+PrimitivePatternsSwitchErrors.java:62:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:70:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:78:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:84:18: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: long, byte)\n+PrimitivePatternsSwitchErrors.java:90:18: compiler.err.constant.label.not.compatible: int, float\n+PrimitivePatternsSwitchErrors.java:92:18: compiler.err.constant.label.not.compatible: int, float\n+PrimitivePatternsSwitchErrors.java:103:13: compiler.err.duplicate.case.label\n+PrimitivePatternsSwitchErrors.java:114:13: compiler.err.default.and.both.boolean.values\n+PrimitivePatternsSwitchErrors.java:122:13: compiler.err.default.and.both.boolean.values\n+PrimitivePatternsSwitchErrors.java:130:18: compiler.err.unconditional.pattern.and.both.boolean.values\n+PrimitivePatternsSwitchErrors.java:143:18: compiler.err.constant.label.not.compatible: long, float\n+PrimitivePatternsSwitchErrors.java:145:18: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: double, float)\n+PrimitivePatternsSwitchErrors.java:151:18: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: float, long)\n+PrimitivePatternsSwitchErrors.java:152:18: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: double, long)\n+PrimitivePatternsSwitchErrors.java:157:18: compiler.err.constant.label.not.compatible: long, double\n+PrimitivePatternsSwitchErrors.java:158:18: compiler.err.constant.label.not.compatible: float, double\n+PrimitivePatternsSwitchErrors.java:164:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: long, java.lang.Float)\n+PrimitivePatternsSwitchErrors.java:166:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: double, java.lang.Float)\n+PrimitivePatternsSwitchErrors.java:172:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: float, java.lang.Long)\n+PrimitivePatternsSwitchErrors.java:173:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: double, java.lang.Long)\n+PrimitivePatternsSwitchErrors.java:178:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: long, java.lang.Double)\n+PrimitivePatternsSwitchErrors.java:179:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: float, java.lang.Double)\n+PrimitivePatternsSwitchErrors.java:189:18: compiler.err.unconditional.pattern.and.both.boolean.values\n+PrimitivePatternsSwitchErrors.java:196:18: compiler.err.duplicate.unconditional.pattern\n+PrimitivePatternsSwitchErrors.java:216:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, int)\n+PrimitivePatternsSwitchErrors.java:30:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:37:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:44:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:52:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:201:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:207:9: compiler.err.not.exhaustive.statement\n+- compiler.note.preview.filename: PrimitivePatternsSwitchErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+34 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.out","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -131,0 +131,199 @@\n+    @Test\n+    public void testNestedPrimitive1(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(R r) {\n+                       if (r instanceof R(byte b)) {\n+                       }\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:4:28: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testNestedPrimitive2(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(R r) {\n+                       switch (r) {\n+                           case R(byte b) -> {}\n+                           default -> {}\n+                       }\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:5:20: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testNestedPrimitive3(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(R r) {\n+                       if (r instanceof R(long l)) {\n+                       }\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:4:28: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testNestedPrimitive4(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(R r) {\n+                       switch (r) {\n+                           case R(long l) -> {}\n+                           default -> {}\n+                       }\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:5:20: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testPrimitive2Reference1(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(int i) {\n+                       if (i instanceof Integer j) {}\n+                   }\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:4:13: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testPrimitive2Reference2(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(int i) {\n+                       switch (i) {\n+                           case Integer j -> {}\n+                       }\n+                   }\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testReference2Primitive1(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Integer i) {\n+                       if (i instanceof int j) {}\n+                   }\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:4:26: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testReference2Primitive2(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Integer i) {\n+                       switch (i) {\n+                           case int j -> {}\n+                       }\n+                   }\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testPrimitivePatternObject1(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Object o) {\n+                       if (o instanceof int j) {}\n+                   }\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:4:26: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testPrimitivePatternObject2(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Object o) {\n+                       switch (o) {\n+                           case int j -> {}\n+                       }\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testOtherPrimitives(Path base) throws Exception {\n+        for (String type : new String[] {\"boolean\", \"long\", \"float\", \"double\"}) {\n+            doTest(base,\n+                   \"\"\"\n+                   package test;\n+                   public class Test {\n+                       private void test($type v) {\n+                           switch (v) {\n+                               default -> {}\n+                           }\n+                       }\n+                   }\n+                   \"\"\".replace(\"$type\", type),\n+                   21,\n+                   \"Test.java:4:16: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+                   \"1 error\");\n+        }\n+    }\n+\n@@ -132,0 +331,4 @@\n+        doTest(base, testCode, 17, expectedErrors);\n+    }\n+\n+    private void doTest(Path base, String testCode, int sourceLevel, String... expectedErrors) throws IOException {\n@@ -141,1 +344,1 @@\n-                    .options(\"--release\", \"17\",\n+                    .options(\"--release\", \"\" + sourceLevel,\n","filename":"test\/langtools\/tools\/javac\/patterns\/SourceLevelChecks.java","additions":204,"deletions":1,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -130,6 +130,0 @@\n-    void primitivePattern(Object o) {\n-        switch (o) {\n-            case int i: break;\n-            default: break;\n-        }\n-    }\n@@ -242,10 +236,0 @@\n-    void primitiveToReference(int i) {\n-        switch (i) {\n-            case Integer j: break;\n-        }\n-    }\n-    void referenceToPrimitive(Integer i) {\n-        switch (i) {\n-            case int j: break;\n-        }\n-    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4,9 +4,11 @@\n-SwitchErrors.java:138:28: compiler.err.default.label.not.allowed\n-SwitchErrors.java:144:18: compiler.err.default.label.not.allowed\n-SwitchErrors.java:149:18: compiler.err.default.label.not.allowed\n-SwitchErrors.java:154:18: compiler.err.default.label.not.allowed\n-SwitchErrors.java:213:29: compiler.err.default.label.not.allowed\n-SwitchErrors.java:220:32: compiler.err.default.label.not.allowed\n-SwitchErrors.java:227:32: compiler.err.default.label.not.allowed\n-SwitchErrors.java:283:20: compiler.err.illegal.start.of.type\n-SwitchErrors.java:286:28: compiler.err.illegal.start.of.type\n+SwitchErrors.java:132:28: compiler.err.default.label.not.allowed\n+SwitchErrors.java:138:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:143:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:148:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:207:29: compiler.err.default.label.not.allowed\n+SwitchErrors.java:214:32: compiler.err.default.label.not.allowed\n+SwitchErrors.java:221:32: compiler.err.default.label.not.allowed\n+SwitchErrors.java:267:20: compiler.err.illegal.start.of.type\n+SwitchErrors.java:270:28: compiler.err.illegal.start.of.type\n+SwitchErrors.java:290:42: compiler.err.expected2: :, ->\n+SwitchErrors.java:299:45: compiler.err.expected2: :, ->\n@@ -14,2 +16,0 @@\n-SwitchErrors.java:315:45: compiler.err.expected2: :, ->\n-SwitchErrors.java:322:42: compiler.err.expected2: :, ->\n@@ -39,24 +39,21 @@\n-SwitchErrors.java:132:18: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n-SwitchErrors.java:143:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:149:27: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:155:18: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:167:18: compiler.err.pattern.expected\n-SwitchErrors.java:173:78: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:179:73: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:186:21: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:197:13: compiler.err.unconditional.pattern.and.default\n-SwitchErrors.java:195:29: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:204:24: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:220:21: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:227:29: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:239:18: compiler.err.duplicate.unconditional.pattern\n-SwitchErrors.java:244:18: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, java.lang.Integer)\n-SwitchErrors.java:249:18: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n-SwitchErrors.java:255:24: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:262:24: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:269:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:276:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:292:49: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n-SwitchErrors.java:294:55: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n-SwitchErrors.java:300:26: compiler.err.pattern.type.cannot.infer\n-SwitchErrors.java:315:21: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:137:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:143:27: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:149:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:161:18: compiler.err.pattern.expected\n+SwitchErrors.java:167:78: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:173:73: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:180:21: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:191:13: compiler.err.unconditional.pattern.and.default\n+SwitchErrors.java:189:29: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:198:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:214:21: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:221:29: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:233:18: compiler.err.duplicate.unconditional.pattern\n+SwitchErrors.java:239:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:246:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:253:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:260:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:276:49: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n+SwitchErrors.java:278:55: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n+SwitchErrors.java:284:26: compiler.err.pattern.type.cannot.infer\n+SwitchErrors.java:299:21: compiler.err.invalid.case.label.combination\n@@ -73,3 +70,3 @@\n-SwitchErrors.java:159:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:232:9: compiler.err.not.exhaustive.statement\n-74 errors\n\\ No newline at end of file\n+SwitchErrors.java:153:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:226:9: compiler.err.not.exhaustive.statement\n+71 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":35,"deletions":38,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302019\n+ * @summary Test basic operation of Elements.overrides\n+ * @library \/tools\/javac\/lib\n+ * @build   JavacTestingAbstractProcessor TestOverrides\n+ * @compile -processor TestOverrides -proc:only TestOverrides.java\n+ *\/\n+\n+import java.util.*;\n+import java.util.function.*;\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.*;\n+\n+\/**\n+ * Test basic workings of Elements.overrides\n+ *\/\n+public class TestOverrides extends JavacTestingAbstractProcessor {\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            checkObjectOverrides();\n+        }\n+        return true;\n+    }\n+\n+    private void checkObjectOverrides() {\n+        boolean elementSeen = false;\n+\n+        TypeElement objectElt = elements.getTypeElement(\"java.lang.Object\");\n+\n+        TypeElement objectInterfaceElt = elements.getTypeElement(\"ObjectInterface\");\n+        for (var method : ElementFilter.methodsIn(objectInterfaceElt.getEnclosedElements())) {\n+            elementSeen = true;\n+            Name methodName = method.getSimpleName();\n+            boolean expectedOverrideResult = method.getAnnotation(OverrideExpected.class).value();\n+            if (expectedOverrideResult !=\n+                elements.overrides(method, findMethod(methodName, objectElt), objectInterfaceElt ) ) {\n+                throw new RuntimeException(\"Unexpected overriding relation found for \" + method);\n+            }\n+\n+            if (!elementSeen) {\n+                throw new RuntimeException(\"No elements seen.\");\n+            }\n+        }\n+    }\n+\n+    ExecutableElement findMethod(Name name, TypeElement typeElt) {\n+        for (var method : ElementFilter.methodsIn(typeElt.getEnclosedElements())) {\n+            if (method.getSimpleName().equals(name)) {\n+                return method;\n+            }\n+        }\n+        return null;\n+    }\n+\n+}\n+\n+@interface OverrideExpected {\n+    boolean value() default true;\n+}\n+\n+\/**\n+ * Interface that has methods override-equivalent to methods of\n+ * java.lang.Object.\n+ *\/\n+interface ObjectInterface {\n+    @Override\n+    @OverrideExpected\n+    boolean equals(Object obj);\n+\n+    @Override\n+    @OverrideExpected\n+    int hashCode();\n+\n+    @Override\n+    @OverrideExpected\n+    String toString();\n+\n+    @OverrideExpected(value=false) \/\/ protected, not public method\n+    Object clone();\n+\n+    @OverrideExpected(value=false) \/\/ protected, not public method\n+    void finalize();\n+\n+    \/\/ Final methods of Object (getClass, wait, notify[all]) rejected\n+    \/\/ if declared in an interface.\n+}\n+\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/TestOverrides.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,305 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8042981\n+ * @summary Test if annotations are stripped from the results of Types' methods\n+ * @library \/tools\/javac\/lib\n+ * @modules java.compiler\n+ * jdk.compiler\n+ * @build JavacTestingAbstractProcessor TestAnnotationStripping\n+ * @compile -processor TestAnnotationStripping -proc:only TestAnnotationStripping.java\n+ *\/\n+\n+import java.lang.annotation.*;\n+import java.util.*;\n+import static java.util.Objects.*;\n+import javax.annotation.processing.*;\n+import javax.lang.model.SourceVersion;\n+import static javax.lang.model.SourceVersion.*;\n+import javax.lang.model.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.type.*;\n+import javax.lang.model.util.*;\n+import static javax.lang.model.util.ElementFilter.*;\n+import static javax.tools.Diagnostic.Kind.*;\n+import static javax.tools.StandardLocation.*;\n+\n+\/**\n+ * Test if annotations are stripped from the results of Types' methods\n+ *\/\n+public class TestAnnotationStripping extends JavacTestingAbstractProcessor {\n+    private Types vacuousTypes = new VacuousTypes();\n+\n+    \/**\n+     * Check expected behavior on classes and packages.\n+     *\/\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+        if (!roundEnv.processingOver()) {\n+            TypeElement juSetElt = eltUtils.getTypeElement(\"java.util.Set\");\n+            TypeElement testElt  = elements.getTypeElement(\"TestAnnotationStripping\");\n+            TypeElement boxElt   = elements.getTypeElement(\"TestAnnotationStripping.Box\");\n+\n+            TypeMirror expectedAnnotation = eltUtils.getTypeElement(\"TestTypeAnnotation\").asType();\n+\n+            for (ExecutableElement m :\n+                     methodsIn(eltUtils.getTypeElement(\"HostClass\").getEnclosedElements())) {\n+                \/*\n+                 * The kinds of types include:\n+                 *\n+                 * arrays\n+                 * declared types (classes, interfaces, etc.)\n+                 * error types\n+                 * executable types\n+                 * intersection types\n+                 * no-type\n+                 * null type\n+                 * primitive types\n+                 * type variable\n+                 * union type\n+                 * wildcards\n+                 *\n+                 * A subset of these can appear at the return type of\n+                 * a method. The general methodology is to verify that\n+                 * types that can appear as return types when\n+                 * annotated with type annotations appear as specified\n+                 * as the result of type operations or when new types\n+                 * are constructed.\n+                 *\/\n+\n+                TypeMirror returnType = m.getReturnType();\n+\n+                System.err.println(\"Checking \" + returnType);\n+\n+                testVacuous(returnType);\n+                checkDeepEmptyAnnotations(typeUtils.stripAnnotations(returnType));\n+\n+                checkExpectedTypeAnnotations(returnType, expectedAnnotation);\n+\n+                \/\/ Note: the result of Types.asElement is *not*\n+                \/\/ checked for its annotations since the return value\n+                \/\/ is an Element and not a TypeMirror.\n+\n+                System.err.print(\"\\tcapture()\");\n+                checkDeepEmptyAnnotations(typeUtils.capture(returnType));\n+\n+                System.err.print(\"\\terasure()\");\n+                checkDeepEmptyAnnotations(typeUtils.erasure(returnType));\n+\n+                System.err.print(\"\\tgetArrayType()\");\n+                ArrayType arrayType = typeUtils.getArrayType(returnType);\n+                checkEmptyAnnotations(arrayType);\n+                \/*\n+                 * \"Annotations on the component type are preserved.\"\n+                 *\/\n+                checkEqualTypeAndAnnotations(returnType, arrayType.getComponentType());\n+\n+                if (!returnType.getKind().isPrimitive()) {\n+                    \/*\n+                     * For getWildcardType()\n+                     * \"Annotations on the bounds are preserved.\"\n+                     *\/\n+                    WildcardType wcType;\n+                    checkEmptyAnnotations(wcType = typeUtils.getWildcardType(returnType, null));\n+                    checkEqualTypeAndAnnotations(returnType, wcType.getExtendsBound());\n+\n+                    checkEmptyAnnotations(wcType = typeUtils.getWildcardType(null,       returnType));\n+                    checkEqualTypeAndAnnotations(returnType, wcType.getSuperBound());\n+\n+                    \/*\n+                     * For getDeclaredType()\n+                     * \"Annotations on the type arguments are preserved.\"\n+                     *\/\n+                    DeclaredType declaredType = typeUtils.getDeclaredType(juSetElt, returnType);\n+                    checkEqualTypeAndAnnotations(returnType, declaredType.getTypeArguments().get(0));\n+\n+                    \/\/ Check both overloads\n+                    declaredType = typeUtils.getDeclaredType(typeUtils.getDeclaredType(testElt), \/\/ outer type\n+                                                             boxElt,\n+                                                             returnType);\n+                    checkEqualTypeAndAnnotations(returnType, declaredType.getTypeArguments().get(0));\n+                }\n+\n+                System.out.println(returnType.getAnnotation(TestTypeAnnotation.class));\n+                System.out.println(returnType.getAnnotationsByType(TestTypeAnnotation.class).length);\n+                TestTypeAnnotation ta = requireNonNull(returnType.getAnnotation(TestTypeAnnotation.class),\n+                                                       returnType.toString());\n+\n+                System.err.println();\n+                System.err.println();\n+            }\n+\n+            if (failures > 0)\n+                throw new RuntimeException(failures + \" failures occured.\");\n+        }\n+        return true;\n+    }\n+\n+    void testVacuous(TypeMirror tm ) {\n+        try {\n+            var result = vacuousTypes.stripAnnotations(tm);\n+            messager.printError(\"Unexpected non-exceptional result returned \" +  result);\n+        } catch(UnsupportedOperationException uoe) {\n+            ; \/\/ Expected\n+        }\n+    }\n+\n+    private int failures = 0;\n+\n+    void checkExpectedTypeAnnotations(AnnotatedConstruct ac, TypeMirror expectedAnnotation) {\n+        List<? extends AnnotationMirror> annotations = ac.getAnnotationMirrors();\n+        if (annotations.size() != 1) {\n+            failures++;\n+            System.err.println(\"\\t\\t\\tUnexpected annotations size: \" + annotations.size());\n+        } else if (!typeUtils.isSameType(annotations.get(0).getAnnotationType(), expectedAnnotation)) {\n+            failures++;\n+            System.err.println(\"\\t\\t\\tUnexpected annotations type: \" + annotations);\n+        }\n+    }\n+\n+    void checkEmptyAnnotations(AnnotatedConstruct ac) {\n+        System.err.println(\"\\t\" + ac);\n+        if (ac == null)\n+            return;\n+        else {\n+            List<? extends AnnotationMirror> annotations = ac.getAnnotationMirrors();\n+            int count = annotations.size();\n+            if (count != 0) {\n+                failures++;\n+                System.err.println(ac.getClass());\n+                System.err.println(\"\\t\\t\\tUnexpected nonzero annotations size: \" + annotations);\n+            }\n+        }\n+    }\n+\n+    void checkDeepEmptyAnnotations(TypeMirror ac) {\n+        System.err.println(\"\\t\" + ac);\n+        if (ac == null) {\n+            return;\n+        }\n+        new SimpleTypeVisitor14<Void, Void>() {\n+            @Override\n+            protected Void defaultAction(TypeMirror t, Void o) {\n+                checkEmptyAnnotations(t);\n+                return null;\n+            }\n+\n+            @Override\n+            public Void visitArray(ArrayType t, Void o) {\n+                scan(t.getComponentType());\n+                return super.visitArray(t, o);\n+            }\n+\n+            @Override\n+            public Void visitDeclared(DeclaredType t, Void o) {\n+                scan(t.getEnclosingType());\n+                t.getTypeArguments().stream().forEach(this::scan);\n+                return super.visitDeclared(t, o);\n+            }\n+\n+            @Override\n+            public Void visitTypeVariable(TypeVariable t, Void o) {\n+                \/\/ the bounds correspond to the type variable declaration, not its use\n+                \/\/ scan(t.getUpperBound());\n+                \/\/ scan(t.getLowerBound());\n+                return super.visitTypeVariable(t, o);\n+            }\n+\n+            @Override\n+            public Void visitWildcard(WildcardType t, Void o) {\n+                scan(t.getExtendsBound());\n+                scan(t.getSuperBound());\n+                return super.visitWildcard(t, o);\n+            }\n+\n+            private void scan(TypeMirror t) {\n+                if (t != null) {\n+                    visit(t);\n+                }\n+            }\n+        }.visit(ac);\n+    }\n+\n+    void checkEqualTypeAndAnnotations(TypeMirror tm1, TypeMirror tm2) {\n+        if (!typeUtils.isSameType(tm1, tm2)) {\n+            failures++;\n+            System.err.printf(\"Unequal types %s and %s.%n\", tm1, tm2);\n+        }\n+\n+        if (!Objects.equals(tm1.getAnnotationMirrors(), tm1.getAnnotationMirrors())) {\n+            failures++;\n+            System.err.printf(\"Unequal annotations on and %s.%n\", tm1, tm2);\n+        }\n+    }\n+\n+    \/\/ Nested class to test getDeclaredType overload.\n+    class Box<T> {\n+        private T contents;\n+\n+        public Box(T t){\n+            contents = t;\n+        }\n+\n+        T value() { return contents;};\n+    }\n+}\n+\n+\/*\n+ * Class to host annotations for testing\n+ *\/\n+class HostClass {\n+    \/\/ Declared type Integer\n+    public static @TestTypeAnnotation(\"foo\") Integer foo() {return null;}\n+\n+    \/\/ Primitive type int\n+    public static @TestTypeAnnotation(\"foo2\") int foo2() {return 0;}\n+\n+    public static @TestTypeAnnotation(\"foo3\") String foo3() {return null;}\n+\n+    \/\/ Declared raw type Set\n+    public static  java.util.@TestTypeAnnotation(\"foo4\")Set foo4() {return null;}\n+\n+    \/\/ Array type\n+    public static  String @TestTypeAnnotation(\"foo5\")[]  foo5() {return null;}\n+\n+    \/\/ Declared type Set with instantiated type parameter\n+    public static  java.util. @TestTypeAnnotation(\"foo6\") Set < @TestTypeAnnotation(\"foo7\") String> foo6() {return null;}\n+\n+    \/\/ Type variable\n+    public static <@TestTypeAnnotation(\"foo8\") T extends @TestTypeAnnotation(\"foo9\") String> @TestTypeAnnotation(\"foo10\") T foo7() {return null;}\n+\n+    \/\/ Declared type including wildcard\n+    public static  java.util. @TestTypeAnnotation(\"foo11\") Set < @TestTypeAnnotation(\"foo12\") ? extends @TestTypeAnnotation(\"foo13\") Number> foo8() {return null;}\n+\n+    \/\/ Type variable with intersection type\n+    public static <@TestTypeAnnotation(\"foo14\") S extends Number &  Runnable> @TestTypeAnnotation(\"foo15\") S foo9() {return null;}\n+\n+}\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE_USE)\n+@interface TestTypeAnnotation {\n+    String value() default \"\";\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/types\/TestAnnotationStripping.java","additions":305,"deletions":0,"binary":false,"changes":305,"status":"added"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8206986\n- * @summary Verify switch over boolean\/long\/float\/double is not allowed.\n- * @compile\/fail\/ref=SwitchNoExtraTypes.out -XDrawDiagnostics SwitchNoExtraTypes.java\n- *\/\n-\n-public class SwitchNoExtraTypes {\n-\n-    private void switchBoolean(boolean b) {\n-        switch (b) {\n-            case true: return ;\n-        }\n-    }\n-\n-    private void switchLong(long l) {\n-        switch (l) {\n-            case 0: return ;\n-        }\n-    }\n-\n-    private void switchFloat(float f) {\n-        switch (f) {\n-            case 0: return ;\n-        }\n-    }\n-\n-    private void switchDouble(double d) {\n-        switch (d) {\n-            case 0: return ;\n-        }\n-    }\n-\n-}\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchNoExtraTypes.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-SwitchNoExtraTypes.java:11:16: compiler.err.selector.type.not.allowed: boolean\n-SwitchNoExtraTypes.java:17:16: compiler.err.selector.type.not.allowed: long\n-SwitchNoExtraTypes.java:23:16: compiler.err.selector.type.not.allowed: float\n-SwitchNoExtraTypes.java:29:16: compiler.err.selector.type.not.allowed: double\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchNoExtraTypes.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.preview.patterns;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * Tests Exactness methods\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations=5, time=1)\n+@Measurement(iterations=5, time=1)\n+@Threads(2)\n+@Fork(value = 1,\n+      jvmArgsPrepend = {\"-Djmh.blackhole.mode=COMPILER\",\n+                        \"--enable-preview\"})\n+@State(Scope.Thread)\n+@SuppressWarnings(\"preview\")\n+public class Exactness {\n+\n+    private static boolean int_float_based_on_leading_trailing(int n) {\n+        if (n == Integer.MIN_VALUE)\n+            return true;\n+        n = Math.abs(n);\n+        return Float.PRECISION >= \/\/ 24\n+                (32 - (Integer.numberOfLeadingZeros(n) +\n+                        Integer.numberOfTrailingZeros(n))) ;\n+    }\n+    @Benchmark\n+    public void test_int_float_based_on_leading_trailing(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(int_float_based_on_leading_trailing(n));\n+        }\n+    }\n+\n+    private static boolean int_float_based_on_filtering(int n) {\n+        return n == (int)(float)n && n != Integer.MAX_VALUE;\n+    }\n+    @Benchmark\n+    public void test_int_float_based_on_filtering(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(int_float_based_on_filtering(n));\n+        }\n+    }\n+\n+    private static boolean long_float_based_on_leading_trailing(long n) {\n+        if (n == Long.MIN_VALUE)\n+            return true;\n+        n = Math.abs(n);\n+        return Float.PRECISION >= \/\/ 24\n+                (64 - (Long.numberOfLeadingZeros(n) +\n+                        Long.numberOfTrailingZeros(n))) ;\n+    }\n+    @Benchmark\n+    public void test_long_float_based_on_leading_trailing(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_float_based_on_leading_trailing(n));\n+        }\n+    }\n+\n+    private static boolean long_float_based_on_filtering(long n) {\n+        return n == (long)(float)n && n != Long.MAX_VALUE;\n+    }\n+    @Benchmark\n+    public void test_long_float_based_on_filtering(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_float_based_on_filtering(n));\n+        }\n+    }\n+\n+    private static boolean long_double_based_on_leading_trailing(long n) {\n+        if (n == Long.MIN_VALUE)\n+            return true;\n+        n = Math.abs(n);\n+        return Double.PRECISION >= \/\/ 53\n+                (64 - (Long.numberOfLeadingZeros(n) +\n+                        Long.numberOfTrailingZeros(n))) ;\n+    }\n+    @Benchmark\n+    public void test_long_double_based_on_leading_trailing(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_double_based_on_leading_trailing(n));\n+        }\n+    }\n+\n+    private static boolean long_double_based_on_filtering(long n) {\n+        return n == (long)(double)n && n != Long.MAX_VALUE;\n+    }\n+    @Benchmark\n+    public void test_long_double_based_on_filtering(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_double_based_on_filtering(n));\n+        }\n+    }\n+\n+    private static boolean float_int_based_on_compare(float n) {\n+        return Double.compare((double)n, (double)((int)n)) == 0;\n+    }\n+    @Benchmark\n+    public void test_float_int_based_on_compare(Blackhole bh) {\n+        float n = -Float.MAX_VALUE;\n+        while (n <= Float.MAX_VALUE) {\n+            bh.consume(float_int_based_on_compare(n));\n+            n = Math.nextUp(n);\n+        }\n+    }\n+\n+    private static boolean isNegativeZero(float n) {\n+        return Float.floatToRawIntBits(n) == Integer.MIN_VALUE;\n+    }\n+    private static boolean float_int_based_on_filtering(float n) {\n+        return n == (float)(int)n && n != 0x1p31f && !isNegativeZero(n);\n+    }\n+    @Benchmark\n+    public void test_float_int_based_on_filtering(Blackhole bh) {\n+        float n = -Float.MAX_VALUE;\n+        while (n <= Float.MAX_VALUE) {\n+            bh.consume(float_int_based_on_filtering(n));\n+            n = Math.nextUp(n);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/preview\/patterns\/Exactness.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/* test allocation speed of object with final field *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 5, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+public class FinalFieldInitialize {\n+  final static int LEN = 100_000;\n+  Object arr[] = null;\n+  @Setup\n+  public void setup(){\n+    arr = new Object[LEN];\n+  }\n+\n+  @Benchmark\n+  public void testAlloc(Blackhole bh) {\n+    for (int i=0; i<LEN; i++) {\n+      arr[i] = new TObj();\n+    }\n+    bh.consume(arr);\n+  }\n+\n+  @Benchmark\n+  public void testAllocWithFinal(Blackhole bh) {\n+    for (int i=0; i<LEN; i++) {\n+      arr[i] = new TObjWithFinal();\n+    }\n+    bh.consume(arr);\n+  }\n+}\n+\n+class TObj {\n+  private int i;\n+  private long l;\n+  private boolean b;\n+\n+  public TObj() {\n+    i = 10;\n+    l = 100L;\n+    b = true;\n+  }\n+}\n+\n+class TObjWithFinal {\n+  private int i;\n+  private long l;\n+  private final boolean b;\n+\n+  public TObjWithFinal() {\n+    i = 10;\n+    l = 100L;\n+    b = true;\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/FinalFieldInitialize.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}