{"files":[{"patch":"@@ -252,2 +252,1 @@\n-  if (!ClassUnloading) return false;\n-  return true;\n+  return ClassUnloading;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -157,0 +157,3 @@\n+\n+  \/\/ This indicates whether or not the current cycle should unload classes.\n+  \/\/ It does NOT indicate that a cycle should be started.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -553,1 +553,2 @@\n-  if (!_old_generation->can_start_gc()) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  if (!_old_generation->can_start_gc() || heap->collection_set()->has_old_regions()) {\n@@ -557,1 +558,0 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -126,0 +126,11 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n+\n+  \/\/ Checks that an old cycle has run for at least ShenandoahMinimumOldMarkTimeMs before allowing a young cycle.\n+  if (ShenandoahMinimumOldMarkTimeMs > 0 && ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress()) {\n+    size_t old_mark_elapsed = size_t(old_heuristics->elapsed_cycle_time() * 1000);\n+    if (old_mark_elapsed < ShenandoahMinimumOldMarkTimeMs) {\n+      return false;\n+    }\n+  }\n+\n@@ -136,2 +147,0 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n@@ -150,1 +159,0 @@\n-  ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-      regulate_concurrent_cycles();\n+      regulate_young_and_old_cycles();\n@@ -58,1 +58,1 @@\n-      regulate_interleaved_cycles();\n+      regulate_young_and_global_cycles();\n@@ -61,1 +61,1 @@\n-    regulate_heap();\n+    regulate_global_cycles();\n@@ -67,1 +67,1 @@\n-void ShenandoahRegulatorThread::regulate_concurrent_cycles() {\n+void ShenandoahRegulatorThread::regulate_young_and_old_cycles() {\n@@ -74,1 +74,1 @@\n-      if (should_unload_classes()) {\n+      if (should_start_metaspace_gc()) {\n@@ -80,0 +80,2 @@\n+          \/\/ Give the old generation a chance to run. The old generation cycle\n+          \/\/ begins with a 'bootstrap' cycle that will also collect young.\n@@ -97,1 +99,2 @@\n-void ShenandoahRegulatorThread::regulate_interleaved_cycles() {\n+\n+void ShenandoahRegulatorThread::regulate_young_and_global_cycles() {\n@@ -114,1 +117,1 @@\n-void ShenandoahRegulatorThread::regulate_heap() {\n+void ShenandoahRegulatorThread::regulate_global_cycles() {\n@@ -152,5 +155,9 @@\n-  \/\/ TODO: These first two checks might be vestigial\n-  return !ShenandoahHeap::heap()->doing_mixed_evacuations()\n-      && !ShenandoahHeap::heap()->collection_set()->has_old_regions()\n-      && _old_heuristics->should_start_gc()\n-      && request_concurrent_gc(OLD);\n+  return _old_heuristics->should_start_gc() && request_concurrent_gc(OLD);\n+}\n+\n+bool ShenandoahRegulatorThread::start_young_cycle() {\n+  return _young_heuristics->should_start_gc() && request_concurrent_gc(YOUNG);\n+}\n+\n+bool ShenandoahRegulatorThread::start_global_cycle() {\n+  return _global_heuristics->should_start_gc() && request_concurrent_gc(ShenandoahControlThread::select_global_generation());\n@@ -171,8 +178,0 @@\n-bool ShenandoahRegulatorThread::start_young_cycle() {\n-  return _young_heuristics->should_start_gc() && request_concurrent_gc(YOUNG);\n-}\n-\n-bool ShenandoahRegulatorThread::start_global_cycle() {\n-  return _global_heuristics->should_start_gc() && request_concurrent_gc(ShenandoahControlThread::select_global_generation());\n-}\n-\n@@ -183,4 +182,8 @@\n-bool ShenandoahRegulatorThread::should_unload_classes() {\n-  \/\/ The heuristics delegate this decision to the collector policy, which is based on the number\n-  \/\/ of cycles started.\n-  return _global_heuristics->should_unload_classes();\n+bool ShenandoahRegulatorThread::should_start_metaspace_gc() {\n+  \/\/ The generational mode can, at present, only unload classes during a global\n+  \/\/ cycle. For this reason, we treat an oom in metaspace as a _trigger_ for a\n+  \/\/ global cycle. But, we check other prerequisites before starting a gc that won't\n+  \/\/ unload anything.\n+  return ClassUnloadingWithConcurrentMark\n+      && _global_heuristics->can_unload_classes()\n+      && _global_heuristics->has_metaspace_oom();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * to allow young generation collections to interrupt and old generation\n+ * to allow young generation collections to interrupt an old generation\n@@ -68,4 +68,8 @@\n-  void regulate_interleaved_cycles();\n-  void regulate_concurrent_cycles();\n-  void regulate_heap();\n-\n+  \/\/ When mode is generational\n+  void regulate_young_and_old_cycles();\n+  \/\/ When mode is generational, but ShenandoahAllowOldMarkingPreemption is false\n+  void regulate_young_and_global_cycles();\n+  \/\/ Default behavior for other modes (single generation).\n+  void regulate_global_cycles();\n+\n+  \/\/ These return true if a cycle was started.\n@@ -76,1 +80,9 @@\n-  bool should_unload_classes();\n+  \/\/ The generational mode can only unload classes in a global cycle. The regulator\n+  \/\/ thread itself will trigger a global cycle if metaspace is out of memory.\n+  bool should_start_metaspace_gc();\n+\n+  \/\/ Regulator will sleep longer when the allocation rate is lower.\n+  void regulator_sleep();\n+\n+  \/\/ Provides instrumentation to track how long it takes to acknowledge a request.\n+  bool request_concurrent_gc(ShenandoahGenerationType generation);\n@@ -86,4 +98,0 @@\n-\n-  void regulator_sleep();\n-\n-  bool request_concurrent_gc(ShenandoahGenerationType generation);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.hpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -599,0 +599,7 @@\n+                                                                            \\\n+  product(uintx, ShenandoahMinimumOldMarkTimeMs, 100, EXPERIMENTAL,         \\\n+         \"Minimum amount of time in milliseconds to run old marking \"       \\\n+         \"before a young collection is allowed to run. This is intended \"   \\\n+         \"to prevent starvation of the old collector. Setting this to \"     \\\n+         \"0 will allow back to back young collections to run during old \"   \\\n+         \"marking.\")                                                        \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}