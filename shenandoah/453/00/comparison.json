{"files":[{"patch":"@@ -383,0 +383,10 @@\n+  \/\/ For normal requested GCs (System.gc) we want to block the caller. However,\n+  \/\/ for whitebox requested GC, we want to initiate the GC and return immediately.\n+  \/\/ The whitebox caller thread will arrange for itself to wait until the GC notifies\n+  \/\/ it that has reached the requested breakpoint (phase in the GC).\n+  if (cause == GCCause::_wb_breakpoint) {\n+    _requested_gc_cause = cause;\n+    _gc_requested.set();\n+    return;\n+  }\n+\n@@ -402,3 +412,1 @@\n-    if (cause != GCCause::_wb_breakpoint) {\n-      ml.wait();\n-    }\n+    ml.wait();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -788,0 +788,10 @@\n+  \/\/ For normal requested GCs (System.gc) we want to block the caller. However,\n+  \/\/ for whitebox requested GC, we want to initiate the GC and return immediately.\n+  \/\/ The whitebox caller thread will arrange for itself to wait until the GC notifies\n+  \/\/ it that has reached the requested breakpoint (phase in the GC).\n+  if (cause == GCCause::_wb_breakpoint) {\n+    Atomic::xchg(&_requested_gc_cause, cause);\n+    notify_control_thread();\n+    return;\n+  }\n+\n@@ -810,3 +820,1 @@\n-    if (cause != GCCause::_wb_breakpoint) {\n-      ml.wait();\n-    }\n+    ml.wait();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"}]}