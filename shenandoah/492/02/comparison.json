{"files":[{"patch":"@@ -435,2 +435,2 @@\n-    \/\/ The heuristic old_is_fragmented trigger may be seeking to achieve up to 7\/8 density.  Allow ourselves to overshoot\n-    \/\/ that target (at 15\/16) so we will not have to do another defragmenting old collection right away.\n+    \/\/ The heuristic old_is_fragmented trigger may be seeking to achieve up to 75% density.  Allow ourselves to overshoot\n+    \/\/ that target (at 7\/8) so we will not have to do another defragmenting old collection right away.\n@@ -438,1 +438,1 @@\n-           (total_uncollected_old_regions < 15 * span_of_uncollected_regions \/ 16)) {\n+           (total_uncollected_old_regions < 7 * span_of_uncollected_regions \/ 8)) {\n@@ -549,1 +549,6 @@\n-void ShenandoahOldHeuristics::trigger_collection_if_fragmented(size_t first_old_region, size_t last_old_region, size_t old_region_count, size_t num_regions) {\n+\/\/ This triggers old-gen collection if the number of regions \"dedicated\" to old generation is much larger than\n+\/\/ is required to represent the memory currently used within the old generation.  This trigger looks specifically\n+\/\/ at density of the old-gen spanned region.  A different mechanism triggers old-gen GC if the total number of\n+\/\/ old-gen regions (regardless of how close the regions are to one another) grows beyond an anticipated growth target.\n+void ShenandoahOldHeuristics::trigger_collection_if_fragmented(size_t first_old_region, size_t last_old_region,\n+                                                               size_t old_region_count, size_t num_regions) {\n@@ -551,1 +556,7 @@\n-    size_t old_region_span = (first_old_region <= last_old_region)? (last_old_region + 1 - first_old_region): 0;\n+    \/\/ Our intent is to pack old-gen memory into the highest-numbered regions of the heap.  Count all memory\n+    \/\/ above first_old_region as the \"span\" of old generation.\n+    size_t old_region_span = (first_old_region <= last_old_region)? (num_regions - first_old_region): 0;\n+    \/\/ Given that memory at the bottom of the heap is reserved to represent humongous objects, the number of\n+    \/\/ regions that old_gen is \"allowed\" to consume is less than the total heap size.  The restriction on allowed\n+    \/\/ span is not strictly enforced.  This is a heuristic designed to reduce the likelihood that a humongous\n+    \/\/ allocation request will require a STW full GC.\n@@ -554,13 +565,3 @@\n-    \/\/ Tolerate lower density if total span is small.  Here's the implementation:\n-    \/\/   if old_gen spans more than 100% and density < 75%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 87.5% and density < 62.5%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 75% and density < 50%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 62.5% and density < 37.5%, trigger old-defrag\n-    \/\/   else if old_gen spans more than 50% and density < 25%, trigger old-defrag\n-    \/\/\n-    \/\/ A previous implementation was more aggressive in triggering, resulting in degraded throughput when\n-    \/\/ humongous allocation was not required.\n-\n-    size_t old_available = _old_gen->available();\n-    size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-    size_t old_unaffiliated_available = _old_gen->free_unaffiliated_regions() * region_size_bytes;\n+    size_t old_available = _old_gen->available() \/ HeapWordSize;\n+    size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n+    size_t old_unaffiliated_available = _old_gen->free_unaffiliated_regions() * region_size_words;\n@@ -570,13 +571,20 @@\n-    size_t old_bytes_consumed = old_region_count * region_size_bytes - old_fragmented_available;\n-    size_t old_bytes_spanned = old_region_span * region_size_bytes;\n-    double old_density = ((double) old_bytes_consumed) \/ old_bytes_spanned;\n-\n-    uint eighths = 8;\n-    for (uint i = 0; i < 5; i++) {\n-      size_t span_threshold = eighths * allowed_old_gen_span \/ 8;\n-      double density_threshold = (eighths - 2) \/ 8.0;\n-      if ((old_region_span >= span_threshold) && (old_density < density_threshold)) {\n-        trigger_old_is_fragmented(old_density, first_old_region, last_old_region);\n-        return;\n-      }\n-      eighths--;\n+    size_t old_words_consumed = old_region_count * region_size_words - old_fragmented_available;\n+    size_t old_words_spanned = old_region_span * region_size_words;\n+    double old_density = ((double) old_words_consumed) \/ old_words_spanned;\n+\n+    double old_span_percent = ((double) old_region_span) \/ allowed_old_gen_span;\n+    double old_span_percent_squared = old_span_percent * old_span_percent;\n+\n+    \/\/ Squaring old_span_percent in the denominator below allows more aggressive triggering when we are\n+    \/\/ above desired maximum span and less aggressive triggering when we are far below the desired\n+    \/\/ maximum span.\n+    if ((old_span_percent >= 0.50) && (old_density \/ old_span_percent_squared < 0.75)) {\n+      \/\/ We trigger old defragmentation, for example, if:\n+      \/\/  old_span_percent is 110% and old_density is below 90.8%, or\n+      \/\/  old_span_percent is 100% and old_density is below 75.0%, or\n+      \/\/  old_span_percent is  90% and old_density is below 60.8%, or\n+      \/\/  old_span_percent is  80% and old_density is below 48.0%, or\n+      \/\/  old_span_percent is  70% and old_density is below 36.8%, or\n+      \/\/  old_span_percent is  60% and old_density is below 27.0%, or\n+      \/\/  old_span_percent is  50% and old_density is below 18.8%.\n+      trigger_old_is_fragmented(old_density, first_old_region, last_old_region);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":39,"deletions":31,"binary":false,"changes":70,"status":"modified"}]}