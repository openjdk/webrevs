{"files":[{"patch":"@@ -133,7 +133,8 @@\n-    PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n-    \/\/ CAUTION: retire_plab may register the remnant filler object with the remembered set scanner without a lock.\n-    \/\/ This is safe iff it is assured that each PLAB is a whole-number multiple of card-mark memory size and each\n-    \/\/ PLAB is aligned with the start of each card's memory range.\n-    \/\/ TODO: Assert this in retire_plab?\n-    if (plab != nullptr) {\n-      ShenandoahGenerationalHeap::heap()->retire_plab(plab);\n+    if (ShenandoahCardBarrier) {\n+      PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+      \/\/ retire_plab may register the remnant filler object with the remembered set scanner without a lock.\n+      \/\/ This is safe because it is assured that each PLAB is a whole-number multiple of card-mark memory size and each\n+      \/\/ PLAB is aligned with the start of each card's memory range.\n+      if (plab != nullptr) {\n+        ShenandoahGenerationalHeap::heap()->retire_plab(plab);\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1213,1 +1213,3 @@\n-    ShenandoahGenerationalHeap::heap()->update_region_ages();\n+    if (!_generation->is_old()) {\n+      ShenandoahGenerationalHeap::heap()->update_region_ages(_generation->complete_marking_context());\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -355,1 +355,1 @@\n-  if (!heap->collection_set()->is_empty() || heap->old_generation()->has_in_place_promotions()) {\n+  if (!heap->collection_set()->is_empty() || has_in_place_promotions(heap)) {\n@@ -381,0 +381,4 @@\n+bool ShenandoahDegenGC::has_in_place_promotions(const ShenandoahHeap* heap) const {\n+  return heap->mode()->is_generational() && heap->old_generation()->has_in_place_promotions();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+\n+  bool has_in_place_promotions(const ShenandoahHeap* heap) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -513,1 +513,0 @@\n-\n@@ -732,3 +731,0 @@\n-      _heap->old_generation()->increment_affiliated_region_count();\n-    } else {\n-      _heap->young_generation()->increment_affiliated_region_count();\n@@ -736,0 +732,1 @@\n+    _heap->generation_for(r->affiliation())->increment_affiliated_region_count();\n@@ -931,1 +928,1 @@\n-  _heap->young_generation()->increase_affiliated_region_count(num);\n+  generation->increase_affiliated_region_count(num);\n@@ -1000,0 +997,1 @@\n+  ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::cast(_heap);\n@@ -1004,1 +1002,1 @@\n-  bool transferred = _heap->generation_sizer()->transfer_to_old(1);\n+  bool transferred = gen_heap->generation_sizer()->transfer_to_old(1);\n@@ -1007,1 +1005,1 @@\n-    _heap->generation_sizer()->force_transfer_to_old(1);\n+    gen_heap->generation_sizer()->force_transfer_to_old(1);\n@@ -1125,1 +1123,1 @@\n-      _heap->generation_sizer()->transfer_to_young(old_collector_regions);\n+      ShenandoahGenerationalHeap::cast(_heap)->generation_sizer()->transfer_to_young(old_collector_regions);\n@@ -1186,0 +1184,1 @@\n+  shenandoah_assert_generational();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -244,0 +244,1 @@\n+  shenandoah_assert_generational();\n@@ -357,0 +358,1 @@\n+  shenandoah_assert_generational();\n@@ -456,1 +458,1 @@\n-    bool result = heap->generation_sizer()->transfer_to_young(regions_to_xfer);\n+    bool result = ShenandoahGenerationalHeap::cast(heap)->generation_sizer()->transfer_to_young(regions_to_xfer);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationSizer.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n+#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+\n+\n+ShenandoahGenerationSizer::ShenandoahGenerationSizer()\n+        : _sizer_kind(SizerDefaults),\n+          _min_desired_young_regions(0),\n+          _max_desired_young_regions(0) {\n+\n+  if (FLAG_IS_CMDLINE(NewRatio)) {\n+    if (FLAG_IS_CMDLINE(NewSize) || FLAG_IS_CMDLINE(MaxNewSize)) {\n+      log_warning(gc, ergo)(\"-XX:NewSize and -XX:MaxNewSize override -XX:NewRatio\");\n+    } else {\n+      _sizer_kind = SizerNewRatio;\n+      return;\n+    }\n+  }\n+\n+  if (NewSize > MaxNewSize) {\n+    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+      log_warning(gc, ergo)(\"NewSize (\" SIZE_FORMAT \"k) is greater than the MaxNewSize (\" SIZE_FORMAT \"k). \"\n+                            \"A new max generation size of \" SIZE_FORMAT \"k will be used.\",\n+              NewSize\/K, MaxNewSize\/K, NewSize\/K);\n+    }\n+    FLAG_SET_ERGO(MaxNewSize, NewSize);\n+  }\n+\n+  if (FLAG_IS_CMDLINE(NewSize)) {\n+    _min_desired_young_regions = MAX2(uint(NewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n+    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+      _max_desired_young_regions = MAX2(uint(MaxNewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n+      _sizer_kind = SizerMaxAndNewSize;\n+    } else {\n+      _sizer_kind = SizerNewSizeOnly;\n+    }\n+  } else if (FLAG_IS_CMDLINE(MaxNewSize)) {\n+    _max_desired_young_regions = MAX2(uint(MaxNewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n+    _sizer_kind = SizerMaxNewSizeOnly;\n+  }\n+}\n+\n+size_t ShenandoahGenerationSizer::calculate_min_young_regions(size_t heap_region_count) {\n+  size_t min_young_regions = (heap_region_count * ShenandoahMinYoungPercentage) \/ 100;\n+  return MAX2(min_young_regions, (size_t) 1U);\n+}\n+\n+size_t ShenandoahGenerationSizer::calculate_max_young_regions(size_t heap_region_count) {\n+  size_t max_young_regions = (heap_region_count * ShenandoahMaxYoungPercentage) \/ 100;\n+  return MAX2(max_young_regions, (size_t) 1U);\n+}\n+\n+void ShenandoahGenerationSizer::recalculate_min_max_young_length(size_t heap_region_count) {\n+  assert(heap_region_count > 0, \"Heap must be initialized\");\n+\n+  switch (_sizer_kind) {\n+    case SizerDefaults:\n+      _min_desired_young_regions = calculate_min_young_regions(heap_region_count);\n+      _max_desired_young_regions = calculate_max_young_regions(heap_region_count);\n+      break;\n+    case SizerNewSizeOnly:\n+      _max_desired_young_regions = calculate_max_young_regions(heap_region_count);\n+      _max_desired_young_regions = MAX2(_min_desired_young_regions, _max_desired_young_regions);\n+      break;\n+    case SizerMaxNewSizeOnly:\n+      _min_desired_young_regions = calculate_min_young_regions(heap_region_count);\n+      _min_desired_young_regions = MIN2(_min_desired_young_regions, _max_desired_young_regions);\n+      break;\n+    case SizerMaxAndNewSize:\n+      \/\/ Do nothing. Values set on the command line, don't update them at runtime.\n+      break;\n+    case SizerNewRatio:\n+      _min_desired_young_regions = MAX2(uint(heap_region_count \/ (NewRatio + 1)), 1U);\n+      _max_desired_young_regions = _min_desired_young_regions;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  assert(_min_desired_young_regions <= _max_desired_young_regions, \"Invalid min\/max young gen size values\");\n+}\n+\n+void ShenandoahGenerationSizer::heap_size_changed(size_t heap_size) {\n+  recalculate_min_max_young_length(heap_size \/ ShenandoahHeapRegion::region_size_bytes());\n+}\n+\n+bool ShenandoahGenerationSizer::transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions) const {\n+  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n+\n+  if (src->free_unaffiliated_regions() < regions) {\n+    \/\/ Source does not have enough free regions for this transfer. The caller should have\n+    \/\/ already capped the transfer based on available unaffiliated regions.\n+    return false;\n+  }\n+\n+  if (dst->max_capacity() + bytes_to_transfer > max_size_for(dst)) {\n+    \/\/ This transfer would cause the destination generation to grow above its configured maximum size.\n+    return false;\n+  }\n+\n+  if (src->max_capacity() - bytes_to_transfer < min_size_for(src)) {\n+    \/\/ This transfer would cause the source generation to shrink below its configured minimum size.\n+    return false;\n+  }\n+\n+  src->decrease_capacity(bytes_to_transfer);\n+  dst->increase_capacity(bytes_to_transfer);\n+  const size_t new_size = dst->max_capacity();\n+  log_info(gc)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+          regions, src->name(), dst->name(), PROPERFMTARGS(new_size));\n+  return true;\n+}\n+\n+\n+size_t ShenandoahGenerationSizer::max_size_for(ShenandoahGeneration* generation) const {\n+  switch (generation->type()) {\n+    case YOUNG:\n+      return max_young_size();\n+    case OLD:\n+      \/\/ On the command line, max size of OLD is specified indirectly, by setting a minimum size of young.\n+      \/\/ OLD is what remains within the heap after YOUNG has been sized.\n+      return ShenandoahHeap::heap()->max_capacity() - min_young_size();\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n+size_t ShenandoahGenerationSizer::min_size_for(ShenandoahGeneration* generation) const {\n+  switch (generation->type()) {\n+    case YOUNG:\n+      return min_young_size();\n+    case OLD:\n+      \/\/ On the command line, min size of OLD is specified indirectly, by setting a maximum size of young.\n+      \/\/ OLD is what remains within the heap after YOUNG has been sized.\n+      return ShenandoahHeap::heap()->max_capacity() - max_young_size();\n+    default:\n+      ShouldNotReachHere();\n+      return 0;\n+  }\n+}\n+\n+\n+\/\/ Returns true iff transfer is successful\n+bool ShenandoahGenerationSizer::transfer_to_old(size_t regions) const {\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  return transfer_regions(heap->young_generation(), heap->old_generation(), regions);\n+}\n+\n+\/\/ This is used when promoting humongous or highly utilized regular regions in place.  It is not required in this situation\n+\/\/ that the transferred regions be unaffiliated.\n+void ShenandoahGenerationSizer::force_transfer_to_old(size_t regions) const {\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  ShenandoahGeneration* old_gen = heap->old_generation();\n+  ShenandoahGeneration* young_gen = heap->young_generation();\n+  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n+\n+  young_gen->decrease_capacity(bytes_to_transfer);\n+  old_gen->increase_capacity(bytes_to_transfer);\n+  const size_t new_size = old_gen->max_capacity();\n+  log_info(gc)(\"Forcing transfer of \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n+          regions, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_size));\n+}\n+\n+\n+bool ShenandoahGenerationSizer::transfer_to_young(size_t regions) const {\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+  return transfer_regions(heap->old_generation(), heap->young_generation(), regions);\n+}\n+\n+size_t ShenandoahGenerationSizer::min_young_size() const {\n+  return min_young_regions() * ShenandoahHeapRegion::region_size_bytes();\n+}\n+\n+size_t ShenandoahGenerationSizer::max_young_size() const {\n+  return max_young_regions() * ShenandoahHeapRegion::region_size_bytes();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationSizer.cpp","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONSIZER_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONSIZER_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class ShenandoahGeneration;\n+class ShenandoahGenerationalHeap;\n+\n+class ShenandoahGenerationSizer {\n+private:\n+  enum SizerKind {\n+    SizerDefaults,\n+    SizerNewSizeOnly,\n+    SizerMaxNewSizeOnly,\n+    SizerMaxAndNewSize,\n+    SizerNewRatio\n+  };\n+  SizerKind _sizer_kind;\n+\n+  size_t _min_desired_young_regions;\n+  size_t _max_desired_young_regions;\n+\n+  static size_t calculate_min_young_regions(size_t heap_region_count);\n+  static size_t calculate_max_young_regions(size_t heap_region_count);\n+\n+  \/\/ Update the given values for minimum and maximum young gen length in regions\n+  \/\/ given the number of heap regions depending on the kind of sizing algorithm.\n+  void recalculate_min_max_young_length(size_t heap_region_count);\n+\n+  \/\/ This will attempt to transfer regions from the `src` generation to `dst` generation.\n+  \/\/ If the transfer would violate the configured minimum size for the source or the configured\n+  \/\/ maximum size of the destination, it will not perform the transfer and will return false.\n+  \/\/ Returns true if the transfer is performed.\n+  bool transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions) const;\n+\n+  \/\/ Return the configured maximum size in bytes for the given generation.\n+  size_t max_size_for(ShenandoahGeneration* generation) const;\n+\n+  \/\/ Return the configured minimum size in bytes for the given generation.\n+  size_t min_size_for(ShenandoahGeneration* generation) const;\n+\n+public:\n+  ShenandoahGenerationSizer();\n+\n+  \/\/ Calculate the maximum length of the young gen given the number of regions\n+  \/\/ depending on the sizing algorithm.\n+  void heap_size_changed(size_t heap_size);\n+\n+  \/\/ Minimum size of young generation in bytes as multiple of region size.\n+  size_t min_young_size() const;\n+  size_t min_young_regions() const {\n+    return _min_desired_young_regions;\n+  }\n+\n+  \/\/ Maximum size of young generation in bytes as multiple of region size.\n+  size_t max_young_size() const;\n+  size_t max_young_regions() const {\n+    return _max_desired_young_regions;\n+  }\n+\n+  \/\/ True if transfer succeeds, else false. See transfer_regions.\n+  bool transfer_to_young(size_t regions) const;\n+  bool transfer_to_old(size_t regions) const;\n+\n+  \/\/ force transfer is used when we promote humongous objects.  May violate min\/max limits on generation sizes\n+  void force_transfer_to_old(size_t regions) const;\n+};\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONSIZER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationSizer.hpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -67,2 +67,3 @@\n-  ShenandoahYoungGeneration* young = heap->young_generation();\n-  ShenandoahOldGeneration* old = heap->old_generation();\n+  ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::cast(heap);\n+  ShenandoahYoungGeneration* young = gen_heap->young_generation();\n+  ShenandoahOldGeneration* old = gen_heap->old_generation();\n@@ -72,2 +73,2 @@\n-  heap->mmu_tracker()->record_full(GCId::current());\n-  heap->log_heap_status(\"At end of Full GC\");\n+  gen_heap->mmu_tracker()->record_full(GCId::current());\n+  gen_heap->log_heap_status(\"At end of Full GC\");\n@@ -102,2 +103,5 @@\n-  size_t old_usage = heap->old_generation()->used_regions_size();\n-  size_t old_capacity = heap->old_generation()->max_capacity();\n+  ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::cast(heap);\n+  ShenandoahOldGeneration* const old_gen = gen_heap->old_generation();\n+\n+  size_t old_usage = old_gen->used_regions_size();\n+  size_t old_capacity = old_gen->max_capacity();\n@@ -110,1 +114,1 @@\n-    heap->generation_sizer()->transfer_to_young(excess_old_regions);\n+    gen_heap->generation_sizer()->transfer_to_young(excess_old_regions);\n@@ -113,1 +117,1 @@\n-    heap->generation_sizer()->force_transfer_to_old(old_regions_deficit);\n+    gen_heap->generation_sizer()->force_transfer_to_old(old_regions_deficit);\n@@ -117,2 +121,2 @@\n-               PROPERFMTARGS(heap->young_generation()->used()),\n-               PROPERFMTARGS(heap->old_generation()->used()));\n+               PROPERFMTARGS(gen_heap->young_generation()->used()),\n+               PROPERFMTARGS(old_gen->used()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -84,0 +84,5 @@\n+  return cast(heap);\n+}\n+\n+ShenandoahGenerationalHeap* ShenandoahGenerationalHeap::cast(CollectedHeap* heap) {\n+  shenandoah_assert_generational();\n@@ -123,0 +128,20 @@\n+void ShenandoahGenerationalHeap::initialize_heuristics() {\n+  \/\/ Initialize global generation and heuristics even in generational mode.\n+  ShenandoahHeap::initialize_heuristics();\n+\n+  \/\/ Max capacity is the maximum _allowed_ capacity. That is, the maximum allowed capacity\n+  \/\/ for old would be total heap - minimum capacity of young. This means the sum of the maximum\n+  \/\/ allowed for old and young could exceed the total heap size. It remains the case that the\n+  \/\/ _actual_ capacity of young + old = total.\n+  _generation_sizer.heap_size_changed(max_capacity());\n+  size_t initial_capacity_young = _generation_sizer.max_young_size();\n+  size_t max_capacity_young = _generation_sizer.max_young_size();\n+  size_t initial_capacity_old = max_capacity() - max_capacity_young;\n+  size_t max_capacity_old = max_capacity() - initial_capacity_young;\n+\n+  _young_generation = new ShenandoahYoungGeneration(max_workers(), max_capacity_young, initial_capacity_young);\n+  _old_generation = new ShenandoahOldGeneration(max_workers(), max_capacity_old, initial_capacity_old);\n+  _young_generation->initialize_heuristics(mode());\n+  _old_generation->initialize_heuristics(mode());\n+}\n+\n@@ -955,0 +980,69 @@\n+namespace ShenandoahCompositeRegionClosure {\n+  template<typename C1, typename C2>\n+  class Closure : public ShenandoahHeapRegionClosure {\n+  private:\n+    C1 &_c1;\n+    C2 &_c2;\n+\n+  public:\n+    Closure(C1 &c1, C2 &c2) : ShenandoahHeapRegionClosure(), _c1(c1), _c2(c2) {}\n+\n+    void heap_region_do(ShenandoahHeapRegion* r) override {\n+      _c1.heap_region_do(r);\n+      _c2.heap_region_do(r);\n+    }\n+\n+    bool is_thread_safe() override {\n+      return _c1.is_thread_safe() && _c2.is_thread_safe();\n+    }\n+  };\n+\n+\n+  template<typename C1, typename C2>\n+  Closure<C1, C2> of(C1 &c1, C2 &c2) {\n+    return Closure<C1, C2>(c1, c2);\n+  }\n+}\n+\n+class ShenandoahUpdateRegionAges : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahMarkingContext* _ctx;\n+\n+public:\n+  explicit ShenandoahUpdateRegionAges(ShenandoahMarkingContext* ctx) : _ctx(ctx) { }\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override {\n+    \/\/ Maintenance of region age must follow evacuation in order to account for\n+    \/\/ evacuation allocations within survivor regions.  We consult region age during\n+    \/\/ the subsequent evacuation to determine whether certain objects need to\n+    \/\/ be promoted.\n+    if (r->is_young() && r->is_active()) {\n+      HeapWord *tams = _ctx->top_at_mark_start(r);\n+      HeapWord *top = r->top();\n+\n+      \/\/ Allocations move the watermark when top moves.  However, compacting\n+      \/\/ objects will sometimes lower top beneath the watermark, after which,\n+      \/\/ attempts to read the watermark will assert out (watermark should not be\n+      \/\/ higher than top).\n+      if (top > tams) {\n+        \/\/ There have been allocations in this region since the start of the cycle.\n+        \/\/ Any objects new to this region must not assimilate elevated age.\n+        r->reset_age();\n+      } else if (ShenandoahGenerationalHeap::heap()->is_aging_cycle()) {\n+        r->increment_age();\n+      }\n+    }\n+  }\n+\n+  bool is_thread_safe() override {\n+    return true;\n+  }\n+};\n+\n+void ShenandoahGenerationalHeap::final_update_refs_update_region_states() {\n+  ShenandoahSynchronizePinnedRegionStates pins;\n+  ShenandoahUpdateRegionAges ages(active_generation()->complete_marking_context());\n+  auto cl = ShenandoahCompositeRegionClosure::of(pins, ages);\n+  parallel_heap_region_iterate(&cl);\n+}\n+\n@@ -1022,14 +1116,3 @@\n-void ShenandoahGenerationalHeap::update_region_ages() {\n-  ShenandoahMarkingContext *ctx = complete_marking_context();\n-  for (size_t i = 0; i < num_regions(); i++) {\n-    ShenandoahHeapRegion *r = get_region(i);\n-    if (r->is_active() && r->is_young()) {\n-      HeapWord* tams = ctx->top_at_mark_start(r);\n-      HeapWord* top = r->top();\n-      if (top > tams) {\n-        r->reset_age();\n-      } else if (is_aging_cycle()) {\n-        r->increment_age();\n-      }\n-    }\n-  }\n+void ShenandoahGenerationalHeap::update_region_ages(ShenandoahMarkingContext* ctx) {\n+  ShenandoahUpdateRegionAges cl(ctx);\n+  parallel_heap_region_iterate(&cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":97,"deletions":14,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+  void initialize_heuristics() override;\n@@ -41,0 +42,1 @@\n+  static ShenandoahGenerationalHeap* cast(CollectedHeap* heap);\n@@ -69,1 +71,1 @@\n-  void update_region_ages();\n+  void update_region_ages(ShenandoahMarkingContext* ctx);\n@@ -83,0 +85,1 @@\n+  void final_update_refs_update_region_states() override;\n@@ -116,0 +119,2 @@\n+  const ShenandoahGenerationSizer* generation_sizer()  const { return &_generation_sizer;  }\n+\n@@ -139,0 +144,2 @@\n+\n+  ShenandoahGenerationSizer     _generation_sizer;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n@@ -115,3 +115,5 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  heap->young_generation()->set_mark_complete();\n-  heap->old_generation()->set_mark_complete();\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+    heap->young_generation()->set_mark_complete();\n+    heap->old_generation()->set_mark_complete();\n+  }\n@@ -122,3 +124,5 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  heap->young_generation()->set_mark_incomplete();\n-  heap->old_generation()->set_mark_incomplete();\n+  if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+    ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n+    heap->young_generation()->set_mark_incomplete();\n+    heap->old_generation()->set_mark_incomplete();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-#include \"gc\/shenandoah\/shenandoahMetrics.hpp\"\n@@ -523,18 +522,2 @@\n-  \/\/ Max capacity is the maximum _allowed_ capacity. That is, the maximum allowed capacity\n-  \/\/ for old would be total heap - minimum capacity of young. This means the sum of the maximum\n-  \/\/ allowed for old and young could exceed the total heap size. It remains the case that the\n-  \/\/ _actual_ capacity of young + old = total.\n-  _generation_sizer.heap_size_changed(max_capacity());\n-  size_t initial_capacity_young = _generation_sizer.max_young_size();\n-  size_t max_capacity_young = _generation_sizer.max_young_size();\n-  size_t initial_capacity_old = max_capacity() - max_capacity_young;\n-  size_t max_capacity_old = max_capacity() - initial_capacity_young;\n-\n-  _young_generation = new ShenandoahYoungGeneration(_max_workers, max_capacity_young, initial_capacity_young);\n-  _old_generation = new ShenandoahOldGeneration(_max_workers, max_capacity_old, initial_capacity_old);\n-  _global_generation = new ShenandoahGlobalGeneration(_gc_mode->is_generational(), _max_workers, max_capacity(), max_capacity());\n-  _global_generation->initialize_heuristics(_gc_mode);\n-  if (mode()->is_generational()) {\n-    _young_generation->initialize_heuristics(_gc_mode);\n-    _old_generation->initialize_heuristics(_gc_mode);\n-  }\n+  _global_generation = new ShenandoahGlobalGeneration(mode()->is_generational(), max_workers(), max_capacity(), max_capacity());\n+  _global_generation->initialize_heuristics(mode());\n@@ -565,1 +548,0 @@\n-  _young_generation(nullptr),\n@@ -567,1 +549,0 @@\n-  _old_generation(nullptr),\n@@ -569,0 +550,2 @@\n+  _young_generation(nullptr),\n+  _old_generation(nullptr),\n@@ -577,1 +560,0 @@\n-  _generation_sizer(),\n@@ -2051,3 +2033,6 @@\n-  _young_generation->cancel_marking();\n-  _old_generation->cancel_marking();\n-  _global_generation->cancel_marking();\n+  if (mode()->is_generational()) {\n+    young_generation()->cancel_marking();\n+    old_generation()->cancel_marking();\n+  }\n+\n+  global_generation()->cancel_marking();\n@@ -2375,5 +2360,1 @@\n-class ShenandoahFinalUpdateRefsUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahMarkingContext* _ctx;\n-  ShenandoahHeapLock* const _lock;\n-  bool _is_generational;\n+ShenandoahSynchronizePinnedRegionStates::ShenandoahSynchronizePinnedRegionStates() : _lock(ShenandoahHeap::heap()->lock()) { }\n@@ -2381,24 +2362,8 @@\n-public:\n-  ShenandoahFinalUpdateRefsUpdateRegionStateClosure(ShenandoahMarkingContext* ctx) :\n-    _ctx(ctx), _lock(ShenandoahHeap::heap()->lock()),\n-    _is_generational(ShenandoahHeap::heap()->mode()->is_generational()) { }\n-\n-  void heap_region_do(ShenandoahHeapRegion* r) override {\n-\n-    \/\/ Maintenance of region age must follow evacuation in order to account for evacuation allocations within survivor\n-    \/\/ regions.  We consult region age during the subsequent evacuation to determine whether certain objects need to\n-    \/\/ be promoted.\n-    if (_is_generational && r->is_young() && r->is_active()) {\n-      HeapWord *tams = _ctx->top_at_mark_start(r);\n-      HeapWord *top = r->top();\n-\n-      \/\/ Allocations move the watermark when top moves.  However, compacting\n-      \/\/ objects will sometimes lower top beneath the watermark, after which,\n-      \/\/ attempts to read the watermark will assert out (watermark should not be\n-      \/\/ higher than top).\n-      if (top > tams) {\n-        \/\/ There have been allocations in this region since the start of the cycle.\n-        \/\/ Any objects new to this region must not assimilate elevated age.\n-        r->reset_age();\n-      } else if (ShenandoahGenerationalHeap::heap()->is_aging_cycle()) {\n-        r->increment_age();\n+void ShenandoahSynchronizePinnedRegionStates::heap_region_do(ShenandoahHeapRegion* r) {\n+  \/\/ Drop \"pinned\" state from regions that no longer have a pinned count. Put\n+  \/\/ regions with a pinned count into the \"pinned\" state.\n+  if (r->is_active()) {\n+    if (r->is_pinned()) {\n+      if (r->pin_count() == 0) {\n+        ShenandoahHeapLocker locker(_lock);\n+        r->make_unpinned();\n@@ -2406,15 +2371,4 @@\n-    }\n-\n-    \/\/ Drop unnecessary \"pinned\" state from regions that does not have CP marks\n-    \/\/ anymore, as this would allow trashing them.\n-    if (r->is_active()) {\n-      if (r->is_pinned()) {\n-        if (r->pin_count() == 0) {\n-          ShenandoahHeapLocker locker(_lock);\n-          r->make_unpinned();\n-        }\n-      } else {\n-        if (r->pin_count() > 0) {\n-          ShenandoahHeapLocker locker(_lock);\n-          r->make_pinned();\n-        }\n+    } else {\n+      if (r->pin_count() > 0) {\n+        ShenandoahHeapLocker locker(_lock);\n+        r->make_pinned();\n@@ -2424,3 +2378,1 @@\n-\n-  bool is_thread_safe() override { return true; }\n-};\n+}\n@@ -2436,2 +2388,2 @@\n-    ShenandoahFinalUpdateRefsUpdateRegionStateClosure cl (active_generation()->complete_marking_context());\n-    parallel_heap_region_iterate(&cl);\n+\n+    final_update_refs_update_region_states();\n@@ -2450,0 +2402,5 @@\n+void ShenandoahHeap::final_update_refs_update_region_states() {\n+  ShenandoahSynchronizePinnedRegionStates cl;\n+  parallel_heap_region_iterate(&cl);\n+}\n+\n@@ -2474,2 +2431,3 @@\n-    size_t allocation_runway = young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions);\n-    ShenandoahGenerationalHeap::heap()->compute_old_generation_balance(allocation_runway, old_cset_regions);\n+    ShenandoahGenerationalHeap* gen_heap = ShenandoahGenerationalHeap::heap();\n+    size_t allocation_runway = gen_heap->young_generation()->heuristics()->bytes_of_allocation_runway_before_gc_trigger(young_cset_regions);\n+    gen_heap->compute_old_generation_balance(allocation_runway, old_cset_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":34,"deletions":76,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationSizer.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -123,0 +125,11 @@\n+class ShenandoahSynchronizePinnedRegionStates : public ShenandoahHeapRegionClosure {\n+private:\n+  ShenandoahHeapLock* const _lock;\n+\n+public:\n+  ShenandoahSynchronizePinnedRegionStates();\n+\n+  void heap_region_do(ShenandoahHeapRegion* r) override;\n+  bool is_thread_safe() override { return true; }\n+};\n+\n@@ -176,1 +189,1 @@\n-  void initialize_heuristics();\n+  virtual void initialize_heuristics();\n@@ -447,0 +460,1 @@\n+  virtual void final_update_refs_update_region_states();\n@@ -459,3 +473,1 @@\n-  ShenandoahYoungGeneration* _young_generation;\n-  ShenandoahGeneration*      _global_generation;\n-  ShenandoahOldGeneration*   _old_generation;\n+  ShenandoahGeneration*  _global_generation;\n@@ -466,0 +478,3 @@\n+  ShenandoahYoungGeneration* _young_generation;\n+  ShenandoahOldGeneration*   _old_generation;\n+\n@@ -476,1 +491,0 @@\n-  ShenandoahGenerationSizer     _generation_sizer;\n@@ -481,1 +495,0 @@\n-  ShenandoahYoungGeneration* young_generation()  const { return _young_generation;  }\n@@ -483,1 +496,10 @@\n-  ShenandoahOldGeneration*   old_generation()    const { return _old_generation;    }\n+  ShenandoahYoungGeneration* young_generation()  const {\n+    assert(mode()->is_generational(), \"Young generation requires generational mode\");\n+    return _young_generation;\n+  }\n+\n+  ShenandoahOldGeneration*   old_generation()    const {\n+    assert(mode()->is_generational(), \"Old generation requires generational mode\");\n+    return _old_generation;\n+  }\n+\n@@ -485,1 +507,0 @@\n-  const ShenandoahGenerationSizer* generation_sizer()  const { return &_generation_sizer;  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -131,2 +131,6 @@\n-       if (is_old()) {\n-         ShenandoahHeap::heap()->old_generation()->decrement_affiliated_region_count();\n+       ShenandoahHeap* heap = ShenandoahHeap::heap();\n+       if (heap->mode()->is_generational()) {\n+         if (is_old()) {\n+           heap->old_generation()->decrement_affiliated_region_count();\n+         }\n+         heap->young_generation()->increment_affiliated_region_count();\n@@ -135,1 +139,0 @@\n-       ShenandoahHeap::heap()->young_generation()->increment_affiliated_region_count();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -456,2 +456,2 @@\n-  uint age() { return _age; }\n-  CENSUS_NOISE(uint youth() { return _youth; })\n+  uint age() const { return _age; }\n+  CENSUS_NOISE(uint youth() const { return _youth; })\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,5 +78,4 @@\n-ShenandoahYoungGenMemoryPool::ShenandoahYoungGenMemoryPool(ShenandoahHeap* heap) :\n-        ShenandoahMemoryPool(heap,\n-                             \"Shenandoah Young Gen\",\n-                             0,\n-                             heap->max_capacity()) { }\n+ShenandoahGenerationalMemoryPool::ShenandoahGenerationalMemoryPool(ShenandoahHeap* heap, const char* name,\n+                                                                   ShenandoahGeneration* generation) :\n+        ShenandoahMemoryPool(heap, name, 0, heap->max_capacity()),\n+        _generation(generation) { }\n@@ -84,1 +83,1 @@\n-MemoryUsage ShenandoahYoungGenMemoryPool::get_memory_usage() {\n+MemoryUsage ShenandoahGenerationalMemoryPool::get_memory_usage() {\n@@ -88,1 +87,1 @@\n-  size_t committed = _heap->young_generation()->used_regions_size();\n+  size_t committed = _generation->used_regions_size();\n@@ -93,2 +92,2 @@\n-size_t ShenandoahYoungGenMemoryPool::used_in_bytes() {\n-  return _heap->young_generation()->used();\n+size_t ShenandoahGenerationalMemoryPool::used_in_bytes() {\n+  return _generation->used();\n@@ -97,2 +96,2 @@\n-size_t ShenandoahYoungGenMemoryPool::max_size() const {\n-  return _heap->young_generation()->max_capacity();\n+size_t ShenandoahGenerationalMemoryPool::max_size() const {\n+  return _generation->max_capacity();\n@@ -101,5 +100,0 @@\n-ShenandoahOldGenMemoryPool::ShenandoahOldGenMemoryPool(ShenandoahHeap* heap) :\n-        ShenandoahMemoryPool(heap,\n-                             \"Shenandoah Old Gen\",\n-                             0,\n-                             heap->max_capacity()) { }\n@@ -107,12 +101,4 @@\n-MemoryUsage ShenandoahOldGenMemoryPool::get_memory_usage() {\n-  size_t initial   = initial_size();\n-  size_t max       = max_size();\n-  size_t used      = used_in_bytes();\n-  size_t committed = _heap->old_generation()->used_regions_size();\n-\n-  return MemoryUsage(initial, used, committed, max);\n-}\n-\n-size_t ShenandoahOldGenMemoryPool::used_in_bytes() {\n-  return _heap->old_generation()->used();\n-}\n+ShenandoahYoungGenMemoryPool::ShenandoahYoungGenMemoryPool(ShenandoahHeap* heap) :\n+        ShenandoahGenerationalMemoryPool(heap,\n+                             \"Shenandoah Young Gen\",\n+                             heap->young_generation()) { }\n@@ -120,3 +106,4 @@\n-size_t ShenandoahOldGenMemoryPool::max_size() const {\n-  return _heap->old_generation()->max_capacity();\n-}\n+ShenandoahOldGenMemoryPool::ShenandoahOldGenMemoryPool(ShenandoahHeap* heap) :\n+        ShenandoahGenerationalMemoryPool(heap,\n+                             \"Shenandoah Old Gen\",\n+                             heap->old_generation()) { }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMemoryPool.cpp","additions":18,"deletions":31,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#ifndef SERIALGC\n@@ -33,1 +32,0 @@\n-#endif\n@@ -40,1 +38,1 @@\n-  ShenandoahMemoryPool(ShenandoahHeap* pool,\n+  explicit ShenandoahMemoryPool(ShenandoahHeap* heap,\n@@ -42,3 +40,3 @@\n-  virtual MemoryUsage get_memory_usage();\n-  virtual size_t used_in_bytes();\n-  virtual size_t max_size() const;\n+  MemoryUsage get_memory_usage() override;\n+  size_t used_in_bytes() override;\n+  size_t max_size() const override;\n@@ -47,1 +45,1 @@\n-  ShenandoahMemoryPool(ShenandoahHeap* pool,\n+  ShenandoahMemoryPool(ShenandoahHeap* heap,\n@@ -53,1 +51,3 @@\n-class ShenandoahYoungGenMemoryPool : public ShenandoahMemoryPool {\n+class ShenandoahGenerationalMemoryPool: public ShenandoahMemoryPool {\n+private:\n+  ShenandoahGeneration* _generation;\n@@ -55,1 +55,1 @@\n-  ShenandoahYoungGenMemoryPool(ShenandoahHeap* pool);\n+  explicit ShenandoahGenerationalMemoryPool(ShenandoahHeap* heap, const char* name, ShenandoahGeneration* generation);\n@@ -61,1 +61,1 @@\n-class ShenandoahOldGenMemoryPool : public ShenandoahMemoryPool {\n+class ShenandoahYoungGenMemoryPool : public ShenandoahGenerationalMemoryPool {\n@@ -63,4 +63,6 @@\n-  ShenandoahOldGenMemoryPool(ShenandoahHeap* pool);\n-  MemoryUsage get_memory_usage() override;\n-  size_t used_in_bytes() override;\n-  size_t max_size() const override;\n+  explicit ShenandoahYoungGenMemoryPool(ShenandoahHeap* heap);\n+};\n+\n+class ShenandoahOldGenMemoryPool : public ShenandoahGenerationalMemoryPool {\n+public:\n+  explicit ShenandoahOldGenMemoryPool(ShenandoahHeap* heap);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMemoryPool.hpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -187,173 +187,0 @@\n-\n-ShenandoahGenerationSizer::ShenandoahGenerationSizer()\n-  : _sizer_kind(SizerDefaults),\n-    _min_desired_young_regions(0),\n-    _max_desired_young_regions(0) {\n-\n-  if (FLAG_IS_CMDLINE(NewRatio)) {\n-    if (FLAG_IS_CMDLINE(NewSize) || FLAG_IS_CMDLINE(MaxNewSize)) {\n-      log_warning(gc, ergo)(\"-XX:NewSize and -XX:MaxNewSize override -XX:NewRatio\");\n-    } else {\n-      _sizer_kind = SizerNewRatio;\n-      return;\n-    }\n-  }\n-\n-  if (NewSize > MaxNewSize) {\n-    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-      log_warning(gc, ergo)(\"NewSize (\" SIZE_FORMAT \"k) is greater than the MaxNewSize (\" SIZE_FORMAT \"k). \"\n-                            \"A new max generation size of \" SIZE_FORMAT \"k will be used.\",\n-                            NewSize\/K, MaxNewSize\/K, NewSize\/K);\n-    }\n-    FLAG_SET_ERGO(MaxNewSize, NewSize);\n-  }\n-\n-  if (FLAG_IS_CMDLINE(NewSize)) {\n-    _min_desired_young_regions = MAX2(uint(NewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n-    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-      _max_desired_young_regions = MAX2(uint(MaxNewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n-      _sizer_kind = SizerMaxAndNewSize;\n-    } else {\n-      _sizer_kind = SizerNewSizeOnly;\n-    }\n-  } else if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-    _max_desired_young_regions = MAX2(uint(MaxNewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n-    _sizer_kind = SizerMaxNewSizeOnly;\n-  }\n-}\n-\n-size_t ShenandoahGenerationSizer::calculate_min_young_regions(size_t heap_region_count) {\n-  size_t min_young_regions = (heap_region_count * ShenandoahMinYoungPercentage) \/ 100;\n-  return MAX2(min_young_regions, (size_t) 1U);\n-}\n-\n-size_t ShenandoahGenerationSizer::calculate_max_young_regions(size_t heap_region_count) {\n-  size_t max_young_regions = (heap_region_count * ShenandoahMaxYoungPercentage) \/ 100;\n-  return MAX2(max_young_regions, (size_t) 1U);\n-}\n-\n-void ShenandoahGenerationSizer::recalculate_min_max_young_length(size_t heap_region_count) {\n-  assert(heap_region_count > 0, \"Heap must be initialized\");\n-\n-  switch (_sizer_kind) {\n-    case SizerDefaults:\n-      _min_desired_young_regions = calculate_min_young_regions(heap_region_count);\n-      _max_desired_young_regions = calculate_max_young_regions(heap_region_count);\n-      break;\n-    case SizerNewSizeOnly:\n-      _max_desired_young_regions = calculate_max_young_regions(heap_region_count);\n-      _max_desired_young_regions = MAX2(_min_desired_young_regions, _max_desired_young_regions);\n-      break;\n-    case SizerMaxNewSizeOnly:\n-      _min_desired_young_regions = calculate_min_young_regions(heap_region_count);\n-      _min_desired_young_regions = MIN2(_min_desired_young_regions, _max_desired_young_regions);\n-      break;\n-    case SizerMaxAndNewSize:\n-      \/\/ Do nothing. Values set on the command line, don't update them at runtime.\n-      break;\n-    case SizerNewRatio:\n-      _min_desired_young_regions = MAX2(uint(heap_region_count \/ (NewRatio + 1)), 1U);\n-      _max_desired_young_regions = _min_desired_young_regions;\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-  }\n-\n-  assert(_min_desired_young_regions <= _max_desired_young_regions, \"Invalid min\/max young gen size values\");\n-}\n-\n-void ShenandoahGenerationSizer::heap_size_changed(size_t heap_size) {\n-  recalculate_min_max_young_length(heap_size \/ ShenandoahHeapRegion::region_size_bytes());\n-}\n-\n-bool ShenandoahGenerationSizer::transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions) const {\n-  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n-\n-  if (src->free_unaffiliated_regions() < regions) {\n-    \/\/ Source does not have enough free regions for this transfer. The caller should have\n-    \/\/ already capped the transfer based on available unaffiliated regions.\n-    return false;\n-  }\n-\n-  if (dst->max_capacity() + bytes_to_transfer > max_size_for(dst)) {\n-    \/\/ This transfer would cause the destination generation to grow above its configured maximum size.\n-    return false;\n-  }\n-\n-  if (src->max_capacity() - bytes_to_transfer < min_size_for(src)) {\n-    \/\/ This transfer would cause the source generation to shrink below its configured minimum size.\n-    return false;\n-  }\n-\n-  src->decrease_capacity(bytes_to_transfer);\n-  dst->increase_capacity(bytes_to_transfer);\n-  const size_t new_size = dst->max_capacity();\n-  log_info(gc)(\"Transfer \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n-               regions, src->name(), dst->name(), PROPERFMTARGS(new_size));\n-  return true;\n-}\n-\n-\n-size_t ShenandoahGenerationSizer::max_size_for(ShenandoahGeneration* generation) const {\n-  switch (generation->type()) {\n-    case YOUNG:\n-      return max_young_size();\n-    case OLD:\n-      \/\/ On the command line, max size of OLD is specified indirectly, by setting a minimum size of young.\n-      \/\/ OLD is what remains within the heap after YOUNG has been sized.\n-      return ShenandoahHeap::heap()->max_capacity() - min_young_size();\n-    default:\n-      ShouldNotReachHere();\n-      return 0;\n-  }\n-}\n-\n-size_t ShenandoahGenerationSizer::min_size_for(ShenandoahGeneration* generation) const {\n-  switch (generation->type()) {\n-    case YOUNG:\n-      return min_young_size();\n-    case OLD:\n-      \/\/ On the command line, min size of OLD is specified indirectly, by setting a maximum size of young.\n-      \/\/ OLD is what remains within the heap after YOUNG has been sized.\n-      return ShenandoahHeap::heap()->max_capacity() - max_young_size();\n-    default:\n-      ShouldNotReachHere();\n-      return 0;\n-  }\n-}\n-\n-\n-\/\/ Returns true iff transfer is successful\n-bool ShenandoahGenerationSizer::transfer_to_old(size_t regions) const {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  return transfer_regions(heap->young_generation(), heap->old_generation(), regions);\n-}\n-\n-\/\/ This is used when promoting humongous or highly utilized regular regions in place.  It is not required in this situation\n-\/\/ that the transferred regions be unaffiliated.\n-void ShenandoahGenerationSizer::force_transfer_to_old(size_t regions) const {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  ShenandoahGeneration* old_gen = heap->old_generation();\n-  ShenandoahGeneration* young_gen = heap->young_generation();\n-  const size_t bytes_to_transfer = regions * ShenandoahHeapRegion::region_size_bytes();\n-\n-  young_gen->decrease_capacity(bytes_to_transfer);\n-  old_gen->increase_capacity(bytes_to_transfer);\n-  const size_t new_size = old_gen->max_capacity();\n-  log_info(gc)(\"Forcing transfer of \" SIZE_FORMAT \" region(s) from %s to %s, yielding increased size: \" PROPERFMT,\n-               regions, young_gen->name(), old_gen->name(), PROPERFMTARGS(new_size));\n-}\n-\n-\n-bool ShenandoahGenerationSizer::transfer_to_young(size_t regions) const {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  return transfer_regions(heap->old_generation(), heap->young_generation(), regions);\n-}\n-\n-size_t ShenandoahGenerationSizer::min_young_size() const {\n-  return min_young_regions() * ShenandoahHeapRegion::region_size_bytes();\n-}\n-\n-size_t ShenandoahGenerationSizer::max_young_size() const {\n-  return max_young_regions() * ShenandoahHeapRegion::region_size_bytes();\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":0,"deletions":173,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -107,60 +107,0 @@\n-class ShenandoahGenerationSizer {\n-private:\n-  enum SizerKind {\n-    SizerDefaults,\n-    SizerNewSizeOnly,\n-    SizerMaxNewSizeOnly,\n-    SizerMaxAndNewSize,\n-    SizerNewRatio\n-  };\n-  SizerKind _sizer_kind;\n-\n-  size_t _min_desired_young_regions;\n-  size_t _max_desired_young_regions;\n-\n-  static size_t calculate_min_young_regions(size_t heap_region_count);\n-  static size_t calculate_max_young_regions(size_t heap_region_count);\n-\n-  \/\/ Update the given values for minimum and maximum young gen length in regions\n-  \/\/ given the number of heap regions depending on the kind of sizing algorithm.\n-  void recalculate_min_max_young_length(size_t heap_region_count);\n-\n-  \/\/ This will attempt to transfer regions from the `src` generation to `dst` generation.\n-  \/\/ If the transfer would violate the configured minimum size for the source or the configured\n-  \/\/ maximum size of the destination, it will not perform the transfer and will return false.\n-  \/\/ Returns true if the transfer is performed.\n-  bool transfer_regions(ShenandoahGeneration* src, ShenandoahGeneration* dst, size_t regions) const;\n-\n-  \/\/ Return the configured maximum size in bytes for the given generation.\n-  size_t max_size_for(ShenandoahGeneration* generation) const;\n-\n-  \/\/ Return the configured minimum size in bytes for the given generation.\n-  size_t min_size_for(ShenandoahGeneration* generation) const;\n-\n-    public:\n-  ShenandoahGenerationSizer();\n-\n-  \/\/ Calculate the maximum length of the young gen given the number of regions\n-  \/\/ depending on the sizing algorithm.\n-  void heap_size_changed(size_t heap_size);\n-\n-  \/\/ Minimum size of young generation in bytes as multiple of region size.\n-  size_t min_young_size() const;\n-  size_t min_young_regions() const {\n-    return _min_desired_young_regions;\n-  }\n-\n-  \/\/ Maximum size of young generation in bytes as multiple of region size.\n-  size_t max_young_size() const;\n-  size_t max_young_regions() const {\n-    return _max_desired_young_regions;\n-  }\n-\n-  \/\/ True if transfer succeeds, else false. See transfer_regions.\n-  bool transfer_to_young(size_t regions) const;\n-  bool transfer_to_old(size_t regions) const;\n-\n-  \/\/ force transfer is used when we promote humongous objects.  May violate min\/max limits on generation sizes\n-  void force_transfer_to_old(size_t regions) const;\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.hpp","additions":0,"deletions":60,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  ShenandoahGenerationalHeap* const heap = ShenandoahGenerationalHeap::heap();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -568,1 +568,1 @@\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  ShenandoahGenerationalHeap* heap = ShenandoahGenerationalHeap::heap();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}