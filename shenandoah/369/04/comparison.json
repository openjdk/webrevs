{"files":[{"patch":"@@ -237,1 +237,0 @@\n-  size_t old_evacuation_reserve = 0;\n@@ -256,3 +255,24 @@\n-  size_t maximum_young_evacuation_reserve = (young_generation->max_capacity() * ShenandoahEvacReserve) \/ 100;\n-  size_t young_evacuation_reserve = maximum_young_evacuation_reserve;\n-  size_t excess_young;\n+  const size_t maximum_young_evacuation_reserve = (young_generation->max_capacity() * ShenandoahEvacReserve) \/ 100;\n+  const size_t young_evacuation_reserve = MIN2(maximum_young_evacuation_reserve, young_generation->available_with_reserve());\n+\n+  \/\/ maximum_old_evacuation_reserve is an upper bound on memory evacuated from old and evacuated to old (promoted),\n+  \/\/ clamped by the old generation space available.\n+  \/\/\n+  \/\/ Here's the algebra.\n+  \/\/ Let SOEP = ShenandoahOldEvacRatioPercent,\n+  \/\/     OE = old evac,\n+  \/\/     YE = young evac, and\n+  \/\/     TE = total evac = OE + YE\n+  \/\/ By definition:\n+  \/\/            SOEP\/100 = OE\/TE\n+  \/\/                     = OE\/(OE+YE)\n+  \/\/  => SOEP\/(100-SOEP) = OE\/((OE+YE)-OE)         \/\/ componendo-dividendo: If a\/b = c\/d, then a\/(b-a) = c\/(d-c)\n+  \/\/                     = OE\/YE\n+  \/\/  =>              OE = YE*SOEP\/(100-SOEP)\n+\n+  \/\/ We have to be careful in the event that SOEP is set to 100 by the user.\n+  assert(ShenandoahOldEvacRatioPercent <= 100, \"Error\");\n+  const size_t old_available = old_generation->available();\n+  const size_t maximum_old_evacuation_reserve = (ShenandoahOldEvacRatioPercent == 100) ?\n+    old_available : MIN2((maximum_young_evacuation_reserve * ShenandoahOldEvacRatioPercent) \/ (100 - ShenandoahOldEvacRatioPercent),\n+                          old_available);\n@@ -260,35 +280,0 @@\n-  size_t total_young_available = young_generation->available_with_reserve();\n-  if (total_young_available > young_evacuation_reserve) {\n-    excess_young = total_young_available - young_evacuation_reserve;\n-  } else {\n-    young_evacuation_reserve = total_young_available;\n-    excess_young = 0;\n-  }\n-  size_t unaffiliated_young = young_generation->free_unaffiliated_regions() * region_size_bytes;\n-  if (excess_young > unaffiliated_young) {\n-    excess_young = unaffiliated_young;\n-  } else {\n-    \/\/ round down to multiple of region size\n-    excess_young \/= region_size_bytes;\n-    excess_young *= region_size_bytes;\n-  }\n-  \/\/ excess_young is available to be transferred to OLD.  Assume that OLD will not request any more than had\n-  \/\/ already been set aside for its promotion and evacuation needs at the end of previous GC.  No need to\n-  \/\/ hold back memory for allocation runway.\n-\n-  \/\/ TODO: excess_young is unused.  Did we want to add it old_promo_reserve and\/or old_evacuation_reserve?\n-\n-  ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n-\n-  \/\/ maximum_old_evacuation_reserve is an upper bound on memory evacuated from old and evacuated to old (promoted).\n-  size_t maximum_old_evacuation_reserve =\n-    maximum_young_evacuation_reserve * ShenandoahOldEvacRatioPercent \/ (100 - ShenandoahOldEvacRatioPercent);\n-  \/\/ Here's the algebra:\n-  \/\/  TotalEvacuation = OldEvacuation + YoungEvacuation\n-  \/\/  OldEvacuation = TotalEvacuation * (ShenandoahOldEvacRatioPercent\/100)\n-  \/\/  OldEvacuation = YoungEvacuation * (ShenandoahOldEvacRatioPercent\/100)\/(1 - ShenandoahOldEvacRatioPercent\/100)\n-  \/\/  OldEvacuation = YoungEvacuation * ShenandoahOldEvacRatioPercent\/(100 - ShenandoahOldEvacRatioPercent)\n-\n-  if (maximum_old_evacuation_reserve > old_generation->available()) {\n-    maximum_old_evacuation_reserve = old_generation->available();\n-  }\n@@ -303,1 +288,2 @@\n-  size_t old_promo_reserve;\n+  ShenandoahOldHeuristics* old_heuristics = heap->old_heuristics();\n+  size_t old_evacuation_reserve, old_promo_reserve;\n@@ -331,0 +317,1 @@\n+  assert(old_evacuation_reserve <= old_available, \"Error\");\n@@ -335,2 +322,1 @@\n-  size_t old_free_regions = old_generation->free_unaffiliated_regions();\n-  size_t old_free_unfragmented = old_free_regions * region_size_bytes;\n+  const size_t old_free_unfragmented = old_generation->free_unaffiliated_regions() * region_size_bytes;\n@@ -338,1 +324,1 @@\n-    size_t delta = old_evacuation_reserve - old_free_unfragmented;\n+    const size_t delta = old_evacuation_reserve - old_free_unfragmented;\n@@ -340,1 +326,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":29,"deletions":44,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -1185,1 +1185,4 @@\n-\/\/ xfer_limit is the maximum we're able to transfer from young to old\n+\/\/ Make sure old-generation is large enough, but no larger than is necessary, to hold mixed evacuations\n+\/\/ and promotions, if we anticipate either. Any deficit is provided by the young generation, subject to\n+\/\/ xfer_limit, and any excess is transferred to the young generation.\n+\/\/ xfer_limit is the maximum we're able to transfer from young to old.\n@@ -1189,4 +1192,19 @@\n-  \/\/ Make sure old-generation is large enough, but no larger, than is necessary to hold mixed evacuations\n-  \/\/ and promotions if we anticipate either.\n-  size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n-  size_t promo_load = get_promotion_potential();\n+  \/\/ We can limit the old reserve to the size of anticipated promotions:\n+  \/\/ max_old_reserve is an upper bound on memory evacuated from old and promoted to old,\n+  \/\/ clamped by the old generation space available.\n+  \/\/\n+  \/\/ Here's the algebra.\n+  \/\/ Let SOEP = ShenandoahOldEvacRatioPercent,\n+  \/\/     OE = old evac,\n+  \/\/     YE = young evac, and\n+  \/\/     TE = total evac = OE + YE\n+  \/\/ By definition:\n+  \/\/            SOEP\/100 = OE\/TE\n+  \/\/                     = OE\/(OE+YE)\n+  \/\/  => SOEP\/(100-SOEP) = OE\/((OE+YE)-OE)      \/\/ componendo-dividendo: If a\/b = c\/d, then a\/(b-a) = c\/(d-c)\n+  \/\/                     = OE\/YE\n+  \/\/  =>              OE = YE*SOEP\/(100-SOEP)\n+\n+  \/\/ We have to be careful in the event that SOEP is set to 100 by the user.\n+  assert(ShenandoahOldEvacRatioPercent <= 100, \"Error\");\n+  const size_t old_available = old_generation()->available();\n@@ -1194,21 +1212,4 @@\n-  size_t young_reserve = (young_generation()->max_capacity() * ShenandoahEvacReserve) \/ 100;\n-  size_t old_reserve = 0;\n-  size_t mixed_candidates = old_heuristics()->unprocessed_old_collection_candidates();\n-  bool doing_mixed = (mixed_candidates > 0);\n-  bool doing_promotions = promo_load > 0;\n-\n-  \/\/ round down\n-  size_t max_old_region_xfer = xfer_limit \/ region_size_bytes;\n-\n-  \/\/ We can limit the reserve to the size of anticipated promotions\n-  size_t max_old_reserve = young_reserve * ShenandoahOldEvacRatioPercent \/ (100 - ShenandoahOldEvacRatioPercent);\n-  \/\/ Here's the algebra:\n-  \/\/  TotalEvacuation = OldEvacuation + YoungEvacuation\n-  \/\/  OldEvacuation = TotalEvacuation*(ShenandoahOldEvacRatioPercent\/100)\n-  \/\/  OldEvacuation = YoungEvacuation * (ShenandoahOldEvacRatioPercent\/100)\/(1 - ShenandoahOldEvacRatioPercent\/100)\n-  \/\/  OldEvacuation = YoungEvacuation * ShenandoahOldEvacRatioPercent\/(100 - ShenandoahOldEvacRatioPercent)\n-\n-  size_t reserve_for_mixed, reserve_for_promo;\n-  if (doing_mixed) {\n-    assert(old_generation()->available() >= old_generation()->free_unaffiliated_regions() * region_size_bytes,\n-           \"Unaffiliated available must be less than total available\");\n+  const size_t young_reserve = (young_generation()->max_capacity() * ShenandoahEvacReserve) \/ 100;\n+  const size_t max_old_reserve = (ShenandoahOldEvacRatioPercent == 100) ?\n+     old_available : MIN2((young_reserve * ShenandoahOldEvacRatioPercent) \/ (100 - ShenandoahOldEvacRatioPercent),\n+                          old_available);\n@@ -1216,0 +1217,7 @@\n+  const size_t region_size_bytes = ShenandoahHeapRegion::region_size_bytes();\n+\n+  \/\/ Decide how much old space we should reserve for a mixed collection\n+  size_t reserve_for_mixed = 0;\n+  const size_t mixed_candidates = old_heuristics()->unprocessed_old_collection_candidates();\n+  const bool doing_mixed = (mixed_candidates > 0);\n+  if (doing_mixed) {\n@@ -1220,0 +1228,2 @@\n+    assert(old_available >= old_generation()->free_unaffiliated_regions() * region_size_bytes,\n+           \"Unaffiliated available must be less than total available\");\n@@ -1221,1 +1231,1 @@\n-      old_generation()->available() - old_generation()->free_unaffiliated_regions() * region_size_bytes;\n+      old_available - old_generation()->free_unaffiliated_regions() * region_size_bytes;\n@@ -1226,2 +1236,0 @@\n-  } else {\n-    reserve_for_mixed = 0;\n@@ -1230,1 +1238,4 @@\n-  size_t available_for_promotions = max_old_reserve - reserve_for_mixed;\n+  \/\/ Decide how much space we should reserve for promotions from young\n+  size_t reserve_for_promo = 0;\n+  const size_t promo_load = get_promotion_potential();\n+  const bool doing_promotions = promo_load > 0;\n@@ -1232,7 +1243,3 @@\n-    \/\/ We're only promoting and we have a maximum bound on the amount to be promoted\n-    reserve_for_promo = (size_t) (promo_load * ShenandoahPromoEvacWaste);\n-    if (reserve_for_promo > available_for_promotions) {\n-      reserve_for_promo = available_for_promotions;\n-    }\n-  } else {\n-    reserve_for_promo = 0;\n+    \/\/ We're promoting and have a bound on the maximum amount that can be promoted\n+    const size_t available_for_promotions = max_old_reserve - reserve_for_mixed;\n+    reserve_for_promo = MIN2((size_t)(promo_load * ShenandoahPromoEvacWaste), available_for_promotions);\n@@ -1240,1 +1247,3 @@\n-  old_reserve = reserve_for_mixed + reserve_for_promo;\n+\n+  \/\/ This is the total old we want to ideally reserve\n+  const size_t old_reserve = reserve_for_mixed + reserve_for_promo;\n@@ -1242,2 +1251,2 @@\n-  size_t old_available = old_generation()->available() + old_cset_regions * region_size_bytes;\n-  size_t young_available = young_generation()->available() + young_cset_regions * region_size_bytes;\n+\n+  \/\/ We now check if the old generation is running a surplus or a deficit.\n@@ -1246,12 +1255,8 @@\n-  if (old_available >= old_reserve) {\n-    size_t old_excess = old_available - old_reserve;\n-    size_t excess_regions = old_excess \/ region_size_bytes;\n-    size_t unaffiliated_old_regions = old_generation()->free_unaffiliated_regions() + old_cset_regions;\n-    size_t unaffiliated_old = unaffiliated_old_regions * region_size_bytes;\n-    if (unaffiliated_old_regions < excess_regions) {\n-      \/\/ We'll give only unaffiliated old to young, which is known to be less than the excess.\n-      old_region_surplus = unaffiliated_old_regions;\n-    } else {\n-      \/\/ unaffiliated_old_regions > excess_regions, so we only give away the excess.\n-      old_region_surplus = excess_regions;\n-    }\n+\n+  const size_t max_old_available = old_generation()->available() + old_cset_regions * region_size_bytes;\n+  if (max_old_available >= old_reserve) {\n+    \/\/ We are running a surplus, so the old region surplus can go to young\n+    const size_t old_surplus = max_old_available - old_reserve;\n+    old_region_surplus = old_surplus \/ region_size_bytes;\n+    const size_t unaffiliated_old_regions = old_generation()->free_unaffiliated_regions() + old_cset_regions;\n+    old_region_surplus = MIN2(old_region_surplus, unaffiliated_old_regions);\n@@ -1259,1 +1264,2 @@\n-    \/\/ We need to request transfer from YOUNG.  Ignore that this will directly impact young_generation()->max_capacity(),\n+    \/\/ We are running a deficit which we'd like to fill from young.\n+    \/\/ Ignore that this will directly impact young_generation()->max_capacity(),\n@@ -1261,2 +1267,2 @@\n-    size_t old_need = old_reserve - old_available;\n-    \/\/ Round up the number of regions needed from YOUNG\n+    const size_t old_need = old_reserve - max_old_available;\n+    \/\/ The old region deficit (rounded up) will come from young\n@@ -1264,0 +1270,6 @@\n+\n+    \/\/ Round down the regions we can transfer from young to old. If we're running short\n+    \/\/ on young-gen memory, we restrict the xfer. Old-gen collection activities will be\n+    \/\/ curtailed if the budget is restricted.\n+    const size_t max_old_region_xfer = xfer_limit \/ region_size_bytes;\n+    old_region_deficit = MIN2(old_region_deficit, max_old_region_xfer);\n@@ -1265,5 +1277,2 @@\n-  if (old_region_deficit > max_old_region_xfer) {\n-    \/\/ If we're running short on young-gen memory, limit the xfer.  Old-gen collection activities will be curtailed\n-    \/\/ if the budget is smaller than desired.\n-    old_region_deficit = max_old_region_xfer;\n-  }\n+  assert(old_region_deficit == 0 || old_region_surplus == 0, \"Only surplus or deficit, never both\");\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":69,"deletions":60,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -414,7 +414,7 @@\n-          \"The maximum proportion of evacuation from old-gen memory, as \"   \\\n-          \"a percent ratio.  The default value 75 denotes that no more \"    \\\n-          \"than 75% of the collection set evacuation \"                      \\\n-          \"workload may be evacuate to old-gen heap regions.  This limits \" \\\n-          \"both the promotion of aged regions and the compaction of \"       \\\n-          \"existing old regions.  A value of 75 denotes that the normal \"   \\\n-          \"young-gen evacuation is increased by up to four fold. \"          \\\n+          \"The maximum proportion of evacuation from old-gen memory, \"      \\\n+          \"expressed as a percentage. The default value 75 denotes that no\" \\\n+          \"more than 75% of the collection set evacuation workload may be \" \\\n+          \"towards evacuation of old-gen heap regions. This limits both the\"\\\n+          \"promotion of aged regions and the compaction of existing old \"   \\\n+          \"regions.  A value of 75 denotes that the total evacuation work\"  \\\n+          \"may increase to up to four times the young gen evacuation work.\" \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}