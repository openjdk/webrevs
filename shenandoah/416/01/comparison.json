{"files":[{"patch":"@@ -38,6 +38,0 @@\n-FindSrcDirsForLib += \\\n-  $(call uniq, $(wildcard \\\n-      $(TOPDIR)\/src\/$(strip $1)\/$(OPENJDK_TARGET_OS)\/native\/lib$(strip $2) \\\n-      $(TOPDIR)\/src\/$(strip $1)\/$(OPENJDK_TARGET_OS_TYPE)\/native\/lib$(strip $2) \\\n-      $(TOPDIR)\/src\/$(strip $1)\/share\/native\/lib$(strip $2)))\n-\n@@ -107,2 +101,3 @@\n-# Setup make rules for creating a native shared library with suitable defaults\n-# for the OpenJDK project.\n+# Setup make rules for creating a native binary with suitable defaults\n+# for the OpenJDK project. This macro is mostly considered to be an internal\n+# support version. Please use SetupJdkLibrary or SetupJdkExecutable instead.\n@@ -114,1 +109,3 @@\n-# SetupNativeCompilation, except for\n+# SetupNativeCompilation. This macro also adds the following additional\n+# arguments:\n+#\n@@ -125,2 +122,25 @@\n-SetupJdkLibrary = $(NamedParamsMacroTemplate)\n-define SetupJdkLibraryBody\n+#   JDK_LIBS -- libraries generated by the JDK build system to link against\n+#   JDK_LIBS_<os> or JDK_LIBS_<osType> -- additional JDK_LIBS for the given OS\n+#     or OS type only\n+#   DEFAULT_CFLAGS -- if false, do not add default CFLAGS and CXXFLAGS\n+#   CFLAGS_FILTER_OUT -- flags to filter out from default CFLAGS\n+#   CXXFLAGS_FILTER_OUT -- flags to filter out from default CXXFLAGS\n+#   LDFLAGS_FILTER_OUT -- flags to filter out from default LDFLAGS\n+#   LD_SET_ORIGIN -- if false, do not add SET_*_ORIGIN flags to LDFLAGS\n+#   APPEND_LDFLAGS -- a quirk to have additional LDFLAGS that will be set after\n+#     the origin flags\n+#\n+SetupJdkNativeCompilation = $(NamedParamsMacroTemplate)\n+define SetupJdkNativeCompilationBody\n+  ifeq ($$($1_TYPE), EXECUTABLE)\n+    $1_NATIVE_DIR_PREFIX :=\n+    $1_MODULES_PATH := modules_cmds\n+    $1_RC_EXT := exe\n+    $1_RC_FTYPE := 0x1L\n+  else\n+    $1_NATIVE_DIR_PREFIX := lib\n+    $1_MODULES_PATH := modules_libs\n+    $1_RC_EXT := dll\n+    $1_RC_FTYPE := 0x2L\n+  endif\n+\n@@ -129,1 +149,5 @@\n-      $1_OUTPUT_DIR := $$(call FindLibDirForModule, $$(MODULE))\n+      ifeq ($$($1_TYPE), STATIC_LIBRARY)\n+        $1_OUTPUT_DIR := $$(SUPPORT_OUTPUTDIR)\/native\/$$(MODULE)\n+      else\n+        $1_OUTPUT_DIR := $$(SUPPORT_OUTPUTDIR)\/$$($1_MODULES_PATH)\/$$(strip $$(MODULE))\n+      endif\n@@ -137,1 +161,1 @@\n-      $1_OBJECT_DIR := $$(SUPPORT_OUTPUTDIR)\/native\/$$(MODULE)\/lib$$($1_NAME)\n+      $1_OBJECT_DIR := $$(SUPPORT_OUTPUTDIR)\/native\/$$(MODULE)\/$$($1_NATIVE_DIR_PREFIX)$$($1_NAME)\n@@ -149,1 +173,1 @@\n-      $1_SRC := $$(call FindSrcDirsForLib, $$(MODULE), $$($1_NAME))\n+      $1_SRC := $$(call FindSrcDirsForComponent, $$(MODULE), $$($1_NATIVE_DIR_PREFIX)$$($1_NAME))\n@@ -174,1 +198,0 @@\n-\n@@ -176,2 +199,2 @@\n-      -D\"JDK_FILEDESC=$$(strip $$($1_RC_FILEDESC))\" \\\n-      -D\"JDK_FNAME=$$($1_NAME).dll\" \\\n+      -D\"JDK_FILEDESC=$$($1_RC_FILEDESC)\" \\\n+      -D\"JDK_FNAME=$$($1_NAME).$$($1_RC_EXT)\" \\\n@@ -179,1 +202,1 @@\n-      -D\"JDK_FTYPE=0x2L\" \\\n+      -D\"JDK_FTYPE=$$($1_RC_FTYPE)\" \\\n@@ -202,2 +225,3 @@\n-    # Set the default flags first to be able to override\n-    $1_CFLAGS := $$(filter-out $$($1_CFLAGS_FILTER_OUT), $$(CFLAGS_JDKLIB)) $$($1_CFLAGS)\n+    ifeq ($$($1_TYPE), EXECUTABLE)\n+      # Set the default flags first to be able to override\n+      $1_CFLAGS := $$(filter-out $$($1_CFLAGS_FILTER_OUT), $$(CFLAGS_JDKEXE)) $$($1_CFLAGS)\n@@ -205,2 +229,9 @@\n-    # Set the default flags first to be able to override\n-    $1_CXXFLAGS := $$(filter-out $$($1_CXXFLAGS_FILTER_OUT), $$(CXXFLAGS_JDKLIB)) $$($1_CXXFLAGS)\n+      # Set the default flags first to be able to override\n+      $1_CXXFLAGS := $$(filter-out $$($1_CXXFLAGS_FILTER_OUT), $$(CXXFLAGS_JDKEXE)) $$($1_CXXFLAGS)\n+    else\n+      # Set the default flags first to be able to override\n+      $1_CFLAGS := $$(filter-out $$($1_CFLAGS_FILTER_OUT), $$(CFLAGS_JDKLIB)) $$($1_CFLAGS)\n+\n+      # Set the default flags first to be able to override\n+      $1_CXXFLAGS := $$(filter-out $$($1_CXXFLAGS_FILTER_OUT), $$(CXXFLAGS_JDKLIB)) $$($1_CXXFLAGS)\n+    endif\n@@ -220,2 +251,7 @@\n-    # Set the default flags first to be able to override\n-    $1_LDFLAGS := $$(filter-out $$($1_LDFLAGS_FILTER_OUT), $$(LDFLAGS_JDKLIB)) $$($1_LDFLAGS)\n+    ifeq ($$($1_TYPE), EXECUTABLE)\n+      # Set the default flags first to be able to override\n+      $1_LDFLAGS := $$(filter-out $$($1_LDFLAGS_FILTER_OUT), $$(LDFLAGS_JDKEXE)) $$($1_LDFLAGS)\n+    else\n+      # Set the default flags first to be able to override\n+      $1_LDFLAGS := $$(filter-out $$($1_LDFLAGS_FILTER_OUT), $$(LDFLAGS_JDKLIB)) $$($1_LDFLAGS)\n+    endif\n@@ -225,1 +261,5 @@\n-    $1_LDFLAGS += $$(call SET_SHARED_LIBRARY_ORIGIN)\n+    ifeq ($$($1_TYPE), EXECUTABLE)\n+      $1_LDFLAGS += $$(call SET_EXECUTABLE_ORIGIN)\n+    else\n+      $1_LDFLAGS += $$(call SET_SHARED_LIBRARY_ORIGIN)\n+    endif\n@@ -233,1 +273,1 @@\n-  $$(eval $$(call SetupNativeCompilation, $1, ))\n+  $$(eval $$(call SetupNativeCompilation, $1))\n@@ -236,2 +276,3 @@\n-# Setup make rules for creating a native executable with suitable defaults for\n-# the OpenJDK project.\n+# Setup make rules for creating a native library with suitable defaults\n+# for the OpenJDK project. The default is to create a shared library,\n+# but by passing TYPE := STATIC_LIBARY, a static library can be created.\n@@ -243,82 +284,6 @@\n-# SetupNativeCompilation, except for\n-#   EXTRA_RCFLAGS -- additional RCFLAGS to append.\n-SetupJdkExecutable = $(NamedParamsMacroTemplate)\n-define SetupJdkExecutableBody\n-  $1_TYPE := EXECUTABLE\n-\n-  ifeq ($$($1_OUTPUT_DIR), )\n-    ifneq ($$(MODULE), )\n-      $1_OUTPUT_DIR := $$(call FindExecutableDirForModule, $$(MODULE))\n-    else\n-      $$(error Must specify OUTPUT_DIR in a MODULE free context)\n-    endif\n-  endif\n-\n-  ifeq ($$($1_OBJECT_DIR), )\n-    ifneq ($$(MODULE), )\n-      $1_OBJECT_DIR := $$(SUPPORT_OUTPUTDIR)\/native\/$$(MODULE)\/$$($1_NAME)\n-    else\n-      $$(error Must specify OBJECT_DIR in a MODULE free context)\n-    endif\n-  endif\n-\n-  ifeq ($$($1_LINK_TYPE), C++)\n-    $1_LIBS += $(LIBCXX)\n-  endif\n-\n-  ifeq ($$($1_SRC), )\n-    ifneq ($$(MODULE), )\n-      $1_SRC := $$(call FindSrcDirsForComponent, $$(MODULE), $$($1_NAME))\n-    else\n-      $$(error Must specify SRC in a MODULE free context)\n-    endif\n-  else\n-    $1_SRC := $$(foreach dir, $$($1_SRC), $$(call ProcessDir, $$(dir)))\n-  endif\n-  ifneq ($$($1_EXTRA_SRC), )\n-    $1_SRC += $$(foreach dir, $$($1_EXTRA_SRC), $$(call ProcessDir, $$(dir)))\n-  endif\n-\n-  ifeq ($$($1_VERSIONINFO_RESOURCE), )\n-    $1_VERSIONINFO_RESOURCE := $$(GLOBAL_VERSION_INFO_RESOURCE)\n-  endif\n-\n-  $1_RCFLAGS := $(JDK_RCFLAGS) \\\n-      -D\"JDK_FILEDESC=$(JDK_RC_NAME) binary\" \\\n-      -D\"JDK_FNAME=$$($1_NAME).exe\" \\\n-      -D\"JDK_INTERNAL_NAME=$$($1_NAME)\" \\\n-      -D\"JDK_FTYPE=0x1L\" \\\n-      -I$(TOPDIR)\/src\/java.base\/windows\/native\/common \\\n-      $$($1_EXTRA_RCFLAGS)\n-\n-  ifneq ($$($1_HEADERS_FROM_SRC), false)\n-    $1_SRC_HEADER_FLAGS := $$(addprefix -I, $$(wildcard $$($1_SRC)))\n-  endif\n-\n-  $1_JDK_LIBS += $$($1_JDK_LIBS_$$(OPENJDK_TARGET_OS))\n-  $1_JDK_LIBS += $$($1_JDK_LIBS_$$(OPENJDK_TARGET_OS_TYPE))\n-  # Prepend JDK libs before external libs\n-  $1_LIBS := $$($1_JDK_LIBS) $$($1_LIBS)\n-\n-  ifneq ($$($1_EXTRA_HEADER_DIRS), )\n-    $1_PROCESSED_EXTRA_HEADER_DIRS := $$(foreach dir, $$($1_EXTRA_HEADER_DIRS), \\\n-        $$(call ProcessDir, $$(dir)))\n-    $1_EXTRA_HEADER_FLAGS := $$(addprefix -I, $$($1_PROCESSED_EXTRA_HEADER_DIRS))\n-  endif\n-\n-  ifneq ($$($1_DEFAULT_CFLAGS), false)\n-    # Set the default flags first to be able to override\n-    $1_CFLAGS := $$(filter-out $$($1_CFLAGS_FILTER_OUT), $$(CFLAGS_JDKEXE)) $$($1_CFLAGS)\n-\n-    # Set the default flags first to be able to override\n-    $1_CXXFLAGS := $$(filter-out $$($1_CXXFLAGS_FILTER_OUT), $$(CXXFLAGS_JDKEXE)) $$($1_CXXFLAGS)\n-  endif\n-\n-  ifneq ($$($1_CFLAGS), )\n-    $1_CFLAGS += $$($1_SRC_HEADER_FLAGS) $$($1_EXTRA_HEADER_FLAGS)\n-  endif\n-  ifneq ($$($1_CXXFLAGS), )\n-    $1_CXXFLAGS += $$($1_SRC_HEADER_FLAGS) $$($1_EXTRA_HEADER_FLAGS)\n-  endif\n-  ifeq ($$($1_CFLAGS)$$($1_CXXFLAGS), )\n-    $1_CFLAGS += $$($1_SRC_HEADER_FLAGS) $$($1_EXTRA_HEADER_FLAGS)\n+# SetupJdkNativeCompilation. Please see that macro for details.\n+SetupJdkLibrary = $(NamedParamsMacroTemplate)\n+define SetupJdkLibraryBody\n+  # If type is unspecified, default to LIBRARY\n+  ifeq ($$($1_TYPE), )\n+    $1_TYPE := LIBRARY\n@@ -327,4 +292,4 @@\n-  ifneq ($$($1_DEFAULT_LDFLAGS), false)\n-    # Set the default flags first to be able to override\n-    $1_LDFLAGS := $$(filter-out $$($1_LDFLAGS_FILTER_OUT), $$(LDFLAGS_JDKEXE)) $$($1_LDFLAGS)\n-  endif\n+  # Since we reuse the rule name ($1), all our arguments will pass through.\n+  # We lose in transparency, but gain in brevity in this call...\n+  $$(eval $$(call SetupJdkNativeCompilation, $1))\n+endef\n@@ -332,3 +297,11 @@\n-  ifneq ($$($1_LD_SET_ORIGIN), false)\n-    $1_LDFLAGS += $$(call SET_EXECUTABLE_ORIGIN)\n-  endif\n+# Setup make rules for creating a native executable with suitable defaults\n+# for the OpenJDK project.\n+#\n+# Parameter 1 is the name of the rule. This name is used as variable prefix,\n+# and the targets generated are listed in a variable by that name.\n+#\n+# Remaining parameters are named arguments. These are all passed on to\n+# SetupJdkNativeCompilation. Please see that macro for details.\n+SetupJdkExecutable = $(NamedParamsMacroTemplate)\n+define SetupJdkExecutableBody\n+  $1_TYPE := EXECUTABLE\n@@ -338,1 +311,1 @@\n-  $$(eval $$(call SetupNativeCompilation, $1))\n+  $$(eval $$(call SetupJdkNativeCompilation, $1))\n","filename":"make\/common\/JdkNativeCompilation.gmk","additions":91,"deletions":118,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -76,2 +76,0 @@\n-#   ARFLAGS the archiver flags to be used on unix platforms\n-#   LIBFLAGS the flags for the lib tool used on windows\n","filename":"make\/common\/NativeCompilation.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,3 +154,1 @@\n-      JDK_LIBS_linux := -ljli, \\\n-      JDK_LIBS_macosx := -ljli, \\\n-      JDK_LIBS_aix := -ljli_static, \\\n+      JDK_LIBS_unix := -ljli, \\\n@@ -180,1 +178,1 @@\n-    $$(BUILD_LAUNCHER_$1): $(call FindStaticLib, java.base, jli_static)\n+    $$(BUILD_LAUNCHER_$1): $(call FindStaticLib, java.base, jli)\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  $1_VARDEPS := $$($1_AR) $$(ARFLAGS) $$($1_ARFLAGS) $$($1_LIBS) \\\n+  $1_VARDEPS := $$($1_AR) $$(ARFLAGS) $$($1_LIBS) \\\n@@ -119,1 +119,1 @@\n-\t    $$($1_AR) $$(ARFLAGS) $$($1_ARFLAGS) -r -cs $$($1_TARGET) \\\n+\t    $$($1_AR) $$(ARFLAGS) -r -cs $$($1_TARGET) \\\n","filename":"make\/common\/native\/Link.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  $1_VARDEPS := $$($1_LIB) $$(LIBFLAGS) $$($1_LIBFLAGS) $$($1_LIBS) \\\n+  $1_VARDEPS := $$($1_LIB) $$(LIBFLAGS) $$($1_LIBS) \\\n@@ -53,1 +53,1 @@\n-\t    $$($1_LIB) -nologo $$(LIBFLAGS) $$($1_LIBFLAGS) -out:$$($1_TARGET) \\\n+\t    $$($1_LIB) -nologo $$(LIBFLAGS) -out:$$($1_TARGET) \\\n","filename":"make\/common\/native\/LinkMicrosoft.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk21\/fd2272bbf8e04c3dbaee13770090416c\/35\/GPL\/openjdk-21_linux-x64_bin.tar.gz\n-LINUX_X64_BOOT_JDK_SHA256=a30c454a9bef8f46d5f1bf3122830014a8fbe7ac03b5f8729bc3add4b92a1d0a\n+LINUX_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk22\/830ec9fcccef480bb3e73fb7ecafe059\/36\/GPL\/openjdk-22_linux-x64_bin.tar.gz\n+LINUX_X64_BOOT_JDK_SHA256=4d65cc6ed28711768fd72c2043a7925f7c83f5f51bb64970bd9d52f7791fc6ac\n@@ -36,2 +36,2 @@\n-MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk21\/fd2272bbf8e04c3dbaee13770090416c\/35\/GPL\/openjdk-21_macos-x64_bin.tar.gz\n-MACOS_X64_BOOT_JDK_SHA256=af32e84c11009f72f783fdcdc9917efc277893988f097e198e2576875d1e88c1\n+MACOS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk22\/830ec9fcccef480bb3e73fb7ecafe059\/36\/GPL\/openjdk-22_macos-x64_bin.tar.gz\n+MACOS_X64_BOOT_JDK_SHA256=ae31fe10916429e3fe284266095067a5ce9fecbdc03ff1a079d20459f731ca36\n@@ -40,2 +40,2 @@\n-MACOS_AARCH64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk21\/fd2272bbf8e04c3dbaee13770090416c\/35\/GPL\/openjdk-21_macos-aarch64_bin.tar.gz\n-MACOS_AARCH64_BOOT_JDK_SHA256=f12e1e0a2dffc847951598f597c8ee60fb0913932f24b2b09c62cfd2f0f4dfb9\n+MACOS_AARCH64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk22\/830ec9fcccef480bb3e73fb7ecafe059\/36\/GPL\/openjdk-22_macos-aarch64_bin.tar.gz\n+MACOS_AARCH64_BOOT_JDK_SHA256=d10f82429d01047968c52c7975c326388cb5d212791e14c1de21c987463a4b53\n@@ -44,2 +44,2 @@\n-WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk21\/fd2272bbf8e04c3dbaee13770090416c\/35\/GPL\/openjdk-21_windows-x64_bin.zip\n-WINDOWS_X64_BOOT_JDK_SHA256=5434faaf029e66e7ce6e75770ca384de476750984a7d2881ef7686894c4b4944\n+WINDOWS_X64_BOOT_JDK_URL=https:\/\/download.java.net\/java\/GA\/jdk22\/830ec9fcccef480bb3e73fb7ecafe059\/36\/GPL\/openjdk-22_windows-x64_bin.zip\n+WINDOWS_X64_BOOT_JDK_SHA256=8f5138fecb53c08c20abd4fa6812f9400051f3852582a2142ffda0dff73a5824\n","filename":"make\/conf\/github-actions.conf","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -393,2 +393,2 @@\n-    common.boot_jdk_version = \"21\";\n-    common.boot_jdk_build_number = \"35\";\n+    common.boot_jdk_version = \"22\";\n+    common.boot_jdk_build_number = \"36\";\n","filename":"make\/conf\/jib-profiles.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"21 22 23\"\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"22 23\"\n","filename":"make\/conf\/version-numbers.conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,1 +217,0 @@\n-      genMarkSweep.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -166,0 +166,5 @@\n+ifeq ($(call isTargetOs, aix), true)\n+  # AIX requires a static libjli because the compiler doesn't support '-rpath'\n+  BUILD_LIBJLI_TYPE := STATIC_LIBRARY\n+endif\n+\n@@ -168,0 +173,1 @@\n+    TYPE := $(BUILD_LIBJLI_TYPE), \\\n@@ -176,1 +182,0 @@\n-    LIBS_aix := $(LIBDL),\\\n@@ -186,23 +191,0 @@\n-\n-LIBJLI_SRC_DIRS := $(call FindSrcDirsForComponent, java.base, libjli)\n-\n-ifeq ($(call isTargetOs, aix), true)\n-  # AIX also requires a static libjli because the compiler doesn't support\n-  # '-rpath'\n-  $(eval $(call SetupNativeCompilation, BUILD_LIBJLI_STATIC, \\\n-      NAME := jli_static, \\\n-      TYPE := STATIC_LIBRARY, \\\n-      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE), \\\n-      SRC := $(LIBJLI_SRC_DIRS), \\\n-      EXCLUDE_FILES := $(LIBJLI_EXCLUDE_FILES), \\\n-      EXTRA_FILES := $(LIBJLI_EXTRA_FILES), \\\n-      OPTIMIZATION := HIGH, \\\n-      CFLAGS := $(STATIC_LIBRARY_FLAGS) $(CFLAGS_JDKLIB) $(LIBJLI_CFLAGS) \\\n-          $(LIBZ_CFLAGS) $(addprefix -I, $(LIBJLI_SRC_DIRS)), \\\n-      DISABLED_WARNINGS_clang_aix := format-nonliteral \\\n-          deprecated-non-prototype, \\\n-      ARFLAGS := $(ARFLAGS), \\\n-      OBJECT_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libjli_static))\n-\n-  TARGETS += $(BUILD_LIBJLI_STATIC)\n-endif\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":6,"deletions":24,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -44,3 +44,1 @@\n-    JDK_LIBS_linux := -ljli, \\\n-    JDK_LIBS_macosx := -ljli, \\\n-    JDK_LIBS_aix := -ljli_static, \\\n+    JDK_LIBS_unix := -ljli, \\\n@@ -60,1 +58,1 @@\n-  $(BUILD_LIBINSTRUMENT): $(call FindStaticLib, java.base, jli_static)\n+  $(BUILD_LIBINSTRUMENT): $(call FindStaticLib, java.base, jli)\n","filename":"make\/modules\/java.instrument\/Lib.gmk","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+################################################################################\n+## Build libmanagement\n","filename":"make\/modules\/java.management\/Lib.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+################################################################################\n+## Build libmanagement_ext\n@@ -46,1 +48,1 @@\n-    CFLAGS := $(CFLAGS_JDKLIB) $(LIBMANAGEMENT_EXT_CFLAGS), \\\n+    CFLAGS := $(LIBMANAGEMENT_EXT_CFLAGS), \\\n","filename":"make\/modules\/jdk.management\/Lib.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,0 +97,3 @@\n+  ifeq ($(call isTargetOs, aix), true)\n+    BUILD_JDK_JTREG_EXECUTABLES_LDFLAGS_exeJliLaunchTest := -L$(SUPPORT_OUTPUTDIR)\/native\/java.base\n+  endif\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,1 +83,0 @@\n-                   notproduct,                                          \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,0 @@\n-                   notproduct,  \\\n","filename":"src\/hotspot\/cpu\/arm\/globals_arm.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,0 @@\n-                   notproduct,                                              \\\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,0 @@\n-                   notproduct,                                                   \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,0 @@\n-                   notproduct,                                                \\\n","filename":"src\/hotspot\/cpu\/s390\/globals_s390.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,1 +101,0 @@\n-                   notproduct,                                              \\\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,0 @@\n-                   notproduct,                                              \\\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-                         notproduct,                                                \\\n","filename":"src\/hotspot\/os\/aix\/globals_aix.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"logging\/log.hpp\"\n@@ -79,1 +80,1 @@\n-    trcVerbose(\"Cannot load %s (error: %s)\", libperfstat, ebuf);\n+    log_warning(os)(\"Cannot load %s (error: %s)\", libperfstat, ebuf);\n@@ -216,1 +217,1 @@\n-      trcVerbose(\"perfstat_cpu_total() failed (errno=%d)\", errno);\n+      log_warning(os)(\"perfstat_cpu_total() failed (errno=%d)\", errno);\n@@ -251,1 +252,1 @@\n-      trcVerbose(\"perfstat_partition_total() failed (errno=%d)\", errno);\n+      log_warning(os)(\"perfstat_partition_total() failed (errno=%d)\", errno);\n@@ -317,1 +318,1 @@\n-    trcVerbose(\"perfstat_wpar_total() failed (errno=%d)\", errno);\n+    log_warning(os)(\"perfstat_wpar_total() failed (errno=%d)\", errno);\n","filename":"src\/hotspot\/os\/aix\/libperfstat_aix.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -38,0 +38,1 @@\n+#include \"logging\/log.hpp\"\n@@ -197,1 +198,1 @@\n-        trcVerbose(\"loadquery failed (%d)\", errno);\n+        log_warning(os)(\"loadquery failed (%d)\", errno);\n@@ -214,1 +215,1 @@\n-      trcVerbose(\"OOM.\");\n+      log_warning(os)(\"OOM.\");\n@@ -227,1 +228,1 @@\n-      trcVerbose(\"OOM.\");\n+      log_warning(os)(\"OOM.\");\n@@ -249,1 +250,1 @@\n-        trcVerbose(\"OOM.\");\n+        log_warning(os)(\"OOM.\");\n","filename":"src\/hotspot\/os\/aix\/loadlib_aix.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -350,1 +350,1 @@\n-    trcVerbose(\"vmgetinfo(VM_PAGE_INFO) failed (errno: %d)\", errno);\n+    log_warning(pagesize)(\"vmgetinfo(VM_PAGE_INFO) failed (errno: %d)\", errno);\n@@ -445,2 +445,1 @@\n-      trcVerbose(\"vmgetinfo(VMINFO_GETPSIZES) failed (errno: %d)\", errno);\n-      trcVerbose(\"disabling multipage support.\");\n+      log_warning(pagesize)(\"vmgetinfo(VMINFO_GETPSIZES) failed (errno: %d), disabling multipage support.\", errno);\n@@ -452,1 +451,1 @@\n-    trcVerbose(\"vmgetinfo(.., VMINFO_GETPSIZES, ...) returns %d supported page sizes: \", num_psizes);\n+    log_info(pagesize)(\"vmgetinfo(.., VMINFO_GETPSIZES, ...) returns %d supported page sizes: \", num_psizes);\n@@ -474,1 +473,1 @@\n-        trcVerbose(\"shmctl(SHM_PAGESIZE) failed with errno=%d\", errno);\n+        log_warning(pagesize)(\"shmctl(SHM_PAGESIZE) failed with errno=%d\", errno);\n@@ -482,1 +481,1 @@\n-          trcVerbose(\"real page size (\" SIZE_FORMAT_X \") differs.\", real_pagesize);\n+          log_warning(pagesize)(\"real page size (\" SIZE_FORMAT_X \") differs.\", real_pagesize);\n@@ -612,1 +611,1 @@\n-    trcVerbose(\"perfstat_memory_total() failed (errno=%d)\", errno);\n+    log_warning(os)(\"perfstat_memory_total() failed (errno=%d)\", errno);\n@@ -1604,1 +1603,1 @@\n-    trcVerbose(\"my_disclaim64(\" PTR_FORMAT \", \" UINTX_FORMAT \") failed.\\n\", p2i(addr), size);\n+    log_warning(os)(\"my_disclaim64(\" PTR_FORMAT \", \" UINTX_FORMAT \") failed.\\n\", p2i(addr), size);\n@@ -1794,1 +1793,1 @@\n-  trcVerbose(\"commit_memory [\" PTR_FORMAT \" - \" PTR_FORMAT \"].\", p2i(addr), p2i(addr + size - 1));\n+  log_info(os)(\"commit_memory [\" PTR_FORMAT \" - \" PTR_FORMAT \"].\", p2i(addr), p2i(addr + size - 1));\n@@ -2174,1 +2173,1 @@\n-    trcVerbose(\"Could not change priority for thread %d to %d (error %d, %s)\",\n+    log_warning(os)(\"Could not change priority for thread %d to %d (error %d, %s)\",\n@@ -2667,1 +2666,1 @@\n-    trcVerbose(\"uname failed (%d)\", errno);\n+    log_warning(os)(\"uname failed (%d)\", errno);\n@@ -2670,1 +2669,1 @@\n-    trcVerbose(\"uname says: sysname \\\"%s\\\" version \\\"%s\\\" release \\\"%s\\\" \"\n+    log_info(os)(\"uname says: sysname \\\"%s\\\" version \\\"%s\\\" release \\\"%s\\\" \"\n@@ -2686,1 +2685,1 @@\n-        trcVerbose(\"AIX releases older than AIX 7.1 are not supported.\");\n+        log_warning(os)(\"AIX releases older than AIX 7.1 are not supported.\");\n@@ -2695,1 +2694,1 @@\n-    trcVerbose(\"We run on %s %s\", name_str, ver_str);\n+    log_info(os)(\"We run on %s %s\", name_str, ver_str);\n@@ -2720,1 +2719,1 @@\n-    trcVerbose(\"*** Unsupported mode! Please remove EXTSHM from your environment! ***\");\n+    log_warning(os)(\"*** Unsupported mode! Please remove EXTSHM from your environment! ***\");\n@@ -2744,1 +2743,1 @@\n-    trcVerbose(\"Unsupported setting: XPG_SUS_ENV=ON\");\n+    log_warning(os)(\"Unsupported setting: XPG_SUS_ENV=ON\");\n@@ -2763,1 +2762,1 @@\n-    trcVerbose(\"libperfstat initialization failed.\");\n+    log_warning(os)(\"libperfstat initialization failed.\");\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-                         notproduct,                                    \\\n","filename":"src\/hotspot\/os\/bsd\/globals_bsd.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-                         notproduct,                                    \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-                         notproduct,                                      \\\n","filename":"src\/hotspot\/os\/windows\/globals_windows.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4260,1 +4260,1 @@\n-  os::infinite_sleep();\n+  ::abort();\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  os::infinite_sleep();\n+  ::abort();\n","filename":"src\/hotspot\/os\/windows\/vmError_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,5 @@\n-\/\/    _insts._start ->              +----------------+\n+\/\/    _consts._start ->             +----------------+\n+\/\/                                  |                |\n+\/\/                                  |   Constants    |\n+\/\/                                  |                |\n+\/\/    _insts._start ->              |----------------|\n@@ -77,4 +81,0 @@\n-\/\/    _consts._start ->             |----------------|\n-\/\/                                  |                |\n-\/\/                                  |   Constants    |\n-\/\/                                  |                |\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-                 notproduct,                                                \\\n@@ -43,1 +42,1 @@\n-  notproduct(bool, PrintC1Statistics, false,                                \\\n+  develop(bool, PrintC1Statistics, false,                                   \\\n@@ -46,1 +45,1 @@\n-  notproduct(bool, PrintInitialBlockList, false,                            \\\n+  develop(bool, PrintInitialBlockList, false,                               \\\n@@ -49,1 +48,1 @@\n-  notproduct(bool, PrintCFG, false,                                         \\\n+  develop(bool, PrintCFG, false,                                            \\\n@@ -52,1 +51,1 @@\n-  notproduct(bool, PrintCFG0, false,                                        \\\n+  develop(bool, PrintCFG0, false,                                           \\\n@@ -55,1 +54,1 @@\n-  notproduct(bool, PrintCFG1, false,                                        \\\n+  develop(bool, PrintCFG1, false,                                           \\\n@@ -58,1 +57,1 @@\n-  notproduct(bool, PrintCFG2, false,                                        \\\n+  develop(bool, PrintCFG2, false,                                           \\\n@@ -61,1 +60,1 @@\n-  notproduct(bool, PrintIRDuringConstruction, false,                        \\\n+  develop(bool, PrintIRDuringConstruction, false,                           \\\n@@ -64,1 +63,1 @@\n-  notproduct(bool, PrintPhiFunctions, false,                                \\\n+  develop(bool, PrintPhiFunctions, false,                                   \\\n@@ -67,1 +66,1 @@\n-  notproduct(bool, PrintIR, false,                                          \\\n+  develop(bool, PrintIR, false,                                             \\\n@@ -70,1 +69,1 @@\n-  notproduct(bool, PrintIR0, false,                                         \\\n+  develop(bool, PrintIR0, false,                                            \\\n@@ -73,1 +72,1 @@\n-  notproduct(bool, PrintIR1, false,                                         \\\n+  develop(bool, PrintIR1, false,                                            \\\n@@ -76,1 +75,1 @@\n-  notproduct(bool, PrintIR2, false,                                         \\\n+  develop(bool, PrintIR2, false,                                            \\\n@@ -79,1 +78,1 @@\n-  notproduct(bool, PrintSimpleStubs, false,                                 \\\n+  develop(bool, PrintSimpleStubs, false,                                    \\\n@@ -191,1 +190,1 @@\n-  notproduct(bool, PrintIRWithLIR, false,                                   \\\n+  develop(bool, PrintIRWithLIR, false,                                      \\\n@@ -194,1 +193,1 @@\n-  notproduct(bool, PrintLIRWithAssembly, false,                             \\\n+  develop(bool, PrintLIRWithAssembly, false,                                \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-    check_unsupported_dumping_properties();\n+    check_unsupported_dumping_module_options();\n@@ -238,1 +238,1 @@\n-void CDSConfig::check_system_property(const char* key, const char* value) {\n+void CDSConfig::check_internal_module_property(const char* key, const char* value) {\n@@ -243,6 +243,16 @@\n-  if (strcmp(key, \"jdk.module.showModuleResolution\") == 0 ||\n-      strcmp(key, \"jdk.module.validation\") == 0 ||\n-      strcmp(key, \"java.system.class.loader\") == 0) {\n-    stop_dumping_full_module_graph();\n-    stop_using_full_module_graph();\n-    log_info(cds)(\"full module graph: disabled due to incompatible property: %s=%s\", key, value);\n+}\n+\n+void CDSConfig::check_incompatible_property(const char* key, const char* value) {\n+  static const char* incompatible_properties[] = {\n+    \"java.system.class.loader\",\n+    \"jdk.module.showModuleResolution\",\n+    \"jdk.module.validation\"\n+  };\n+\n+  for (const char* property : incompatible_properties) {\n+    if (strcmp(key, property) == 0) {\n+      stop_dumping_full_module_graph();\n+      stop_using_full_module_graph();\n+      log_info(cds)(\"full module graph: disabled due to incompatible property: %s=%s\", key, value);\n+      break;\n+    }\n@@ -250,0 +260,1 @@\n+\n@@ -252,15 +263,19 @@\n-static const char* unsupported_properties[] = {\n-  \"jdk.module.limitmods\",\n-  \"jdk.module.upgrade.path\",\n-  \"jdk.module.patch.0\"\n-};\n-static const char* unsupported_options[] = {\n-  \"--limit-modules\",\n-  \"--upgrade-module-path\",\n-  \"--patch-module\"\n-};\n-\n-void CDSConfig::check_unsupported_dumping_properties() {\n-  assert(is_dumping_archive(), \"this function is only used with CDS dump time\");\n-  assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), \"must be\");\n-  \/\/ If a vm option is found in the unsupported_options array, vm will exit with an error message.\n+\/\/ Returns any JVM command-line option, such as \"--patch-module\", that's not supported by CDS.\n+static const char* find_any_unsupported_module_option() {\n+  \/\/ Note that arguments.cpp has translated the command-line options into properties. If we find an\n+  \/\/ unsupported property, translate it back to its command-line option for better error reporting.\n+\n+  \/\/ The following properties are checked by Arguments::is_internal_module_property() and cannot be\n+  \/\/ directly specified in the command-line.\n+  static const char* unsupported_module_properties[] = {\n+    \"jdk.module.limitmods\",\n+    \"jdk.module.upgrade.path\",\n+    \"jdk.module.patch.0\"\n+  };\n+  static const char* unsupported_module_options[] = {\n+    \"--limit-modules\",\n+    \"--upgrade-module-path\",\n+    \"--patch-module\"\n+  };\n+\n+  assert(ARRAY_SIZE(unsupported_module_properties) == ARRAY_SIZE(unsupported_module_options), \"must be\");\n@@ -269,4 +284,3 @@\n-    for (uint i = 0; i < ARRAY_SIZE(unsupported_properties); i++) {\n-      if (strcmp(sp->key(), unsupported_properties[i]) == 0) {\n-        vm_exit_during_initialization(\n-          \"Cannot use the following option when dumping the shared archive\", unsupported_options[i]);\n+    for (uint i = 0; i < ARRAY_SIZE(unsupported_module_properties); i++) {\n+      if (strcmp(sp->key(), unsupported_module_properties[i]) == 0) {\n+        return unsupported_module_options[i];\n@@ -278,0 +292,9 @@\n+  return nullptr; \/\/ not found\n+}\n+\n+void CDSConfig::check_unsupported_dumping_module_options() {\n+  assert(is_dumping_archive(), \"this function is only used with CDS dump time\");\n+  const char* option = find_any_unsupported_module_option();\n+  if (option != nullptr) {\n+    vm_exit_during_initialization(\"Cannot use the following option when dumping the shared archive\", option);\n+  }\n@@ -284,1 +307,1 @@\n-bool CDSConfig::check_unsupported_cds_runtime_properties() {\n+bool CDSConfig::has_unsupported_runtime_module_options() {\n@@ -286,1 +309,0 @@\n-  assert(ARRAY_SIZE(unsupported_properties) == ARRAY_SIZE(unsupported_options), \"must be\");\n@@ -294,8 +316,6 @@\n-  for (uint i = 0; i < ARRAY_SIZE(unsupported_properties); i++) {\n-    if (Arguments::get_property(unsupported_properties[i]) != nullptr) {\n-      if (RequireSharedSpaces) {\n-        warning(\"CDS is disabled when the %s option is specified.\", unsupported_options[i]);\n-      } else {\n-        log_info(cds)(\"CDS is disabled when the %s option is specified.\", unsupported_options[i]);\n-      }\n-      return true;\n+  const char* option = find_any_unsupported_module_option();\n+  if (option != nullptr) {\n+    if (RequireSharedSpaces) {\n+      warning(\"CDS is disabled when the %s option is specified.\", option);\n+    } else {\n+      log_info(cds)(\"CDS is disabled when the %s option is specified.\", option);\n@@ -303,0 +323,1 @@\n+    return true;\n@@ -307,1 +328,1 @@\n-bool CDSConfig::check_vm_args_consistency(bool patch_mod_javabase,  bool mode_flag_cmd_line) {\n+bool CDSConfig::check_vm_args_consistency(bool patch_mod_javabase, bool mode_flag_cmd_line) {\n@@ -355,1 +376,1 @@\n-  if (UseSharedSpaces && check_unsupported_cds_runtime_properties()) {\n+  if (UseSharedSpaces && has_unsupported_runtime_module_options()) {\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":60,"deletions":39,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-  static bool check_unsupported_cds_runtime_properties();\n@@ -61,3 +60,5 @@\n-  static void check_system_property(const char* key, const char* value) NOT_CDS_RETURN;\n-  static void check_unsupported_dumping_properties() NOT_CDS_RETURN;\n-  static bool check_vm_args_consistency(bool patch_mod_javabase,  bool mode_flag_cmd_line) NOT_CDS_RETURN_(true);\n+  static void check_internal_module_property(const char* key, const char* value) NOT_CDS_RETURN;\n+  static void check_incompatible_property(const char* key, const char* value) NOT_CDS_RETURN;\n+  static void check_unsupported_dumping_module_options() NOT_CDS_RETURN;\n+  static bool has_unsupported_runtime_module_options() NOT_CDS_RETURN_(false);\n+  static bool check_vm_args_consistency(bool patch_mod_javabase, bool mode_flag_cmd_line) NOT_CDS_RETURN_(true);\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-                  notproduct,                                               \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -433,0 +433,6 @@\n+int HeapShared::archive_exception_instance(oop exception) {\n+  bool success = archive_reachable_objects_from(1, _default_subgraph_info, exception);\n+  assert(success, \"sanity\");\n+  return append_root(exception);\n+}\n+\n@@ -592,0 +598,1 @@\n+  Universe::archive_exception_instances();\n@@ -1390,5 +1397,9 @@\n-    guarantee(subgraph_k->name()->equals(\"java\/lang\/Class\") ||\n-              subgraph_k->name()->equals(\"java\/lang\/String\") ||\n-              subgraph_k->name()->equals(\"[Ljava\/lang\/Object;\") ||\n-              subgraph_k->name()->equals(\"[C\") ||\n-              subgraph_k->name()->equals(\"[B\"),\n+    Symbol* name = ArchiveBuilder::current()->get_source_addr(subgraph_k->name());\n+    guarantee(name == vmSymbols::java_lang_Class() ||\n+              name == vmSymbols::java_lang_String() ||\n+              name == vmSymbols::java_lang_ArithmeticException() ||\n+              name == vmSymbols::java_lang_NullPointerException() ||\n+              name == vmSymbols::java_lang_VirtualMachineError() ||\n+              name == vmSymbols::object_array_signature() ||\n+              name == vmSymbols::byte_array_signature() ||\n+              name == vmSymbols::char_array_signature(),\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -368,0 +368,1 @@\n+  static int archive_exception_instance(oop exception);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -654,1 +654,1 @@\n-  CDSConfig::check_unsupported_dumping_properties();\n+  CDSConfig::check_unsupported_dumping_module_options();\n@@ -1469,2 +1469,1 @@\n-\n-  CDS_JAVA_HEAP_ONLY(Universe::update_archived_basic_type_mirrors());\n+  Universe::load_archived_object_instances();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1122,12 +1122,2 @@\n-    \/\/ At CDS dump time, the --patch-module entries are ignored. That means a\n-    \/\/ class is still loaded from the runtime image even if it might\n-    \/\/ appear in the _patch_mod_entries. The runtime shared class visibility\n-    \/\/ check will determine if a shared class is visible based on the runtime\n-    \/\/ environment, including the runtime --patch-module setting.\n-    \/\/\n-    \/\/ Dynamic dumping requires UseSharedSpaces to be enabled. Since --patch-module\n-    \/\/ is not supported with UseSharedSpaces, we can never come here during dynamic dumping.\n-    assert(!CDSConfig::is_dumping_dynamic_archive(), \"sanity\");\n-    if (!CDSConfig::is_dumping_static_archive()) {\n-      stream = search_module_entries(THREAD, _patch_mod_entries, pkg_entry, file_name);\n-    }\n+    assert(!CDSConfig::is_dumping_archive(), \"CDS doesn't support --patch-module during dumping\");\n+    stream = search_module_entries(THREAD, _patch_mod_entries, pkg_entry, file_name);\n@@ -1144,0 +1134,1 @@\n+      assert(!CDSConfig::is_dumping_archive(), \"CDS dumping doesn't support exploded build\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -767,1 +767,1 @@\n-  template(decodeAndThrowThrowable_signature,          \"(IJZ)V\")                                                  \\\n+  template(decodeAndThrowThrowable_signature,          \"(IJZZ)V\")                                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1029,1 +1029,1 @@\n-    if (is_trivial(method)) {\n+    if (is_trivial(method) || method->is_native()) {\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-                       notproduct,                                          \\\n@@ -98,1 +97,1 @@\n-  notproduct(intx, CICrashAt, -1,                                           \\\n+  develop(intx, CICrashAt, -1,                                              \\\n@@ -102,1 +101,1 @@\n-  notproduct(bool, CIObjectFactoryVerify, false,                            \\\n+  develop(bool, CIObjectFactoryVerify, false,                               \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-                         notproduct,                                        \\\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilon_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1188,1 +1188,1 @@\n-  _survivors_age_table.print_age_table(_tenuring_threshold);\n+  _survivors_age_table.print_age_table();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-                                       notproduct,                          \\\n@@ -88,1 +87,0 @@\n-                                       notproduct,                          \\\n@@ -100,1 +98,0 @@\n-                    notproduct,                                             \\\n@@ -345,1 +342,0 @@\n-                    notproduct,                                             \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -136,4 +136,0 @@\n-size_t ParallelArguments::heap_max_size_bytes() {\n-  return MaxHeapSize;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  static size_t heap_max_size_bytes();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-                          notproduct,                                       \\\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallel_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1150,0 +1150,1 @@\n+    region_after_dense_prefix->set_partial_obj_addr(obj_beg);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -647,1 +647,1 @@\n-  age_table()->print_age_table(_tenuring_threshold);\n+  age_table()->print_age_table();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,544 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/stringTable.hpp\"\n-#include \"classfile\/symbolTable.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"code\/codeCache.hpp\"\n-#include \"compiler\/oopMap.hpp\"\n-#include \"gc\/serial\/cardTableRS.hpp\"\n-#include \"gc\/serial\/defNewGeneration.hpp\"\n-#include \"gc\/serial\/generation.hpp\"\n-#include \"gc\/serial\/genMarkSweep.hpp\"\n-#include \"gc\/serial\/markSweep.inline.hpp\"\n-#include \"gc\/serial\/serialGcRefProcProxyTask.hpp\"\n-#include \"gc\/serial\/serialHeap.hpp\"\n-#include \"gc\/shared\/classUnloadingContext.hpp\"\n-#include \"gc\/shared\/collectedHeap.inline.hpp\"\n-#include \"gc\/shared\/gcHeapSummary.hpp\"\n-#include \"gc\/shared\/gcTimer.hpp\"\n-#include \"gc\/shared\/gcTrace.hpp\"\n-#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n-#include \"gc\/shared\/modRefBarrierSet.hpp\"\n-#include \"gc\/shared\/preservedMarks.inline.hpp\"\n-#include \"gc\/shared\/referencePolicy.hpp\"\n-#include \"gc\/shared\/referenceProcessorPhaseTimes.hpp\"\n-#include \"gc\/shared\/space.inline.hpp\"\n-#include \"gc\/shared\/strongRootsScope.hpp\"\n-#include \"gc\/shared\/weakProcessor.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"oops\/instanceRefKlass.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"prims\/jvmtiExport.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/prefetch.inline.hpp\"\n-#include \"runtime\/synchronizer.hpp\"\n-#include \"runtime\/vmThread.hpp\"\n-#include \"utilities\/copy.hpp\"\n-#include \"utilities\/events.hpp\"\n-#include \"utilities\/stack.inline.hpp\"\n-#if INCLUDE_JVMCI\n-#include \"jvmci\/jvmci.hpp\"\n-#endif\n-\n-class DeadSpacer : StackObj {\n-  size_t _allowed_deadspace_words;\n-  bool _active;\n-  ContiguousSpace* _space;\n-\n-public:\n-  DeadSpacer(ContiguousSpace* space) : _allowed_deadspace_words(0), _space(space) {\n-    size_t ratio = _space->allowed_dead_ratio();\n-    _active = ratio > 0;\n-\n-    if (_active) {\n-      \/\/ We allow some amount of garbage towards the bottom of the space, so\n-      \/\/ we don't start compacting before there is a significant gain to be made.\n-      \/\/ Occasionally, we want to ensure a full compaction, which is determined\n-      \/\/ by the MarkSweepAlwaysCompactCount parameter.\n-      if ((MarkSweep::total_invocations() % MarkSweepAlwaysCompactCount) != 0) {\n-        _allowed_deadspace_words = (space->capacity() * ratio \/ 100) \/ HeapWordSize;\n-      } else {\n-        _active = false;\n-      }\n-    }\n-  }\n-\n-  bool insert_deadspace(HeapWord* dead_start, HeapWord* dead_end) {\n-    if (!_active) {\n-      return false;\n-    }\n-\n-    size_t dead_length = pointer_delta(dead_end, dead_start);\n-    if (_allowed_deadspace_words >= dead_length) {\n-      _allowed_deadspace_words -= dead_length;\n-      CollectedHeap::fill_with_object(dead_start, dead_length);\n-      oop obj = cast_to_oop(dead_start);\n-      \/\/ obj->set_mark(obj->mark().set_marked());\n-\n-      assert(dead_length == obj->size(), \"bad filler object size\");\n-      log_develop_trace(gc, compaction)(\"Inserting object to dead space: \" PTR_FORMAT \", \" PTR_FORMAT \", \" SIZE_FORMAT \"b\",\n-                                        p2i(dead_start), p2i(dead_end), dead_length * HeapWordSize);\n-\n-      return true;\n-    } else {\n-      _active = false;\n-      return false;\n-    }\n-  }\n-};\n-\n-\/\/ Implement the \"compaction\" part of the mark-compact GC algorithm.\n-class Compacter {\n-  \/\/ There are four spaces in total, but only the first three can be used after\n-  \/\/ compact. IOW, old and eden\/from must be enough for all live objs\n-  static constexpr uint max_num_spaces = 4;\n-\n-  struct CompactionSpace {\n-    ContiguousSpace* _space;\n-    \/\/ Will be the new top after compaction is complete.\n-    HeapWord* _compaction_top;\n-    \/\/ The first dead word in this contiguous space. It's an optimization to\n-    \/\/ skip large chunk of live objects at the beginning.\n-    HeapWord* _first_dead;\n-\n-    void init(ContiguousSpace* space) {\n-      _space = space;\n-      _compaction_top = space->bottom();\n-      _first_dead = nullptr;\n-    }\n-  };\n-\n-  CompactionSpace _spaces[max_num_spaces];\n-  \/\/ The num of spaces to be compacted, i.e. containing live objs.\n-  uint _num_spaces;\n-\n-  uint _index;\n-\n-  HeapWord* get_compaction_top(uint index) const {\n-    return _spaces[index]._compaction_top;\n-  }\n-\n-  HeapWord* get_first_dead(uint index) const {\n-    return _spaces[index]._first_dead;\n-  }\n-\n-  ContiguousSpace* get_space(uint index) const {\n-    return _spaces[index]._space;\n-  }\n-\n-  void record_first_dead(uint index, HeapWord* first_dead) {\n-    assert(_spaces[index]._first_dead == nullptr, \"should write only once\");\n-    _spaces[index]._first_dead = first_dead;\n-  }\n-\n-  HeapWord* alloc(size_t words) {\n-    while (true) {\n-      if (words <= pointer_delta(_spaces[_index]._space->end(),\n-                                 _spaces[_index]._compaction_top)) {\n-        HeapWord* result = _spaces[_index]._compaction_top;\n-        _spaces[_index]._compaction_top += words;\n-        if (_index == 0) {\n-          \/\/ old-gen requires BOT update\n-          static_cast<TenuredSpace*>(_spaces[0]._space)->update_for_block(result, result + words);\n-        }\n-        return result;\n-      }\n-\n-      \/\/ out-of-memory in this space\n-      _index++;\n-      assert(_index < max_num_spaces - 1, \"the last space should not be used\");\n-    }\n-  }\n-\n-  static void prefetch_read_scan(void* p) {\n-    if (PrefetchScanIntervalInBytes >= 0) {\n-      Prefetch::read(p, PrefetchScanIntervalInBytes);\n-    }\n-  }\n-\n-  static void prefetch_write_scan(void* p) {\n-    if (PrefetchScanIntervalInBytes >= 0) {\n-      Prefetch::write(p, PrefetchScanIntervalInBytes);\n-    }\n-  }\n-\n-  static void prefetch_write_copy(void* p) {\n-    if (PrefetchCopyIntervalInBytes >= 0) {\n-      Prefetch::write(p, PrefetchCopyIntervalInBytes);\n-    }\n-  }\n-\n-  static void forward_obj(oop obj, HeapWord* new_addr) {\n-    prefetch_write_scan(obj);\n-    if (cast_from_oop<HeapWord*>(obj) != new_addr) {\n-      obj->forward_to(cast_to_oop(new_addr));\n-    } else {\n-      assert(obj->is_gc_marked(), \"inv\");\n-      \/\/ This obj will stay in-place. Fix the markword.\n-      obj->init_mark();\n-    }\n-  }\n-\n-  static HeapWord* find_next_live_addr(HeapWord* start, HeapWord* end) {\n-    for (HeapWord* i_addr = start; i_addr < end; \/* empty *\/) {\n-      prefetch_read_scan(i_addr);\n-      oop obj = cast_to_oop(i_addr);\n-      if (obj->is_gc_marked()) {\n-        return i_addr;\n-      }\n-      i_addr += obj->size();\n-    }\n-    return end;\n-  };\n-\n-  static size_t relocate(HeapWord* addr) {\n-    \/\/ Prefetch source and destination\n-    prefetch_read_scan(addr);\n-\n-    oop obj = cast_to_oop(addr);\n-    oop new_obj = obj->forwardee();\n-    HeapWord* new_addr = cast_from_oop<HeapWord*>(new_obj);\n-    assert(addr != new_addr, \"inv\");\n-    prefetch_write_copy(new_addr);\n-\n-    size_t obj_size = obj->size();\n-    Copy::aligned_conjoint_words(addr, new_addr, obj_size);\n-    new_obj->init_mark();\n-\n-    return obj_size;\n-  }\n-\n-public:\n-  explicit Compacter(SerialHeap* heap) {\n-    \/\/ In this order so that heap is compacted towards old-gen.\n-    _spaces[0].init(heap->old_gen()->space());\n-    _spaces[1].init(heap->young_gen()->eden());\n-    _spaces[2].init(heap->young_gen()->from());\n-\n-    bool is_promotion_failed = (heap->young_gen()->from()->next_compaction_space() != nullptr);\n-    if (is_promotion_failed) {\n-      _spaces[3].init(heap->young_gen()->to());\n-      _num_spaces = 4;\n-    } else {\n-      _num_spaces = 3;\n-    }\n-    _index = 0;\n-  }\n-\n-  void phase2_calculate_new_addr() {\n-    for (uint i = 0; i < _num_spaces; ++i) {\n-      ContiguousSpace* space = get_space(i);\n-      HeapWord* cur_addr = space->bottom();\n-      HeapWord* top = space->top();\n-\n-      bool record_first_dead_done = false;\n-\n-      DeadSpacer dead_spacer(space);\n-\n-      while (cur_addr < top) {\n-        oop obj = cast_to_oop(cur_addr);\n-        size_t obj_size = obj->size();\n-        if (obj->is_gc_marked()) {\n-          HeapWord* new_addr = alloc(obj_size);\n-          forward_obj(obj, new_addr);\n-          cur_addr += obj_size;\n-        } else {\n-          \/\/ Skipping the current known-unmarked obj\n-          HeapWord* next_live_addr = find_next_live_addr(cur_addr + obj_size, top);\n-          if (dead_spacer.insert_deadspace(cur_addr, next_live_addr)) {\n-            \/\/ Register space for the filler obj\n-            alloc(pointer_delta(next_live_addr, cur_addr));\n-          } else {\n-            if (!record_first_dead_done) {\n-              record_first_dead(i, cur_addr);\n-              record_first_dead_done = true;\n-            }\n-            *(HeapWord**)cur_addr = next_live_addr;\n-          }\n-          cur_addr = next_live_addr;\n-        }\n-      }\n-\n-      if (!record_first_dead_done) {\n-        record_first_dead(i, top);\n-      }\n-    }\n-  }\n-\n-  void phase3_adjust_pointers() {\n-    for (uint i = 0; i < _num_spaces; ++i) {\n-      ContiguousSpace* space = get_space(i);\n-      HeapWord* cur_addr = space->bottom();\n-      HeapWord* const top = space->top();\n-      HeapWord* const first_dead = get_first_dead(i);\n-\n-      while (cur_addr < top) {\n-        prefetch_write_scan(cur_addr);\n-        if (cur_addr < first_dead || cast_to_oop(cur_addr)->is_gc_marked()) {\n-          size_t size = MarkSweep::adjust_pointers(cast_to_oop(cur_addr));\n-          cur_addr += size;\n-        } else {\n-          assert(*(HeapWord**)cur_addr > cur_addr, \"forward progress\");\n-          cur_addr = *(HeapWord**)cur_addr;\n-        }\n-      }\n-    }\n-  }\n-\n-  void phase4_compact() {\n-    for (uint i = 0; i < _num_spaces; ++i) {\n-      ContiguousSpace* space = get_space(i);\n-      HeapWord* cur_addr = space->bottom();\n-      HeapWord* top = space->top();\n-\n-      \/\/ Check if the first obj inside this space is forwarded.\n-      if (!cast_to_oop(cur_addr)->is_forwarded()) {\n-        \/\/ Jump over consecutive (in-place) live-objs-chunk\n-        cur_addr = get_first_dead(i);\n-      }\n-\n-      while (cur_addr < top) {\n-        if (!cast_to_oop(cur_addr)->is_forwarded()) {\n-          cur_addr = *(HeapWord**) cur_addr;\n-          continue;\n-        }\n-        cur_addr += relocate(cur_addr);\n-      }\n-\n-      \/\/ Reset top and unused memory\n-      space->set_top(get_compaction_top(i));\n-      if (ZapUnusedHeapArea) {\n-        space->mangle_unused_area();\n-      }\n-    }\n-  }\n-};\n-\n-void GenMarkSweep::phase1_mark(bool clear_all_softrefs) {\n-  \/\/ Recursively traverse all live objects and mark them\n-  GCTraceTime(Info, gc, phases) tm(\"Phase 1: Mark live objects\", _gc_timer);\n-\n-  SerialHeap* gch = SerialHeap::heap();\n-\n-  ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_mark);\n-\n-  ref_processor()->start_discovery(clear_all_softrefs);\n-\n-  {\n-    StrongRootsScope srs(0);\n-\n-    CLDClosure* weak_cld_closure = ClassUnloading ? nullptr : &follow_cld_closure;\n-    MarkingCodeBlobClosure mark_code_closure(&follow_root_closure, !CodeBlobToOopClosure::FixRelocations, true);\n-    gch->process_roots(SerialHeap::SO_None,\n-                       &follow_root_closure,\n-                       &follow_cld_closure,\n-                       weak_cld_closure,\n-                       &mark_code_closure);\n-  }\n-\n-  \/\/ Process reference objects found during marking\n-  {\n-    GCTraceTime(Debug, gc, phases) tm_m(\"Reference Processing\", gc_timer());\n-\n-    ReferenceProcessorPhaseTimes pt(_gc_timer, ref_processor()->max_num_queues());\n-    SerialGCRefProcProxyTask task(is_alive, keep_alive, follow_stack_closure);\n-    const ReferenceProcessorStats& stats = ref_processor()->process_discovered_references(task, pt);\n-    pt.print_all_references();\n-    gc_tracer()->report_gc_reference_stats(stats);\n-  }\n-\n-  \/\/ This is the point where the entire marking should have completed.\n-  assert(_marking_stack.is_empty(), \"Marking should have completed\");\n-\n-  {\n-    GCTraceTime(Debug, gc, phases) tm_m(\"Weak Processing\", gc_timer());\n-    WeakProcessor::weak_oops_do(&is_alive, &do_nothing_cl);\n-  }\n-\n-  {\n-    GCTraceTime(Debug, gc, phases) tm_m(\"Class Unloading\", gc_timer());\n-\n-    ClassUnloadingContext* ctx = ClassUnloadingContext::context();\n-\n-    bool unloading_occurred;\n-    {\n-      CodeCache::UnlinkingScope scope(&is_alive);\n-\n-      \/\/ Unload classes and purge the SystemDictionary.\n-      unloading_occurred = SystemDictionary::do_unloading(gc_timer());\n-\n-      \/\/ Unload nmethods.\n-      CodeCache::do_unloading(unloading_occurred);\n-    }\n-\n-    {\n-      GCTraceTime(Debug, gc, phases) t(\"Purge Unlinked NMethods\", gc_timer());\n-      \/\/ Release unloaded nmethod's memory.\n-      ctx->purge_nmethods();\n-    }\n-    {\n-      GCTraceTime(Debug, gc, phases) ur(\"Unregister NMethods\", gc_timer());\n-      gch->prune_unlinked_nmethods();\n-    }\n-    {\n-      GCTraceTime(Debug, gc, phases) t(\"Free Code Blobs\", gc_timer());\n-      ctx->free_code_blobs();\n-    }\n-\n-    \/\/ Prune dead klasses from subklass\/sibling\/implementor lists.\n-    Klass::clean_weak_klass_links(unloading_occurred);\n-\n-    \/\/ Clean JVMCI metadata handles.\n-    JVMCI_ONLY(JVMCI::do_unloading(unloading_occurred));\n-  }\n-\n-  {\n-    GCTraceTime(Debug, gc, phases) tm_m(\"Report Object Count\", gc_timer());\n-    gc_tracer()->report_object_count_after_gc(&is_alive, nullptr);\n-  }\n-}\n-\n-void GenMarkSweep::invoke_at_safepoint(bool clear_all_softrefs) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n-\n-  SerialHeap* gch = SerialHeap::heap();\n-#ifdef ASSERT\n-  if (gch->soft_ref_policy()->should_clear_all_soft_refs()) {\n-    assert(clear_all_softrefs, \"Policy should have been checked earlier\");\n-  }\n-#endif\n-\n-  gch->trace_heap_before_gc(_gc_tracer);\n-\n-  \/\/ Increment the invocation count\n-  _total_invocations++;\n-\n-  \/\/ Capture used regions for old-gen to reestablish old-to-young invariant\n-  \/\/ after full-gc.\n-  gch->old_gen()->save_used_region();\n-\n-  allocate_stacks();\n-\n-  phase1_mark(clear_all_softrefs);\n-\n-  Compacter compacter{gch};\n-\n-  {\n-    \/\/ Now all live objects are marked, compute the new object addresses.\n-    GCTraceTime(Info, gc, phases) tm(\"Phase 2: Compute new object addresses\", _gc_timer);\n-\n-    compacter.phase2_calculate_new_addr();\n-  }\n-\n-  \/\/ Don't add any more derived pointers during phase3\n-#if COMPILER2_OR_JVMCI\n-  assert(DerivedPointerTable::is_active(), \"Sanity\");\n-  DerivedPointerTable::set_active(false);\n-#endif\n-\n-  {\n-    \/\/ Adjust the pointers to reflect the new locations\n-    GCTraceTime(Info, gc, phases) tm(\"Phase 3: Adjust pointers\", gc_timer());\n-\n-    ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_adjust);\n-\n-    CodeBlobToOopClosure code_closure(&adjust_pointer_closure, CodeBlobToOopClosure::FixRelocations);\n-    gch->process_roots(SerialHeap::SO_AllCodeCache,\n-                       &adjust_pointer_closure,\n-                       &adjust_cld_closure,\n-                       &adjust_cld_closure,\n-                       &code_closure);\n-\n-    WeakProcessor::oops_do(&adjust_pointer_closure);\n-\n-    adjust_marks();\n-    compacter.phase3_adjust_pointers();\n-  }\n-\n-  {\n-    \/\/ All pointers are now adjusted, move objects accordingly\n-    GCTraceTime(Info, gc, phases) tm(\"Phase 4: Move objects\", _gc_timer);\n-\n-    compacter.phase4_compact();\n-  }\n-\n-  restore_marks();\n-\n-  \/\/ Set saved marks for allocation profiler (and other things? -- dld)\n-  \/\/ (Should this be in general part?)\n-  gch->save_marks();\n-\n-  deallocate_stacks();\n-\n-  MarkSweep::_string_dedup_requests->flush();\n-\n-  bool is_young_gen_empty = (gch->young_gen()->used() == 0);\n-  gch->rem_set()->maintain_old_to_young_invariant(gch->old_gen(), is_young_gen_empty);\n-\n-  gch->prune_scavengable_nmethods();\n-\n-  \/\/ Update heap occupancy information which is used as\n-  \/\/ input to soft ref clearing policy at the next gc.\n-  Universe::heap()->update_capacity_and_used_at_gc();\n-\n-  \/\/ Signal that we have completed a visit to all live objects.\n-  Universe::heap()->record_whole_heap_examined_timestamp();\n-\n-  gch->trace_heap_after_gc(_gc_tracer);\n-}\n-\n-void GenMarkSweep::allocate_stacks() {\n-  void* scratch = nullptr;\n-  size_t num_words;\n-  DefNewGeneration* young_gen = (DefNewGeneration*)SerialHeap::heap()->young_gen();\n-  young_gen->contribute_scratch(scratch, num_words);\n-\n-  if (scratch != nullptr) {\n-    _preserved_count_max = num_words * HeapWordSize \/ sizeof(PreservedMark);\n-  } else {\n-    _preserved_count_max = 0;\n-  }\n-\n-  _preserved_marks = (PreservedMark*)scratch;\n-  _preserved_count = 0;\n-\n-  _preserved_overflow_stack_set.init(1);\n-}\n-\n-void GenMarkSweep::deallocate_stacks() {\n-  if (_preserved_count_max != 0) {\n-    DefNewGeneration* young_gen = (DefNewGeneration*)SerialHeap::heap()->young_gen();\n-    young_gen->reset_scratch();\n-  }\n-\n-  _preserved_overflow_stack_set.reclaim();\n-  _marking_stack.clear();\n-  _objarray_stack.clear(true);\n-}\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":0,"deletions":544,"binary":false,"changes":544,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SERIAL_GENMARKSWEEP_HPP\n-#define SHARE_GC_SERIAL_GENMARKSWEEP_HPP\n-\n-#include \"gc\/serial\/markSweep.hpp\"\n-\n-class GenMarkSweep : public MarkSweep {\n- public:\n-  static void invoke_at_safepoint(bool clear_all_softrefs);\n-\n- private:\n-  \/\/ Mark live objects\n-  static void phase1_mark(bool clear_all_softrefs);\n-\n-  \/\/ Temporary data structures for traversal and storing\/restoring marks\n-  static void allocate_stacks();\n-  static void deallocate_stacks();\n-};\n-\n-#endif \/\/ SHARE_GC_SERIAL_GENMARKSWEEP_HPP\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.hpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,7 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/stringTable.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"code\/codeCache.hpp\"\n@@ -27,0 +34,3 @@\n+#include \"compiler\/oopMap.hpp\"\n+#include \"gc\/serial\/cardTableRS.hpp\"\n+#include \"gc\/serial\/defNewGeneration.hpp\"\n@@ -28,0 +38,3 @@\n+#include \"gc\/serial\/serialGcRefProcProxyTask.hpp\"\n+#include \"gc\/serial\/serialHeap.hpp\"\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -29,0 +42,1 @@\n+#include \"gc\/shared\/gcHeapSummary.hpp\"\n@@ -31,0 +45,1 @@\n+#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n@@ -32,0 +47,6 @@\n+#include \"gc\/shared\/modRefBarrierSet.hpp\"\n+#include \"gc\/shared\/referencePolicy.hpp\"\n+#include \"gc\/shared\/referenceProcessorPhaseTimes.hpp\"\n+#include \"gc\/shared\/space.inline.hpp\"\n+#include \"gc\/shared\/strongRootsScope.hpp\"\n+#include \"gc\/shared\/weakProcessor.hpp\"\n@@ -36,0 +57,1 @@\n+#include \"oops\/instanceRefKlass.hpp\"\n@@ -40,0 +62,3 @@\n+#include \"runtime\/prefetch.inline.hpp\"\n+#include \"utilities\/copy.hpp\"\n+#include \"utilities\/events.hpp\"\n@@ -41,0 +66,3 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmci.hpp\"\n+#endif\n@@ -65,0 +93,274 @@\n+class DeadSpacer : StackObj {\n+  size_t _allowed_deadspace_words;\n+  bool _active;\n+  ContiguousSpace* _space;\n+\n+public:\n+  DeadSpacer(ContiguousSpace* space) : _allowed_deadspace_words(0), _space(space) {\n+    size_t ratio = _space->allowed_dead_ratio();\n+    _active = ratio > 0;\n+\n+    if (_active) {\n+      \/\/ We allow some amount of garbage towards the bottom of the space, so\n+      \/\/ we don't start compacting before there is a significant gain to be made.\n+      \/\/ Occasionally, we want to ensure a full compaction, which is determined\n+      \/\/ by the MarkSweepAlwaysCompactCount parameter.\n+      if ((MarkSweep::total_invocations() % MarkSweepAlwaysCompactCount) != 0) {\n+        _allowed_deadspace_words = (space->capacity() * ratio \/ 100) \/ HeapWordSize;\n+      } else {\n+        _active = false;\n+      }\n+    }\n+  }\n+\n+  bool insert_deadspace(HeapWord* dead_start, HeapWord* dead_end) {\n+    if (!_active) {\n+      return false;\n+    }\n+\n+    size_t dead_length = pointer_delta(dead_end, dead_start);\n+    if (_allowed_deadspace_words >= dead_length) {\n+      _allowed_deadspace_words -= dead_length;\n+      CollectedHeap::fill_with_object(dead_start, dead_length);\n+      oop obj = cast_to_oop(dead_start);\n+      \/\/ obj->set_mark(obj->mark().set_marked());\n+\n+      assert(dead_length == obj->size(), \"bad filler object size\");\n+      log_develop_trace(gc, compaction)(\"Inserting object to dead space: \" PTR_FORMAT \", \" PTR_FORMAT \", \" SIZE_FORMAT \"b\",\n+                                        p2i(dead_start), p2i(dead_end), dead_length * HeapWordSize);\n+\n+      return true;\n+    } else {\n+      _active = false;\n+      return false;\n+    }\n+  }\n+};\n+\n+\/\/ Implement the \"compaction\" part of the mark-compact GC algorithm.\n+class Compacter {\n+  \/\/ There are four spaces in total, but only the first three can be used after\n+  \/\/ compact. IOW, old and eden\/from must be enough for all live objs\n+  static constexpr uint max_num_spaces = 4;\n+\n+  struct CompactionSpace {\n+    ContiguousSpace* _space;\n+    \/\/ Will be the new top after compaction is complete.\n+    HeapWord* _compaction_top;\n+    \/\/ The first dead word in this contiguous space. It's an optimization to\n+    \/\/ skip large chunk of live objects at the beginning.\n+    HeapWord* _first_dead;\n+\n+    void init(ContiguousSpace* space) {\n+      _space = space;\n+      _compaction_top = space->bottom();\n+      _first_dead = nullptr;\n+    }\n+  };\n+\n+  CompactionSpace _spaces[max_num_spaces];\n+  \/\/ The num of spaces to be compacted, i.e. containing live objs.\n+  uint _num_spaces;\n+\n+  uint _index;\n+\n+  HeapWord* get_compaction_top(uint index) const {\n+    return _spaces[index]._compaction_top;\n+  }\n+\n+  HeapWord* get_first_dead(uint index) const {\n+    return _spaces[index]._first_dead;\n+  }\n+\n+  ContiguousSpace* get_space(uint index) const {\n+    return _spaces[index]._space;\n+  }\n+\n+  void record_first_dead(uint index, HeapWord* first_dead) {\n+    assert(_spaces[index]._first_dead == nullptr, \"should write only once\");\n+    _spaces[index]._first_dead = first_dead;\n+  }\n+\n+  HeapWord* alloc(size_t words) {\n+    while (true) {\n+      if (words <= pointer_delta(_spaces[_index]._space->end(),\n+                                 _spaces[_index]._compaction_top)) {\n+        HeapWord* result = _spaces[_index]._compaction_top;\n+        _spaces[_index]._compaction_top += words;\n+        if (_index == 0) {\n+          \/\/ old-gen requires BOT update\n+          static_cast<TenuredSpace*>(_spaces[0]._space)->update_for_block(result, result + words);\n+        }\n+        return result;\n+      }\n+\n+      \/\/ out-of-memory in this space\n+      _index++;\n+      assert(_index < max_num_spaces - 1, \"the last space should not be used\");\n+    }\n+  }\n+\n+  static void prefetch_read_scan(void* p) {\n+    if (PrefetchScanIntervalInBytes >= 0) {\n+      Prefetch::read(p, PrefetchScanIntervalInBytes);\n+    }\n+  }\n+\n+  static void prefetch_write_scan(void* p) {\n+    if (PrefetchScanIntervalInBytes >= 0) {\n+      Prefetch::write(p, PrefetchScanIntervalInBytes);\n+    }\n+  }\n+\n+  static void prefetch_write_copy(void* p) {\n+    if (PrefetchCopyIntervalInBytes >= 0) {\n+      Prefetch::write(p, PrefetchCopyIntervalInBytes);\n+    }\n+  }\n+\n+  static void forward_obj(oop obj, HeapWord* new_addr) {\n+    prefetch_write_scan(obj);\n+    if (cast_from_oop<HeapWord*>(obj) != new_addr) {\n+      obj->forward_to(cast_to_oop(new_addr));\n+    } else {\n+      assert(obj->is_gc_marked(), \"inv\");\n+      \/\/ This obj will stay in-place. Fix the markword.\n+      obj->init_mark();\n+    }\n+  }\n+\n+  static HeapWord* find_next_live_addr(HeapWord* start, HeapWord* end) {\n+    for (HeapWord* i_addr = start; i_addr < end; \/* empty *\/) {\n+      prefetch_read_scan(i_addr);\n+      oop obj = cast_to_oop(i_addr);\n+      if (obj->is_gc_marked()) {\n+        return i_addr;\n+      }\n+      i_addr += obj->size();\n+    }\n+    return end;\n+  };\n+\n+  static size_t relocate(HeapWord* addr) {\n+    \/\/ Prefetch source and destination\n+    prefetch_read_scan(addr);\n+\n+    oop obj = cast_to_oop(addr);\n+    oop new_obj = obj->forwardee();\n+    HeapWord* new_addr = cast_from_oop<HeapWord*>(new_obj);\n+    assert(addr != new_addr, \"inv\");\n+    prefetch_write_copy(new_addr);\n+\n+    size_t obj_size = obj->size();\n+    Copy::aligned_conjoint_words(addr, new_addr, obj_size);\n+    new_obj->init_mark();\n+\n+    return obj_size;\n+  }\n+\n+public:\n+  explicit Compacter(SerialHeap* heap) {\n+    \/\/ In this order so that heap is compacted towards old-gen.\n+    _spaces[0].init(heap->old_gen()->space());\n+    _spaces[1].init(heap->young_gen()->eden());\n+    _spaces[2].init(heap->young_gen()->from());\n+\n+    bool is_promotion_failed = (heap->young_gen()->from()->next_compaction_space() != nullptr);\n+    if (is_promotion_failed) {\n+      _spaces[3].init(heap->young_gen()->to());\n+      _num_spaces = 4;\n+    } else {\n+      _num_spaces = 3;\n+    }\n+    _index = 0;\n+  }\n+\n+  void phase2_calculate_new_addr() {\n+    for (uint i = 0; i < _num_spaces; ++i) {\n+      ContiguousSpace* space = get_space(i);\n+      HeapWord* cur_addr = space->bottom();\n+      HeapWord* top = space->top();\n+\n+      bool record_first_dead_done = false;\n+\n+      DeadSpacer dead_spacer(space);\n+\n+      while (cur_addr < top) {\n+        oop obj = cast_to_oop(cur_addr);\n+        size_t obj_size = obj->size();\n+        if (obj->is_gc_marked()) {\n+          HeapWord* new_addr = alloc(obj_size);\n+          forward_obj(obj, new_addr);\n+          cur_addr += obj_size;\n+        } else {\n+          \/\/ Skipping the current known-unmarked obj\n+          HeapWord* next_live_addr = find_next_live_addr(cur_addr + obj_size, top);\n+          if (dead_spacer.insert_deadspace(cur_addr, next_live_addr)) {\n+            \/\/ Register space for the filler obj\n+            alloc(pointer_delta(next_live_addr, cur_addr));\n+          } else {\n+            if (!record_first_dead_done) {\n+              record_first_dead(i, cur_addr);\n+              record_first_dead_done = true;\n+            }\n+            *(HeapWord**)cur_addr = next_live_addr;\n+          }\n+          cur_addr = next_live_addr;\n+        }\n+      }\n+\n+      if (!record_first_dead_done) {\n+        record_first_dead(i, top);\n+      }\n+    }\n+  }\n+\n+  void phase3_adjust_pointers() {\n+    for (uint i = 0; i < _num_spaces; ++i) {\n+      ContiguousSpace* space = get_space(i);\n+      HeapWord* cur_addr = space->bottom();\n+      HeapWord* const top = space->top();\n+      HeapWord* const first_dead = get_first_dead(i);\n+\n+      while (cur_addr < top) {\n+        prefetch_write_scan(cur_addr);\n+        if (cur_addr < first_dead || cast_to_oop(cur_addr)->is_gc_marked()) {\n+          size_t size = MarkSweep::adjust_pointers(cast_to_oop(cur_addr));\n+          cur_addr += size;\n+        } else {\n+          assert(*(HeapWord**)cur_addr > cur_addr, \"forward progress\");\n+          cur_addr = *(HeapWord**)cur_addr;\n+        }\n+      }\n+    }\n+  }\n+\n+  void phase4_compact() {\n+    for (uint i = 0; i < _num_spaces; ++i) {\n+      ContiguousSpace* space = get_space(i);\n+      HeapWord* cur_addr = space->bottom();\n+      HeapWord* top = space->top();\n+\n+      \/\/ Check if the first obj inside this space is forwarded.\n+      if (!cast_to_oop(cur_addr)->is_forwarded()) {\n+        \/\/ Jump over consecutive (in-place) live-objs-chunk\n+        cur_addr = get_first_dead(i);\n+      }\n+\n+      while (cur_addr < top) {\n+        if (!cast_to_oop(cur_addr)->is_forwarded()) {\n+          cur_addr = *(HeapWord**) cur_addr;\n+          continue;\n+        }\n+        cur_addr += relocate(cur_addr);\n+      }\n+\n+      \/\/ Reset top and unused memory\n+      space->set_top(get_compaction_top(i));\n+      if (ZapUnusedHeapArea) {\n+        space->mangle_unused_area();\n+      }\n+    }\n+  }\n+};\n+\n@@ -160,0 +462,113 @@\n+void MarkSweep::phase1_mark(bool clear_all_softrefs) {\n+  \/\/ Recursively traverse all live objects and mark them\n+  GCTraceTime(Info, gc, phases) tm(\"Phase 1: Mark live objects\", _gc_timer);\n+\n+  SerialHeap* gch = SerialHeap::heap();\n+\n+  ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_mark);\n+\n+  ref_processor()->start_discovery(clear_all_softrefs);\n+\n+  {\n+    StrongRootsScope srs(0);\n+\n+    CLDClosure* weak_cld_closure = ClassUnloading ? nullptr : &follow_cld_closure;\n+    MarkingCodeBlobClosure mark_code_closure(&follow_root_closure, !CodeBlobToOopClosure::FixRelocations, true);\n+    gch->process_roots(SerialHeap::SO_None,\n+                       &follow_root_closure,\n+                       &follow_cld_closure,\n+                       weak_cld_closure,\n+                       &mark_code_closure);\n+  }\n+\n+  \/\/ Process reference objects found during marking\n+  {\n+    GCTraceTime(Debug, gc, phases) tm_m(\"Reference Processing\", gc_timer());\n+\n+    ReferenceProcessorPhaseTimes pt(_gc_timer, ref_processor()->max_num_queues());\n+    SerialGCRefProcProxyTask task(is_alive, keep_alive, follow_stack_closure);\n+    const ReferenceProcessorStats& stats = ref_processor()->process_discovered_references(task, pt);\n+    pt.print_all_references();\n+    gc_tracer()->report_gc_reference_stats(stats);\n+  }\n+\n+  \/\/ This is the point where the entire marking should have completed.\n+  assert(_marking_stack.is_empty(), \"Marking should have completed\");\n+\n+  {\n+    GCTraceTime(Debug, gc, phases) tm_m(\"Weak Processing\", gc_timer());\n+    WeakProcessor::weak_oops_do(&is_alive, &do_nothing_cl);\n+  }\n+\n+  {\n+    GCTraceTime(Debug, gc, phases) tm_m(\"Class Unloading\", gc_timer());\n+\n+    ClassUnloadingContext* ctx = ClassUnloadingContext::context();\n+\n+    bool unloading_occurred;\n+    {\n+      CodeCache::UnlinkingScope scope(&is_alive);\n+\n+      \/\/ Unload classes and purge the SystemDictionary.\n+      unloading_occurred = SystemDictionary::do_unloading(gc_timer());\n+\n+      \/\/ Unload nmethods.\n+      CodeCache::do_unloading(unloading_occurred);\n+    }\n+\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Purge Unlinked NMethods\", gc_timer());\n+      \/\/ Release unloaded nmethod's memory.\n+      ctx->purge_nmethods();\n+    }\n+    {\n+      GCTraceTime(Debug, gc, phases) ur(\"Unregister NMethods\", gc_timer());\n+      gch->prune_unlinked_nmethods();\n+    }\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Free Code Blobs\", gc_timer());\n+      ctx->free_code_blobs();\n+    }\n+\n+    \/\/ Prune dead klasses from subklass\/sibling\/implementor lists.\n+    Klass::clean_weak_klass_links(unloading_occurred);\n+\n+    \/\/ Clean JVMCI metadata handles.\n+    JVMCI_ONLY(JVMCI::do_unloading(unloading_occurred));\n+  }\n+\n+  {\n+    GCTraceTime(Debug, gc, phases) tm_m(\"Report Object Count\", gc_timer());\n+    gc_tracer()->report_object_count_after_gc(&is_alive, nullptr);\n+  }\n+}\n+\n+void MarkSweep::allocate_stacks() {\n+  void* scratch = nullptr;\n+  size_t num_words;\n+  DefNewGeneration* young_gen = (DefNewGeneration*)SerialHeap::heap()->young_gen();\n+  young_gen->contribute_scratch(scratch, num_words);\n+\n+  if (scratch != nullptr) {\n+    _preserved_count_max = num_words * HeapWordSize \/ sizeof(PreservedMark);\n+  } else {\n+    _preserved_count_max = 0;\n+  }\n+\n+  _preserved_marks = (PreservedMark*)scratch;\n+  _preserved_count = 0;\n+\n+  _preserved_overflow_stack_set.init(1);\n+}\n+\n+void MarkSweep::deallocate_stacks() {\n+  if (_preserved_count_max != 0) {\n+    DefNewGeneration* young_gen = (DefNewGeneration*)SerialHeap::heap()->young_gen();\n+    young_gen->reset_scratch();\n+  }\n+\n+  _preserved_overflow_stack_set.reclaim();\n+  _marking_stack.clear();\n+  _objarray_stack.clear(true);\n+}\n+\n@@ -238,0 +653,89 @@\n+\n+void MarkSweep::invoke_at_safepoint(bool clear_all_softrefs) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n+\n+  SerialHeap* gch = SerialHeap::heap();\n+#ifdef ASSERT\n+  if (gch->soft_ref_policy()->should_clear_all_soft_refs()) {\n+    assert(clear_all_softrefs, \"Policy should have been checked earlier\");\n+  }\n+#endif\n+\n+  gch->trace_heap_before_gc(_gc_tracer);\n+\n+  \/\/ Increment the invocation count\n+  _total_invocations++;\n+\n+  \/\/ Capture used regions for old-gen to reestablish old-to-young invariant\n+  \/\/ after full-gc.\n+  gch->old_gen()->save_used_region();\n+\n+  allocate_stacks();\n+\n+  phase1_mark(clear_all_softrefs);\n+\n+  Compacter compacter{gch};\n+\n+  {\n+    \/\/ Now all live objects are marked, compute the new object addresses.\n+    GCTraceTime(Info, gc, phases) tm(\"Phase 2: Compute new object addresses\", _gc_timer);\n+\n+    compacter.phase2_calculate_new_addr();\n+  }\n+\n+  \/\/ Don't add any more derived pointers during phase3\n+#if COMPILER2_OR_JVMCI\n+  assert(DerivedPointerTable::is_active(), \"Sanity\");\n+  DerivedPointerTable::set_active(false);\n+#endif\n+\n+  {\n+    \/\/ Adjust the pointers to reflect the new locations\n+    GCTraceTime(Info, gc, phases) tm(\"Phase 3: Adjust pointers\", gc_timer());\n+\n+    ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_adjust);\n+\n+    CodeBlobToOopClosure code_closure(&adjust_pointer_closure, CodeBlobToOopClosure::FixRelocations);\n+    gch->process_roots(SerialHeap::SO_AllCodeCache,\n+                       &adjust_pointer_closure,\n+                       &adjust_cld_closure,\n+                       &adjust_cld_closure,\n+                       &code_closure);\n+\n+    WeakProcessor::oops_do(&adjust_pointer_closure);\n+\n+    adjust_marks();\n+    compacter.phase3_adjust_pointers();\n+  }\n+\n+  {\n+    \/\/ All pointers are now adjusted, move objects accordingly\n+    GCTraceTime(Info, gc, phases) tm(\"Phase 4: Move objects\", _gc_timer);\n+\n+    compacter.phase4_compact();\n+  }\n+\n+  restore_marks();\n+\n+  \/\/ Set saved marks for allocation profiler (and other things? -- dld)\n+  \/\/ (Should this be in general part?)\n+  gch->save_marks();\n+\n+  deallocate_stacks();\n+\n+  MarkSweep::_string_dedup_requests->flush();\n+\n+  bool is_young_gen_empty = (gch->young_gen()->used() == 0);\n+  gch->rem_set()->maintain_old_to_young_invariant(gch->old_gen(), is_young_gen_empty);\n+\n+  gch->prune_scavengable_nmethods();\n+\n+  \/\/ Update heap occupancy information which is used as\n+  \/\/ input to soft ref clearing policy at the next gc.\n+  Universe::heap()->update_capacity_and_used_at_gc();\n+\n+  \/\/ Signal that we have completed a visit to all live objects.\n+  Universe::heap()->record_whole_heap_examined_timestamp();\n+\n+  gch->trace_heap_after_gc(_gc_tracer);\n+}\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":505,"deletions":1,"binary":false,"changes":506,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,0 +131,2 @@\n+  static void invoke_at_safepoint(bool clear_all_softrefs);\n+\n@@ -155,0 +157,7 @@\n+  \/\/ Mark live objects\n+  static void phase1_mark(bool clear_all_softrefs);\n+\n+  \/\/ Temporary data structures for traversal and storing\/restoring marks\n+  static void allocate_stacks();\n+  static void deallocate_stacks();\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n-SerialBlockOffsetSharedArray::SerialBlockOffsetSharedArray(MemRegion reserved,\n-                                                           size_t init_word_size):\n+SerialBlockOffsetTable::SerialBlockOffsetTable(MemRegion reserved,\n+                                               size_t init_word_size):\n@@ -52,1 +52,1 @@\n-  log_trace(gc, bot)(\"SerialBlockOffsetSharedArray::SerialBlockOffsetSharedArray: \");\n+  log_trace(gc, bot)(\"SerialBlockOffsetTable::SerialBlockOffsetTable: \");\n@@ -59,1 +59,1 @@\n-void SerialBlockOffsetSharedArray::resize(size_t new_word_size) {\n+void SerialBlockOffsetTable::resize(size_t new_word_size) {\n@@ -115,1 +115,1 @@\n-  uint8_t* const offset_card = _array->entry_for_addr(cur_card_boundary);\n+  uint8_t* const offset_card = entry_for_addr(cur_card_boundary);\n@@ -118,1 +118,1 @@\n-  _array->set_offset_array(offset_card, cur_card_boundary, blk_start);\n+  set_offset_array(offset_card, cur_card_boundary, blk_start);\n@@ -121,1 +121,1 @@\n-  uint8_t* end_card = _array->entry_for_addr(blk_end - 1);\n+  uint8_t* end_card = entry_for_addr(blk_end - 1);\n@@ -133,1 +133,1 @@\n-      _array->set_offset_array(start_card_for_region, MIN2(reach, end_card), value);\n+      set_offset_array(start_card_for_region, MIN2(reach, end_card), value);\n@@ -147,1 +147,1 @@\n-  uint8_t* entry = _array->entry_for_addr(addr);\n+  uint8_t* entry = entry_for_addr(addr);\n@@ -156,1 +156,1 @@\n-  HeapWord* q = _array->addr_for_entry(entry);\n+  HeapWord* q = addr_for_entry(entry);\n@@ -163,2 +163,2 @@\n-  uint8_t* start_card = _array->entry_for_addr(align_up_by_card_size(blk_start));\n-  uint8_t* end_card = _array->entry_for_addr(blk_end - 1);\n+  uint8_t* start_card = entry_for_addr(align_up_by_card_size(blk_start));\n+  uint8_t* end_card = entry_for_addr(blk_end - 1);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -39,1 +39,5 @@\n-class SerialBlockOffsetSharedArray: public CHeapObj<mtGC> {\n+\/\/ SerialBlockOffsetTable divides the covered region into \"N\"-word subregions (where\n+\/\/ \"N\" = 2^\"LogN\".  An array with an entry for each such subregion indicates\n+\/\/ how far back one must go to find the start of the chunk that includes the\n+\/\/ first word of the subregion.\n+class SerialBlockOffsetTable: public CHeapObj<mtGC> {\n@@ -41,1 +45,0 @@\n-  friend class SerialBlockOffsetTable;\n@@ -66,0 +69,8 @@\n+  void update_for_block_work(HeapWord* blk_start, HeapWord* blk_end);\n+\n+  static HeapWord* align_up_by_card_size(HeapWord* const addr) {\n+    return align_up(addr, CardTable::card_size());\n+  }\n+\n+  void verify_for_block(HeapWord* blk_start, HeapWord* blk_end) const;\n+\n@@ -73,1 +84,19 @@\n-  SerialBlockOffsetSharedArray(MemRegion reserved, size_t init_word_size);\n+  SerialBlockOffsetTable(MemRegion reserved, size_t init_word_size);\n+\n+  static bool is_crossing_card_boundary(HeapWord* const obj_start,\n+                                        HeapWord* const obj_end) {\n+    HeapWord* cur_card_boundary = align_up_by_card_size(obj_start);\n+    \/\/ Strictly greater-than, since we check if this block *crosses* card boundary.\n+    return obj_end > cur_card_boundary;\n+  }\n+\n+  \/\/ Returns the address of the start of the block reaching into the card containing\n+  \/\/ \"addr\".\n+  HeapWord* block_start_reaching_into_card(const void* addr) const;\n+\n+  \/\/ [blk_start, blk_end) representing a block of memory in the heap.\n+  void update_for_block(HeapWord* blk_start, HeapWord* blk_end) {\n+    if (is_crossing_card_boundary(blk_start, blk_end)) {\n+      update_for_block_work(blk_start, blk_end);\n+    }\n+  }\n@@ -102,42 +131,0 @@\n-\/\/ SerialBlockOffsetTable divides the covered region into \"N\"-word subregions (where\n-\/\/ \"N\" = 2^\"LogN\".  An array with an entry for each such subregion indicates\n-\/\/ how far back one must go to find the start of the chunk that includes the\n-\/\/ first word of the subregion.\n-class SerialBlockOffsetTable {\n-  friend class VMStructs;\n-\n-  \/\/ The array that contains offset values. Its reacts to heap resizing.\n-  SerialBlockOffsetSharedArray* _array;\n-\n-  void update_for_block_work(HeapWord* blk_start, HeapWord* blk_end);\n-\n-  static HeapWord* align_up_by_card_size(HeapWord* const addr) {\n-    return align_up(addr, CardTable::card_size());\n-  }\n-\n-  void verify_for_block(HeapWord* blk_start, HeapWord* blk_end) const;\n-\n-public:\n-  \/\/ Initialize the table to cover the given space.\n-  \/\/ The contents of the initial table are undefined.\n-  SerialBlockOffsetTable(SerialBlockOffsetSharedArray* array) : _array(array) {}\n-\n-  static bool is_crossing_card_boundary(HeapWord* const obj_start,\n-                                        HeapWord* const obj_end) {\n-    HeapWord* cur_card_boundary = align_up_by_card_size(obj_start);\n-    \/\/ Strictly greater-than, since we check if this block *crosses* card boundary.\n-    return obj_end > cur_card_boundary;\n-  }\n-\n-  \/\/ Returns the address of the start of the block reaching into the card containing\n-  \/\/ \"addr\".\n-  HeapWord* block_start_reaching_into_card(const void* addr) const;\n-\n-  \/\/ [blk_start, blk_end) representing a block of memory in the heap.\n-  void update_for_block(HeapWord* blk_start, HeapWord* blk_end) {\n-    if (is_crossing_card_boundary(blk_start, blk_end)) {\n-      update_for_block_work(blk_start, blk_end);\n-    }\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.hpp","additions":32,"deletions":45,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-inline uint8_t* SerialBlockOffsetSharedArray::entry_for_addr(const void* const p) const {\n+inline uint8_t* SerialBlockOffsetTable::entry_for_addr(const void* const p) const {\n@@ -37,1 +37,1 @@\n-inline HeapWord* SerialBlockOffsetSharedArray::addr_for_entry(const uint8_t* const p) const {\n+inline HeapWord* SerialBlockOffsetTable::addr_for_entry(const uint8_t* const p) const {\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"gc\/serial\/genMarkSweep.hpp\"\n@@ -564,1 +563,1 @@\n-    GCTraceCPUTime tcpu(GenMarkSweep::gc_tracer());\n+    GCTraceCPUTime tcpu(MarkSweep::gc_tracer());\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  friend class GenMarkSweep;\n+  friend class MarkSweep;\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-                        notproduct,  \\\n","filename":"src\/hotspot\/share\/gc\/serial\/serial_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-#include \"gc\/serial\/genMarkSweep.hpp\"\n+#include \"gc\/serial\/markSweep.hpp\"\n@@ -290,2 +290,2 @@\n-  _bts = new SerialBlockOffsetSharedArray(reserved_mr,\n-                                          heap_word_size(initial_byte_size));\n+  _bts = new SerialBlockOffsetTable(reserved_mr,\n+                                    heap_word_size(initial_byte_size));\n@@ -447,1 +447,1 @@\n-  STWGCTimer* gc_timer = GenMarkSweep::gc_timer();\n+  STWGCTimer* gc_timer = MarkSweep::gc_timer();\n@@ -450,1 +450,1 @@\n-  SerialOldTracer* gc_tracer = GenMarkSweep::gc_tracer();\n+  SerialOldTracer* gc_tracer = MarkSweep::gc_tracer();\n@@ -455,1 +455,1 @@\n-  GenMarkSweep::invoke_at_safepoint(clear_all_soft_refs);\n+  MarkSweep::invoke_at_safepoint(clear_all_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-class SerialBlockOffsetSharedArray;\n+class SerialBlockOffsetTable;\n@@ -53,1 +53,1 @@\n-  SerialBlockOffsetSharedArray* _bts;\n+  SerialBlockOffsetTable* _bts;\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  nonstatic_field(TenuredGeneration,                 _bts,                   SerialBlockOffsetSharedArray*) \\\n+  nonstatic_field(TenuredGeneration,                 _bts,                   SerialBlockOffsetTable*)       \\\n@@ -57,1 +57,3 @@\n-  nonstatic_field(SerialBlockOffsetTable,            _array,                 SerialBlockOffsetSharedArray*) \\\n+  nonstatic_field(SerialBlockOffsetTable,            _reserved,              MemRegion)                     \\\n+  nonstatic_field(SerialBlockOffsetTable,            _vs,                    VirtualSpace)                  \\\n+  nonstatic_field(SerialBlockOffsetTable,            _offset_base,           u_char*)                       \\\n@@ -59,5 +61,1 @@\n-  nonstatic_field(SerialBlockOffsetSharedArray,      _reserved,              MemRegion)                     \\\n-  nonstatic_field(SerialBlockOffsetSharedArray,      _vs,                    VirtualSpace)                  \\\n-  nonstatic_field(SerialBlockOffsetSharedArray,      _offset_base,           u_char*)                       \\\n-                                                                                                            \\\n-  nonstatic_field(TenuredSpace,                      _offsets,               SerialBlockOffsetTable)        \\\n+  nonstatic_field(TenuredSpace,                      _offsets,               SerialBlockOffsetTable*)       \\\n@@ -81,1 +79,0 @@\n-  declare_toplevel_type(SerialBlockOffsetSharedArray)                         \\\n","filename":"src\/hotspot\/share\/gc\/serial\/vmStructs_serial.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,1 @@\n-void AgeTable::print_age_table(uint tenuring_threshold) {\n+void AgeTable::print_age_table() {\n@@ -121,1 +121,1 @@\n-    print_on(&st, tenuring_threshold);\n+    print_on(&st);\n@@ -125,3 +125,2 @@\n-void AgeTable::print_on(outputStream* st, uint tenuring_threshold) {\n-  st->print_cr(\"Age table with threshold %u (max threshold %u)\",\n-               tenuring_threshold, MaxTenuringThreshold);\n+void AgeTable::print_on(outputStream* st) {\n+  st->print_cr(\"Age table:\");\n","filename":"src\/hotspot\/share\/gc\/shared\/ageTable.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-  void print_age_table(uint tenuring_threshold);\n-  void print_on(outputStream* st, uint tenuring_threshold);\n+  void print_age_table();\n+  void print_on(outputStream* st);\n","filename":"src\/hotspot\/share\/gc\/shared\/ageTable.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -207,4 +207,1 @@\n-  while (cur < last) {\n-    *cur = dirty_card;\n-    cur++;\n-  }\n+  memset(cur, dirty_card, pointer_delta(last, cur, sizeof(CardValue)));\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -350,5 +350,0 @@\n-  \/\/ If a GC uses a stack watermark barrier, the stack processing is lazy, concurrent,\n-  \/\/ incremental and cooperative. In order for that to work well, mechanisms that stop\n-  \/\/ another thread might want to ensure its roots are in a sane state.\n-  virtual bool uses_stack_watermark_barrier() const { return false; }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-                 notproduct,                                                \\\n@@ -62,1 +61,0 @@\n-    notproduct,                                                             \\\n@@ -71,1 +69,0 @@\n-    notproduct,                                                             \\\n@@ -80,1 +77,0 @@\n-    notproduct,                                                             \\\n@@ -89,1 +85,0 @@\n-    notproduct,                                                             \\\n@@ -98,1 +93,0 @@\n-    notproduct,                                                             \\\n@@ -107,1 +101,0 @@\n-    notproduct,                                                             \\\n@@ -243,1 +236,1 @@\n-  notproduct(bool, ScavengeALot, false,                                     \\\n+  develop(bool, ScavengeALot, false,                                        \\\n@@ -251,1 +244,1 @@\n-  notproduct(bool, GCALotAtAllSafepoints, false,                            \\\n+  develop(bool, GCALotAtAllSafepoints, false,                               \\\n@@ -254,1 +247,1 @@\n-  notproduct(bool, PromotionFailureALot, false,                             \\\n+  develop(bool, PromotionFailureALot, false,                                \\\n@@ -529,1 +522,1 @@\n-  notproduct(int, ScavengeALotInterval,     1,                              \\\n+  develop(int, ScavengeALotInterval,     1,                                 \\\n@@ -532,1 +525,1 @@\n-  notproduct(int, FullGCALotInterval,     1,                                \\\n+  develop(int, FullGCALotInterval,     1,                                   \\\n@@ -535,1 +528,1 @@\n-  notproduct(int, FullGCALotStart,     0,                                   \\\n+  develop(int, FullGCALotStart,     0,                                      \\\n@@ -538,1 +531,1 @@\n-  notproduct(int, FullGCALotDummies,  32*K,                                 \\\n+  develop(int, FullGCALotDummies,  32*K,                                    \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -319,0 +319,1 @@\n+  \/\/ ...and clear or zap just allocated TLAB, if needed.\n@@ -320,1 +321,0 @@\n-    \/\/ ..and clear it.\n@@ -322,3 +322,1 @@\n-  } else {\n-    \/\/ ...and zap just allocated object.\n-#ifdef ASSERT\n+  } else if (ZapTLAB) {\n@@ -330,1 +328,0 @@\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-  HeapWord* cur_block = _offsets.block_start_reaching_into_card(addr);\n+  HeapWord* cur_block = _offsets->block_start_reaching_into_card(addr);\n@@ -211,1 +211,1 @@\n-TenuredSpace::TenuredSpace(SerialBlockOffsetSharedArray* sharedOffsetArray,\n+TenuredSpace::TenuredSpace(SerialBlockOffsetTable* offsets,\n@@ -213,1 +213,1 @@\n-  _offsets(sharedOffsetArray)\n+  _offsets(offsets)\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -228,1 +228,1 @@\n-  SerialBlockOffsetTable _offsets;\n+  SerialBlockOffsetTable* _offsets;\n@@ -234,1 +234,1 @@\n-  TenuredSpace(SerialBlockOffsetSharedArray* sharedOffsetArray,\n+  TenuredSpace(SerialBlockOffsetTable* offsets,\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    _offsets.update_for_block(res, res + size);\n+    _offsets->update_for_block(res, res + size);\n@@ -49,1 +49,1 @@\n-    _offsets.update_for_block(res, res + size);\n+    _offsets->update_for_block(res, res + size);\n@@ -55,1 +55,1 @@\n-  _offsets.update_for_block(start, end);\n+  _offsets->update_for_block(start, end);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,8 +42,2 @@\n-    \/\/ successful thread-local allocation\n-#ifdef ASSERT\n-    \/\/ Skip mangling the space corresponding to the object header to\n-    \/\/ ensure that the returned space is not considered parsable by\n-    \/\/ any concurrent GC thread.\n-    size_t hdr_size = oopDesc::header_size();\n-    Copy::fill_to_words(obj + hdr_size, size - hdr_size, badHeapWordVal);\n-#endif \/\/ ASSERT\n+    \/\/ Successful thread-local allocation.\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.inline.hpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-                   notproduct,                                              \\\n","filename":"src\/hotspot\/share\/gc\/shared\/tlab_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    _age_table->print_on(st, ShenandoahHeap::heap()->age_census()->tenuring_threshold());\n+    _age_table->print_on(st);\n@@ -120,1 +120,0 @@\n-    uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n@@ -122,1 +121,1 @@\n-    young_region_ages.print_on(st, tenuring_threshold);\n+    young_region_ages.print_on(st);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -978,0 +979,1 @@\n+  \/\/ ...and clear or zap just allocated TLAB, if needed.\n@@ -979,1 +981,0 @@\n-    \/\/ ..and clear it.\n@@ -981,3 +982,1 @@\n-  } else {\n-    \/\/ ...and zap just allocated object.\n-#ifdef ASSERT\n+  } else if (ZapTLAB) {\n@@ -989,1 +988,0 @@\n-#endif \/\/ ASSERT\n@@ -3297,0 +3295,1 @@\n+  StackWatermarkSet::safepoint_synchronize_begin();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -631,5 +631,0 @@\n-\/\/ ---------- Concurrent Stack Processing support\n-\/\/\n-public:\n-  bool uses_stack_watermark_barrier() const override { return true; }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-                            notproduct,                                     \\\n@@ -593,1 +592,1 @@\n-  notproduct(bool, ShenandoahEnableCardStats, false,                        \\\n+  develop(bool, ShenandoahEnableCardStats, false,                           \\\n@@ -596,1 +595,1 @@\n-  notproduct(int, ShenandoahCardStatsLogInterval, 50,                       \\\n+  develop(int, ShenandoahCardStatsLogInterval, 50,                          \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -218,4 +219,0 @@\n-bool XCollectedHeap::uses_stack_watermark_barrier() const {\n-  return true;\n-}\n-\n@@ -280,0 +277,1 @@\n+  StackWatermarkSet::safepoint_synchronize_begin();\n","filename":"src\/hotspot\/share\/gc\/x\/xCollectedHeap.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,2 +90,0 @@\n-  bool uses_stack_watermark_barrier() const override;\n-\n","filename":"src\/hotspot\/share\/gc\/x\/xCollectedHeap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-                   notproduct,                                       \\\n","filename":"src\/hotspot\/share\/gc\/x\/x_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-                          notproduct,                                       \\\n@@ -95,1 +94,0 @@\n-    notproduct,                                                             \\\n@@ -104,1 +102,0 @@\n-    notproduct,                                                             \\\n","filename":"src\/hotspot\/share\/gc\/z\/shared\/z_shared_globals.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -251,1 +251,0 @@\n-  static zpointer set_remset_bits(zpointer ptr);\n","filename":"src\/hotspot\/share\/gc\/z\/zAddress.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -457,7 +457,0 @@\n-inline zpointer ZPointer::set_remset_bits(zpointer ptr) {\n-  uintptr_t raw_addr = untype(ptr);\n-  assert(raw_addr != 0, \"raw nulls should have been purged in promotion to old gen\");\n-  raw_addr |= ZPointerRemembered0 | ZPointerRemembered1;\n-  return to_zpointer(raw_addr);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zAddress.inline.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,0 @@\n-  friend class ZAllocatorEden;\n-  friend class ZAllocatorSurvivor;\n-  friend class ZAllocatorOld;\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zAllocator.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -243,4 +244,0 @@\n-bool ZCollectedHeap::uses_stack_watermark_barrier() const {\n-  return true;\n-}\n-\n@@ -341,0 +338,1 @@\n+  StackWatermarkSet::safepoint_synchronize_begin();\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,2 +91,0 @@\n-  bool uses_stack_watermark_barrier() const override;\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-                   notproduct,                                              \\\n","filename":"src\/hotspot\/share\/gc\/z\/z_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1994,5 +1994,3 @@\n-              \/\/ Initialize object field block:\n-              \/\/   - if TLAB is pre-zeroed, we can skip this path\n-              \/\/   - in debug mode, ThreadLocalAllocBuffer::allocate mangles\n-              \/\/     this area, and we still need to initialize it\n-              if (DEBUG_ONLY(true ||) !ZeroTLAB) {\n+              \/\/ Initialize object field block.\n+              if (!ZeroTLAB) {\n+                \/\/ The TLAB was not pre-zeroed, we need to clear the memory here.\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -232,3 +232,6 @@\n-      const char* disable_msg = err_msg(\"JVMCI compiler disabled \"\n-      \"after %d of %d upcalls had errors (Last error: \\\"%s\\\"). \"\n-      \"Use -Xlog:jit+compilation for more detail.\", err, total, error);\n+      \/\/ Using stringStream instead of err_msg to avoid truncation\n+      stringStream st;\n+      st.print(\"JVMCI compiler disabled \"\n+               \"after %d of %d upcalls had errors (Last error: \\\"%s\\\"). \"\n+               \"Use -Xlog:jit+compilation for more detail.\", err, total, error);\n+      const char* disable_msg = st.freeze();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -43,1 +44,0 @@\n-#include \"runtime\/thread.inline.hpp\"\n@@ -242,2 +242,4 @@\n-  JVMCI_THROW_MSG(InternalError, err_msg(\"Error creating or attaching to libjvmci (err: %d, description: %s)\",\n-                  _init_error, _init_error_msg == nullptr ? \"unknown\" : _init_error_msg));\n+  stringStream st;\n+  st.print(\"Error creating or attaching to libjvmci (err: %d, description: %s)\",\n+           _init_error, _init_error_msg == nullptr ? \"unknown\" : _init_error_msg);\n+  JVMCI_THROW_MSG(InternalError, st.freeze());\n@@ -253,2 +255,4 @@\n-  THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), err_msg(\"Error creating or attaching to libjvmci (err: %d, description: %s)\",\n-            _init_error, _init_error_msg == nullptr ? \"unknown\" : _init_error_msg));\n+  stringStream st;\n+  st.print(\"Error creating or attaching to libjvmci (err: %d, description: %s)\",\n+           _init_error, _init_error_msg == nullptr ? \"unknown\" : _init_error_msg);\n+  THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), st.freeze());\n@@ -414,0 +418,5 @@\n+  static bool debug_translated_exception() {\n+      const char* prop_value = Arguments::get_property(\"jdk.internal.vm.TranslatedException.debug\");\n+      return prop_value != nullptr && strcmp(\"true\", prop_value) == 0;\n+  }\n+\n@@ -509,1 +518,1 @@\n-                                format, buffer, false);\n+                                format, buffer, false, debug_translated_exception());\n@@ -542,0 +551,1 @@\n+    jargs.push_int(debug_translated_exception());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1976,1 +1976,4 @@\n-    const char* failure_reason = os::strdup(err_msg(\"uncaught exception in %s [%s]\", function, pending_string), mtJVMCI);\n+    \/\/ Using stringStream instead of err_msg to avoid truncation\n+    stringStream st;\n+    st.print(\"uncaught exception in %s [%s]\", function, pending_string);\n+    const char* failure_reason = os::strdup(st.freeze(), mtJVMCI);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-  JVMCI_FLAGS(params4, params3, params4, params3, params4, IGNORE_RANGE, IGNORE_CONSTRAINT)\n+  JVMCI_FLAGS(params4, params3, params4, params3, IGNORE_RANGE, IGNORE_CONSTRAINT)\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-                    notproduct,                                             \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -90,0 +90,23 @@\n+\/\/ A helper class for caching a Method* when the user of the cache\n+\/\/ only cares about the latest version of the Method*. This cache safely\n+\/\/ interacts with the RedefineClasses API.\n+class LatestMethodCache {\n+  \/\/ We save the InstanceKlass* and the idnum of Method* in order to get\n+  \/\/ the current Method*.\n+  InstanceKlass*        _klass;\n+  int                   _method_idnum;\n+\n+ public:\n+  LatestMethodCache()   { _klass = nullptr; _method_idnum = -1; }\n+\n+  void init(JavaThread* current, InstanceKlass* ik, const char* method,\n+            Symbol* signature, bool is_static);\n+  Method* get_method();\n+};\n+\n+static LatestMethodCache _finalizer_register_cache;         \/\/ Finalizer.register()\n+static LatestMethodCache _loader_addClass_cache;            \/\/ ClassLoader.addClass()\n+static LatestMethodCache _throw_illegal_access_error_cache; \/\/ Unsafe.throwIllegalAccessError()\n+static LatestMethodCache _throw_no_such_method_error_cache; \/\/ Unsafe.throwNoSuchMethodError()\n+static LatestMethodCache _do_stack_walk_cache;              \/\/ AbstractStackWalker.doStackWalk()\n+\n@@ -129,4 +152,0 @@\n-OopHandle Universe::_null_ptr_exception_instance;\n-OopHandle Universe::_arithmetic_exception_instance;\n-OopHandle Universe::_virtual_machine_error_instance;\n-\n@@ -136,5 +155,0 @@\n-LatestMethodCache* Universe::_finalizer_register_cache = nullptr;\n-LatestMethodCache* Universe::_loader_addClass_cache    = nullptr;\n-LatestMethodCache* Universe::_throw_illegal_access_error_cache = nullptr;\n-LatestMethodCache* Universe::_throw_no_such_method_error_cache = nullptr;\n-LatestMethodCache* Universe::_do_stack_walk_cache     = nullptr;\n@@ -171,0 +185,46 @@\n+\/\/ These are the exceptions that are always created and are guatanteed to exist.\n+\/\/ If possible, they can be stored as CDS archived objects to speed up AOT code.\n+class BuiltinException {\n+  OopHandle _instance;\n+  CDS_JAVA_HEAP_ONLY(int _archived_root_index;)\n+\n+public:\n+  BuiltinException() : _instance() {\n+    CDS_JAVA_HEAP_ONLY(_archived_root_index = 0);\n+  }\n+\n+  void init_if_empty(Symbol* symbol, TRAPS) {\n+    if (_instance.is_empty()) {\n+      Klass* k = SystemDictionary::resolve_or_fail(symbol, true, CHECK);\n+      oop obj = InstanceKlass::cast(k)->allocate_instance(CHECK);\n+      _instance = OopHandle(Universe::vm_global(), obj);\n+    }\n+  }\n+\n+  oop instance() {\n+    return _instance.resolve();\n+  }\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  void store_in_cds() {\n+    _archived_root_index = HeapShared::archive_exception_instance(instance());\n+  }\n+\n+  void load_from_cds() {\n+    if (_archived_root_index >= 0) {\n+      oop obj = HeapShared::get_root(_archived_root_index);\n+      assert(obj != nullptr, \"must be\");\n+      _instance = OopHandle(Universe::vm_global(), obj);\n+    }\n+  }\n+\n+  void serialize(SerializeClosure *f) {\n+    f->do_int(&_archived_root_index);\n+  }\n+#endif\n+};\n+\n+static BuiltinException _null_ptr_exception;\n+static BuiltinException _arithmetic_exception;\n+static BuiltinException _virtual_machine_error;\n+\n@@ -184,3 +244,3 @@\n-oop Universe::null_ptr_exception_instance()       { return _null_ptr_exception_instance.resolve(); }\n-oop Universe::arithmetic_exception_instance()     { return _arithmetic_exception_instance.resolve(); }\n-oop Universe::virtual_machine_error_instance()    { return _virtual_machine_error_instance.resolve(); }\n+oop Universe::null_ptr_exception_instance()       { return _null_ptr_exception.instance(); }\n+oop Universe::arithmetic_exception_instance()     { return _arithmetic_exception.instance(); }\n+oop Universe::virtual_machine_error_instance()    { return _virtual_machine_error.instance(); }\n@@ -217,4 +277,0 @@\n-void LatestMethodCache::metaspace_pointers_do(MetaspaceClosure* it) {\n-  it->push(&_klass);\n-}\n-\n@@ -234,6 +290,0 @@\n-\n-  _finalizer_register_cache->metaspace_pointers_do(it);\n-  _loader_addClass_cache->metaspace_pointers_do(it);\n-  _throw_illegal_access_error_cache->metaspace_pointers_do(it);\n-  _throw_no_such_method_error_cache->metaspace_pointers_do(it);\n-  _do_stack_walk_cache->metaspace_pointers_do(it);\n@@ -249,1 +299,7 @@\n-void Universe::update_archived_basic_type_mirrors() {\n+void Universe::archive_exception_instances() {\n+  _null_ptr_exception.store_in_cds();\n+  _arithmetic_exception.store_in_cds();\n+  _virtual_machine_error.store_in_cds();\n+}\n+\n+void Universe::load_archived_object_instances() {\n@@ -259,0 +315,4 @@\n+\n+    _null_ptr_exception.load_from_cds();\n+    _arithmetic_exception.load_from_cds();\n+    _virtual_machine_error.load_from_cds();\n@@ -270,1 +330,1 @@\n-    \/\/ updated later in Universe::update_archived_basic_type_mirrors().\n+    \/\/ updated later in Universe::load_archived_object_instances().\n@@ -272,0 +332,3 @@\n+  _null_ptr_exception.serialize(f);\n+  _arithmetic_exception.serialize(f);\n+  _virtual_machine_error.serialize(f);\n@@ -286,5 +349,0 @@\n-  _finalizer_register_cache->serialize(f);\n-  _loader_addClass_cache->serialize(f);\n-  _throw_illegal_access_error_cache->serialize(f);\n-  _throw_no_such_method_error_cache->serialize(f);\n-  _do_stack_walk_cache->serialize(f);\n@@ -813,8 +871,0 @@\n-  \/\/ We have a heap so create the Method* caches before\n-  \/\/ Metaspace::initialize_shared_spaces() tries to populate them.\n-  Universe::_finalizer_register_cache = new LatestMethodCache();\n-  Universe::_loader_addClass_cache    = new LatestMethodCache();\n-  Universe::_throw_illegal_access_error_cache = new LatestMethodCache();\n-  Universe::_throw_no_such_method_error_cache = new LatestMethodCache();\n-  Universe::_do_stack_walk_cache = new LatestMethodCache();\n-\n@@ -927,5 +977,2 @@\n-static void initialize_known_method(LatestMethodCache* method_cache,\n-                                    InstanceKlass* ik,\n-                                    const char* method,\n-                                    Symbol* signature,\n-                                    bool is_static, TRAPS)\n+void LatestMethodCache::init(JavaThread* current, InstanceKlass* ik,\n+                             const char* method, Symbol* signature, bool is_static)\n@@ -936,1 +983,1 @@\n-  if (!ik->link_class_or_fail(THREAD) ||\n+  if (!ik->link_class_or_fail(current) ||\n@@ -939,1 +986,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -945,1 +992,4 @@\n-  method_cache->init(ik, m);\n+\n+  _klass = ik;\n+  _method_idnum = m->method_idnum();\n+  assert(_method_idnum >= 0, \"sanity check\");\n@@ -948,1 +998,17 @@\n-void Universe::initialize_known_methods(TRAPS) {\n+Method* LatestMethodCache::get_method() {\n+  if (_klass == nullptr) {\n+    return nullptr;\n+  } else {\n+    Method* m = _klass->method_with_idnum(_method_idnum);\n+    assert(m != nullptr, \"sanity check\");\n+    return m;\n+  }\n+}\n+\n+Method* Universe::finalizer_register_method()     { return _finalizer_register_cache.get_method(); }\n+Method* Universe::loader_addClass_method()        { return _loader_addClass_cache.get_method(); }\n+Method* Universe::throw_illegal_access_error()    { return _throw_illegal_access_error_cache.get_method(); }\n+Method* Universe::throw_no_such_method_error()    { return _throw_no_such_method_error_cache.get_method(); }\n+Method* Universe::do_stack_walk_method()          { return _do_stack_walk_cache.get_method(); }\n+\n+void Universe::initialize_known_methods(JavaThread* current) {\n@@ -950,1 +1016,1 @@\n-  initialize_known_method(_finalizer_register_cache,\n+  _finalizer_register_cache.init(current,\n@@ -953,1 +1019,1 @@\n-                          vmSymbols::object_void_signature(), true, CHECK);\n+                          vmSymbols::object_void_signature(), true);\n@@ -955,1 +1021,1 @@\n-  initialize_known_method(_throw_illegal_access_error_cache,\n+  _throw_illegal_access_error_cache.init(current,\n@@ -958,1 +1024,1 @@\n-                          vmSymbols::void_method_signature(), true, CHECK);\n+                          vmSymbols::void_method_signature(), true);\n@@ -960,1 +1026,1 @@\n-  initialize_known_method(_throw_no_such_method_error_cache,\n+  _throw_no_such_method_error_cache.init(current,\n@@ -963,1 +1029,1 @@\n-                          vmSymbols::void_method_signature(), true, CHECK);\n+                          vmSymbols::void_method_signature(), true);\n@@ -966,1 +1032,1 @@\n-  initialize_known_method(_loader_addClass_cache,\n+  _loader_addClass_cache.init(current,\n@@ -969,1 +1035,1 @@\n-                          vmSymbols::class_void_signature(), false, CHECK);\n+                          vmSymbols::class_void_signature(), false);\n@@ -972,1 +1038,1 @@\n-  initialize_known_method(_do_stack_walk_cache,\n+  _do_stack_walk_cache.init(current,\n@@ -975,1 +1041,1 @@\n-                          vmSymbols::doStackWalk_signature(), false, CHECK);\n+                          vmSymbols::doStackWalk_signature(), false);\n@@ -1013,11 +1079,4 @@\n-  \/\/ Setup preallocated NullPointerException\n-  \/\/ (this is currently used for a cheap & dirty solution in compiler exception handling)\n-  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_NullPointerException(), true, CHECK_false);\n-  instance = InstanceKlass::cast(k)->allocate_instance(CHECK_false);\n-  Universe::_null_ptr_exception_instance = OopHandle(Universe::vm_global(), instance);\n-\n-  \/\/ Setup preallocated ArithmeticException\n-  \/\/ (this is currently used for a cheap & dirty solution in compiler exception handling)\n-  k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_ArithmeticException(), true, CHECK_false);\n-  instance = InstanceKlass::cast(k)->allocate_instance(CHECK_false);\n-  Universe::_arithmetic_exception_instance = OopHandle(Universe::vm_global(), instance);\n+  \/\/ Setup preallocated NullPointerException\/ArithmeticException\n+  \/\/ (used for a cheap & dirty solution in compiler exception handling)\n+  _null_ptr_exception.init_if_empty(vmSymbols::java_lang_NullPointerException(), CHECK_false);\n+  _arithmetic_exception.init_if_empty(vmSymbols::java_lang_ArithmeticException(), CHECK_false);\n@@ -1026,1 +1085,1 @@\n-  k = vmClasses::VirtualMachineError_klass();\n+  Klass* k = vmClasses::VirtualMachineError_klass();\n@@ -1032,2 +1091,1 @@\n-  instance = InstanceKlass::cast(k)->allocate_instance(CHECK_false);\n-  Universe::_virtual_machine_error_instance = OopHandle(Universe::vm_global(), instance);\n+  _virtual_machine_error.init_if_empty(vmSymbols::java_lang_VirtualMachineError(), CHECK_false);\n@@ -1043,1 +1101,1 @@\n-  Universe::initialize_known_methods(CHECK_false);\n+  Universe::initialize_known_methods(THREAD);\n@@ -1258,29 +1316,0 @@\n-\n-void LatestMethodCache::init(Klass* k, Method* m) {\n-  if (!UseSharedSpaces) {\n-    _klass = k;\n-  }\n-#ifndef PRODUCT\n-  else {\n-    \/\/ sharing initialization should have already set up _klass\n-    assert(_klass != nullptr, \"just checking\");\n-  }\n-#endif\n-\n-  _method_idnum = m->method_idnum();\n-  assert(_method_idnum >= 0, \"sanity check\");\n-}\n-\n-\n-Method* LatestMethodCache::get_method() {\n-  if (klass() == nullptr) return nullptr;\n-  InstanceKlass* ik = InstanceKlass::cast(klass());\n-  Method* m = ik->method_with_idnum(method_idnum());\n-  assert(m != nullptr, \"sanity check\");\n-  return m;\n-}\n-\n-void LatestMethodCache::serialize(SerializeClosure* f) {\n-  f->do_ptr(&_klass);\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":129,"deletions":100,"binary":false,"changes":229,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,27 +48,0 @@\n-\/\/ A helper class for caching a Method* when the user of the cache\n-\/\/ only cares about the latest version of the Method*.  This cache safely\n-\/\/ interacts with the RedefineClasses API.\n-\n-class LatestMethodCache : public CHeapObj<mtClass> {\n-  \/\/ We save the Klass* and the idnum of Method* in order to get\n-  \/\/ the current cached Method*.\n- private:\n-  Klass*                _klass;\n-  int                   _method_idnum;\n-\n- public:\n-  LatestMethodCache()   { _klass = nullptr; _method_idnum = -1; }\n-  ~LatestMethodCache()  { _klass = nullptr; _method_idnum = -1; }\n-\n-  void   init(Klass* k, Method* m);\n-  Klass* klass() const           { return _klass; }\n-  int    method_idnum() const    { return _method_idnum; }\n-\n-  Method* get_method();\n-\n-  \/\/ CDS support.  Replace the klass in this with the archive version\n-  \/\/ could use this for Enhanced Class Redefinition also.\n-  void serialize(SerializeClosure* f);\n-  void metaspace_pointers_do(MetaspaceClosure* it);\n-};\n-\n@@ -118,6 +91,0 @@\n-  static LatestMethodCache* _finalizer_register_cache; \/\/ static method for registering finalizable objects\n-  static LatestMethodCache* _loader_addClass_cache;    \/\/ method for registering loaded classes in class loader vector\n-  static LatestMethodCache* _throw_illegal_access_error_cache; \/\/ Unsafe.throwIllegalAccessError() method\n-  static LatestMethodCache* _throw_no_such_method_error_cache; \/\/ Unsafe.throwNoSuchMethodError() method\n-  static LatestMethodCache* _do_stack_walk_cache;      \/\/ method for stack walker callback\n-\n@@ -142,4 +109,0 @@\n-  static OopHandle    _null_ptr_exception_instance;   \/\/ preallocated exception object\n-  static OopHandle    _arithmetic_exception_instance; \/\/ preallocated exception object\n-  static OopHandle    _virtual_machine_error_instance; \/\/ preallocated exception object\n-\n@@ -247,0 +210,1 @@\n+  static void load_archived_object_instances() NOT_CDS_JAVA_HEAP_RETURN;\n@@ -249,1 +213,1 @@\n-  static void update_archived_basic_type_mirrors();\n+  static void archive_exception_instances();\n@@ -269,5 +233,0 @@\n-  static Method*      finalizer_register_method()     { return _finalizer_register_cache->get_method(); }\n-  static Method*      loader_addClass_method()        { return _loader_addClass_cache->get_method(); }\n-\n-  static Method*      throw_illegal_access_error()    { return _throw_illegal_access_error_cache->get_method(); }\n-  static Method*      throw_no_such_method_error()    { return _throw_no_such_method_error_cache->get_method(); }\n@@ -275,1 +234,5 @@\n-  static Method*      do_stack_walk_method()          { return _do_stack_walk_cache->get_method(); }\n+  static Method*      finalizer_register_method();\n+  static Method*      loader_addClass_method();\n+  static Method*      throw_illegal_access_error();\n+  static Method*      throw_no_such_method_error();\n+  static Method*      do_stack_walk_method();\n@@ -281,1 +244,1 @@\n-  static void initialize_known_methods(TRAPS);\n+  static void initialize_known_methods(JavaThread* current);\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":9,"deletions":46,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-                 notproduct,                                                \\\n@@ -107,1 +106,1 @@\n-  notproduct(intx, IndexSetWatch, 0,                                        \\\n+  develop(intx, IndexSetWatch, 0,                                           \\\n@@ -122,1 +121,1 @@\n-  notproduct(bool, PrintIdeal, false,                                       \\\n+  develop(bool, PrintIdeal, false,                                          \\\n@@ -125,1 +124,1 @@\n-  notproduct(bool, PrintOpto, false,                                        \\\n+  develop(bool, PrintOpto, false,                                           \\\n@@ -128,1 +127,1 @@\n-  notproduct(bool, PrintOptoInlining, false,                                \\\n+  develop(bool, PrintOptoInlining, false,                                   \\\n@@ -131,1 +130,1 @@\n-  notproduct(bool, VerifyIdealNodeCount, false,                             \\\n+  develop(bool, VerifyIdealNodeCount, false,                                \\\n@@ -134,1 +133,1 @@\n-  notproduct(bool, PrintIdealNodeCount, false,                              \\\n+  develop(bool, PrintIdealNodeCount, false,                                 \\\n@@ -143,1 +142,1 @@\n-  notproduct(bool, OptoBreakpointOSR, false,                                \\\n+  develop(bool, OptoBreakpointOSR, false,                                   \\\n@@ -146,1 +145,1 @@\n-  notproduct(uint64_t, BreakAtNode, 0,                                      \\\n+  develop(uint64_t, BreakAtNode, 0,                                         \\\n@@ -149,1 +148,1 @@\n-  notproduct(bool, OptoBreakpointC2R, false,                                \\\n+  develop(bool, OptoBreakpointC2R, false,                                   \\\n@@ -152,1 +151,1 @@\n-  notproduct(bool, OptoNoExecute, false,                                    \\\n+  develop(bool, OptoNoExecute, false,                                       \\\n@@ -155,1 +154,1 @@\n-  notproduct(bool, PrintOptoStatistics, false,                              \\\n+  develop(bool, PrintOptoStatistics, false,                                 \\\n@@ -164,1 +163,1 @@\n-  notproduct(bool, PrintFrameConverterAssembly, false,                      \\\n+  develop(bool, PrintFrameConverterAssembly, false,                         \\\n@@ -167,1 +166,1 @@\n-  notproduct(bool, PrintParseStatistics, false,                             \\\n+  develop(bool, PrintParseStatistics, false,                                \\\n@@ -170,1 +169,1 @@\n-  notproduct(bool, PrintOptoPeephole, false,                                \\\n+  develop(bool, PrintOptoPeephole, false,                                   \\\n@@ -195,1 +194,1 @@\n-  notproduct(bool, TraceSuperWordLoopUnrollAnalysis, false,                 \\\n+  develop(bool, TraceSuperWordLoopUnrollAnalysis, false,                    \\\n@@ -224,1 +223,1 @@\n-  notproduct(bool, TraceProfileTripCount, false,                            \\\n+  develop(bool, TraceProfileTripCount, false,                               \\\n@@ -281,1 +280,1 @@\n-  notproduct(bool, VerifyGraphEdges , false,                                \\\n+  develop(bool, VerifyGraphEdges , false,                                   \\\n@@ -284,1 +283,1 @@\n-  notproduct(bool, VerifyDUIterators, true,                                 \\\n+  develop(bool, VerifyDUIterators, true,                                    \\\n@@ -287,1 +286,1 @@\n-  notproduct(bool, VerifyHashTableKeys, true,                               \\\n+  develop(bool, VerifyHashTableKeys, true,                                  \\\n@@ -290,1 +289,1 @@\n-  notproduct(bool, VerifyRegisterAllocator , false,                         \\\n+  develop(bool, VerifyRegisterAllocator , false,                            \\\n@@ -305,1 +304,1 @@\n-  notproduct(bool, TraceOptoPipelining, false,                              \\\n+  develop(bool, TraceOptoPipelining, false,                                 \\\n@@ -308,1 +307,1 @@\n-  notproduct(bool, TraceOptoOutput, false,                                  \\\n+  develop(bool, TraceOptoOutput, false,                                     \\\n@@ -324,1 +323,1 @@\n-  notproduct(bool, TracePartialPeeling, false,                              \\\n+  develop(bool, TracePartialPeeling, false,                                 \\\n@@ -336,1 +335,1 @@\n-  notproduct(bool, TraceLoopUnswitching, false,                             \\\n+  develop(bool, TraceLoopUnswitching, false,                                \\\n@@ -351,1 +350,1 @@\n-  notproduct(bool, TraceSuperWord, false,                                   \\\n+  develop(bool, TraceSuperWord, false,                                      \\\n@@ -354,1 +353,1 @@\n-  notproduct(bool, TraceNewVectors, false,                                  \\\n+  develop(bool, TraceNewVectors, false,                                     \\\n@@ -364,1 +363,1 @@\n-  notproduct(bool, PrintIdealGraph, false,                                  \\\n+  develop(bool, PrintIdealGraph, false,                                     \\\n@@ -368,1 +367,1 @@\n-  notproduct(intx, PrintIdealGraphLevel, 0,                                 \\\n+  develop(intx, PrintIdealGraphLevel, 0,                                    \\\n@@ -377,1 +376,1 @@\n-  notproduct(intx, PrintIdealGraphPort, 4444,                               \\\n+  develop(intx, PrintIdealGraphPort, 4444,                                  \\\n@@ -381,1 +380,1 @@\n-  notproduct(ccstr, PrintIdealGraphAddress, \"127.0.0.1\",                    \\\n+  develop(ccstr, PrintIdealGraphAddress, \"127.0.0.1\",                       \\\n@@ -384,1 +383,1 @@\n-  notproduct(ccstr, PrintIdealGraphFile, nullptr,                           \\\n+  develop(ccstr, PrintIdealGraphFile, nullptr,                              \\\n@@ -452,1 +451,1 @@\n-  notproduct(bool, PrintLockStatistics, false,                              \\\n+  develop(bool, PrintLockStatistics, false,                                 \\\n@@ -458,1 +457,1 @@\n-  notproduct(bool, PrintEliminateLocks, false,                              \\\n+  develop(bool, PrintEliminateLocks, false,                                 \\\n@@ -477,1 +476,1 @@\n-  notproduct(bool, TraceReduceAllocationMerges, false,                      \\\n+  develop(bool, TraceReduceAllocationMerges, false,                         \\\n@@ -493,1 +492,1 @@\n-  notproduct(bool, PrintEscapeAnalysis, false,                              \\\n+  develop(bool, PrintEscapeAnalysis, false,                                 \\\n@@ -499,1 +498,1 @@\n-  notproduct(bool, PrintEliminateAllocations, false,                        \\\n+  develop(bool, PrintEliminateAllocations, false,                           \\\n@@ -513,1 +512,1 @@\n-  notproduct(bool, PrintOptimizePtrCompare, false,                          \\\n+  develop(bool, PrintOptimizePtrCompare, false,                             \\\n@@ -516,1 +515,1 @@\n-  notproduct(bool, VerifyConnectionGraph , true,                            \\\n+  develop(bool, VerifyConnectionGraph , true,                               \\\n@@ -522,1 +521,1 @@\n-  notproduct(bool, PrintOptimizeStringConcat, false,                        \\\n+  develop(bool, PrintOptimizeStringConcat, false,                           \\\n@@ -583,1 +582,1 @@\n-  notproduct(bool, TracePhaseCCP, false,                                    \\\n+  develop(bool, TracePhaseCCP, false,                                       \\\n@@ -617,1 +616,1 @@\n-  notproduct(bool, VerifyLoopOptimizations, false,                          \\\n+  develop(bool, VerifyLoopOptimizations, false,                             \\\n@@ -633,1 +632,1 @@\n-  notproduct(bool, TraceCISCSpill, false,                                   \\\n+  develop(bool, TraceCISCSpill, false,                                      \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":42,"deletions":43,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2712,1 +2712,12 @@\n-    switch (C->static_subtype_check(superk, subk)) {\n+    \/\/\n+    \/\/ Do not skip the static sub type check with StressReflectiveCode during\n+    \/\/ parsing (i.e. with ExpandSubTypeCheckAtParseTime) because the\n+    \/\/ associated CheckCastNodePP could already be folded when the type\n+    \/\/ system can prove it's an impossible type. Therefore, we should also\n+    \/\/ do the static sub type check here to ensure control is folded as well.\n+    \/\/ Otherwise, the graph is left in a broken state.\n+    \/\/ At macro expansion, we would have already folded the SubTypeCheckNode\n+    \/\/ being expanded here because we always perform the static sub type\n+    \/\/ check in SubTypeCheckNode::sub() regardless of whether\n+    \/\/ StressReflectiveCode is set or not.\n+    switch (C->static_subtype_check(superk, subk, !ExpandSubTypeCheckAtParseTime)) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -4330,1 +4330,1 @@\n-    \/\/ Bail out if length is negative.\n+    \/\/ Bail out if length is negative (i.e., if start > end).\n@@ -4336,0 +4336,4 @@\n+    \/\/ Bail out if start is larger than the original length\n+    Node* orig_tail = _gvn.transform(new SubINode(orig_length, start));\n+    generate_negative_guard(orig_tail, bailout, &orig_tail);\n+\n@@ -4345,2 +4349,1 @@\n-      \/\/ The answer is MinI(orig_length - start, length).\n-      Node* orig_tail = _gvn.transform(new SubINode(orig_length, start));\n+      \/\/ The answer is MinI(orig_tail, length).\n@@ -4394,1 +4397,1 @@\n-        ArrayCopyNode* ac = ArrayCopyNode::make(this, true, original, start, newcopy, intcon(0), moved, true, false,\n+        ArrayCopyNode* ac = ArrayCopyNode::make(this, true, original, start, newcopy, intcon(0), moved, true, true,\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -368,1 +368,2 @@\n-IfProjNode* PhaseIdealLoop::clone_assertion_predicate_for_unswitched_loops(Node* iff, IfProjNode* predicate,\n+IfProjNode* PhaseIdealLoop::clone_assertion_predicate_for_unswitched_loops(IfNode* template_assertion_predicate,\n+                                                                           IfProjNode* predicate,\n@@ -371,3 +372,5 @@\n-  Node* bol = create_bool_from_template_assertion_predicate(iff, nullptr, nullptr, parse_predicate_proj);\n-  IfProjNode* if_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, iff->Opcode(), false);\n-  _igvn.replace_input_of(if_proj->in(0), 1, bol);\n+  TemplateAssertionPredicateExpression template_assertion_predicate_expression(\n+      template_assertion_predicate->in(1)->as_Opaque4());\n+  Opaque4Node* cloned_opaque4_node = template_assertion_predicate_expression.clone(parse_predicate_proj, this);\n+  IfProjNode* if_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, template_assertion_predicate->Opcode(), false);\n+  _igvn.replace_input_of(if_proj->in(0), 1, cloned_opaque4_node);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/predicates.hpp\"\n@@ -1662,1 +1663,1 @@\n-  IfProjNode* clone_assertion_predicate_for_unswitched_loops(Node* iff, IfProjNode* predicate,\n+  IfProjNode* clone_assertion_predicate_for_unswitched_loops(IfNode* template_assertion_predicate, IfProjNode* predicate,\n@@ -1676,0 +1677,6 @@\n+  Node* clone_and_register(Node* n, Node* ctrl) {\n+    n = n->clone();\n+    register_new_node(n, ctrl);\n+    return n;\n+  }\n+\n@@ -1909,0 +1916,2 @@\n+  void clone_data_nodes_and_transform_opaque_loop_nodes(const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+                                                        Node* new_ctrl);\n@@ -1910,0 +1919,1 @@\n+  void transform_opaque_node(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* node);\n@@ -1920,0 +1930,13 @@\n+\n+  \/\/ Create a copy of the data nodes provided to the constructor by doing the following:\n+  \/\/ Clone all non-OpaqueLoop* nodes and rewire them to create an identical subgraph copy. For the OpaqueLoop* nodes,\n+  \/\/ apply the provided transformation strategy and include the transformed node into the subgraph copy to get a complete\n+  \/\/ \"cloned-and-transformed\" graph copy. For all newly cloned nodes (which could also be new OpaqueLoop* nodes), set\n+  \/\/ `new_ctrl` as ctrl.\n+  const OrigToNewHashtable& clone_with_opaque_loop_transform_strategy(\n+      const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+      Node* new_ctrl) {\n+    clone_data_nodes_and_transform_opaque_loop_nodes(transform_strategy, new_ctrl);\n+    rewire_clones_to_cloned_inputs();\n+    return _orig_to_new;\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -4505,1 +4505,1 @@\n-\/\/ Clone the given node and set it up properly. Set `new_ctrl` as ctrl.\n+\/\/ Clone the given node and set it up properly. Set 'new_ctrl' as ctrl.\n@@ -4526,0 +4526,27 @@\n+\n+\/\/ Clone all non-OpaqueLoop* nodes and apply the provided transformation strategy for OpaqueLoop* nodes.\n+\/\/ Set 'new_ctrl' as ctrl for all cloned non-OpaqueLoop* nodes.\n+void DataNodeGraph::clone_data_nodes_and_transform_opaque_loop_nodes(\n+    const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+    Node* new_ctrl) {\n+  for (uint i = 0; i < _data_nodes.size(); i++) {\n+    Node* data_node = _data_nodes[i];\n+    if (data_node->is_Opaque1()) {\n+      transform_opaque_node(transform_strategy, data_node);\n+    } else {\n+      clone(data_node, new_ctrl);\n+    }\n+  }\n+}\n+\n+void DataNodeGraph::transform_opaque_node(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* node) {\n+  Node* transformed_node;\n+  if (node->is_OpaqueLoopInit()) {\n+    transformed_node = transform_strategy.transform_opaque_init(node->as_OpaqueLoopInit());\n+  } else {\n+    assert(node->is_OpaqueLoopStride(), \"must be OpaqueLoopStrideNode\");\n+    transformed_node = transform_strategy.transform_opaque_stride(node->as_OpaqueLoopStride());\n+  }\n+  \/\/ Add an orig->new mapping to correctly update the inputs of the copied graph in rewire_clones_to_cloned_inputs().\n+  _orig_to_new.put(node, transformed_node);\n+}\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1269,1 +1269,1 @@\n-                       true, !ac->is_copyofrange());\n+                       true, ac->has_negative_length_guard());\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -137,0 +137,3 @@\n+class OpaqueLoopInitNode;\n+class OpaqueLoopStrideNode;\n+class Opaque4Node;\n@@ -789,3 +792,6 @@\n-    DEFINE_CLASS_ID(Move,     Node, 17)\n-    DEFINE_CLASS_ID(LShift,   Node, 18)\n-    DEFINE_CLASS_ID(Neg,      Node, 19)\n+      DEFINE_CLASS_ID(OpaqueLoopInit, Opaque1, 0)\n+      DEFINE_CLASS_ID(OpaqueLoopStride, Opaque1, 1)\n+    DEFINE_CLASS_ID(Opaque4,  Node, 17)\n+    DEFINE_CLASS_ID(Move,     Node, 18)\n+    DEFINE_CLASS_ID(LShift,   Node, 19)\n+    DEFINE_CLASS_ID(Neg,      Node, 20)\n@@ -958,0 +964,3 @@\n+  DEFINE_CLASS_QUERY(Opaque4)\n+  DEFINE_CLASS_QUERY(OpaqueLoopInit)\n+  DEFINE_CLASS_QUERY(OpaqueLoopStride)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    init_class_id(Class_OpaqueLoopInit);\n@@ -70,0 +71,1 @@\n+    init_class_id(Class_OpaqueLoopStride);\n@@ -123,0 +125,1 @@\n+    init_class_id(Class_Opaque4);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"opto\/loopnode.hpp\"\n+#include \"opto\/node.hpp\"\n@@ -150,0 +152,124 @@\n+\n+\/\/ This strategy clones the OpaqueLoopInit and OpaqueLoopStride nodes.\n+class CloneStrategy : public TransformStrategyForOpaqueLoopNodes {\n+  PhaseIdealLoop* const _phase;\n+  Node* const _new_ctrl;\n+\n+ public:\n+  CloneStrategy(PhaseIdealLoop* phase, Node* new_ctrl)\n+      : _phase(phase),\n+        _new_ctrl(new_ctrl) {}\n+  NONCOPYABLE(CloneStrategy);\n+\n+  Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) const override {\n+    return _phase->clone_and_register(opaque_init, _new_ctrl)->as_OpaqueLoopInit();\n+  }\n+\n+  Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) const override {\n+    return _phase->clone_and_register(opaque_stride, _new_ctrl)->as_OpaqueLoopStride();\n+  }\n+};\n+\n+\/\/ Creates an identical clone of this Template Assertion Predicate Expression (i.e.cloning all nodes from the Opaque4Node\n+\/\/ to and including the OpaqueLoop* nodes). The cloned nodes are rewired to reflect the same graph structure as found for\n+\/\/ this Template Assertion Predicate Expression. The cloned nodes get 'new_ctrl' as ctrl. There is no other update done\n+\/\/ for the cloned nodes. Return the newly cloned Opaque4Node.\n+Opaque4Node* TemplateAssertionPredicateExpression::clone(Node* new_ctrl, PhaseIdealLoop* phase) {\n+  CloneStrategy clone_init_and_stride_strategy(phase, new_ctrl);\n+  return clone(clone_init_and_stride_strategy, new_ctrl, phase);\n+}\n+\n+\/\/ Class to collect data nodes from a source to target nodes by following the inputs of the source node recursively.\n+\/\/ The class takes a node filter to decide which input nodes to follow and a target node predicate to start backtracking\n+\/\/ from. All nodes found on all paths from source->target(s) are returned in a Unique_Node_List (without duplicates).\n+class DataNodesOnPathsToTargets : public StackObj {\n+  typedef bool (*NodeCheck)(const Node*);\n+\n+  \/\/ Node filter function to decide if we should process a node or not while searching for targets.\n+  NodeCheck _node_filter;\n+  \/\/ Function to decide if a node is a target node (i.e. where we should start backtracking). This check should also\n+  \/\/ trivially pass the _node_filter.\n+  NodeCheck _is_target_node;\n+  \/\/ The resulting node collection of all nodes on paths from source->target(s).\n+  Unique_Node_List _collected_nodes;\n+  \/\/ List to track all nodes visited on the search for target nodes starting at a start node. These nodes are then used\n+  \/\/ in backtracking to find the nodes actually being on a start->target(s) path. This list also serves as visited set\n+  \/\/ to avoid double visits of a node which could happen with diamonds shapes.\n+  Unique_Node_List _nodes_to_visit;\n+\n+ public:\n+  DataNodesOnPathsToTargets(NodeCheck node_filter, NodeCheck is_target_node)\n+      : _node_filter(node_filter),\n+        _is_target_node(is_target_node) {}\n+  NONCOPYABLE(DataNodesOnPathsToTargets);\n+\n+  \/\/ Collect all input nodes from 'start_node'->target(s) by applying the node filter to discover new input nodes and\n+  \/\/ the target node predicate to stop discovering more inputs and start backtracking. The implementation is done\n+  \/\/ with two BFS traversal: One to collect the target nodes (if any) and one to backtrack from the target nodes to\n+  \/\/ find all other nodes on the start->target(s) paths.\n+  const Unique_Node_List& collect(Node* start_node) {\n+    assert(_collected_nodes.size() == 0 && _nodes_to_visit.size() == 0, \"should not call this method twice in a row\");\n+    assert(!_is_target_node(start_node), \"no trivial paths where start node is also a target node\");\n+\n+    collect_target_nodes(start_node);\n+    backtrack_from_target_nodes();\n+    assert(_collected_nodes.size() == 0 || _collected_nodes.member(start_node),\n+           \"either target node predicate was never true or must find start node again when doing backtracking work\");\n+    return _collected_nodes;\n+  }\n+\n+ private:\n+  \/\/ Do a BFS from the start_node to collect all target nodes. We can then do another BFS from the target nodes to\n+  \/\/ find all nodes on the paths from start->target(s).\n+  \/\/ Note: We could do a single DFS pass to search targets and backtrack in one walk. But this is much more complex.\n+  \/\/       Given that the typical Template Assertion Predicate Expression only consists of a few nodes, we aim for\n+  \/\/       simplicity here.\n+  void collect_target_nodes(Node* start_node) {\n+    _nodes_to_visit.push(start_node);\n+    for (uint i = 0; i < _nodes_to_visit.size(); i++) {\n+      Node* next = _nodes_to_visit[i];\n+      for (uint j = 1; j < next->req(); j++) {\n+        Node* input = next->in(j);\n+        if (_is_target_node(input)) {\n+          assert(_node_filter(input), \"must also pass node filter\");\n+          _collected_nodes.push(input);\n+        } else if (_node_filter(input)) {\n+          _nodes_to_visit.push(input);\n+        }\n+      }\n+    }\n+  }\n+\n+  \/\/ Backtrack from all previously collected target nodes by using the visited set of the start->target(s) search. If no\n+  \/\/ node was collected in the first place (i.e. target node predicate was never true), then nothing needs to be done.\n+  void backtrack_from_target_nodes() {\n+    for (uint i = 0; i < _collected_nodes.size(); i++) {\n+      Node* node_on_path = _collected_nodes[i];\n+      for (DUIterator_Fast jmax, j = node_on_path->fast_outs(jmax); j < jmax; j++) {\n+        Node* use = node_on_path->fast_out(j);\n+        if (_nodes_to_visit.member(use)) {\n+          \/\/ use must be on a path from start->target(s) because it was also visited in the first BFS starting from\n+          \/\/ the start node.\n+          _collected_nodes.push(use);\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+\/\/ Clones this Template Assertion Predicate Expression and applies the given strategy to transform the OpaqueLoop* nodes.\n+Opaque4Node* TemplateAssertionPredicateExpression::clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy,\n+                                                         Node* new_ctrl, PhaseIdealLoop* phase) {\n+  ResourceMark rm;\n+  auto is_opaque_loop_node = [](const Node* node) {\n+    return node->is_Opaque1();\n+  };\n+  DataNodesOnPathsToTargets data_nodes_on_path_to_targets(TemplateAssertionPredicateExpression::maybe_contains,\n+                                                          is_opaque_loop_node);\n+  const Unique_Node_List& collected_nodes = data_nodes_on_path_to_targets.collect(_opaque4_node);\n+  DataNodeGraph data_node_graph(collected_nodes, phase);\n+  const OrigToNewHashtable& orig_to_new = data_node_graph.clone_with_opaque_loop_transform_strategy(transform_strategy, new_ctrl);\n+  assert(orig_to_new.contains(_opaque4_node), \"must exist\");\n+  Node* opaque4_clone = *orig_to_new.get(_opaque4_node);\n+  return opaque4_clone->as_Opaque4();\n+}\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/opaquenode.hpp\"\n@@ -266,0 +267,45 @@\n+\/\/ Interface to transform OpaqueLoopInit and OpaqueLoopStride nodes of a Template Assertion Predicate Expression.\n+class TransformStrategyForOpaqueLoopNodes : public StackObj {\n+ public:\n+  virtual Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) const = 0;\n+  virtual Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) const = 0;\n+};\n+\n+\/\/ A Template Assertion Predicate Expression represents the Opaque4Node for the initial value or the last value of a\n+\/\/ Template Assertion Predicate and all the nodes up to and including the OpaqueLoop* nodes.\n+class TemplateAssertionPredicateExpression : public StackObj {\n+  Opaque4Node* _opaque4_node;\n+\n+ public:\n+  explicit TemplateAssertionPredicateExpression(Opaque4Node* opaque4_node) : _opaque4_node(opaque4_node) {}\n+\n+ private:\n+  Opaque4Node* clone(const TransformStrategyForOpaqueLoopNodes& transform_strategy, Node* new_ctrl, PhaseIdealLoop* phase);\n+\n+ public:\n+  \/\/ Is 'n' a node that could be part of a Template Assertion Predicate Expression (i.e. could be found on the input\n+  \/\/ chain of a Template Assertion Predicate Opaque4Node up to and including the OpaqueLoop* nodes)?\n+  static bool maybe_contains(const Node* n) {\n+    const int opcode = n->Opcode();\n+    return (opcode == Op_OpaqueLoopInit ||\n+            opcode == Op_OpaqueLoopStride ||\n+            n->is_Bool() ||\n+            n->is_Cmp() ||\n+            opcode == Op_AndL ||\n+            opcode == Op_OrL ||\n+            opcode == Op_RShiftL ||\n+            opcode == Op_LShiftL ||\n+            opcode == Op_LShiftI ||\n+            opcode == Op_AddL ||\n+            opcode == Op_AddI ||\n+            opcode == Op_MulL ||\n+            opcode == Op_MulI ||\n+            opcode == Op_SubL ||\n+            opcode == Op_SubI ||\n+            opcode == Op_ConvI2L ||\n+            opcode == Op_CastII);\n+  }\n+\n+  Opaque4Node* clone(Node* new_ctrl, PhaseIdealLoop* phase);\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"opto\/predicates.hpp\"\n@@ -104,2 +105,3 @@\n-        Node* bol = create_bool_from_template_assertion_predicate(m, nullptr, nullptr, m->in(0));\n-        _igvn.replace_input_of(m, 1, bol);\n+        TemplateAssertionPredicateExpression template_assertion_predicate_expression(m->in(1)->as_Opaque4());\n+        Opaque4Node* cloned_opaque4_node = template_assertion_predicate_expression.clone(m->in(0), this);\n+        _igvn.replace_input_of(m, 1, cloned_opaque4_node);\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-  _packset(arena(), 8,  0, nullptr),                        \/\/ packs for the current block\n@@ -49,1 +48,5 @@\n-  _race_possible(false),                                    \/\/ cases where SDMU is true\n+  _pairset(&_arena, _vloop_analyzer),\n+  _packset(&_arena, _vloop_analyzer\n+           NOT_PRODUCT(COMMA is_trace_superword_packset())\n+           NOT_PRODUCT(COMMA is_trace_superword_rejections())\n+           ),\n@@ -457,1 +460,1 @@\n-  if (_packset.length() == 0) {\n+  if (_pairset.is_empty()) {\n@@ -467,1 +470,1 @@\n-  extend_packset_with_more_pairs_by_following_use_and_def();\n+  extend_pairset_with_more_pairs_by_following_use_and_def();\n@@ -471,2 +474,0 @@\n-  construct_my_pack_map();\n-\n@@ -478,1 +479,0 @@\n-  \/\/ Now we only remove packs:\n@@ -534,1 +534,1 @@\n-    VPointer align_to_ref_p(mem_ref, _vloop);\n+    const VPointer& align_to_ref_p = vpointer(mem_ref);\n@@ -540,1 +540,1 @@\n-        VPointer p2(s, _vloop);\n+        const VPointer& p2 = vpointer(s);\n@@ -558,3 +558,0 @@\n-            Node_List* pair = new Node_List();\n-            pair->push(s1);\n-            pair->push(s2);\n@@ -562,1 +559,1 @@\n-              _packset.append(pair);\n+              _pairset.add_pair(s1, s2);\n@@ -578,2 +575,2 @@\n-  assert(_packset.is_empty() || align_to_mem_ref != nullptr,\n-         \"packset empty or we find the alignment reference\");\n+  assert(_pairset.is_empty() || align_to_mem_ref != nullptr,\n+         \"pairset empty or we find the alignment reference\");\n@@ -584,1 +581,1 @@\n-    print_packset();\n+    _pairset.print();\n@@ -599,1 +596,1 @@\n-    VPointer p1(s1, _vloop);\n+    const VPointer& p1 = vpointer(s1);\n@@ -603,1 +600,1 @@\n-        VPointer p2(s2, _vloop);\n+        const VPointer& p2 = vpointer(s2);\n@@ -624,1 +621,1 @@\n-      VPointer p(s, _vloop);\n+      const VPointer& p = vpointer(s);\n@@ -647,1 +644,1 @@\n-        VPointer p(s, _vloop);\n+        const VPointer& p = vpointer(s);\n@@ -720,1 +717,1 @@\n-  VPointer align_to_ref_p(mem_ref, _vloop);\n+  const VPointer& align_to_ref_p = vpointer(mem_ref);\n@@ -846,1 +843,1 @@\n-      if (!exists_at(s1, 0) && !exists_at(s2, 1)) {\n+      if (!_pairset.is_left(s1) && !_pairset.is_right(s2)) {\n@@ -862,12 +859,0 @@\n-\/\/------------------------------exists_at---------------------------\n-\/\/ Does s exist in a pack at position pos?\n-bool SuperWord::exists_at(Node* s, uint pos) {\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* p = _packset.at(i);\n-    if (p->at(pos) == s) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n@@ -876,1 +861,1 @@\n-bool SuperWord::are_adjacent_refs(Node* s1, Node* s2) {\n+bool SuperWord::are_adjacent_refs(Node* s1, Node* s2) const {\n@@ -893,2 +878,2 @@\n-  VPointer p1(s1->as_Mem(), _vloop);\n-  VPointer p2(s2->as_Mem(), _vloop);\n+  const VPointer& p1 = vpointer(s1->as_Mem());\n+  const VPointer& p2 = vpointer(s2->as_Mem());\n@@ -1027,1 +1012,1 @@\n-bool VLoopReductions::is_marked_reduction_pair(Node* s1, Node* s2) const {\n+bool VLoopReductions::is_marked_reduction_pair(const Node* s1, const Node* s2) const {\n@@ -1052,2 +1037,2 @@\n-\/\/ Extend packset by following use->def and def->use links from pack members.\n-void SuperWord::extend_packset_with_more_pairs_by_following_use_and_def() {\n+\/\/ Extend pairset by following use->def and def->use links from pair members.\n+void SuperWord::extend_pairset_with_more_pairs_by_following_use_and_def() {\n@@ -1056,1 +1041,0 @@\n-    packset_sort(_packset.length());\n@@ -1058,4 +1042,6 @@\n-    for (int i = 0; i < _packset.length(); i++) {\n-      Node_List* p = _packset.at(i);\n-      changed |= follow_use_defs(p);\n-      changed |= follow_def_uses(p);\n+    \/\/ Iterate the pairs in insertion order.\n+    for (int i = 0; i < _pairset.length(); i++) {\n+      Node* left  = _pairset.left_at_in_insertion_order(i);\n+      Node* right = _pairset.right_at_in_insertion_order(i);\n+      changed |= extend_pairset_with_more_pairs_by_following_def(left, right);\n+      changed |= extend_pairset_with_more_pairs_by_following_use(left, right);\n@@ -1065,5 +1051,11 @@\n-  if (_race_possible) {\n-    for (int i = 0; i < _packset.length(); i++) {\n-      Node_List* p = _packset.at(i);\n-      order_def_uses(p);\n-    }\n+  \/\/ During extend_pairset_with_more_pairs_by_following_use, we may have re-ordered the\n+  \/\/ inputs of some nodes, when calling order_inputs_of_uses_to_match_def_pair. If a def\n+  \/\/ node has multiple uses, we may have re-ordered some of the inputs one use after\n+  \/\/ packing another use with the old order. Now that we have all pairs, we must ensure\n+  \/\/ that the order between the pairs is matching again. Since the PairSetIterator visits\n+  \/\/ all pair-chains from left-to-right, we essencially impose the order of the first\n+  \/\/ element on all other elements in the pair-chain.\n+  for (PairSetIterator pair(_pairset); !pair.done(); pair.next()) {\n+    Node* left  = pair.left();\n+    Node* right = pair.right();\n+    order_inputs_of_all_use_pairs_to_match_def_pair(left, right);\n@@ -1074,2 +1066,2 @@\n-    tty->print_cr(\"\\nAfter Superword::extend_packset_with_more_pairs_by_following_use_and_def\");\n-    print_packset();\n+    tty->print_cr(\"\\nAfter Superword::extend_pairset_with_more_pairs_by_following_use_and_def\");\n+    _pairset.print();\n@@ -1096,6 +1088,2 @@\n-\/\/------------------------------follow_use_defs---------------------------\n-\/\/ Extend the packset by visiting operand definitions of nodes in pack p\n-bool SuperWord::follow_use_defs(Node_List* p) {\n-  assert(p->size() == 2, \"just checking\");\n-  Node* s1 = p->at(0);\n-  Node* s2 = p->at(1);\n+bool SuperWord::extend_pairset_with_more_pairs_by_following_def(Node* s1, Node* s2) {\n+  assert(_pairset.is_pair(s1, s2), \"(s1, s2) must be a pair\");\n@@ -1109,1 +1097,1 @@\n-    tty->print_cr(\"SuperWord::follow_use_defs: s1 %d, align %d\",\n+    tty->print_cr(\"SuperWord::extend_pairset_with_more_pairs_by_following_def: s1 %d, align %d\",\n@@ -1126,5 +1114,2 @@\n-      if (est_savings(t1, t2) >= 0) {\n-        Node_List* pair = new Node_List();\n-        pair->push(t1);\n-        pair->push(t2);\n-        _packset.append(pair);\n+      if (estimate_cost_savings_when_packing_as_pair(t1, t2) >= 0) {\n+        _pairset.add_pair(t1, t2);\n@@ -1133,1 +1118,1 @@\n-          tty->print_cr(\"SuperWord::follow_use_defs: set_alignment(%d, %d, %d)\",\n+          tty->print_cr(\"SuperWord::extend_pairset_with_more_pairs_by_following_def: set_alignment(%d, %d, %d)\",\n@@ -1145,7 +1130,5 @@\n-\/\/------------------------------follow_def_uses---------------------------\n-\/\/ Extend the packset by visiting uses of nodes in pack p\n-bool SuperWord::follow_def_uses(Node_List* p) {\n-  bool changed = false;\n-  Node* s1 = p->at(0);\n-  Node* s2 = p->at(1);\n-  assert(p->size() == 2, \"just checking\");\n+\/\/ Note: we only extend with a single pair (the one with most savings) for every call. Since we keep\n+\/\/       calling this method as long as there are some changes, we will eventually pack all pairs that\n+\/\/       can be packed.\n+bool SuperWord::extend_pairset_with_more_pairs_by_following_use(Node* s1, Node* s2) {\n+  assert(_pairset.is_pair(s1, s2), \"(s1, s2) must be a pair\");\n@@ -1160,1 +1143,1 @@\n-    tty->print_cr(\"SuperWord::follow_def_uses: s1 %d, align %d\",\n+    tty->print_cr(\"SuperWord::extend_pairset_with_more_pairs_by_following_use: s1 %d, align %d\",\n@@ -1165,1 +1148,0 @@\n-  int num_s1_uses = 0;\n@@ -1170,1 +1152,0 @@\n-    num_s1_uses++;\n@@ -1182,2 +1163,1 @@\n-      if (!opnd_positions_match(s1, t1, s2, t2))\n-        continue;\n+      if (order_inputs_of_uses_to_match_def_pair(s1, s2, t1, t2) != PairOrderStatus::Ordered) { continue; }\n@@ -1187,1 +1167,1 @@\n-        int my_savings = est_savings(t1, t2);\n+        int my_savings = estimate_cost_savings_when_packing_as_pair(t1, t2);\n@@ -1197,3 +1177,0 @@\n-  if (num_s1_uses > 1) {\n-    _race_possible = true;\n-  }\n@@ -1201,4 +1178,1 @@\n-    Node_List* pair = new Node_List();\n-    pair->push(u1);\n-    pair->push(u2);\n-    _packset.append(pair);\n+    _pairset.add_pair(u1, u2);\n@@ -1207,1 +1181,1 @@\n-      tty->print_cr(\"SuperWord::follow_def_uses: set_alignment(%d, %d, %d)\",\n+      tty->print_cr(\"SuperWord::extend_pairset_with_more_pairs_by_following_use: set_alignment(%d, %d, %d)\",\n@@ -1212,1 +1186,1 @@\n-    changed = true;\n+    return true; \/\/ changed\n@@ -1214,1 +1188,1 @@\n-  return changed;\n+  return false; \/\/ no change\n@@ -1217,4 +1191,4 @@\n-\/\/------------------------------order_def_uses---------------------------\n-\/\/ For extended packsets, ordinally arrange uses packset by major component\n-void SuperWord::order_def_uses(Node_List* p) {\n-  Node* s1 = p->at(0);\n+\/\/ For a pair (def1, def2), find all use packs (use1, use2), and ensure that their inputs have an order\n+\/\/ that matches the (def1, def2) pair.\n+void SuperWord::order_inputs_of_all_use_pairs_to_match_def_pair(Node* def1, Node* def2) {\n+  assert(_pairset.is_pair(def1, def2), \"(def1, def2) must be a pair\");\n@@ -1222,1 +1196,1 @@\n-  if (s1->is_Store()) return;\n+  if (def1->is_Store()) return;\n@@ -1225,1 +1199,1 @@\n-  if (is_marked_reduction(s1)) return;\n+  if (is_marked_reduction(def1)) return;\n@@ -1227,2 +1201,2 @@\n-  for (DUIterator_Fast imax, i = s1->fast_outs(imax); i < imax; i++) {\n-    Node* t1 = s1->fast_out(i);\n+  for (DUIterator_Fast imax, i = def1->fast_outs(imax); i < imax; i++) {\n+    Node* use1 = def1->fast_out(i);\n@@ -1231,1 +1205,1 @@\n-    if (!t1->is_Add() && !t1->is_Mul() && !VectorNode::is_muladds2i(t1)) {\n+    if (!use1->is_Add() && !use1->is_Mul() && !VectorNode::is_muladds2i(use1)) {\n@@ -1235,18 +1209,5 @@\n-    \/\/ Now find t1's packset\n-    Node_List* p2 = nullptr;\n-    for (int j = 0; j < _packset.length(); j++) {\n-      p2 = _packset.at(j);\n-      Node* first = p2->at(0);\n-      if (t1 == first) {\n-        break;\n-      }\n-      p2 = nullptr;\n-    }\n-    \/\/ Arrange all sub components by the major component\n-    if (p2 != nullptr) {\n-      for (uint j = 1; j < p->size(); j++) {\n-        Node* d1 = p->at(j);\n-        Node* u1 = p2->at(j);\n-        opnd_positions_match(s1, t1, d1, u1);\n-      }\n-    }\n+    \/\/ Find pair (use1, use2)\n+    Node* use2 = _pairset.get_right_or_null_for(use1);\n+    if (use2 == nullptr) { break; }\n+\n+    order_inputs_of_uses_to_match_def_pair(def1, def2, use1, use2);\n@@ -1256,10 +1217,42 @@\n-\/\/---------------------------opnd_positions_match-------------------------\n-\/\/ Is the use of d1 in u1 at the same operand position as d2 in u2?\n-bool SuperWord::opnd_positions_match(Node* d1, Node* u1, Node* d2, Node* u2) {\n-  \/\/ check reductions to see if they are marshalled to represent the reduction\n-  \/\/ operator in a specified opnd\n-  if (is_marked_reduction(u1) && is_marked_reduction(u2)) {\n-    \/\/ ensure reductions have phis and reduction definitions feeding the 1st operand\n-    Node* first = u1->in(2);\n-    if (first->is_Phi() || is_marked_reduction(first)) {\n-      u1->swap_edges(1, 2);\n+\/\/ For a def-pair (def1, def2), and their use-nodes (use1, use2):\n+\/\/ Ensure that the input order of (use1, use2) matches the order of (def1, def2).\n+\/\/\n+\/\/ We have different cases:\n+\/\/\n+\/\/ 1. Reduction (use1, use2): must always reduce left-to-right. Make sure that we have pattern:\n+\/\/\n+\/\/    phi\/reduction x1  phi\/reduction x2                    phi\/reduction x1\n+\/\/                | |               | |    and hopefully:               | |\n+\/\/                use1              use2                                use1 x2\n+\/\/                                                                         | |\n+\/\/                                                                         use2\n+\/\/\n+\/\/ 2: Commutative operations, just as Add\/Mul and their subclasses: we can try to swap edges:\n+\/\/\n+\/\/     def1 x1   x2 def2           def1 x1   def2 x2\n+\/\/        | |     | |       ==>       | |       | |\n+\/\/        use1    use2                use1      use2\n+\/\/\n+\/\/ 3: MulAddS2I (use1, use2): we can try to swap edges:\n+\/\/\n+\/\/    (x1 * x2) + (x3 * x4)    ==>  3.a: (x2 * x1) + (x4 * x3)\n+\/\/                                  3.b: (x4 * x3) + (x2 * x1)\n+\/\/                                  3.c: (x3 * x4) + (x1 * x2)\n+\/\/\n+\/\/    Note: MulAddS2I with its 4 inputs is too complicated, if there is any mismatch, we always\n+\/\/          return PairOrderStatus::Unknown.\n+\/\/          Therefore, extend_pairset_with_more_pairs_by_following_use cannot extend to MulAddS2I,\n+\/\/          but there is a chance that extend_pairset_with_more_pairs_by_following_def can do it.\n+\/\/\n+\/\/ 4: Otherwise, check if the inputs of (use1, use2) already match (def1, def2), i.e. for all input indices i:\n+\/\/\n+\/\/    use1->in(i) == def1 || use2->in(i) == def2   ->    use1->in(i) == def1 && use2->in(i) == def2\n+\/\/\n+SuperWord::PairOrderStatus SuperWord::order_inputs_of_uses_to_match_def_pair(Node* def1, Node* def2, Node* use1, Node* use2) {\n+  assert(_pairset.is_pair(def1, def2), \"(def1, def2) must be a pair\");\n+\n+  \/\/ 1. Reduction\n+  if (is_marked_reduction(use1) && is_marked_reduction(use2)) {\n+    Node* use1_in2 = use1->in(2);\n+    if (use1_in2->is_Phi() || is_marked_reduction(use1_in2)) {\n+      use1->swap_edges(1, 2);\n@@ -1267,4 +1260,3 @@\n-    \/\/ ensure reductions have phis and reduction definitions feeding the 1st operand\n-    first = u2->in(2);\n-    if (first->is_Phi() || is_marked_reduction(first)) {\n-      u2->swap_edges(1, 2);\n+    Node* use2_in2 = use2->in(2);\n+    if (use2_in2->is_Phi() || is_marked_reduction(use2_in2)) {\n+      use2->swap_edges(1, 2);\n@@ -1272,1 +1264,1 @@\n-    return true;\n+    return PairOrderStatus::Ordered;\n@@ -1275,2 +1267,2 @@\n-  uint ct = u1->req();\n-  if (ct != u2->req()) return false;\n+  uint ct = use1->req();\n+  if (ct != use2->req()) { return PairOrderStatus::Unordered; };\n@@ -1280,2 +1272,2 @@\n-    for (i1++; i1 < ct; i1++) if (u1->in(i1) == d1) break;\n-    for (i2++; i2 < ct; i2++) if (u2->in(i2) == d2) break;\n+    for (i1++; i1 < ct; i1++) { if (use1->in(i1) == def1) { break; } }\n+    for (i2++; i2 < ct; i2++) { if (use2->in(i2) == def2) { break; } }\n@@ -1283,4 +1275,5 @@\n-      if ((i1 == (3-i2)) && (u2->is_Add() || u2->is_Mul())) {\n-        \/\/ Further analysis relies on operands position matching.\n-        u2->swap_edges(i1, i2);\n-      } else if (VectorNode::is_muladds2i(u2) && u1 != u2) {\n+      if ((i1 == (3-i2)) && (use2->is_Add() || use2->is_Mul())) {\n+        \/\/ 2. Commutative: swap edges, and hope the other position matches too.\n+        use2->swap_edges(i1, i2);\n+      } else if (VectorNode::is_muladds2i(use2) && use1 != use2) {\n+        \/\/ 3.a\/b: MulAddS2I.\n@@ -1288,2 +1281,2 @@\n-          u2->swap_edges(1, 2);\n-          u2->swap_edges(3, 4);\n+          use2->swap_edges(1, 2);\n+          use2->swap_edges(3, 4);\n@@ -1292,2 +1285,2 @@\n-          u2->swap_edges(2, 3);\n-          u2->swap_edges(1, 4);\n+          use2->swap_edges(2, 3);\n+          use2->swap_edges(1, 4);\n@@ -1295,1 +1288,1 @@\n-        return false; \/\/ Just swap the edges, the muladds2i nodes get packed in follow_use_defs\n+        return PairOrderStatus::Unknown;\n@@ -1297,1 +1290,2 @@\n-        return false;\n+        \/\/ 4. The inputs are not ordered, and we cannot do anything about it.\n+        return PairOrderStatus::Unordered;\n@@ -1299,4 +1293,5 @@\n-    } else if (i1 == i2 && VectorNode::is_muladds2i(u2) && u1 != u2) {\n-      u2->swap_edges(1, 3);\n-      u2->swap_edges(2, 4);\n-      return false; \/\/ Just swap the edges, the muladds2i nodes get packed in follow_use_defs\n+    } else if (i1 == i2 && VectorNode::is_muladds2i(use2) && use1 != use2) {\n+      \/\/ 3.c: MulAddS2I.\n+      use2->swap_edges(1, 3);\n+      use2->swap_edges(2, 4);\n+      return PairOrderStatus::Unknown;\n@@ -1305,1 +1300,3 @@\n-  return true;\n+\n+  \/\/ 4. All inputs match.\n+  return PairOrderStatus::Ordered;\n@@ -1308,3 +1305,2 @@\n-\/\/------------------------------est_savings---------------------------\n-\/\/ Estimate the savings from executing s1 and s2 as a pack\n-int SuperWord::est_savings(Node* s1, Node* s2) {\n+\/\/ Estimate the savings from executing s1 and s2 as a pair.\n+int SuperWord::estimate_cost_savings_when_packing_as_pair(const Node* s1, const Node* s2) const {\n@@ -1313,0 +1309,4 @@\n+  const int adjacent_profit = 2;\n+  auto pack_cost       = [&] (const int size) { return size; };\n+  auto unpack_cost     = [&] (const int size) { return size; };\n+\n@@ -1319,2 +1319,2 @@\n-        save_in += adjacent_profit(x1, x2);\n-      } else if (!in_packset(x1, x2)) {\n+        save_in += adjacent_profit;\n+      } else if (!_pairset.is_pair(x1, x2)) {\n@@ -1329,1 +1329,1 @@\n-  uint ct = 0;\n+  uint number_of_packed_use_pairs = 0;\n@@ -1332,12 +1332,17 @@\n-    Node* s1_use = s1->fast_out(i);\n-    for (int j = 0; j < _packset.length(); j++) {\n-      Node_List* p = _packset.at(j);\n-      if (p->at(0) == s1_use) {\n-        for (DUIterator_Fast kmax, k = s2->fast_outs(kmax); k < kmax; k++) {\n-          Node* s2_use = s2->fast_out(k);\n-          if (p->at(p->size()-1) == s2_use) {\n-            ct++;\n-            if (are_adjacent_refs(s1_use, s2_use)) {\n-              save_use += adjacent_profit(s1_use, s2_use);\n-            }\n-          }\n+    Node* use1 = s1->fast_out(i);\n+\n+    \/\/ Find pair (use1, use2)\n+    Node* use2 = _pairset.get_right_or_null_for(use1);\n+    if (use2 == nullptr) { continue; }\n+\n+    for (DUIterator_Fast kmax, k = s2->fast_outs(kmax); k < kmax; k++) {\n+      if (use2 == s2->fast_out(k)) {\n+        \/\/ We have pattern:\n+        \/\/\n+        \/\/   s1    s2\n+        \/\/    |    |\n+        \/\/ [use1, use2]\n+        \/\/\n+        number_of_packed_use_pairs++;\n+        if (are_adjacent_refs(use1, use2)) {\n+          save_use += adjacent_profit;\n@@ -1349,2 +1354,2 @@\n-  if (ct < s1->outcnt()) save_use += unpack_cost(1);\n-  if (ct < s2->outcnt()) save_use += unpack_cost(1);\n+  if (number_of_packed_use_pairs < s1->outcnt()) save_use += unpack_cost(1);\n+  if (number_of_packed_use_pairs < s2->outcnt()) save_use += unpack_cost(1);\n@@ -1355,6 +1360,1 @@\n-\/\/------------------------------costs---------------------------\n-int SuperWord::adjacent_profit(Node* s1, Node* s2) { return 2; }\n-int SuperWord::pack_cost(int ct)   { return ct; }\n-int SuperWord::unpack_cost(int ct) { return ct; }\n-\n-\/\/ Combine packs A and B with A.last == B.first into A.first..,A.last,B.second,..B.last\n+\/\/ Combine pairs (n1, n2), (n2, n3), ... into pack (n1, n2, n3 ...)\n@@ -1363,5 +1363,2 @@\n-  assert(!_packset.is_empty(), \"packset not empty\");\n-  for (int i = 0; i < _packset.length(); i++) {\n-    assert(_packset.at(i) != nullptr, \"no nullptr in packset\");\n-    assert(_packset.at(i)->size() == 2, \"all packs are pairs\");\n-  }\n+  assert(!_pairset.is_empty(), \"pairset not empty\");\n+  assert(_packset.is_empty(), \"packset not empty\");\n@@ -1370,19 +1367,15 @@\n-  bool changed = true;\n-  \/\/ Combine packs regardless max vector size.\n-  while (changed) {\n-    changed = false;\n-    for (int i = 0; i < _packset.length(); i++) {\n-      Node_List* p1 = _packset.at(i);\n-      if (p1 == nullptr) continue;\n-      \/\/ Because of sorting we can start at i + 1\n-      for (int j = i + 1; j < _packset.length(); j++) {\n-        Node_List* p2 = _packset.at(j);\n-        if (p2 == nullptr) continue;\n-        if (p1->at(p1->size()-1) == p2->at(0)) {\n-          for (uint k = 1; k < p2->size(); k++) {\n-            p1->push(p2->at(k));\n-          }\n-          _packset.at_put(j, nullptr);\n-          changed = true;\n-        }\n-      }\n+  \/\/ Iterate pair-chain by pair-chain, each from left-most to right-most.\n+  Node_List* pack = nullptr;\n+  for (PairSetIterator pair(_pairset); !pair.done(); pair.next()) {\n+    Node* left  = pair.left();\n+    Node* right = pair.right();\n+    if (_pairset.is_left_in_a_left_most_pair(left)) {\n+      assert(pack == nullptr, \"no unfinished pack\");\n+      pack = new (arena()) Node_List(arena());\n+      pack->push(left);\n+    }\n+    assert(pack != nullptr, \"must have unfinished pack\");\n+    pack->push(right);\n+    if (_pairset.is_right_in_a_right_most_pair(right)) {\n+      _packset.add_pack(pack);\n+      pack = nullptr;\n@@ -1391,3 +1384,1 @@\n-\n-  \/\/ Remove all nullptr from packset\n-  compress_packset();\n+  assert(pack == nullptr, \"no unfinished pack\");\n@@ -1400,1 +1391,1 @@\n-    print_packset();\n+    _packset.print();\n@@ -1405,3 +1396,3 @@\n-SuperWord::SplitStatus SuperWord::split_pack(const char* split_name,\n-                                             Node_List* pack,\n-                                             SplitTask task)\n+SplitStatus PackSet::split_pack(const char* split_name,\n+                                Node_List* pack,\n+                                SplitTask task)\n@@ -1419,1 +1410,1 @@\n-        tty->print_cr(\"WARNING: Removed pack during split: %s:\", task.message());\n+        tty->print_cr(\"WARNING: Removed pack: %s:\", task.message());\n@@ -1423,4 +1414,1 @@\n-    for (uint i = 0; i < pack_size; i++) {\n-      Node* n = pack->at(i);\n-      set_my_pack(n, nullptr);\n-    }\n+    unmap_all_nodes_in_pack(pack);\n@@ -1456,4 +1444,1 @@\n-    for (uint i = 0; i < pack_size; i++) {\n-      Node* n = pack->at(i);\n-      set_my_pack(n, nullptr);\n-    }\n+    unmap_all_nodes_in_pack(pack);\n@@ -1467,1 +1452,1 @@\n-    set_my_pack(n, nullptr);\n+    unmap_node_in_pack(n);\n@@ -1483,1 +1468,1 @@\n-    set_my_pack(n, nullptr);\n+    unmap_node_in_pack(n);\n@@ -1501,1 +1486,1 @@\n-    set_my_pack(n, new_pack);\n+    remap_node_in_pack(n, new_pack);\n@@ -1514,2 +1499,2 @@\n-void SuperWord::split_packs(const char* split_name,\n-                            SplitStrategy strategy) {\n+void PackSet::split_packs(const char* split_name,\n+                          SplitStrategy strategy) {\n@@ -1520,2 +1505,2 @@\n-    for (int i = 0; i < _packset.length(); i++) {\n-      Node_List* pack = _packset.at(i);\n+    for (int i = 0; i < _packs.length(); i++) {\n+      Node_List* pack = _packs.at(i);\n@@ -1528,1 +1513,1 @@\n-      _packset.at_put(i, nullptr); \/\/ take out pack\n+      _packs.at_put(i, nullptr); \/\/ take out pack\n@@ -1532,1 +1517,1 @@\n-        _packset.at_put(new_packset_length++, first_pack);\n+        _packs.at_put(new_packset_length++, first_pack);\n@@ -1536,1 +1521,1 @@\n-        _packset.append(second_pack);\n+        _packs.append(second_pack);\n@@ -1539,1 +1524,1 @@\n-    _packset.trunc_to(new_packset_length);\n+    _packs.trunc_to(new_packset_length);\n@@ -1545,1 +1530,1 @@\n-    print_packset();\n+    print();\n@@ -1552,10 +1537,10 @@\n-  split_packs(\"SuperWord::split_packs_at_use_def_boundaries\",\n-               [&](const Node_List* pack) {\n-                 uint pack_size = pack->size();\n-                 uint boundary = find_use_def_boundary(pack);\n-                 assert(boundary < pack_size, \"valid boundary %d\", boundary);\n-                 if (boundary != 0) {\n-                   return SplitTask::make_split(pack_size - boundary, \"found a use\/def boundary\");\n-                 }\n-                 return SplitTask::make_unchanged();\n-               });\n+  auto split_strategy = [&](const Node_List* pack) {\n+    uint pack_size = pack->size();\n+    uint boundary = find_use_def_boundary(pack);\n+    assert(boundary < pack_size, \"valid boundary %d\", boundary);\n+    if (boundary != 0) {\n+      return SplitTask::make_split(pack_size - boundary, \"found a use\/def boundary\");\n+    }\n+    return SplitTask::make_unchanged();\n+  };\n+  _packset.split_packs(\"SuperWord::split_packs_at_use_def_boundaries\", split_strategy);\n@@ -1567,13 +1552,13 @@\n-  split_packs(\"SuperWord::split_packs_only_implemented_with_smaller_size\",\n-               [&](const Node_List* pack) {\n-                 uint pack_size = pack->size();\n-                 uint implemented_size = max_implemented_size(pack);\n-                 if (implemented_size == 0)  {\n-                   return SplitTask::make_rejected(\"not implemented at any smaller size\");\n-                 }\n-                 assert(is_power_of_2(implemented_size), \"power of 2 size or zero: %d\", implemented_size);\n-                 if (implemented_size != pack_size) {\n-                   return SplitTask::make_split(implemented_size, \"only implemented at smaller size\");\n-                 }\n-                 return SplitTask::make_unchanged();\n-               });\n+  auto split_strategy = [&](const Node_List* pack) {\n+    uint pack_size = pack->size();\n+    uint implemented_size = max_implemented_size(pack);\n+    if (implemented_size == 0)  {\n+      return SplitTask::make_rejected(\"not implemented at any smaller size\");\n+    }\n+    assert(is_power_of_2(implemented_size), \"power of 2 size or zero: %d\", implemented_size);\n+    if (implemented_size != pack_size) {\n+      return SplitTask::make_split(implemented_size, \"only implemented at smaller size\");\n+    }\n+    return SplitTask::make_unchanged();\n+  };\n+  _packset.split_packs(\"SuperWord::split_packs_only_implemented_with_smaller_size\", split_strategy);\n@@ -1584,12 +1569,12 @@\n-  split_packs(\"SuperWord::split_packs_to_break_mutual_dependence\",\n-               [&](const Node_List* pack) {\n-                 uint pack_size = pack->size();\n-                 assert(is_power_of_2(pack_size), \"ensured by earlier splits %d\", pack_size);\n-                 if (!is_marked_reduction(pack->at(0)) &&\n-                     !mutually_independent(pack)) {\n-                   \/\/ As a best guess, we split the pack in half. This way, we iteratively make the\n-                   \/\/ packs smaller, until there is no dependency.\n-                   return SplitTask::make_split(pack_size >> 1, \"was not mutually independent\");\n-                 }\n-                 return SplitTask::make_unchanged();\n-               });\n+  auto split_strategy = [&](const Node_List* pack) {\n+    uint pack_size = pack->size();\n+    assert(is_power_of_2(pack_size), \"ensured by earlier splits %d\", pack_size);\n+    if (!is_marked_reduction(pack->at(0)) &&\n+        !mutually_independent(pack)) {\n+      \/\/ As a best guess, we split the pack in half. This way, we iteratively make the\n+      \/\/ packs smaller, until there is no dependency.\n+      return SplitTask::make_split(pack_size >> 1, \"was not mutually independent\");\n+    }\n+    return SplitTask::make_unchanged();\n+  };\n+  _packset.split_packs(\"SuperWord::split_packs_to_break_mutual_dependence\", split_strategy);\n@@ -1599,2 +1584,2 @@\n-void SuperWord::filter_packs(const char* filter_name,\n-                             const char* error_message,\n+void PackSet::filter_packs(const char* filter_name,\n+                             const char* rejection_message,\n@@ -1602,4 +1587,1 @@\n-  int new_packset_length = 0;\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* pack = _packset.at(i);\n-    assert(pack != nullptr, \"no nullptr in packset\");\n+  auto split_strategy = [&](const Node_List* pack) {\n@@ -1607,2 +1589,1 @@\n-      assert(i >= new_packset_length, \"only move packs down\");\n-      _packset.at_put(new_packset_length++, pack);\n+      return SplitTask::make_unchanged();\n@@ -1610,8 +1591,1 @@\n-      remove_pack_at(i);\n-#ifndef PRODUCT\n-      if (is_trace_superword_rejections()) {\n-        tty->cr();\n-        tty->print_cr(\"WARNING: Removed pack: %s:\", error_message);\n-        print_pack(pack);\n-      }\n-#endif\n+      return SplitTask::make_rejected(rejection_message);\n@@ -1619,11 +1593,2 @@\n-  }\n-\n-  assert(_packset.length() >= new_packset_length, \"filter only reduces number of packs\");\n-  _packset.trunc_to(new_packset_length);\n-\n-#ifndef PRODUCT\n-  if (is_trace_superword_packset() && filter_name != nullptr) {\n-    tty->print_cr(\"\\nAfter %s:\", filter_name);\n-    print_packset();\n-  }\n-#endif\n+  };\n+  split_packs(filter_name, split_strategy);\n@@ -1633,5 +1598,5 @@\n-  filter_packs(\"SuperWord::filter_packs_for_power_of_2_size\",\n-               \"size is not a power of 2\",\n-               [&](const Node_List* pack) {\n-                 return is_power_of_2(pack->size());\n-               });\n+  auto filter = [&](const Node_List* pack) {\n+    return is_power_of_2(pack->size());\n+  };\n+  _packset.filter_packs(\"SuperWord::filter_packs_for_power_of_2_size\",\n+                        \"size is not a power of 2\", filter);\n@@ -1661,7 +1626,7 @@\n-  filter_packs(\"SuperWord::filter_packs_for_mutual_independence\",\n-               \"found dependency between nodes at distance greater than 1\",\n-               [&](const Node_List* pack) {\n-                 \/\/ reductions are trivially connected\n-                 return is_marked_reduction(pack->at(0)) ||\n-                        mutually_independent(pack);\n-               });\n+  auto filter = [&](const Node_List* pack) {\n+    \/\/ reductions are trivially connected\n+    return is_marked_reduction(pack->at(0)) ||\n+           mutually_independent(pack);\n+  };\n+  _packset.filter_packs(\"SuperWord::filter_packs_for_mutual_independence\",\n+                        \"found dependency between nodes at distance greater than 1\", filter);\n@@ -1675,1 +1640,1 @@\n-  VPointer mem_ref_p(mem_ref, _vloop);\n+  const VPointer& mem_ref_p = vpointer(mem_ref);\n@@ -1716,8 +1681,6 @@\n-  filter_packs(\"SuperWord::filter_packs_for_alignment\",\n-               \"rejected by AlignVector (strict alignment requirement)\",\n-               [&](const Node_List* pack) {\n-                 \/\/ Only memops need to be aligned.\n-                 if (!pack->at(0)->is_Load() &&\n-                     !pack->at(0)->is_Store()) {\n-                   return true; \/\/ accept all non memops\n-                 }\n+  auto filter = [&](const Node_List* pack) {\n+    \/\/ Only memops need to be aligned.\n+    if (!pack->at(0)->is_Load() &&\n+        !pack->at(0)->is_Store()) {\n+      return true; \/\/ accept all non memops\n+    }\n@@ -1725,3 +1688,3 @@\n-                 mem_ops_count++;\n-                 const AlignmentSolution* s = pack_alignment_solution(pack);\n-                 const AlignmentSolution* intersect = current->filter(s);\n+    mem_ops_count++;\n+    const AlignmentSolution* s = pack_alignment_solution(pack);\n+    const AlignmentSolution* intersect = current->filter(s);\n@@ -1730,6 +1693,6 @@\n-                 if (is_trace_align_vector()) {\n-                   tty->print(\"  solution for pack:         \");\n-                   s->print();\n-                   tty->print(\"  intersection with current: \");\n-                   intersect->print();\n-                 }\n+    if (is_trace_align_vector()) {\n+      tty->print(\"  solution for pack:         \");\n+      s->print();\n+      tty->print(\"  intersection with current: \");\n+      intersect->print();\n+    }\n@@ -1737,4 +1700,4 @@\n-                 if (intersect->is_empty()) {\n-                   mem_ops_rejected++;\n-                   return false; \/\/ reject because of empty solution\n-                 }\n+    if (intersect->is_empty()) {\n+      mem_ops_rejected++;\n+      return false; \/\/ reject because of empty solution\n+    }\n@@ -1742,3 +1705,6 @@\n-                 current = intersect;\n-                 return true; \/\/ accept because of non-empty solution\n-               });\n+    current = intersect;\n+    return true; \/\/ accept because of non-empty solution\n+  };\n+\n+  _packset.filter_packs(\"SuperWord::filter_packs_for_alignment\",\n+                        \"rejected by AlignVector (strict alignment requirement)\", filter);\n@@ -1763,34 +1729,0 @@\n-\/\/ Compress packset, such that it has no nullptr entries\n-void SuperWord::compress_packset() {\n-  int j = 0;\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* p = _packset.at(i);\n-    if (p != nullptr) {\n-      _packset.at_put(j, p);\n-      j++;\n-    }\n-  }\n-  _packset.trunc_to(j);\n-}\n-\n-\/\/-----------------------------construct_my_pack_map--------------------------\n-\/\/ Construct the map from nodes to packs.  Only valid after the\n-\/\/ point where a node is only in one pack (after combine_pairs_to_longer_packs).\n-void SuperWord::construct_my_pack_map() {\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* p = _packset.at(i);\n-    for (uint j = 0; j < p->size(); j++) {\n-      Node* s = p->at(j);\n-#ifdef ASSERT\n-      if (my_pack(s) != nullptr) {\n-        s->dump(1);\n-        tty->print_cr(\"packs[%d]:\", i);\n-        print_pack(p);\n-        assert(false, \"only in one pack\");\n-      }\n-#endif\n-      set_my_pack(s, p);\n-    }\n-  }\n-}\n-\n@@ -1799,5 +1731,5 @@\n-  filter_packs(\"SuperWord::filter_packs_for_implemented\",\n-               \"Unimplemented\",\n-               [&](const Node_List* pack) {\n-                 return implemented(pack, pack->size());\n-               });\n+  auto filter = [&](const Node_List* pack) {\n+    return implemented(pack, pack->size());\n+  };\n+  _packset.filter_packs(\"SuperWord::filter_packs_for_implemented\",\n+                        \"Unimplemented\", filter);\n@@ -1821,20 +1753,5 @@\n-  while (true) {\n-    int old_packset_length = _packset.length();\n-    filter_packs(nullptr, \/\/ don't dump each time\n-                 \"not profitable\",\n-                 [&](const Node_List* pack) {\n-                   return profitable(pack);\n-                 });\n-    \/\/ Repeat until stable\n-    if (old_packset_length == _packset.length()) {\n-      break;\n-    }\n-  }\n-\n-#ifndef PRODUCT\n-  if (is_trace_superword_packset()) {\n-    tty->print_cr(\"\\nAfter Superword::filter_packs_for_profitable\");\n-    print_packset();\n-    tty->cr();\n-  }\n-#endif\n+  auto filter = [&](const Node_List* pack) {\n+    return profitable(pack);\n+  };\n+  _packset.filter_packs(\"Superword::filter_packs_for_profitable\",\n+                        \"not profitable\", filter);\n@@ -1844,1 +1761,1 @@\n-bool SuperWord::implemented(const Node_List* pack, uint size) {\n+bool SuperWord::implemented(const Node_List* pack, const uint size) const {\n@@ -1920,1 +1837,1 @@\n-bool SuperWord::same_inputs(const Node_List* p, int idx) {\n+bool SuperWord::same_inputs(const Node_List* p, int idx) const {\n@@ -1936,1 +1853,1 @@\n-bool SuperWord::profitable(const Node_List* p) {\n+bool SuperWord::profitable(const Node_List* p) const {\n@@ -1954,1 +1871,1 @@\n-    Node_List* second_pk = my_pack(second_in);\n+    Node_List* second_pk = get_pack(second_in);\n@@ -1967,1 +1884,1 @@\n-    Node_List* cnt_pk = my_pack(cnt);\n+    Node_List* cnt_pk = get_pack(cnt);\n@@ -2020,1 +1937,1 @@\n-    if (bol == nullptr || my_pack(bol) == nullptr) {\n+    if (bol == nullptr || get_pack(bol) == nullptr) {\n@@ -2025,1 +1942,1 @@\n-    if (cmp == nullptr || my_pack(cmp) == nullptr) {\n+    if (cmp == nullptr || get_pack(cmp) == nullptr) {\n@@ -2033,2 +1950,4 @@\n-void SuperWord::verify_packs() {\n-  \/\/ Verify independence at pack level.\n+void SuperWord::verify_packs() const {\n+  _packset.verify();\n+\n+  \/\/ All packs must be:\n@@ -2036,3 +1955,5 @@\n-    Node_List* p = _packset.at(i);\n-    if (!is_marked_reduction(p->at(0)) &&\n-        !mutually_independent(p)) {\n+    Node_List* pack = _packset.at(i);\n+\n+    \/\/ 1. Mutually independent (or a reduction).\n+    if (!is_marked_reduction(pack->at(0)) &&\n+        !mutually_independent(pack)) {\n@@ -2040,1 +1961,1 @@\n-      print_pack(p);\n+      _packset.print_pack(pack);\n@@ -2043,0 +1964,14 @@\n+\n+    \/\/ 2. Implemented.\n+    if (!implemented(pack, pack->size())) {\n+      tty->print_cr(\"FAILURE: nodes not implementable in pack[%d]\", i);\n+      _packset.print_pack(pack);\n+      assert(false, \"pack not implementable\");\n+    }\n+\n+    \/\/ 3. Profitable.\n+    if (!profitable(pack)) {\n+      tty->print_cr(\"FAILURE: nodes not profitable in pack[%d]\", i);\n+      _packset.print_pack(pack);\n+      assert(false, \"pack not profitable\");\n+    }\n@@ -2044,0 +1979,1 @@\n+}\n@@ -2045,1 +1981,2 @@\n-  \/\/ Verify all nodes in packset have my_pack set correctly.\n+void PackSet::verify() const {\n+  \/\/ Verify all nodes in packset have pack set correctly.\n@@ -2048,2 +1985,2 @@\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* p = _packset.at(i);\n+  for (int i = 0; i < _packs.length(); i++) {\n+    Node_List* p = _packs.at(i);\n@@ -2052,1 +1989,1 @@\n-      assert(in_bb(n), \"only nodes in bb can be in packset\");\n+      assert(_vloop.in_bb(n), \"only nodes in bb can be in packset\");\n@@ -2054,1 +1991,1 @@\n-      assert(my_pack(n) == p, \"n has consisten packset info\");\n+      assert(get_pack(n) == p, \"n has consisten packset info\");\n@@ -2059,3 +1996,3 @@\n-  \/\/ Check that no other node has my_pack set.\n-  for (int i = 0; i < body().length(); i++) {\n-    Node* n = body().at(i);\n+  \/\/ Check that no other node has pack set.\n+  for (int i = 0; i < _body.body().length(); i++) {\n+    Node* n = _body.body().at(i);\n@@ -2063,1 +2000,1 @@\n-      assert(my_pack(n) == nullptr, \"should not have pack if not in packset\");\n+      assert(get_pack(n) == nullptr, \"should not have pack if not in packset\");\n@@ -2090,1 +2027,1 @@\n-  GrowableArray<Node*> _pid_to_node;       \/\/ one node per pid, find rest via my_pack\n+  GrowableArray<Node*> _pid_to_node;       \/\/ one node per pid, find rest via _packset.pack\n@@ -2144,1 +2081,1 @@\n-    const GrowableArray<Node_List*>& packset = _slp->packset();\n+    const PackSet& packset = _slp->packset();\n@@ -2153,1 +2090,1 @@\n-        assert(_slp->my_pack(n) == p, \"matching packset\");\n+        assert(packset.get_pack(n) == p, \"matching packset\");\n@@ -2169,1 +2106,1 @@\n-        assert(_slp->my_pack(n) == nullptr, \"no packset\");\n+        assert(packset.get_pack(n) == nullptr, \"no packset\");\n@@ -2235,1 +2172,1 @@\n-      Node_List* p = _slp->my_pack(n);\n+      Node_List* p = _slp->packset().get_pack(n);\n@@ -2443,1 +2380,1 @@\n-  if (_packset.length() == 0) {\n+  if (_packset.is_empty()) {\n@@ -2464,1 +2401,1 @@\n-    Node_List* p = my_pack(n);\n+    Node_List* p = get_pack(n);\n@@ -2554,1 +2491,1 @@\n-        Node_List* p_bol = my_pack(bol);\n+        Node_List* p_bol = get_pack(bol);\n@@ -2567,1 +2504,1 @@\n-        Node_List* p_cmp = my_pack(cmp);\n+        Node_List* p_cmp = get_pack(cmp);\n@@ -2886,1 +2823,1 @@\n-    if (my_pack(in) != nullptr) {\n+    if (get_pack(in) != nullptr) {\n@@ -2894,1 +2831,1 @@\n-      if (my_pack(in2) != nullptr) {\n+      if (get_pack(in2) != nullptr) {\n@@ -2927,1 +2864,1 @@\n-            Node_List* p_use = my_pack(use);\n+            Node_List* p_use = get_pack(use);\n@@ -2940,2 +2877,2 @@\n-  Node_List* pack = my_pack(n_super);\n-  assert(pack != nullptr && pack == my_pack(n_sub), \"must have the same pack\");\n+  Node_List* pack = get_pack(n_super);\n+  assert(pack != nullptr && pack == get_pack(n_sub), \"must have the same pack\");\n@@ -2946,1 +2883,1 @@\n-    Node_List* pack_use_sub = my_pack(use_sub);\n+    Node_List* pack_use_sub = get_pack(use_sub);\n@@ -2959,1 +2896,1 @@\n-        Node_List* pack_use_super = my_pack(use_super);\n+        Node_List* pack_use_super = get_pack(use_super);\n@@ -3008,1 +2945,1 @@\n-      if (my_pack(n0_in) != my_pack(n1_in) &&\n+      if (get_pack(n0_in) != get_pack(n1_in) &&\n@@ -3028,2 +2965,2 @@\n-bool SuperWord::is_vector_use(Node* use, int u_idx) {\n-  Node_List* u_pk = my_pack(use);\n+bool SuperWord::is_vector_use(Node* use, int u_idx) const {\n+  Node_List* u_pk = get_pack(use);\n@@ -3033,1 +2970,1 @@\n-  Node_List* d_pk = my_pack(def);\n+  Node_List* d_pk = get_pack(def);\n@@ -3216,1 +3153,1 @@\n-BasicType SuperWord::longer_type_for_conversion(Node* n) {\n+BasicType SuperWord::longer_type_for_conversion(Node* n) const {\n@@ -3376,1 +3313,1 @@\n-  VPointer p(s, _vloop);\n+  const VPointer& p = vpointer(s);\n@@ -3430,43 +3367,0 @@\n-\/\/------------------------------in_packset---------------------------\n-\/\/ Are s1 and s2 in a pack pair and ordered as s1,s2?\n-bool SuperWord::in_packset(Node* s1, Node* s2) {\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* p = _packset.at(i);\n-    assert(p->size() == 2, \"must be\");\n-    if (p->at(0) == s1 && p->at(p->size()-1) == s2) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-\/\/------------------------------remove_pack_at---------------------------\n-\/\/ Remove the pack at position pos in the packset\n-void SuperWord::remove_pack_at(int pos) {\n-  Node_List* p = _packset.at(pos);\n-  for (uint i = 0; i < p->size(); i++) {\n-    Node* s = p->at(i);\n-    set_my_pack(s, nullptr);\n-  }\n-  _packset.at_put(pos, nullptr);\n-}\n-\n-void SuperWord::packset_sort(int n) {\n-  \/\/ simple bubble sort so that we capitalize with O(n) when its already sorted\n-  do {\n-    int max_swap_index = 0;\n-    for (int i = 1; i < n; i++) {\n-      Node_List* q_low = _packset.at(i-1);\n-      Node_List* q_i = _packset.at(i);\n-\n-      \/\/ only swap when we find something to swap\n-      if (alignment(q_low->at(0)) > alignment(q_i->at(0))) {\n-        *(_packset.adr_at(i)) = q_low;\n-        *(_packset.adr_at(i-1)) = q_i;\n-        max_swap_index = i;\n-      }\n-    }\n-    n = max_swap_index;\n-  } while (n > 1);\n-}\n-\n@@ -3522,1 +3416,1 @@\n-  VPointer align_to_ref_p(align_to_ref, _vloop);\n+  const VPointer& align_to_ref_p = vpointer(align_to_ref);\n@@ -3825,2 +3719,0 @@\n-\/\/------------------------------print_packset---------------------------\n-void SuperWord::print_packset() {\n@@ -3828,5 +3720,24 @@\n-  tty->print_cr(\"packset\");\n-  for (int i = 0; i < _packset.length(); i++) {\n-    tty->print_cr(\"Pack: %d\", i);\n-    Node_List* p = _packset.at(i);\n-    if (p == nullptr) {\n+void PairSet::print() const {\n+  tty->print_cr(\"\\nPairSet::print: %d pairs\", length());\n+  int chain = 0;\n+  int chain_index = 0;\n+  for (PairSetIterator pair(*this); !pair.done(); pair.next()) {\n+    Node* left  = pair.left();\n+    Node* right = pair.right();\n+    if (is_left_in_a_left_most_pair(left)) {\n+      chain_index = 0;\n+      tty->print_cr(\" Pair-chain %d:\", chain++);\n+      tty->print(\"  %3d: \", chain_index++);\n+      left->dump();\n+    }\n+    tty->print(\"  %3d: \", chain_index++);\n+    right->dump();\n+  }\n+}\n+\n+void PackSet::print() const {\n+  tty->print_cr(\"\\nPackSet::print: %d packs\", _packs.length());\n+  for (int i = 0; i < _packs.length(); i++) {\n+    tty->print_cr(\" Pack: %d\", i);\n+    Node_List* pack = _packs.at(i);\n+    if (pack == nullptr) {\n@@ -3835,1 +3746,1 @@\n-      print_pack(p);\n+      print_pack(pack);\n@@ -3838,1 +3749,0 @@\n-#endif\n@@ -3841,4 +3751,4 @@\n-\/\/------------------------------print_pack---------------------------\n-void SuperWord::print_pack(Node_List* p) {\n-  for (uint i = 0; i < p->size(); i++) {\n-    print_stmt(p->at(i));\n+void PackSet::print_pack(Node_List* pack) {\n+  for (uint i = 0; i < pack->size(); i++) {\n+    tty->print(\"  %3d: \", i);\n+    pack->at(i)->dump();\n@@ -3847,0 +3757,1 @@\n+#endif\n@@ -3861,8 +3772,0 @@\n-\/\/------------------------------print_stmt---------------------------\n-void SuperWord::print_stmt(Node* s) {\n-#ifndef PRODUCT\n-  tty->print(\" align: %d \\t\", alignment(s));\n-  s->dump();\n-#endif\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":397,"deletions":494,"binary":false,"changes":891,"status":"modified"},{"patch":"@@ -60,0 +60,327 @@\n+\/\/ The PairSet is a set of pairs. These are later combined to packs,\n+\/\/ and stored in the PackSet.\n+class PairSet : public StackObj {\n+private:\n+  const VLoop& _vloop;\n+  const VLoopBody& _body;\n+\n+  \/\/ Doubly-linked pairs. If not linked: -1\n+  GrowableArray<int> _left_to_right; \/\/ bb_idx -> bb_idx\n+  GrowableArray<int> _right_to_left; \/\/ bb_idx -> bb_idx\n+  \/\/ Example:\n+  \/\/\n+  \/\/   Pairs: (n1, n2) and (n2, n3)\n+  \/\/   bb_idx(n1) = 1\n+  \/\/   bb_idx(n2) = 3\n+  \/\/   bb_idx(n3) = 5\n+  \/\/\n+  \/\/   index \/ bb_idx:   0   1   2   3   4   5   6\n+  \/\/\n+  \/\/   left_to_right:  |   | 3 |   | 5 |   |   |   |\n+  \/\/                         n1----->\n+  \/\/                                 n2----->\n+  \/\/\n+  \/\/   right_to_left:  |   |   |   | 1 |   | 3 |   |\n+  \/\/                          <------n2\n+  \/\/                                  <------n3\n+  \/\/\n+  \/\/   Nodes with bb_idx 0, 2, 4, and 6 are in no pair, they are thus neither left nor right elements,\n+  \/\/   and hence have no entries in the mapping.\n+  \/\/\n+  \/\/   Nodes with bb_idx 1 and 3 (n1 and n2) are both a left element in some pair. Therefore, they both\n+  \/\/   have an entry in the left_to_right mapping. This mapping indicates which right element they are\n+  \/\/   paired with, namely the nodes with bb_idx 3 and 5 (n2 and n3), respectively.\n+  \/\/\n+  \/\/   Nodes with bb_idx 3 and 5 (n2 and n4) are both a right element in some pair. Therefore, they both\n+  \/\/   have an entry in the right_to_left mapping. This mapping indicates which left element they are\n+  \/\/   paired with, namely the nodes with bb_idx 1 and 3 (n1 and n2), respectively.\n+  \/\/\n+  \/\/   Node n1 with bb_idx 1 is not a right element in any pair, thus its right_to_left is empty.\n+  \/\/\n+  \/\/   Node n2 with bb_idx 3 is both a left element of pair (n2, n3), and a right element of pair (n1, n2).\n+  \/\/   Thus it has entries in both left_to_right (mapping n2->n3) and right_to_left (mapping n2->n1).\n+  \/\/\n+  \/\/   Node n3 with bb_idx 5 is not a left element in any pair, thus its left_to_right is empty.\n+\n+  \/\/ List of all left elements bb_idx, in the order of pair addition.\n+  GrowableArray<int> _lefts_in_insertion_order;\n+\n+public:\n+  \/\/ Initialize empty, i.e. all not linked (-1).\n+  PairSet(Arena* arena, const VLoopAnalyzer& vloop_analyzer) :\n+    _vloop(vloop_analyzer.vloop()),\n+    _body(vloop_analyzer.body()),\n+    _left_to_right(arena, _body.body().length(), _body.body().length(), -1),\n+    _right_to_left(arena, _body.body().length(), _body.body().length(), -1),\n+    _lefts_in_insertion_order(arena, 8, 0, 0) {}\n+\n+  const VLoopBody& body() const { return _body; }\n+\n+  bool is_empty() const { return _lefts_in_insertion_order.is_empty(); }\n+\n+  bool is_left(int i)  const { return _left_to_right.at(i) != -1; }\n+  bool is_right(int i) const { return _right_to_left.at(i) != -1; }\n+  bool is_left(const Node* n)  const { return _vloop.in_bb(n) && is_left( _body.bb_idx(n)); }\n+  bool is_right(const Node* n) const { return _vloop.in_bb(n) && is_right(_body.bb_idx(n)); }\n+\n+  bool is_pair(const Node* n1, const Node* n2) const { return is_left(n1) && get_right_for(n1) == n2; }\n+\n+  bool is_left_in_a_left_most_pair(int i)   const { return is_left(i) && !is_right(i); }\n+  bool is_right_in_a_right_most_pair(int i) const { return !is_left(i) && is_right(i); }\n+  bool is_left_in_a_left_most_pair(const Node* n)   const { return is_left_in_a_left_most_pair( _body.bb_idx(n)); }\n+  bool is_right_in_a_right_most_pair(const Node* n) const { return is_right_in_a_right_most_pair(_body.bb_idx(n)); }\n+\n+  int get_right_for(int i) const { return _left_to_right.at(i); }\n+  Node* get_right_for(const Node* n) const { return _body.body().at(get_right_for(_body.bb_idx(n))); }\n+  Node* get_right_or_null_for(const Node* n) const { return is_left(n) ? get_right_for(n) : nullptr; }\n+\n+  \/\/ To access elements in insertion order:\n+  int length() const { return _lefts_in_insertion_order.length(); }\n+  Node* left_at_in_insertion_order(int i)  const { return _body.body().at(_lefts_in_insertion_order.at(i)); }\n+  Node* right_at_in_insertion_order(int i) const { return _body.body().at(get_right_for(_lefts_in_insertion_order.at(i))); }\n+\n+  void add_pair(Node* n1, Node* n2) {\n+    assert(n1 != nullptr && n2 != nullptr && n1 != n2, \"no nullptr, and different nodes\");\n+    assert(!is_left(n1) && !is_right(n2), \"cannot be left twice, or right twice\");\n+    int bb_idx_1 = _body.bb_idx(n1);\n+    int bb_idx_2 = _body.bb_idx(n2);\n+    _left_to_right.at_put(bb_idx_1, bb_idx_2);\n+    _right_to_left.at_put(bb_idx_2, bb_idx_1);\n+    _lefts_in_insertion_order.append(bb_idx_1);\n+    assert(is_left(n1) && is_right(n2), \"must be set now\");\n+  }\n+\n+  NOT_PRODUCT(void print() const;)\n+};\n+\n+\/\/ Iterate over the PairSet, pair-chain by pair-chain.\n+\/\/ A pair-chain starts with a \"left-most\" pair (n1, n2), where n1 is never a right-element\n+\/\/ in any pair. We walk a chain: (n2, n3), (n3, n4) ... until we hit a \"right-most\" pair\n+\/\/ where the right-element is never a left-element of any pair.\n+\/\/ These pair-chains will later be combined into packs by combine_pairs_to_longer_packs.\n+class PairSetIterator : public StackObj {\n+private:\n+  const PairSet& _pairset;\n+  const VLoopBody& _body;\n+\n+  int _chain_start_bb_idx; \/\/ bb_idx of left-element in the left-most pair.\n+  int _current_bb_idx;     \/\/ bb_idx of left-element of the current pair.\n+  const int _end_bb_idx;\n+\n+public:\n+  PairSetIterator(const PairSet& pairset) :\n+    _pairset(pairset),\n+    _body(pairset.body()),\n+    _chain_start_bb_idx(-1),\n+    _current_bb_idx(-1),\n+    _end_bb_idx(_body.body().length())\n+  {\n+    next_chain();\n+  }\n+\n+  bool done() const {\n+    return _chain_start_bb_idx >= _end_bb_idx;\n+  }\n+\n+  Node* left() const {\n+    return _body.body().at(_current_bb_idx);\n+  }\n+\n+  Node* right() const {\n+    int bb_idx_2 = _pairset.get_right_for(_current_bb_idx);\n+    return _body.body().at(bb_idx_2);\n+  }\n+\n+  \/\/ Try to keep walking on the current pair-chain, else find a new pair-chain.\n+  void next() {\n+    assert(_pairset.is_left(_current_bb_idx), \"current was valid\");\n+    _current_bb_idx = _pairset.get_right_for(_current_bb_idx);\n+    if (!_pairset.is_left(_current_bb_idx)) {\n+      next_chain();\n+    }\n+  }\n+\n+private:\n+  void next_chain() {\n+    do {\n+      _chain_start_bb_idx++;\n+    } while (!done() && !_pairset.is_left_in_a_left_most_pair(_chain_start_bb_idx));\n+    _current_bb_idx = _chain_start_bb_idx;\n+  }\n+};\n+\n+class SplitTask {\n+private:\n+  enum Kind {\n+    \/\/ The lambda method for split_packs can return one of these tasks:\n+    Unchanged, \/\/ The pack is left in the packset, unchanged.\n+    Rejected,  \/\/ The pack is removed from the packset.\n+    Split,     \/\/ Split away split_size nodes from the end of the pack.\n+  };\n+  const Kind _kind;\n+  const uint _split_size;\n+  const char* _message;\n+\n+  SplitTask(const Kind kind, const uint split_size, const char* message) :\n+      _kind(kind), _split_size(split_size), _message(message)\n+  {\n+    assert(message != nullptr, \"must have message\");\n+    assert(_kind != Unchanged || split_size == 0, \"unchanged task conditions\");\n+    assert(_kind != Rejected  || split_size == 0, \"reject task conditions\");\n+    assert(_kind != Split     || split_size != 0, \"split task conditions\");\n+  }\n+\n+public:\n+  static SplitTask make_split(const uint split_size, const char* message) {\n+    return SplitTask(Split, split_size, message);\n+  }\n+\n+  static SplitTask make_unchanged() {\n+    return SplitTask(Unchanged, 0, \"unchanged\");\n+  }\n+\n+  static SplitTask make_rejected(const char* message) {\n+    return SplitTask(Rejected, 0, message);\n+  }\n+\n+  bool is_unchanged() const { return _kind == Unchanged; }\n+  bool is_rejected() const { return _kind == Rejected; }\n+  bool is_split() const { return _kind == Split; }\n+  const char* message() const { return _message; }\n+\n+  uint split_size() const {\n+    assert(is_split(), \"only split tasks have split_size\");\n+    return _split_size;\n+  }\n+};\n+\n+class SplitStatus {\n+private:\n+  enum Kind {\n+    \/\/ After split_pack, we have:                              first_pack   second_pack\n+    Unchanged, \/\/ The pack is left in the pack, unchanged.     old_pack     nullptr\n+    Rejected,  \/\/ The pack is removed from the packset.        nullptr      nullptr\n+    Modified,  \/\/ The pack had some nodes removed.             old_pack     nullptr\n+    Split,     \/\/ The pack was split into two packs.           pack1        pack2\n+  };\n+  Kind _kind;\n+  Node_List* _first_pack;\n+  Node_List* _second_pack;\n+\n+  SplitStatus(Kind kind, Node_List* first_pack, Node_List* second_pack) :\n+    _kind(kind), _first_pack(first_pack), _second_pack(second_pack)\n+  {\n+    assert(_kind != Unchanged || (first_pack != nullptr && second_pack == nullptr), \"unchanged status conditions\");\n+    assert(_kind != Rejected  || (first_pack == nullptr && second_pack == nullptr), \"rejected status conditions\");\n+    assert(_kind != Modified  || (first_pack != nullptr && second_pack == nullptr), \"modified status conditions\");\n+    assert(_kind != Split     || (first_pack != nullptr && second_pack != nullptr), \"split status conditions\");\n+  }\n+\n+public:\n+  static SplitStatus make_unchanged(Node_List* old_pack) {\n+    return SplitStatus(Unchanged, old_pack, nullptr);\n+  }\n+\n+  static SplitStatus make_rejected() {\n+    return SplitStatus(Rejected, nullptr, nullptr);\n+  }\n+\n+  static SplitStatus make_modified(Node_List* first_pack) {\n+    return SplitStatus(Modified, first_pack, nullptr);\n+  }\n+\n+  static SplitStatus make_split(Node_List* first_pack, Node_List* second_pack) {\n+    return SplitStatus(Split, first_pack, second_pack);\n+  }\n+\n+  bool is_unchanged() const { return _kind == Unchanged; }\n+  Node_List* first_pack() const { return _first_pack; }\n+  Node_List* second_pack() const { return _second_pack; }\n+};\n+\n+class PackSet : public StackObj {\n+private:\n+  const VLoop& _vloop;\n+  const VLoopBody& _body;\n+\n+  \/\/ Set of all packs:\n+  GrowableArray<Node_List*> _packs;\n+\n+  \/\/ Mapping from nodes to their pack: bb_idx -> pack\n+  GrowableArray<Node_List*> _node_to_pack;\n+\n+  NOT_PRODUCT(const bool _trace_packset;)\n+  NOT_PRODUCT(const bool _trace_rejections;)\n+\n+public:\n+  \/\/ Initialize empty, i.e. no packs, and unmapped (nullptr).\n+  PackSet(Arena* arena, const VLoopAnalyzer& vloop_analyzer\n+          NOT_PRODUCT(COMMA bool trace_packset COMMA bool trace_rejections)\n+          ) :\n+    _vloop(vloop_analyzer.vloop()),\n+    _body(vloop_analyzer.body()),\n+    _packs(arena, 8, 0, nullptr),\n+    _node_to_pack(arena, _body.body().length(), _body.body().length(), nullptr)\n+    NOT_PRODUCT(COMMA _trace_packset(trace_packset))\n+    NOT_PRODUCT(COMMA _trace_rejections(trace_rejections))\n+    {}\n+\n+  \/\/ Accessors to iterate over packs.\n+  int length() const { return _packs.length(); }\n+  bool is_empty() const { return _packs.is_empty(); }\n+  Node_List* at(int i) const { return _packs.at(i); }\n+\n+private:\n+  void map_node_in_pack(const Node* n, Node_List* new_pack) {\n+    assert(get_pack(n) == nullptr, \"was previously unmapped\");\n+    _node_to_pack.at_put(_body.bb_idx(n), new_pack);\n+  }\n+\n+  void remap_node_in_pack(const Node* n, Node_List* new_pack) {\n+    assert(get_pack(n) != nullptr && new_pack != nullptr && get_pack(n) != new_pack, \"was previously mapped\");\n+    _node_to_pack.at_put(_body.bb_idx(n), new_pack);\n+  }\n+\n+  void unmap_node_in_pack(const Node* n) {\n+    assert(get_pack(n) != nullptr, \"was previously mapped\");\n+    _node_to_pack.at_put(_body.bb_idx(n), nullptr);\n+  }\n+\n+  void unmap_all_nodes_in_pack(Node_List* old_pack) {\n+    for (uint i = 0; i < old_pack->size(); i++) {\n+      unmap_node_in_pack(old_pack->at(i));\n+    }\n+  }\n+public:\n+  Node_List* get_pack(const Node* n) const { return !_vloop.in_bb(n) ? nullptr : _node_to_pack.at(_body.bb_idx(n)); }\n+\n+  void add_pack(Node_List* pack) {\n+    _packs.append(pack);\n+    for (uint i = 0; i < pack->size(); i++) {\n+      Node* n = pack->at(i);\n+      map_node_in_pack(n, pack);\n+    }\n+  }\n+\n+private:\n+  SplitStatus split_pack(const char* split_name, Node_List* pack, SplitTask task);\n+public:\n+  template <typename SplitStrategy>\n+  void split_packs(const char* split_name, SplitStrategy strategy);\n+\n+  template <typename FilterPredicate>\n+  void filter_packs(const char* filter_name,\n+                    const char* rejection_message,\n+                    FilterPredicate filter);\n+\n+  void clear() { _packs.clear(); }\n+\n+private:\n+  NOT_PRODUCT(bool is_trace_superword_packset() const { return _trace_packset; })\n+  NOT_PRODUCT(bool is_trace_superword_rejections() const { return _trace_rejections; })\n+public:\n+  DEBUG_ONLY(void verify() const;)\n+  NOT_PRODUCT(void print() const;)\n+  NOT_PRODUCT(static void print_pack(Node_List* pack);)\n+};\n+\n@@ -67,1 +394,0 @@\n-  Node_List*  _my_pack;   \/\/ pack containing this node\n@@ -69,1 +395,1 @@\n-  SWNodeInfo() : _alignment(-1), _my_pack(nullptr) {}\n+  SWNodeInfo() : _alignment(-1) {}\n@@ -86,2 +412,0 @@\n-  GrowableArray<Node_List*> _packset;    \/\/ Packs for the current block\n-\n@@ -92,0 +416,3 @@\n+  PairSet _pairset;\n+  PackSet _packset;\n+\n@@ -101,1 +428,1 @@\n-  \/\/ VLoop Accessors\n+  \/\/ VLoop accessors\n@@ -110,1 +437,1 @@\n-  \/\/ VLoopReductions Accessors\n+  \/\/ VLoopReductions accessors\n@@ -115,1 +442,1 @@\n-  bool reduction(Node* n1, Node* n2) const {\n+  bool reduction(const Node* n1, const Node* n2) const {\n@@ -119,1 +446,1 @@\n-  \/\/ VLoopMemorySlices Accessors\n+  \/\/ VLoopMemorySlices accessors\n@@ -124,1 +451,1 @@\n-  \/\/ VLoopBody Accessors\n+  \/\/ VLoopBody accessors\n@@ -133,1 +460,1 @@\n-  \/\/ VLoopTypes Accessors\n+  \/\/ VLoopTypes accessors\n@@ -158,1 +485,1 @@\n-  \/\/ VLoopDependencyGraph Accessors\n+  \/\/ VLoopDependencyGraph accessors\n@@ -171,0 +498,5 @@\n+  \/\/ VLoopVPointer accessors\n+  const VPointer& vpointer(const MemNode* mem) const {\n+    return _vloop_analyzer.vpointers().vpointer(mem);\n+  }\n+\n@@ -222,1 +554,3 @@\n-  const GrowableArray<Node_List*>& packset() const { return _packset; }\n+  const PackSet& packset() const { return _packset; }\n+  Node_List* get_pack(const Node* n) const { return _packset.get_pack(n); }\n+\n@@ -224,1 +558,0 @@\n-  bool           _race_possible;   \/\/ In cases where SDMU is true\n@@ -243,1 +576,1 @@\n-  int alignment(Node* n)                     { return _node_info.adr_at(bb_idx(n))->_alignment; }\n+  int alignment(Node* n) const               { return _node_info.adr_at(bb_idx(n))->_alignment; }\n@@ -246,5 +579,0 @@\n-  \/\/ my_pack\n- public:\n-  Node_List* my_pack(const Node* n)     const { return !in_bb(n) ? nullptr : _node_info.adr_at(bb_idx(n))->_my_pack; }\n- private:\n-  void set_my_pack(Node* n, Node_List* p)     { int i = bb_idx(n); grow_node_info(i); _node_info.adr_at(i)->_my_pack = p; }\n@@ -254,1 +582,1 @@\n-  bool same_inputs(const Node_List* p, int idx);\n+  bool same_inputs(const Node_List* p, int idx) const;\n@@ -270,2 +598,0 @@\n-  \/\/ Does s exist in a pack at position pos?\n-  bool exists_at(Node* s, uint pos);\n@@ -273,1 +599,1 @@\n-  bool are_adjacent_refs(Node* s1, Node* s2);\n+  bool are_adjacent_refs(Node* s1, Node* s2) const;\n@@ -282,2 +608,0 @@\n-  \/\/ Extend packset by following use->def and def->use links from pack members.\n-  void extend_packset_with_more_pairs_by_following_use_and_def();\n@@ -285,98 +609,0 @@\n-  \/\/ Extend the packset by visiting operand definitions of nodes in pack p\n-  bool follow_use_defs(Node_List* p);\n-  \/\/ Extend the packset by visiting uses of nodes in pack p\n-  bool follow_def_uses(Node_List* p);\n-  \/\/ For extended packsets, ordinally arrange uses packset by major component\n-  void order_def_uses(Node_List* p);\n-  \/\/ Estimate the savings from executing s1 and s2 as a pack\n-  int est_savings(Node* s1, Node* s2);\n-  int adjacent_profit(Node* s1, Node* s2);\n-  int pack_cost(int ct);\n-  int unpack_cost(int ct);\n-\n-  \/\/ Combine packs A and B with A.last == B.first into A.first..,A.last,B.second,..B.last\n-  void combine_pairs_to_longer_packs();\n-\n-  class SplitTask {\n-  private:\n-    enum Kind {\n-      \/\/ The lambda method for split_packs can return one of these tasks:\n-      Unchanged, \/\/ The pack is left in the packset, unchanged.\n-      Rejected,  \/\/ The pack is removed from the packset.\n-      Split,     \/\/ Split away split_size nodes from the end of the pack.\n-    };\n-    const Kind _kind;\n-    const uint _split_size;\n-    const char* _message;\n-\n-    SplitTask(const Kind kind, const uint split_size, const char* message) :\n-        _kind(kind), _split_size(split_size), _message(message)\n-    {\n-      assert(message != nullptr, \"must have message\");\n-      assert(_kind != Unchanged || split_size == 0, \"unchanged task conditions\");\n-      assert(_kind != Rejected  || split_size == 0, \"reject task conditions\");\n-      assert(_kind != Split     || split_size != 0, \"split task conditions\");\n-    }\n-\n-  public:\n-    static SplitTask make_split(const uint split_size, const char* message) {\n-      return SplitTask(Split, split_size, message);\n-    }\n-\n-    static SplitTask make_unchanged() {\n-      return SplitTask(Unchanged, 0, \"unchanged\");\n-    }\n-\n-    static SplitTask make_rejected(const char* message) {\n-      return SplitTask(Rejected, 0, message);\n-    }\n-\n-    bool is_unchanged() const { return _kind == Unchanged; }\n-    bool is_rejected() const { return _kind == Rejected; }\n-    bool is_split() const { return _kind == Split; }\n-    const char* message() const { return _message; }\n-\n-    uint split_size() const {\n-      assert(is_split(), \"only split tasks have split_size\");\n-      return _split_size;\n-    }\n-  };\n-\n-  class SplitStatus {\n-  private:\n-    enum Kind {\n-      \/\/ After split_pack, we have:                              first_pack   second_pack\n-      Unchanged, \/\/ The pack is left in the pack, unchanged.     old_pack     nullptr\n-      Rejected,  \/\/ The pack is removed from the packset.        nullptr      nullptr\n-      Modified,  \/\/ The pack had some nodes removed.             old_pack     nullptr\n-      Split,     \/\/ The pack was split into two packs.           pack1        pack2\n-    };\n-    Kind _kind;\n-    Node_List* _first_pack;\n-    Node_List* _second_pack;\n-\n-    SplitStatus(Kind kind, Node_List* first_pack, Node_List* second_pack) :\n-      _kind(kind), _first_pack(first_pack), _second_pack(second_pack)\n-    {\n-      assert(_kind != Unchanged || (first_pack != nullptr && second_pack == nullptr), \"unchanged status conditions\");\n-      assert(_kind != Rejected  || (first_pack == nullptr && second_pack == nullptr), \"rejected status conditions\");\n-      assert(_kind != Modified  || (first_pack != nullptr && second_pack == nullptr), \"modified status conditions\");\n-      assert(_kind != Split     || (first_pack != nullptr && second_pack != nullptr), \"split status conditions\");\n-    }\n-\n-  public:\n-    static SplitStatus make_unchanged(Node_List* old_pack) {\n-      return SplitStatus(Unchanged, old_pack, nullptr);\n-    }\n-\n-    static SplitStatus make_rejected() {\n-      return SplitStatus(Rejected, nullptr, nullptr);\n-    }\n-\n-    static SplitStatus make_modified(Node_List* first_pack) {\n-      return SplitStatus(Modified, first_pack, nullptr);\n-    }\n-\n-    static SplitStatus make_split(Node_List* first_pack, Node_List* second_pack) {\n-      return SplitStatus(Split, first_pack, second_pack);\n-    }\n@@ -384,4 +610,7 @@\n-    bool is_unchanged() const { return _kind == Unchanged; }\n-    Node_List* first_pack() const { return _first_pack; }\n-    Node_List* second_pack() const { return _second_pack; }\n-  };\n+  void extend_pairset_with_more_pairs_by_following_use_and_def();\n+  bool extend_pairset_with_more_pairs_by_following_def(Node* s1, Node* s2);\n+  bool extend_pairset_with_more_pairs_by_following_use(Node* s1, Node* s2);\n+  void order_inputs_of_all_use_pairs_to_match_def_pair(Node* def1, Node* def2);\n+  enum PairOrderStatus { Ordered, Unordered, Unknown };\n+  PairOrderStatus order_inputs_of_uses_to_match_def_pair(Node* def1, Node* def2, Node* use1, Node* use2);\n+  int estimate_cost_savings_when_packing_as_pair(const Node* s1, const Node* s2) const;\n@@ -389,3 +618,1 @@\n-  SplitStatus split_pack(const char* split_name, Node_List* pack, SplitTask task);\n-  template <typename SplitStrategy>\n-  void split_packs(const char* split_name, SplitStrategy strategy);\n+  void combine_pairs_to_longer_packs();\n@@ -397,5 +624,0 @@\n-  \/\/ Filter out packs with various filter predicates\n-  template <typename FilterPredicate>\n-  void filter_packs(const char* filter_name,\n-                    const char* error_message,\n-                    FilterPredicate filter);\n@@ -404,1 +626,0 @@\n-  \/\/ Ensure all packs are aligned, if AlignVector is on.\n@@ -406,1 +627,0 @@\n-  \/\/ Find the set of alignment solutions for load\/store pack.\n@@ -408,5 +628,0 @@\n-  \/\/ Compress packset, such that it has no nullptr entries.\n-  void compress_packset();\n-  \/\/ Construct the map from nodes to packs.\n-  void construct_my_pack_map();\n-  \/\/ Remove packs that are not implemented.\n@@ -414,1 +629,0 @@\n-  \/\/ Remove packs that are not profitable.\n@@ -416,3 +630,3 @@\n-  \/\/ Verify that for every pack, all nodes are mutually independent.\n-  \/\/ Also verify that packset and my_pack are consistent.\n-  DEBUG_ONLY(void verify_packs();)\n+\n+  DEBUG_ONLY(void verify_packs() const;)\n+\n@@ -430,1 +644,1 @@\n-  bool implemented(const Node_List* pack, uint size);\n+  bool implemented(const Node_List* pack, const uint size) const;\n@@ -435,1 +649,2 @@\n-  bool profitable(const Node_List* p);\n+  bool profitable(const Node_List* p) const;\n+\n@@ -443,0 +658,1 @@\n+\n@@ -444,1 +660,1 @@\n-  bool is_vector_use(Node* use, int u_idx);\n+  bool is_vector_use(Node* use, int u_idx) const;\n@@ -448,2 +664,0 @@\n-  \/\/ Compute max depth for expressions from beginning of block\n-  void compute_max_depth();\n@@ -451,1 +665,1 @@\n-  BasicType longer_type_for_conversion(Node* n);\n+  BasicType longer_type_for_conversion(Node* n) const;\n@@ -454,4 +668,1 @@\n-  \/\/ Are s1 and s2 in a pack pair and ordered as s1,s2?\n-  bool in_packset(Node* s1, Node* s2);\n-  \/\/ Remove the pack at position pos in the packset\n-  void remove_pack_at(int pos);\n+\n@@ -463,9 +674,0 @@\n-  \/\/ Is the use of d1 in u1 at the same operand position as d2 in u2?\n-  bool opnd_positions_match(Node* d1, Node* u1, Node* d2, Node* u2);\n-\n-  \/\/ print methods\n-  void print_packset();\n-  void print_pack(Node_List* p);\n-  void print_stmt(Node* s);\n-\n-  void packset_sort(int n);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":367,"deletions":165,"binary":false,"changes":532,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  flags(POINTER_ANALYSIS,     \"Trace VPointer\") \\\n+  flags(POINTER_ANALYSIS,     \"Trace VPointer (verbose)\") \\\n@@ -38,0 +38,1 @@\n+  flags(POINTERS,             \"Trace VLoopPointers\") \\\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6461,3 +6461,1 @@\n-  int dummy;\n-  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n-  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n@@ -6469,0 +6467,7 @@\n+\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+  if (this_top_or_bottom) {\n+    return true;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,0 +34,13 @@\n+#ifndef PRODUCT\n+static void print_con_or_idx(const Node* n) {\n+  if (n == nullptr) {\n+    tty->print(\"(   0)\");\n+  } else if (n->is_ConI()) {\n+    jint val = n->as_ConI()->get_int();\n+    tty->print(\"(%4d)\", val);\n+  } else {\n+    tty->print(\"[%4d]\", n->_idx);\n+  }\n+}\n+#endif\n+\n@@ -164,0 +177,2 @@\n+  _vpointers.compute_vpointers();\n+\n@@ -169,0 +184,49 @@\n+void VLoopVPointers::compute_vpointers() {\n+  count_vpointers();\n+  allocate_vpointers_array();\n+  compute_and_cache_vpointers();\n+  NOT_PRODUCT( if (_vloop.is_trace_vpointers()) { print(); } )\n+}\n+\n+void VLoopVPointers::count_vpointers() {\n+  _vpointers_length = 0;\n+  _body.for_each_mem([&] (const MemNode* mem, int bb_idx) {\n+    _vpointers_length++;\n+  });\n+}\n+\n+void VLoopVPointers::allocate_vpointers_array() {\n+  uint bytes = _vpointers_length * sizeof(VPointer);\n+  _vpointers = (VPointer*)_arena->Amalloc(bytes);\n+}\n+\n+void VLoopVPointers::compute_and_cache_vpointers() {\n+  int pointers_idx = 0;\n+  _body.for_each_mem([&] (const MemNode* mem, int bb_idx) {\n+    \/\/ Placement new: construct directly into the array.\n+    ::new (&_vpointers[pointers_idx]) VPointer(mem, _vloop);\n+    _bb_idx_to_vpointer.at_put(bb_idx, pointers_idx);\n+    pointers_idx++;\n+  });\n+}\n+\n+const VPointer& VLoopVPointers::vpointer(const MemNode* mem) const {\n+  assert(mem != nullptr && _vloop.in_bb(mem), \"only mem in loop\");\n+  int bb_idx = _body.bb_idx(mem);\n+  int pointers_idx = _bb_idx_to_vpointer.at(bb_idx);\n+  assert(0 <= pointers_idx && pointers_idx < _vpointers_length, \"valid range\");\n+  return _vpointers[pointers_idx];\n+}\n+\n+#ifndef PRODUCT\n+void VLoopVPointers::print() const {\n+  tty->print_cr(\"\\nVLoopVPointers::print:\");\n+\n+  _body.for_each_mem([&] (const MemNode* mem, int bb_idx) {\n+    const VPointer& p = vpointer(mem);\n+    tty->print(\"  \");\n+    p.print();\n+  });\n+}\n+#endif\n+\n@@ -196,1 +260,1 @@\n-      VPointer p1(n1, _vloop);\n+      const VPointer& p1 = _vpointers.vpointer(n1);\n@@ -204,1 +268,1 @@\n-        VPointer p2(n2, _vloop);\n+        const VPointer& p2 = _vpointers.vpointer(n2);\n@@ -396,0 +460,19 @@\n+  \/\/ In the pointer analysis, and especially the AlignVector, analysis we assume that\n+  \/\/ stride and scale are not too large. For example, we multiply \"scale * stride\",\n+  \/\/ and assume that this does not overflow the int range. We also take \"abs(scale)\"\n+  \/\/ and \"abs(stride)\", which would overflow for min_int = -(2^31). Still, we want\n+  \/\/ to at least allow small and moderately large stride and scale. Therefore, we\n+  \/\/ allow values up to 2^30, which is only a factor 2 smaller than the max\/min int.\n+  \/\/ Normal performance relevant code will have much lower values. And the restriction\n+  \/\/ allows us to keep the rest of the autovectorization code much simpler, since we\n+  \/\/ do not have to deal with overflows.\n+  jlong long_scale  = _scale;\n+  jlong long_stride = _vloop.iv_stride();\n+  jlong max_val = 1 << 30;\n+  if (abs(long_scale) >= max_val ||\n+      abs(long_stride) >= max_val ||\n+      abs(long_scale * long_stride) >= max_val) {\n+    assert(!valid(), \"adr stride*scale is too large\");\n+    return;\n+  }\n+\n@@ -707,2 +790,0 @@\n-\/\/ Function for printing the fields of a VPointer\n-void VPointer::print() {\n@@ -710,9 +791,15 @@\n-  tty->print(\"base: [%d]  adr: [%d]  scale: %d  offset: %d\",\n-             _base != nullptr ? _base->_idx : 0,\n-             _adr  != nullptr ? _adr->_idx  : 0,\n-             _scale, _offset);\n-  if (_invar != nullptr) {\n-    tty->print(\"  invar: [%d]\", _invar->_idx);\n-  }\n-  tty->cr();\n-#endif\n+\/\/ Function for printing the fields of a VPointer\n+void VPointer::print() const {\n+  tty->print(\"VPointer[mem: %4d %10s, \", _mem->_idx, _mem->Name());\n+  tty->print(\"base: %4d, \", _base != nullptr ? _base->_idx : 0);\n+  tty->print(\"adr: %4d, \", _adr != nullptr ? _adr->_idx : 0);\n+\n+  tty->print(\" base\");\n+  print_con_or_idx(_base);\n+\n+  tty->print(\" + offset(%4d)\", _offset);\n+\n+  tty->print(\" + invar\");\n+  print_con_or_idx(_invar);\n+\n+  tty->print_cr(\" + scale(%4d) * iv]\", _scale);\n@@ -720,0 +807,1 @@\n+#endif\n@@ -1486,11 +1574,0 @@\n-static void print_con_or_idx(const Node* n) {\n-  if (n == nullptr) {\n-    tty->print(\"(0)\");\n-  } else if (n->is_ConI()) {\n-    jint val = n->as_ConI()->get_int();\n-    tty->print(\"(%d)\", val);\n-  } else {\n-    tty->print(\"[%d]\", n->_idx);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":101,"deletions":24,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+class VPointer;\n+\n@@ -157,0 +159,4 @@\n+  bool is_trace_vpointers() const {\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::POINTERS);\n+  }\n+\n@@ -278,1 +284,1 @@\n-  bool is_marked_reduction_pair(Node* s1, Node* s2) const;\n+  bool is_marked_reduction_pair(const Node* s1, const Node* s2) const;\n@@ -359,0 +365,10 @@\n+  template<typename Callback>\n+  void for_each_mem(Callback callback) const {\n+    for (int i = 0; i < _body.length(); i++) {\n+      MemNode* mem = _body.at(i)->isa_Mem();\n+      if (mem != nullptr && _vloop.in_bb(mem)) {\n+        callback(mem, i);\n+      }\n+    }\n+  }\n+\n@@ -448,0 +464,39 @@\n+\/\/ Submodule of VLoopAnalyzer.\n+\/\/ We compute and cache the VPointer for every load and store.\n+class VLoopVPointers : public StackObj {\n+private:\n+  Arena*                   _arena;\n+  const VLoop&             _vloop;\n+  const VLoopBody&         _body;\n+\n+  \/\/ Array of cached pointers\n+  VPointer* _vpointers;\n+  int _vpointers_length;\n+\n+  \/\/ Map bb_idx -> index in _vpointers. -1 if not mapped.\n+  GrowableArray<int> _bb_idx_to_vpointer;\n+\n+public:\n+  VLoopVPointers(Arena* arena,\n+                 const VLoop& vloop,\n+                 const VLoopBody& body) :\n+    _arena(arena),\n+    _vloop(vloop),\n+    _body(body),\n+    _vpointers(nullptr),\n+    _bb_idx_to_vpointer(arena,\n+                        vloop.estimated_body_length(),\n+                        vloop.estimated_body_length(),\n+                        -1) {}\n+  NONCOPYABLE(VLoopVPointers);\n+\n+  void compute_vpointers();\n+  const VPointer& vpointer(const MemNode* mem) const;\n+  NOT_PRODUCT( void print() const; )\n+\n+private:\n+  void count_vpointers();\n+  void allocate_vpointers_array();\n+  void compute_and_cache_vpointers();\n+};\n+\n@@ -464,0 +519,1 @@\n+  const VLoopVPointers&    _vpointers;\n@@ -475,1 +531,2 @@\n-                       const VLoopMemorySlices& memory_slices) :\n+                       const VLoopMemorySlices& memory_slices,\n+                       const VLoopVPointers& pointers) :\n@@ -480,0 +537,1 @@\n+    _vpointers(pointers),\n@@ -573,0 +631,1 @@\n+  VLoopVPointers       _vpointers;\n@@ -584,1 +643,2 @@\n-    _dependency_graph(&_arena, vloop, _body, _memory_slices)\n+    _vpointers       (&_arena, vloop, _body),\n+    _dependency_graph(&_arena, vloop, _body, _memory_slices, _vpointers)\n@@ -598,0 +658,1 @@\n+  const VLoopVPointers& vpointers()              const { return _vpointers; }\n@@ -681,1 +742,1 @@\n-  bool invar_equals(VPointer& q) {\n+  bool invar_equals(const VPointer& q) const {\n@@ -689,1 +750,1 @@\n-  int cmp(VPointer& q) {\n+  int cmp(const VPointer& q) const {\n@@ -701,1 +762,1 @@\n-  bool overlap_possible_with_any_in(Node_List* p) {\n+  bool overlap_possible_with_any_in(const Node_List* p) const {\n@@ -715,3 +776,3 @@\n-  bool not_equal(VPointer& q)     { return not_equal(cmp(q)); }\n-  bool equal(VPointer& q)         { return equal(cmp(q)); }\n-  bool comparable(VPointer& q)    { return comparable(cmp(q)); }\n+  bool not_equal(const VPointer& q)  const { return not_equal(cmp(q)); }\n+  bool equal(const VPointer& q)      const { return equal(cmp(q)); }\n+  bool comparable(const VPointer& q) const { return comparable(cmp(q)); }\n@@ -722,1 +783,1 @@\n-  void print();\n+  NOT_PRODUCT( void print() const; )\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":71,"deletions":10,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -429,1 +429,1 @@\n-bool VectorNode::is_muladds2i(Node* n) {\n+bool VectorNode::is_muladds2i(const Node* n) {\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  static bool is_muladds2i(Node* n);\n+  static bool is_muladds2i(const Node* n);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleAnnotations\", anno);\n+      write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", anno);\n@@ -125,1 +125,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", type_anno);\n+      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", type_anno);\n@@ -383,0 +383,14 @@\n+void JvmtiClassFileReconstituter::write_annotations_attribute(const char* attr_name,\n+                                                              const char* fallback_attr_name,\n+                                                              AnnotationArray* annos) {\n+  TempNewSymbol sym = SymbolTable::probe(attr_name, (int)strlen(attr_name));\n+  if (sym != nullptr) {\n+    if (symbol_to_cpool_index(sym) != 0) {\n+      write_annotations_attribute(attr_name, annos);\n+      return;\n+    }\n+  }\n+  \/\/ use fallback name\n+  write_annotations_attribute(fallback_attr_name, annos);\n+}\n+\n@@ -522,1 +536,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleAnnotations\", component->annotations());\n+      write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", component->annotations());\n@@ -525,1 +539,1 @@\n-      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", component->type_annotations());\n+      write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", component->type_annotations());\n@@ -764,1 +778,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleAnnotations\", anno);\n+    write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", anno);\n@@ -767,1 +781,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleParameterAnnotations\", param_anno);\n+    write_annotations_attribute(\"RuntimeVisibleParameterAnnotations\", \"RuntimeInvisibleParameterAnnotations\", param_anno);\n@@ -770,1 +784,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", type_anno);\n+    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", type_anno);\n@@ -830,1 +844,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleAnnotations\", anno);\n+    write_annotations_attribute(\"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\", anno);\n@@ -833,1 +847,1 @@\n-    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", type_anno);\n+    write_annotations_attribute(\"RuntimeVisibleTypeAnnotations\", \"RuntimeInvisibleTypeAnnotations\", type_anno);\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,7 @@\n+  \/\/ With PreserveAllAnnotations option \"runtime invisible\" annotations\n+  \/\/ (RuntimeInvisibleAnnotations\/RuntimeInvisibleTypeAnnotations\/RuntimeInvisibleParameterAnnotations)\n+  \/\/ are considered \"runtime visible\" and ClassFileReconstituter writes them as\n+  \/\/ RuntimeVisibleAnnotations\/RuntimeVisibleTypeAnnotations\/RuntimeVisibleParameterAnnotations.\n+  \/\/ This helper method is for the corner case when \"runtime visible\" attribute name is not presents\n+  \/\/ in the class constant pool and the annotations are written with fallback \"runtime invisible\" name.\n+  void write_annotations_attribute(const char* attr_name, const char* fallback_attr_name, AnnotationArray* annos);\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1135,2 +1135,1 @@\n-      bool mismatched = ((msg_type == JVMFlag::NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD) ||\n-                         (msg_type == JVMFlag::DEVELOPER_FLAG_BUT_PRODUCT_BUILD));\n+      bool mismatched = msg_type == JVMFlag::DEVELOPER_FLAG_BUT_PRODUCT_BUILD;\n@@ -1264,1 +1263,3 @@\n-  CDSConfig::check_system_property(key, value);\n+  if (internal == ExternalProperty) {\n+    CDSConfig::check_incompatible_property(key, value);\n+  }\n@@ -1903,0 +1904,1 @@\n+  CDSConfig::check_internal_module_property(prop_name, prop_value);\n@@ -1922,0 +1924,1 @@\n+  CDSConfig::check_internal_module_property(prop_base_name, prop_value);\n@@ -3415,2 +3418,1 @@\n-#ifndef PRODUCT\n-  \/\/ UseDebuggerErgo is notproduct\n+#ifdef ASSERT\n@@ -3420,1 +3422,0 @@\n-#endif\n@@ -3422,1 +3423,0 @@\n-#ifndef PRODUCT\n@@ -3428,1 +3428,0 @@\n-#endif\n@@ -3437,0 +3436,1 @@\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-    notproduct,               \\\n@@ -52,1 +51,0 @@\n-    notproduct,               \\\n@@ -59,1 +57,0 @@\n-    notproduct,               \\\n@@ -68,1 +65,0 @@\n-    notproduct,               \\\n@@ -77,1 +73,0 @@\n-    notproduct,               \\\n@@ -86,1 +81,0 @@\n-    notproduct,               \\\n@@ -95,1 +89,0 @@\n-    notproduct,               \\\n@@ -104,1 +97,0 @@\n-    notproduct,               \\\n@@ -113,1 +105,0 @@\n-    notproduct,               \\\n@@ -122,1 +113,0 @@\n-    notproduct,               \\\n@@ -131,1 +121,0 @@\n-    notproduct,               \\\n@@ -140,1 +129,0 @@\n-    notproduct,               \\\n@@ -149,1 +137,0 @@\n-    notproduct,               \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/allFlags.hpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-                            notproduct,                                     \\\n@@ -58,1 +57,0 @@\n-                            notproduct,                                     \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/debug_globals.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n- * true for notproduct and develop flags in product builds.\n+ * true for develop flags in product builds.\n@@ -62,1 +62,1 @@\n-  return is_notproduct() || is_develop();\n+  return is_develop();\n@@ -124,5 +124,0 @@\n-  if (is_notproduct() && is_product_build()) {\n-    jio_snprintf(buf, buflen, \"Error: VM option '%s' is notproduct and is available only in debug version of VM.\\n\",\n-                 _name);\n-    return JVMFlag::NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD;\n-  }\n@@ -145,1 +140,1 @@\n-  \/\/ Don't print notproduct and develop flags in a product build.\n+  \/\/ Don't print develop flags in a product build.\n@@ -347,1 +342,0 @@\n-    { KIND_NOT_PRODUCT, \"notproduct\" },\n@@ -461,6 +455,6 @@\n-\/\/                                                  dev     dev-pd  pro     pro-pd  notpro  range     constraint\n-enum FlagCounter_LP64  { LP64_RUNTIME_FLAGS(        ENUM_F, ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)  num_flags_LP64   };\n-enum FlagCounter_ARCH  { ARCH_FLAGS(                ENUM_F,         ENUM_F,         ENUM_F, IGNORE_F, IGNORE_F)  num_flags_ARCH   };\n-enum FlagCounter_JVMCI { JVMCI_ONLY(JVMCI_FLAGS(    ENUM_F, ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)) num_flags_JVMCI  };\n-enum FlagCounter_C1    { COMPILER1_PRESENT(C1_FLAGS(ENUM_F, ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)) num_flags_C1     };\n-enum FlagCounter_C2    { COMPILER2_PRESENT(C2_FLAGS(ENUM_F, ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)) num_flags_C2     };\n+\/\/                                                  dev     dev-pd  pro     pro-pd  range     constraint\n+enum FlagCounter_LP64  { LP64_RUNTIME_FLAGS(        ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)  num_flags_LP64   };\n+enum FlagCounter_ARCH  { ARCH_FLAGS(                ENUM_F,         ENUM_F,         IGNORE_F, IGNORE_F)  num_flags_ARCH   };\n+enum FlagCounter_JVMCI { JVMCI_ONLY(JVMCI_FLAGS(    ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)) num_flags_JVMCI  };\n+enum FlagCounter_C1    { COMPILER1_PRESENT(C1_FLAGS(ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)) num_flags_C1     };\n+enum FlagCounter_C2    { COMPILER2_PRESENT(C2_FLAGS(ENUM_F, ENUM_F, ENUM_F, ENUM_F, IGNORE_F, IGNORE_F)) num_flags_C2     };\n@@ -506,1 +500,0 @@\n-const int NOTPROD_KIND     = JVMFlag::KIND_NOT_PRODUCT;\n@@ -513,1 +506,0 @@\n-#define INITIALIZE_NOTPROD_FLAG(   type, name, value, ...) JVMFlag(FLAG_MEMBER_ENUM(name), FLAG_TYPE(type), XSTR(name), (void*)&name, NOTPROD_KIND,    __VA_ARGS__),\n@@ -525,1 +517,0 @@\n-            INITIALIZE_NOTPROD_FLAG,     \\\n@@ -562,1 +553,1 @@\n-    \/\/ Don't report notproduct and develop flags in product builds.\n+    \/\/ Don't report develop flags in product builds.\n@@ -688,2 +679,1 @@\n-      assert((flags & KIND_NOT_PRODUCT) == 0 &&\n-             (flags & KIND_DEVELOP) == 0,\n+      assert((flags & KIND_DEVELOP) == 0,\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":11,"deletions":21,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,8 +66,7 @@\n-    KIND_NOT_PRODUCT        = 1 << 8,\n-    KIND_DEVELOP            = 1 << 9,\n-    KIND_PLATFORM_DEPENDENT = 1 << 10,\n-    KIND_C1                 = 1 << 11,\n-    KIND_C2                 = 1 << 12,\n-    KIND_ARCH               = 1 << 13,\n-    KIND_LP64_PRODUCT       = 1 << 14,\n-    KIND_JVMCI              = 1 << 15,\n+    KIND_DEVELOP            = 1 << 8,\n+    KIND_PLATFORM_DEPENDENT = 1 << 9,\n+    KIND_C1                 = 1 << 10,\n+    KIND_C2                 = 1 << 11,\n+    KIND_ARCH               = 1 << 12,\n+    KIND_LP64_PRODUCT       = 1 << 13,\n+    KIND_JVMCI              = 1 << 14,\n@@ -117,2 +116,1 @@\n-    DEVELOPER_FLAG_BUT_PRODUCT_BUILD,\n-    NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD\n+    DEVELOPER_FLAG_BUT_PRODUCT_BUILD\n@@ -251,1 +249,0 @@\n-  bool is_notproduct() const      { return (_flags & KIND_NOT_PRODUCT) != 0;                  }\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,0 @@\n-           FLAG_LIMIT_DEFINE_DUMMY,\n@@ -118,1 +117,0 @@\n-           FLAG_LIMIT_DEFINE,\n@@ -133,1 +131,0 @@\n-            FLAG_LIMIT_PTR_NONE,\n@@ -141,1 +138,0 @@\n-            FLAG_LIMIT_PTR,\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-            DO_FLAG,\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLookup.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-#define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, ...)\n@@ -38,1 +37,0 @@\n-#define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, ...)   type name = value;\n@@ -45,1 +43,0 @@\n-          MATERIALIZE_NOTPRODUCT_FLAG,\n","filename":"src\/hotspot\/share\/runtime\/globals.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-\/\/ notproduct flags are settable \/ visible only during development and are not declared in the PRODUCT version\n@@ -121,1 +120,0 @@\n-                           notproduct,                                      \\\n@@ -145,1 +143,0 @@\n-                           notproduct,                                      \\\n@@ -158,1 +155,0 @@\n-                      notproduct,                                           \\\n@@ -162,1 +158,1 @@\n-  notproduct(bool, CheckCompressedOops, true,                               \\\n+  develop(bool, CheckCompressedOops, true,                                  \\\n@@ -285,1 +281,1 @@\n-  notproduct(bool, TraceCodeBlobStacks, false,                              \\\n+  develop(bool, TraceCodeBlobStacks, false,                                 \\\n@@ -288,1 +284,1 @@\n-  notproduct(bool, PrintRewrites, false,                                    \\\n+  develop(bool, PrintRewrites, false,                                       \\\n@@ -387,1 +383,1 @@\n-  notproduct(ccstrlist, DeoptimizeOnlyAt, \"\",                               \\\n+  develop(ccstrlist, DeoptimizeOnlyAt, \"\",                                  \\\n@@ -393,1 +389,1 @@\n-  notproduct(bool, ZombieALot, false,                                       \\\n+  develop(bool, ZombieALot, false,                                          \\\n@@ -396,1 +392,1 @@\n-  notproduct(bool, WalkStackALot, false,                                    \\\n+  develop(bool, WalkStackALot, false,                                       \\\n@@ -422,1 +418,1 @@\n-  notproduct(bool, VerifyLastFrame, false,                                  \\\n+  develop(bool, VerifyLastFrame, false,                                     \\\n@@ -465,1 +461,1 @@\n-  notproduct(bool, VerifyCodeCache, false,                                  \\\n+  develop(bool, VerifyCodeCache, false,                                     \\\n@@ -471,1 +467,1 @@\n-  notproduct(bool, ZapVMHandleArea, trueInDebug,                            \\\n+  develop(bool, ZapVMHandleArea, trueInDebug,                               \\\n@@ -474,1 +470,1 @@\n-  notproduct(bool, ZapStackSegments, trueInDebug,                           \\\n+  develop(bool, ZapStackSegments, trueInDebug,                              \\\n@@ -486,0 +482,3 @@\n+  develop(bool, ZapTLAB, trueInDebug,                                       \\\n+          \"Zap allocated TLABs\")                                            \\\n+                                                                            \\\n@@ -618,1 +617,1 @@\n-  notproduct(bool, PrintNMethodStatistics, false,                           \\\n+  develop(bool, PrintNMethodStatistics, false,                              \\\n@@ -695,1 +694,1 @@\n-  notproduct(bool, PrintSystemDictionaryAtExit, false,                      \\\n+  develop(bool, PrintSystemDictionaryAtExit, false,                         \\\n@@ -698,1 +697,1 @@\n-  notproduct(bool, PrintClassLoaderDataGraphAtExit, false,                  \\\n+  develop(bool, PrintClassLoaderDataGraphAtExit, false,                     \\\n@@ -812,1 +811,1 @@\n-  notproduct(bool, PrintFieldLayout, false,                                 \\\n+  develop(bool, PrintFieldLayout, false,                                    \\\n@@ -876,1 +875,1 @@\n-  notproduct(bool, TraceInvocationCounterOverflow, false,                   \\\n+  develop(bool, TraceInvocationCounterOverflow, false,                      \\\n@@ -1020,1 +1019,1 @@\n-  notproduct(bool, PrintFlagsWithComments, false,                           \\\n+  develop(bool, PrintFlagsWithComments, false,                              \\\n@@ -1070,1 +1069,1 @@\n-  notproduct(bool, PrintSymbolTableSizeHistogram, false,                    \\\n+  develop(bool, PrintSymbolTableSizeHistogram, false,                       \\\n@@ -1096,1 +1095,1 @@\n-  notproduct(bool, TraceLivenessQuery, false,                               \\\n+  develop(bool, TraceLivenessQuery, false,                                  \\\n@@ -1099,1 +1098,1 @@\n-  notproduct(bool, CollectIndexSetStatistics, false,                        \\\n+  develop(bool, CollectIndexSetStatistics, false,                           \\\n@@ -1129,1 +1128,1 @@\n-  notproduct(bool, ICMissHistogram, false,                                  \\\n+  develop(bool, ICMissHistogram, false,                                     \\\n@@ -1155,1 +1154,1 @@\n-  notproduct(bool, TraceOnStackReplacement, false,                          \\\n+  develop(bool, TraceOnStackReplacement, false,                             \\\n@@ -1213,1 +1212,1 @@\n-  notproduct(bool, CrashGCForDumpingJavaThread, false,                      \\\n+  develop(bool, CrashGCForDumpingJavaThread, false,                         \\\n@@ -1309,1 +1308,1 @@\n-  notproduct(int, MaxElementPrintSize, 256,                                 \\\n+  develop(int, MaxElementPrintSize, 256,                                    \\\n@@ -1312,1 +1311,1 @@\n-  notproduct(intx, MaxSubklassPrintSize, 4,                                 \\\n+  develop(intx, MaxSubklassPrintSize, 4,                                    \\\n@@ -1326,1 +1325,1 @@\n-  notproduct(intx, DeoptimizeALotInterval,     5,                           \\\n+  develop(intx, DeoptimizeALotInterval,     5,                              \\\n@@ -1329,1 +1328,1 @@\n-  notproduct(intx, ZombieALotInterval,     5,                               \\\n+  develop(intx, ZombieALotInterval,     5,                                  \\\n@@ -1562,1 +1561,1 @@\n-  notproduct(bool, ExitOnFullCodeCache, false,                              \\\n+  develop(bool, ExitOnFullCodeCache, false,                                 \\\n@@ -1711,1 +1710,1 @@\n-  notproduct(bool, UseDebuggerErgo, false,                                  \\\n+  develop(bool, UseDebuggerErgo, false,                                     \\\n@@ -1715,1 +1714,1 @@\n-  notproduct(bool, UseDebuggerErgo1, false,                                 \\\n+  develop(bool, UseDebuggerErgo1, false,                                    \\\n@@ -1719,1 +1718,1 @@\n-  notproduct(bool, UseDebuggerErgo2, false,                                 \\\n+  develop(bool, UseDebuggerErgo2, false,                                    \\\n@@ -1722,1 +1721,1 @@\n-  notproduct(bool, EnableJVMTIStackDepthAsserts, true,                      \\\n+  develop(bool, EnableJVMTIStackDepthAsserts, true,                         \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":34,"deletions":35,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-            DEFINE_FLAG_MEMBER_ENUM,\n@@ -67,1 +66,0 @@\n-          IGNORE_FLAG,               \/\/ not-product : is not declared\n@@ -75,1 +73,0 @@\n-          DEFINE_FLAG_MEMBER_SETTER,\n","filename":"src\/hotspot\/share\/runtime\/globals_extension.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,0 @@\n-#define DECLARE_NOTPRODUCT_FLAG(type, name, value, ...)   const type name = value;\n@@ -81,1 +80,0 @@\n-#define DECLARE_NOTPRODUCT_FLAG(type, name, value, ...)   extern \"C\" type name;\n@@ -89,1 +87,0 @@\n-               DECLARE_NOTPRODUCT_FLAG,   \\\n@@ -96,1 +93,0 @@\n-               DECLARE_NOTPRODUCT_FLAG,   \\\n","filename":"src\/hotspot\/share\/runtime\/globals_shared.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -432,1 +432,0 @@\n-  _Stalled(0),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -161,2 +161,0 @@\n-  volatile intptr_t _Stalled;\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -98,0 +100,7 @@\n+\n+    if (log_is_enabled(Debug, monitorinflation)) {\n+      \/\/ The VMThread calls do_final_audit_and_print_stats() which calls\n+      \/\/ audit_and_print_stats() at the Info level at VM exit time.\n+      LogStreamHandle(Debug, monitorinflation) ls;\n+      ObjectSynchronizer::audit_and_print_stats(&ls, false \/* on_exit *\/);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -272,1 +272,0 @@\n-  _Spinner(0),\n@@ -404,2 +403,0 @@\n-  assert(current->_Stalled == 0, \"invariant\");\n-  current->_Stalled = intptr_t(this);\n@@ -419,1 +416,0 @@\n-    current->_Stalled = 0;\n@@ -440,1 +436,0 @@\n-    current->_Stalled = 0;\n@@ -503,1 +498,0 @@\n-  current->_Stalled = 0;\n@@ -1514,2 +1508,0 @@\n-  assert(current->_Stalled == 0, \"invariant\");\n-  current->_Stalled = intptr_t(this);\n@@ -1649,3 +1641,0 @@\n-    assert(current->_Stalled != 0, \"invariant\");\n-    current->_Stalled = 0;\n-\n@@ -2193,1 +2182,0 @@\n-\/\/   _Spinner = 0\n@@ -2223,1 +2211,0 @@\n-  st->print_cr(\"  _Spinner = %d\", _Spinner);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -178,1 +178,0 @@\n-  volatile int _Spinner;            \/\/ for exit->spinner handoff optimization\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -513,1 +513,0 @@\n-  bool _do_lazy_roots;\n@@ -534,3 +533,1 @@\n-    _subtasks(SafepointSynchronize::SAFEPOINT_CLEANUP_NUM_TASKS),\n-    _do_lazy_roots(!VMThread::vm_operation()->skip_thread_oop_barriers() &&\n-                   Universe::heap()->uses_stack_watermark_barrier()) {}\n+    _subtasks(SafepointSynchronize::SAFEPOINT_CLEANUP_NUM_TASKS) {}\n@@ -541,4 +538,0 @@\n-    if (_do_lazy_roots) {\n-      workers++;\n-    }\n-\n@@ -549,14 +542,0 @@\n-    if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_LAZY_ROOT_PROCESSING)) {\n-      if (_do_lazy_roots) {\n-        Tracer t(\"lazy partial thread root processing\");\n-        class LazyRootClosure : public ThreadClosure {\n-        public:\n-          void do_thread(Thread* thread) {\n-            StackWatermarkSet::start_processing(JavaThread::cast(thread), StackWatermarkKind::gc);\n-          }\n-        };\n-        LazyRootClosure cl;\n-        Threads::java_threads_do(&cl);\n-      }\n-    }\n-\n@@ -591,6 +570,0 @@\n-\n-  if (log_is_enabled(Debug, monitorinflation)) {\n-    \/\/ The VMThread calls do_final_audit_and_print_stats() which calls\n-    \/\/ audit_and_print_stats() at the Info level at VM exit time.\n-    ObjectSynchronizer::audit_and_print_stats(false \/* on_exit *\/);\n-  }\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-    SAFEPOINT_CLEANUP_LAZY_ROOT_PROCESSING,\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2790,1 +2790,1 @@\n-        DirectiveSet* directive = DirectivesStack::getDefaultDirective(CompileBroker::compiler(CompLevel_simple));\n+        DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, CompileBroker::compiler(CompLevel_simple));\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n@@ -121,1 +124,0 @@\n-  assert(!jt->is_terminated(), \"Poll after termination is a bug\");\n@@ -161,0 +163,10 @@\n+\n+void StackWatermarkSet::safepoint_synchronize_begin() {\n+  if (VMThread::vm_operation()->skip_thread_oop_barriers()) {\n+    return;\n+  }\n+\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {\n+    StackWatermarkSet::start_processing(thread, StackWatermarkKind::gc);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,4 @@\n+\n+  \/\/ We are synchronizing a safepoint, so we might want to ensure processing has at least\n+  \/\/ started, as safepoint operations sometimes assume that is the case\n+  static void safepoint_synchronize_begin();\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1953,3 +1953,2 @@\n-    \/\/ The other audit_and_print_stats() call is done at the Debug\n-    \/\/ level at a safepoint in SafepointSynchronize::do_cleanup_tasks.\n-    audit_and_print_stats(true \/* on_exit *\/);\n+    LogStreamHandle(Info, monitorinflation) ls;\n+    audit_and_print_stats(&ls, true \/* on_exit *\/);\n@@ -1959,5 +1958,3 @@\n-\/\/ This function can be called at a safepoint or it can be called when\n-\/\/ we are trying to exit the VM. When we are trying to exit the VM, the\n-\/\/ list walker functions can run in parallel with the other list\n-\/\/ operations so spin-locking is used for safety.\n-\/\/\n+\/\/ This function can be called by the MonitorDeflationThread or it can be called when\n+\/\/ we are trying to exit the VM. The list walker functions can run in parallel with\n+\/\/ the other list operations.\n@@ -1965,3 +1962,1 @@\n-\/\/ aid; pass 'true' for the 'on_exit' parameter to have in-use monitor\n-\/\/ details logged at the Info level and 'false' for the 'on_exit'\n-\/\/ parameter to have in-use monitor details logged at the Trace level.\n+\/\/ aid.\n@@ -1969,16 +1964,1 @@\n-void ObjectSynchronizer::audit_and_print_stats(bool on_exit) {\n-  assert(on_exit || SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-\n-  LogStreamHandle(Debug, monitorinflation) lsh_debug;\n-  LogStreamHandle(Info, monitorinflation) lsh_info;\n-  LogStreamHandle(Trace, monitorinflation) lsh_trace;\n-  LogStream* ls = nullptr;\n-  if (log_is_enabled(Trace, monitorinflation)) {\n-    ls = &lsh_trace;\n-  } else if (log_is_enabled(Debug, monitorinflation)) {\n-    ls = &lsh_debug;\n-  } else if (log_is_enabled(Info, monitorinflation)) {\n-    ls = &lsh_info;\n-  }\n-  assert(ls != nullptr, \"sanity check\");\n-\n+void ObjectSynchronizer::audit_and_print_stats(outputStream* ls, bool on_exit) {\n@@ -1996,6 +1976,8 @@\n-  if ((on_exit && log_is_enabled(Info, monitorinflation)) ||\n-      (!on_exit && log_is_enabled(Trace, monitorinflation))) {\n-    \/\/ When exiting this log output is at the Info level. When called\n-    \/\/ at a safepoint, this log output is at the Trace level since\n-    \/\/ there can be a lot of it.\n-    log_in_use_monitor_details(ls, !on_exit \/* log_all *\/);\n+  \/\/ When exiting, only log the interesting entries at the Info level.\n+  \/\/ When called at intervals by the MonitorDeflationThread, log output\n+  \/\/ at the Trace level since there can be a lot of it.\n+  if (!on_exit && log_is_enabled(Trace, monitorinflation)) {\n+    LogStreamHandle(Trace, monitorinflation) ls_tr;\n+    log_in_use_monitor_details(&ls_tr, true \/* log_all *\/);\n+  } else if (on_exit) {\n+    log_in_use_monitor_details(ls, false \/* log_all *\/);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":15,"deletions":33,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-  static void audit_and_print_stats(bool on_exit);\n+  static void audit_and_print_stats(outputStream* out, bool on_exit);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -660,0 +660,1 @@\n+  bool _saved_in_asgct;\n@@ -663,1 +664,2 @@\n-    assert(!thread->in_asgct(), \"invariant\");\n+    \/\/ Allow AsyncGetCallTrace to be reentrant - save the previous state.\n+    _saved_in_asgct = thread->in_asgct();\n@@ -668,1 +670,1 @@\n-    _thread->set_in_asgct(false);\n+    _thread->set_in_asgct(_saved_in_asgct);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1436,1 +1436,1 @@\n-    \/\/ Exclude notproduct and develop flags in product builds.\n+    \/\/ Exclude develop flags in product builds.\n@@ -1593,1 +1593,1 @@\n-      \/\/ Exclude notproduct and develop flags in product builds.\n+      \/\/ Exclude develop flags in product builds.\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-  GrowableArrayView<E>(E* data, int capacity, int initial_len) :\n+  GrowableArrayView(E* data, int capacity, int initial_len) :\n@@ -126,1 +126,1 @@\n-  bool operator==(const GrowableArrayView<E>& rhs) const {\n+  bool operator==(const GrowableArrayView& rhs) const {\n@@ -137,1 +137,1 @@\n-  bool operator!=(const GrowableArrayView<E>& rhs) const {\n+  bool operator!=(const GrowableArrayView& rhs) const {\n@@ -354,1 +354,1 @@\n-  GrowableArrayFromArray<E>(E* data, int len) :\n+  GrowableArrayFromArray(E* data, int len) :\n@@ -489,1 +489,1 @@\n-  void swap(GrowableArrayWithAllocator<E, Derived>* other) {\n+  void swap(GrowableArrayWithAllocator* other) {\n@@ -691,2 +691,2 @@\n-class GrowableArray : public GrowableArrayWithAllocator<E, GrowableArray<E> > {\n-  friend class GrowableArrayWithAllocator<E, GrowableArray<E> >;\n+class GrowableArray : public GrowableArrayWithAllocator<E, GrowableArray<E>> {\n+  friend class GrowableArrayWithAllocator<E, GrowableArray>;\n@@ -740,1 +740,1 @@\n-      GrowableArrayWithAllocator<E, GrowableArray<E> >(\n+      GrowableArrayWithAllocator<E, GrowableArray>(\n@@ -748,1 +748,1 @@\n-      GrowableArrayWithAllocator<E, GrowableArray<E> >(\n+      GrowableArrayWithAllocator<E, GrowableArray>(\n@@ -756,1 +756,1 @@\n-      GrowableArrayWithAllocator<E, GrowableArray<E> >(\n+      GrowableArrayWithAllocator<E, GrowableArray>(\n@@ -764,1 +764,1 @@\n-      GrowableArrayWithAllocator<E, GrowableArray<E> >(\n+      GrowableArrayWithAllocator<E, GrowableArray>(\n@@ -772,1 +772,1 @@\n-      GrowableArrayWithAllocator<E, GrowableArray<E> >(\n+      GrowableArrayWithAllocator<E, GrowableArray>(\n@@ -855,2 +855,2 @@\n-  GrowableArrayIterator<E>& operator++() { ++_position; return *this; }\n-  E operator*()                          { return _array->at(_position); }\n+  GrowableArrayIterator& operator++() { ++_position; return *this; }\n+  E operator*()                       { return _array->at(_position); }\n@@ -858,1 +858,1 @@\n-  bool operator==(const GrowableArrayIterator<E>& rhs)  {\n+  bool operator==(const GrowableArrayIterator& rhs)  {\n@@ -863,1 +863,1 @@\n-  bool operator!=(const GrowableArrayIterator<E>& rhs)  {\n+  bool operator!=(const GrowableArrayIterator& rhs)  {\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -818,4 +818,0 @@\n-     * <p> To interpret localized string representations of a\n-     * floating-point value, use subclasses of {@link\n-     * java.text.NumberFormat}.\n-     *\n@@ -892,0 +888,10 @@\n+     * @apiNote To interpret localized string representations of a\n+     * floating-point value, or string representations that have\n+     * non-ASCII digits, use {@link java.text.NumberFormat}. For\n+     * example,\n+     * {@snippet lang=\"java\" :\n+     *     NumberFormat.getInstance(l).parse(s).doubleValue();\n+     * }\n+     * where {@code l} is the desired locale, or\n+     * {@link java.util.Locale#ROOT} if locale insensitive.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -492,4 +492,0 @@\n-     * <p>To interpret localized string representations of a\n-     * floating-point value, use subclasses of {@link\n-     * java.text.NumberFormat}.\n-     *\n@@ -519,0 +515,10 @@\n+     * @apiNote To interpret localized string representations of a\n+     * floating-point value, or string representations that have\n+     * non-ASCII digits, use {@link java.text.NumberFormat}. For\n+     * example,\n+     * {@snippet lang=\"java\" :\n+     *     NumberFormat.getInstance(l).parse(s).floatValue();\n+     * }\n+     * where {@code l} is the desired locale, or\n+     * {@link java.util.Locale#ROOT} if locale insensitive.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,2 +85,2 @@\n-     * Note the exponent range of decimal32 is <em>not<\/em> used for\n-     * rounding.\n+     * Note the exponent range of decimal32 (min exponent of -95, max\n+     * exponent of 96) is <em>not<\/em> used for rounding.\n@@ -95,2 +95,2 @@\n-     * Note the exponent range of decimal64 is <em>not<\/em> used for\n-     * rounding.\n+     * Note the exponent range of decimal64 (min exponent of -383, max\n+     * exponent of 384) is <em>not<\/em> used for rounding.\n@@ -105,2 +105,2 @@\n-     * Note the exponent range of decimal64 is <em>not<\/em> used for\n-     * rounding.\n+     * Note the exponent range of decimal128 (min exponent of -6143,\n+     * max exponent of 6144) is <em>not<\/em> used for rounding.\n","filename":"src\/java.base\/share\/classes\/java\/math\/MathContext.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,2 +134,1 @@\n-        List<Service> list = GetInstance.getServices(\"KeyFactory\", algorithm);\n-        serviceIterator = list.iterator();\n+        serviceIterator = GetInstance.getServices(\"KeyFactory\", algorithm);\n","filename":"src\/java.base\/share\/classes\/java\/security\/KeyFactory.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,3 +233,1 @@\n-        List<Service> list =\n-                GetInstance.getServices(\"KeyPairGenerator\", algorithm);\n-        Iterator<Service> t = list.iterator();\n+        Iterator<Service> t = GetInstance.getServices(\"KeyPairGenerator\", algorithm);\n","filename":"src\/java.base\/share\/classes\/java\/security\/KeyPairGenerator.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -260,1 +260,1 @@\n-        List<Service> list;\n+        Iterator<Service> t;\n@@ -262,1 +262,1 @@\n-            list = GetInstance.getServices(rsaIds);\n+            t = GetInstance.getServices(rsaIds);\n@@ -264,1 +264,1 @@\n-            list = GetInstance.getServices(\"Signature\", algorithm);\n+            t = GetInstance.getServices(\"Signature\", algorithm);\n@@ -266,1 +266,0 @@\n-        Iterator<Service> t = list.iterator();\n","filename":"src\/java.base\/share\/classes\/java\/security\/Signature.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -542,1 +542,0 @@\n-        List<Service> services = GetInstance.getServices(cipherServices);\n@@ -545,1 +544,1 @@\n-        Iterator<Service> t = services.iterator();\n+        Iterator<Service> t = GetInstance.getServices(cipherServices);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,1 @@\n-        List<Service> services = GetInstance.getServices(type, algorithm);\n+        Iterator<Service> t = GetInstance.getServices(type, algorithm);\n@@ -159,1 +159,2 @@\n-        for (Service s : services) {\n+        while (t.hasNext()) {\n+            Service s = t.next();\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/JceSecurity.java.template","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Iterator;\n@@ -540,1 +541,1 @@\n-        List<Provider.Service> list = GetInstance.getServices(\n+        Iterator<Provider.Service> t = GetInstance.getServices(\n@@ -544,1 +545,2 @@\n-        for (Provider.Service s : list) {\n+        while (t.hasNext()) {\n+            Provider.Service s = t.next();\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KEM.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,2 +183,0 @@\n-        List<Service> services =\n-                GetInstance.getServices(\"KeyAgreement\", algorithm);\n@@ -186,1 +184,1 @@\n-        Iterator<Service> t = services.iterator();\n+        Iterator<Service> t = GetInstance.getServices(\"KeyAgreement\", algorithm);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KeyAgreement.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,3 +170,1 @@\n-        List<Service> list =\n-                GetInstance.getServices(\"KeyGenerator\", algorithm);\n-        serviceIterator = list.iterator();\n+        serviceIterator = GetInstance.getServices(\"KeyGenerator\", algorithm);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KeyGenerator.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,1 +180,0 @@\n-        List<Service> services = GetInstance.getServices(\"Mac\", algorithm);\n@@ -182,1 +181,1 @@\n-        Iterator<Service> t = services.iterator();\n+        Iterator<Service> t = GetInstance.getServices(\"Mac\", algorithm);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Mac.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,3 +113,1 @@\n-        List<Service> list =\n-                GetInstance.getServices(\"SecretKeyFactory\", algorithm);\n-        serviceIterator = list.iterator();\n+        serviceIterator = GetInstance.getServices(\"SecretKeyFactory\", algorithm);\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/SecretKeyFactory.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.internal.misc.ThreadTracker;\n@@ -136,0 +137,12 @@\n+    private static class ThreadTrackHolder {\n+        static final ThreadTracker TRACKER = new ThreadTracker();\n+    }\n+\n+    private static Object tryBeginLookup() {\n+        return ThreadTrackHolder.TRACKER.tryBegin();\n+    }\n+\n+    private static void endLookup(Object key) {\n+        ThreadTrackHolder.TRACKER.end(key);\n+    }\n+\n@@ -144,6 +157,13 @@\n-        \/\/ Avoid a bootstrap issue where the commitEvent attempts to\n-        \/\/ trigger early loading of System Logger but where\n-        \/\/ the verification process still has JarFiles locked\n-        if (securityLogger == null && !JUJA.isInitializing()) {\n-            LOGGER_HANDLE.compareAndSet( null, System.getLogger(SECURITY_LOGGER_NAME));\n-            loggingSecurity = securityLogger.isLoggable(LOG_LEVEL);\n+        Object key;\n+        \/\/ Avoid bootstrap issues where\n+        \/\/ * commitEvent triggers early loading of System Logger but where\n+        \/\/   the verification process still has JarFiles locked\n+        \/\/ * the loading of the logging libraries involves recursive\n+        \/\/   calls to security libraries triggering recursion\n+        if (securityLogger == null && !JUJA.isInitializing() && (key = tryBeginLookup()) != null) {\n+            try {\n+                LOGGER_HANDLE.compareAndSet(null, System.getLogger(SECURITY_LOGGER_NAME));\n+                loggingSecurity = securityLogger.isLoggable(LOG_LEVEL);\n+            } finally {\n+                endLookup(key);\n+            }\n@@ -153,1 +173,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/EventHelper.java","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -125,2 +125,2 @@\n-    private static void debugPrintStackTrace(Throwable throwable) {\n-        if (Boolean.getBoolean(\"jdk.internal.vm.TranslatedException.debug\")) {\n+    private static void debugPrintStackTrace(Throwable throwable, boolean debug) {\n+        if (debug) {\n@@ -132,1 +132,1 @@\n-    private static Throwable initCause(Throwable throwable, Throwable cause) {\n+    private static Throwable initCause(Throwable throwable, Throwable cause, boolean debug) {\n@@ -138,1 +138,1 @@\n-                debugPrintStackTrace(e);\n+                debugPrintStackTrace(e, debug);\n@@ -144,1 +144,1 @@\n-    private static Throwable create(String className, String message, Throwable cause) {\n+    private static Throwable create(String className, String message, Throwable cause, boolean debug) {\n@@ -160,1 +160,1 @@\n-                return initCause((Throwable) cons.newInstance(), cause);\n+                return initCause((Throwable) cons.newInstance(), cause, debug);\n@@ -163,1 +163,1 @@\n-            return initCause((Throwable) cons.newInstance(message), cause);\n+            return initCause((Throwable) cons.newInstance(message), cause, debug);\n@@ -165,2 +165,2 @@\n-            debugPrintStackTrace(translationFailure);\n-            return initCause(new TranslatedException(message, className), cause);\n+            debugPrintStackTrace(translationFailure, debug);\n+            return initCause(new TranslatedException(message, className), cause, debug);\n@@ -256,1 +256,1 @@\n-    static Throwable decodeThrowable(byte[] encodedThrowable) {\n+    static Throwable decodeThrowable(byte[] encodedThrowable, boolean debug) {\n@@ -265,1 +265,1 @@\n-                throwable = create(exceptionClassName, exceptionMessage, cause);\n+                throwable = create(exceptionClassName, exceptionMessage, cause, debug);\n@@ -313,1 +313,1 @@\n-            debugPrintStackTrace(translationFailure);\n+            debugPrintStackTrace(translationFailure, debug);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/TranslatedException.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -128,0 +128,1 @@\n+     * @param debug specifies whether debug stack traces should be enabled in case of translation failure\n@@ -129,1 +130,1 @@\n-    public static void decodeAndThrowThrowable(int format, long buffer, boolean inJVMHeap) throws Throwable {\n+    public static void decodeAndThrowThrowable(int format, long buffer, boolean inJVMHeap, boolean debug) throws Throwable {\n@@ -145,1 +146,1 @@\n-        throw TranslatedException.decodeThrowable(bufferToBytes(buffer));\n+        throw TranslatedException.decodeThrowable(bufferToBytes(buffer), debug);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/VMSupport.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -227,0 +227,33 @@\n+\n+    \/**\n+     * Convenience method for fetching System property values that are booleans.\n+     *\n+     * @param prop the name of the System property\n+     * @param def a default value\n+     * @param dbg a Debug object, if null no debug messages will be sent\n+     *\n+     * @return a boolean value corresponding to the value in the System property.\n+     *      If the property value is neither \"true\" or \"false\", the default value\n+     *      will be returned.\n+     *\/\n+    public static boolean privilegedGetBooleanProp(String prop, boolean def, Debug dbg) {\n+        String rawPropVal = privilegedGetProperty(prop, \"\");\n+        if (\"\".equals(rawPropVal)) {\n+            return def;\n+        }\n+\n+        String lower = rawPropVal.toLowerCase(Locale.ROOT);\n+        if (\"true\".equals(lower)) {\n+            return true;\n+        } else if (\"false\".equals(lower)) {\n+            return false;\n+        } else {\n+            if (dbg != null) {\n+                dbg.println(\"Warning: Unexpected value for \" + prop +\n+                            \": \" + rawPropVal +\n+                            \". Using default value: \" + def);\n+            }\n+            return def;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/action\/GetPropertyAction.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import sun.security.util.BitArray;\n@@ -62,1 +63,0 @@\n-    @SuppressWarnings(\"deprecation\")\n@@ -70,1 +70,2 @@\n-        key = ECUtil.encodePoint(w, params.getCurve());\n+        byte[] key = ECUtil.encodePoint(w, params.getCurve());\n+        setKey(new BitArray(key.length * 8, key));\n@@ -95,7 +96,0 @@\n-    \/\/ Internal API to get the encoded point. Currently used by SunPKCS11.\n-    \/\/ This may change\/go away depending on what we do with the public API.\n-    @SuppressWarnings(\"deprecation\")\n-    public byte[] getEncodedPublicValue() {\n-        return key.clone();\n-    }\n-\n@@ -105,1 +99,0 @@\n-    @SuppressWarnings(\"deprecation\")\n@@ -115,1 +108,1 @@\n-            w = ECUtil.decodePoint(key, params.getCurve());\n+            w = ECUtil.decodePoint(getKey().toByteArray(), params.getCurve());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPublicKeyImpl.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,2 +107,2 @@\n-     * Return a List of all the available Services that implement\n-     * (type, algorithm). Note that the list is initialized lazily\n+     * Return an iterator over all the available Services that implement\n+     * (type, algorithm). Note that the iterator is initialized lazily\n@@ -112,1 +112,1 @@\n-    public static List<Service> getServices(String type, String algorithm) {\n+    public static Iterator<Service> getServices(String type, String algorithm) {\n@@ -118,13 +118,1 @@\n-     * This method exists for compatibility with JCE only. It will be removed\n-     * once JCE has been changed to use the replacement method.\n-     * @deprecated use {@code getServices(List<ServiceId>)} instead\n-     *\/\n-    @Deprecated\n-    public static List<Service> getServices(String type,\n-            List<String> algorithms) {\n-        ProviderList list = Providers.getProviderList();\n-        return list.getServices(type, algorithms);\n-    }\n-\n-    \/**\n-     * Return a List of all the available Services that implement any of\n+     * Return an iterator over all the available Services that implement any of\n@@ -133,1 +121,1 @@\n-    public static List<Service> getServices(List<ServiceId> ids) {\n+    public static Iterator<Service> getServices(List<ServiceId> ids) {\n@@ -170,1 +158,3 @@\n-        for (Service s : list.getServices(type, algorithm)) {\n+        Iterator<Service> services = list.getServices(type, algorithm);\n+        while (services.hasNext()) {\n+            Service s = services.next();\n@@ -186,1 +176,1 @@\n-        List<Service> services = getServices(type, algorithm);\n+        Iterator<Service> services = getServices(type, algorithm);\n@@ -188,1 +178,2 @@\n-        for (Service s : services) {\n+        while (services.hasNext()) {\n+            Service s = services.next();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/GetInstance.java","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -394,1 +394,1 @@\n-     * Return a List containing all the Services describing implementations\n+     * Return an iterator over all the Services describing implementations\n@@ -396,1 +396,1 @@\n-     * exists, this method returns an empty List.\n+     * exists, this method returns an empty iterator.\n@@ -398,1 +398,1 @@\n-     * The elements of this list are determined lazily on demand.\n+     * The elements of this iterator are determined lazily on demand.\n@@ -400,1 +400,1 @@\n-     * The List returned is NOT thread safe.\n+     * The iterator returned is NOT thread safe.\n@@ -402,2 +402,2 @@\n-    public List<Service> getServices(String type, String algorithm) {\n-        return new ServiceList(type, algorithm);\n+    public Iterator<Service> getServices(String type, String algorithm) {\n+        return new ServiceIterator(type, algorithm);\n@@ -406,16 +406,2 @@\n-    \/**\n-     * This method exists for compatibility with JCE only. It will be removed\n-     * once JCE has been changed to use the replacement method.\n-     * @deprecated use {@code getServices(List<ServiceId>)} instead\n-     *\/\n-    @Deprecated\n-    public List<Service> getServices(String type, List<String> algorithms) {\n-        List<ServiceId> ids = new ArrayList<>();\n-        for (String alg : algorithms) {\n-            ids.add(new ServiceId(type, alg));\n-        }\n-        return getServices(ids);\n-    }\n-\n-    public List<Service> getServices(List<ServiceId> ids) {\n-        return new ServiceList(ids);\n+    public Iterator<Service> getServices(List<ServiceId> ids) {\n+        return new ServiceIterator(ids);\n@@ -425,1 +411,1 @@\n-     * Inner class for a List of Services. Custom List implementation in\n+     * Inner class for an iterator over Services. Customized implementation in\n@@ -429,1 +415,1 @@\n-    private final class ServiceList extends AbstractList<Service> {\n+    private final class ServiceIterator implements Iterator<Service> {\n@@ -452,1 +438,1 @@\n-        \/\/ Matching preferred provider list for this ServiceList\n+        \/\/ Matching preferred provider list for this ServiceIterator\n@@ -456,1 +442,1 @@\n-        ServiceList(String type, String algorithm) {\n+        ServiceIterator(String type, String algorithm) {\n@@ -462,1 +448,1 @@\n-        ServiceList(List<ServiceId> ids) {\n+        ServiceIterator(List<ServiceId> ids) {\n@@ -537,1 +523,9 @@\n-        public Service get(int index) {\n+        int index;\n+\n+        @Override\n+        public boolean hasNext() {\n+            return tryGet(index) != null;\n+        }\n+\n+        @Override\n+        public Service next() {\n@@ -540,1 +534,1 @@\n-                throw new IndexOutOfBoundsException();\n+                throw new NoSuchElementException();\n@@ -542,0 +536,1 @@\n+            index++;\n@@ -545,41 +540,3 @@\n-        public int size() {\n-            int n;\n-            if (services != null) {\n-                n = services.size();\n-            } else {\n-                n = (firstService != null) ? 1 : 0;\n-            }\n-            while (tryGet(n) != null) {\n-                n++;\n-            }\n-            return n;\n-        }\n-\n-        \/\/ override isEmpty() and iterator() to not call size()\n-        \/\/ this avoids loading + checking all Providers\n-\n-        public boolean isEmpty() {\n-            return (tryGet(0) == null);\n-        }\n-\n-        public Iterator<Service> iterator() {\n-            return new Iterator<>() {\n-                int index;\n-\n-                public boolean hasNext() {\n-                    return tryGet(index) != null;\n-                }\n-\n-                public Service next() {\n-                    Service s = tryGet(index);\n-                    if (s == null) {\n-                        throw new NoSuchElementException();\n-                    }\n-                    index++;\n-                    return s;\n-                }\n-\n-                public void remove() {\n-                    throw new UnsupportedOperationException();\n-                }\n-            };\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n@@ -595,1 +552,1 @@\n-         * ServiceList.\n+         * ServiceIterator.\n@@ -597,1 +554,1 @@\n-        ArrayList<PreferredEntry> getAll(ServiceList s) {\n+        ArrayList<PreferredEntry> getAll(ServiceIterator s) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/ProviderList.java","additions":30,"deletions":73,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-            \"com.sun.security.ocsp.useget\", \"true\");\n+            \"com.sun.security.ocsp.useget\", true);\n@@ -124,3 +124,3 @@\n-    private static boolean initializeBoolean(String prop, String def) {\n-        String flag = GetPropertyAction.privilegedGetProperty(prop, def);\n-        boolean value = Boolean.parseBoolean(flag);\n+    private static boolean initializeBoolean(String prop, boolean def) {\n+        boolean value =\n+                GetPropertyAction.privilegedGetBooleanProp(prop, def, debug);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/OCSP.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n@@ -44,0 +47,2 @@\n+    private boolean printDateTime;\n+    private boolean printThreadDetails;\n@@ -46,0 +51,4 @@\n+    private static boolean threadInfoAll;\n+    private static boolean timeStampInfoAll;\n+    private static final String TIMESTAMP_OPTION = \"+timestamp\";\n+    private static final String THREAD_OPTION = \"+thread\";\n@@ -64,0 +73,10 @@\n+            } else if (args.contains(\"all\")) {\n+                \/\/ \"all\" option has special handling for decorator options\n+                \/\/ If the thread or timestamp decorator option is detected\n+                \/\/ with the \"all\" option, then it impacts decorator options\n+                \/\/ for other categories\n+                int beginIndex = args.lastIndexOf(\"all\") + \"all\".length();\n+                int commaIndex = args.indexOf(',', beginIndex);\n+                if (commaIndex == -1) commaIndex = args.length();\n+                threadInfoAll = args.substring(beginIndex, commaIndex).contains(THREAD_OPTION);\n+                timeStampInfoAll = args.substring(beginIndex, commaIndex).contains(TIMESTAMP_OPTION);\n@@ -68,2 +87,1 @@\n-    public static void Help()\n-    {\n+    public static void Help() {\n@@ -98,0 +116,5 @@\n+        System.err.println(\"+timestamp can be appended to any of above options to print\");\n+        System.err.println(\"              a timestamp for that debug option\");\n+        System.err.println(\"+thread can be appended to any of above options to print\");\n+        System.err.println(\"              thread and caller information for that debug option\");\n+        System.err.println();\n@@ -142,2 +165,1 @@\n-    public static Debug getInstance(String option)\n-    {\n+    public static Debug getInstance(String option) {\n@@ -151,2 +173,1 @@\n-    public static Debug getInstance(String option, String prefix)\n-    {\n+    public static Debug getInstance(String option, String prefix) {\n@@ -156,0 +177,1 @@\n+            d.configureExtras(option);\n@@ -162,0 +184,35 @@\n+    private static String formatCaller() {\n+        return StackWalker.getInstance().walk(s ->\n+                s.dropWhile(f ->\n+                    f.getClassName().startsWith(\"sun.security.util.Debug\"))\n+                        .map(f -> f.getFileName() + \":\" + f.getLineNumber())\n+                        .findFirst().orElse(\"unknown caller\"));\n+    }\n+\n+    \/\/ parse an option string to determine if extra details,\n+    \/\/ like thread and timestamp, should be printed\n+    private void configureExtras(String option) {\n+        \/\/ treat \"all\" as special case, only used for java.security.debug property\n+        this.printDateTime = timeStampInfoAll;\n+        this.printThreadDetails = threadInfoAll;\n+\n+        if (printDateTime && printThreadDetails) {\n+            \/\/ nothing left to configure\n+            return;\n+        }\n+\n+        \/\/ args is converted to lower case for the most part via marshal method\n+        int optionIndex = args.lastIndexOf(option);\n+        if (optionIndex == -1) {\n+            \/\/ option not in args list. Only here since \"all\" was present\n+            \/\/ in debug property argument. \"all\" option already parsed\n+            return;\n+        }\n+        int beginIndex = optionIndex + option.length();\n+        int commaIndex = args.indexOf(',', beginIndex);\n+        if (commaIndex == -1) commaIndex = args.length();\n+        String subOpt = args.substring(beginIndex, commaIndex);\n+        printDateTime = printDateTime || subOpt.contains(TIMESTAMP_OPTION);\n+        printThreadDetails = printThreadDetails || subOpt.contains(THREAD_OPTION);\n+    }\n+\n@@ -176,1 +233,7 @@\n-     * @param option the debug option name\n+     *\n+     * +timestamp string can be appended to property value\n+     * to print timestamp information. (e.g. true+timestamp)\n+     * +thread string can be appended to property value\n+     * to print thread and caller information. (e.g. true+thread)\n+     *\n+     * @param prefix the debug option name\n@@ -180,2 +243,2 @@\n-    public static Debug of(String option, String property) {\n-        if (\"true\".equalsIgnoreCase(property)) {\n+    public static Debug of(String prefix, String property) {\n+        if (property != null && property.toLowerCase(Locale.ROOT).startsWith(\"true\")) {\n@@ -183,1 +246,3 @@\n-            d.prefix = option;\n+            d.prefix = prefix;\n+            d.printThreadDetails = property.contains(THREAD_OPTION);\n+            d.printDateTime = property.contains(TIMESTAMP_OPTION);\n@@ -193,2 +258,1 @@\n-    public static boolean isOn(String option)\n-    {\n+    public static boolean isOn(String option) {\n@@ -217,3 +281,2 @@\n-    public void println(String message)\n-    {\n-        System.err.println(prefix + \": \"+message);\n+    public void println(String message) {\n+        System.err.println(prefix + extraInfo() + \": \" + message);\n@@ -226,3 +289,2 @@\n-    public void println(Object obj, String message)\n-    {\n-        System.err.println(prefix + \" [\" + obj.getClass().getSimpleName() +\n+    public void println(Object obj, String message) {\n+        System.err.println(prefix + extraInfo() + \" [\" + obj.getClass().getSimpleName() +\n@@ -236,3 +298,2 @@\n-    public void println()\n-    {\n-        System.err.println(prefix + \":\");\n+    public void println() {\n+        System.err.println(prefix + extraInfo() + \":\");\n@@ -245,3 +306,22 @@\n-    public static void println(String prefix, String message)\n-    {\n-        System.err.println(prefix + \": \"+message);\n+    public void println(String prefix, String message) {\n+        System.err.println(prefix + extraInfo() + \": \" + message);\n+    }\n+\n+    \/**\n+     * If thread debug option enabled, include information containing\n+     * hex value of threadId and the current thread name\n+     * If timestamp debug option enabled, include timestamp string\n+     * @return extra info if debug option enabled.\n+     *\/\n+    private String extraInfo() {\n+        String retString = \"\";\n+        if (printThreadDetails) {\n+            retString = \"0x\" + Long.toHexString(\n+                    Thread.currentThread().threadId()).toUpperCase(Locale.ROOT) +\n+                    \"|\" + Thread.currentThread().getName() + \"|\" + formatCaller();\n+        }\n+        if (printDateTime) {\n+            retString += (retString.isEmpty() ? \"\" : \"|\")\n+                    + FormatHolder.DATE_TIME_FORMATTER.format(Instant.now());\n+        }\n+        return retString.isEmpty() ? \"\" : \"[\" + retString + \"]\";\n@@ -367,0 +447,7 @@\n+    \/\/ Holder class to break cyclic dependency seen during build\n+    private static class FormatHolder {\n+        private static final String PATTERN = \"yyyy-MM-dd kk:mm:ss.SSS\";\n+        private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter\n+                .ofPattern(PATTERN, Locale.ENGLISH)\n+                .withZone(ZoneId.systemDefault());\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Debug.java","additions":111,"deletions":24,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,18 +68,0 @@\n-    \/**\n-     * The key bytes, without the algorithm information.\n-     * @deprecated Use the BitArray form which does not require keys to\n-     * be byte aligned.\n-     * @see sun.security.x509.X509Key#setKey(BitArray)\n-     * @see sun.security.x509.X509Key#getKey()\n-     *\/\n-    @Deprecated\n-    protected byte[] key = null;\n-\n-    \/*\n-     * The number of bits unused in the last byte of the key.\n-     * Added to keep the byte[] key form consistent with the BitArray\n-     * form. Can de deleted when byte[] key is deleted.\n-     *\/\n-    @Deprecated\n-    private int unusedBits = 0;\n-\n@@ -115,9 +97,0 @@\n-\n-        \/*\n-         * Do this to keep the byte array form consistent with\n-         * this. Can delete when byte[] key is deleted.\n-         *\/\n-        this.key = key.toByteArray();\n-        int remaining = key.length() % 8;\n-        this.unusedBits =\n-            ((remaining == 0) ? 0 : 8 - remaining);\n@@ -131,12 +104,0 @@\n-        \/*\n-         * Do this for consistency in case a subclass\n-         * modifies byte[] key directly. Remove when\n-         * byte[] key is deleted.\n-         * Note: the consistency checks fail when the subclass\n-         * modifies a non byte-aligned key (into a byte-aligned key)\n-         * using the deprecated byte[] key field.\n-         *\/\n-        this.bitStringKey = new BitArray(\n-                          this.key.length * 8 - this.unusedBits,\n-                          this.key);\n-\n@@ -334,1 +295,1 @@\n-            + \", unparsed keybits = \\n\" + encoder.encodeBuffer(key);\n+            + \", unparsed keybits = \\n\" + encoder.encodeBuffer(bitStringKey.toByteArray());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509Key.java","additions":2,"deletions":41,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -622,10 +622,0 @@\n-            kit.read(r, doc, 0);\n-        } catch (BadLocationException e) {\n-            throw new IOException(e.getMessage());\n-        } catch (ChangedCharSetException changedCharSetException) {\n-            String charSetSpec = changedCharSetException.getCharSetSpec();\n-            if (changedCharSetException.keyEqualsCharSet()) {\n-                putClientProperty(\"charset\", charSetSpec);\n-            } else {\n-                setCharsetFromContentTypeParameters(charSetSpec);\n-            }\n@@ -633,8 +623,7 @@\n-                in.reset();\n-            } catch (IOException exception) {\n-                \/\/mark was invalidated\n-                in.close();\n-                URL url = (URL)doc.getProperty(Document.StreamDescriptionProperty);\n-                if (url != null) {\n-                    URLConnection conn = url.openConnection();\n-                    in = conn.getInputStream();\n+                kit.read(r, doc, 0);\n+            } catch (BadLocationException e) {\n+                throw new IOException(e.getMessage());\n+            } catch (ChangedCharSetException changedCharSetException) {\n+                String charSetSpec = changedCharSetException.getCharSetSpec();\n+                if (changedCharSetException.keyEqualsCharSet()) {\n+                    putClientProperty(\"charset\", charSetSpec);\n@@ -642,2 +631,15 @@\n-                    \/\/there is nothing we can do to recover stream\n-                    throw changedCharSetException;\n+                    setCharsetFromContentTypeParameters(charSetSpec);\n+                }\n+                try {\n+                    in.reset();\n+                } catch (IOException exception) {\n+                    \/\/mark was invalidated\n+                    in.close();\n+                    URL url = (URL)doc.getProperty(Document.StreamDescriptionProperty);\n+                    if (url != null) {\n+                        URLConnection conn = url.openConnection();\n+                        in = conn.getInputStream();\n+                    } else {\n+                        \/\/there is nothing we can do to recover stream\n+                        throw changedCharSetException;\n+                    }\n@@ -645,0 +647,5 @@\n+                try {\n+                    doc.remove(0, doc.getLength());\n+                } catch (BadLocationException e) {}\n+                doc.putProperty(\"IgnoreCharsetDirective\", Boolean.valueOf(true));\n+                read(in, doc);\n@@ -646,5 +653,0 @@\n-            try {\n-                doc.remove(0, doc.getLength());\n-            } catch (BadLocationException e) {}\n-            doc.putProperty(\"IgnoreCharsetDirective\", Boolean.valueOf(true));\n-            read(in, doc);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JEditorPane.java","additions":28,"deletions":26,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,1 +196,0 @@\n-\/\/\/ PENDING(klobad) Who should be opaque in this component?\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JRootPane.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -381,27 +381,0 @@\n-int\n-HandleError(Display * disp, XErrorEvent * err) {\n-    \/\/ silently ignore non-fatal errors\n-    \/*\n-    char msg[0x1000];\n-    char buf[0x1000];\n-    XGetErrorText(disp, err->error_code, msg, sizeof(msg));\n-    fprintf(stderr, \"Xerror %s, XID %x, ser# %d\\n\", msg, err->resourceid,\n-        err->serial);\n-    snprintf(buf, sizeof(buf), \"%d\", err->request_code);\n-    XGetErrorDatabaseText(disp, \"XRequest\", buf, \"Unknown\", msg, sizeof(msg));\n-    fprintf(stderr, \"Major opcode %d (%s)\\n\", err->request_code, msg);\n-    if (err->request_code > 128) {\n-        fprintf(stderr, \"Minor opcode %d\\n\", err->minor_code);\n-    }\n-    *\/\n-    return 0;\n-}\n-\n-int\n-HandleIOError(Display * display) {\n-    \/\/ for really bad errors, we should exit the thread we're on\n-    SplashCleanup(SplashGetInstance());\n-    pthread_exit(NULL);\n-    return 0;\n-}\n-\n@@ -420,4 +393,0 @@\n-    \/\/ We should not ignore any errors.\n-    \/\/XSetErrorHandler(HandleError);\n-\/\/    XSetIOErrorHandler(HandleIOError);\n-    XSetIOErrorHandler(NULL);\n","filename":"src\/java.desktop\/unix\/native\/libsplashscreen\/splashscreen_sys.c","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1997,1 +1997,2 @@\n-            long flags = flags();\n+            \/\/ just in case the method is restricted but that is not a modifier\n+            long flags = flags() & ~RESTRICTED;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -331,7 +331,0 @@\n-    \/** The current `this' symbol.\n-     *  @param env    The current environment.\n-     *\/\n-    Symbol thisSym(DiagnosticPosition pos, Env<AttrContext> env) {\n-        return rs.resolveSelf(pos, env, env.enclClass.sym, names._this);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  const char* const _locale;\n+  char* const _locale;\n@@ -38,1 +38,1 @@\n-  DirectivesParserTest() : _locale(setlocale(LC_NUMERIC, nullptr)) {\n+  DirectivesParserTest() : _locale(os::strdup(setlocale(LC_NUMERIC, nullptr), mtTest)) {\n@@ -43,0 +43,1 @@\n+    os::free(_locale);\n","filename":"test\/hotspot\/gtest\/compiler\/test_directivesParser.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,1 +50,3 @@\n-vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM03\/cm03t001\/TestDescription.java 8299493 macosx-x64\n+vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM03\/cm03t001\/TestDescription.java 8299493 macosx-x64,windows-x64\n+\n+vmTestbase\/nsk\/stress\/thread\/thread006.java 8321476 linux-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+containers\/docker\/TestJFREvents.java 8327723 linux-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8323682\n+ * @summary Test that the appropriate guards are generated for the copyOfRange\n+ *          intrinsic, even if the result of the array copy is not used.\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.arraycopy.TestArrayCopyOfRangeGuards::test\n+ *                   -Xbatch\n+ *                   compiler.arraycopy.TestArrayCopyOfRangeGuards\n+ *\/\n+\n+package compiler.arraycopy;\n+\n+import java.util.Arrays;\n+\n+public class TestArrayCopyOfRangeGuards {\n+    static int counter = 0;\n+\n+    public static void main(String[] args) {\n+        Object[] array = new Object[10];\n+        for (int i = 0; i < 50_000; i++) {\n+            test(array);\n+        }\n+        if (counter != 50_000) {\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+    static void test(Object[] array) {\n+        try {\n+            Arrays.copyOfRange(array, 15, 20, Object[].class);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            \/\/ Expected\n+            counter++;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyOfRangeGuards.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,490 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8324655\n+ * @summary Test that if expressions are properly folded into min\/max nodes\n+ * @requires os.arch != \"riscv64\"\n+ * @library \/test\/lib \/\n+ * @run main compiler.c2.irTests.TestIfMinMax\n+ *\/\n+public class TestIfMinMax {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI1(int a, int b) {\n+        return a < b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI2(int a, int b) {\n+        return a > b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI1(int a, int b) {\n+        return a > b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI2(int a, int b) {\n+        return a < b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI1E(int a, int b) {\n+        return a <= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MIN_I, \"1\" })\n+    public int testMinI2E(int a, int b) {\n+        return a >= b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI1E(int a, int b) {\n+        return a >= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.IF }, counts = { IRNode.MAX_I, \"1\" })\n+    public int testMaxI2E(int a, int b) {\n+        return a <= b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n+    public long testMinL1(long a, long b) {\n+        return a < b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n+    public long testMinL2(long a, long b) {\n+        return a > b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n+    public long testMaxL1(long a, long b) {\n+        return a > b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n+    public long testMaxL2(long a, long b) {\n+        return a < b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n+    public long testMinL1E(long a, long b) {\n+        return a <= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MIN_L, \"1\" })\n+    public long testMinL2E(long a, long b) {\n+        return a >= b ? b : a;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n+    public long testMaxL1E(long a, long b) {\n+        return a >= b ? a : b;\n+    }\n+\n+    @Test\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, failOn = { IRNode.IF }, counts = { IRNode.MAX_L, \"1\" })\n+    public long testMaxL2E(long a, long b) {\n+        return a <= b ? b : a;\n+    }\n+\n+    @Setup\n+    static Object[] setupIntArrays() {\n+        int[] a = new int[512];\n+        int[] b = new int[512];\n+\n+        for (int i = 0; i < 512; i++) {\n+            a[i] = RANDOM.nextInt();\n+            b[i] = RANDOM.nextInt();\n+        }\n+\n+        return new Object[] { a, b };\n+    }\n+\n+    @Setup\n+    static Object[] setupLongArrays() {\n+        long[] a = new long[512];\n+        long[] b = new long[512];\n+\n+        for (int i = 0; i < 512; i++) {\n+            a[i] = RANDOM.nextLong();\n+            b[i] = RANDOM.nextLong();\n+        }\n+\n+        return new Object[] { a, b };\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"SuperWordReductions\", \"true\" },\n+        applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        counts = { IRNode.MAX_REDUCTION_V, \"> 0\" })\n+    @Arguments(setup = \"setupIntArrays\")\n+    public Object[] testMaxIntReduction(int[] a, int[] b) {\n+        int r = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i] * 2;\n+\n+            r = aI > r ? aI : r;\n+        }\n+\n+        return new Object[] { a, r };\n+    }\n+\n+    @Check(test = \"testMaxIntReduction\")\n+    public void checkTestMaxIntReduction(Object[] vals) {\n+        int[] a = (int[]) vals[0];\n+        int testRet = (int) vals[1];\n+\n+        int r = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i] * 2;\n+\n+            r = aI > r ? aI : r;\n+        }\n+\n+        if (r != testRet) {\n+            throw new IllegalStateException(\"Int max reduction test failed: expected \" + testRet + \" but got \" + r);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"SuperWordReductions\", \"true\" },\n+        applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        counts = { IRNode.MIN_REDUCTION_V, \"> 0\" })\n+    @Arguments(setup = \"setupIntArrays\")\n+    public Object[] testMinIntReduction(int[] a, int[] b) {\n+        int r = 0;\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i] * 2;\n+\n+            r = aI < r ? aI : r;\n+        }\n+\n+        return new Object[] { a, r };\n+    }\n+\n+    @Check(test = \"testMinIntReduction\")\n+    public void checkTestMinIntReduction(Object[] vals) {\n+        int[] a = (int[]) vals[0];\n+        int testRet = (int) vals[1];\n+\n+        int r = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i] * 2;\n+\n+            r = aI < r ? aI : r;\n+        }\n+\n+        if (r != testRet) {\n+            throw new IllegalStateException(\"Int min reduction test failed: expected \" + testRet + \" but got \" + r);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"SuperWordReductions\", \"true\" },\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\" },\n+        counts = { IRNode.MAX_REDUCTION_V, \"> 0\" })\n+    @Arguments(setup = \"setupLongArrays\")\n+    public Object[] testMaxLongReduction(long[] a, long[] b) {\n+        long r = 0;\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i] * 2;\n+\n+            r = aI > r ? aI : r;\n+        }\n+\n+        return new Object[] { a, r };\n+    }\n+\n+    @Check(test = \"testMaxLongReduction\")\n+    public void checkTestMaxLongReduction(Object[] vals) {\n+        long[] a = (long[]) vals[0];\n+        long testRet = (long) vals[1];\n+\n+        long r = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i] * 2;\n+\n+            r = aI > r ? aI : r;\n+        }\n+\n+        if (r != testRet) {\n+            throw new IllegalStateException(\"Long max reduction test failed: expected \" + testRet + \" but got \" + r);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"SuperWordReductions\", \"true\" },\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\" },\n+        counts = { IRNode.MIN_REDUCTION_V, \"> 0\" })\n+    @Arguments(setup = \"setupLongArrays\")\n+    public Object[] testMinLongReduction(long[] a, long[] b) {\n+        long r = 0;\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i] * 2;\n+\n+            r = aI < r ? aI : r;\n+        }\n+\n+        return new Object[] { a, r };\n+    }\n+\n+    @Check(test = \"testMinLongReduction\")\n+    public void checkTestMinLongReduction(Object[] vals) {\n+        long[] a = (long[]) vals[0];\n+        long testRet = (long) vals[1];\n+\n+        long r = 0;\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i] * 2;\n+\n+            r = aI < r ? aI : r;\n+        }\n+\n+        if (r != testRet) {\n+            throw new IllegalStateException(\"Long min reduction test failed: expected \" + testRet + \" but got \" + r);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        counts = { IRNode.MAX_VI, \"> 0\" })\n+    @Arguments(setup = \"setupIntArrays\")\n+    public Object[] testMaxIntVector(int[] a, int[] b) {\n+        int[] r = new int[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i];\n+            int bI = b[i];\n+\n+            r[i] = aI > bI ? aI : bI;\n+        }\n+\n+        return new Object[] { a, b, r };\n+    }\n+\n+    @Check(test = \"testMaxIntVector\")\n+    public void checkTestMaxIntVector(Object[] vals) {\n+        int[] a = (int[]) vals[0];\n+        int[] b = (int[]) vals[1];\n+        int[] testRet = (int[]) vals[2];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i];\n+            int bI = b[i];\n+\n+            int r = aI > bI ? aI : bI;\n+\n+            if (r != testRet[i]) {\n+                throw new IllegalStateException(\"Int max vectorization test failed: expected \" + testRet + \" but got \" + r);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        counts = { IRNode.MIN_VI, \"> 0\" })\n+    @Arguments(setup = \"setupIntArrays\")\n+    public Object[] testMinIntVector(int[] a, int[] b) {\n+        int[] r = new int[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i];\n+            int bI = b[i];\n+\n+            r[i] = aI < bI ? aI : bI;\n+        }\n+\n+        return new Object[] { a, b, r };\n+    }\n+\n+    @Check(test = \"testMinIntVector\")\n+    public void checkTestMinIntVector(Object[] vals) {\n+        int[] a = (int[]) vals[0];\n+        int[] b = (int[]) vals[1];\n+        int[] testRet = (int[]) vals[2];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            int aI = a[i];\n+            int bI = b[i];\n+\n+            int r = aI < bI ? aI : bI;\n+\n+            if (r != testRet[i]) {\n+                throw new IllegalStateException(\"Int min vectorization test failed: expected \" + testRet + \" but got \" + r);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        counts = { IRNode.MAX_VL, \"> 0\" })\n+    @Arguments(setup = \"setupLongArrays\")\n+    public Object[] testMaxLongVector(long[] a, long[] b) {\n+        long[] r = new long[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i];\n+            long bI = b[i];\n+\n+            r[i] = aI > bI ? aI : bI;\n+        }\n+\n+        return new Object[] { a, b, r };\n+    }\n+\n+    @Check(test = \"testMaxLongVector\")\n+    public void checkTestMaxLongVector(Object[] vals) {\n+        long[] a = (long[]) vals[0];\n+        long[] b = (long[]) vals[1];\n+        long[] testRet = (long[]) vals[2];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i];\n+            long bI = b[i];\n+\n+            long r = aI > bI ? aI : bI;\n+\n+            if (r != testRet[i]) {\n+                throw new IllegalStateException(\"Long max vectorization test failed: expected \" + testRet + \" but got \" + r);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = { \"sse4.1\", \"true\" , \"asimd\" , \"true\"},\n+        counts = { IRNode.MIN_VL, \"> 0\" })\n+    @Arguments(setup = \"setupLongArrays\")\n+    public Object[] testMinLongVector(long[] a, long[] b) {\n+        long[] r = new long[a.length];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i];\n+            long bI = b[i];\n+\n+            r[i] = aI < bI ? aI : bI;\n+        }\n+\n+        return new Object[] { a, b, r };\n+    }\n+\n+    @Check(test = \"testMinLongVector\")\n+    public void checkTestMinLongVector(Object[] vals) {\n+        long[] a = (long[]) vals[0];\n+        long[] b = (long[]) vals[1];\n+        long[] testRet = (long[]) vals[2];\n+\n+        for (int i = 0; i < a.length; i++) {\n+            long aI = a[i];\n+            long bI = b[i];\n+\n+            long r = aI < bI ? aI : bI;\n+\n+            if (r != testRet[i]) {\n+                throw new IllegalStateException(\"Long min vectorization test failed: expected \" + testRet + \" but got \" + r);\n+            }\n+        }\n+    }\n+\n+    @Run(test = { \"testMinI1\", \"testMinI2\", \"testMaxI1\", \"testMaxI2\", \"testMinI1E\", \"testMinI2E\", \"testMaxI1E\", \"testMaxI2E\" })\n+    public void runTestIntegers() {\n+        testIntegers(10, 20);\n+        testIntegers(20, 10);\n+        testIntegers(10, 10);\n+        testIntegers(Integer.MAX_VALUE, Integer.MIN_VALUE);\n+        testIntegers(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        testIntegers(RANDOM.nextInt(), RANDOM.nextInt());\n+    }\n+\n+    @DontCompile\n+    public void testIntegers(int a, int b) {\n+        Asserts.assertEQ(a < b ? a : b, testMinI1(a, b));\n+        Asserts.assertEQ(a > b ? b : a, testMinI2(a, b));\n+        Asserts.assertEQ(a > b ? a : b, testMaxI1(a, b));\n+        Asserts.assertEQ(a < b ? b : a, testMaxI2(a, b));\n+\n+        Asserts.assertEQ(a <= b ? a : b, testMinI1E(a, b));\n+        Asserts.assertEQ(a >= b ? b : a, testMinI2E(a, b));\n+        Asserts.assertEQ(a >= b ? a : b, testMaxI1E(a, b));\n+        Asserts.assertEQ(a <= b ? b : a, testMaxI2E(a, b));\n+    }\n+\n+    @Run(test = { \"testMinL1\", \"testMinL2\", \"testMaxL1\", \"testMaxL2\", \"testMinL1E\", \"testMinL2E\", \"testMaxL1E\", \"testMaxL2E\" })\n+    public void runTestLongs() {\n+        testLongs(10, 20);\n+        testLongs(20, 10);\n+        testLongs(10, 10);\n+        testLongs(Integer.MAX_VALUE, Integer.MIN_VALUE);\n+        testLongs(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        testLongs(Long.MAX_VALUE, Long.MIN_VALUE);\n+        testLongs(Long.MIN_VALUE, Long.MAX_VALUE);\n+        testLongs(RANDOM.nextLong(), RANDOM.nextLong());\n+    }\n+\n+    @DontCompile\n+    public void testLongs(long a, long b) {\n+        Asserts.assertEQ(a < b ? a : b, testMinL1(a, b));\n+        Asserts.assertEQ(a > b ? b : a, testMinL2(a, b));\n+        Asserts.assertEQ(a > b ? a : b, testMaxL1(a, b));\n+        Asserts.assertEQ(a < b ? b : a, testMaxL2(a, b));\n+\n+        Asserts.assertEQ(a <= b ? a : b, testMinL1E(a, b));\n+        Asserts.assertEQ(a >= b ? b : a, testMinL2E(a, b));\n+        Asserts.assertEQ(a >= b ? a : b, testMaxL1E(a, b));\n+        Asserts.assertEQ(a <= b ? b : a, testMaxL2E(a, b));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIfMinMax.java","additions":490,"deletions":0,"binary":false,"changes":490,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8329126 8329421\n+ * @summary check that native methods get compiled and printed\n+ *\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/native compiler.calls.NativeCalls\n+ *\/\n+\n+package compiler.calls;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class NativeCalls {\n+    static Method emptyStaticNativeMethod;\n+    static Method callNativeMethod;\n+    static {\n+        init();\n+    }\n+    static void init() {\n+        System.loadLibrary(\"NativeCalls\");\n+        try {\n+            emptyStaticNativeMethod = NativeCalls.class.getDeclaredMethod(\"emptyStaticNative\");\n+            callNativeMethod = NativeCalls.class.getDeclaredMethod(\"callNative\");\n+        } catch (NoSuchMethodException nsme) {\n+            throw new Error(\"TEST BUG: can't find test method\", nsme);\n+        }\n+    }\n+\n+    native static void emptyStaticNative();\n+\n+    static void callNative() {\n+        emptyStaticNative();\n+    }\n+\n+    static public void main(String[] args) throws Exception {\n+\n+        ArrayList<String> baseOptions = new ArrayList<String>();\n+        baseOptions.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        baseOptions.add(\"-XX:+WhiteBoxAPI\");\n+        baseOptions.add(\"-Xbootclasspath\/a:.\");\n+        baseOptions.add(\"-Xbatch\");\n+        baseOptions.add(\"-XX:-UseOnStackReplacement\");\n+        baseOptions.add(\"-XX:+PrintCompilation\");\n+        baseOptions.add(Executor.class.getName());\n+        String nativeMethodName = NativeCalls.class.getName() + \"::\" + emptyStaticNativeMethod.getName();\n+        List<Variant> variants = List.of(new Variant(List.of(\"-XX:+TieredCompilation\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\",\n+                                                             \"-XX:+PreferInterpreterNativeStubs\"), \"false\", \"false\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\",\n+                                                             \"-XX:+PreferInterpreterNativeStubs\"), \"false\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=1\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=2\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=3\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\", \"-XX:TieredStopAtLevel=4\"), \"true\", \"false\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\",\n+                                                             \"-XX:CompileCommand=print,\" + nativeMethodName), \"true\", \"true\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\",\n+                                                             \"-XX:CompileCommand=print,\" + nativeMethodName), \"true\", \"true\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\",\n+                                                             \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintAssembly\"), \"true\", \"true\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\",\n+                                                             \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintNativeNMethods\"), \"true\", \"true\"),\n+                                         new Variant(List.of(\"-XX:+TieredCompilation\",\n+                                                             \"-XX:CompileCommand=exclude,\" + nativeMethodName), \"false\", \"false\"),\n+                                         new Variant(List.of(\"-XX:-TieredCompilation\",\n+                                                             \"-XX:CompileCommand=exclude,\" + nativeMethodName), \"false\", \"false\"));\n+        for (Variant v : variants) {\n+            ArrayList<String> command = new ArrayList<String>(v.options);\n+            command.addAll(baseOptions);\n+            command.add(v.compile);\n+            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(command);\n+            OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+            analyzer.shouldHaveExitValue(0);\n+            System.out.println(analyzer.getOutput());\n+            if (Boolean.valueOf(v.print).booleanValue() &&\n+                analyzer.asLines().stream().\n+                filter(Pattern.compile(\"Compiled method.+\" + nativeMethodName + \".*\").asPredicate()).\n+                findAny().isEmpty()) {\n+                throw new Error(nativeMethodName + \" not printed\");\n+            }\n+        }\n+    }\n+\n+    public static class Variant {\n+        Collection<String> options;\n+        String compile;\n+        String print;\n+        public Variant(Collection<String> options, String compile, String print) {\n+            this.options = options;\n+            this. compile = compile;\n+            this. print = print;\n+        }\n+    }\n+\n+    public static class Executor {\n+\n+        static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+        static public void main(String[] args) {\n+\n+            if (args.length != 1) {\n+                throw new Error(\"Expected two arguments\");\n+            }\n+            boolean compile = Boolean.valueOf(args[0]);\n+            for (int i = 0; i < 20_000; i++) {\n+                callNative();\n+            }\n+            if (wb.getMethodCompilationLevel(callNativeMethod) > 0) {\n+                if (compile && !wb.isMethodCompiled(emptyStaticNativeMethod)) {\n+                    throw new Error(\"TEST BUG: '\" + emptyStaticNativeMethod + \"' should be compiled\");\n+                }\n+                if (!compile && wb.isMethodCompiled(emptyStaticNativeMethod)) {\n+                    throw new Error(\"TEST BUG: '\" + emptyStaticNativeMethod + \"' should not be compiled\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/NativeCalls.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+\n+JNIEXPORT\n+void JNICALL Java_compiler_calls_NativeCalls_emptyStaticNative(JNIEnv* env, jclass jclazz) {}\n","filename":"test\/hotspot\/jtreg\/compiler\/calls\/libNativeCalls.c","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-        \/\/ Line example: ccstr PrintIdealGraphAddress = 127.0.0.1 {C2 notproduct} {default}\n+        \/\/ Line example: ccstr PrintIdealGraphAddress = 127.0.0.1 {C2 develop} {default}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/GetFlagValueTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8328938\n+ * @summary Test autovectorization with large scale and stride\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main compiler.loopopts.superword.TestLargeScaleAndStride\n+ *\/\n+\n+\/*\n+ * @test id=AlignVector\n+ * @bug 8328938\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:+AlignVector compiler.loopopts.superword.TestLargeScaleAndStride\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestLargeScaleAndStride {\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    static int RANGE = 100_000;\n+\n+    public static void main(String[] args) {\n+        byte[] a = new byte[100];\n+        fill(a);\n+\n+        byte[] gold1a = a.clone();\n+        byte[] gold1b = a.clone();\n+        byte[] gold2a = a.clone();\n+        byte[] gold2b = a.clone();\n+        byte[] gold2c = a.clone();\n+        byte[] gold2d = a.clone();\n+        byte[] gold3  = a.clone();\n+        test1a(gold1a);\n+        test1b(gold1b);\n+        test2a(gold2a);\n+        test2b(gold2b);\n+        test2c(gold2c);\n+        test2d(gold2d);\n+        test3(gold3);\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test1a(c);\n+            verify(c, gold1a);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test1b(c);\n+            verify(c, gold1b);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test2a(c);\n+            verify(c, gold2a);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test2b(c);\n+            verify(c, gold2b);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test2c(c);\n+            verify(c, gold2c);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test2d(c);\n+            verify(c, gold2d);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test3(c);\n+            verify(c, gold3);\n+        }\n+    }\n+\n+    static void fill(byte[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+          a[i] = (byte)i;\n+        }\n+    }\n+\n+    static void verify(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] != b[i]) {\n+                throw new RuntimeException(\"wrong value: \" + i + \": \" + a[i] + \" != \" + b[i]);\n+            }\n+        }\n+    }\n+\n+    static void test1a(byte[] a) {\n+        int scale = 1 << 31;\n+        for (int i = 0; i < RANGE; i+=2) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 2\n+            \/\/ 2 * (1 >> 31) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+    static void test1b(byte[] a) {\n+        int scale = 1 << 31;\n+        for (int i = RANGE-2; i >= 0; i-=2) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 2\n+            \/\/ 2 * (1 >> 31) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+    static void test2a(byte[] a) {\n+        int scale = 1 << 30;\n+        for (int i = 0; i < RANGE; i+=4) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 4\n+            \/\/ 4 * (1 >> 30) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+\n+    static void test2b(byte[] a) {\n+        int scale = 1 << 30;\n+        for (int i = RANGE-4; i >= 0; i-=4) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 4\n+            \/\/ 4 * (1 >> 30) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+    static void test2c(byte[] a) {\n+        int scale = -(1 << 30);\n+        for (int i = 0; i < RANGE; i+=4) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 4\n+            \/\/ 4 * (1 >> 30) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+    static void test2d(byte[] a) {\n+        int scale = -(1 << 30);\n+        for (int i = RANGE-4; i >= 0; i-=4) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 4\n+            \/\/ 4 * (1 >> 30) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+    static void test3(byte[] a) {\n+        int scale =   1 << 28;\n+        int stride =  1 << 4;\n+        int start = -(1 << 30);\n+        int end =     1 << 30;\n+        for (int i = start; i < end; i+=stride) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestLargeScaleAndStride.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8310886\n+ * @bug 8310886 8325252\n@@ -39,1 +39,1 @@\n-    static final int RANGE = 1024;\n+    static final int RANGE = 1024*16;\n@@ -44,0 +44,1 @@\n+    static int[] ioutArr = new int[RANGE];\n@@ -47,0 +48,5 @@\n+    static final int[] GOLDEN_D;\n+    static final int[] GOLDEN_E;\n+    static final int[] GOLDEN_F;\n+    static final int[] GOLDEN_G;\n+    static final int[] GOLDEN_H;\n@@ -56,0 +62,5 @@\n+        GOLDEN_D = testd();\n+        GOLDEN_E = teste();\n+        GOLDEN_F = testf();\n+        GOLDEN_G = testg();\n+        GOLDEN_H = testh();\n@@ -68,1 +79,1 @@\n-    @Run(test = {\"testa\", \"testb\", \"testc\"})\n+    @Run(test = {\"testa\", \"testb\", \"testc\", \"testd\", \"teste\", \"testf\", \"testg\", \"testh\"})\n@@ -73,1 +84,6 @@\n-        compare(testb(), GOLDEN_C, \"testc\");\n+        compare(testc(), GOLDEN_C, \"testc\");\n+        compare(testd(), GOLDEN_D, \"testd\");\n+        compare(teste(), GOLDEN_E, \"teste\");\n+        compare(testf(), GOLDEN_F, \"testf\");\n+        compare(testg(), GOLDEN_G, \"testg\");\n+        compare(testh(), GOLDEN_H, \"testh\");\n@@ -136,0 +152,95 @@\n+\n+    @Test\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    public static int[] testd() {\n+        int[] out = ioutArr;\n+        for (int i = 0; i < ITER-2; i+=2) {\n+            \/\/ Unrolled, with the same structure.\n+            out[i+0] += ((sArr1[2*i+0] * sArr2[2*i+0]) + (sArr1[2*i+1] * sArr2[2*i+1]));\n+            out[i+1] += ((sArr1[2*i+2] * sArr2[2*i+2]) + (sArr1[2*i+3] * sArr2[2*i+3]));\n+        }\n+        return out;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    public static int[] teste() {\n+        int[] out = ioutArr;\n+        for (int i = 0; i < ITER-2; i+=2) {\n+            \/\/ Unrolled, with some swaps.\n+            out[i+0] += ((sArr1[2*i+0] * sArr2[2*i+0]) + (sArr1[2*i+1] * sArr2[2*i+1]));\n+            out[i+1] += ((sArr2[2*i+2] * sArr1[2*i+2]) + (sArr1[2*i+3] * sArr2[2*i+3])); \/\/ swap(1 2)\n+        }\n+        return out;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    public static int[] testf() {\n+        int[] out = ioutArr;\n+        for (int i = 0; i < ITER-2; i+=2) {\n+            \/\/ Unrolled, with some swaps.\n+            out[i+0] += ((sArr1[2*i+0] * sArr2[2*i+0]) + (sArr1[2*i+1] * sArr2[2*i+1]));\n+            out[i+1] += ((sArr2[2*i+2] * sArr1[2*i+2]) + (sArr2[2*i+3] * sArr1[2*i+3])); \/\/ swap(1 2), swap(3 4)\n+        }\n+        return out;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    public static int[] testg() {\n+        int[] out = ioutArr;\n+        for (int i = 0; i < ITER-2; i+=2) {\n+            \/\/ Unrolled, with some swaps.\n+            out[i+0] += ((sArr1[2*i+0] * sArr2[2*i+0]) + (sArr1[2*i+1] * sArr2[2*i+1]));\n+            out[i+1] += ((sArr1[2*i+3] * sArr2[2*i+3]) + (sArr1[2*i+2] * sArr2[2*i+2])); \/\/ swap(1 3), swap(2 4)\n+        }\n+        return out;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    public static int[] testh() {\n+        int[] out = ioutArr;\n+        for (int i = 0; i < ITER-2; i+=2) {\n+            \/\/ Unrolled, with some swaps.\n+            out[i+0] += ((sArr1[2*i+0] * sArr2[2*i+0]) + (sArr1[2*i+1] * sArr2[2*i+1]));\n+            out[i+1] += ((sArr2[2*i+3] * sArr1[2*i+3]) + (sArr2[2*i+2] * sArr1[2*i+2])); \/\/ swap(1 4), swap(2 3)\n+        }\n+        return out;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMulAddS2I.java","additions":115,"deletions":4,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327110\n+ * @requires vm.compiler2.enabled\n+ * @summary Test that DFS algorithm for cloning Template Assertion Predicate Expression does not endlessly process paths.\n+ * @run main\/othervm\/timeout=30 -Xcomp -XX:LoopMaxUnroll=0\n+ *                              -XX:CompileCommand=compileonly,*TestCloningWithManyDiamondsInExpression::test*\n+ *                              -XX:CompileCommand=inline,*TestCloningWithManyDiamondsInExpression::create*\n+ *                              compiler.predicates.TestCloningWithManyDiamondsInExpression\n+ * @run main\/othervm\/timeout=30 -Xbatch -XX:LoopMaxUnroll=0\n+ *                              -XX:CompileCommand=compileonly,*TestCloningWithManyDiamondsInExpression::test*\n+ *                              -XX:CompileCommand=inline,*TestCloningWithManyDiamondsInExpression::create*\n+ *                              compiler.predicates.TestCloningWithManyDiamondsInExpression\n+ * @run main compiler.predicates.TestCloningWithManyDiamondsInExpression\n+ *\/\n+\n+package compiler.predicates;\n+\n+public class TestCloningWithManyDiamondsInExpression {\n+    static int limit = 100;\n+    static int iFld;\n+    static boolean flag;\n+    static int[] iArr;\n+\n+    public static void main(String[] strArr) {\n+        Math.min(10, 13); \/\/ Load class for Xcomp mode.\n+        for (int i = 0; i < 10_000; i++) {\n+            testSplitIf(i % 2);\n+            testLoopUnswitching(i % 2);\n+        }\n+    }\n+\n+    static void testLoopUnswitching(int x) {\n+        \/\/ We create an array with a positive size whose type range is known by the C2 compiler to be positive.\n+        \/\/ Loop Predication will then be able to hoist the array check out of the loop by creating a Hoisted\n+        \/\/ Check Predicate accompanied by a Template Assertion Predicate. The Template Assertion Predicate\n+        \/\/ Expression gets the size as an input. When splitting the loop further (i.e. when doing Loop Unswitching),\n+        \/\/ the predicate needs to be updated. We need to clone all nodes of the Tempalte Assertion Predicate\n+        \/\/ Expression. We first need to find them by doing a DFS walk.\n+        \/\/\n+        \/\/ createExpressionWithManyDiamonds() creates an expression with many diamonds. The current implementation\n+        \/\/ (found in create_bool_from_template_assertion_predicate()) to clone the Template Assertion Predicate\n+        \/\/ does not use a visited set. Therefore, the DFS implementation visits nodes twice to discover more paths.\n+        \/\/ The more diamonds we add, the more possible paths we get to visit. This leads to an exponential explosion\n+        \/\/ of paths and time required to visit them all. This example here will get \"stuck\" during DFS while trying\n+        \/\/ to walk all the possible paths.\n+        \/\/\n+        int[] a = new int[createExpressionWithManyDiamonds(x) + 1000];\n+        for (int i = 0; i < limit; i++) {\n+            a[i] = i; \/\/ Loop Predication hoists this check and creates a Template Assertion Predicate.\n+            \/\/ Triggers Loop Unswitching -> we need to clone the Template Assertion Predicates\n+            \/\/ to both the true- and false-path loop. Will take forever (see explanation above).\n+            if (x == 0) {\n+                iFld = 34;\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as for Loop Unswitching but triggered in Split If when the Tempalte Assertion Predicate Expression\n+    \/\/ needs to be cloned. This time it's not the size of the array that contains many diamonds but the array\n+    \/\/ index for the first and last value Template Assertion Predicate Expression.\n+    static void testSplitIf(int x) {\n+        int e = createExpressionWithManyDiamonds(x);\n+        iArr = new int[1000];\n+        int a;\n+        if (flag) {\n+            a = 4;\n+        } else {\n+            a = 3;\n+        }\n+\n+        for (int i = a; i < 100; i++) {\n+            iArr[i+e] = 34;\n+        }\n+    }\n+\n+\n+    \/\/ Creates in int expression with many diamonds. This method is forced-inlined.\n+    static int createExpressionWithManyDiamonds(int x) {\n+        int e = Math.min(10, Math.max(1, x));\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2) - 823542;\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2) - 823542;\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2);\n+        e = e + (e << 1) + (e << 2) - 823542;\n+        return e;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestCloningWithManyDiamondsInExpression.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp\n+ * @bug 8328702\n+ * @summary Check that SubTypeCheckNode is properly folded when having an array with bottom type elements checked\n+ *          against an interface.\n+ *\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.types.TestSubTypeCheckWithBottomArray::test*\n+ *                   -XX:CompileCommand=inline,compiler.types.TestSubTypeCheckWithBottomArray::check*\n+ *                   compiler.types.TestSubTypeCheckWithBottomArray\n+ *\/\n+\n+\/*\n+ * @test id=Xbatch\n+ * @bug 8328702\n+ * @summary Check that SubTypeCheckNode is properly folded when having an array with bottom type elements checked\n+ *          against an interface.\n+ *\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,compiler.types.TestSubTypeCheckWithBottomArray::test*\n+ *                   -XX:CompileCommand=inline,compiler.types.TestSubTypeCheckWithBottomArray::check*\n+ *                   compiler.types.TestSubTypeCheckWithBottomArray\n+ *\/\n+\n+\/*\n+ * @test id=stress\n+ * @bug 8328702\n+ * @summary Check that PartialSubtypeCheckNode is properly folded when having an array with bottom type elements checked\n+ *          either against an interface or an unrelated non-sub-class.\n+ *\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.types.TestSubTypeCheckWithBottomArray::test*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+ExpandSubTypeCheckAtParseTime\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+StressReflectiveCode\n+ *                   -XX:CompileCommand=inline,compiler.types.TestSubTypeCheckWithBottomArray::check*\n+ *                   compiler.types.TestSubTypeCheckWithBottomArray\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,compiler.types.TestSubTypeCheckWithBottomArray::test*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+ExpandSubTypeCheckAtParseTime\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+StressReflectiveCode\n+ *                   -XX:CompileCommand=inline,compiler.types.TestSubTypeCheckWithBottomArray::check*\n+ *                   compiler.types.TestSubTypeCheckWithBottomArray\n+ *\/\n+\n+package compiler.types;\n+\n+public class TestSubTypeCheckWithBottomArray {\n+    static byte[] bArr = new byte[10];\n+    static Object[] oArr = new Object[10];\n+    static boolean flag;\n+\n+    public static void main(String[] args) {\n+        A a = new A();\n+        B b = new B();\n+        Y y = new Y();\n+        Z z = new Z();\n+        for (int i = 0; i < 10000; i++) {\n+            \/\/ With -Xcomp: Immediatly crashes because of no profiling -> don't know anything.\n+            checkInterface(a); \/\/ Make sure that checkInterface() sometimes passes instanceof.\n+            checkInterface(b); \/\/ Use two sub classes such that checkcast is required.\n+            testInterface();\n+\n+            checkClass(y); \/\/ Make sure that checkClass() sometimes passes instanceof.\n+            checkClass(z); \/\/ Use two sub classes such that checkcast is required.\n+            testClass();\n+            flag = !flag;\n+        }\n+    }\n+\n+    static void testInterface() {\n+        checkInterface(flag ? bArr : oArr); \/\/ Inlined, never passes instanceof\n+    }\n+\n+    static void checkInterface(Object o) {\n+        if (o instanceof I i) {\n+            \/\/ Use of i: Needs CheckCastPP which is replaced by top because [bottom <: I cannot be true.\n+            \/\/ But: SubTypeCheckNode is not folded away -> broken graph (data dies, control not)\n+            i.getClass();\n+        }\n+    }\n+\n+    static void testClass() {\n+        checkClass(flag ? bArr : oArr); \/\/ Inlined, never passes instanceof\n+    }\n+\n+    static void checkClass(Object o) {\n+        if (o instanceof X x) {\n+            \/\/ Use of i: Needs CheckCastPP which is replaced by top because [bottom <: I cannot be true.\n+            \/\/ But: SubTypeCheckNode is not folded away -> broken graph (data dies, control not)\n+            x.getClass();\n+        }\n+    }\n+\n+}\n+\n+interface I {}\n+class A implements I {}\n+class B implements I {}\n+\n+class X {}\n+class Y extends X {}\n+class Z extends X {}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestSubTypeCheckWithBottomArray.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-        checkPattern(\".*GC\\\\(0\\\\) .*Age table with threshold.*\", stdout);\n+        checkPattern(\".*GC\\\\(0\\\\) .*Age table:.*\", stdout);\n","filename":"test\/hotspot\/jtreg\/gc\/TestAgeOutput.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/hotspot\/jtreg\/gc\/x\/TestGarbageCollectorMXBean.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires vm.compMode != \"Xcomp\"\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestGarbageCollectorMXBean.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,5 +78,5 @@\n-      #1.3 develop & notproduct flag on debug VM:\n-                                      develop & !product_build        notproduct & !product_build\n-                                      -XX:+DeoptimizeALot             -XX:+VerifyCodeCache\n-      -IgnoreUnrecognizedVMOptions               OK                            OK\n-      +IgnoreUnrecognizedVMOptions               OK                            OK\n+      #1.3 develop flag on debug VM:\n+                                      develop & !product_build\n+                                      -XX:+DeoptimizeALot\n+      -IgnoreUnrecognizedVMOptions               OK\n+      +IgnoreUnrecognizedVMOptions               OK\n@@ -86,1 +86,0 @@\n-      runJavaAndCheckExitValue(true, \"-XX:-IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyCodeCache\", \"-version\");\n@@ -88,1 +87,0 @@\n-      runJavaAndCheckExitValue(true, \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyCodeCache\", \"-version\");\n@@ -92,5 +90,5 @@\n-      #1.4 develop & notproduct flag on product VM:\n-                                    develop & !product_build           notproduct & product_build\n-                                    -XX:+DeoptimizeALot                -XX:+VerifyCodeCache\n-      -IgnoreUnrecognizedVMOptions               ERR                           ERR\n-      +IgnoreUnrecognizedVMOptions               OK                            OK\n+      #1.4 develop flag on product VM:\n+                                    develop & product_build\n+                                    -XX:+DeoptimizeALot\n+      -IgnoreUnrecognizedVMOptions               ERR\n+      +IgnoreUnrecognizedVMOptions               OK\n@@ -100,1 +98,0 @@\n-      runJavaAndCheckExitValue(false, \"-XX:-IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyCodeCache\", \"-version\");\n@@ -102,1 +99,0 @@\n-      runJavaAndCheckExitValue(true, \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+VerifyCodeCache\", \"-version\");\n@@ -107,5 +103,5 @@\n-      #1.5 malformed develop & notproduct flag on debug VM:\n-                                  develop & !product_build             notproduct & !product_build\n-                                  -XX:DeoptimizeALot                   -XX:VerifyCodeCache\n-      -IgnoreUnrecognizedVMOptions               ERR                           ERR\n-      +IgnoreUnrecognizedVMOptions               ERR                           ERR\n+      #1.5 malformed develop flag on debug VM:\n+                                  develop & !product_build\n+                                  -XX:DeoptimizeALot\n+      -IgnoreUnrecognizedVMOptions               ERR\n+      +IgnoreUnrecognizedVMOptions               ERR\n@@ -115,1 +111,0 @@\n-      runJavaAndCheckExitValue(false, \"-XX:-IgnoreUnrecognizedVMOptions\", \"-XX:VerifyCodeCache\", \"-version\");\n@@ -117,1 +112,0 @@\n-      runJavaAndCheckExitValue(false, \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:VerifyCodeCache\", \"-version\");\n@@ -121,5 +115,5 @@\n-      #1.6 malformed develop & notproduct flag on product VM:\n-                                    develop & !product_build           notproduct & product_build\n-                                    -XX:DeoptimizeALot                 -XX:VerifyCodeCache\n-      -IgnoreUnrecognizedVMOptions               ERR                           ERR\n-      +IgnoreUnrecognizedVMOptions               OK                            OK\n+      #1.6 malformed develop flag on product VM:\n+                                    develop & !product_build\n+                                    -XX:DeoptimizeALot\n+      -IgnoreUnrecognizedVMOptions               ERR\n+      +IgnoreUnrecognizedVMOptions               OK\n@@ -129,1 +123,0 @@\n-      runJavaAndCheckExitValue(false, \"-XX:-IgnoreUnrecognizedVMOptions\", \"-XX:VerifyCodeCache\", \"-version\");\n@@ -131,1 +124,0 @@\n-      runJavaAndCheckExitValue(true, \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:VerifyCodeCache\", \"-version\");\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/IgnoreUnrecognizedVMOptions.java","additions":21,"deletions":29,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,1 +213,1 @@\n-        allOptionsAsMap = JVMOptionsUtils.getOptionsWithRangeAsMap(origin -> (!(origin.contains(\"develop\") || origin.contains(\"notproduct\"))));\n+        allOptionsAsMap = JVMOptionsUtils.getOptionsWithRangeAsMap(origin -> (!origin.contains(\"develop\")));\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Warn if diagnostic or experimental vm option is used and -XX:+UnlockDiagnosticVMOptions or -XX:+UnlockExperimentalVMOptions, respectively, isn't specified. Warn if develop or notproduct vm option is used with product version of VM.\n+ * @summary Warn if diagnostic or experimental vm option is used and -XX:+UnlockDiagnosticVMOptions or -XX:+UnlockExperimentalVMOptions, respectively, isn't specified. Warn if develop vm option is used with product version of VM.\n@@ -47,1 +47,1 @@\n-            System.out.println(\"Skip the rest of the tests on debug builds since diagnostic, develop, and notproduct options are available on debug builds.\");\n+            System.out.println(\"Skip the rest of the tests on debug builds since diagnostic, and develop options are available on debug builds.\");\n@@ -60,5 +60,0 @@\n-\n-        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+CheckCompressedOops\", \"-version\");\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldNotHaveExitValue(0);\n-        output.shouldContain(\"Error: VM option 'CheckCompressedOops' is notproduct and is available only in debug version of VM.\");\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMOptionWarning.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,87 @@\n+\n+    private static ProcessBuilder processCommand(String loggingLevel) {\n+        return ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \/\/ Test doesn't need much Java heap:\n+            \"-Xmx100M\",\n+            \/\/ AvgMonitorsPerThreadEstimate == 1 means we'll start with\n+            \/\/ an in_use_list_ceiling of <n-threads> plus a couple of\n+            \/\/ of monitors for threads that call Object.wait().\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:AvgMonitorsPerThreadEstimate=1\",\n+            \/\/ MonitorUsedDeflationThreshold == 10 means we'll request\n+            \/\/ deflations when 10% of monitors are used rather than the\n+            \/\/ default 90%. This should allow the test to tolerate a burst\n+            \/\/ of used monitors by threads not under this test's control.\n+            \"-XX:MonitorUsedDeflationThreshold=10\",\n+            \/\/ Enable monitorinflation logging so we can see that\n+            \/\/ MonitorUsedDeflationThreshold and\n+            \/\/ NoAsyncDeflationProgressMaxoption are working.\n+            \"-Xlog:monitorinflation=\" + loggingLevel,\n+            \/\/ Run the test with inflate_count == 33 since that\n+            \/\/ reproduced the bug with JDK13. With inflate_count == 33, an\n+            \/\/ initial ceiling == 12 and MonitorUsedDeflationThreshold == 10,\n+            \/\/ we should hit NoAsyncDeflationProgressMax at least 3 times.\n+            \"MonitorUsedDeflationThresholdTest\", \"33\");\n+    }\n+\n+    private static void testProcess1() throws Exception {\n+        ProcessBuilder pb = processCommand(\"info\");\n+\n+        OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n+        output_detail.shouldHaveExitValue(0);\n+\n+        \/\/ This mesg means:\n+        \/\/ - AvgMonitorsPerThreadEstimate == 1 reduced in_use_list_ceiling\n+        \/\/   to a small number.\n+        \/\/ - and we crossed MonitorUsedDeflationThreshold:\n+        output_detail.shouldMatch(\"begin deflating: .*\");\n+        System.out.println(\"Found beginning of a deflation cycle.\");\n+\n+        \/\/ This mesg means we hit NoAsyncDeflationProgressMax and\n+        \/\/ had to adjust the in_use_list_ceiling:\n+        String too_many = output_detail.firstMatch(\"Too many deflations without progress; .*\", 0);\n+        if (too_many == null) {\n+            output_detail.reportDiagnosticSummary();\n+            throw new RuntimeException(\"Did not find too_many string in output.\\n\");\n+        }\n+        System.out.println(\"too_many='\" + too_many + \"'\");\n+        \/\/ Uncomment the following line for dumping test output in passing runs:\n+        \/\/ output_detail.reportDiagnosticSummary();\n+\n+        System.out.println(\"PASSED.\");\n+    }\n+\n+    private static void testProcess2() throws Exception {\n+        ProcessBuilder pb = processCommand(\"debug\");\n+        OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n+        output_detail.shouldHaveExitValue(0);\n+\n+        \/\/ Test that logging reports in_use_list with each iteration of the deflation thread in debug mode.\n+        \/\/ but not monitor details with each report\n+        output_detail.shouldMatch(   \".debug..monitorinflation. Checking in_use_list:\");\n+        output_detail.shouldNotMatch(\".debug..monitorinflation. .*is_busy\");\n+\n+        \/\/ Reporting stats at exit is in Info mode, and contains monitor details\n+        output_detail.shouldMatch(\".info ..monitorinflation. Checking in_use_list:\");\n+        output_detail.shouldMatch(\".info ..monitorinflation. .*is_busy\");\n+\n+        System.out.println(\"PASSED.\");\n+    }\n+\n+    private static void testProcess3() throws Exception {\n+        ProcessBuilder pb = processCommand(\"trace\");\n+        OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n+        output_detail.shouldHaveExitValue(0);\n+\n+        \/\/ Test that logging reports in_use_list with each iteration of the deflation thread in debug mode.\n+        \/\/ and monitor details with each report\n+        output_detail.shouldMatch(\".debug..monitorinflation. Checking in_use_list:\");\n+        output_detail.shouldMatch(\".trace..monitorinflation. .*is_busy\");\n+\n+        \/\/ Reporting stats at exit is in Info mode, and contains monitor details\n+        output_detail.shouldMatch(\".info ..monitorinflation. Checking in_use_list:\");\n+        output_detail.shouldMatch(\".info ..monitorinflation. .*is_busy\");\n+\n+        System.out.println(\"PASSED.\");\n+    }\n+\n@@ -75,49 +162,4 @@\n-            \/\/ Without args we invoke the test in a java sub-process:\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n-                \/\/ Test doesn't need much Java heap:\n-                \"-Xmx100M\",\n-                \/\/ AvgMonitorsPerThreadEstimate == 1 means we'll start with\n-                \/\/ an in_use_list_ceiling of <n-threads> plus a couple of\n-                \/\/ of monitors for threads that call Object.wait().\n-                \"-XX:+UnlockDiagnosticVMOptions\",\n-                \"-XX:AvgMonitorsPerThreadEstimate=1\",\n-                \/\/ MonitorUsedDeflationThreshold == 10 means we'll request\n-                \/\/ deflations when 10% of monitors are used rather than the\n-                \/\/ default 90%. This should allow the test to tolerate a burst\n-                \/\/ of used monitors by threads not under this test's control.\n-                \"-XX:MonitorUsedDeflationThreshold=10\",\n-                \/\/ Enable monitorinflation logging so we can see that\n-                \/\/ MonitorUsedDeflationThreshold and\n-                \/\/ NoAsyncDeflationProgressMaxoption are working.\n-                \"-Xlog:monitorinflation=info\",\n-                \/\/ Enable some safepoint logging for diagnostic purposes.\n-                \"-Xlog:safepoint+cleanup=info\",\n-                \"-Xlog:safepoint+stats=debug\",\n-                \/\/ Run the test with inflate_count == 33 since that\n-                \/\/ reproduced the bug with JDK13. With inflate_count == 33, an\n-                \/\/ initial ceiling == 12 and MonitorUsedDeflationThreshold == 10,\n-                \/\/ we should hit NoAsyncDeflationProgressMax at least 3 times.\n-                \"MonitorUsedDeflationThresholdTest\", \"33\");\n-\n-            OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n-            output_detail.shouldHaveExitValue(0);\n-\n-            \/\/ This mesg means:\n-            \/\/ - AvgMonitorsPerThreadEstimate == 1 reduced in_use_list_ceiling\n-            \/\/   to a small number.\n-            \/\/ - and we crossed MonitorUsedDeflationThreshold:\n-            output_detail.shouldMatch(\"begin deflating: .*\");\n-            System.out.println(\"Found beginning of a deflation cycle.\");\n-\n-            \/\/ This mesg means we hit NoAsyncDeflationProgressMax and\n-            \/\/ had to adjust the in_use_list_ceiling:\n-            String too_many = output_detail.firstMatch(\"Too many deflations without progress; .*\", 0);\n-            if (too_many == null) {\n-                output_detail.reportDiagnosticSummary();\n-                throw new RuntimeException(\"Did not find too_many string in output.\\n\");\n-            }\n-            System.out.println(\"too_many='\" + too_many + \"'\");\n-            \/\/ Uncomment the following line for dumping test output in passing runs:\n-            \/\/ output_detail.reportDiagnosticSummary();\n-\n-            System.out.println(\"PASSED.\");\n+            \/\/ Without args we invoke the tests in a java sub-process.\n+            testProcess1();\n+            testProcess2();\n+            testProcess3();\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorUsedDeflationThresholdTest.java","additions":92,"deletions":50,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -52,4 +52,4 @@\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+CrashOnOutOfMemoryError\",\n-                                                                             \"-XX:-CreateCoredumpOnCrash\", \"-Xmx128m\",\n-                                                                             \"-Xshare:on\", TestCDSVMCrash.class.getName(),\n-                                                                             \"throwOOME\");\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\"-XX:+CrashOnOutOfMemoryError\",\n+                                                                      \"-XX:-CreateCoredumpOnCrash\", \"-Xmx128m\",\n+                                                                      \"-Xshare:on\", TestCDSVMCrash.class.getName(),\n+                                                                      \"throwOOME\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/TestCDSVMCrash.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/FillerObjectLoadTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestDumpClassListSource.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test locking on shared strings\n- * @requires vm.cds.write.archived.java.heap\n- * @requires vm.gc == null\n- * @library \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/lib\n- * @compile LockStringTest.java LockStringValueTest.java\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run driver LockSharedStrings\n- *\/\n-\n-public class LockSharedStrings {\n-    public static void main(String[] args) throws Exception {\n-        SharedStringsUtils.run(args, LockSharedStrings::test);\n-    }\n-\n-    public static void test(String[] args) throws Exception {\n-        SharedStringsUtils.buildJarAndWhiteBox(\"LockStringTest\", \"LockStringValueTest\");\n-\n-        SharedStringsUtils.dumpWithWhiteBox(\n-            TestCommon.list(\"LockStringTest\", \"LockStringValueTest\"),\n-            \"ExtraSharedInput.txt\", \"-Xlog:cds,cds+hashtables\");\n-\n-        String[] extraMatch = new String[] {\"LockStringTest: PASS\"};\n-        SharedStringsUtils.runWithArchiveAndWhiteBox(extraMatch, \"LockStringTest\");\n-\n-        extraMatch = new String[] {\"LockStringValueTest: PASS\"};\n-        SharedStringsUtils.runWithArchiveAndWhiteBox(extraMatch, \"LockStringValueTest\",\n-            \"--add-opens=java.base\/java.lang=ALL-UNNAMED\");\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/LockSharedStrings.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class LockStringTest extends Thread {\n-    static String lock;\n-    static boolean done;\n-    static WhiteBox wb = WhiteBox.getWhiteBox();\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        if (!wb.areSharedStringsMapped()) {\n-            System.out.println(\"The shared strings are not mapped\");\n-            System.out.println(\"LockStringTest: PASS\");\n-            return;\n-        }\n-\n-        if (!wb.isSharedClass(LockStringTest.class)) {\n-            throw new RuntimeException(\"Failed: LockStringTest class is not shared.\");\n-        }\n-\n-        \/\/ Note: This class is archived. All string literals (including the ones used in this class)\n-        \/\/ in all archived classes are interned into the CDS shared string table.\n-\n-        doTest(\"StringLock\", false);\n-        doTest(\"\", true);\n-\n-        \/\/ The following string has a 0 hashCode. Calling String.hashCode() could cause\n-        \/\/ the String.hash field to be written into, if so make sure we don't functionally\n-        \/\/ break.\n-        doTest(\"\\u0121\\u0151\\u00a2\\u0001\\u0001\\udbb2\", true);\n-    }\n-\n-    private static void doTest(String s, boolean hasZeroHashCode) throws Exception {\n-        lock = s;\n-        done = false;\n-\n-        if (!wb.isSharedInternedString(lock)) {\n-            throw new RuntimeException(\"Failed: String \\\"\" + lock + \"\\\" is not shared.\");\n-        }\n-\n-        if (hasZeroHashCode && lock.hashCode() != 0) {\n-            throw new RuntimeException(\"Shared string \\\"\" + lock + \"\\\" should have 0 hashCode, but is instead \" + lock.hashCode());\n-        }\n-\n-        String copy = new String(lock);\n-        if (lock.hashCode() != copy.hashCode()) {\n-            throw new RuntimeException(\"Shared string \\\"\" + lock + \"\\\" does not have the same hashCode as its non-shared copy\");\n-        }\n-\n-        new LockStringTest().start();\n-\n-        synchronized(lock) {\n-            while (!done) {\n-                lock.wait();\n-            }\n-        }\n-        System.gc();\n-        System.out.println(\"LockStringTest: PASS\");\n-    }\n-\n-    public void run() {\n-        String shared = \"LiveOak\";\n-        synchronized (lock) {\n-            for (int i = 0; i < 100; i++) {\n-                new String(shared);\n-                System.gc();\n-                try {\n-                    sleep(5);\n-                } catch (InterruptedException e) {}\n-            }\n-            done = true;\n-            lock.notify();\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/LockStringTest.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import java.lang.reflect.*;\n-import jdk.test.whitebox.WhiteBox;\n-\n-\/*\n- * Lock the 'value' field of a known shared string, java.lang.Object\n- *\/\n-public class LockStringValueTest {\n-    public static void main(String args[]) {\n-        String s = \"LiveOak\";\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n-\n-        if (!wb.areSharedStringsMapped()) {\n-            System.out.println(\"The shared strings are not mapped\");\n-            System.out.println(\"LockStringValueTest: PASS\");\n-            return;\n-        }\n-\n-        if (!wb.isSharedInternedString(s)) {\n-            throw new RuntimeException(\"LockStringValueTest Failed: String is not shared.\");\n-        }\n-\n-        Class c = s.getClass();\n-        try {\n-            Field f = c.getDeclaredField(\"value\");\n-            f.setAccessible(true);\n-            Object v = f.get(s);\n-            lock(v);\n-        } catch (NoSuchFieldException nfe) {\n-        } catch (IllegalAccessException iae) {}\n-    }\n-\n-    public static void lock(Object o) {\n-        synchronized (o) {\n-            System.out.println(\"LockStringValueTest: PASS\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/LockStringValueTest.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/ResolvedReferencesNotNullTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import jdk.test.lib.process.ProcessTools;\n@@ -72,3 +71,8 @@\n-        String test_cases[][] = {\n-            \/\/ default heap size\n-            {},\n+        OutputAnalyzer dumpOutput = TestCommon.dump(appJar, TestCommon.list(\"HelloString\"),\n+            TestCommon.concat(vmOptionsPrefix,\n+                \"-XX:SharedArchiveConfigFile=\" + sharedArchiveConfigFile,\n+                \"-Xlog:gc+region+cds\",\n+                \"-Xlog:gc+region=trace\"));\n+        TestCommon.checkDump(dumpOutput);\n+        dumpOutput.shouldContain(\"string table array (primary)\");\n+        dumpOutput.shouldContain(\"string table array (secondary)\");\n@@ -76,28 +80,3 @@\n-            \/\/ Test for handling of heap fragmentation. With sharedArchiveConfigFile, we will dump about\n-            \/\/ 18MB of shared objects on 64 bit VM (smaller on 32-bit).\n-            \/\/\n-            \/\/ During dump time, an extra copy of these objects are allocated,\n-            \/\/ so we need about 36MB, plus a few MB for other system data. So 64MB total heap\n-            \/\/ should be enough.\n-            \/\/\n-            \/\/ The VM should executed a full GC to maximize contiguous free space and\n-            \/\/ avoid fragmentation.\n-            {\"-Xmx64m\"},\n-        };\n-\n-        for (String[] extra_opts: test_cases) {\n-            vmOptionsPrefix = TestCommon.concat(vmOptionsPrefix, extra_opts);\n-\n-            OutputAnalyzer dumpOutput = TestCommon.dump(appJar, TestCommon.list(\"HelloString\"),\n-                TestCommon.concat(vmOptionsPrefix,\n-                    \"-XX:SharedArchiveConfigFile=\" + sharedArchiveConfigFile,\n-                    \"-Xlog:gc+region+cds\",\n-                    \"-Xlog:gc+region=trace\"));\n-            TestCommon.checkDump(dumpOutput);\n-            dumpOutput.shouldContain(\"string table array (primary)\");\n-            dumpOutput.shouldContain(\"string table array (secondary)\");\n-\n-            OutputAnalyzer execOutput = TestCommon.exec(appJar,\n-                TestCommon.concat(vmOptionsPrefix, \"-Xlog:cds\", \"HelloString\"));\n-            TestCommon.checkExec(execOutput);\n-        }\n+        OutputAnalyzer execOutput = TestCommon.exec(appJar,\n+            TestCommon.concat(vmOptionsPrefix, \"-Xlog:cds\", \"HelloString\"));\n+        TestCommon.checkExec(execOutput);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/SharedStringsStress.java","additions":12,"deletions":33,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -52,1 +52,3 @@\n-    rml.wait(0);\n+    while (bp_sync_reached) { \/\/ guard against spurious wakeups\n+      rml.wait(0);\n+    }\n@@ -56,1 +58,1 @@\n-  if (do_pop_frame != 0) {\n+  if (do_pop_frame) {\n@@ -155,2 +157,0 @@\n-  bool need_stop = false;\n-\n@@ -158,4 +158,8 @@\n-  while (!need_stop) {\n-    RawMonitorLocker rml(jvmti, jni, monitor);\n-    need_stop = bp_sync_reached;\n-    sleep_ms(1); \/\/ 1 millisecond\n+  RawMonitorLocker rml(jvmti, jni, monitor);\n+  int attempts = 0;\n+  while (!bp_sync_reached) {\n+    if (++attempts > 100) {\n+      fatal(jni, \"Main: ensureAtBreakpoint: waited 20 sec\");\n+    }\n+    LOG(\"Main: ensureAtBreakpoint: waiting 200 millis\\n\");\n+    rml.wait(200); \/\/ 200 milliseconds\n@@ -169,0 +173,3 @@\n+  if (!bp_sync_reached) { \/\/ better diagnosability\n+    fatal(jni, \"Main: notifyAtBreakpoint: expected: bp_sync_reached==true\");\n+  }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/PopFrameTest\/libPopFrameTest.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -186,0 +186,1 @@\n+java\/awt\/FullScreen\/BufferStrategyExceptionTest\/BufferStrategyExceptionTest.java 8246558 windows-all\n@@ -642,0 +643,1 @@\n+javax\/sound\/sampled\/Clip\/ClipFlushCrash.java 8308395 linux-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,3 @@\n+\n+    public static final int COUNTER_TIMEOUT_SECONDS = 60;\n+\n@@ -87,2 +90,2 @@\n-            if (!counter.await(30, TimeUnit.SECONDS)) {\n-                throw new InterruptedException();\n+            if (!counter.await(COUNTER_TIMEOUT_SECONDS, TimeUnit.SECONDS)) {\n+                throw new Error(\"Client: Counter await expired\");\n@@ -97,1 +100,1 @@\n-            throw new Error(\"notification thread interrupted unexpectedly\");\n+            throw new Error(\"notification thread interrupted unexpectedly\", e);\n","filename":"test\/jdk\/com\/sun\/jmx\/remote\/NotificationMarshalVersions\/Client\/Client.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import java.nio.file.Path;\n@@ -56,1 +57,1 @@\n-            File flagsFile = File.createTempFile(\"CheckOriginFlags\", null);\n+            File flagsFile = File.createTempFile(\"CheckOriginFlags\", null, Path.of(\".\").toFile());\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/CheckOrigin.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Dialog;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Point;\n+\n+\/*\n+ * @test\n+ * @bug 4340727\n+ * @summary Tests that undecorated property is set correctly\n+ *          when Frames and Dialogs are mixed.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FrameDialogMixedTest\n+ *\/\n+\n+public class FrameDialogMixedTest {\n+    private static final int SIZE = 100;\n+\n+    private static final String INSTRUCTIONS = \"\"\"\n+            When the test starts, a RED UNDECORATED Frame is seen.\n+            Click on \"Create Dialog\" button, you should see a GREEN UNDECORATED Dialog.\n+            If both the frame and the dialog are undecorated press PASS otherwise FAIL.\"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame.builder()\n+                      .title(\"Undecorated Frame & Dialog Test Instructions\")\n+                      .instructions(INSTRUCTIONS)\n+                      .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                      .columns(40)\n+                      .testUI(FrameDialogMixedTest::createUI)\n+                      .build()\n+                      .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame frame = new Frame(\"Undecorated Frame\");\n+        frame.setSize(SIZE, SIZE);\n+        frame.setBackground(Color.RED);\n+        frame.setUndecorated(true);\n+        frame.setLayout(new FlowLayout(FlowLayout.CENTER));\n+\n+        Button button = new Button(\"Create Dialog\");\n+        button.addActionListener(e -> {\n+            Dialog dialog = new Dialog(frame);\n+            Point frameLoc = frame.getLocationOnScreen();\n+            dialog.setBounds(frameLoc.x + frame.getSize().width + 5,\n+                             frameLoc.y,\n+                             SIZE, SIZE);\n+            dialog.setBackground(Color.GREEN);\n+            dialog.setUndecorated(true);\n+            dialog.setVisible(true);\n+        });\n+\n+        frame.add(button);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/FrameDialogMixedTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.stream.Stream;\n+import javax.imageio.ImageIO;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 4862945\n+ * @summary Undecorated frames miss certain mwm functions in the mwm hints.\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException\n+ * @run main MaximizeUndecoratedTest\n+ *\/\n+\n+public class MaximizeUndecoratedTest {\n+    private static final int SIZE = 300;\n+    private static final int OFFSET = 2;\n+\n+    private static Frame frame;\n+    private static Robot robot;\n+\n+    private static volatile Dimension screenSize;\n+    private static volatile Rectangle maxBounds;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!Toolkit.getDefaultToolkit()\n+                    .isFrameStateSupported(Frame.MAXIMIZED_BOTH)) {\n+            throw new SkippedException(\"Test is not applicable as\"\n+                    + \" the Window manager does not support MAXIMIZATION\");\n+        }\n+\n+        try {\n+            robot = new Robot();\n+\n+            EventQueue.invokeAndWait(MaximizeUndecoratedTest::createUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+                maxBounds = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+                                               .getMaximumWindowBounds();\n+                System.out.println(\"Maximum Window Bounds: \" + maxBounds);\n+                frame.setExtendedState(Frame.MAXIMIZED_BOTH);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            \/\/ Colors sampled at top-left, top-right, bottom-right & bottom-left\n+            \/\/ corners of maximized frame.\n+            Point[] points = new Point[] {\n+                    new Point(maxBounds.x + OFFSET, maxBounds.y + OFFSET),\n+                    new Point(maxBounds.width - OFFSET, maxBounds.y + OFFSET),\n+                    new Point(maxBounds.width - OFFSET, maxBounds.height - OFFSET),\n+                    new Point(maxBounds.x + OFFSET, maxBounds.height - OFFSET)\n+            };\n+\n+            if (!Stream.of(points)\n+                       .map(p -> robot.getPixelColor(p.x, p.y))\n+                       .allMatch(c -> c.equals(Color.GREEN))) {\n+                saveScreenCapture();\n+                throw new RuntimeException(\"Test Failed !! Frame not maximized.\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.setExtendedState(Frame.NORMAL);\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createUI() {\n+        frame = new Frame(\"Test Maximization of Frame\");\n+        frame.setSize(SIZE, SIZE);\n+        frame.setBackground(Color.GREEN);\n+        frame.setResizable(true);\n+        frame.setUndecorated(true);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void saveScreenCapture() {\n+        BufferedImage image = robot.createScreenCapture(new Rectangle(new Point(),\n+                                                                      screenSize));\n+        try {\n+            ImageIO.write(image, \"png\", new File(\"MaximizedFrame.png\"));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/MaximizeUndecoratedTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import javax.imageio.ImageIO;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 6251941\n+ * @summary Undecorated frames should be minimizable.\n+ * @library \/test\/lib\n+ * @build jtreg.SkippedException\n+ * @run main MinimizeUndecoratedTest\n+ *\/\n+\n+public class MinimizeUndecoratedTest {\n+    private static final int SIZE = 300;\n+    private static final CountDownLatch isMinimized = new CountDownLatch(1);\n+\n+    private static Frame frame;\n+    private static Robot robot;\n+\n+    private static volatile Point frameLoc;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!Toolkit.getDefaultToolkit()\n+                    .isFrameStateSupported(Frame.ICONIFIED)) {\n+            throw new SkippedException(\"Test is not applicable as\"\n+                    + \" the Window manager does not support MINIMIZATION\");\n+        }\n+\n+        try {\n+            robot = new Robot();\n+            EventQueue.invokeAndWait(MinimizeUndecoratedTest::createUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> frameLoc = frame.getLocationOnScreen());\n+\n+            Color beforeColor = robot.getPixelColor(frameLoc.x + SIZE \/ 2,\n+                                                    frameLoc.y + SIZE \/ 2);\n+\n+            EventQueue.invokeAndWait(() -> frame.setExtendedState(Frame.ICONIFIED));\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            if (!isMinimized.await(8, TimeUnit.SECONDS)) {\n+                throw new RuntimeException(\"Window iconified event not received.\");\n+            }\n+\n+            EventQueue.invokeAndWait(() -> System.out.println(\"Frame state: \"\n+                                                              + frame.getExtendedState()));\n+            Color afterColor = robot.getPixelColor(frameLoc.x + SIZE \/ 2,\n+                                                   frameLoc.y + SIZE \/ 2);\n+\n+            if (beforeColor.equals(afterColor)) {\n+                saveScreenCapture();\n+                throw new RuntimeException(\"Color before & after minimization : \"\n+                                           + beforeColor + \" vs \" + afterColor + \"\\n\"\n+                                           + \"Test Failed !! Frame not minimized.\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.setExtendedState(Frame.NORMAL);\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createUI() {\n+        frame = new Frame(\"Test Minimization of Frame\");\n+        frame.setSize(SIZE, SIZE);\n+        frame.setBackground(Color.GREEN);\n+        frame.setResizable(true);\n+        frame.setUndecorated(true);\n+        frame.addWindowStateListener(new WindowAdapter() {\n+            @Override\n+            public void windowStateChanged(WindowEvent e) {\n+                if (e.getNewState() == Frame.ICONIFIED) {\n+                    System.out.println(\"Window iconified event received.\");\n+                    isMinimized.countDown();\n+                }\n+            }\n+        });\n+\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static void saveScreenCapture() {\n+        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+        BufferedImage image = robot.createScreenCapture(new Rectangle(new Point(),\n+                                                                      screenSize));\n+        try {\n+            ImageIO.write(image, \"png\", new File(\"MinimizedFrame.png\"));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/MinimizeUndecoratedTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -1,328 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-  test %W% %E%  %I%, %G%\n-  @bug 6315717\n-  @summary  manual control over the Robot\n-  @author Andrei Dmitriev : area=awt.robot\n-  @run applet\/manual=yesno ManualInstructions.html\n-*\/\n-\n-import java.applet.Applet;\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.util.Timer;\n-import java.util.TimerTask;\n-\n-public class ManualInstructions extends Applet\n-{\n-    final static long SEND_DELAY = 1000;\n-\n-    public static void main(String s[]){\n-        ManualInstructions mi = new ManualInstructions();\n-        mi.init();\n-        mi.start();\n-    }\n-\n-    static Robot robot;\n-    Point mouseLocation; \/\/where mouse should be pressed each time\n-    Panel target = new Panel();\n-    Button pressOn = new Button(\"press on ...\");\n-    Button releaseOn = new Button(\"release on ...\");\n-    Button clickOn = new Button(\"click on ...\");\n-    Choice buttonNumber = new Choice();\n-\n-    public void init()\n-    {\n-        try {\n-            robot = new Robot();\n-        } catch (AWTException ex) {\n-            ex.printStackTrace();\n-            throw new RuntimeException(ex);\n-        }\n-        this.setLayout (new BorderLayout ());\n-\n-        target.setBackground(Color.green);\n-        target.setName(\"GreenBox\");\/\/for the ease of debug\n-        target.setPreferredSize(new Dimension(100, 100));\n-        String toolkit = Toolkit.getDefaultToolkit().getClass().getName();\n-\n-        \/\/ on X systems two buttons are reserved for wheel though they are countable by MouseInfo.\n-        int buttonsNumber = toolkit.equals(\"sun.awt.windows.WToolkit\")?MouseInfo.getNumberOfButtons():MouseInfo.getNumberOfButtons()-2;\n-\n-        for (int i = 0; i < 8; i++){\n-            buttonNumber.add(\"BUTTON\"+(i+1)+\"_MASK\");\n-        }\n-\n-        pressOn.addActionListener(new ActionListener(){\n-                public void actionPerformed(ActionEvent e){\n-                    System.out.println(\"Now pressing : \" + (buttonNumber.getSelectedIndex()+1));\n-\n-                    Timer timer = new Timer();\n-                    TimerTask robotInteraction = new TimerTask(){\n-                            public void run(){\n-                                robot.mouseMove(updateTargetLocation().x, updateTargetLocation().y);\n-                                robot.mousePress(getMask(buttonNumber.getSelectedIndex()+1));\n-                            }\n-                        };\n-                    timer.schedule(robotInteraction, SEND_DELAY);\n-                }\n-            });\n-\n-        releaseOn.addActionListener(new ActionListener(){\n-            public void actionPerformed(ActionEvent e){\n-                System.out.println(\"Now releasing : \" + (buttonNumber.getSelectedIndex()+1));\n-                Timer timer = new Timer();\n-                TimerTask robotInteraction = new TimerTask(){\n-                        public void run(){\n-                            robot.mouseMove(updateTargetLocation().x, updateTargetLocation().y);\n-                            robot.mouseRelease(getMask(buttonNumber.getSelectedIndex()+1));\n-                        }\n-                    };\n-                timer.schedule(robotInteraction, SEND_DELAY);\n-            }\n-        });\n-\n-        clickOn.addActionListener(new ActionListener(){\n-            public void actionPerformed(ActionEvent e){\n-                System.out.println(\"Now clicking : \" + (buttonNumber.getSelectedIndex()+1));\n-                Timer timer = new Timer();\n-                TimerTask robotInteraction = new TimerTask(){\n-                        public void run(){\n-                            robot.mouseMove(updateTargetLocation().x, updateTargetLocation().y);\n-                            robot.mousePress(getMask(buttonNumber.getSelectedIndex()+1));\n-                            robot.mouseRelease(getMask(buttonNumber.getSelectedIndex()+1));\n-                        }\n-                    };\n-                timer.schedule(robotInteraction, SEND_DELAY);\n-            }\n-\n-        });\n-        target.addMouseListener(new MouseAdapter(){\n-           public void mousePressed(MouseEvent e){\n-                Sysout.println(\"\"+e);\n-           }\n-           public void mouseReleased(MouseEvent e){\n-                Sysout.println(\"\"+e);\n-           }\n-           public void mouseClicked(MouseEvent e){\n-                Sysout.println(\"\"+e);\n-           }\n-        });\n-\n-        String[] instructions =\n-        {\n-            \"Do provide an instruction to the robot by\",\n-            \"choosing the button number to act and \",\n-            \"pressing appropriate java.awt.Button on the left.\",\n-            \"Inspect an output in the TextArea below.\",\n-            \"Please don't generate non-natural sequences like Release-Release, etc.\",\n-            \"If you use keyboard be sure that you released the keyboard shortly.\",\n-            \"If events are generated well press Pass, otherwise Fail.\"\n-        };\n-        Sysout.createDialogWithInstructions( instructions );\n-\n-    }\/\/End  init()\n-\n-    private int getMask(int button){\n-        return InputEvent.getMaskForButton(button);\n-\n-        \/*\n-            \/\/this only works for standard buttons and for old JDK builds\n-        int mask = 0;\n-        switch (button){\n-        case 1: {\n-            mask = InputEvent.BUTTON1_MASK;\n-            break;\n-        }\n-        case 2: {\n-            mask = InputEvent.BUTTON2_MASK;\n-            break;\n-        }\n-        case 3: {\n-            mask = InputEvent.BUTTON3_MASK;\n-            break;\n-        }\n-        }\n-        return mask;\n-        *\/\n-    }\n-\n-    private Point updateTargetLocation() {\n-        return new Point(target.getLocationOnScreen().x + target.getWidth()\/2, target.getLocationOnScreen().y + target.getHeight()\/2);\n-    }\n-\n-    public void start ()\n-    {\n-        \/\/Get things going.  Request focus, set size, et cetera\n-        setSize (200,200);\n-        setVisible(true);\n-        validate();\n-        Frame f = new Frame (\"Set action for Robot here.\");\n-        f.setLayout(new FlowLayout());\n-        f.add(buttonNumber);\n-        f.add(pressOn);\n-        f.add(releaseOn);\n-        f.add(clickOn);\n-        f.add(target);\n-        f.pack();\n-        f.setVisible(true);\n-     }\/\/ start()\n-}\/\/ class\n-\n-\/* Place other classes related to the test after this line *\/\n-\n-\n-\/****************************************************\n- Standard Test Machinery\n- DO NOT modify anything below -- it's a standard\n-  chunk of code whose purpose is to make user\n-  interaction uniform, and thereby make it simpler\n-  to read and understand someone else's test.\n- ****************************************************\/\n-\n-\/**\n- This is part of the standard test machinery.\n- It creates a dialog (with the instructions), and is the interface\n-  for sending text messages to the user.\n- To print the instructions, send an array of strings to Sysout.createDialog\n-  WithInstructions method.  Put one line of instructions per array entry.\n- To display a message for the tester to see, simply call Sysout.println\n-  with the string to be displayed.\n- This mimics System.out.println but works within the test harness as well\n-  as standalone.\n- *\/\n-\n-class Sysout\n-{\n-    private static TestDialog dialog;\n-\n-    public static void createDialogWithInstructions( String[] instructions )\n-    {\n-        dialog = new TestDialog( new Frame(), \"Instructions\" );\n-        dialog.printInstructions( instructions );\n-        dialog.setVisible(true);\n-        println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-    public static void createDialog( )\n-    {\n-        dialog = new TestDialog( new Frame(), \"Instructions\" );\n-        String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-        dialog.printInstructions( defInstr );\n-        dialog.setVisible(true);\n-        println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-    public static void printInstructions( String[] instructions )\n-    {\n-        dialog.printInstructions( instructions );\n-    }\n-\n-\n-    public static void println( String messageIn )\n-    {\n-        dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog\n-{\n-\n-    TextArea instructionsText;\n-    TextArea messageText;\n-    int maxStringLength = 120;\n-\n-    \/\/DO NOT call this directly, go through Sysout\n-    public TestDialog( Frame frame, String name )\n-    {\n-        super( frame, name );\n-        int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-        instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-        add( \"North\", instructionsText );\n-\n-        messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-        add(\"Center\", messageText);\n-\n-        pack();\n-\n-        setVisible(true);\n-    }\/\/ TestDialog()\n-\n-    \/\/DO NOT call this directly, go through Sysout\n-    public void printInstructions( String[] instructions )\n-    {\n-        \/\/Clear out any current instructions\n-        instructionsText.setText( \"\" );\n-\n-        \/\/Go down array of instruction strings\n-\n-        String printStr, remainingStr;\n-        for( int i=0; i < instructions.length; i++ )\n-        {\n-            \/\/chop up each into pieces maxSringLength long\n-            remainingStr = instructions[ i ];\n-            while( remainingStr.length() > 0 )\n-            {\n-                \/\/if longer than max then chop off first max chars to print\n-                if( remainingStr.length() >= maxStringLength )\n-                {\n-                    \/\/Try to chop on a word boundary\n-                    int posOfSpace = remainingStr.\n-                        lastIndexOf( ' ', maxStringLength - 1 );\n-\n-                    if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-                    printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-                    remainingStr = remainingStr.substring( posOfSpace + 1 );\n-                }\n-                \/\/else just print\n-                else\n-                {\n-                    printStr = remainingStr;\n-                    remainingStr = \"\";\n-                }\n-\n-                instructionsText.append( printStr + \"\\n\" );\n-            }\/\/ while\n-        }\/\/ for\n-    }\/\/printInstructions()\n-\n-    \/\/DO NOT call this directly, go through Sysout\n-    public void displayMessage( String messageIn )\n-    {\n-        messageText.append( messageIn + \"\\n\" );\n-        System.out.println(messageIn);\n-    }\n-\n-}\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/Robot\/ManualInstructions\/ManualInstructions.java","additions":0,"deletions":328,"binary":false,"changes":328,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.Color;\n-import java.awt.Graphics2D;\n-import java.awt.event.ActionEvent;\n-import java.awt.print.PageFormat;\n-import java.awt.print.Paper;\n-import java.awt.print.Printable;\n-import java.awt.print.PrinterJob;\n-\n-import javax.swing.JButton;\n-\n-\/*\n- * @test\n- * @bug 5024549\n- * @key printer\n- * @library \/java\/awt\/regtesthelpers\n- * @build PassFailJFrame\n- * @summary Pass if dialogs are modal.\n- * @run main\/manual PrintModalDialog\n- *\/\n-\n-public class PrintModalDialog {\n-    private static JButton jButton1;\n-    private static final String INSTRUCTIONS =\n-            \"\"\"\n-             Click the \"PRINT\" button in the test window. A new dialog\n-             should appear to print the page. Test if this print new dialog\n-             is actually modal.\n-\n-             Modal in this case means that it blocks the user from interacting\n-             with other windows in the same application. You may still be able\n-             to interact with unrelated applications on the desktop.\n-             One sure way to test this is to first show the print dialog and\n-             then press \"Fail\", because if you can click on \"Fail\" and have it\n-             respond, then the print dialog was not modal. If clicking on it\n-             does nothing then cancel the print dialog and do the same for the\n-             other print dialog. If all is well, then press Pass.\n-            \"\"\";\n-\n-    public static void main(String[] args) throws Exception {\n-        PassFailJFrame\n-                .builder()\n-                .title(\"PrintModalDialog Instructions\")\n-                .instructions(INSTRUCTIONS)\n-                .rows((int) INSTRUCTIONS.lines().count() + 1)\n-                .columns(40)\n-                .splitUIBottom(PrintModalDialog::createAndShowGUI)\n-                .build()\n-                .awaitAndCheck();\n-    }\n-\n-    public static JButton createAndShowGUI() {\n-        jButton1 = new JButton(\"PRINT\");\n-        jButton1.addActionListener(e -> jButton1_actionPerformed(e));\n-        return jButton1;\n-    }\n-\n-    static void jButton1_actionPerformed(ActionEvent e) {\n-        PrinterJob printJob = null;\n-        PageFormat pageFormat = null;\n-        Paper prtPaper = null;\n-        boolean bPrintFlg = true;\n-\n-        try {\n-            printJob = PrinterJob.getPrinterJob();\n-        }\n-        catch (SecurityException se) {\n-            bPrintFlg = false;\n-        }\n-\n-        if (bPrintFlg) {\n-            pageFormat = printJob.pageDialog(printJob.defaultPage());\n-            System.out.println(\"PrintModalDialog: pageFormat = \" +\n-                    pageFormat.getWidth() \/ 72.0 + \" x \" +\n-                    pageFormat.getHeight() \/ 72.0);\n-            if (pageFormat != null) {\n-                prtPaper = pageFormat.getPaper();\n-                pageFormat.setPaper(prtPaper);\n-                printJob.setPrintable((g, pf, page) -> {\n-                    System.out.println(\"Calling print\");\n-                    if (page == 0) {\n-                        Graphics2D g2 = (Graphics2D)g;\n-                        g2.translate(pf.getImageableX(), pf.getImageableY());\n-                        g2.setColor(Color.black);\n-                        g2.drawString(\"Hello World\", 20, 100);\n-\n-                        return Printable.PAGE_EXISTS;\n-                    }\n-                    return Printable.NO_SUCH_PAGE;\n-                }, pageFormat);\n-            }\n-\n-            if (printJob.printDialog()) {\n-                try {\n-                    printJob.print();\n-                }\n-                catch (java.awt.print.PrinterException ex) {\n-                    ex.printStackTrace();\n-                    String msg = \"PrinterException: \" + ex.getMessage();\n-                    PassFailJFrame.forceFail(msg);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/print\/Dialog\/PrintModalDialog.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,20 +24,1 @@\n-\/*\n-  @test\n-  @bug 4199506\n-  @summary  java.awt.print.PageFormat.setpaper(Paper paper)\n-                 assertion test fails by not throwing\n-                 NullPointerException when a null paper instance is\n-                 passed as argument and this is specified in the doc.\n-  @run main NullPaper\n-*\/\n-\n-\n-\/\/*** global search and replace NullPaper with name of the test ***\n-\n-\/**\n- * NullPaper.java\n- *\n- * summary: java.awt.print.PageFormat.setpaper(Paper paper)\n-                 assertion test fails by not throwing\n-                 NullPointerException when a null paper instance is\n-                 passed as argument and this is specified in the doc.\n+import java.awt.print.PageFormat;\n@@ -45,0 +26,6 @@\n+\/*\n+ * @test\n+ * @bug 4199506\n+ * @summary Verify PageFormat.setPaper(null) throws NullPointerException\n+ *          as specified\n+ * @run main NullPaper\n@@ -46,126 +33,13 @@\n-\n-import java.awt.print.*;\n-\n-\/\/ This test is a \"main\" test as applets would need Runtime permission\n-\/\/ \"queuePrintJob\".\n-\n-public class NullPaper {\n-\n-   private static void init()\n-    {\n-    boolean settingNullWorked = false;\n-\n-    try {\n-        \/* Setting the paper to null should throw an exception.\n-         * The bug was the exception was not being thrown.\n-         *\/\n-        new PageFormat().setPaper(null);\n-        settingNullWorked = true;\n-\n-    \/* If the test succeeds we'll end up here, so write\n-     * to standard out.\n-     *\/\n-    } catch (NullPointerException e) {\n-        pass();\n-\n-    \/* The test failed if we end up here because an exception\n-     * other than the one we were expecting was thrown.\n-     *\/\n-    } catch (Exception e) {\n-        fail(\"Instead of the expected NullPointerException, '\" + e + \"' was thrown.\");\n-    }\n-\n-    if (settingNullWorked) {\n-        fail(\"The expected NullPointerException was not thrown\");\n-    }\n-\n-    }\/\/End  init()\n-\n-\n-   \/*****************************************************\n-     Standard Test Machinery Section\n-      DO NOT modify anything in this section -- it's a\n-      standard chunk of code which has all of the\n-      synchronisation necessary for the test harness.\n-      By keeping it the same in all tests, it is easier\n-      to read and understand someone else's test, as\n-      well as insuring that all tests behave correctly\n-      with the test harness.\n-     There is a section following this for test-defined\n-      classes\n-   ******************************************************\/\n-   private static boolean theTestPassed = false;\n-   private static boolean testGeneratedInterrupt = false;\n-   private static String failureMessage = \"\";\n-\n-   private static Thread mainThread = null;\n-\n-   private static int sleepTime = 300000;\n-\n-   public static void main( String args[] ) throws InterruptedException\n-    {\n-      mainThread = Thread.currentThread();\n-      try\n-       {\n-         init();\n-       }\n-      catch( TestPassedException e )\n-       {\n-         \/\/The test passed, so just return from main and harness will\n-         \/\/ interepret this return as a pass\n-         return;\n-       }\n-      \/\/At this point, neither test passed nor test failed has been\n-      \/\/ called -- either would have thrown an exception and ended the\n-      \/\/ test, so we know we have multiple threads.\n-\n-      \/\/Test involves other threads, so sleep and wait for them to\n-      \/\/ called pass() or fail()\n-      try\n-       {\n-         Thread.sleep( sleepTime );\n-         \/\/Timed out, so fail the test\n-         throw new RuntimeException( \"Timed out after \" + sleepTime\/1000 + \" seconds\" );\n-       }\n-      catch (InterruptedException e)\n-       {\n-         if( ! testGeneratedInterrupt ) throw e;\n-\n-         \/\/reset flag in case hit this code more than once for some reason (just safety)\n-         testGeneratedInterrupt = false;\n-         if ( theTestPassed == false )\n-          {\n-            throw new RuntimeException( failureMessage );\n-          }\n-       }\n-\n-    }\/\/main\n-\n-   public static synchronized void setTimeoutTo( int seconds )\n-    {\n-      sleepTime = seconds * 1000;\n-    }\n-\n-   public static synchronized void pass()\n-    {\n-      System.out.println( \"The test passed.\" );\n-      \/\/first check if this is executing in main thread\n-      if ( mainThread == Thread.currentThread() )\n-       {\n-         \/\/Still in the main thread, so set the flag just for kicks,\n-         \/\/ and throw a test passed exception which will be caught\n-         \/\/ and end the test.\n-         theTestPassed = true;\n-         throw new TestPassedException();\n-       }\n-      \/\/pass was called from a different thread, so set the flag and interrupt\n-      \/\/ the main thead.\n-      theTestPassed = true;\n-      testGeneratedInterrupt = true;\n-      mainThread.interrupt();\n-    }\/\/pass()\n-\n-   public static synchronized void fail()\n-    {\n-      \/\/test writer didn't specify why test failed, so give generic\n-      fail( \"it just plain failed! :-)\" );\n+public final class NullPaper {\n+    public static void main(String[] args) {\n+        try {\n+            \/* Setting the paper to null should throw an exception.\n+             * The bug was the exception was not being thrown.\n+             *\/\n+            new PageFormat().setPaper(null);\n+\n+            throw new RuntimeException(\"NullPointerException is expected \"\n+                                       + \"but not thrown\");\n+        } catch (NullPointerException e) {\n+            System.out.println(\"NullPointerException caught - test passes\");\n+        }\n@@ -173,24 +47,1 @@\n-\n-   public static synchronized void fail( String whyFailed )\n-    {\n-      System.out.println( \"The test failed: \" + whyFailed );\n-      \/\/check if this called from main thread\n-      if ( mainThread == Thread.currentThread() )\n-       {\n-         \/\/If main thread, fail now 'cause not sleeping\n-         throw new RuntimeException( whyFailed );\n-       }\n-      theTestPassed = false;\n-      testGeneratedInterrupt = true;\n-      failureMessage = whyFailed;\n-      mainThread.interrupt();\n-    }\/\/fail()\n-\n- }\/\/ class NullPaper\n-\n-\/\/This exception is used to exit from any level of call nesting\n-\/\/ when it's determined that the test has passed, and immediately\n-\/\/ end the test.\n-class TestPassedException extends RuntimeException\n- {\n- }\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PageFormat\/NullPaper.java","additions":22,"deletions":171,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,18 @@\n-\/**\n+import java.awt.Button;\n+import java.awt.Checkbox;\n+import java.awt.Color;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GridLayout;\n+import java.awt.Label;\n+import java.awt.Panel;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Paper;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n@@ -26,5 +43,1 @@\n- * @bug 4197377\n- * @bug 4299145\n- * @bug 6358747\n- * @bug 6574633\n- * @summary Page setup dialog settings\n+ * @bug 4197377 4299145 6358747 6574633\n@@ -32,0 +45,3 @@\n+ * @summary Page setup dialog settings\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -34,5 +50,0 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-\n@@ -40,42 +51,67 @@\n-\n-  PrinterJob myPrinterJob;\n-  PageFormat myPageFormat;\n-  Label pw, ph, pglm, pgiw, pgrm, pgtm, pgih, pgbm;\n-  Label myWidthLabel;\n-  Label myHeightLabel;\n-  Label myImageableXLabel;\n-  Label myImageableYLabel;\n-  Label myImageableRightLabel;\n-  Label myImageableBottomLabel;\n-  Label myImageableWidthLabel;\n-  Label myImageableHeightLabel;\n-  Label myOrientationLabel;\n-  Checkbox reverseCB;\n-  boolean alpha = false;\n-  boolean reverse = false;\n-\n-  protected void displayPageFormatAttributes() {\n-\n-    myWidthLabel.setText(\"Format Width = \" + (float)myPageFormat.getWidth());\n-    myHeightLabel.setText(\"Format Height = \" + (float)myPageFormat.getHeight());\n-    myImageableXLabel.setText\n-        (\"Format Left Margin = \" + (float)myPageFormat.getImageableX());\n-    myImageableRightLabel.setText\n-        (\"Format Right Margin = \" + (float)(myPageFormat.getWidth() -\n-        (myPageFormat.getImageableX() + myPageFormat.getImageableWidth())));\n-    myImageableWidthLabel.setText\n-        (\"Format ImageableWidth = \" + (float)myPageFormat.getImageableWidth());\n-    myImageableYLabel.setText\n-        (\"Format Top Margin = \" + (float)myPageFormat.getImageableY());\n-    myImageableBottomLabel.setText\n-        (\"Format Bottom Margin = \" + (float)(myPageFormat.getHeight() -\n-        (myPageFormat.getImageableY() + myPageFormat.getImageableHeight())));\n-    myImageableHeightLabel.setText\n-        (\"Format ImageableHeight = \" + (float)myPageFormat.getImageableHeight());\n-    int o = myPageFormat.getOrientation();\n-    if (o == PageFormat.LANDSCAPE && reverse) {\n-        o = PageFormat.REVERSE_LANDSCAPE;\n-        myPageFormat.setOrientation(PageFormat.REVERSE_LANDSCAPE);\n-    } else if (o == PageFormat.REVERSE_LANDSCAPE && !reverse) {\n-        o = PageFormat.LANDSCAPE;\n-        myPageFormat.setOrientation(PageFormat.LANDSCAPE);\n+    PrinterJob myPrinterJob;\n+    PageFormat myPageFormat;\n+    Label pw, ph, pglm, pgiw, pgrm, pgtm, pgih, pgbm;\n+    Label myWidthLabel;\n+    Label myHeightLabel;\n+    Label myImageableXLabel;\n+    Label myImageableYLabel;\n+    Label myImageableRightLabel;\n+    Label myImageableBottomLabel;\n+    Label myImageableWidthLabel;\n+    Label myImageableHeightLabel;\n+    Label myOrientationLabel;\n+    Checkbox reverseCB;\n+    boolean alpha = false;\n+    boolean reverse = false;\n+\n+    private static final String INSTRUCTIONS =\n+            \" This test is very flexible and requires much interaction.\\n\" +\n+            \" If the platform print dialog supports it, adjust orientation\\n\" +\n+            \" and margins and print pages and compare the results with the request.\";\n+\n+    protected void displayPageFormatAttributes() {\n+        myWidthLabel.setText(\"Format Width = \" + myPageFormat.getWidth());\n+        myHeightLabel.setText(\"Format Height = \" + myPageFormat.getHeight());\n+        myImageableXLabel.setText(\"Format Left Margin = \"\n+                + myPageFormat.getImageableX());\n+        myImageableRightLabel.setText(\"Format Right Margin = \"\n+                + (myPageFormat.getWidth()\n+                        - (myPageFormat.getImageableX() + myPageFormat.getImageableWidth())));\n+        myImageableWidthLabel.setText(\"Format ImageableWidth = \"\n+                + myPageFormat.getImageableWidth());\n+        myImageableYLabel.setText(\"Format Top Margin = \"\n+                + myPageFormat.getImageableY());\n+        myImageableBottomLabel.setText(\"Format Bottom Margin = \"\n+                + (myPageFormat.getHeight()\n+                        - (myPageFormat.getImageableY() + myPageFormat.getImageableHeight())));\n+        myImageableHeightLabel.setText(\"Format ImageableHeight = \"\n+                + myPageFormat.getImageableHeight());\n+        int o = myPageFormat.getOrientation();\n+        if (o == PageFormat.LANDSCAPE && reverse) {\n+            o = PageFormat.REVERSE_LANDSCAPE;\n+            myPageFormat.setOrientation(PageFormat.REVERSE_LANDSCAPE);\n+        } else if (o == PageFormat.REVERSE_LANDSCAPE && !reverse) {\n+            o = PageFormat.LANDSCAPE;\n+            myPageFormat.setOrientation(PageFormat.LANDSCAPE);\n+        }\n+        myOrientationLabel.setText\n+                (\"Format Orientation = \" +\n+                        (switch (o) {\n+                            case PageFormat.PORTRAIT -> \"PORTRAIT\";\n+                            case PageFormat.LANDSCAPE -> \"LANDSCAPE\";\n+                            case PageFormat.REVERSE_LANDSCAPE -> \"REVERSE_LANDSCAPE\";\n+                            default -> \"<invalid>\";\n+                        }));\n+        Paper p = myPageFormat.getPaper();\n+        pw.setText(\"Paper Width = \" + p.getWidth());\n+        ph.setText(\"Paper Height = \" + p.getHeight());\n+        pglm.setText(\"Paper Left Margin = \" + p.getImageableX());\n+        pgiw.setText(\"Paper Imageable Width = \" + p.getImageableWidth());\n+        pgrm.setText(\"Paper Right Margin = \"\n+                + (p.getWidth()\n+                        - (p.getImageableX() + p.getImageableWidth())));\n+        pgtm.setText(\"Paper Top Margin = \" + p.getImageableY());\n+        pgih.setText(\"Paper Imageable Height = \" + p.getImageableHeight());\n+        pgbm.setText(\"Paper Bottom Margin = \"\n+                + (p.getHeight()\n+                        - (p.getImageableY() + p.getImageableHeight())));\n@@ -83,18 +119,0 @@\n-    myOrientationLabel.setText\n-        (\"Format Orientation = \" +\n-                (o == PageFormat.PORTRAIT ? \"PORTRAIT\" :\n-                 o == PageFormat.LANDSCAPE ? \"LANDSCAPE\" :\n-                 o == PageFormat.REVERSE_LANDSCAPE ? \"REVERSE_LANDSCAPE\" :\n-                 \"<invalid>\"));\n-    Paper p = myPageFormat.getPaper();\n-    pw.setText(\"Paper Width = \" + (float)p.getWidth());\n-    ph.setText(\"Paper Height = \" + (float)p.getHeight());\n-    pglm.setText(\"Paper Left Margin = \" + (float)p.getImageableX());\n-    pgiw.setText(\"Paper Imageable Width = \" + (float)p.getImageableWidth());\n-    pgrm.setText(\"Paper Right Margin = \" +\n-         (float)(p.getWidth() - (p.getImageableX()+p.getImageableWidth())));\n-    pgtm.setText(\"Paper Top Margin = \" + (float)p.getImageableY());\n-    pgih.setText(\"Paper Imageable Height = \" + (float)p.getImageableHeight());\n-    pgbm.setText(\"Paper Bottom Margin = \" +\n-       (float)(p.getHeight() - (p.getImageableY()+p.getImageableHeight())));\n-  }\n@@ -102,38 +120,37 @@\n-  public PageSetupDialog() {\n-    super (\"Page Dialog Test\");\n-    myPrinterJob = PrinterJob.getPrinterJob();\n-    myPageFormat = new PageFormat();\n-    Paper p = new Paper();\n-    double margin = 1.5*72;\n-    p.setImageableArea(margin, margin,\n-                       p.getWidth()-2*margin, p.getHeight()-2*margin);\n-    myPageFormat.setPaper(p);\n-    Panel c = new Panel();\n-    c.setLayout (new GridLayout (9, 2, 0, 0));\n-    c.add (reverseCB = new Checkbox(\"reverse if landscape\"));\n-    c.add (myOrientationLabel = new Label());\n-    c.add (myWidthLabel = new Label());\n-    c.add (pw = new Label());\n-    c.add (myImageableXLabel = new Label());\n-    c.add (pglm = new Label());\n-    c.add (myImageableRightLabel = new Label());\n-    c.add (pgrm = new Label());\n-    c.add (myImageableWidthLabel = new Label());\n-    c.add (pgiw = new Label());\n-    c.add (myHeightLabel = new Label());\n-    c.add (ph = new Label());\n-    c.add (myImageableYLabel = new Label());\n-    c.add (pgtm = new Label());\n-    c.add (myImageableHeightLabel = new Label());\n-    c.add (pgih = new Label());\n-    c.add (myImageableBottomLabel = new Label());\n-    c.add (pgbm = new Label());\n-\n-    reverseCB.addItemListener(new ItemListener() {\n-                public void itemStateChanged(ItemEvent e) {\n-                       reverse = e.getStateChange() == ItemEvent.SELECTED;\n-                       int o = myPageFormat.getOrientation();\n-                       if (o == PageFormat.LANDSCAPE ||\n-                           o == PageFormat.REVERSE_LANDSCAPE) {\n-                           displayPageFormatAttributes();\n-                       }\n+    public PageSetupDialog() {\n+        super(\"Page Dialog Test\");\n+        myPrinterJob = PrinterJob.getPrinterJob();\n+        myPageFormat = new PageFormat();\n+        Paper p = new Paper();\n+        double margin = 1.5 * 72;\n+        p.setImageableArea(margin, margin,\n+                p.getWidth() - 2 * margin, p.getHeight() - 2 * margin);\n+        myPageFormat.setPaper(p);\n+        Panel c = new Panel();\n+        c.setLayout(new GridLayout(9, 2, 0, 0));\n+        c.add(reverseCB = new Checkbox(\"reverse if landscape\"));\n+        c.add(myOrientationLabel = new Label());\n+        c.add(myWidthLabel = new Label());\n+        c.add(pw = new Label());\n+        c.add(myImageableXLabel = new Label());\n+        c.add(pglm = new Label());\n+        c.add(myImageableRightLabel = new Label());\n+        c.add(pgrm = new Label());\n+        c.add(myImageableWidthLabel = new Label());\n+        c.add(pgiw = new Label());\n+        c.add(myHeightLabel = new Label());\n+        c.add(ph = new Label());\n+        c.add(myImageableYLabel = new Label());\n+        c.add(pgtm = new Label());\n+        c.add(myImageableHeightLabel = new Label());\n+        c.add(pgih = new Label());\n+        c.add(myImageableBottomLabel = new Label());\n+        c.add(pgbm = new Label());\n+\n+        reverseCB.addItemListener(new ItemListener() {\n+            public void itemStateChanged(ItemEvent e) {\n+                reverse = e.getStateChange() == ItemEvent.SELECTED;\n+                int o = myPageFormat.getOrientation();\n+                if (o == PageFormat.LANDSCAPE ||\n+                        o == PageFormat.REVERSE_LANDSCAPE) {\n+                    displayPageFormatAttributes();\n@@ -141,10 +158,21 @@\n-    });\n-\n-    add(\"Center\", c);\n-    displayPageFormatAttributes();\n-    Panel panel = new Panel();\n-    Button pageButton = new Button (\"Page Setup...\");\n-    pageButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                        myPageFormat = myPrinterJob.pageDialog (myPageFormat);\n-                        displayPageFormatAttributes();\n+            }\n+        });\n+\n+        add(\"Center\", c);\n+        displayPageFormatAttributes();\n+        Panel panel = new Panel();\n+        Button pageButton = new Button(\"Page Setup...\");\n+        pageButton.addActionListener(e -> {\n+            myPageFormat = myPrinterJob.pageDialog(myPageFormat);\n+            displayPageFormatAttributes();\n+        });\n+        Button printButton = new Button(\"Print ...\");\n+        printButton.addActionListener(e -> {\n+            if (myPrinterJob.printDialog()) {\n+                myPrinterJob.setPrintable(PageSetupDialog.this, myPageFormat);\n+                alpha = false;\n+                try {\n+                    myPrinterJob.print();\n+                } catch (PrinterException pe) {\n+                    pe.printStackTrace();\n+                    PassFailJFrame.forceFail(\"Test failed because of PrinterException\");\n@@ -152,13 +180,12 @@\n-    });\n-    Button printButton = new Button (\"Print ...\");\n-    printButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                    try {\n-                         if (myPrinterJob.printDialog()) {\n-                             myPrinterJob.setPrintable(PageSetupDialog.this,\n-                                                       myPageFormat);\n-                             alpha = false;\n-                             myPrinterJob.print();\n-                    }\n-                    } catch (PrinterException pe ) {\n-                    }\n+            }\n+        });\n+        Button printAlphaButton = new Button(\"Print w\/Alpha...\");\n+        printAlphaButton.addActionListener(e -> {\n+            if (myPrinterJob.printDialog()) {\n+                myPrinterJob.setPrintable(PageSetupDialog.this, myPageFormat);\n+                alpha = true;\n+                try {\n+                    myPrinterJob.print();\n+                } catch (PrinterException pe) {\n+                    pe.printStackTrace();\n+                    PassFailJFrame.forceFail(\"Test failed because of PrinterException\");\n@@ -166,84 +193,7 @@\n-    });\n-    Button printAlphaButton = new Button (\"Print w\/Alpha...\");\n-    printAlphaButton.addActionListener(new ActionListener() {\n-           public void actionPerformed (ActionEvent e) {\n-                    try {\n-                         if (myPrinterJob.printDialog()) {\n-                             myPrinterJob.setPrintable(PageSetupDialog.this,\n-                                                       myPageFormat);\n-                             alpha = true;\n-                             myPrinterJob.print();\n-                    }\n-                    } catch (PrinterException pe ) {\n-                    }\n-           }\n-    });\n-    panel.add (pageButton);\n-    panel.add (printButton);\n-    panel.add (printAlphaButton);\n-    add(\"South\", panel);\n-    addWindowListener (new WindowAdapter() {\n-         public void windowClosing (WindowEvent e) {\n-            dispose();\n-            System.exit (0);\n-         }\n-\n-      });\n-      \/\/setSize (280, 550);\n-      pack();\n-      setVisible (true);\n-  }\n-\n-  public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) {\n-\n-     if (pageIndex > 0) {\n-        return Printable.NO_SUCH_PAGE;\n-     }\n-\n-     Graphics2D g2d = (Graphics2D)graphics;\n-     g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n-     g2d.drawString(\"ORIGIN(\"+pageFormat.getImageableX()+\",\"+\n-                             pageFormat.getImageableY()+\")\", 20, 20);\n-     g2d.drawString(\"X THIS WAY\", 200, 50);\n-     g2d.drawString(\"Y THIS WAY\", 60 , 200);\n-     g2d.drawString(\"Graphics is \" + g2d.getClass().getName(), 100, 100);\n-     g2d.drawRect(0,0,(int)pageFormat.getImageableWidth(),\n-                      (int)pageFormat.getImageableHeight());\n-     if (alpha) {\n-       g2d.setColor(new Color(0,0,255,192));\n-     } else {\n-        g2d.setColor(Color.blue);\n-     }\n-     g2d.drawRect(1,1,(int)pageFormat.getImageableWidth()-2,\n-                      (int)pageFormat.getImageableHeight()-2);\n-\n-     return  Printable.PAGE_EXISTS;\n-  }\n-\n-  public static void main( String[] args) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test is very flexible and requires much interaction.\",\n-         \"If the platform print dialog supports it, adjust orientation\",\n-         \"and margins and print pages and compare the results with the\",\n-         \"request.\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-     new PageSetupDialog();\n-  }\n-\n-}\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+            }\n+        });\n+        panel.add(pageButton);\n+        panel.add(printButton);\n+        panel.add(printAlphaButton);\n+        add(\"South\", panel);\n+        pack();\n@@ -252,7 +202,26 @@\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    @Override\n+    public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) {\n+        if (pageIndex > 0) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n+\n+        Graphics2D g2d = (Graphics2D) graphics;\n+        g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n+        g2d.drawString(\"ORIGIN(\" + pageFormat.getImageableX() + \",\" +\n+                pageFormat.getImageableY() + \")\", 20, 20);\n+        g2d.drawString(\"X THIS WAY\", 200, 50);\n+        g2d.drawString(\"Y THIS WAY\", 60, 200);\n+        g2d.drawString(\"Graphics is \" + g2d.getClass().getName(), 100, 100);\n+        g2d.drawRect(0, 0,\n+                (int) pageFormat.getImageableWidth(),\n+                (int) pageFormat.getImageableHeight());\n+        if (alpha) {\n+            g2d.setColor(new Color(0, 0, 255, 192));\n+        } else {\n+            g2d.setColor(Color.blue);\n+        }\n+        g2d.drawRect(1, 1,\n+                (int) pageFormat.getImageableWidth() - 2,\n+                (int) pageFormat.getImageableHeight() - 2);\n+\n+        return Printable.PAGE_EXISTS;\n@@ -261,4 +230,13 @@\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testTimeOut(10)\n+                .testUI(PageSetupDialog::new)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n@@ -266,88 +244,1 @@\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PageFormat\/PageSetupDialog.java","additions":207,"deletions":316,"binary":false,"changes":523,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,10 @@\n-\/**\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterAbortException;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n@@ -27,1 +36,0 @@\n- * @summary PrinterJob not cancelled when PrinterJob.cancel() is used\n@@ -29,0 +37,3 @@\n+ * @summary PrinterJob not cancelled when PrinterJob.cancel() is used\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,4 +42,0 @@\n-\n-import java.awt.* ;\n-import java.awt.print.* ;\n-\n@@ -36,55 +43,28 @@\n-\n-  PrinterJob pj ;\n-  boolean okayed;\n-\n-  public static void main ( String args[] ) {\n-\n-     String[] instructions =\n-        {\n-         \"Test that print job cancellation works.\",\n-         \"You must have a printer available to perform this test.\",\n-         \"This test silently starts a print job and while the job is\",\n-         \"still being printed, cancels the print job\",\n-         \"You should see a message on System.out that the job\",\n-         \"was properly cancelled.\",\n-         \"You will need to kill the application manually since regression\",\n-         \"tests apparently aren't supposed to call System.exit()\"\n-       };\n-\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-      PrinterJobCancel pjc = new PrinterJobCancel() ;\n-\n-      if (pjc.okayed) {\n-          pjc.start();\n-          try {\n-               Thread.sleep(5000);\n-               pjc.pj.cancel();\n-          } catch ( InterruptedException e ) {\n-          }\n-      }\n-  }\n-\n-  public PrinterJobCancel() {\n-\n-    pj = PrinterJob.getPrinterJob() ;\n-    pj.setPrintable(this);\n-    okayed = pj.printDialog();\n-  }\n-\n-  public void run() {\n-    boolean cancelWorked = false;\n-    try {\n-        pj.print() ;\n-    }\n-    catch ( PrinterAbortException paex ) {\n-      cancelWorked = true;\n-      System.out.println(\"Job was properly cancelled and we\");\n-      System.out.println(\"got the expected PrintAbortException\");\n-    }\n-    catch ( PrinterException prex ) {\n-      System.out.println(\"This is wrong .. we shouldn't be here\");\n-      System.out.println(\"Looks like a test failure\");\n-      prex.printStackTrace() ;\n-      \/\/throw prex;\n+    private final PrinterJob pj;\n+    private final boolean okayed;\n+    private static final String INSTRUCTIONS =\n+            \"Test that print job cancellation works.\\n\\n\" +\n+            \"This test starts after clicking OK \/ Print button.\\n\" +\n+            \"While the print job is in progress, the test automatically cancels it.\\n\" +\n+            \"The test will complete automatically.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n+\n+        PrinterJobCancel pjc = new PrinterJobCancel();\n+        if (pjc.okayed) {\n+            pjc.start();\n+            Thread.sleep(5000);\n+            pjc.pj.cancel();\n+        } else {\n+            PassFailJFrame.forceFail(\"User cancelled printing\");\n+        }\n+        passFailJFrame.awaitAndCheck();\n@@ -92,33 +72,0 @@\n-    finally {\n-       System.out.println(\"DONE PRINTING\");\n-       if (!cancelWorked) {\n-           System.out.println(\"Looks like the test failed - we didn't get\");\n-           System.out.println(\"the expected PrintAbortException \");\n-       }\n-    }\n-    \/\/System.exit(0);\n-  }\n-\n-  public int print(Graphics g, PageFormat pagef, int pidx) {\n-\n-     if (pidx > 5) {\n-        return( Printable.NO_SUCH_PAGE ) ;\n-     }\n-\n-     Graphics2D g2d = (Graphics2D)g;\n-     g2d.translate(pagef.getImageableX(), pagef.getImageableY());\n-     g2d.setColor(Color.black);\n-\n-     g2d.drawString((\"This is page\"+(pidx+1)), 60 , 80);\n-     \/\/ Need to slow things down a bit .. important not to try this\n-     \/\/ on the event dispathching thread of course.\n-     try {\n-          Thread.sleep(2000);\n-     } catch (InterruptedException e) {\n-     }\n-\n-     return ( Printable.PAGE_EXISTS );\n-  }\n-\n-}\n-\n@@ -126,9 +73,4 @@\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    public PrinterJobCancel() {\n+        pj = PrinterJob.getPrinterJob();\n+        pj.setPrintable(this);\n+        okayed = pj.printDialog();\n@@ -137,7 +79,18 @@\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    public void run() {\n+        boolean cancelWorked = false;\n+        try {\n+            pj.print();\n+        } catch (PrinterAbortException paex) {\n+            cancelWorked = true;\n+            System.out.println(\"Job was properly cancelled and we\");\n+            System.out.println(\"got the expected PrintAbortException\");\n+            PassFailJFrame.forcePass();\n+        } catch (PrinterException prex) {\n+            prex.printStackTrace();\n+            PassFailJFrame.forceFail(\"Unexpected PrinterException caught:\" + prex.getMessage());\n+        } finally {\n+            System.out.println(\"DONE PRINTING\");\n+            if (!cancelWorked) {\n+                PassFailJFrame.forceFail(\"Didn't get the expected PrintAbortException\");\n+            }\n+        }\n@@ -146,4 +99,18 @@\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n+    @Override\n+    public int print(Graphics g, PageFormat pagef, int pidx) {\n+        if (pidx > 5) {\n+            return (Printable.NO_SUCH_PAGE);\n+        }\n+\n+        Graphics2D g2d = (Graphics2D) g;\n+        g2d.translate(pagef.getImageableX(), pagef.getImageableY());\n+        g2d.setColor(Color.black);\n+        g2d.drawString((\"This is page\" + (pidx + 1)), 60, 80);\n+        \/\/ Need to slow things down a bit .. important not to try this\n+        \/\/ on the event dispatching thread of course.\n+        try {\n+            Thread.sleep(2000);\n+        } catch (InterruptedException ignored) {\n+        }\n+\n+        return Printable.PAGE_EXISTS;\n@@ -151,88 +118,1 @@\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/Cancel\/PrinterJobCancel.java","additions":83,"deletions":203,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,25 @@\n-\/**\n+import java.awt.Graphics;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.io.InputStream;\n+import java.io.Reader;\n+\n+import javax.print.Doc;\n+import javax.print.DocFlavor;\n+import javax.print.DocPrintJob;\n+import javax.print.PrintException;\n+import javax.print.PrintService;\n+import javax.print.PrintServiceLookup;\n+import javax.print.attribute.DocAttributeSet;\n+import javax.print.attribute.HashPrintRequestAttributeSet;\n+import javax.print.attribute.standard.Copies;\n+import javax.print.attribute.standard.SheetCollate;\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -29,0 +53,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,15 +57,2 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-import javax.print.attribute.standard.*;\n-import javax.print.attribute.*;\n-import javax.print.*;\n-import java.io.*;\n-\n-public class Collate2DPrintingTest\n-    extends Frame implements Doc, Printable, ActionListener {\n-\n-        Button print2D = new Button(\"2D Print\");\n-        Button printMerlin = new Button(\"PrintService\");\n-        PrinterJob pj = PrinterJob.getPrinterJob();\n-        PrintService defService = null;\n+public class Collate2DPrintingTest implements Doc, Printable {\n+    private static JComponent createTestUI() {\n@@ -47,0 +60,3 @@\n+        PrintService defService = PrintServiceLookup.lookupDefaultPrintService();\n+        prSet.add(SheetCollate.COLLATED);\n+        prSet.add(new Copies(2));\n@@ -48,10 +64,14 @@\n-    public Collate2DPrintingTest() {\n-\n-        Panel butPanel = new Panel();\n-        butPanel.add(print2D);\n-        butPanel.add(printMerlin);\n-        print2D.addActionListener(this);\n-        printMerlin.addActionListener(this);\n-        addWindowListener (new WindowAdapter() {\n-            public void windowClosing (WindowEvent e) {\n-                dispose();\n+        JButton print2D = new JButton(\"2D Print\");\n+        print2D.addActionListener((ae) -> {\n+            try {\n+                PrinterJob pj = PrinterJob.getPrinterJob();\n+                pj.setPrintable(new Collate2DPrintingTest());\n+                if (pj.printDialog(prSet)) {\n+                    pj.print(prSet);\n+                }\n+            } catch (PrinterException ex) {\n+                ex.printStackTrace();\n+                String msg = \"PrinterException: \" + ex.getMessage();\n+                JOptionPane.showMessageDialog(print2D, msg, \"Error occurred\",\n+                        JOptionPane.ERROR_MESSAGE);\n+                PassFailJFrame.forceFail(msg);\n@@ -60,1 +80,0 @@\n-        add(\"South\", butPanel);\n@@ -62,6 +81,11 @@\n-        defService = PrintServiceLookup.lookupDefaultPrintService();\n-        PrintService[] pservice;\n-        if (defService == null) {\n-            pservice = PrintServiceLookup.lookupPrintServices(null, null);\n-            if (pservice.length == 0) {\n-                throw new RuntimeException(\"No printer found.  TEST ABORTED\");\n+        JButton printMerlin = new JButton(\"PrintService\");\n+        printMerlin.addActionListener((ae) -> {\n+            try {\n+                DocPrintJob pj = defService.createPrintJob();\n+                pj.print(new Collate2DPrintingTest(), prSet);\n+            } catch (PrintException ex) {\n+                ex.printStackTrace();\n+                String msg = \"PrintException: \" + ex.getMessage();\n+                JOptionPane.showMessageDialog(printMerlin, msg, \"Error occurred\",\n+                        JOptionPane.ERROR_MESSAGE);\n+                PassFailJFrame.forceFail(msg);\n@@ -69,8 +93,1 @@\n-            defService = pservice[0];\n-        }\n-        prSet.add(SheetCollate.COLLATED);\n-        prSet.add(new Copies(2));\n-        pj.setPrintable(Collate2DPrintingTest.this);\n-        setSize(300, 200);\n-        setVisible(true);\n-    }\n+        });\n@@ -78,0 +95,9 @@\n+        Box main = Box.createVerticalBox();\n+        main.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));\n+        main.add(Box.createVerticalGlue());\n+        main.add(print2D);\n+        main.add(Box.createVerticalStrut(4));\n+        main.add(printMerlin);\n+        main.add(Box.createVerticalGlue());\n+        return main;\n+    }\n@@ -79,0 +105,1 @@\n+    @Override\n@@ -80,1 +107,1 @@\n-          throws PrinterException {\n+            throws PrinterException {\n@@ -89,16 +116,1 @@\n-    public void actionPerformed (ActionEvent ae) {\n-        try {\n-            if (ae.getSource() == print2D) {\n-                if (pj.printDialog(prSet)) {\n-                    pj.print(prSet);\n-                }\n-            } else {\n-                DocPrintJob pj = defService.createPrintJob();\n-                pj.print(this, prSet);\n-            }\n-            System.out.println (\"DONE\");\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n+    @Override\n@@ -109,0 +121,1 @@\n+    @Override\n@@ -110,2 +123,1 @@\n-        DocFlavor flavor = DocFlavor.SERVICE_FORMATTED.PRINTABLE;\n-        return flavor;\n+        return DocFlavor.SERVICE_FORMATTED.PRINTABLE;\n@@ -114,0 +126,1 @@\n+    @Override\n@@ -118,0 +131,1 @@\n+    @Override\n@@ -122,0 +136,1 @@\n+    @Override\n@@ -126,120 +141,13 @@\n-  public static void main( String[] args) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"The print result should be collated.\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-     new Collate2DPrintingTest();\n-  }\n-}\n-\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.setVisible(true);\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.setVisible(true);\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      setVisible(true);\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n+    private static final String INSTRUCTIONS =\n+            \"Click on the '2D Print' button.\\n\" +\n+            \"Choose copies as '2' with 'Collated' checkbox and Print\\n\" +\n+            \"\\n\" +\n+            \"Click on the 'PrintService', should get a print from default printer\\n\" +\n+            \"\\n\" +\n+            \"If you get only one copy or non 'Collated' prints from any of the above cases, \" +\n+            \"test failed\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n@@ -247,4 +155,7 @@\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .splitUI(Collate2DPrintingTest::createTestUI)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n@@ -252,2 +163,1 @@\n-\n- }\/\/ TestDialog  class\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/Collate2DPrintingTest.java","additions":97,"deletions":187,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,15 @@\n-\/**\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.BufferedImageOp;\n+import java.awt.image.RescaleOp;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n@@ -29,0 +43,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,0 +47,2 @@\n+public class DrawImage {\n+    private static final int OBJECT_BORDER = 15;\n@@ -32,25 +50,4 @@\n-import java.util.*;\n-import java.text.*;\n-import java.io.*;\n-import java.net.*;\n-import java.awt.*;\n-import java.awt.font.*;\n-import java.awt.geom.*;\n-import java.awt.print.*;\n-import java.awt.event.*;\n-import java.awt.image.*;\n-import java.awt.image.renderable.*;\n-import javax.swing.*;\n-import javax.swing.text.*;\n-import javax.swing.border.*;\n-import javax.swing.event.*;\n-\n-public class DrawImage\n-{\n-    protected static final double _hwBorder = 72 \/ 4;       \/\/ 1\/4 inch\n-    protected static final double _border = 72 \/ 4;         \/\/ 1\/4 inch\n-    protected static final int _objectBorder = 15;\n-    protected static final int _verticalGap = 20;\n-    protected static final int _textIndent = 150;\n-\n-    protected BufferedImage _image;\n+    private static final String INSTRUCTIONS =\n+            \"This test will automatically initiate a print\\n\\n\" +\n+            \"Test passes if you get a printout of a gray rectangle\\n\" +\n+            \"with white text without any exception.\";\n@@ -58,1 +55,2 @@\n-    protected PageFormat  _pageFormat;\n+    private final BufferedImage image;\n+    private final PageFormat pageFormat;\n@@ -60,2 +58,2 @@\n-    public DrawImage(BufferedImage image) {\n-        _image = image;\n+    private DrawImage(BufferedImage image) {\n+        this.image = image;\n@@ -63,1 +61,2 @@\n-        _pageFormat = pj.defaultPage();\n+        pageFormat = pj.defaultPage();\n+    }\n@@ -65,1 +64,4 @@\n- }\n+    private int printImage(Graphics g, PageFormat pf, int pageIndex) {\n+        if (pageIndex > 0) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n@@ -67,0 +69,4 @@\n+        int paperW = (int) pageFormat.getImageableWidth();\n+        int paperH = (int) pageFormat.getImageableHeight();\n+        int x = (int) pageFormat.getImageableX();\n+        int y = (int) pageFormat.getImageableY();\n@@ -68,3 +74,3 @@\n-    protected int printImage(Graphics g, PageFormat pf, BufferedImage image) {\n-        Graphics2D g2D = (Graphics2D)g;\n-        g2D.transform(new AffineTransform(_pageFormat.getMatrix()));\n+        \/\/ Make the image slightly smaller (25) than max possible width\n+        float scaleFactor = ((float) ((paperW - 25) - OBJECT_BORDER - OBJECT_BORDER)\n+                                   \/ (float) (image.getWidth()));\n@@ -72,2 +78,1 @@\n-        int paperW = (int)pf.getImageableWidth(), paperH =\n-            (int)pf.getImageableHeight();\n+        BufferedImageOp scaleOp = new RescaleOp(scaleFactor, 0, null);\n@@ -75,1 +80,2 @@\n-        int x = (int)pf.getImageableX(), y = (int)pf.getImageableY();\n+        Graphics2D g2D = (Graphics2D) g;\n+        g2D.transform(new AffineTransform(pageFormat.getMatrix()));\n@@ -77,0 +83,1 @@\n+        g2D.drawImage(image, scaleOp, x + OBJECT_BORDER, y + OBJECT_BORDER);\n@@ -78,16 +85,1 @@\n-        \/\/ print images\n-        if (image != null ) {\n-            int imageH = image.getHeight(), imageW = image.getWidth();\n-            \/\/ make slightly smaller (25) than max possible width\n-            float scaleFactor = ((float)((paperW - 25) - _objectBorder -\n-                                         _objectBorder) \/ (float)(imageW));\n-            int scaledW = (int)(imageW * scaleFactor),\n-                scaledH = (int)(imageH *scaleFactor);\n-            BufferedImageOp scaleOp = new RescaleOp(scaleFactor, 0, null);\n-            g2D.drawImage(image, scaleOp, x + _objectBorder, y + _objectBorder);\n-            y += _objectBorder + scaledH + _objectBorder;\n-            return Printable.PAGE_EXISTS;\n-        }\n-        else {\n-            return Printable.NO_SUCH_PAGE;\n-        }\n+        return Printable.PAGE_EXISTS;\n@@ -96,23 +88,8 @@\n-    public void print() {\n-        try {\n-            final PrinterJob pj = PrinterJob.getPrinterJob();\n-            pj.setJobName(\"Print Image\");\n-            pj.setPrintable(new Printable() {\n-                public int print(Graphics g, PageFormat pf, int pageIndex) {\n-                    int result = NO_SUCH_PAGE;\n-                    if (pageIndex == 0) {\n-                        result = printImage(g, _pageFormat, _image);\n-                    }\n-                    return result;\n-                }\n-            });\n-            if (pj.printDialog()) {\n-                try { pj.print(); }\n-                catch (PrinterException e) {\n-                    System.out.println(e);\n-                }\n-            }\n-\n-        }\n-        catch (Exception e) {\n-            e.printStackTrace(System.out);\n+    private void print() throws PrinterException {\n+        final PrinterJob pj = PrinterJob.getPrinterJob();\n+        pj.setJobName(\"Print Image\");\n+        pj.setPrintable(this::printImage);\n+        if (pj.printDialog()) {\n+            pj.print();\n+        } else {\n+            PassFailJFrame.forceFail(\"User cancelled printing\");\n@@ -122,10 +99,4 @@\n-    public static void main(String[] args) {\n-                                String[] instructions =\n-           {\n-            \"You must have a printer available to perform this test.\",\n-            \"The test passes if you get a printout of a gray rectangle\",\n-                                                \"with white text without any exception.\"\n-          };\n-\n-         Sysout.createDialog( );\n-         Sysout.printInstructions( instructions );\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n@@ -134,0 +105,7 @@\n+\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n+\n@@ -136,1 +114,1 @@\n-        \/\/      System.exit(0);\n+        passFailJFrame.awaitAndCheck();\n@@ -139,3 +117,1 @@\n-\n-\n-    public static BufferedImage prepareFrontImage() {\n+    private static BufferedImage prepareFrontImage() {\n@@ -144,1 +120,3 @@\n-                                                 BufferedImage.TYPE_BYTE_GRAY);\n+                                   BufferedImage.TYPE_BYTE_GRAY);\n+        int w = result.getWidth();\n+        int h = result.getHeight();\n@@ -146,1 +124,1 @@\n-        Graphics2D g2D = (Graphics2D)result.getGraphics();\n+        Graphics2D g2D = (Graphics2D) result.getGraphics();\n@@ -149,2 +127,0 @@\n-        int w = result.getWidth(), h = result.getHeight();\n-\n@@ -153,1 +129,0 @@\n-\n@@ -156,3 +131,2 @@\n-        AffineTransform original = g2D.getTransform();\n-        AffineTransform originXform = AffineTransform.getTranslateInstance(w \/\n-5, h \/ 5);\n+        AffineTransform originXform = AffineTransform.getTranslateInstance(\n+                w \/ 5.0, h \/ 5.0);\n@@ -160,2 +134,0 @@\n-\n-\n@@ -163,0 +135,1 @@\n+        g2D.dispose();\n@@ -166,2 +139,0 @@\n-\n-\n@@ -169,114 +140,0 @@\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/DrawImage.java","additions":74,"deletions":217,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,13 @@\n-\/**\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.font.FontRenderContext;\n+import java.awt.print.Book;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterJob;\n+import java.text.AttributedCharacterIterator;\n+import java.text.AttributedString;\n+\n+\/*\n@@ -30,0 +42,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -32,6 +46,0 @@\n-\n-import java.awt.*;\n-import java.text.*;\n-import java.awt.font.*;\n-import java.awt.print.*;\n-\n@@ -39,0 +47,11 @@\n+    private static final String INSTRUCTIONS =\n+            \" This test will automatically initiate a print.\\n\" +\n+            \"\\n\" +\n+            \" Confirm that the following methods are printed:\\n\" +\n+            \" For Graphics: drawString, drawString, drawChars, drawBytes\\n\" +\n+            \" For Graphics2D: drawString, drawString, drawGlyphVector\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n@@ -40,9 +59,5 @@\n-    public static void main(String args[]) {\n-        String[] instructions =\n-        {\n-            \"Confirm that the methods are printed.\",\n-            \" For Graphics: drawString, drawString, drawChars, drawBytes\",\n-            \" For Graphics2D: drawString, drawString, drawGlyphVector\"\n-        };\n-        Sysout.createDialogWithInstructions( instructions );\n-\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n@@ -56,0 +71,1 @@\n+        pjob.print();\n@@ -57,5 +73,1 @@\n-        try {\n-            pjob.print();\n-        } catch (PrinterException e) {\n-            throw new RuntimeException(e.getMessage());\n-        }\n+        passFailJFrame.awaitAndCheck();\n@@ -64,1 +76,1 @@\n-    public static AttributedCharacterIterator getIterator(String s) {\n+    private static AttributedCharacterIterator getIterator(String s) {\n@@ -68,0 +80,1 @@\n+    @Override\n@@ -96,1 +109,1 @@\n-        byte data[] = new byte[s.length()];\n+        byte[] data = new byte[s.length()];\n@@ -119,1 +132,1 @@\n-                           \"float x, float y)\";\n+                \"float x, float y)\";\n@@ -136,116 +149,0 @@\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog\n- {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"South\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-     \/\/chop up each into pieces maxSringLength long\n-     remainingStr = instructions[ i ];\n-     while( remainingStr.length() > 0 )\n-      {\n-        \/\/if longer than max then chop off first max chars to print\n-        if( remainingStr.length() >= maxStringLength )\n-         {\n-           \/\/Try to chop on a word boundary\n-           int posOfSpace = remainingStr.\n-          lastIndexOf( ' ', maxStringLength - 1 );\n-\n-           if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-           printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-           remainingStr = remainingStr.substring( posOfSpace + 1 );\n-         }\n-        \/\/else just print\n-        else\n-         {\n-           printStr = remainingStr;\n-           remainingStr = \"\";\n-         }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-      }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/DrawStringMethods.java","additions":38,"deletions":141,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,16 @@\n-\/**\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Paper;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -29,0 +44,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,29 +48,13 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-\n-public class InvalidPage extends Frame implements Printable {\n-\n-  PrinterJob pJob;\n-  PageFormat pf;\n-\n-  public InvalidPage() {\n-    super (\"Validate Page Test\");\n-    pJob = PrinterJob.getPrinterJob();\n-    pf = pJob.defaultPage();\n-    Paper p = pf.getPaper();\n-    p.setImageableArea(0,0,p.getWidth(), p.getHeight());\n-    pf.setPaper(p);\n-    setLayout(new FlowLayout());\n-    Panel panel = new Panel();\n-    Button printButton = new Button (\"Print\");\n-    printButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                    try {\n-                         if (pJob.printDialog()) {\n-                             pJob.setPrintable(InvalidPage.this, pf);\n-                             pJob.print();\n-                    }\n-                    } catch (PrinterException pe ) {\n-                    }\n+public class InvalidPage implements Printable {\n+    private static JComponent createTestUI() {\n+        JButton b = new JButton(\"Print\");\n+        b.addActionListener((ae) -> {\n+            try {\n+                PrinterJob job = PrinterJob.getPrinterJob();\n+                PageFormat pf = job.defaultPage();\n+                Paper p = pf.getPaper();\n+                p.setImageableArea(0, 0, p.getWidth(), p.getHeight());\n+                pf.setPaper(p);\n+                job.setPrintable(new InvalidPage(), pf);\n+                if (job.printDialog()) {\n+                    job.print();\n@@ -61,79 +62,15 @@\n-    });\n-    panel.add (printButton);\n-    add(panel);\n-\n-    addWindowListener (new WindowAdapter() {\n-         public void windowClosing (WindowEvent e) {\n-            dispose();\n-            System.exit (0);\n-         }\n-\n-      });\n-      setSize (200, 200);\n-      setVisible (true);\n-  }\n-\n-  public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) {\n-\n-     if (pageIndex > 1) {\n-        return Printable.NO_SUCH_PAGE;\n-     }\n-\n-     Graphics2D g2d = (Graphics2D)graphics;\n-\n-     g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n-     g2d.drawString(\"ORIGIN\", 30, 30);\n-     g2d.drawString(\"X THIS WAY\", 200, 50);\n-     g2d.drawString(\"Y THIS WAY\", 60 , 200);\n-     g2d.drawRect(0,0,(int)pageFormat.getImageableWidth(),\n-                      (int)pageFormat.getImageableHeight());\n-     if (pageIndex == 0) {\n-        g2d.setColor(Color.black);\n-     } else {\n-        g2d.setColor(new Color(0,0,0,128));\n-     }\n-     g2d.drawRect(1,1,(int)pageFormat.getImageableWidth()-2,\n-                      (int)pageFormat.getImageableHeight()-2);\n-\n-     g2d.drawLine(0,0,\n-                  (int)pageFormat.getImageableWidth(),\n-                  (int)pageFormat.getImageableHeight());\n-     g2d.drawLine((int)pageFormat.getImageableWidth(),0,\n-                   0,(int)pageFormat.getImageableHeight());\n-     return  Printable.PAGE_EXISTS;\n-  }\n-\n-  public static void main( String[] args) {\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"Press the print button, which brings up a print dialog and\",\n-         \"in the dialog select a printer and press the print button\",\n-         \"in the dialog. Repeat for as many printers as you have installed\",\n-         \"On solaris and linux just one printer is sufficient\",\n-         \"Collect the output and examine it, each print job has two pages\",\n-         \"of very similar output, except that the 2nd page of the job may\",\n-         \"appear in a different colour, and the output near the edge of\",\n-         \"the page may be clipped. This is OK. Hold up both pieces of paper\",\n-         \"to the light and confirm that the lines and text (where present)\",\n-         \"are positioned identically on both pages\",\n-         \"The test fails if the JRE crashes, or if the output from the two\",\n-         \"pages of a job is aligned differently\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-     new InvalidPage();\n-  }\n-\n-}\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+            } catch (PrinterException ex) {\n+                ex.printStackTrace();\n+                String msg = \"PrinterException: \" + ex.getMessage();\n+                JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n+                        JOptionPane.ERROR_MESSAGE);\n+                PassFailJFrame.forceFail(msg);\n+            }\n+        });\n+\n+        Box main = Box.createHorizontalBox();\n+        main.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));\n+        main.add(Box.createHorizontalGlue());\n+        main.add(b);\n+        main.add(Box.createHorizontalGlue());\n+        return main;\n@@ -142,7 +79,29 @@\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    @Override\n+    public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) {\n+        if (pageIndex > 1) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n+\n+        Graphics2D g2d = (Graphics2D) graphics;\n+        g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n+        g2d.drawString(\"ORIGIN\", 30, 30);\n+        g2d.drawString(\"X THIS WAY\", 200, 50);\n+        g2d.drawString(\"Y THIS WAY\", 60, 200);\n+        g2d.drawRect(0, 0,\n+                (int) pageFormat.getImageableWidth(),\n+                (int) pageFormat.getImageableHeight());\n+        if (pageIndex == 0) {\n+            g2d.setColor(Color.black);\n+        } else {\n+            g2d.setColor(new Color(0, 0, 0, 128));\n+        }\n+        g2d.drawRect(1, 1,\n+                (int) pageFormat.getImageableWidth() - 2,\n+                (int) pageFormat.getImageableHeight() - 2);\n+        g2d.drawLine(0, 0,\n+                (int) pageFormat.getImageableWidth(),\n+                (int) pageFormat.getImageableHeight());\n+        g2d.drawLine((int) pageFormat.getImageableWidth(), 0,\n+                0, (int) pageFormat.getImageableHeight());\n+\n+        return Printable.PAGE_EXISTS;\n@@ -151,4 +110,27 @@\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n+    private static final String INSTRUCTIONS =\n+            \" Press the print button, which brings up a print dialog.\\n\" +\n+            \" In the dialog select a printer and press the print button.\\n\\n\" +\n+            \" Repeat for all the printers as you have installed\\n\" +\n+            \" On Solaris and Linux just one printer is sufficient.\\n\\n\" +\n+            \" Collect the output and examine it, each print job has two pages\\n\" +\n+            \" of very similar output, except that the 2nd page of the job may\\n\" +\n+            \" appear in a different colour, and the output near the edge of\\n\" +\n+            \" the page may be clipped. This is OK. Hold up both pieces of paper\\n\" +\n+            \" to the light and confirm that the lines and text (where present)\\n\" +\n+            \" are positioned identically on both pages\\n\\n\" +\n+            \" The test fails if the output from the two\\n\" +\n+            \" pages of a job is aligned differently\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testTimeOut(10)\n+                .splitUI(InvalidPage::createTestUI)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n@@ -156,88 +138,1 @@\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/InvalidPage.java","additions":104,"deletions":209,"binary":false,"changes":313,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,7 @@\n-\/**\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n@@ -29,0 +35,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,4 +39,0 @@\n-\n-import java.awt.*;\n-import java.awt.print.*;\n-\n@@ -36,0 +40,23 @@\n+    private static final String THE_NAME = \"Testing the Job name setting\";\n+\n+    private static final String INSTRUCTIONS =\n+            \"This test prints a page with a banner\/job name of\\n\\n\" +\n+            THE_NAME;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n+\n+        PrinterJob job = PrinterJob.getPrinterJob();\n+        job.setJobName(THE_NAME);\n+        job.setPrintable(new PrinterJobName());\n+        job.print();\n+        passFailJFrame.awaitAndCheck();\n+    }\n@@ -37,28 +64,1 @@\n-\n-  static String theName = \"Testing the Jobname setting\";\n-\n-  public static void main(String[] args) {\n-\n-       String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test prints a page with a banner\/job name of\",\n-          theName\n-       };\n-\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-      PrinterJob job = PrinterJob.getPrinterJob();\n-      job.setJobName(theName);\n-      job.setPrintable(new PrinterJobName());\n-      try {\n-          job.print();\n-          System.out.println(\"PRINTING DONE.\");\n-      }\n-      catch (Exception exc) {\n-          System.out.println(\"Printer Exception\");\n-      }\n-  }\n-\n-\n+    @Override\n@@ -66,10 +66,8 @@\n-      if (pgIndex > 0 ) {\n-          return Printable.NO_SUCH_PAGE;\n-      }\n-\n-      double iw = pgFmt.getImageableWidth();\n-      double ih = pgFmt.getImageableHeight();\n-      Graphics2D g2d = (Graphics2D)g;\n-      g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-      g2d.drawString(\"Name is: \"+theName,20,20 );\n-      return Printable.PAGE_EXISTS;\n+        if (pgIndex > 0) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n+\n+        Graphics2D g2d = (Graphics2D) g;\n+        g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+        g2d.drawString(\"Name is: \" + THE_NAME, 20, 20);\n+        return Printable.PAGE_EXISTS;\n@@ -77,1 +75,0 @@\n-\n@@ -79,115 +76,0 @@\n-\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/JobName\/PrinterJobName.java","additions":42,"deletions":160,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,8 @@\n-\/**\n+import java.awt.Color;\n+import java.awt.Graphics;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n@@ -29,0 +36,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,4 +40,0 @@\n-\n-import java.awt.*;\n-import java.awt.print.*;\n-\n@@ -36,19 +41,20 @@\n-\n-\n-  public static void main(String[] args) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test should print a total of four pages which are two\",\n-         \" copies of each of two pages which consist of the text :-\",\n-         \"'This is page number N', where N is 0 and 1.\",\n-         \"The pages should be uncollated.\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    PrinterJob job = PrinterJob.getPrinterJob();\n-    job.setCopies(2);\n-    job.setPrintable(new NumCopies());\n-    try {\n+    private static final String INSTRUCTIONS =\n+            \"This test should print four pages, which are \\n\" +\n+            \"two copies of each page with the text :-\\n\" +\n+            \"'This is page number N', where N is 0 and 1.\\n\" +\n+            \"The pages should be uncollated.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n+\n+        PrinterJob job = PrinterJob.getPrinterJob();\n+        job.setCopies(2);\n+        job.setPrintable(new NumCopies());\n@@ -56,0 +62,1 @@\n+        passFailJFrame.awaitAndCheck();\n@@ -57,4 +64,0 @@\n-    catch (Exception exc) {\n-        System.out.println(\"Printer Exception\");\n-    }\n-  }\n@@ -62,5 +65,10 @@\n-  public int print(Graphics g, PageFormat pf, int pageIndex)\n-                   throws PrinterException {\n-\n-    if (pageIndex > 1) {\n-         return NO_SUCH_PAGE;\n+    @Override\n+    public int print(Graphics g, PageFormat pf, int pageIndex)\n+            throws PrinterException {\n+        if (pageIndex > 1) {\n+            return NO_SUCH_PAGE;\n+        }\n+        g.translate((int) pf.getImageableX(), (int) pf.getImageableY());\n+        g.setColor(Color.black);\n+        g.drawString(\"This is page number \" + pageIndex, 50, 50);\n+        return PAGE_EXISTS;\n@@ -68,6 +76,0 @@\n-    g.translate((int)pf.getImageableX(), (int)pf.getImageableY());\n-    g.setColor(Color.black);\n-    g.drawString(\"This is page number \" + Integer.toString(pageIndex), 50, 50);\n-    return PAGE_EXISTS ;\n-   }\n-\n@@ -75,115 +77,0 @@\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/NumCopies.java","additions":42,"deletions":155,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,12 +24,0 @@\n-\/**\n- * @test\n- * @bug 4956397\n- * @key printer\n- * @run main\/manual PageDlgPrnButton\n- *\/\n-\n-import java.awt.print.PrinterJob;\n-import java.awt.print.PageFormat;\n-import java.awt.print.Printable;\n-import java.awt.print.PrinterException;\n-\n@@ -39,5 +27,4 @@\n-import java.awt.* ;\n-\n-public class PageDlgPrnButton implements Printable\n-{\n-    public static void main ( String args[] ) {\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n@@ -45,7 +32,1 @@\n-        String[] instructions =\n-           {\"For non-windows OS, this test PASSes.\",\n-            \"You must have at least 2 printers available to perform this test.\",\n-            \"This test brings up a native Windows page dialog.\",\n-            \"Click on the Printer... button and change the selected printer. \",\n-            \"Test passes if the printout comes from the new selected printer.\",\n-         };\n+import jtreg.SkippedException;\n@@ -53,2 +34,23 @@\n-         Sysout.createDialog( );\n-         Sysout.printInstructions( instructions );\n+\/*\n+ * @test\n+ * @bug 4956397\n+ * @key printer\n+ * @requires os.family==\"windows\"\n+ * @library \/test\/lib \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame jtreg.SkippedException\n+ * @run main\/manual PageDlgPrnButton\n+ *\/\n+public class PageDlgPrnButton implements Printable {\n+    private static final String INSTRUCTIONS =\n+            \"This test brings up a native Windows page dialog.\\n\" +\n+            \"Click on the Printer... button and change the selected printer. \\n\" +\n+            \"Test passes if the printout comes from the new selected printer.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        final int serviceCount = PrinterJob.lookupPrintServices().length;\n+        if (serviceCount == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+        if (serviceCount < 2) {\n+            throw new SkippedException(\"The test requires at least 2 printers.\");\n+        }\n@@ -56,2 +58,5 @@\n-        PageDlgPrnButton pdpb = new PageDlgPrnButton() ;\n-    }\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n@@ -59,8 +64,2 @@\n-    public PageDlgPrnButton()\n-    {\n-        try\n-        {\n-            pageDialogExample();\n-        }\n-        catch(Exception e)\n-        {e.printStackTrace(System.err);}\n+        pageDialogExample();\n+        passFailJFrame.awaitAndCheck();\n@@ -69,1 +68,0 @@\n-\n@@ -72,2 +70,1 @@\n-    public void pageDialogExample() throws PrinterException\n-    {\n+    public static void pageDialogExample() throws PrinterException {\n@@ -78,4 +75,4 @@\n-        if(originalPageFormat == pageFormat) return;\n-\n-        job.setPrintable(this,pageFormat);\n-        job.print();\n+        job.setPrintable(new PageDlgPrnButton(), pageFormat);\n+        if (job.printDialog()) {\n+            job.print();\n+        }\n@@ -84,4 +81,2 @@\n-\n-\n-    public int print(Graphics g, PageFormat pageFormat, int pageIndex)\n-    {\n+    @Override\n+    public int print(Graphics g, PageFormat pageFormat, int pageIndex) {\n@@ -90,1 +85,1 @@\n-        final Rectangle rect = new Rectangle(0,0,boxWidth,boxHeight);\n+        final Rectangle rect = new Rectangle(0, 0, boxWidth, boxHeight);\n@@ -93,0 +88,1 @@\n+        final Graphics2D g2d = (Graphics2D) g;\n@@ -94,3 +90,3 @@\n-        if (pageIndex > 0) return (NO_SUCH_PAGE);\n-\n-        final Graphics2D g2d = (Graphics2D)g;\n+        if (pageIndex > 0) {\n+            return NO_SUCH_PAGE;\n+        }\n@@ -102,1 +98,1 @@\n-        g2d.drawRect(0,0,(int)pageW,(int)pageH);\n+        g2d.drawRect(0, 0, (int) pageW, (int) pageH);\n@@ -106,1 +102,1 @@\n-        final double scale = Math.min( (pageW\/boxWidth), (pageH\/boxHeight) );\n+        final double scale = Math.min((pageW \/ boxWidth), (pageH \/ boxHeight));\n@@ -108,1 +104,3 @@\n-        if(scale < 1.0) g2d.scale(scale, scale);\n+        if (scale < 1.0) {\n+            g2d.scale(scale, scale);\n+        }\n@@ -113,1 +111,1 @@\n-        return(PAGE_EXISTS);\n+        return PAGE_EXISTS;\n@@ -116,114 +114,0 @@\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PageDlgPrnButton.java","additions":54,"deletions":170,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,10 @@\n-\/**\n- *\n- * test\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n+ * @test\n@@ -29,0 +36,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -32,5 +41,0 @@\n-\n-import java.awt.*;\n-import java.awt.print.*;\n-import java.awt.GraphicsEnvironment;\n-\n@@ -38,0 +42,2 @@\n+    private static final int LINE_HEIGHT = 18;\n+    private static final int FONT_SIZE = 14;\n@@ -39,6 +45,5 @@\n-    static Font[] allFonts;\n-    int fontNum = 0;\n-    int startNum = 0;\n-    int lineHeight = 18;\n-    boolean done = false;\n-    int thisPage = 0;\n+    private final Font[] allFonts =\n+            GraphicsEnvironment.getLocalGraphicsEnvironment().getAllFonts();\n+    private int fontNum = 0;\n+    private int startNum = 0;\n+    private int thisPage = 0;\n@@ -46,0 +51,5 @@\n+    private static final String INSTRUCTIONS =\n+            \"This bug is system dependent and is not always reproducible.\\n\" +\n+            \"Font names will be printed in two columns.\\n\" +\n+            \"First column non synthesised and second column with synthesised italic.\\n\" +\n+            \"A passing test will have all text printed with correct font style.\";\n@@ -48,0 +58,3 @@\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n@@ -49,14 +62,6 @@\n-        String[] instructions =\n-        {\n-            \"You must have a printer available to perform this test and should use Win 98.\",\n-            \"This bug is system dependent and is not always reproducible.\",\n-            \" \",\n-            \"A passing test will have all text printed with correct font style.\",\n-        };\n-\n-        Sysout.createDialog( );\n-        Sysout.printInstructions( instructions );\n-\n-        GraphicsEnvironment ge =\n-            GraphicsEnvironment.getLocalGraphicsEnvironment();\n-        allFonts = ge.getAllFonts();\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testTimeOut(10)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build();\n@@ -67,1 +72,3 @@\n-           pj.print();\n+            pj.print();\n+        } else {\n+            PassFailJFrame.forceFail(\"User cancelled printing\");\n@@ -69,0 +76,1 @@\n+        passFailJFrame.awaitAndCheck();\n@@ -71,0 +79,1 @@\n+    @Override\n@@ -72,1 +81,0 @@\n-\n@@ -82,1 +90,0 @@\n-        g.setColor(Color.black);\n@@ -84,4 +91,3 @@\n-        int hgt = (int)pf.getImageableHeight();\n-        int fontsPerPage = hgt\/lineHeight;\n-        int x = (int)pf.getImageableX()+10;\n-        int y = (int)pf.getImageableY()+lineHeight;\n+        int fontsPerPage = (int) pf.getImageableHeight() \/ LINE_HEIGHT - 1;\n+        int x = (int) pf.getImageableX() + 10;\n+        int y = (int) pf.getImageableY() + LINE_HEIGHT;\n@@ -89,0 +95,1 @@\n+        g.setColor(Color.black);\n@@ -90,1 +97,2 @@\n-            Font f = allFonts[fontNum].deriveFont(Font.PLAIN, 16);\n+            Font f = allFonts[fontNum].deriveFont(Font.PLAIN, FONT_SIZE);\n+            Font fi = allFonts[fontNum].deriveFont(Font.ITALIC, FONT_SIZE);\n@@ -93,1 +101,3 @@\n-            y+= lineHeight;\n+            g.setFont(fi);\n+            g.drawString(f.getFontName(), (int) (x + pf.getImageableWidth() \/ 2), y);\n+            y += LINE_HEIGHT;\n@@ -102,114 +112,0 @@\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintAllFonts.java","additions":48,"deletions":152,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,14 @@\n-\/**\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -29,0 +42,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,0 +46,22 @@\n+public class PrintCompoundString implements Printable {\n+    private static final String STR = \"Test string compound printing \\u2203\\u2200\\u2211\";\n+\n+    private static final String INSTRUCTIONS =\n+            \"This test should print following text\\n\\n\" +\n+            STR +\"\\n\\n\" +\n+            \"If an exception is thrown, or the page doesn't print properly\\n\" +\n+            \"then the test fails\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .splitUI(PrintCompoundString::createTestUI)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -32,42 +69,15 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-import java.text.*;\n-\n-public class PrintCompoundString extends Frame implements ActionListener {\n-\n- private TextCanvas c;\n-\n- public static void main(String args[]) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test should print a page which contains the same\",\n-         \"text message as in the test window on the screen\",\n-         \"You should also monitor the command line to see if any exceptions\",\n-         \"were thrown\",\n-         \"If an exception is thrown, or the page doesn't print properly\",\n-         \"then the test fails\",\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    PrintCompoundString f = new PrintCompoundString();\n-    f.show();\n- }\n-\n- public PrintCompoundString() {\n-    super(\"JDK 1.2 drawString Printing\");\n-\n-    c = new TextCanvas();\n-    add(\"Center\", c);\n-\n-    Button printButton = new Button(\"Print\");\n-    printButton.addActionListener(this);\n-    add(\"South\", printButton);\n-\n-    addWindowListener(new WindowAdapter() {\n-       public void windowClosing(WindowEvent e) {\n-             System.exit(0);\n+    private static JComponent createTestUI() {\n+        JButton b = new JButton(\"Print\");\n+        b.addActionListener((ae) -> {\n+            try {\n+                PrinterJob job = PrinterJob.getPrinterJob();\n+                job.setPrintable(new PrintCompoundString());\n+                if (job.printDialog()) {\n+                    job.print();\n+                }\n+            } catch (PrinterException ex) {\n+                ex.printStackTrace();\n+                String msg = \"PrinterException: \" + ex.getMessage();\n+                JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n+                        JOptionPane.ERROR_MESSAGE);\n+                PassFailJFrame.forceFail(msg);\n@@ -75,41 +85,8 @@\n-    });\n-\n-    pack();\n- }\n-\n- public void actionPerformed(ActionEvent e) {\n-\n-   PrinterJob pj = PrinterJob.getPrinterJob();\n-\n-   if (pj != null && pj.printDialog()) {\n-\n-       pj.setPrintable(c);\n-       try {\n-            pj.print();\n-      } catch (PrinterException pe) {\n-      } finally {\n-         System.err.println(\"PRINT RETURNED\");\n-      }\n-   }\n- }\n-\n- class TextCanvas extends Panel implements Printable {\n-\n-    String nullStr = null;\n-    String emptyStr = new String();\n-    AttributedString nullAttStr = null;\n-    AttributedString emptyAttStr = new AttributedString(emptyStr);\n-    AttributedCharacterIterator nullIterator = null;\n-    AttributedCharacterIterator emptyIterator = emptyAttStr.getIterator();\n-\n-    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n-\n-      if (pgIndex > 0)\n-         return Printable.NO_SUCH_PAGE;\n-\n-      Graphics2D g2d = (Graphics2D)g;\n-      g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-\n-      paint(g);\n-\n-      return Printable.PAGE_EXISTS;\n+        });\n+\n+        Box main = Box.createHorizontalBox();\n+        main.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));\n+        main.add(Box.createHorizontalGlue());\n+        main.add(b);\n+        main.add(Box.createHorizontalGlue());\n+        return main;\n@@ -118,5 +95,5 @@\n-    public void paint(Graphics g1) {\n-        Graphics2D g = (Graphics2D)g1;\n-\n-          String str = \"Test string compound printing \\u2203\\u2200\\u2211\";\n-          g.drawString(str, 20, 40);\n+    @Override\n+    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n+        if (pgIndex > 0) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n@@ -124,1 +101,3 @@\n-    }\n+        Graphics2D g2d = (Graphics2D) g;\n+        g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+        g2d.drawString(STR, 20, 40);\n@@ -126,2 +105,1 @@\n-     public Dimension getPreferredSize() {\n-        return new Dimension(450, 250);\n+        return Printable.PAGE_EXISTS;\n@@ -129,2 +107,0 @@\n- }\n-\n@@ -132,115 +108,0 @@\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintCompoundString.java","additions":71,"deletions":210,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,18 @@\n-\/**\n- * @test %I %W\n+import java.awt.BorderLayout;\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n+ * @test\n@@ -29,0 +45,3 @@\n+ * @requires os.family==\"windows\"\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,4 +50,0 @@\n-import java.awt.*;\n-import java.awt.print.*;\n-import java.awt.event.*;\n-\n@@ -36,48 +51,21 @@\n-\n-        private PrintImageCanvas                printImageCanvas;\n-\n-        private MenuItem        print1Menu = new MenuItem(\"PrintTest1\");\n-        private MenuItem        print2Menu = new MenuItem(\"PrintTest2\");\n-        private MenuItem        exitMenu = new MenuItem(\"Exit\");\n-\n-        public static void main(String[] argv) {\n-        String[] instructions =\n-           { \"You must have a printer available to perform this test,\",\n-             \"prefererably Canon LaserShot A309GII.\",\n-             \"Printing must be done in Win 98 Japanese 2nd Edition.\",\n-             \"\",\n-             \"Passing test : Output of text image for PrintTest1 and PrintTest2 should be same as that on the screen.\",\n-           };\n-\n-        Sysout.createDialog( );\n-         Sysout.printInstructions( instructions );\n-\n-                new PrintImage();\n-        }\n-\n-        public PrintImage() {\n-                super(\"PrintImage\");\n-                initPrintImage();\n-        }\n-\n-        public void initPrintImage() {\n-\n-                printImageCanvas = new PrintImageCanvas(this);\n-\n-                initMenu();\n-\n-                addWindowListener(new WindowAdapter() {\n-                        public void windowClosing(WindowEvent ev) {\n-                                dispose();\n-                        }\n-                        public void windowClosed(WindowEvent ev) {\n-                                System.exit(0);\n-                        }\n-                });\n-\n-                setLayout(new BorderLayout());\n-                add(printImageCanvas, BorderLayout.CENTER);\n-                pack();\n-\n-                setSize(500,500);\n-                setVisible(true);\n+    private final PrintImageCanvas printImageCanvas = new PrintImageCanvas();\n+    private final MenuItem print1Menu = new MenuItem(\"PrintTest1\");\n+    private final MenuItem print2Menu = new MenuItem(\"PrintTest2\");\n+    private static final String INSTRUCTIONS =\n+            \"Select PrintTest1 in the File menu.\\n\" +\n+            \"Print Dialog will appear.\\n\" +\n+            \"Click OK to start the first print job.\\n\" +\n+            \"\\n\" +\n+            \"Select PrintTest2 in the File menu.\\n\" +\n+            \"Page Setup Dialog will appear.\\n\" +\n+            \"Click OK.\\n\" +\n+            \"Print Dialog will appear.\\n\" +\n+            \"Click OK to start the second print job.\\n\" +\n+            \"\\n\" +\n+            \"The text in the printouts for PrintTest1 and PrintTest2 should be\\n\" +\n+            \"same as that on the screen.\\n\" +\n+            \"Press Pass if they are, otherwise press Fail.\";\n+\n+    public static void main(String[] argv) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n@@ -86,14 +74,8 @@\n-        private void initMenu() {\n-                MenuBar         mb = new MenuBar();\n-                Menu            me = new Menu(\"File\");\n-                me.add(print1Menu);\n-                me.add(print2Menu);\n-                me.add(\"-\");\n-                me.add(exitMenu);\n-                mb.add(me);\n-                this.setMenuBar(mb);\n-\n-                print1Menu.addActionListener(this);\n-                print2Menu.addActionListener(this);\n-                exitMenu.addActionListener(this);\n-        }\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testUI(PrintImage::new)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -101,12 +83,4 @@\n-        public void actionPerformed(ActionEvent e) {\n-                Object target = e.getSource();\n-                if( target.equals(print1Menu) ) {\n-                        printMain1();\n-                }\n-                else if( target.equals(print2Menu) ) {\n-                        printMain2();\n-                }\n-                else if( target.equals(exitMenu) ) {\n-                        dispose();\n-                }\n-        }\n+    public PrintImage() {\n+        super(\"PrintImage\");\n+        initPrintImage();\n+    }\n@@ -114,1 +88,6 @@\n-        private void printMain1(){\n+    public void initPrintImage() {\n+        initMenu();\n+        setLayout(new BorderLayout());\n+        add(printImageCanvas, BorderLayout.CENTER);\n+        setSize(500, 300);\n+    }\n@@ -116,2 +95,7 @@\n-                PrinterJob printerJob = PrinterJob.getPrinterJob();\n-                PageFormat pageFormat = printerJob.defaultPage();\n+    private void initMenu() {\n+        MenuBar mb = new MenuBar();\n+        Menu me = new Menu(\"File\");\n+        me.add(print1Menu);\n+        me.add(print2Menu);\n+        mb.add(me);\n+        setMenuBar(mb);\n@@ -119,1 +103,3 @@\n-                printerJob.setPrintable((Printable)printImageCanvas, pageFormat);\n+        print1Menu.addActionListener(this);\n+        print2Menu.addActionListener(this);\n+    }\n@@ -121,9 +107,6 @@\n-                if(printerJob.printDialog()){\n-                        try {\n-                                printerJob.print();\n-                        }\n-                        catch(PrinterException p){\n-                        }\n-                }\n-                else\n-                        printerJob.cancel();\n+    public void actionPerformed(ActionEvent e) {\n+        Object target = e.getSource();\n+        if (target.equals(print1Menu)) {\n+            printMain1();\n+        } else if (target.equals(print2Menu)) {\n+            printMain2();\n@@ -131,0 +114,1 @@\n+    }\n@@ -132,16 +116,15 @@\n-        private void printMain2(){\n-\n-                PrinterJob printerJob = PrinterJob.getPrinterJob();\n-                PageFormat pageFormat = printerJob.pageDialog(printerJob.defaultPage());\n-\n-                printerJob.setPrintable((Printable)printImageCanvas, pageFormat);\n-\n-                if(printerJob.printDialog()){\n-                        try {\n-                                printerJob.print();\n-                        }\n-                        catch(PrinterException p){\n-                        }\n-                }\n-                else\n-                        printerJob.cancel();\n+    private void printMain1() {\n+        PrinterJob printerJob = PrinterJob.getPrinterJob();\n+        PageFormat pageFormat = printerJob.defaultPage();\n+\n+        printerJob.setPrintable(printImageCanvas, pageFormat);\n+\n+        if (printerJob.printDialog()) {\n+            try {\n+                printerJob.print();\n+            } catch (PrinterException e) {\n+                PassFailJFrame.forceFail(\"Print Failed\");\n+                e.printStackTrace();\n+            }\n+        } else {\n+            printerJob.cancel();\n@@ -149,0 +132,1 @@\n+    }\n@@ -150,8 +134,15 @@\n-}\n-\n-class PrintImageCanvas extends Canvas implements Printable {\n-\n-        private PrintImage pdsFrame;\n-\n-        public PrintImageCanvas(PrintImage pds) {\n-                pdsFrame = pds;\n+    private void printMain2() {\n+        PrinterJob printerJob = PrinterJob.getPrinterJob();\n+        PageFormat pageFormat = printerJob.pageDialog(printerJob.defaultPage());\n+\n+        printerJob.setPrintable(printImageCanvas, pageFormat);\n+\n+        if (printerJob.printDialog()) {\n+            try {\n+                printerJob.print();\n+            } catch (PrinterException e) {\n+                PassFailJFrame.forceFail(\"Print Failed\");\n+                e.printStackTrace();\n+            }\n+        } else {\n+            printerJob.cancel();\n@@ -159,0 +150,1 @@\n+    }\n@@ -160,0 +152,2 @@\n+    private static class PrintImageCanvas extends Canvas implements Printable {\n+        @Override\n@@ -161,3 +155,4 @@\n-                Font drawFont = new Font(\"MS Mincho\",Font.ITALIC,50);\n-                g.setFont(drawFont);\n-                g.drawString(\"PrintSample!\",100,150);\n+            Font drawFont = new Font(\"MS Mincho\", Font.ITALIC, 50);\n+            g.setFont(drawFont);\n+            g.setColor(new Color(0, 0, 0, 200));\n+            g.drawString(\"PrintSample!\", 100, 150);\n@@ -166,0 +161,1 @@\n+        @Override\n@@ -168,12 +164,5 @@\n-\n-                if(pi>=1)\n-                        return NO_SUCH_PAGE;\n-                else{\n-                        Graphics2D g2 = (Graphics2D)g;\n-                        g.setColor(new Color(0,0,0,200));\n-\n-                        Font drawFont = new Font(\"MS Mincho\",Font.ITALIC,50);\n-                        g.setFont(drawFont);\n-                        g.drawString(\"PrintSample!\",100,150);\n-                        return PAGE_EXISTS;\n-                }\n+            if (pi > 0) {\n+                return NO_SUCH_PAGE;\n+            }\n+            paint(g);\n+            return PAGE_EXISTS;\n@@ -181,113 +170,0 @@\n-}\n-\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n@@ -295,0 +171,1 @@\n+}\n@@ -296,1 +173,0 @@\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintImage.java","additions":123,"deletions":247,"binary":false,"changes":370,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,16 @@\n-\/**\n+import java.awt.Button;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.text.AttributedCharacterIterator;\n+import java.text.AttributedString;\n+\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -29,0 +44,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,209 +48,23 @@\n-\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-import java.text.*;\n-\n-public class PrintNullString extends Frame implements ActionListener {\n-\n- private TextCanvas c;\n-\n- public static void main(String args[]) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test should print a page which contains the same\",\n-         \"text messages as in the test window on the screen\",\n-         \"The messages should contain only 'OK' and 'expected' messages\",\n-         \"There should be no FAILURE messages.\",\n-         \"You should also monitor the command line to see if any exceptions\",\n-         \"were thrown\",\n-         \"If the page fails to print, but there were no exceptions\",\n-         \"then the problem is likely elsewhere (ie your printer)\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    PrintNullString f = new PrintNullString();\n-    f.show();\n- }\n-\n- public PrintNullString() {\n-    super(\"JDK 1.2 drawString Printing\");\n-\n-    c = new TextCanvas();\n-    add(\"Center\", c);\n-\n-    Button printButton = new Button(\"Print\");\n-    printButton.addActionListener(this);\n-    add(\"South\", printButton);\n-\n-    addWindowListener(new WindowAdapter() {\n-       public void windowClosing(WindowEvent e) {\n-             System.exit(0);\n-            }\n-    });\n-\n-    pack();\n- }\n-\n- public void actionPerformed(ActionEvent e) {\n-\n-   PrinterJob pj = PrinterJob.getPrinterJob();\n-\n-   if (pj != null && pj.printDialog()) {\n-\n-       pj.setPrintable(c);\n-       try {\n-            pj.print();\n-      } catch (PrinterException pe) {\n-      } finally {\n-         System.err.println(\"PRINT RETURNED\");\n-      }\n-   }\n- }\n-\n- class TextCanvas extends Panel implements Printable {\n-\n-    String nullStr = null;\n-    String emptyStr = new String();\n-    AttributedString nullAttStr = null;\n-    AttributedString emptyAttStr = new AttributedString(emptyStr);\n-    AttributedCharacterIterator nullIterator = null;\n-    AttributedCharacterIterator emptyIterator = emptyAttStr.getIterator();\n-\n-    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n-\n-      if (pgIndex > 0)\n-         return Printable.NO_SUCH_PAGE;\n-\n-      Graphics2D g2d = (Graphics2D)g;\n-      g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-\n-      paint(g);\n-\n-      return Printable.PAGE_EXISTS;\n-    }\n-\n-    public void paint(Graphics g1) {\n-        Graphics2D g = (Graphics2D)g1;\n-\n-        \/\/ API 1: null & empty drawString(String, int, int);\n-        try {\n-             g.drawString(nullStr, 20, 40);\n-             g.drawString(\"FAILURE: No NPE for null String, int\", 20, 40);\n-        } catch (NullPointerException e) {\n-          g.drawString(\"caught expected NPE for null String, int\", 20, 40);\n-        }\/* catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for null String, int\",\n-                        20, 40);\n-        }*\/\n-\n-        \/\/try {\n-             g.drawString(emptyStr, 20, 60);\n-             g.drawString(\"OK for empty String, int\", 20, 60);\n-        \/*} catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for empty String, int\",\n-                        20, 60);\n-        }*\/\n-\n-\n-        \/\/ API 2: null & empty drawString(String, float, float);\n-        try {\n-             g.drawString(nullStr, 20.0f, 80.0f);\n-             g.drawString(\"FAILURE: No NPE for null String, float\", 20, 80);\n-        } catch (NullPointerException e) {\n-          g.drawString(\"caught expected NPE for null String, float\", 20, 80);\n-        } \/*catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for null String, float\",\n-                        20, 80);\n-        }*\/\n-        \/\/try {\n-             g.drawString(emptyStr, 20.0f, 100.0f);\n-             g.drawString(\"OK for empty String, float\", 20.0f, 100.f);\n-        \/* } catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for empty String, float\",\n-                        20, 100);\n-        }*\/\n-\n-        \/\/ API 3: null & empty drawString(Iterator, int, int);\n-        try {\n-             g.drawString(nullIterator, 20, 120);\n-             g.drawString(\"FAILURE: No NPE for null iterator, float\", 20, 120);\n-        } catch (NullPointerException e) {\n-          g.drawString(\"caught expected NPE for null iterator, int\", 20, 120);\n-        } \/*catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for null iterator, int\",\n-                       20, 120);\n-        } *\/\n-        try {\n-             g.drawString(emptyIterator, 20, 140);\n-             g.drawString(\"FAILURE: No IAE for empty iterator, int\",\n-                           20, 140);\n-        } catch (IllegalArgumentException e) {\n-          g.drawString(\"caught expected IAE for empty iterator, int\",\n-                        20, 140);\n-        } \/*catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for empty iterator, int\",\n-                       20, 140);\n-        } *\/\n-\n-\n-        \/\/ API 4: null & empty drawString(Iterator, float, int);\n-        try {\n-             g.drawString(nullIterator, 20.0f, 160.0f);\n-             g.drawString(\"FAILURE: No NPE for null iterator, float\", 20, 160);\n-        } catch (NullPointerException e) {\n-          g.drawString(\"caught expected NPE for null iterator, float\", 20, 160);\n-        } \/*catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for null iterator, float\",\n-                        20, 160);\n-        } *\/\n-\n-        try {\n-             g.drawString(emptyIterator, 20, 180);\n-             g.drawString(\"FAILURE: No IAE for empty iterator, float\",\n-                           20, 180);\n-        } catch (IllegalArgumentException e) {\n-          g.drawString(\"caught expected IAE for empty iterator, float\",\n-                        20, 180);\n-        } \/*catch (Exception e) {\n-          g.drawString(\"FAILURE: unexpected exception for empty iterator, float\",\n-                       20, 180);\n-        } *\/\n-    }\n-\n-     public Dimension getPreferredSize() {\n-        return new Dimension(450, 250);\n-    }\n- }\n-\n-}\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n+public class PrintNullString extends Frame {\n+    private static final String INSTRUCTIONS =\n+            \"This test should print a page which contains the same\\n\" +\n+            \"text messages as in the test window on the screen.\\n\" +\n+            \"\\n\" +\n+            \"The messages should contain only 'OK' and 'expected' messages.\\n\" +\n+            \"Press Pass if it's the case; otherwise press Fail.\\n\" +\n+            \"\\n\" +\n+            \"If the page fails to print, but there were no exceptions\\n\" +\n+            \"then the problem is likely elsewhere (i.e. your printer)\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testUI(PrintNullString::new)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n@@ -242,4 +73,24 @@\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n+    public PrintNullString() {\n+        super(\"PrintNullString\");\n+\n+        TextCanvas c = new TextCanvas();\n+        add(\"Center\", c);\n+\n+        Button b = new Button(\"Print\");\n+        add(\"South\", b);\n+        b.addActionListener(e -> {\n+            PrinterJob pj = PrinterJob.getPrinterJob();\n+            if (pj.printDialog()) {\n+                pj.setPrintable(c);\n+                try {\n+                    pj.print();\n+                } catch (PrinterException ex) {\n+                    ex.printStackTrace();\n+                    String msg = \"PrinterException: \" + ex.getMessage();\n+                    JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n+                            JOptionPane.ERROR_MESSAGE);\n+                    PassFailJFrame.forceFail(msg);\n+                }\n+            }\n+        });\n+        pack();\n@@ -248,28 +99,18 @@\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n+    private static class TextCanvas extends Panel implements Printable {\n+        private final String nullStr = null;\n+        private final String emptyStr = \"\";\n+        private final AttributedString emptyAttStr = new AttributedString(emptyStr);\n+        private final AttributedCharacterIterator nullIterator = null;\n+        private final AttributedCharacterIterator emptyIterator = emptyAttStr.getIterator();\n+\n+        @Override\n+        public void paint(Graphics g) {\n+            Graphics2D g2d = (Graphics2D) g;\n+            paint(g2d);\n+        }\n+\n+        @Override\n+        public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n+            if (pgIndex > 0) {\n+                return NO_SUCH_PAGE;\n+            }\n@@ -277,2 +118,3 @@\n-      show();\n-    }\/\/ TestDialog()\n+            Graphics2D g2d = (Graphics2D) g;\n+            g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+            paint(g2d);\n@@ -280,5 +122,2 @@\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n+            return PAGE_EXISTS;\n+        }\n@@ -286,1 +125,8 @@\n-      \/\/Go down array of instruction strings\n+        private void paint(Graphics2D g2d) {\n+            \/\/ API 1: null & empty drawString(String, int, int);\n+            try {\n+                g2d.drawString(nullStr, 20, 40);\n+                g2d.drawString(\"FAILURE: No NPE for null String, int\", 20, 40);\n+            } catch (NullPointerException e) {\n+                g2d.drawString(\"caught expected NPE for null String, int\", 20, 40);\n+            }\n@@ -288,13 +134,2 @@\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n+            g2d.drawString(emptyStr, 20, 60);\n+            g2d.drawString(\"OK for empty String, int\", 20, 60);\n@@ -302,1 +137,7 @@\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n+            \/\/ API 2: null & empty drawString(String, float, float);\n+            try {\n+                g2d.drawString(nullStr, 20.0f, 80.0f);\n+                g2d.drawString(\"FAILURE: No NPE for null String, float\", 20, 80);\n+            } catch (NullPointerException e) {\n+                g2d.drawString(\"caught expected NPE for null String, float\", 20, 80);\n+            }\n@@ -304,9 +145,2 @@\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n+            g2d.drawString(emptyStr, 20.0f, 100.0f);\n+            g2d.drawString(\"OK for empty String, float\", 20.0f, 100.f);\n@@ -314,1 +148,7 @@\n-            instructionsText.append( printStr + \"\\n\" );\n+            \/\/ API 3: null & empty drawString(Iterator, int, int);\n+            try {\n+                g2d.drawString(nullIterator, 20, 120);\n+                g2d.drawString(\"FAILURE: No NPE for null iterator, float\", 20, 120);\n+            } catch (NullPointerException e) {\n+                g2d.drawString(\"caught expected NPE for null iterator, int\", 20, 120);\n+            }\n@@ -316,1 +156,6 @@\n-          }\/\/ while\n+            try {\n+                g2d.drawString(emptyIterator, 20, 140);\n+                g2d.drawString(\"FAILURE: No IAE for empty iterator, int\", 20, 140);\n+            } catch (IllegalArgumentException e) {\n+                g2d.drawString(\"caught expected IAE for empty iterator, int\", 20, 140);\n+            }\n@@ -318,1 +163,7 @@\n-       }\/\/ for\n+            \/\/ API 4: null & empty drawString(Iterator, float, int);\n+            try {\n+                g2d.drawString(nullIterator, 20.0f, 160.0f);\n+                g2d.drawString(\"FAILURE: No NPE for null iterator, float\", 20, 160);\n+            } catch (NullPointerException e) {\n+                g2d.drawString(\"caught expected NPE for null iterator, float\", 20, 160);\n+            }\n@@ -320,1 +171,7 @@\n-    }\/\/printInstructions()\n+            try {\n+                g2d.drawString(emptyIterator, 20, 180);\n+                g2d.drawString(\"FAILURE: No IAE for empty iterator, float\", 20, 180);\n+            } catch (IllegalArgumentException e) {\n+                g2d.drawString(\"caught expected IAE for empty iterator, float\", 20, 180);\n+            }\n+        }\n@@ -322,4 +179,4 @@\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n+        @Override\n+        public Dimension getPreferredSize() {\n+            return new Dimension(450, 250);\n+        }\n@@ -327,2 +184,1 @@\n-\n- }\/\/ TestDialog  class\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintNullString.java","additions":140,"deletions":284,"binary":false,"changes":424,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,14 @@\n-\/**\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -29,0 +42,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,0 +46,22 @@\n+public class PrintParenString implements Printable {\n+    private static final String STR = \"String containing unclosed parenthesis (.\";\n+\n+    private static final String INSTRUCTIONS =\n+            \"This test should print a page with following text\\n\\n\" +\n+            STR + \"\\n\\n\" +\n+            \"If an exception is thrown, or the page doesn't print properly\\n\" +\n+            \"then the test fails\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .splitUI(PrintParenString::createTestUI)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -32,42 +69,15 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-import java.text.*;\n-\n-public class PrintParenString extends Frame implements ActionListener {\n-\n- private TextCanvas c;\n-\n- public static void main(String args[]) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test should print a page which contains the same\",\n-         \"text message as in the test window on the screen\",\n-         \"You should also monitor the command line to see if any exceptions\",\n-         \"were thrown\",\n-         \"If an exception is thrown, or the page doesn't print properly\",\n-         \"then the test fails\",\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    PrintParenString f = new PrintParenString();\n-    f.show();\n- }\n-\n- public PrintParenString() {\n-    super(\"JDK 1.2 drawString Printing\");\n-\n-    c = new TextCanvas();\n-    add(\"Center\", c);\n-\n-    Button printButton = new Button(\"Print\");\n-    printButton.addActionListener(this);\n-    add(\"South\", printButton);\n-\n-    addWindowListener(new WindowAdapter() {\n-       public void windowClosing(WindowEvent e) {\n-             System.exit(0);\n+    private static JComponent createTestUI() {\n+        JButton b = new JButton(\"Print\");\n+        b.addActionListener((ae) -> {\n+            try {\n+                PrinterJob job = PrinterJob.getPrinterJob();\n+                job.setPrintable(new PrintParenString());\n+                if (job.printDialog()) {\n+                    job.print();\n+                }\n+            } catch (PrinterException ex) {\n+                ex.printStackTrace();\n+                String msg = \"PrinterException: \" + ex.getMessage();\n+                JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n+                        JOptionPane.ERROR_MESSAGE);\n+                PassFailJFrame.forceFail(msg);\n@@ -75,41 +85,8 @@\n-    });\n-\n-    pack();\n- }\n-\n- public void actionPerformed(ActionEvent e) {\n-\n-   PrinterJob pj = PrinterJob.getPrinterJob();\n-\n-   if (pj != null && pj.printDialog()) {\n-\n-       pj.setPrintable(c);\n-       try {\n-            pj.print();\n-      } catch (PrinterException pe) {\n-      } finally {\n-         System.err.println(\"PRINT RETURNED\");\n-      }\n-   }\n- }\n-\n- class TextCanvas extends Panel implements Printable {\n-\n-    String nullStr = null;\n-    String emptyStr = new String();\n-    AttributedString nullAttStr = null;\n-    AttributedString emptyAttStr = new AttributedString(emptyStr);\n-    AttributedCharacterIterator nullIterator = null;\n-    AttributedCharacterIterator emptyIterator = emptyAttStr.getIterator();\n-\n-    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n-\n-      if (pgIndex > 0)\n-         return Printable.NO_SUCH_PAGE;\n-\n-      Graphics2D g2d = (Graphics2D)g;\n-      g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-\n-      paint(g);\n-\n-      return Printable.PAGE_EXISTS;\n+        });\n+\n+        Box main = Box.createHorizontalBox();\n+        main.setBorder(BorderFactory.createEmptyBorder(8, 8, 8, 8));\n+        main.add(Box.createHorizontalGlue());\n+        main.add(b);\n+        main.add(Box.createHorizontalGlue());\n+        return main;\n@@ -118,5 +95,5 @@\n-    public void paint(Graphics g1) {\n-        Graphics2D g = (Graphics2D)g1;\n-\n-          String str = \"String containing unclosed parenthesis (.\";\n-          g.drawString(str, 20, 40);\n+    @Override\n+    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n+        if (pgIndex > 0) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n@@ -124,1 +101,3 @@\n-    }\n+        Graphics2D g2d = (Graphics2D) g;\n+        g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+        g2d.drawString(STR, 20, 40);\n@@ -126,2 +105,1 @@\n-     public Dimension getPreferredSize() {\n-        return new Dimension(450, 250);\n+        return Printable.PAGE_EXISTS;\n@@ -129,2 +107,0 @@\n- }\n-\n@@ -132,115 +108,0 @@\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintParenString.java","additions":71,"deletions":210,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,17 @@\n-\/**\n+import java.awt.Button;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.FontMetrics;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.geom.AffineTransform;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -28,0 +44,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,0 +49,21 @@\n+public class PrintTranslatedFont extends Frame {\n+    private static final String INSTRUCTIONS =\n+            \"This test should print a page which contains the same\\n\" +\n+            \"content as the test window on the screen, in particular the lines\\n\" +\n+            \"should be immediately under the text\\n\\n\" +\n+            \"If an exception is thrown, or the page doesn't print properly\\n\" +\n+            \"then the test fails\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testUI(PrintTranslatedFont::new)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -32,44 +71,21 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.geom.*;\n-import java.awt.print.*;\n-import java.text.*;\n-\n-public class PrintTranslatedFont extends Frame implements ActionListener {\n-\n- private TextCanvas c;\n-\n- public static void main(String args[]) {\n-\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test should print a page which contains the same\",\n-         \"content as the test window on the screen, in particular the lines\",\n-         \"should be immediately under the text\",\n-         \"You should also monitor the command line to see if any exceptions\",\n-         \"were thrown\",\n-         \"If an exception is thrown, or the page doesn't print properly\",\n-         \"then the test fails\",\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    PrintTranslatedFont f = new PrintTranslatedFont();\n-    f.show();\n- }\n-\n- public PrintTranslatedFont() {\n-    super(\"JDK 1.2 drawString Printing\");\n-\n-    c = new TextCanvas();\n-    add(\"Center\", c);\n-\n-    Button printButton = new Button(\"Print\");\n-    printButton.addActionListener(this);\n-    add(\"South\", printButton);\n-\n-    addWindowListener(new WindowAdapter() {\n-       public void windowClosing(WindowEvent e) {\n-             System.exit(0);\n+    public PrintTranslatedFont() {\n+        super(\"PrintTranslatedFont\");\n+\n+        TextCanvas c = new TextCanvas();\n+        add(\"Center\", c);\n+\n+        Button b = new Button(\"Print\");\n+        add(\"South\", b);\n+        b.addActionListener(e -> {\n+            PrinterJob pj = PrinterJob.getPrinterJob();\n+            if (pj.printDialog()) {\n+                pj.setPrintable(c);\n+                try {\n+                    pj.print();\n+                } catch (PrinterException ex) {\n+                    ex.printStackTrace();\n+                    String msg = \"PrinterException: \" + ex.getMessage();\n+                    JOptionPane.showMessageDialog(b, msg, \"Error occurred\",\n+                            JOptionPane.ERROR_MESSAGE);\n+                    PassFailJFrame.forceFail(msg);\n+                }\n@@ -77,6 +93,1 @@\n-    });\n-\n-    pack();\n- }\n-\n- public void actionPerformed(ActionEvent e) {\n+        });\n@@ -84,27 +95,1 @@\n-   PrinterJob pj = PrinterJob.getPrinterJob();\n-\n-   if (pj != null && pj.printDialog()) {\n-\n-       pj.setPrintable(c);\n-       try {\n-            pj.print();\n-      } catch (PrinterException pe) {\n-      } finally {\n-         System.err.println(\"PRINT RETURNED\");\n-      }\n-   }\n- }\n-\n- class TextCanvas extends Panel implements Printable {\n-\n-    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n-\n-      if (pgIndex > 0)\n-         return Printable.NO_SUCH_PAGE;\n-\n-      Graphics2D g2d = (Graphics2D)g;\n-      g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-\n-      paint(g);\n-\n-      return Printable.PAGE_EXISTS;\n+        pack();\n@@ -113,23 +98,12 @@\n-    public void paint(Graphics g1) {\n-        Graphics2D g = (Graphics2D)g1;\n-\n-          Font f = new Font(\"Dialog\", Font.PLAIN, 20);\n-          int tx = 20;\n-          int ty = 20;\n-          AffineTransform at = AffineTransform.getTranslateInstance(tx, ty);\n-          f = f.deriveFont(at);\n-          g.setFont(f);\n-\n-          FontMetrics fm = g.getFontMetrics();\n-          String str = \"Basic ascii string\";\n-          int sw = fm.stringWidth(str);\n-          int posx = 20, posy = 40;\n-          g.drawString(str, posx, posy);\n-          g.drawLine(posx+tx, posy+ty+2, posx+tx+sw, posy+ty+2);\n-\n-          posx = 20; posy = 70;\n-          str = \"Test string compound printing \\u2203\\u2200\";\n-          sw = fm.stringWidth(str);\n-          g.drawString(str, posx, posy);\n-          g.drawLine(posx+tx, posy+ty+2, posx+tx+sw, posy+ty+2);\n-    }\n+    private static class TextCanvas extends Panel implements Printable {\n+        @Override\n+        public void paint(Graphics g) {\n+            Graphics2D g2d = (Graphics2D) g;\n+            paint(g2d);\n+        }\n+\n+        @Override\n+        public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n+            if (pgIndex > 0) {\n+                return Printable.NO_SUCH_PAGE;\n+            }\n@@ -137,2 +111,34 @@\n-     public Dimension getPreferredSize() {\n-        return new Dimension(450, 250);\n+            Graphics2D g2d = (Graphics2D) g;\n+            g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+            paint(g2d);\n+            return Printable.PAGE_EXISTS;\n+        }\n+\n+        private void paint(Graphics2D g2d) {\n+            Font f = new Font(\"Dialog\", Font.PLAIN, 20);\n+            int tx = 20;\n+            int ty = 20;\n+            AffineTransform at = AffineTransform.getTranslateInstance(tx, ty);\n+            f = f.deriveFont(at);\n+            g2d.setFont(f);\n+\n+            FontMetrics fm = g2d.getFontMetrics();\n+            String str = \"Basic ascii string\";\n+            int sw = fm.stringWidth(str);\n+            int posx = 20;\n+            int posy = 40;\n+            g2d.drawString(str, posx, posy);\n+            g2d.drawLine(posx + tx, posy + ty + 2, posx + tx + sw, posy + ty + 2);\n+\n+            posx = 20;\n+            posy = 70;\n+            str = \"Test string compound printing \\u2203\\u2200\";\n+            sw = fm.stringWidth(str);\n+            g2d.drawString(str, posx, posy);\n+            g2d.drawLine(posx + tx, posy + ty + 2, posx + tx + sw, posy + ty + 2);\n+        }\n+\n+        @Override\n+        public Dimension getPreferredSize() {\n+            return new Dimension(450, 250);\n+        }\n@@ -140,2 +146,0 @@\n- }\n-\n@@ -143,115 +147,0 @@\n-\n-class Sysout\n- {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n- }\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrintTranslatedFont.java","additions":110,"deletions":221,"binary":false,"changes":331,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @bug 4784285 4785920\n+ * @bug 4784285 4785920 5024549\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/PrinterDialogsModalityTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,19 @@\n-\/**\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GridLayout;\n+import java.awt.Label;\n+import java.awt.Panel;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Paper;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import javax.swing.JOptionPane;\n+\n+\/*\n@@ -29,0 +47,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,5 +51,0 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-\n@@ -37,287 +52,21 @@\n-\n-PrinterJob myPrinterJob;\n-PageFormat myPageFormat;\n-Label pw, ph, pglm, pgrm, pgiw, pgih, pgtm, pgbm;\n-TextField tpw, tph, tpglm, tpgtm, tpgiw, tpgih;\n-Label myWidthLabel;\n-Label myHeightLabel;\n-Label myImageableXLabel;\n-Label myImageableYLabel;\n-Label myImageableRightLabel;\n-Label myImageableBottomLabel;\n-Label myImageableWidthLabel;\n-Label myImageableHeightLabel;\n-Label myOrientationLabel;\n-\n-  protected void displayPageFormatAttributes() {\n-    myWidthLabel.setText (\"Format Width = \" + drnd(myPageFormat.getWidth()));\n-    myHeightLabel.setText (\"Format Height = \" + drnd(myPageFormat.getHeight()));\n-    myImageableXLabel.setText\n-        (\"Format Left Margin = \" + drnd(myPageFormat.getImageableX()));\n-    myImageableRightLabel.setText\n-        (\"Format Right Margin = \" + drnd(myPageFormat.getWidth() -\n-        (myPageFormat.getImageableX() + myPageFormat.getImageableWidth())));\n-    myImageableWidthLabel.setText\n-        (\"Format ImageableWidth = \" + drnd(myPageFormat.getImageableWidth()));\n-    myImageableYLabel.setText\n-        (\"Format Top Margin = \" + drnd(myPageFormat.getImageableY()));\n-    myImageableBottomLabel.setText\n-        (\"Format Bottom Margin = \" + drnd(myPageFormat.getHeight() -\n-        (myPageFormat.getImageableY() + myPageFormat.getImageableHeight())));\n-    myImageableHeightLabel.setText\n-        (\"Format ImageableHeight = \" + drnd(myPageFormat.getImageableHeight()));\n-    int o = myPageFormat.getOrientation();\n-    myOrientationLabel.setText\n-        (\"Format Orientation = \" +\n-                (o == PageFormat.PORTRAIT ? \"PORTRAIT\" :\n-                 o == PageFormat.LANDSCAPE ? \"LANDSCAPE\" :\n-                 o == PageFormat.REVERSE_LANDSCAPE ? \"REVERSE_LANDSCAPE\" :\n-                 \"<invalid>\"));\n-    Paper p = myPageFormat.getPaper();\n-    pw.setText(\"Paper Width = \" + drnd(p.getWidth()));\n-    ph.setText(\"Paper Height = \" + drnd(p.getHeight()));\n-    pglm.setText(\"Paper Left Margin = \" + drnd(p.getImageableX()));\n-    pgiw.setText(\"Paper Imageable Width = \" + drnd(p.getImageableWidth()));\n-    pgih.setText(\"Paper Imageable Height = \" + drnd(p.getImageableHeight()));\n-\n-    pgrm.setText(\"Paper Right Margin = \" +\n-         drnd(p.getWidth() - (p.getImageableX()+p.getImageableWidth())));\n-    pgtm.setText(\"Paper Top Margin = \" + drnd(p.getImageableY()));\n-    pgbm.setText(\"Paper Bottom Margin = \" +\n-       drnd(p.getHeight() - (p.getImageableY()+p.getImageableHeight())));\n-  }\n-\n-  static String drnd(double d) {\n-      d = d * 10.0 + 0.5;\n-      d = Math.floor(d) \/10.0;\n-      String ds = Double.toString(d);\n-      int decimal_pos = ds.indexOf(\".\");\n-      int len = ds.length();\n-      if (len > decimal_pos+2) {\n-          return ds.substring(0, decimal_pos+2);\n-      } else {\n-          return ds;\n-      }\n-  }\n-\n-  public ValidatePage() {\n-    super (\"Validate Page Test\");\n-    myPrinterJob = PrinterJob.getPrinterJob();\n-    myPageFormat = new PageFormat();\n-    Paper p = new Paper();\n-    p.setSize(28*72, 21.5 * 72);\n-    myPageFormat.setPaper(p);\n-    setLayout(new FlowLayout());\n-    Panel pfp = new Panel();\n-    pfp.setLayout (new GridLayout (9, 1, 0, 0));\n-    pfp.add (myOrientationLabel = new Label());\n-    pfp.add (myWidthLabel = new Label());\n-    pfp.add (myImageableXLabel = new Label());\n-    pfp.add (myImageableRightLabel = new Label());\n-    pfp.add (myImageableWidthLabel = new Label());\n-    pfp.add (myHeightLabel = new Label());\n-    pfp.add (myImageableYLabel = new Label());\n-    pfp.add (myImageableBottomLabel = new Label());\n-    pfp.add (myImageableHeightLabel = new Label());\n-\n-    add(pfp);\n-\n-    Panel pp = new Panel();\n-    pp.setLayout (new GridLayout (8, 1, 0, 0));\n-    pp.add (pw = new Label());\n-    pp.add (pglm = new Label());\n-    pp.add (pgtm = new Label());\n-    pp.add (ph = new Label());\n-    pp.add (pgiw = new Label());\n-    pp.add (pgih = new Label());\n-    pp.add (pgrm = new Label());\n-    pp.add (pgbm = new Label());\n-\n-    add(pp);\n-\n-    Panel epp = new Panel();\n-    epp.setLayout (new GridLayout (6, 2, 0, 0));\n-\n-    epp.add(new Label(\"Page width:\"));\n-    epp.add (tpw = new TextField());\n-    epp.add(new Label(\"Page height:\"));\n-    epp.add (tph = new TextField());\n-    epp.add(new Label(\"Left Margin:\"));\n-    epp.add (tpglm = new TextField());\n-    epp.add(new Label(\"Top margin:\"));\n-    epp.add (tpgtm = new TextField());\n-    epp.add(new Label(\"Imageable Wid:\"));\n-    epp.add (tpgiw = new TextField());\n-    epp.add(new Label(\"Imageable Hgt:\"));\n-    epp.add (tpgih = new TextField());\n-\n-    add(epp);\n-       displayPageFormatAttributes();\n-\n-    Panel panel = new Panel();\n-    Button defButton = new Button (\"Default Page\");\n-    defButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                        myPageFormat = myPrinterJob.defaultPage();\n-                        displayPageFormatAttributes();\n-                }\n-    });\n-\n-    Button pageButton = new Button (\"Page Setup..\");\n-    pageButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                        myPageFormat = myPrinterJob.pageDialog (myPageFormat);\n-                        displayPageFormatAttributes();\n-                }\n-    });\n-    Button printButton = new Button (\"Print\");\n-    printButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                    try {\n-                         \/\/if (myPrinterJob.printDialog()) {\n-                             myPrinterJob.setPrintable(ValidatePage.this,\n-                                                       myPageFormat);\n-                             myPrinterJob.print();\n-                   \/\/ }\n-                    } catch (PrinterException pe ) {\n-                    }\n-                }\n-    });\n-\n-    Button chooseButton = new Button (\"Printer..\");\n-    chooseButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                            myPrinterJob.printDialog();\n-                }\n-    });\n-\n-    Button validateButton = new Button (\"Validate Page\");\n-    validateButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                        myPageFormat = myPrinterJob.validatePage(myPageFormat);\n-                        displayPageFormatAttributes();\n-                }\n-    });\n-    Button setButton = new Button (\"Set Paper\");\n-    setButton.addActionListener(new ActionListener() {\n-                public void actionPerformed (ActionEvent e) {\n-                  try {\n-                      Paper p = new Paper();\n-                      double pwid = Double.parseDouble(tpw.getText());\n-                      double phgt = Double.parseDouble(tph.getText());\n-                      double pimx = Double.parseDouble(tpglm.getText());\n-                      double pimy = Double.parseDouble(tpgtm.getText());\n-                      double pimwid = Double.parseDouble(tpgiw.getText());\n-                      double pimhgt = Double.parseDouble(tpgih.getText());\n-                      p.setSize(pwid, phgt);\n-                      p.setImageableArea(pimx, pimy, pimwid, pimhgt);\n-                      myPageFormat.setPaper(p);\n-                            displayPageFormatAttributes();\n-                  } catch (NumberFormatException nfe) {\n-                  }\n-                }\n-    });\n-    panel.add (setButton);\n-    panel.add (defButton);\n-    panel.add (pageButton);\n-    panel.add (chooseButton);\n-    panel.add (validateButton);\n-    panel.add (printButton);\n-    add(panel);\n-    TextArea ta = new TextArea(7, 60);\n-    String ls = System.getProperty(\"line.Separator\", \"\\n\");\n-    ta.setText(\n-        \"When validating a page, the process is 1st to find the closest matching \" + ls +\n-        \"paper size, next to make sure the requested imageable area fits within \" + ls +\n-        \"the printer's imageable area for that paper size. Finally the top and \" + ls +\n-        \"left margins will be shrunk if they are too great for the adjusted \" + ls +\n-        \"imageable area to fit at that position. They will shrink by the minimum\" + ls +\n-        \"needed to accomodate the imageable area.\"+ls+ls+\n-        \"To test 6229507, put the minimum margins (all 0s) in Page Setup dialog.\"+ls+\n-        \"Compare Imageable width, height, and margins of portrait against landscape.\");\n-    ta.setEditable(false);\n-    add(ta);\n-\n-    addWindowListener (new WindowAdapter() {\n-         public void windowClosing (WindowEvent e) {\n-            dispose();\n-            System.exit (0);\n-         }\n-\n-      });\n-      setSize (500, 630);\n-      setVisible (true);\n-  }\n-\n-  public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) {\n-\n-     if (pageIndex > 0) {\n-        return Printable.NO_SUCH_PAGE;\n-     }\n-\n-     Graphics2D g2d = (Graphics2D)graphics;\n-\n-    int o = pageFormat.getOrientation();\n-\n-     System.out.println(\"Format Orientation = \" +\n-                (o == PageFormat.PORTRAIT ? \"PORTRAIT\" :\n-                 o == PageFormat.LANDSCAPE ? \"LANDSCAPE\" :\n-                 o == PageFormat.REVERSE_LANDSCAPE ? \"REVERSE_LANDSCAPE\" :\n-                 \"<invalid>\"));\n-     System.out.println(g2d.getTransform());\n-     System.out.println(\"ix=\"+pageFormat.getImageableX()+\n-                       \" iy=\"+pageFormat.getImageableY());\n-     g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n-     g2d.drawString(\"ORIGIN\", 20, 20);\n-     g2d.drawString(\"X THIS WAY\", 200, 50);\n-     g2d.drawString(\"Y THIS WAY\", 60 , 200);\n-     g2d.drawRect(0,0,(int)pageFormat.getImageableWidth(),\n-                      (int)pageFormat.getImageableHeight());\n-     g2d.setColor(Color.blue);\n-     g2d.drawRect(1,1,(int)pageFormat.getImageableWidth()-2,\n-                      (int)pageFormat.getImageableHeight()-2);\n-\n-     return  Printable.PAGE_EXISTS;\n-  }\n-\n-  public static void main( String[] args) {\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test is very flexible and requires much interaction.\",\n-         \"There are several buttons.\",\n-         \"Set Paper: if all fields are valid numbers it sets the Paper object.\",\n-         \"This is used to create arbitrary nonsensical paper sizes to help\",\n-         \"test validatePage.\",\n-         \"Default Page: sets a default page. This should always be valid.\",\n-         \"Page Setup: brings up the page dialog. You must OK this dialog\",\n-         \"for it to have any effect. You can use this to set different size,\",\n-         \"orientation and margins - which of course affect imageable area.\",\n-         \"Printer: Used to set the current printer. Useful because current\",\n-         \"printer affects the choice of paper sizes available.\",\n-         \"You must OK this dialog for it to have any effect.\",\n-         \"Validate Page:\",\n-         \"The most important button in the test. By setting nonsensical\",\n-         \"or valid papers with varying margins etc, this should always find\",\n-         \"the closest\",\n-         \"match within the limits of what is possible on the current printer.\",\n-         \"Print: to the current printer. Not vital for this test.\",\n-         \"request.\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-     new ValidatePage();\n-  }\n-\n-}\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    PrinterJob myPrinterJob;\n+    PageFormat myPageFormat;\n+    Label pw, ph, pglm, pgrm, pgiw, pgih, pgtm, pgbm;\n+    TextField tpw, tph, tpglm, tpgtm, tpgiw, tpgih;\n+    Label myWidthLabel;\n+    Label myHeightLabel;\n+    Label myImageableXLabel;\n+    Label myImageableYLabel;\n+    Label myImageableRightLabel;\n+    Label myImageableBottomLabel;\n+    Label myImageableWidthLabel;\n+    Label myImageableHeightLabel;\n+    Label myOrientationLabel;\n+\n+    private static String getOrientation(int o) {\n+        return switch (o) {\n+            case PageFormat.PORTRAIT -> \"PORTRAIT\";\n+            case PageFormat.LANDSCAPE -> \"LANDSCAPE\";\n+            case PageFormat.REVERSE_LANDSCAPE -> \"REVERSE_LANDSCAPE\";\n+            default -> \"<invalid>\";\n+        };\n@@ -326,7 +75,32 @@\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n+    private void displayPageFormatAttributes() {\n+        myWidthLabel.setText(\"Format Width = \" + drnd(myPageFormat.getWidth()));\n+        myHeightLabel.setText(\"Format Height = \" + drnd(myPageFormat.getHeight()));\n+        myImageableXLabel.setText(\"Format Left Margin = \" + drnd(myPageFormat.getImageableX()));\n+        myImageableRightLabel.setText(\"Format Right Margin = \"\n+                + drnd(myPageFormat.getWidth()\n+                        - (myPageFormat.getImageableX() + myPageFormat.getImageableWidth())));\n+        myImageableWidthLabel.setText(\"Format ImageableWidth = \"\n+                + drnd(myPageFormat.getImageableWidth()));\n+        myImageableYLabel.setText(\"Format Top Margin = \"\n+                + drnd(myPageFormat.getImageableY()));\n+        myImageableBottomLabel.setText(\"Format Bottom Margin = \"\n+                + drnd(myPageFormat.getHeight()\n+                        - (myPageFormat.getImageableY() + myPageFormat.getImageableHeight())));\n+        myImageableHeightLabel.setText(\"Format ImageableHeight = \"\n+                + drnd(myPageFormat.getImageableHeight()));\n+        myOrientationLabel.setText(\"Format Orientation = \"\n+                + getOrientation(myPageFormat.getOrientation()));\n+        Paper p = myPageFormat.getPaper();\n+        pw.setText(\"Paper Width = \" + drnd(p.getWidth()));\n+        ph.setText(\"Paper Height = \" + drnd(p.getHeight()));\n+        pglm.setText(\"Paper Left Margin = \" + drnd(p.getImageableX()));\n+        pgiw.setText(\"Paper Imageable Width = \" + drnd(p.getImageableWidth()));\n+        pgih.setText(\"Paper Imageable Height = \" + drnd(p.getImageableHeight()));\n+\n+        pgrm.setText(\"Paper Right Margin = \"\n+                + drnd(p.getWidth()\n+                        - (p.getImageableX() + p.getImageableWidth())));\n+        pgtm.setText(\"Paper Top Margin = \" + drnd(p.getImageableY()));\n+        pgbm.setText(\"Paper Bottom Margin = \"\n+                + drnd(p.getHeight()\n+                        - (p.getImageableY() + p.getImageableHeight())));\n@@ -335,4 +109,2 @@\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n+    static String drnd(double d) {\n+        return String.format(\"%.2f\", d);\n@@ -341,4 +113,126 @@\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n+    public ValidatePage() {\n+        super(\"Validate Page Test\");\n+        myPrinterJob = PrinterJob.getPrinterJob();\n+        myPageFormat = new PageFormat();\n+        Paper p = new Paper();\n+        p.setSize(28 * 72, 21.5 * 72);\n+        myPageFormat.setPaper(p);\n+        setLayout(new FlowLayout());\n+        Panel pfp = new Panel();\n+        pfp.setLayout(new GridLayout(9, 1, 0, 0));\n+        pfp.add(myOrientationLabel = new Label());\n+        pfp.add(myWidthLabel = new Label());\n+        pfp.add(myImageableXLabel = new Label());\n+        pfp.add(myImageableRightLabel = new Label());\n+        pfp.add(myImageableWidthLabel = new Label());\n+        pfp.add(myHeightLabel = new Label());\n+        pfp.add(myImageableYLabel = new Label());\n+        pfp.add(myImageableBottomLabel = new Label());\n+        pfp.add(myImageableHeightLabel = new Label());\n+\n+        add(pfp);\n+\n+        Panel pp = new Panel();\n+        pp.setLayout(new GridLayout(8, 1, 0, 0));\n+        pp.add(pw = new Label());\n+        pp.add(pglm = new Label());\n+        pp.add(pgtm = new Label());\n+        pp.add(ph = new Label());\n+        pp.add(pgiw = new Label());\n+        pp.add(pgih = new Label());\n+        pp.add(pgrm = new Label());\n+        pp.add(pgbm = new Label());\n+\n+        add(pp);\n+\n+        Panel epp = new Panel();\n+        epp.setLayout(new GridLayout(6, 2, 0, 0));\n+\n+        epp.add(new Label(\"Page width:\"));\n+        epp.add(tpw = new TextField());\n+        epp.add(new Label(\"Page height:\"));\n+        epp.add(tph = new TextField());\n+        epp.add(new Label(\"Left Margin:\"));\n+        epp.add(tpglm = new TextField());\n+        epp.add(new Label(\"Top margin:\"));\n+        epp.add(tpgtm = new TextField());\n+        epp.add(new Label(\"Imageable Wid:\"));\n+        epp.add(tpgiw = new TextField());\n+        epp.add(new Label(\"Imageable Hgt:\"));\n+        epp.add(tpgih = new TextField());\n+\n+        add(epp);\n+        displayPageFormatAttributes();\n+\n+        Panel panel = new Panel();\n+        Button defButton = new Button(\"Default Page\");\n+        defButton.addActionListener(e -> {\n+            myPageFormat = myPrinterJob.defaultPage();\n+            displayPageFormatAttributes();\n+        });\n+\n+        Button pageButton = new Button(\"Page Setup...\");\n+        pageButton.addActionListener(e -> {\n+            myPageFormat = myPrinterJob.pageDialog(myPageFormat);\n+            displayPageFormatAttributes();\n+        });\n+        Button printButton = new Button(\"Print\");\n+        printButton.addActionListener(e -> {\n+            try {\n+                myPrinterJob.setPrintable(ValidatePage.this, myPageFormat);\n+                myPrinterJob.print();\n+            } catch (PrinterException pe) {\n+                pe.printStackTrace();\n+                PassFailJFrame.forceFail(\"Test failed because of PrinterException\");\n+            }\n+        });\n+\n+        Button chooseButton = new Button(\"Printer...\");\n+        chooseButton.addActionListener(e -> myPrinterJob.printDialog());\n+\n+        Button validateButton = new Button(\"Validate Page\");\n+        validateButton.addActionListener(e -> {\n+            myPageFormat = myPrinterJob.validatePage(myPageFormat);\n+            displayPageFormatAttributes();\n+        });\n+        Button setButton = new Button(\"Set Paper\");\n+        setButton.addActionListener(e -> {\n+            try {\n+                Paper p1 = new Paper();\n+                double pwid = Double.parseDouble(tpw.getText());\n+                double phgt = Double.parseDouble(tph.getText());\n+                double pimx = Double.parseDouble(tpglm.getText());\n+                double pimy = Double.parseDouble(tpgtm.getText());\n+                double pimwid = Double.parseDouble(tpgiw.getText());\n+                double pimhgt = Double.parseDouble(tpgih.getText());\n+                p1.setSize(pwid, phgt);\n+                p1.setImageableArea(pimx, pimy, pimwid, pimhgt);\n+                myPageFormat.setPaper(p1);\n+                displayPageFormatAttributes();\n+            } catch (NumberFormatException nfe) {\n+                JOptionPane.showMessageDialog(ValidatePage.this,\n+                        \"NumberFormatException occurred\", \"Error\",\n+                        JOptionPane.ERROR_MESSAGE);\n+            }\n+        });\n+        panel.add(setButton);\n+        panel.add(defButton);\n+        panel.add(pageButton);\n+        panel.add(chooseButton);\n+        panel.add(validateButton);\n+        panel.add(printButton);\n+        add(panel);\n+        TextArea ta = new TextArea(10, 45);\n+        ta.setText(\n+                \"When validating a page, the process is 1st to find the closest matching \\n\" +\n+                \"paper size, next to make sure the requested imageable area fits within \\n\" +\n+                \"the printer's imageable area for that paper size. Finally the top and \\n\" +\n+                \"left margins will be shrunk if they are too great for the adjusted \\n\" +\n+                \"imageable area to fit at that position. They will shrink by the minimum\\n\" +\n+                \"needed to accommodate the imageable area.\\n \\n \\n\" +\n+                \"To test 6229507, put the minimum margins (all 0s) in Page Setup dialog.\\n\" +\n+                \"Compare Imageable width, height, and margins of portrait against landscape.\");\n+\n+        ta.setEditable(false);\n+        add(ta);\n+        setSize(700, 500);\n@@ -347,78 +241,27 @@\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n+    @Override\n+    public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) {\n+        if (pageIndex > 0) {\n+            return Printable.NO_SUCH_PAGE;\n+        }\n+\n+        System.out.println(\"Format Orientation = \"\n+                + getOrientation(pageFormat.getOrientation()));\n+\n+        Graphics2D g2d = (Graphics2D) graphics;\n+\n+        System.out.println(g2d.getTransform());\n+        System.out.println(\"ix=\" + pageFormat.getImageableX() +\n+                           \" iy=\" + pageFormat.getImageableY());\n+        g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n+        g2d.drawString(\"ORIGIN\", 20, 20);\n+        g2d.drawString(\"X THIS WAY\", 200, 50);\n+        g2d.drawString(\"Y THIS WAY\", 60, 200);\n+        g2d.drawRect(0, 0,\n+                    (int) pageFormat.getImageableWidth(),\n+                    (int) pageFormat.getImageableHeight());\n+        g2d.setColor(Color.blue);\n+        g2d.drawRect(1, 1,\n+                    (int) pageFormat.getImageableWidth() - 2,\n+                    (int) pageFormat.getImageableHeight() - 2);\n+\n+        return Printable.PAGE_EXISTS;\n@@ -427,1 +270,34 @@\n- }\/\/ TestDialog  class\n+    private static final String INSTRUCTIONS =\n+            \"This test is very flexible and requires much interaction.\\n\" +\n+            \"There are several buttons.\\n\\n\" +\n+            \"Set Paper: if all fields are valid numbers it sets the Paper object.\\n\" +\n+            \"This is used to create arbitrary nonsensical paper sizes to help\\n\" +\n+            \"test validatePage.\\n\\n\" +\n+            \"Default Page: sets a default page. This should always be valid.\\n\\n\" +\n+            \"Page Setup: brings up the page dialog. You must OK this dialog\\n\" +\n+            \"for it to have any effect. You can use this to set different size,\\n\" +\n+            \"orientation and margins - which of course affect imageable area.\\n\\n\" +\n+            \"Printer: Used to set the current printer. Useful because current\\n\" +\n+            \"printer affects the choice of paper sizes available.\\n\" +\n+            \"You must OK this dialog for it to have any effect.\\n\\n\" +\n+            \"Validate Page:The most important button in the test.\\n\" +\n+            \"By setting nonsensical or valid papers with varying margins etc,\\n\" +\n+            \"this should always find the closest match within the limits of\\n\" +\n+            \"what is possible on the current printer.\\n\\n\" +\n+            \"Print: to the current printer. Not vital for this test request.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testTimeOut(10)\n+                .testUI(ValidatePage::new)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/ValidatePage\/ValidatePage.java","additions":264,"deletions":388,"binary":false,"changes":652,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,17 @@\n-\/**\n+import java.awt.Button;\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.GradientPaint;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.image.BufferedImage;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+\n+\/*\n@@ -29,0 +45,2 @@\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -31,8 +49,0 @@\n-import java.awt.*;\n-import java.awt.geom.*;\n-import java.awt.event.*;\n-import java.awt.print.*;\n-import java.awt.Toolkit;\n-import java.awt.image.BufferedImage;\n-\n-\n@@ -40,0 +50,23 @@\n+    private final RasterCanvas c;\n+    private static final String INSTRUCTIONS =\n+            \"This test uses rendering operations which force the implementation\\n\" +\n+            \"to print the page as a raster\\n\" +\n+            \"You should see two square images, the 1st containing overlapping\\n\" +\n+            \"composited squares, the lower image shows a gradient paint.\\n\" +\n+            \"The printed output should match the on-screen display, although\\n\" +\n+            \"only colour printers will be able to accurately reproduce the\\n\" +\n+            \"subtle color changes.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (PrinterJob.lookupPrintServices().length == 0) {\n+            throw new RuntimeException(\"Printer not configured or available.\");\n+        }\n+\n+        PassFailJFrame.builder()\n+                .instructions(INSTRUCTIONS)\n+                .testUI(RasterTest::new)\n+                .rows((int) INSTRUCTIONS.lines().count() + 1)\n+                .columns(45)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -41,22 +74,1 @@\n- private RasterCanvas c;\n-\n- public static void main(String args[]) {\n-  String[] instructions =\n-        {\n-         \"You must have a printer available to perform this test\",\n-         \"This test uses rendering operations which force the implementation\",\n-         \"to print the page as a raster\",\n-         \"You should see two square images, the 1st containing overlapping\",\n-         \"composited squares, the lower image shows a gradient paint.\",\n-         \"The printed output should match the on-screen display, although\",\n-         \"only colour printers will be able to accurately reproduce the\",\n-         \"subtle color changes.\"\n-       };\n-      Sysout.createDialog( );\n-      Sysout.printInstructions( instructions );\n-\n-    RasterTest f = new RasterTest();\n-    f.show();\n- }\n-\n- public RasterTest() {\n+    public RasterTest() {\n@@ -65,14 +77,2 @@\n-    c = new RasterCanvas();\n-    add(\"Center\", c);\n-\n-    Button printButton = new Button(\"Print\");\n-    printButton.addActionListener(this);\n-    add(\"South\", printButton);\n-\n-    addWindowListener(new WindowAdapter() {\n-       public void windowClosing(WindowEvent e) {\n-             System.exit(0);\n-            }\n-    });\n-\n-    pack();\n+        c = new RasterCanvas();\n+        add(\"Center\", c);\n@@ -80,0 +80,4 @@\n+        Button printButton = new Button(\"Print\");\n+        printButton.addActionListener(this);\n+        add(\"South\", printButton);\n+        pack();\n@@ -81,30 +85,0 @@\n-\n- }\n-\n- public void actionPerformed(ActionEvent e) {\n-\n-   PrinterJob pj = PrinterJob.getPrinterJob();\n-\n-   if (pj != null && pj.printDialog()) {\n-       pj.setPrintable(c);\n-       try {\n-            pj.print();\n-      } catch (PrinterException pe) {\n-      } finally {\n-         System.err.println(\"PRINT RETURNED\");\n-      }\n-   }\n-}\n-\n-\n- class RasterCanvas extends Canvas implements Printable {\n-\n-\n-    public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n-      if (pgIndex > 0)\n-         return Printable.NO_SUCH_PAGE;\n-\n-         Graphics2D g2d= (Graphics2D)g;\n-         g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n-         doPaint(g2d);\n-      return Printable.PAGE_EXISTS;\n@@ -113,3 +87,2 @@\n-    public void paint(Graphics g) {\n-       doPaint(g);\n-    }\n+    public void actionPerformed(ActionEvent e) {\n+        PrinterJob pj = PrinterJob.getPrinterJob();\n@@ -117,2 +90,9 @@\n-    public void paintComponent(Graphics g) {\n-       doPaint(g);\n+        if (pj.printDialog()) {\n+            pj.setPrintable(c);\n+            try {\n+                pj.print();\n+            } catch (PrinterException pe) {\n+                pe.printStackTrace();\n+                PassFailJFrame.forceFail(\"Test failed because of PrinterException\");\n+            }\n+        }\n@@ -121,25 +101,6 @@\n-    public void doPaint(Graphics g) {\n-        Graphics2D g2 = (Graphics2D)g;\n-\n-        g2.setColor(Color.black);\n-\n-        BufferedImage bimg = new BufferedImage(200, 200,\n-                                                 BufferedImage.TYPE_INT_ARGB);\n-        Graphics ig = bimg.getGraphics();\n-        Color alphared = new Color(255, 0, 0, 128);\n-        Color alphagreen = new Color(0, 255, 0, 128);\n-        Color alphablue = new Color(0, 0, 255, 128);\n-        ig.setColor(alphared);\n-        ig.fillRect(0,0,200,200);\n-        ig.setColor(alphagreen);\n-        ig.fillRect(25,25,150,150);\n-        ig.setColor(alphablue);\n-        ig.fillRect(75,75,125,125);\n-        g.drawImage(bimg, 10, 25, this);\n-\n-        GradientPaint gp =\n-         new GradientPaint(10.0f, 10.0f, alphablue, 210.0f, 210.0f, alphared, true);\n-        g2.setPaint(gp);\n-        g2.fillRect(10, 240, 200, 200);\n-\n-     }\n+    private static class RasterCanvas extends Canvas implements Printable {\n+        @Override\n+        public int print(Graphics g, PageFormat pgFmt, int pgIndex) {\n+            if (pgIndex > 0) {\n+                return Printable.NO_SUCH_PAGE;\n+            }\n@@ -147,2 +108,40 @@\n-    public Dimension getPreferredSize() {\n-        return new Dimension(500, 500);\n+            Graphics2D g2d = (Graphics2D) g;\n+            g2d.translate(pgFmt.getImageableX(), pgFmt.getImageableY());\n+            doPaint(g2d);\n+\n+            return Printable.PAGE_EXISTS;\n+        }\n+\n+        @Override\n+        public void paint(Graphics g) {\n+            doPaint(g);\n+        }\n+\n+        private void doPaint(Graphics g) {\n+            BufferedImage bimg = new BufferedImage(200, 200,\n+                    BufferedImage.TYPE_INT_ARGB);\n+            Graphics ig = bimg.getGraphics();\n+            Color alphared = new Color(255, 0, 0, 128);\n+            Color alphagreen = new Color(0, 255, 0, 128);\n+            Color alphablue = new Color(0, 0, 255, 128);\n+            ig.setColor(alphared);\n+            ig.fillRect(0, 0, 200, 200);\n+            ig.setColor(alphagreen);\n+            ig.fillRect(25, 25, 150, 150);\n+            ig.setColor(alphablue);\n+            ig.fillRect(75, 75, 125, 125);\n+            g.drawImage(bimg, 10, 25, this);\n+            ig.dispose();\n+\n+            GradientPaint gp =\n+                    new GradientPaint(10.0f, 10.0f, alphablue, 210.0f, 210.0f, alphared, true);\n+\n+            Graphics2D g2 = (Graphics2D) g;\n+            g2.setPaint(gp);\n+            g2.fillRect(10, 240, 200, 200);\n+        }\n+\n+        @Override\n+        public Dimension getPreferredSize() {\n+            return new Dimension(500, 500);\n+        }\n@@ -150,3 +149,0 @@\n-\n- }\n-\n@@ -154,115 +150,0 @@\n-\n-\n-class Sysout {\n-   private static TestDialog dialog;\n-\n-   public static void createDialogWithInstructions( String[] instructions )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      dialog.printInstructions( instructions );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-   public static void createDialog( )\n-    {\n-      dialog = new TestDialog( new Frame(), \"Instructions\" );\n-      String[] defInstr = { \"Instructions will appear here. \", \"\" } ;\n-      dialog.printInstructions( defInstr );\n-      dialog.show();\n-      println( \"Any messages for the tester will display here.\" );\n-    }\n-\n-\n-   public static void printInstructions( String[] instructions )\n-    {\n-      dialog.printInstructions( instructions );\n-    }\n-\n-\n-   public static void println( String messageIn )\n-    {\n-      dialog.displayMessage( messageIn );\n-    }\n-\n-}\/\/ Sysout  class\n-\n-\/**\n-  This is part of the standard test machinery.  It provides a place for the\n-   test instructions to be displayed, and a place for interactive messages\n-   to the user to be displayed.\n-  To have the test instructions displayed, see Sysout.\n-  To have a message to the user be displayed, see Sysout.\n-  Do not call anything in this dialog directly.\n-  *\/\n-class TestDialog extends Dialog {\n-\n-   TextArea instructionsText;\n-   TextArea messageText;\n-   int maxStringLength = 80;\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public TestDialog( Frame frame, String name )\n-    {\n-      super( frame, name );\n-      int scrollBoth = TextArea.SCROLLBARS_BOTH;\n-      instructionsText = new TextArea( \"\", 15, maxStringLength, scrollBoth );\n-      add( \"North\", instructionsText );\n-\n-      messageText = new TextArea( \"\", 5, maxStringLength, scrollBoth );\n-      add(\"Center\", messageText);\n-\n-      pack();\n-\n-      show();\n-    }\/\/ TestDialog()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void printInstructions( String[] instructions )\n-    {\n-      \/\/Clear out any current instructions\n-      instructionsText.setText( \"\" );\n-\n-      \/\/Go down array of instruction strings\n-\n-      String printStr, remainingStr;\n-      for( int i=0; i < instructions.length; i++ )\n-       {\n-         \/\/chop up each into pieces maxSringLength long\n-         remainingStr = instructions[ i ];\n-         while( remainingStr.length() > 0 )\n-          {\n-            \/\/if longer than max then chop off first max chars to print\n-            if( remainingStr.length() >= maxStringLength )\n-             {\n-               \/\/Try to chop on a word boundary\n-               int posOfSpace = remainingStr.\n-                  lastIndexOf( ' ', maxStringLength - 1 );\n-\n-               if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;\n-\n-               printStr = remainingStr.substring( 0, posOfSpace + 1 );\n-               remainingStr = remainingStr.substring( posOfSpace + 1 );\n-             }\n-            \/\/else just print\n-            else\n-             {\n-               printStr = remainingStr;\n-               remainingStr = \"\";\n-             }\n-\n-            instructionsText.append( printStr + \"\\n\" );\n-\n-          }\/\/ while\n-\n-       }\/\/ for\n-\n-    }\/\/printInstructions()\n-\n-   \/\/DO NOT call this directly, go through Sysout\n-   public void displayMessage( String messageIn )\n-    {\n-      messageText.append( messageIn + \"\\n\" );\n-    }\n-\n- }\/\/ TestDialog  class\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/raster\/RasterTest.java","additions":107,"deletions":226,"binary":false,"changes":333,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -365,1 +365,1 @@\n-        File tmpFile = File.createTempFile(CHECK_PERMISSION_TEST, null);\n+        File tmpFile = File.createTempFile(CHECK_PERMISSION_TEST, null, new File(\".\"));\n@@ -371,1 +371,1 @@\n-        tmpFile = File.createTempFile(CHECK_PERMISSION_TEST, null, null);\n+        tmpFile = File.createTempFile(CHECK_PERMISSION_TEST, null, new File(\".\"));\n","filename":"test\/jdk\/java\/io\/File\/CheckPermission.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,4 +49,6 @@\n-        try (BufferedWriter writer =\n-            Files.newBufferedWriter(tmp, Charset.defaultCharset())) {\n-            for (int i = 0; i < SIZE; i++) {\n-                writer.write('1');\n+        try {\n+            try (BufferedWriter writer =\n+                         Files.newBufferedWriter(tmp, Charset.defaultCharset())) {\n+                for (int i = 0; i < SIZE; i++) {\n+                    writer.write('1');\n+                }\n@@ -54,1 +56,0 @@\n-        }\n@@ -56,5 +57,13 @@\n-        File tempFile = tmp.toFile();\n-        try (FileInputStream fis = new FileInputStream(tempFile)) {\n-            if (tempFile.length() != SIZE) {\n-                throw new RuntimeException(\"unexpected file size = \"\n-                                           + tempFile.length());\n+            File tempFile = tmp.toFile();\n+            try (FileInputStream fis = new FileInputStream(tempFile)) {\n+                if (tempFile.length() != SIZE) {\n+                    throw new RuntimeException(\"unexpected file size = \"\n+                            + tempFile.length());\n+                }\n+                long space = skipBytes(fis, SKIP, SIZE);\n+                space = skipBytes(fis, NEGATIVE_SKIP, space);\n+                space = skipBytes(fis, SKIP, space);\n+                space = skipBytes(fis, SKIP, space);\n+                space = skipBytes(fis, SKIP, space);\n+                space = skipBytes(fis, NEGATIVE_SKIP, space);\n+                space = skipBytes(fis, NEGATIVE_SKIP, space);\n@@ -62,7 +71,2 @@\n-            long space = skipBytes(fis, SKIP, SIZE);\n-            space = skipBytes(fis, NEGATIVE_SKIP, space);\n-            space = skipBytes(fis, SKIP, space);\n-            space = skipBytes(fis, SKIP, space);\n-            space = skipBytes(fis, SKIP, space);\n-            space = skipBytes(fis, NEGATIVE_SKIP, space);\n-            space = skipBytes(fis, NEGATIVE_SKIP, space);\n+        } finally {\n+            Files.deleteIfExists(tmp);\n@@ -70,1 +74,0 @@\n-        Files.deleteIfExists(tmp);\n","filename":"test\/jdk\/java\/io\/FileInputStream\/NegativeAvailable.java","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -196,0 +196,1 @@\n+        \"\\uD835\\uDFD9e\\uD835\\uDFD9\", \/\/ 1e1 in Mathematical Alphanumeric Symbols\n","filename":"test\/jdk\/java\/lang\/Double\/ParseDouble.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -204,1 +204,2 @@\n-        \"\\u0967e\\u0967\" \/\/ 1e1 in Devanagari digits\n+        \"\\u0967e\\u0967\", \/\/ 1e1 in Devanagari digits\n+        \"\\uD835\\uDFD9e\\uD835\\uDFD9\" \/\/ 1e1 in Mathematical Alphanumeric Symbols\n","filename":"test\/jdk\/java\/lang\/Float\/ParseFloat.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8315575\n+ * @bug 8315575 8328137\n@@ -32,0 +32,1 @@\n+ * @run main\/othervm -javaagent:retransformAgent.jar -XX:+PreserveAllAnnotations -Xlog:redefine+class=trace RetransformRecordAnnotation\n","filename":"test\/jdk\/java\/lang\/instrument\/RetransformRecordAnnotation.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,2 +162,1 @@\n-            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n-            UnixDomainSocketAddress usa =  UnixDomainSocketAddress.of(\"with space\"); \/\/ relative to CWD\n+            UnixDomainSocketAddress usa = UnixDomainSocketAddress.of(\"with space\");\n@@ -165,4 +164,9 @@\n-            server.bind(usa);\n-            client = SocketChannel.open(usa);\n-            Files.delete(usa.getPath());\n-            assertAddress(client.getRemoteAddress(), usa, \"address\");\n+            try {\n+                server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                \/\/ relative to CWD\n+                server.bind(usa);\n+                client = SocketChannel.open(usa);\n+                assertAddress(client.getRemoteAddress(), usa, \"address\");\n+            } finally {\n+                Files.deleteIfExists(usa.getPath());\n+            }\n@@ -188,6 +192,13 @@\n-            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n-            server.bind(null);\n-            UnixDomainSocketAddress usa = (UnixDomainSocketAddress)server.getLocalAddress();\n-            if (usa.getPath().toString().isEmpty())\n-                throw new RuntimeException(\"expected non zero address length\");\n-            System.out.println(\"Null server address: \" + server.getLocalAddress());\n+            UnixDomainSocketAddress usa = null;\n+            try {\n+                server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                server.bind(null);\n+                usa = (UnixDomainSocketAddress) server.getLocalAddress();\n+                if (usa.getPath().toString().isEmpty())\n+                    throw new RuntimeException(\"expected non zero address length\");\n+                System.out.println(\"Null server address: \" + server.getLocalAddress());\n+            } finally {\n+                if (usa != null) {\n+                    Files.deleteIfExists(usa.getPath());\n+                }\n+            }\n@@ -310,6 +321,9 @@\n-            ServerSocketChannel server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n-            server.bind(address);\n-            SocketChannel client = SocketChannel.open(address);\n-            assertAddress(server.getLocalAddress(), address, \"server\");\n-            assertAddress(client.getRemoteAddress(), address, \"client\");\n-            Files.delete(address.getPath());\n+            try {\n+                ServerSocketChannel server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                server.bind(address);\n+                SocketChannel client = SocketChannel.open(address);\n+                assertAddress(server.getLocalAddress(), address, \"server\");\n+                assertAddress(client.getRemoteAddress(), address, \"client\");\n+            } finally {\n+                Files.deleteIfExists(address.getPath());\n+            }\n@@ -320,7 +334,13 @@\n-            server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n-            server.bind(null);\n-            UnixDomainSocketAddress usa = (UnixDomainSocketAddress)server.getLocalAddress();\n-            client = SocketChannel.open(usa);\n-            accept1 = server.accept();\n-            assertAddress(client.getRemoteAddress(), usa, \"server\");\n-            Files.delete(usa.getPath());\n+            UnixDomainSocketAddress usa = null;\n+            try {\n+                server = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+                server.bind(null);\n+                usa = (UnixDomainSocketAddress) server.getLocalAddress();\n+                client = SocketChannel.open(usa);\n+                accept1 = server.accept();\n+                assertAddress(client.getRemoteAddress(), usa, \"server\");\n+            } finally {\n+                if (usa != null) {\n+                    Files.deleteIfExists(usa.getPath());\n+                }\n+            }\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/Bind.java","additions":46,"deletions":26,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.net.UnixDomainSocketAddress;\n@@ -34,0 +35,2 @@\n+import java.nio.file.Files;\n+\n@@ -51,0 +54,1 @@\n+        UnixDomainSocketAddress addr = null;\n@@ -57,0 +61,1 @@\n+            addr = (UnixDomainSocketAddress) serverSocketChannel.getLocalAddress();\n@@ -62,0 +67,4 @@\n+        } finally {\n+            if (addr != null) {\n+                Files.deleteIfExists(addr.getPath());\n+            }\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/NonBlockingAccept.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.nio.file.FileStore;\n@@ -71,0 +72,2 @@\n+    private static final String TMP_DIR =\n+        System.getProperty(\"copymove.tmp.dir\", \".\");\n@@ -73,1 +76,1 @@\n-        Path currentDir = null;\n+        Path tempFile = null;\n@@ -75,1 +78,1 @@\n-            currentDir = Files.createTempFile(Path.of(\".\"), \"this\", \"that\");\n+            tempFile = Files.createTempFile(Path.of(TMP_DIR), \"this\", \"that\");\n@@ -77,1 +80,1 @@\n-                Files.getFileStore(currentDir).supportsFileAttributeView(\"posix\");\n+                Files.getFileStore(tempFile).supportsFileAttributeView(\"posix\");\n@@ -81,1 +84,1 @@\n-            if (currentDir != null) {\n+            if (tempFile != null) {\n@@ -83,1 +86,1 @@\n-                    Files.delete(currentDir);\n+                    Files.delete(tempFile);\n@@ -94,0 +97,7 @@\n+    private static boolean isSameFileStore(Path p1, Path p2)\n+        throws IOException {\n+        FileStore fs1 = p1.getFileSystem().provider().getFileStore(p1);\n+        FileStore fs2 = p2.getFileSystem().provider().getFileStore(p2);\n+        return fs1.equals(fs2);\n+    }\n+\n@@ -145,1 +155,1 @@\n-        Path currentDir = Path.of(\".\");\n+        Path tmpDir = Path.of(TMP_DIR);\n@@ -149,1 +159,1 @@\n-                    source = Files.createTempFile(currentDir, \"file\", \"dat\");\n+                    source = Files.createTempFile(tmpDir, \"file\", \"dat\");\n@@ -151,1 +161,1 @@\n-                    source = Files.createTempDirectory(currentDir, \"dir\");\n+                    source = Files.createTempDirectory(tmpDir, \"dir\");\n@@ -153,1 +163,1 @@\n-                    linkTarget = Files.createTempFile(currentDir, \"link\", \"target\");\n+                    linkTarget = Files.createTempFile(tmpDir, \"link\", \"target\");\n@@ -167,1 +177,1 @@\n-                target = Files.createTempFile(currentDir, \"file\", \"target\");\n+                target = Files.createTempFile(tmpDir, \"file\", \"target\");\n@@ -196,1 +206,5 @@\n-                    Files.move(source, target, options);\n+                    try {\n+                        Files.move(source, target, options);\n+                    } catch (AccessDeniedException ade) {\n+                        assertTrue(mode.charAt(0) != 'r');\n+                    }\n@@ -216,1 +230,14 @@\n-                        assertTrue(mode.charAt(1) != 'w');\n+                        Path other = target.getParent();\n+                        if (other == null)\n+                            other = Path.of(System.getProperty(\"user.dir\"));\n+                        if (isSameFileStore(source, other)) {\n+                            \/\/ directories on same store should be renamed\n+                            assertTrue(mode.charAt(1) != 'w');\n+                        } else {\n+                            \/\/ directories on different stores will likely be\n+                            \/\/ moved by a copy which requires read permission\n+                            if (mode.charAt(1) == 'w')\n+                                assertTrue(mode.charAt(0) != 'r');\n+                            else\n+                                assertTrue(mode.charAt(1) != 'w');\n+                        }\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyMoveVariations.java","additions":39,"deletions":12,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @run main\/othervm -Dcom.sun.security.ocsp.useget=foo GetAndPostTests\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/OCSP\/GetAndPostTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -705,0 +705,3 @@\n+        private final boolean USE_GET =\n+            !System.getProperty(\"com.sun.security.ocsp.useget\", \"\").equals(\"false\");\n+\n@@ -877,0 +880,6 @@\n+                if (USE_GET && length <= 255) {\n+                    \/\/ Received a small POST request. Check that our client code properly\n+                    \/\/ handled the relevant flag. We expect small GET requests, unless\n+                    \/\/ explicitly disabled.\n+                    throw new IOException(\"Should have received small GET, not POST.\");\n+                }\n","filename":"test\/jdk\/java\/security\/testlibrary\/SimpleOCSPServer.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8318761\n+ * @bug 8318761 8329118\n@@ -43,0 +43,2 @@\n+\/\/ This test expects an US locale, as this locale provides distinct instances\n+\/\/ for different styles.\n@@ -49,1 +51,1 @@\n-                \"{0,number,compact_short}{1,number,compact_long}\");\n+                \"{0,number,compact_short}{1,number,compact_long}\", Locale.US);\n@@ -65,2 +67,3 @@\n-        assertEquals(new DecimalFormat(\"compact_regular\"),\n-                new MessageFormat(\"{0,number,compact_regular}\").getFormatsByArgumentIndex()[0]);\n+        DecimalFormatSymbols symbols = new DecimalFormatSymbols(Locale.US);\n+        assertEquals(new DecimalFormat(\"compact_regular\", symbols),\n+                new MessageFormat(\"{0,number,compact_regular}\", Locale.US).getFormatsByArgumentIndex()[0]);\n@@ -72,1 +75,1 @@\n-        var mFmt = new MessageFormat(\"{0}{1}\");\n+        var mFmt = new MessageFormat(\"{0}{1}\", Locale.US);\n@@ -83,1 +86,1 @@\n-        var mFmt = new MessageFormat(\"{0}\");\n+        var mFmt = new MessageFormat(\"{0}\", Locale.US);\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/CompactSubFormats.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8318761\n+ * @bug 8318761 8329118\n@@ -36,0 +36,1 @@\n+import java.util.Locale;\n@@ -42,0 +43,2 @@\n+\/\/ This test expects an US locale, as this locale provides distinct instances\n+\/\/ for different styles.\n@@ -48,1 +51,1 @@\n-        var mFmt = new MessageFormat(\"{0,list}{1,list,or}{2,list,unit}\");\n+        var mFmt = new MessageFormat(\"{0,list}{1,list,or}{2,list,unit}\", Locale.US);\n@@ -66,1 +69,1 @@\n-                new MessageFormat(\"{0,list,standard}\"));\n+                new MessageFormat(\"{0,list,standard}\", Locale.US));\n@@ -71,1 +74,1 @@\n-                new MessageFormat(\"{0,listt,or}\"));\n+                new MessageFormat(\"{0,listt,or}\", Locale.US));\n@@ -80,1 +83,1 @@\n-        var mFmt = new MessageFormat(\"{0}{1}{2}\");\n+        var mFmt = new MessageFormat(\"{0}{1}{2}\", Locale.US);\n@@ -93,1 +96,1 @@\n-        var mFmt = new MessageFormat(\"{0}\");\n+        var mFmt = new MessageFormat(\"{0}\", Locale.US);\n@@ -95,1 +98,2 @@\n-                ListFormat.getInstance(mFmt.getLocale(), ListFormat.Type.UNIT, ListFormat.Style.NARROW));\n+                ListFormat.getInstance(mFmt.getLocale(),\n+                        ListFormat.Type.UNIT, ListFormat.Style.NARROW));\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/ListSubFormats.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -48,0 +50,1 @@\n+ * @library \/test\/lib\n@@ -53,13 +56,13 @@\n-        Path path = Files.createTempFile(\"bad\", \".zip\");\n-        try (OutputStream os = Files.newOutputStream(path);\n-                ZipOutputStream zos = new ZipOutputStream(os)) {\n-            ZipEntry e = new ZipEntry(\"x\");\n-            zos.putNextEntry(e);\n-            zos.write((int) 'x');\n-        }\n-        int len = (int) Files.size(path);\n-        byte[] data = new byte[len];\n-        try (InputStream is = Files.newInputStream(path)) {\n-            is.read(data);\n-        }\n-        Files.delete(path);\n+        Path path = Utils.createTempFile(\"bad\", \".zip\");\n+        try {\n+            try (OutputStream os = Files.newOutputStream(path);\n+                 ZipOutputStream zos = new ZipOutputStream(os)) {\n+                ZipEntry e = new ZipEntry(\"x\");\n+                zos.putNextEntry(e);\n+                zos.write((int) 'x');\n+            }\n+            int len = (int) Files.size(path);\n+            byte[] data = new byte[len];\n+            try (InputStream is = Files.newInputStream(path)) {\n+                is.read(data);\n+            }\n@@ -67,11 +70,14 @@\n-        \/\/ year, month, day are zero\n-        testDate(data.clone(), 0, LocalDate.of(1979, 11, 30).atStartOfDay());\n-        \/\/ only year is zero\n-        testDate(data.clone(), 0 << 25 | 4 << 21 | 5 << 16, LocalDate.of(1980, 4, 5).atStartOfDay());\n-        \/\/ month is greater than 12\n-        testDate(data.clone(), 0 << 25 | 13 << 21 | 1 << 16, LocalDate.of(1981, 1, 1).atStartOfDay());\n-        \/\/ 30th of February\n-        testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16, LocalDate.of(1980, 3, 1).atStartOfDay());\n-        \/\/ 30th of February, 24:60:60\n-        testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16 | 24 << 11 | 60 << 5 | 60 >> 1,\n-                LocalDateTime.of(1980, 3, 2, 1, 1, 0));\n+            \/\/ year, month, day are zero\n+            testDate(data.clone(), 0, LocalDate.of(1979, 11, 30).atStartOfDay());\n+            \/\/ only year is zero\n+            testDate(data.clone(), 0 << 25 | 4 << 21 | 5 << 16, LocalDate.of(1980, 4, 5).atStartOfDay());\n+            \/\/ month is greater than 12\n+            testDate(data.clone(), 0 << 25 | 13 << 21 | 1 << 16, LocalDate.of(1981, 1, 1).atStartOfDay());\n+            \/\/ 30th of February\n+            testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16, LocalDate.of(1980, 3, 1).atStartOfDay());\n+            \/\/ 30th of February, 24:60:60\n+            testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16 | 24 << 11 | 60 << 5 | 60 >> 1,\n+                    LocalDateTime.of(1980, 3, 2, 1, 1, 0));\n+        } finally {\n+            Files.delete(path);\n+        }\n@@ -89,1 +95,1 @@\n-        Path path = Files.createTempFile(\"out\", \".zip\");\n+        Path path = Utils.createTempFile(\"out\", \".zip\");\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ZeroDate.java","additions":32,"deletions":26,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,1 +174,1 @@\n-                    \/\/ Error: Exception thrown by the agent : java.rmi.server.ExportException: Port already in use: 46481; nested exception is:\n+                    \/\/ Error: Exception thrown by the agent: java.rmi.server.ExportException: Port already in use: 46481; nested exception is:\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/connection\/DefaultAgentFilterTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,31 +0,0 @@\n-<!--\n- Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n- DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n- This code is free software; you can redistribute it and\/or modify it\n- under the terms of the GNU General Public License version 2 only, as\n- published by the Free Software Foundation.\n-\n- This code is distributed in the hope that it will be useful, but WITHOUT\n- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- version 2 for more details (a copy is included in the LICENSE file that\n- accompanied this code).\n-\n- You should have received a copy of the GNU General Public License version\n- 2 along with this work; if not, write to the Free Software Foundation,\n- Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n- Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- or visit www.oracle.com if you need additional information or have any\n- questions.\n--->\n-\n-<html>\n-<body>\n-If you don't see the preview panel, then test failed, otherwise it passed.\n-\n-<applet width=\"500\" height=\"400\" code=\"Test6977726.class\">\n-<\/applet>\n-<\/body>\n-<\/html>\n","filename":"test\/jdk\/javax\/swing\/JColorChooser\/Test6977726.html","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,4 @@\n+import java.awt.Color;\n+import javax.swing.JColorChooser;\n+import javax.swing.JLabel;\n+\n@@ -27,3 +31,5 @@\n- * @summary Checks if JColorChooser.setPreviewPanel removes the old one\n- * @author Sergey Malenkov\n- * @run applet\/manual=yesno Test6977726.html\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @summary Checks if JColorChooser.setPreviewPanel(JLabel) doesn't remove the preview panel but\n+ *          removes the content of the default preview panel\n+ * @run main\/manual Test6977726\n@@ -32,3 +38,18 @@\n-import javax.swing.JApplet;\n-import javax.swing.JColorChooser;\n-import javax.swing.JLabel;\n+public class Test6977726 {\n+\n+    public static void main(String[] args) throws Exception {\n+        String instructions = \"\"\"\n+                Check that there is a panel with \"Text Preview Panel\" text\n+                and with title \"Preview\" in the JColorChooser.\n+                Test passes if the panel is as described, test fails otherwise.\"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test6977726\")\n+                .instructions(instructions)\n+                .rows(5)\n+                .columns(40)\n+                .testTimeOut(2)\n+                .testUI(Test6977726::createColorChooser)\n+                .build()\n+                .awaitAndCheck();\n+    }\n@@ -36,3 +57,2 @@\n-public class Test6977726 extends JApplet {\n-    public void init() {\n-        JColorChooser chooser = new JColorChooser();\n+    private static JColorChooser createColorChooser() {\n+        JColorChooser chooser = new JColorChooser(Color.BLUE);\n@@ -40,1 +60,1 @@\n-        getContentPane().add(chooser);\n+        return chooser;\n","filename":"test\/jdk\/javax\/swing\/JColorChooser\/Test6977726.java","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+\n+import javax.swing.JEditorPane;\n+import javax.swing.text.BadLocationException;\n+import javax.swing.text.Document;\n+import javax.swing.text.Element;\n+\n+\/*\n+ * @test\n+ * @bug 8328953\n+ * @summary Verifies JEditorPane.read doesn't throw ChangedCharSetException\n+            but handles it and reads HTML in the specified encoding\n+ * @run main EditorPaneCharset\n+ *\/\n+\n+public final class EditorPaneCharset {\n+    private static final String CYRILLIC_TEXT =\n+            \"\\u041F\\u0440\\u0438\\u0432\\u0435\\u0442, \\u043C\\u0438\\u0440!\";\n+    private static final String HTML_CYRILLIC =\n+            \"<html lang=\\\"ru\\\">\\n\" +\n+            \"<head>\\n\" +\n+            \"    <meta http-equiv=\\\"Content-Type\\\" \" +\n+            \"          content=\\\"text\/html; charset=windows-1251\\\">\\n\" +\n+            \"<\/head><body>\\n\" +\n+            \"<p>\" + CYRILLIC_TEXT + \"<\/p>\\n\" +\n+            \"<\/body><\/html>\\n\";\n+\n+    public static void main(String[] args) throws IOException, BadLocationException {\n+        JEditorPane editorPane = new JEditorPane();\n+        editorPane.setContentType(\"text\/html\");\n+        Document document = editorPane.getDocument();\n+\n+        \/\/ Shouldn't throw ChangedCharSetException\n+        editorPane.read(\n+                new ByteArrayInputStream(\n+                        HTML_CYRILLIC.getBytes(\n+                                Charset.forName(\"windows-1251\"))),\n+                document);\n+\n+        Element root = document.getDefaultRootElement();\n+        Element body = root.getElement(1);\n+        Element p = body.getElement(0);\n+        String pText = document.getText(p.getStartOffset(),\n+                                        p.getEndOffset() - p.getStartOffset() - 1);\n+        if (!CYRILLIC_TEXT.equals(pText)) {\n+            throw new RuntimeException(\"Text doesn't match\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JEditorPane\/EditorPaneCharset.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -1,43 +0,0 @@\n-<html>\n-<!--\n- Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\n- This code is free software; you can redistribute it and\/or modify it\n- under the terms of the GNU General Public License version 2 only, as\n- published by the Free Software Foundation.\n-\n- This code is distributed in the hope that it will be useful, but WITHOUT\n- ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- version 2 for more details (a copy is included in the LICENSE file that\n- accompanied this code).\n-\n- You should have received a copy of the GNU General Public License version\n- 2 along with this work; if not, write to the Free Software Foundation,\n- Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\n- Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- or visit www.oracle.com if you need additional information or have any\n- questions.\n--->\n-\n-<!--\n- @test\n- @bug 4150029 8006087\n- @summary BackSpace keyboard button does not lead to parent directory\n- @author Oleg Mokhovikov\n- @library \/test\/lib\n- @build jdk.test.lib.Platform\n- @run applet\/manual=done bug4150029.html\n--->\n-\n-<body>\n-<applet  code=\"bug4150029.class\" width=200 height=200><\/applet>\n-Follow the instructions below.\n-1.Go into 'subDir' folder.\n-2.Press BACKSPACE key.\n-3.Push OPEN button.\n-4.Push DONE button.\n-<\/body>\n-<\/html>\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/4150029\/bug4150029.html","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,5 +24,10 @@\n-\/*\n-   bug 4150029 8006087\n-   summary BackSpace keyboard button does not lead to parent directory\n-   author Oleg Mokhovikov\n-*\/\n+import java.awt.BorderLayout;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.io.File;\n+import javax.swing.JFileChooser;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n@@ -32,3 +37,17 @@\n-import javax.swing.*;\n-import java.io.File;\n-import java.io.IOException;\n+\/*\n+ * @test\n+ * @bug 4150029 8006087\n+ * @key headful\n+ * @summary BackSpace keyboard button does not lead to parent directory\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main bug4150029\n+ *\/\n+\n+public class bug4150029 {\n+    private static JFrame frame;\n+    private static JFileChooser fileChooser;\n+    private static Robot robot;\n+    private static File prevDir;\n+    private static File crntDir;\n+    private static volatile Point p;\n@@ -36,2 +55,3 @@\n-public class bug4150029 extends JApplet {\n-    private boolean res;\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        robot.setAutoDelay(100);\n@@ -39,6 +59,7 @@\n-    public void init() {\n-        if (Platform.isOSX()) {\n-            try {\n-                UIManager.setLookAndFeel(\"javax.swing.plaf.metal.MetalLookAndFeel\");\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n+        try {\n+            if (Platform.isOSX()) {\n+                try {\n+                    UIManager.setLookAndFeel(\"javax.swing.plaf.metal.MetalLookAndFeel\");\n+                } catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n@@ -46,1 +67,0 @@\n-        }\n@@ -48,1 +68,1 @@\n-        String tmpDir = System.getProperty(\"java.io.tmpdir\");\n+            String tmpDir = System.getProperty(\"java.io.tmpdir\");\n@@ -50,2 +70,28 @@\n-        if (tmpDir.length() == 0) {\/\/'java.io.tmpdir' isn't guaranteed to be defined\n-            tmpDir = System.getProperty(\"user.home\");\n+            \/\/'java.io.tmpdir' isn't guaranteed to be defined\n+            if (tmpDir.length() == 0) {\n+                tmpDir = System.getProperty(\"user.home\");\n+            }\n+            System.out.println(\"Temp directory: \" + tmpDir);\n+\n+            File testDir = new File(tmpDir, \"testDir\");\n+            testDir.mkdir();\n+            testDir.deleteOnExit();\n+            System.out.println(\"Created directory: \" + testDir);\n+\n+            File subDir = new File(testDir, \"subDir\");\n+            subDir.mkdir();\n+            subDir.deleteOnExit();\n+            System.out.println(\"Created sub-directory: \" + subDir);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                createAndShowUI();\n+                fileChooser.setCurrentDirectory(subDir);\n+            });\n+\n+            doTesting();\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n@@ -53,0 +99,1 @@\n+    }\n@@ -54,14 +101,11 @@\n-        System.out.println(\"Temp directory: \" + tmpDir);\n-\n-        File testDir = new File(tmpDir, \"testDir\");\n-\n-        testDir.mkdir();\n-\n-        File subDir = new File(testDir, \"subDir\");\n-\n-        subDir.mkdir();\n-\n-        System.out.println(\"Created directory: \" + testDir);\n-        System.out.println(\"Created sub-directory: \" + subDir);\n-\n-        JFileChooser fileChooser = new JFileChooser(testDir);\n+    private static void createAndShowUI() {\n+        frame = new JFrame(\"Backspace Shortcut for Directory Navigation Test\");\n+        frame.setLayout(new BorderLayout());\n+        fileChooser = new JFileChooser();\n+        fileChooser.setControlButtonsAreShown(false);\n+        frame.add(fileChooser, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+    }\n@@ -69,1 +113,7 @@\n-        fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);\n+    private static void doTesting() throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            p = frame.getLocationOnScreen();\n+        });\n+        robot.mouseMove(p.x + 200, p.y + 200);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n@@ -71,5 +121,1 @@\n-        try {\n-            res = fileChooser.showOpenDialog(this) != JFileChooser.APPROVE_OPTION ||\n-                    testDir.getCanonicalPath().equals(fileChooser.getSelectedFile().getCanonicalPath());\n-        } catch (IOException e) {\n-            res = false;\n+        robot.waitForIdle();\n@@ -77,2 +123,2 @@\n-            e.printStackTrace();\n-        }\n+        \/\/ check backspace key at subDir level\n+        clickBackSpace();\n@@ -80,5 +126,2 @@\n-        try {\n-            subDir.delete();\n-            testDir.delete();\n-        } catch (SecurityException e) {\n-            e.printStackTrace();\n+        if (prevDir.equals(crntDir)) {\n+            throw new RuntimeException(\"BackSpace does not lead to parent directory\");\n@@ -88,4 +131,5 @@\n-    public void destroy() {\n-        if (!res) {\n-            throw new RuntimeException(\"BackSpace keyboard button does not lead to parent directory\");\n-        }\n+    private static void clickBackSpace() {\n+        prevDir = fileChooser.getCurrentDirectory();\n+        robot.keyPress(KeyEvent.VK_BACK_SPACE);\n+        robot.keyRelease(KeyEvent.VK_BACK_SPACE);\n+        crntDir = fileChooser.getCurrentDirectory();\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/4150029\/bug4150029.java","additions":96,"deletions":52,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-            VMSupport.decodeAndThrowThrowable(0, 0L, true);\n+            VMSupport.decodeAndThrowThrowable(0, 0L, true, false);\n@@ -72,1 +72,1 @@\n-            VMSupport.decodeAndThrowThrowable(1, 0L, true);\n+            VMSupport.decodeAndThrowThrowable(1, 0L, true, false);\n@@ -83,1 +83,1 @@\n-            VMSupport.decodeAndThrowThrowable(2, 0L, true);\n+            VMSupport.decodeAndThrowThrowable(2, 0L, true, false);\n@@ -92,1 +92,1 @@\n-            VMSupport.decodeAndThrowThrowable(3, 0L, true);\n+            VMSupport.decodeAndThrowThrowable(3, 0L, true, false);\n@@ -101,1 +101,1 @@\n-            VMSupport.decodeAndThrowThrowable(4, 0L, true);\n+            VMSupport.decodeAndThrowThrowable(4, 0L, true, false);\n@@ -115,1 +115,1 @@\n-            VMSupport.decodeAndThrowThrowable(3, buffer, true);\n+            VMSupport.decodeAndThrowThrowable(3, buffer, true, false);\n@@ -142,1 +142,1 @@\n-                        VMSupport.decodeAndThrowThrowable(format, buffer, true);\n+                        VMSupport.decodeAndThrowThrowable(format, buffer, true, false);\n","filename":"test\/jdk\/jdk\/internal\/vm\/TestTranslatedException.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.nio.file.Files;\n@@ -38,0 +37,1 @@\n+import jdk.test.lib.Utils;\n@@ -151,1 +151,1 @@\n-            Path p = Files.createTempFile(\"recording\", \".jfr\");\n+            Path p = Utils.createTempFile(\"recording\", \".jfr\");\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/filestream\/TestOrdered.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.test.lib.Utils;\n@@ -121,1 +122,1 @@\n-            Path p = Files.createTempFile(\"recording\", \".jfr\");\n+            Path p = Utils.createTempFile(\"recording\", \".jfr\");\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/filestream\/TestReuse.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import jdk.test.lib.Utils;\n@@ -81,1 +82,1 @@\n-            Path p = Files.createTempFile(\"test\", \".jfr\");\n+            Path p = Utils.createTempFile(\"test\", \".jfr\");\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestManyVirtualThreads.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -53,0 +55,1 @@\n+ * @library \/test\/lib\n@@ -58,13 +61,13 @@\n-        Path path = Files.createTempFile(\"bad\", \".zip\");\n-        try (OutputStream os = Files.newOutputStream(path);\n-                ZipOutputStream zos = new ZipOutputStream(os)) {\n-            ZipEntry e = new ZipEntry(\"x\");\n-            zos.putNextEntry(e);\n-            zos.write((int) 'x');\n-        }\n-        int len = (int) Files.size(path);\n-        byte[] data = new byte[len];\n-        try (InputStream is = Files.newInputStream(path)) {\n-            is.read(data);\n-        }\n-        Files.delete(path);\n+        Path path = Utils.createTempFile(\"bad\", \".zip\");\n+        try {\n+            try (OutputStream os = Files.newOutputStream(path);\n+                 ZipOutputStream zos = new ZipOutputStream(os)) {\n+                ZipEntry e = new ZipEntry(\"x\");\n+                zos.putNextEntry(e);\n+                zos.write((int) 'x');\n+            }\n+            int len = (int) Files.size(path);\n+            byte[] data = new byte[len];\n+            try (InputStream is = Files.newInputStream(path)) {\n+                is.read(data);\n+            }\n@@ -72,11 +75,14 @@\n-        \/\/ year, month, day are zero\n-        testDate(data.clone(), 0, LocalDate.of(1979, 11, 30).atStartOfDay());\n-        \/\/ only year is zero\n-        testDate(data.clone(), 0 << 25 | 4 << 21 | 5 << 16, LocalDate.of(1980, 4, 5).atStartOfDay());\n-        \/\/ month is greater than 12\n-        testDate(data.clone(), 0 << 25 | 13 << 21 | 1 << 16, LocalDate.of(1981, 1, 1).atStartOfDay());\n-        \/\/ 30th of February\n-        testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16, LocalDate.of(1980, 3, 1).atStartOfDay());\n-        \/\/ 30th of February, 24:60:60\n-        testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16 | 24 << 11 | 60 << 5 | 60 >> 1,\n-                LocalDateTime.of(1980, 3, 2, 1, 1, 0));\n+            \/\/ year, month, day are zero\n+            testDate(data.clone(), 0, LocalDate.of(1979, 11, 30).atStartOfDay());\n+            \/\/ only year is zero\n+            testDate(data.clone(), 0 << 25 | 4 << 21 | 5 << 16, LocalDate.of(1980, 4, 5).atStartOfDay());\n+            \/\/ month is greater than 12\n+            testDate(data.clone(), 0 << 25 | 13 << 21 | 1 << 16, LocalDate.of(1981, 1, 1).atStartOfDay());\n+            \/\/ 30th of February\n+            testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16, LocalDate.of(1980, 3, 1).atStartOfDay());\n+            \/\/ 30th of February, 24:60:60\n+            testDate(data.clone(), 0 << 25 | 2 << 21 | 30 << 16 | 24 << 11 | 60 << 5 | 60 >> 1,\n+                    LocalDateTime.of(1980, 3, 2, 1, 1, 0));\n+        } finally {\n+            Files.delete(path);\n+        }\n@@ -94,1 +100,1 @@\n-        Path path = Files.createTempFile(\"out\", \".zip\");\n+        Path path = Utils.createTempFile(\"out\", \".zip\");\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/ZeroDate.java","additions":32,"deletions":26,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.logging.*;\n+\n+import jdk.internal.event.EventHelper;\n+\n+\/*\n+ * @test\n+ * @bug 8329013\n+ * @summary StackOverflowError when starting Apache Tomcat with signed jar\n+ * @modules java.base\/jdk.internal.event:+open\n+ * @run main\/othervm -Xmx32m -Djava.util.logging.manager=RecursiveEventHelper RecursiveEventHelper\n+ *\/\n+public class RecursiveEventHelper extends LogManager {\n+    \/\/ an extra check to ensure the custom manager is in use\n+    static volatile boolean customMethodCalled;\n+\n+    public static void main(String[] args) throws Exception {\n+        String classname = System.getProperty(\"java.util.logging.manager\");\n+        if (!classname.equals(\"RecursiveEventHelper\")) {\n+            throw new RuntimeException(\"java.util.logging.manager not set\");\n+        }\n+\n+        \/\/ this call will trigger initialization of logging framework\n+        \/\/ which will call into our custom LogManager and use the\n+        \/\/ custom getProperty method below. EventHelper.isLoggingSecurity()\n+        \/\/ is also on the code path of original report and triggers\n+        \/\/ similar recursion.\n+        System.getLogger(\"testLogger\");\n+        if (!customMethodCalled) {\n+            throw new RuntimeException(\"Method not called\");\n+        }\n+    }\n+\n+    @Override\n+    public String getProperty(String p) {\n+        \/\/ this call mimics issue reported in initial bug report where\n+        \/\/ opening of a signed jar during System logger initialization triggered\n+        \/\/ a recursive call (via EventHelper.isLoggingSecurity) back into\n+        \/\/ logger API\n+        EventHelper.isLoggingSecurity();\n+        customMethodCalled = true;\n+        return super.getProperty(p);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/security\/logging\/RecursiveEventHelper.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n- * Change file permission for out-of-the-box management an do test used by\n- * PasswordFilePermissionTest and SSLConfigFilePermissionTest tests\n+ * Change file permission for out-of-the-box management, and test.\n+ * Used by PasswordFilePermissionTest and SSLConfigFilePermissionTest tests.\n@@ -143,1 +143,3 @@\n-        if (doTest() != 0) {\n+        int e = doTest();\n+        if (e != 0) {\n+            System.out.println(\"FAILURE: expected exit code 0, got: \" + e);\n@@ -149,1 +151,1 @@\n-     * Test 1 - SSL config file is secure - VM should start\n+     * Test 2 - SSL config file is NOT secure - VM should not start\n@@ -157,1 +159,3 @@\n-        if (doTest() == 0) {\n+        int e = doTest();\n+        if (e == 0) {\n+            System.out.println(\"FAILURE: expected exit code non-zero, got: \" + e);\n@@ -175,1 +179,0 @@\n-\n@@ -184,4 +187,5 @@\n-            if ((output.getExitValue() == 0)  ||\n-                !output.getOutput().contains(\"Exception thrown by the agent : \" +\n-                        \"java.rmi.server.ExportException: Port already in use\")) {\n-                return output.getExitValue();\n+            if (output.getOutput().contains(\"Exception thrown by the agent: java.rmi.server.ExportException: Port already in use\")) {\n+                if (i < MAX_GET_FREE_PORT_TRIES - 1) {\n+                    System.out.println(\"Retrying...\");\n+                    continue;\n+                }\n@@ -189,0 +193,2 @@\n+            \/\/ Fail on too many port failures, and all other startup failures.\n+            return output.getExitValue();\n@@ -190,1 +196,0 @@\n-\n","filename":"test\/jdk\/sun\/management\/jmxremote\/bootstrap\/AbstractFilePermissionTest.java","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,1 @@\n-            if (!output.getOutput().contains(\"Exception thrown by the agent : \" +\n+            if (!output.getOutput().contains(\"Exception thrown by the agent: \" +\n","filename":"test\/jdk\/sun\/management\/jmxremote\/bootstrap\/RmiRegistrySslTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8327818\n+ * @bug 8327818 8051959\n@@ -29,0 +29,1 @@\n+ * @run junit LoginModuleDebug\n@@ -31,0 +32,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -32,0 +34,3 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -34,0 +39,1 @@\n+import java.util.stream.Stream;\n@@ -37,20 +43,35 @@\n-    public static void main(String[] args) throws Exception {\n-        if (args.length == 0) {\n-            \/\/ debug option set to true\n-            ProcessTools.executeTestJava(\"LoginModuleDebug\",\n-                            \"debug\", \"true\")\n-                    .stdoutShouldBeEmpty()\n-                    .stderrShouldContain(\"krb5loginmodule:\");\n-            \/\/ debug option set to false\n-            ProcessTools.executeTestJava(\"LoginModuleDebug\",\n-                            \"debug\", \"false\")\n-                    .stdoutShouldBeEmpty()\n-                    .stderrShouldNotContain(\"krb5loginmodule:\");\n-            \/\/ no debug option\n-            ProcessTools.executeTestJava(\"LoginModuleDebug\",\n-                            \"foo\", \"bar\")\n-                    .stdoutShouldBeEmpty()\n-                    .stderrShouldNotContain(\"krb5loginmodule:\");\n-        } else {\n-            test(args[0], args[1]);\n-        }\n+    static final String DATE_REGEX = \"\\\\d{4}-\\\\d{2}-\\\\d{2}\";\n+\n+    private static Stream<Arguments> patternMatches() {\n+        return Stream.of(\n+                \/\/ debug option set to true - no extra info\n+                Arguments.of(\"debug\",\n+                        \"true\",\n+                        \"krb5loginmodule:\",\n+                        \"krb5loginmodule\\\\[\"),\n+                \/\/ debug option set to false\n+                Arguments.of(\"debug\",\n+                        \"false\",\n+                        \"\",\n+                        \"krb5loginmodule\"),\n+                \/\/ no debug option\n+                Arguments.of(\"foo\",\n+                        \"bar\",\n+                        \"\",\n+                        \"krb5loginmodule\"),\n+                \/\/ thread info only\n+                Arguments.of(\"debug\",\n+                        \"true+thread\",\n+                        \"krb5loginmodule\\\\[.*\\\\|main|\\\\.*java.*]:\",\n+                        \"\\\\|\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ timestamp info only\n+                Arguments.of(\"debug\",\n+                        \"true+timestamp\",\n+                        \"krb5loginmodule\\\\[\" + DATE_REGEX + \".*\\\\]\",\n+                        \"\\\\|main\\\\]:\"),\n+                \/\/ both thread and timestamp\n+                Arguments.of(\"debug\",\n+                        \"true+timestamp+thread\",\n+                        \"krb5loginmodule\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"krb5loginmodule:\")\n+        );\n@@ -59,4 +80,26 @@\n-    static void test(String key, String prop)\n-            throws Exception {\n-        new Krb5LoginModule().initialize(\n-                new Subject(), null, Map.of(), Map.of(key, prop));\n+    @ParameterizedTest\n+    @MethodSource(\"patternMatches\")\n+    public void shouldContain(String value, String key, String expected, String notExpected) throws Exception {\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n+                \"LoginModuleDebug\",\n+                value, key);\n+        outputAnalyzer.shouldHaveExitValue(0)\n+                .shouldMatch(expected)\n+                .shouldNotMatch(notExpected);\n+        \/\/ let's also run with java debug property enabled\n+        outputAnalyzer = ProcessTools.executeTestJava(\n+                \"-Djava.security.debug=all\",\n+                \"LoginModuleDebug\",\n+                value, key);\n+        outputAnalyzer.shouldHaveExitValue(0)\n+                .shouldMatch(expected)\n+                .shouldNotMatch(notExpected);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        System.err.println(args.length);\n+        if (args.length == 2) {\n+            \/\/ something to trigger \"krb5\" debug output\n+            new Krb5LoginModule().initialize(\n+                    new Subject(), null, Map.of(), Map.of(args[0], args[1]));\n+        }\n@@ -64,1 +107,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/LoginModuleDebug.java","additions":69,"deletions":26,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,3 +57,1 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -264,2 +262,3 @@\n-        String nssLibDir = fetchNssLib(osid);\n-        if (nssLibDir == null) {\n+        Path libraryName = Path.of(System.mapLibraryName(library));\n+        Path nssLibPath = fetchNssLib(osid, libraryName);\n+        if (nssLibPath == null) {\n@@ -269,8 +268,1 @@\n-\n-        String libraryName = System.mapLibraryName(library);\n-        Path libPath = Paths.get(nssLibDir).resolve(libraryName);\n-        if (!Files.exists(libPath)) {\n-            throw new SkippedException(\"NSS library \\\"\" + libraryName + \"\\\" was not found in \" + nssLibDir);\n-        }\n-\n-        return libPath;\n+        return nssLibPath;\n@@ -738,1 +730,1 @@\n-    private static String fetchNssLib(String osId) {\n+    private static Path fetchNssLib(String osId, Path libraryName) {\n@@ -741,1 +733,1 @@\n-                return fetchNssLib(WINDOWS_X64.class);\n+                return fetchNssLib(WINDOWS_X64.class, libraryName);\n@@ -744,1 +736,1 @@\n-                return fetchNssLib(MACOSX_X64.class);\n+                return fetchNssLib(MACOSX_X64.class, libraryName);\n@@ -747,1 +739,1 @@\n-                return fetchNssLib(MACOSX_AARCH64.class);\n+                return fetchNssLib(MACOSX_AARCH64.class, libraryName);\n@@ -753,1 +745,1 @@\n-                    return fetchNssLib(LINUX_X64.class);\n+                    return fetchNssLib(LINUX_X64.class, libraryName);\n@@ -760,1 +752,1 @@\n-                    return fetchNssLib(LINUX_AARCH64.class);\n+                    return fetchNssLib(LINUX_AARCH64.class, libraryName);\n@@ -767,2 +759,2 @@\n-    private static String fetchNssLib(Class<?> clazz) {\n-        String path = null;\n+    private static Path fetchNssLib(Class<?> clazz, Path libraryName) {\n+        Path path = null;\n@@ -770,4 +762,4 @@\n-            path = ArtifactResolver.resolve(clazz).entrySet().stream()\n-                    .findAny().get().getValue() + File.separator + \"nss\"\n-                    + File.separator + \"lib\" + File.separator;\n-        } catch (ArtifactResolverException e) {\n+            Path p = ArtifactResolver.resolve(clazz).entrySet().stream()\n+                    .findAny().get().getValue();\n+            path = findNSSLibrary(p, libraryName);\n+        } catch (ArtifactResolverException | IOException e) {\n@@ -787,0 +779,10 @@\n+    private static Path findNSSLibrary(Path path, Path libraryName) throws IOException {\n+        try(Stream<Path> files = Files.find(path, 10,\n+                (tp, attr) -> tp.getFileName().equals(libraryName))) {\n+\n+            return files.findAny()\n+                        .orElseThrow(() -> new SkippedException(\n+                        \"NSS library \\\"\" + libraryName + \"\\\" was not found in \" + path));\n+        }\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":28,"deletions":26,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.nio.file.Files;\n@@ -69,4 +70,0 @@\n-        try (FileOutputStream fos = new FileOutputStream(ksFile)) {\n-            ks.store(fos, pw);\n-            fos.flush();\n-        }\n@@ -74,12 +71,19 @@\n-        \/\/ now see if we can get it back\n-        try (FileInputStream fis = new FileInputStream(ksFile)) {\n-            KeyStore ks2 = KeyStore.getInstance(keystoreType);\n-            ks2.load(fis, pw);\n-            KeyStore.Entry entry = ks2.getEntry(ALIAS, kspp);\n-            SecretKey keyIn = ((KeyStore.SecretKeyEntry)entry).getSecretKey();\n-            if (Arrays.equals(key.getEncoded(), keyIn.getEncoded())) {\n-                System.err.println(\"OK: worked just fine with \" + keystoreType +\n-                                   \" keystore\");\n-            } else {\n-                System.err.println(\"ERROR: keys are NOT equal after storing in \"\n-                                   + keystoreType + \" keystore\");\n+        try {\n+            try (FileOutputStream fos = new FileOutputStream(ksFile)) {\n+                ks.store(fos, pw);\n+                fos.flush();\n+            }\n+\n+            \/\/ now see if we can get it back\n+            try (FileInputStream fis = new FileInputStream(ksFile)) {\n+                KeyStore ks2 = KeyStore.getInstance(keystoreType);\n+                ks2.load(fis, pw);\n+                KeyStore.Entry entry = ks2.getEntry(ALIAS, kspp);\n+                SecretKey keyIn = ((KeyStore.SecretKeyEntry) entry).getSecretKey();\n+                if (Arrays.equals(key.getEncoded(), keyIn.getEncoded())) {\n+                    System.err.println(\"OK: worked just fine with \" + keystoreType +\n+                            \" keystore\");\n+                } else {\n+                    System.err.println(\"ERROR: keys are NOT equal after storing in \"\n+                            + keystoreType + \" keystore\");\n+                }\n@@ -87,0 +91,2 @@\n+        } finally {\n+            Files.deleteIfExists(ksFile.toPath());\n","filename":"test\/jdk\/sun\/security\/pkcs12\/P12SecretKey.java","additions":23,"deletions":17,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8051959\n+ * @summary Option to print extra information in java.security.debug output\n+ * @library \/test\/lib\n+ * @run junit DebugOptions\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.security.KeyStore;\n+import java.security.Security;\n+import java.util.stream.Stream;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class DebugOptions {\n+\n+    static final String DATE_REGEX = \"\\\\d{4}-\\\\d{2}-\\\\d{2}\";\n+\n+    private static Stream<Arguments> patternMatches() {\n+        return Stream.of(\n+                \/\/ no extra info present\n+                Arguments.of(\"properties\",\n+                        \"properties: Initial\",\n+                        \"properties\\\\[\"),\n+                \/\/ thread info only\n+                Arguments.of(\"properties+thread\",\n+                        \"properties\\\\[.*\\\\|main\\\\|.*java.*]:\",\n+                        \"properties\\\\[\" + DATE_REGEX),\n+                \/\/ timestamp info only\n+                Arguments.of(\"properties+timestamp\",\n+                        \"properties\\\\[\" + DATE_REGEX + \".*\\\\]\",\n+                        \"\\\\|main\\\\]:\"),\n+                \/\/ both thread and timestamp\n+                Arguments.of(\"properties+timestamp+thread\",\n+                        \"properties\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"properties:\"),\n+                \/\/ flip the arguments of previous test\n+                Arguments.of(\"properties+thread+timestamp\",\n+                        \"properties\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"properties:\"),\n+                \/\/ comma not valid separator, ignore extra info printing request\n+                Arguments.of(\"properties,thread,timestamp\",\n+                        \"properties:\",\n+                        \"properties\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ no extra info for keystore debug prints\n+                Arguments.of(\"properties+thread+timestamp,keystore\",\n+                        \"properties\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"keystore\\\\[\"),\n+                \/\/ flip arguments around in last test - same outcome expected\n+                Arguments.of(\"keystore,properties+thread+timestamp\",\n+                        \"properties\\\\[.*\\\\|main|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"keystore\\\\[\"),\n+                \/\/ turn on thread info for both keystore and properties components\n+                Arguments.of(\"keystore+thread,properties+thread\",\n+                        \"properties\\\\[.*\\\\|main|.*\\\\Rkeystore\\\\[.*\\\\|main|.*\\\\]:\",\n+                        \"\\\\|\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ same as above with erroneous comma at end of string. same output expected\n+                Arguments.of(\"keystore+thread,properties+thread,\",\n+                        \"properties\\\\[.*\\\\|main|.*\\\\Rkeystore\\\\[.*\\\\|main|.*\\\\]:\",\n+                        \"\\\\|\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ turn on thread info for properties and timestamp for keystore\n+                Arguments.of(\"keystore+timestamp,properties+thread\",\n+                        \"properties\\\\[.*\\\\|main|.*\\\\Rkeystore\\\\[\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"properties\\\\[.*\\\\|\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ turn on thread info for all components\n+                Arguments.of(\"all+thread\",\n+                        \"properties\\\\[.*\\\\|main.*((.*\\\\R)*)keystore\\\\[.*\\\\|main.*java.*\\\\]:\",\n+                        \"properties\\\\[\" + DATE_REGEX + \".*\\\\]:\"),\n+                \/\/ turn on thread info and timestamp for all components\n+                Arguments.of(\"all+thread+timestamp\",\n+                        \"properties\\\\[.*\\\\|main.*\\\\|\" + DATE_REGEX +\n+                                \".*\\\\]((.*\\\\R)*)keystore\\\\[.*\\\\|main.*\\\\|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"properties:\"),\n+                \/\/ all decorator option should override other component options\n+                Arguments.of(\"all+thread+timestamp,properties\",\n+                        \"properties\\\\[.*\\\\|main.*\\\\|\" + DATE_REGEX +\n+                                \".*\\\\]((.*\\\\R)*)keystore\\\\[.*\\\\|main.*\\\\|\" + DATE_REGEX + \".*\\\\]:\",\n+                        \"properties:\"),\n+                \/\/ thread details should only be printed for properties option\n+                Arguments.of(\"properties+thread,all\",\n+                        \"properties\\\\[.*\\\\|main\\\\|.*\\\\]:\",\n+                        \"keystore\\\\[.*\\\\|main\\\\|.*\\\\]:\"),\n+                \/\/ thread details should be printed for all statements\n+                Arguments.of(\"properties,all+thread\",\n+                        \"properties\\\\[.*\\\\|main.*java\" +\n+                                \".*\\\\]((.*\\\\R)*)keystore\\\\[.*\\\\|main.*java.*\\\\]:\",\n+                        \"properties:\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"patternMatches\")\n+    public void shouldContain(String params, String expected, String notExpected) throws Exception {\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n+                \"-Djava.security.debug=\" + params,\n+                \"DebugOptions\"\n+        );\n+        outputAnalyzer.shouldHaveExitValue(0)\n+                .shouldMatch(expected)\n+                .shouldNotMatch(notExpected);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ something to trigger \"properties\" debug output\n+        Security.getProperty(\"test\");\n+        \/\/ trigger \"keystore\" debug output\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/util\/Debug\/DebugOptions.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8316972\n+ * @bug 8316972 8325217\n@@ -110,3 +110,2 @@\n-                <div class=\"member-signature\"><span class=\"modifiers\">sealed<\/span>&nbsp;<span clas\\\n-                s=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">restrictedMethod<\/span>\\\n-                ()<\/div>\n+                <div class=\"member-signature\"><span class=\"return-type\">void<\/span>&nbsp;<span \\\n+                class=\"element-name\">restrictedMethod<\/span>()<\/div>\n@@ -124,3 +123,2 @@\n-                <div class=\"member-signature\"><span class=\"modifiers\">sealed<\/span>&nbsp;<span clas\\\n-                s=\"return-type\">int<\/span>&nbsp;<span class=\"element-name\">restrictedPreviewMethod<\\\n-                \/span>()<\/div>\n+                <div class=\"member-signature\"><span class=\"return-type\">int<\/span>&nbsp;<span class=\\\n+                \"element-name\">restrictedPreviewMethod<\/span>()<\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRestricted\/TestRestricted.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"}]}