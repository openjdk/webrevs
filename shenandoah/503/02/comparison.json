{"files":[{"patch":"@@ -380,3 +380,1 @@\n-  \/\/ We allow forwarding in young generation and marking in old generation\n-  \/\/ to happen simultaneously.\n-  assert(_heap->mode()->is_generational() || HAS_FWD == _heap->has_forwarded_objects(), \"Forwarded object status is sane\");\n+  assert(HAS_FWD == _heap->has_forwarded_objects(), \"Forwarded object status is sane\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-  }\n@@ -196,1 +195,0 @@\n-  if (heap->has_forwarded_objects()) {\n@@ -215,4 +213,17 @@\n-    \/\/ We chose not to evacuate because we found sufficient immediate garbage. Note that we\n-    \/\/ do not check for cancellation here because, at this point, the cycle is effectively\n-    \/\/ complete. If the cycle has been cancelled here, the control thread will detect it\n-    \/\/ on its next iteration and run a degenerated young cycle.\n+    \/\/ We chose not to evacuate because we found sufficient immediate garbage.\n+    \/\/ However, there may still be regions to promote in place, so do that now.\n+    if (has_in_place_promotions(heap)) {\n+      entry_promote_in_place();\n+\n+      \/\/ If the promote-in-place operation was cancelled, we can have the degenerated\n+      \/\/ cycle complete the operation. It will see that no evacuations are in progress,\n+      \/\/ and that there are regions wanting promotion. The risk with not handling the\n+      \/\/ cancellation would be failing to restore top for these regions and leaving\n+      \/\/ them unable to serve allocations for the old generation.\n+      if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_evac)) {\n+        return false;\n+      }\n+    }\n+\n+    \/\/ At this point, the cycle is effectively complete. If the cycle has been cancelled here,\n+    \/\/ the control thread will detect it on its next iteration and run a degenerated young cycle.\n@@ -513,0 +524,17 @@\n+void ShenandoahConcurrentGC::entry_promote_in_place() {\n+  shenandoah_assert_generational();\n+\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+\n+  static const char* msg = \"Promote in place\";\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::promote_in_place);\n+  EventMark em(\"%s\", msg);\n+\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_evac(),\n+                              \"promote in place\");\n+\n+  ShenandoahGenerationalHeap::heap()->promote_regions_in_place(true);\n+}\n+\n@@ -692,4 +720,1 @@\n-    if (!heap->collection_set()->is_empty() || has_in_place_promotions(heap)) {\n-      \/\/ Even if the collection set is empty, we need to do evacuation if there are regions to be promoted in place.\n-      \/\/ Concurrent evacuation takes responsibility for registering objects and setting the remembered set cards to dirty.\n-\n+    if (!heap->collection_set()->is_empty()) {\n@@ -708,5 +733,2 @@\n-\n-      \/\/ Generational mode may promote objects in place during the evacuation phase.\n-      \/\/ If that is the only reason we are evacuating, we don't need to update references\n-      \/\/ and there will be no forwarded objects on the heap.\n-      heap->set_has_forwarded_objects(!heap->collection_set()->is_empty());\n+      \/\/ From here on, we need to update references.\n+      heap->set_has_forwarded_objects(true);\n@@ -715,7 +737,2 @@\n-      if (!heap->collection_set()->is_empty()) {\n-        \/\/ Iff objects will be evaluated, arm the nmethod barriers. These will be disarmed\n-        \/\/ under the same condition (established in prepare_concurrent_roots) after strong\n-        \/\/ root evacuation has completed (see op_strong_roots).\n-        ShenandoahCodeRoots::arm_nmethods_for_evac();\n-        ShenandoahStackWatermark::change_epoch_id();\n-      }\n+      ShenandoahCodeRoots::arm_nmethods_for_evac();\n+      ShenandoahStackWatermark::change_epoch_id();\n@@ -728,1 +745,5 @@\n-        heap->verifier()->verify_after_concmark();\n+        if (has_in_place_promotions(heap)) {\n+          heap->verifier()->verify_before_region_promotions();\n+        } else {\n+          heap->verifier()->verify_after_concmark();\n+        }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":44,"deletions":23,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -110,0 +110,3 @@\n+  \/\/ Called when the collection set is empty, but the generational mode has regions to promote in place\n+  void entry_promote_in_place();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -254,0 +254,4 @@\n+      } else if (has_in_place_promotions(heap)) {\n+        \/\/ We have nothing to evacuate, but there are still regions to promote in place.\n+        ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc_promote_regions);\n+        ShenandoahGenerationalHeap::heap()->promote_regions_in_place(false \/* concurrent*\/);\n@@ -256,1 +260,1 @@\n-      \/\/ Update collector state regardless of whether or not there are forwarded objects\n+      \/\/ Update collector state regardless of whether there are forwarded objects\n@@ -352,4 +356,1 @@\n-  if (!heap->collection_set()->is_empty() || has_in_place_promotions(heap)) {\n-    \/\/ Even if the collection set is empty, we need to do evacuation if there are regions to be promoted in place.\n-    \/\/ Degenerated evacuation takes responsibility for registering objects and setting the remembered set cards to dirty.\n-\n+  if (!heap->collection_set()->is_empty()) {\n@@ -361,1 +362,1 @@\n-    heap->set_has_forwarded_objects(!heap->collection_set()->is_empty());\n+    heap->set_has_forwarded_objects(true);\n@@ -364,1 +365,5 @@\n-      heap->verifier()->verify_after_concmark();\n+      if (has_in_place_promotions(heap)) {\n+        heap->verifier()->verify_before_region_promotions();\n+      } else {\n+        heap->verifier()->verify_after_concmark();\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-                                                                           bool concurrent) :\n+                                                                           bool concurrent, bool only_promote_regions) :\n@@ -61,0 +61,1 @@\n+  _only_promote_regions(only_promote_regions),\n@@ -71,1 +72,0 @@\n-    ShenandoahEvacOOMScope oom_evac_scope;\n@@ -75,1 +75,0 @@\n-    ShenandoahEvacOOMScope oom_evac_scope;\n@@ -81,0 +80,39 @@\n+  if (_only_promote_regions) {\n+    \/\/ No allocations will be made, do not enter oom-during-evac protocol.\n+    assert(ShenandoahHeap::heap()->collection_set()->is_empty(), \"Should not have a collection set here\");\n+    promote_regions();\n+  } else {\n+    assert(!ShenandoahHeap::heap()->collection_set()->is_empty(), \"Should have a collection set here\");\n+    ShenandoahEvacOOMScope oom_evac_scope;\n+    evacuate_and_promote_regions();\n+  }\n+}\n+\n+void log_region(const ShenandoahHeapRegion* r, LogStream* ls) {\n+  ls->print_cr(\"GenerationalEvacuationTask, looking at %s region \" SIZE_FORMAT \", (age: %d) [%s, %s, %s]\",\n+              r->is_old()? \"old\": r->is_young()? \"young\": \"free\", r->index(), r->age(),\n+              r->is_active()? \"active\": \"inactive\",\n+              r->is_humongous()? (r->is_humongous_start()? \"humongous_start\": \"humongous_continuation\"): \"regular\",\n+              r->is_cset()? \"cset\": \"not-cset\");\n+}\n+\n+void ShenandoahGenerationalEvacuationTask::promote_regions() {\n+  ShenandoahHeapRegion* r;\n+  LogTarget(Debug, gc) lt;\n+\n+  while ((r = _regions->next()) != nullptr) {\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      log_region(r, &ls);\n+    }\n+\n+    maybe_promote_region(r);\n+\n+    if (_heap->check_cancelled_gc_and_yield(_concurrent)) {\n+      break;\n+    }\n+  }\n+}\n+\n+void ShenandoahGenerationalEvacuationTask::evacuate_and_promote_regions() {\n+  LogTarget(Debug, gc) lt;\n@@ -85,5 +123,4 @@\n-    log_debug(gc)(\"GenerationalEvacuationTask do_work(), looking at %s region \" SIZE_FORMAT \", (age: %d) [%s, %s, %s]\",\n-            r->is_old()? \"old\": r->is_young()? \"young\": \"free\", r->index(), r->age(),\n-            r->is_active()? \"active\": \"inactive\",\n-            r->is_humongous()? (r->is_humongous_start()? \"humongous_start\": \"humongous_continuation\"): \"regular\",\n-            r->is_cset()? \"cset\": \"not-cset\");\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      log_region(r, &ls);\n+    }\n@@ -97,11 +134,18 @@\n-    } else if (r->is_young() && r->is_active() && (r->age() >= _tenuring_threshold)) {\n-      if (r->is_humongous_start()) {\n-        \/\/ We promote humongous_start regions along with their affiliated continuations during evacuation rather than\n-        \/\/ doing this work during a safepoint.  We cannot put humongous regions into the collection set because that\n-        \/\/ triggers the load-reference barrier (LRB) to copy on reference fetch.\n-        promote_humongous(r);\n-      } else if (r->is_regular() && (r->get_top_before_promote() != nullptr)) {\n-        \/\/ Likewise, we cannot put promote-in-place regions into the collection set because that would also trigger\n-        \/\/ the LRB to copy on reference fetch.\n-        promote_in_place(r);\n-      }\n+    } else {\n+      maybe_promote_region(r);\n+    }\n+\n+    if (_heap->check_cancelled_gc_and_yield(_concurrent)) {\n+      break;\n+    }\n+  }\n+}\n+\n+\n+void ShenandoahGenerationalEvacuationTask::maybe_promote_region(ShenandoahHeapRegion* r) {\n+  if (r->is_young() && r->is_active() && (r->age() >= _tenuring_threshold)) {\n+    if (r->is_humongous_start()) {\n+      \/\/ We promote humongous_start regions along with their affiliated continuations during evacuation rather than\n+      \/\/ doing this work during a safepoint.  We cannot put humongous regions into the collection set because that\n+      \/\/ triggers the load-reference barrier (LRB) to copy on reference fetch.\n+      \/\/\n@@ -112,1 +156,5 @@\n-\n+      promote_humongous(r);\n+    } else if (r->is_regular() && (r->get_top_before_promote() != nullptr)) {\n+      \/\/ Likewise, we cannot put promote-in-place regions into the collection set because that would also trigger\n+      \/\/ the LRB to copy on reference fetch.\n+      \/\/\n@@ -115,5 +163,1 @@\n-    }\n-    \/\/ else, region is free, or OLD, or not in collection set, or humongous_continuation,\n-    \/\/ or is young humongous_start that is too young to be promoted\n-    if (_heap->check_cancelled_gc_and_yield(_concurrent)) {\n-      break;\n+      promote_in_place(r);\n@@ -282,0 +326,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":70,"deletions":25,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  bool _only_promote_regions;\n@@ -46,1 +47,1 @@\n-                                       bool concurrent);\n+                                       bool concurrent, bool only_promote_regions);\n@@ -50,1 +51,3 @@\n-\n+  void promote_regions();\n+  void evacuate_and_promote_regions();\n+  void maybe_promote_region(ShenandoahHeapRegion* region);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -173,0 +173,12 @@\n+void ShenandoahGenerationalHeap::evacuate_collection_set(bool concurrent) {\n+  ShenandoahRegionIterator regions;\n+  ShenandoahGenerationalEvacuationTask task(this, &regions, concurrent, false \/* only promote regions *\/);\n+  workers()->run_task(&task);\n+}\n+\n+void ShenandoahGenerationalHeap::promote_regions_in_place(bool concurrent) {\n+  ShenandoahRegionIterator regions;\n+  ShenandoahGenerationalEvacuationTask task(this, &regions, concurrent, true \/* only promote regions *\/);\n+  workers()->run_task(&task);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+  void evacuate_collection_set(bool concurrent) override;\n+  void promote_regions_in_place(bool concurrent);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1213,8 +1213,2 @@\n-  if (mode()->is_generational()) {\n-    ShenandoahRegionIterator regions;\n-    ShenandoahGenerationalEvacuationTask task(ShenandoahGenerationalHeap::heap(), &regions, concurrent);\n-    workers()->run_task(&task);\n-  } else {\n-    ShenandoahEvacuationTask task(this, _collection_set, concurrent);\n-    workers()->run_task(&task);\n-  }\n+  ShenandoahEvacuationTask task(this, _collection_set, concurrent);\n+  workers()->run_task(&task);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -472,1 +472,1 @@\n-  void evacuate_collection_set(bool concurrent);\n+  virtual void evacuate_collection_set(bool concurrent);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,2 @@\n-  bool has_in_place_promotions() const { return (_promotable_humongous_regions + _promotable_regular_regions) > 0; }\n+  size_t get_expected_in_place_promotions() const { return _promotable_humongous_regions + _promotable_regular_regions; }\n+  bool has_in_place_promotions() const { return get_expected_in_place_promotions() > 0; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-                                                                                       \\\n+  f(promote_in_place,                               \"Concurrent Promote Regions\")      \\\n@@ -157,0 +157,1 @@\n+  f(degen_gc_promote_regions,                       \"  Degen Promote Regions\")         \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1075,9 +1075,23 @@\n-          _verify_remembered_disable,  \/\/ do not verify remembered set\n-          _verify_forwarded_none,      \/\/ no forwarded references\n-          _verify_marked_complete_satb_empty,\n-                                       \/\/ bitmaps as precise as we can get, except dangling j.l.r.Refs\n-          _verify_cset_none,           \/\/ no references to cset anymore\n-          _verify_liveness_complete,   \/\/ liveness data must be complete here\n-          _verify_regions_disable,     \/\/ trash regions not yet recycled\n-          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n-          _verify_gcstate_stable_weakroots  \/\/ heap is still stable, weakroots are in progress\n+          _verify_remembered_disable,         \/\/ do not verify remembered set\n+          _verify_forwarded_none,             \/\/ no forwarded references\n+          _verify_marked_complete_satb_empty, \/\/ bitmaps as precise as we can get, except dangling j.l.r.Refs\n+          _verify_cset_none,                  \/\/ no references to cset anymore\n+          _verify_liveness_complete,          \/\/ liveness data must be complete here\n+          _verify_regions_disable,            \/\/ trash regions not yet recycled\n+          _verify_size_exact,                 \/\/ expect generation and heap sizes to match exactly\n+          _verify_gcstate_stable_weakroots    \/\/ heap is still stable, weakroots are in progress\n+  );\n+}\n+\n+void ShenandoahVerifier::verify_before_region_promotions() {\n+  verify_at_safepoint(\n+          \"After Mark\",\n+          _verify_remembered_disable,         \/\/ do not verify remembered set\n+          _verify_forwarded_none,             \/\/ no forwarded references\n+          _verify_marked_complete_satb_empty, \/\/ bitmaps as precise as we can get, except dangling j.l.r.Refs\n+          _verify_cset_none,                  \/\/ no references to cset anymore\n+          _verify_liveness_complete,          \/\/ liveness data must be complete here\n+          _verify_regions_disable,            \/\/ trash regions not yet recycled\n+          _verify_size_adjusted_for_padding,  \/\/ expect generation and heap sizes to match after adjustments\n+                                              \/\/ for promote in place padding\n+          _verify_gcstate_stable_weakroots    \/\/ heap is still stable, weakroots are in progress\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -215,0 +215,1 @@\n+  void verify_before_region_promotions();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}