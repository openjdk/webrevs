{"files":[{"patch":"@@ -380,3 +380,1 @@\n-  \/\/ We allow forwarding in young generation and marking in old generation\n-  \/\/ to happen simultaneously.\n-  assert(_heap->mode()->is_generational() || HAS_FWD == _heap->has_forwarded_objects(), \"Forwarded object status is sane\");\n+  assert(HAS_FWD == _heap->has_forwarded_objects(), \"Forwarded object status is sane\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-  }\n@@ -196,1 +195,0 @@\n-  if (heap->has_forwarded_objects()) {\n@@ -215,4 +213,17 @@\n-    \/\/ We chose not to evacuate because we found sufficient immediate garbage. Note that we\n-    \/\/ do not check for cancellation here because, at this point, the cycle is effectively\n-    \/\/ complete. If the cycle has been cancelled here, the control thread will detect it\n-    \/\/ on its next iteration and run a degenerated young cycle.\n+    \/\/ We chose not to evacuate because we found sufficient immediate garbage.\n+    \/\/ However, there may still be regions to promote in place, so do that now.\n+    if (has_in_place_promotions(heap)) {\n+      entry_promote_in_place();\n+\n+      \/\/ If the promote-in-place operation was cancelled, we can have the degenerated\n+      \/\/ cycle complete the operation. It will see that no evacuations are in progress,\n+      \/\/ and that there are regions wanting promotion. The risk with not handling the\n+      \/\/ cancellation would be failing to restore top for these regions and leaving\n+      \/\/ them unable to serve allocations for the old generation.\n+      if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_evac)) {\n+        return false;\n+      }\n+    }\n+\n+    \/\/ At this point, the cycle is effectively complete. If the cycle has been cancelled here,\n+    \/\/ the control thread will detect it on its next iteration and run a degenerated young cycle.\n@@ -513,0 +524,17 @@\n+void ShenandoahConcurrentGC::entry_promote_in_place() {\n+  shenandoah_assert_generational();\n+\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+\n+  static const char* msg = \"Promote in place\";\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::promote_in_place);\n+  EventMark em(\"%s\", msg);\n+\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_evac(),\n+                              \"promote in place\");\n+\n+  ShenandoahGenerationalHeap::heap()->promote_regions_in_place(true);\n+}\n+\n@@ -692,4 +720,1 @@\n-    if (!heap->collection_set()->is_empty() || has_in_place_promotions(heap)) {\n-      \/\/ Even if the collection set is empty, we need to do evacuation if there are regions to be promoted in place.\n-      \/\/ Concurrent evacuation takes responsibility for registering objects and setting the remembered set cards to dirty.\n-\n+    if (!heap->collection_set()->is_empty()) {\n@@ -708,5 +733,2 @@\n-\n-      \/\/ Generational mode may promote objects in place during the evacuation phase.\n-      \/\/ If that is the only reason we are evacuating, we don't need to update references\n-      \/\/ and there will be no forwarded objects on the heap.\n-      heap->set_has_forwarded_objects(!heap->collection_set()->is_empty());\n+      \/\/ From here on, we need to update references.\n+      heap->set_has_forwarded_objects(true);\n@@ -715,7 +737,2 @@\n-      if (!heap->collection_set()->is_empty()) {\n-        \/\/ Iff objects will be evaluated, arm the nmethod barriers. These will be disarmed\n-        \/\/ under the same condition (established in prepare_concurrent_roots) after strong\n-        \/\/ root evacuation has completed (see op_strong_roots).\n-        ShenandoahCodeRoots::arm_nmethods_for_evac();\n-        ShenandoahStackWatermark::change_epoch_id();\n-      }\n+      ShenandoahCodeRoots::arm_nmethods_for_evac();\n+      ShenandoahStackWatermark::change_epoch_id();\n@@ -728,1 +745,4 @@\n-        heap->verifier()->verify_after_concmark();\n+        ShenandoahVerifier::VerifySize sizeness = has_in_place_promotions(heap)\n+                                                ? ShenandoahVerifier::_verify_size_adjusted_for_padding\n+                                                : ShenandoahVerifier::_verify_size_exact;\n+        heap->verifier()->verify_after_concmark(sizeness);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":43,"deletions":23,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -110,0 +110,3 @@\n+  \/\/ Called when the collection set is empty, but the generational mode has regions to promote in place\n+  void entry_promote_in_place();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -254,0 +254,4 @@\n+      } else if (has_in_place_promotions(heap)) {\n+        \/\/ We have nothing to evacuate, but there are still regions to promote in place.\n+        ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc_promote_regions);\n+        ShenandoahGenerationalHeap::heap()->promote_regions_in_place(false \/* concurrent*\/);\n@@ -256,1 +260,1 @@\n-      \/\/ Update collector state regardless of whether or not there are forwarded objects\n+      \/\/ Update collector state regardless of whether there are forwarded objects\n@@ -352,4 +356,1 @@\n-  if (!heap->collection_set()->is_empty() || has_in_place_promotions(heap)) {\n-    \/\/ Even if the collection set is empty, we need to do evacuation if there are regions to be promoted in place.\n-    \/\/ Degenerated evacuation takes responsibility for registering objects and setting the remembered set cards to dirty.\n-\n+  if (!heap->collection_set()->is_empty()) {\n@@ -361,1 +362,1 @@\n-    heap->set_has_forwarded_objects(!heap->collection_set()->is_empty());\n+    heap->set_has_forwarded_objects(true);\n@@ -364,1 +365,4 @@\n-      heap->verifier()->verify_after_concmark();\n+      ShenandoahVerifier::VerifySize sizeness = has_in_place_promotions(heap)\n+                                              ? ShenandoahVerifier::_verify_size_adjusted_for_padding\n+                                              : ShenandoahVerifier::_verify_size_exact;\n+      heap->verifier()->verify_after_concmark(sizeness);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-                                                                           bool concurrent) :\n+                                                                           bool concurrent, bool only_promote_regions) :\n@@ -61,0 +61,1 @@\n+  _only_promote_regions(only_promote_regions),\n@@ -71,1 +72,0 @@\n-    ShenandoahEvacOOMScope oom_evac_scope;\n@@ -75,1 +75,0 @@\n-    ShenandoahEvacOOMScope oom_evac_scope;\n@@ -81,0 +80,10 @@\n+  if (_only_promote_regions) {\n+    \/\/ No allocations will be made, do not enter oom-during-evac protocol.\n+    do_evacuations();\n+  } else {\n+    ShenandoahEvacOOMScope oom_evac_scope;\n+    do_evacuations();\n+  }\n+}\n+\n+void ShenandoahGenerationalEvacuationTask::do_evacuations() {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  bool _only_promote_regions;\n@@ -46,1 +47,1 @@\n-                                       bool concurrent);\n+                                       bool concurrent, bool only_promote_regions);\n@@ -50,1 +51,1 @@\n-\n+  void do_evacuations();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -173,0 +173,12 @@\n+void ShenandoahGenerationalHeap::evacuate_collection_set(bool concurrent) {\n+  ShenandoahRegionIterator regions;\n+  ShenandoahGenerationalEvacuationTask task(this, &regions, concurrent, false \/* only promote regions *\/);\n+  workers()->run_task(&task);\n+}\n+\n+void ShenandoahGenerationalHeap::promote_regions_in_place(bool concurrent) {\n+  ShenandoahRegionIterator regions;\n+  ShenandoahGenerationalEvacuationTask task(this, &regions, concurrent, true \/* only promote regions *\/);\n+  workers()->run_task(&task);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+  void evacuate_collection_set(bool concurrent) override;\n+  void promote_regions_in_place(bool concurrent);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1213,8 +1213,2 @@\n-  if (mode()->is_generational()) {\n-    ShenandoahRegionIterator regions;\n-    ShenandoahGenerationalEvacuationTask task(ShenandoahGenerationalHeap::heap(), &regions, concurrent);\n-    workers()->run_task(&task);\n-  } else {\n-    ShenandoahEvacuationTask task(this, _collection_set, concurrent);\n-    workers()->run_task(&task);\n-  }\n+  ShenandoahEvacuationTask task(this, _collection_set, concurrent);\n+  workers()->run_task(&task);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -472,1 +472,1 @@\n-  void evacuate_collection_set(bool concurrent);\n+  virtual void evacuate_collection_set(bool concurrent);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,2 @@\n-  bool has_in_place_promotions() const { return (_promotable_humongous_regions + _promotable_regular_regions) > 0; }\n+  size_t get_expected_in_place_promotions() const { return _promotable_humongous_regions + _promotable_regular_regions; }\n+  bool has_in_place_promotions() const { return get_expected_in_place_promotions() > 0; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-                                                                                       \\\n+  f(promote_in_place,                               \"Concurrent Promote Regions\")      \\\n@@ -157,0 +157,1 @@\n+  f(degen_gc_promote_regions,                       \"  Degen Promote Regions\")         \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1072,1 +1072,1 @@\n-void ShenandoahVerifier::verify_after_concmark() {\n+void ShenandoahVerifier::verify_after_concmark(ShenandoahVerifier::VerifySize sizeness) {\n@@ -1082,1 +1082,1 @@\n-          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n+          sizeness,          \/\/ expect generation and heap sizes to match exactly\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-  void verify_after_concmark();\n+  void verify_after_concmark(VerifySize sizeness);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}