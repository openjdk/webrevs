{"files":[{"patch":"@@ -380,3 +380,1 @@\n-  \/\/ We allow forwarding in young generation and marking in old generation\n-  \/\/ to happen simultaneously.\n-  assert(_heap->mode()->is_generational() || HAS_FWD == _heap->has_forwarded_objects(), \"Forwarded object status is sane\");\n+  assert(HAS_FWD == _heap->has_forwarded_objects(), \"Forwarded object status is sane\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-  }\n@@ -196,1 +195,0 @@\n-  if (heap->has_forwarded_objects()) {\n@@ -215,4 +213,17 @@\n-    \/\/ We chose not to evacuate because we found sufficient immediate garbage. Note that we\n-    \/\/ do not check for cancellation here because, at this point, the cycle is effectively\n-    \/\/ complete. If the cycle has been cancelled here, the control thread will detect it\n-    \/\/ on its next iteration and run a degenerated young cycle.\n+    \/\/ We chose not to evacuate because we found sufficient immediate garbage.\n+    \/\/ However, there may still be regions to promote in place, so do that now.\n+    if (has_in_place_promotions(heap)) {\n+      entry_promote_in_place();\n+\n+      \/\/ If the promote-in-place operation was cancelled, we can have the degenerated\n+      \/\/ cycle complete the operation. It will see that no evacuations are in progress,\n+      \/\/ and that there are regions wanting promotion. The risk with not handling the\n+      \/\/ cancellation would be failing to restore top for these regions and leaving\n+      \/\/ them unable to serve allocations for the old generation.\n+      if (check_cancellation_and_abort(ShenandoahDegenPoint::_degenerated_evac)) {\n+        return false;\n+      }\n+    }\n+\n+    \/\/ At this point, the cycle is effectively complete. If the cycle has been cancelled here,\n+    \/\/ the control thread will detect it on its next iteration and run a degenerated young cycle.\n@@ -513,0 +524,20 @@\n+void ShenandoahConcurrentGC::entry_promote_in_place() {\n+  shenandoah_assert_generational();\n+\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  TraceCollectorStats tcs(heap->monitoring_support()->concurrent_collection_counters());\n+\n+  static const char* msg = \"Promote in place\";\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::promote_in_place);\n+  EventMark em(\"%s\", msg);\n+\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_evac(),\n+                              \"promote in place\");\n+\n+  \/\/ Ultimately, the same closure handles in-place promotions for tenured regions. No objects will be moved.\n+  \/\/ The threads will still participate in the oom-evac-protocol, although no memory will be allocated for\n+  \/\/ in place promotions.\n+  op_evacuate();\n+}\n+\n@@ -692,4 +723,1 @@\n-    if (!heap->collection_set()->is_empty() || has_in_place_promotions(heap)) {\n-      \/\/ Even if the collection set is empty, we need to do evacuation if there are regions to be promoted in place.\n-      \/\/ Concurrent evacuation takes responsibility for registering objects and setting the remembered set cards to dirty.\n-\n+    if (!heap->collection_set()->is_empty()) {\n@@ -708,5 +736,2 @@\n-\n-      \/\/ Generational mode may promote objects in place during the evacuation phase.\n-      \/\/ If that is the only reason we are evacuating, we don't need to update references\n-      \/\/ and there will be no forwarded objects on the heap.\n-      heap->set_has_forwarded_objects(!heap->collection_set()->is_empty());\n+      \/\/ From here on, we need to update references.\n+      heap->set_has_forwarded_objects(true);\n@@ -715,7 +740,2 @@\n-      if (!heap->collection_set()->is_empty()) {\n-        \/\/ Iff objects will be evaluated, arm the nmethod barriers. These will be disarmed\n-        \/\/ under the same condition (established in prepare_concurrent_roots) after strong\n-        \/\/ root evacuation has completed (see op_strong_roots).\n-        ShenandoahCodeRoots::arm_nmethods_for_evac();\n-        ShenandoahStackWatermark::change_epoch_id();\n-      }\n+      ShenandoahCodeRoots::arm_nmethods_for_evac();\n+      ShenandoahStackWatermark::change_epoch_id();\n@@ -728,1 +748,4 @@\n-        heap->verifier()->verify_after_concmark();\n+        ShenandoahVerifier::VerifySize sizeness = has_in_place_promotions(heap)\n+                                                ? ShenandoahVerifier::_verify_size_adjusted_for_padding\n+                                                : ShenandoahVerifier::_verify_size_exact;\n+        heap->verifier()->verify_after_concmark(sizeness);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":46,"deletions":23,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -110,0 +110,3 @@\n+  \/\/ Called when the collection set is empty, but the generational mode has regions to promote in place\n+  void entry_promote_in_place();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -254,0 +254,4 @@\n+      } else if (has_in_place_promotions(heap)) {\n+        \/\/ We have nothing to evacuate, but there are still regions to promote in place.\n+        ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc_promote_regions);\n+        ShenandoahHeap::heap()->evacuate_collection_set(false \/* concurrent*\/);\n@@ -256,1 +260,1 @@\n-      \/\/ Update collector state regardless of whether or not there are forwarded objects\n+      \/\/ Update collector state regardless of whether there are forwarded objects\n@@ -352,4 +356,1 @@\n-  if (!heap->collection_set()->is_empty() || has_in_place_promotions(heap)) {\n-    \/\/ Even if the collection set is empty, we need to do evacuation if there are regions to be promoted in place.\n-    \/\/ Degenerated evacuation takes responsibility for registering objects and setting the remembered set cards to dirty.\n-\n+  if (!heap->collection_set()->is_empty()) {\n@@ -361,1 +362,1 @@\n-    heap->set_has_forwarded_objects(!heap->collection_set()->is_empty());\n+    heap->set_has_forwarded_objects(true);\n@@ -364,1 +365,4 @@\n-      heap->verifier()->verify_after_concmark();\n+      ShenandoahVerifier::VerifySize sizeness = has_in_place_promotions(heap)\n+                                              ? ShenandoahVerifier::_verify_size_adjusted_for_padding\n+                                              : ShenandoahVerifier::_verify_size_exact;\n+      heap->verifier()->verify_after_concmark(sizeness);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -151,1 +151,2 @@\n-  bool has_in_place_promotions() const { return (_promotable_humongous_regions + _promotable_regular_regions) > 0; }\n+  size_t get_expected_in_place_promotions() const { return _promotable_humongous_regions + _promotable_regular_regions; }\n+  bool has_in_place_promotions() const { return get_expected_in_place_promotions() > 0; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-                                                                                       \\\n+  f(promote_in_place,                               \"Concurrent Promote Regions\")      \\\n@@ -157,0 +157,1 @@\n+  f(degen_gc_promote_regions,                       \"  Degen Promote Regions\")         \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1072,1 +1072,1 @@\n-void ShenandoahVerifier::verify_after_concmark() {\n+void ShenandoahVerifier::verify_after_concmark(ShenandoahVerifier::VerifySize sizeness) {\n@@ -1082,1 +1082,1 @@\n-          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n+          sizeness,          \/\/ expect generation and heap sizes to match exactly\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-  void verify_after_concmark();\n+  void verify_after_concmark(VerifySize sizeness);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}