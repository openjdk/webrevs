{"files":[{"patch":"@@ -43,9 +43,0 @@\n-  \/\/ See comments in ShenandoahAdaptiveHeuristics::choose_collection_set_from_regiondata():\n-  \/\/ we do the same here, but with the following adjustments for generational mode:\n-  \/\/\n-  \/\/ In generational mode, the sort order within the data array is not strictly descending amounts\n-  \/\/ of garbage. In particular, regions that have reached tenure age will be sorted into this\n-  \/\/ array before younger regions that typically contain more garbage. This is one reason why,\n-  \/\/ for example, we continue examining regions even after rejecting a region that has\n-  \/\/ more live data than we can evacuate.\n-\n@@ -55,3 +46,1 @@\n-  size_t cur_young_garbage = add_preselected_regions_to_collection_set(cset, data, size);\n-\n-  choose_global_collection_set(cset, data, size, actual_free, cur_young_garbage);\n+  choose_global_collection_set(cset, data, size, actual_free, 0 \/* cur_young_garbage *\/);\n@@ -114,5 +103,1 @@\n-    if (cset->is_preselected(r->index())) {\n-      assert(false, \"There should be no preselected regions during GLOBAL GC\");\n-      \/\/ It isn't fatal, we just ignore it.\n-      continue;\n-    }\n+    assert(!cset->is_preselected(r->index()), \"There should be no preselected regions during GLOBAL GC\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.cpp","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -45,1 +45,2 @@\n-  \/\/ The logic for cset selection in adaptive is as follows:\n+  \/\/ See comments in ShenandoahAdaptiveHeuristics::choose_collection_set_from_regiondata():\n+  \/\/ we do the same here, but with the following adjustments for generational mode:\n@@ -47,19 +48,5 @@\n-  \/\/   1. We cannot get cset larger than available free space. Otherwise we guarantee OOME\n-  \/\/      during evacuation, and thus guarantee full GC. In practice, we also want to let\n-  \/\/      application to allocate something. This is why we limit CSet to some fraction of\n-  \/\/      available space. In non-overloaded heap, max_cset would contain all plausible candidates\n-  \/\/      over garbage threshold.\n-  \/\/\n-  \/\/   2. We should not get cset too low so that free threshold would not be met right\n-  \/\/      after the cycle. Otherwise we get back-to-back cycles for no reason if heap is\n-  \/\/      too fragmented. In non-overloaded non-fragmented heap min_garbage would be around zero.\n-  \/\/\n-  \/\/ Therefore, we start by sorting the regions by garbage. Then we unconditionally add the best candidates\n-  \/\/ before we meet min_garbage. Then we add all candidates that fit with a garbage threshold before\n-  \/\/ we hit max_cset. When max_cset is hit, we terminate the cset selection. Note that in this scheme,\n-  \/\/ ShenandoahGarbageThreshold is the soft threshold which would be ignored until min_garbage is hit.\n-\n-  \/\/ In generational mode, the sort order within the data array is not strictly descending amounts of garbage.  In\n-  \/\/ particular, regions that have reached tenure age will be sorted into this array before younger regions that contain\n-  \/\/ more garbage.  This represents one of the reasons why we keep looking at regions even after we decide, for example,\n-  \/\/ to exclude one of the regions because it might require evacuation of too much live data.\n+  \/\/ In generational mode, the sort order within the data array is not strictly descending amounts\n+  \/\/ of garbage. In particular, regions that have reached tenure age will be sorted into this\n+  \/\/ array before younger regions that typically contain more garbage. This is one reason why,\n+  \/\/ for example, we continue examining regions even after rejecting a region that has\n+  \/\/ more live data than we can evacuate.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"}]}