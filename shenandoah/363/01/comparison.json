{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":".github\/actions\/get-msys2\/action.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":".github\/workflows\/build-cross-compile.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+      - jdk*\n","filename":".github\/workflows\/main.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,6 @@\n-this_script_dir=`dirname $0`\n-this_script_dir=`cd $this_script_dir > \/dev\/null && pwd`\n+source_path=\"$(dirname ${0})\"\n+this_script_dir=\"$(cd -- \"${source_path}\" > \/dev\/null && pwd)\"\n+if test -z \"${this_script_dir}\"; then\n+  echo \"Error: Could not determine location of configure script\"\n+  exit 1\n+fi\n@@ -35,1 +39,1 @@\n-bash ${-:+-$-} -c \". $this_script_dir\/make\/autoconf\/configure\" $this_script_dir\/configure CHECKME $this_script_dir \"$@\"\n+bash ${-:+-$-} -c \". \\\"${this_script_dir}\/make\/autoconf\/configure\\\"\" \"${this_script_dir}\/configure\" CHECKME \"${this_script_dir}\" \"$@\"\n","filename":"configure","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -589,3 +589,6 @@\n-correctly, the system property <code>test.nss.lib.paths<\/code> is\n-required on Ubuntu 18.04 to specify the alternative NSS lib\n-directories.<\/p>\n+correctly, the system property\n+<code>jdk.test.lib.artifacts.&lt;NAME&gt;<\/code> is required on Ubuntu\n+18.04 to specify the alternative NSS lib directory. The\n+<code>&lt;NAME&gt;<\/code> component should be replaced with the name\n+element of the appropriate <code>@Artifact<\/code> class. (See\n+<code>test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java<\/code>)<\/p>\n@@ -594,1 +597,1 @@\n-    JTREG=&quot;JAVA_OPTIONS=-Dtest.nss.lib.paths=\/path\/to\/your\/latest\/NSS-libs&quot;<\/code><\/pre>\n+    JTREG=&quot;JAVA_OPTIONS=-Djdk.test.lib.artifacts.nsslib-linux_aarch64=\/path\/to\/NSS-libs&quot;<\/code><\/pre>\n","filename":"doc\/testing.html","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -607,2 +607,4 @@\n-correctly, the system property `test.nss.lib.paths` is required on Ubuntu 18.04\n-to specify the alternative NSS lib directories.\n+correctly, the system property `jdk.test.lib.artifacts.<NAME>` is required on\n+Ubuntu 18.04 to specify the alternative NSS lib directory. The `<NAME>`\n+component should be replaced with the name element of the appropriate\n+`@Artifact` class. (See `test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java`)\n@@ -614,1 +616,1 @@\n-    JTREG=\"JAVA_OPTIONS=-Dtest.nss.lib.paths=\/path\/to\/your\/latest\/NSS-libs\"\n+    JTREG=\"JAVA_OPTIONS=-Djdk.test.lib.artifacts.nsslib-linux_aarch64=\/path\/to\/NSS-libs\"\n","filename":"doc\/testing.md","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/CompileDemos.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/CompileModuleTools.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n-\t$(info $(_) make install           # Install the generated images locally)\n","filename":"make\/Global.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-    CAPSTONE_ARCH := CS_ARCH_ARM64\n+    CAPSTONE_ARCH := CS_ARCH_$(CAPSTONE_ARCH_AARCH64_NAME)\n","filename":"make\/Hsdis.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-#\n-# Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-default: install\n-\n-include $(SPEC)\n-\n-BINARIES := $(notdir $(wildcard $(JDK_IMAGE_DIR)\/bin\/*))\n-INSTALLDIR := openjdk-$(VERSION_SHORT)\n-\n-# Install the jdk image, in a very crude way. Not taking into\n-# account, how to install properly on macosx or windows etc.\n-install:\n-\techo Installing jdk image into $(INSTALL_PREFIX)\/jvm\/$(INSTALLDIR)\n-\techo and creating $(words $(BINARIES)) links from $(INSTALL_PREFIX)\/bin into the jdk.\n-\t$(MKDIR) -p $(INSTALL_PREFIX)\/jvm\/$(INSTALLDIR)\n-\t$(RM) -r $(INSTALL_PREFIX)\/jvm\/$(INSTALLDIR)\/*\n-\t$(CP) -rp $(JDK_IMAGE_DIR)\/* $(INSTALL_PREFIX)\/jvm\/$(INSTALLDIR)\n-\t$(MKDIR) -p $(INSTALL_PREFIX)\/bin\n-\t$(RM) $(addprefix $(INSTALL_PREFIX)\/bin\/, $(BINARIES))\n-\t$(foreach b, $(BINARIES), $(LN) -s $(INSTALL_PREFIX)\/jvm\/$(INSTALLDIR)\/bin\/$b $(INSTALL_PREFIX)\/bin\/$b &&) true\n","filename":"make\/Install.gmk","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -611,1 +611,1 @@\n-      java.base-copy jdk.jdeps-launchers\n+      java.base-copy jdk.jdeps-launchers jdk.compiler-launchers\n@@ -614,2 +614,2 @@\n-BUILDJDK_MODULES := $(sort $(foreach m, jdk.jlink $(INTERIM_IMAGE_MODULES), \\\n-    $(call FindTransitiveDepsForModule, $m) $m))\n+BUILDJDK_MODULES := $(sort $(foreach m, jdk.jlink jdk.compiler \\\n+    $(INTERIM_IMAGE_MODULES), $(call FindTransitiveDepsForModule, $m) $m))\n@@ -869,8 +869,0 @@\n-################################################################################\n-# Install targets\n-\n-$(eval $(call SetupTarget, install, \\\n-    MAKEFILE := Install, \\\n-    DEPS := product-images, \\\n-))\n-\n@@ -974,1 +966,14 @@\n-  jdk.compiler-gendata: $(GENSRC_MODULEINFO_TARGETS)\n+  jdk.compiler-gendata: $(GENSRC_MODULEINFO_TARGETS) $(JAVA_TARGETS)\n+  # jdk.compiler-gendata needs the BUILD_JDK. If the BUILD_JDK was supplied\n+  # externally, no extra prerequisites are needed.\n+  ifeq ($(CREATE_BUILDJDK), true)\n+    ifneq ($(CREATING_BUILDJDK), true)\n+      # When cross compiling and an external BUILD_JDK wasn't supplied, it's\n+      # produced by the create-buildjdk target.\n+      jdk.compiler-gendata: create-buildjdk\n+    endif\n+  else ifeq ($(EXTERNAL_BUILDJDK), false)\n+    # When not cross compiling, the BUILD_JDK is the interim jdk image, and\n+    # the javac launcher is needed.\n+    jdk.compiler-gendata: jdk.compiler-launchers\n+  endif\n","filename":"make\/Main.gmk","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/ReleaseFile.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/RunTestsPrebuilt.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/RunTestsPrebuiltSpec.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/ToolsJdk.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-include @TOPDIR@\/Makefile\n+include @WORKSPACE_ROOT@\/Makefile\n","filename":"make\/autoconf\/Makefile.in","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -523,2 +523,2 @@\n-  BUILDJDK_JAVA_FLAGS_SMALL=\"-Xms32M -Xmx512M -XX:TieredStopAtLevel=1\"\n-  AC_SUBST(BUILDJDK_JAVA_FLAGS_SMALL)\n+  BUILD_JAVA_FLAGS_SMALL=\"-Xms32M -Xmx512M -XX:TieredStopAtLevel=1\"\n+  AC_SUBST(BUILD_JAVA_FLAGS_SMALL)\n","filename":"make\/autoconf\/boot-jdk.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/autoconf\/buildjdk-spec.gmk.in","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,6 @@\n+\n+if [[ \"$TOPDIR\" =~ .*[[:space:]]+.* ]]; then\n+  echo \"Error: Build path containing space character is not supported\" 1>&2\n+  exit 1\n+fi\n+\n","filename":"make\/autoconf\/configure","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/autoconf\/flags-other.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/autoconf\/lib-ffi.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,13 @@\n+\n+  capstone_header=\"\\\"$CAPSTONE\/include\/capstone\/capstone.h\\\"\"\n+  AC_MSG_CHECKING([capstone aarch64 arch name])\n+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include $capstone_header],[[cs_arch test = CS_ARCH_AARCH64]])],\n+    [\n+      AC_MSG_RESULT([AARCH64])\n+      CAPSTONE_ARCH_AARCH64_NAME=\"AARCH64\"\n+    ],\n+    [\n+      AC_MSG_RESULT([ARM64])\n+      CAPSTONE_ARCH_AARCH64_NAME=\"ARM64\"\n+    ]\n+  )\n@@ -281,1 +294,1 @@\n-  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include $disasm_header],[[void foo() {init_disassemble_info(0, 0, 0, 0);}]])],\n+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include $disasm_header],[[init_disassemble_info(0, 0, 0, 0);]])],\n@@ -368,0 +381,1 @@\n+  AC_SUBST(CAPSTONE_ARCH_AARCH64_NAME)\n","filename":"make\/autoconf\/lib-hsdis.m4","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-CONFIGURE_COMMAND_LINE:=@CONFIGURE_COMMAND_LINE@\n+CONFIGURE_COMMAND_LINE := @CONFIGURE_COMMAND_LINE@\n@@ -36,1 +36,1 @@\n-CONFIGURE_START_DIR:=@CONFIGURE_START_DIR@\n+CONFIGURE_START_DIR := @CONFIGURE_START_DIR@\n@@ -44,1 +44,1 @@\n-SPEC:=@SPEC@\n+SPEC := @SPEC@\n@@ -52,3 +52,3 @@\n-X:=\n-SPACE:=$(X) $(X)\n-COMMA:=,\n+X :=\n+SPACE := $(X) $(X)\n+COMMA := ,\n@@ -69,2 +69,2 @@\n-OUTPUT_SYNC_SUPPORTED:=@OUTPUT_SYNC_SUPPORTED@\n-OUTPUT_SYNC:=@OUTPUT_SYNC@\n+OUTPUT_SYNC_SUPPORTED := @OUTPUT_SYNC_SUPPORTED@\n+OUTPUT_SYNC := @OUTPUT_SYNC@\n@@ -73,3 +73,3 @@\n-BASH:=@BASH@\n-BASH_ARGS:=@BASH_ARGS@\n-SHELL:=$(BASH) $(BASH_ARGS)\n+BASH := @BASH@\n+BASH_ARGS := @BASH_ARGS@\n+SHELL := $(BASH) $(BASH_ARGS)\n@@ -78,1 +78,1 @@\n-CONF_NAME:=@CONF_NAME@\n+CONF_NAME := @CONF_NAME@\n@@ -81,4 +81,4 @@\n-OPENJDK_TARGET_OS:=@OPENJDK_TARGET_OS@\n-OPENJDK_TARGET_OS_TYPE:=@OPENJDK_TARGET_OS_TYPE@\n-OPENJDK_TARGET_OS_ENV:=@OPENJDK_TARGET_OS_ENV@\n-OPENJDK_TARGET_OS_UPPERCASE:=@OPENJDK_TARGET_OS_UPPERCASE@\n+OPENJDK_TARGET_OS := @OPENJDK_TARGET_OS@\n+OPENJDK_TARGET_OS_TYPE := @OPENJDK_TARGET_OS_TYPE@\n+OPENJDK_TARGET_OS_ENV := @OPENJDK_TARGET_OS_ENV@\n+OPENJDK_TARGET_OS_UPPERCASE := @OPENJDK_TARGET_OS_UPPERCASE@\n@@ -86,4 +86,4 @@\n-OPENJDK_TARGET_CPU:=@OPENJDK_TARGET_CPU@\n-OPENJDK_TARGET_CPU_ARCH:=@OPENJDK_TARGET_CPU_ARCH@\n-OPENJDK_TARGET_CPU_BITS:=@OPENJDK_TARGET_CPU_BITS@\n-OPENJDK_TARGET_CPU_ENDIAN:=@OPENJDK_TARGET_CPU_ENDIAN@\n+OPENJDK_TARGET_CPU := @OPENJDK_TARGET_CPU@\n+OPENJDK_TARGET_CPU_ARCH := @OPENJDK_TARGET_CPU_ARCH@\n+OPENJDK_TARGET_CPU_BITS := @OPENJDK_TARGET_CPU_BITS@\n+OPENJDK_TARGET_CPU_ENDIAN := @OPENJDK_TARGET_CPU_ENDIAN@\n@@ -91,1 +91,1 @@\n-OPENJDK_TARGET_LIBC:=@OPENJDK_TARGET_LIBC@\n+OPENJDK_TARGET_LIBC := @OPENJDK_TARGET_LIBC@\n@@ -93,1 +93,1 @@\n-COMPILE_TYPE:=@COMPILE_TYPE@\n+COMPILE_TYPE := @COMPILE_TYPE@\n@@ -96,4 +96,4 @@\n-OPENJDK_TARGET_CPU_LEGACY:=@OPENJDK_TARGET_CPU_LEGACY@\n-OPENJDK_TARGET_CPU_LEGACY_LIB:=@OPENJDK_TARGET_CPU_LEGACY_LIB@\n-OPENJDK_TARGET_CPU_OSARCH:=@OPENJDK_TARGET_CPU_OSARCH@\n-OPENJDK_TARGET_OS_INCLUDE_SUBDIR:=@OPENJDK_TARGET_OS_INCLUDE_SUBDIR@\n+OPENJDK_TARGET_CPU_LEGACY := @OPENJDK_TARGET_CPU_LEGACY@\n+OPENJDK_TARGET_CPU_LEGACY_LIB := @OPENJDK_TARGET_CPU_LEGACY_LIB@\n+OPENJDK_TARGET_CPU_OSARCH := @OPENJDK_TARGET_CPU_OSARCH@\n+OPENJDK_TARGET_OS_INCLUDE_SUBDIR := @OPENJDK_TARGET_OS_INCLUDE_SUBDIR@\n@@ -110,1 +110,1 @@\n-OPENJDK_TARGET_BUNDLE_PLATFORM:=@OPENJDK_TARGET_BUNDLE_PLATFORM@\n+OPENJDK_TARGET_BUNDLE_PLATFORM := @OPENJDK_TARGET_BUNDLE_PLATFORM@\n@@ -115,3 +115,3 @@\n-OPENJDK_BUILD_OS:=@OPENJDK_BUILD_OS@\n-OPENJDK_BUILD_OS_TYPE:=@OPENJDK_BUILD_OS_TYPE@\n-OPENJDK_BUILD_OS_ENV:=@OPENJDK_BUILD_OS_ENV@\n+OPENJDK_BUILD_OS := @OPENJDK_BUILD_OS@\n+OPENJDK_BUILD_OS_TYPE := @OPENJDK_BUILD_OS_TYPE@\n+OPENJDK_BUILD_OS_ENV := @OPENJDK_BUILD_OS_ENV@\n@@ -119,4 +119,4 @@\n-OPENJDK_BUILD_CPU:=@OPENJDK_BUILD_CPU@\n-OPENJDK_BUILD_CPU_ARCH:=@OPENJDK_BUILD_CPU_ARCH@\n-OPENJDK_BUILD_CPU_BITS:=@OPENJDK_BUILD_CPU_BITS@\n-OPENJDK_BUILD_CPU_ENDIAN:=@OPENJDK_BUILD_CPU_ENDIAN@\n+OPENJDK_BUILD_CPU := @OPENJDK_BUILD_CPU@\n+OPENJDK_BUILD_CPU_ARCH := @OPENJDK_BUILD_CPU_ARCH@\n+OPENJDK_BUILD_CPU_BITS := @OPENJDK_BUILD_CPU_BITS@\n+OPENJDK_BUILD_CPU_ENDIAN := @OPENJDK_BUILD_CPU_ENDIAN@\n@@ -124,1 +124,1 @@\n-OPENJDK_BUILD_LIBC:=@OPENJDK_BUILD_LIBC@\n+OPENJDK_BUILD_LIBC := @OPENJDK_BUILD_LIBC@\n@@ -126,1 +126,1 @@\n-OPENJDK_BUILD_OS_INCLUDE_SUBDIR:=@OPENJDK_TARGET_OS_INCLUDE_SUBDIR@\n+OPENJDK_BUILD_OS_INCLUDE_SUBDIR := @OPENJDK_TARGET_OS_INCLUDE_SUBDIR@\n@@ -129,1 +129,1 @@\n-OPENJDK_MODULE_TARGET_PLATFORM:=@OPENJDK_MODULE_TARGET_PLATFORM@\n+OPENJDK_MODULE_TARGET_PLATFORM := @OPENJDK_MODULE_TARGET_PLATFORM@\n@@ -132,3 +132,3 @@\n-RELEASE_FILE_OS_NAME:=@RELEASE_FILE_OS_NAME@\n-RELEASE_FILE_OS_ARCH:=@RELEASE_FILE_OS_ARCH@\n-RELEASE_FILE_LIBC:=@RELEASE_FILE_LIBC@\n+RELEASE_FILE_OS_NAME := @RELEASE_FILE_OS_NAME@\n+RELEASE_FILE_OS_ARCH := @RELEASE_FILE_OS_ARCH@\n+RELEASE_FILE_LIBC := @RELEASE_FILE_LIBC@\n@@ -145,2 +145,2 @@\n-LIBM:=@LIBM@\n-LIBDL:=@LIBDL@\n+LIBM := @LIBM@\n+LIBDL := @LIBDL@\n@@ -172,1 +172,1 @@\n-TOPDIR:=@TOPDIR@\n+TOPDIR := @TOPDIR@\n@@ -175,12 +175,12 @@\n-WORKSPACE_ROOT:=@WORKSPACE_ROOT@\n-IMPORT_MODULES_CLASSES:=@IMPORT_MODULES_CLASSES@\n-IMPORT_MODULES_CMDS:=@IMPORT_MODULES_CMDS@\n-IMPORT_MODULES_LIBS:=@IMPORT_MODULES_LIBS@\n-IMPORT_MODULES_CONF:=@IMPORT_MODULES_CONF@\n-IMPORT_MODULES_LEGAL:=@IMPORT_MODULES_LEGAL@\n-IMPORT_MODULES_MAN:=@IMPORT_MODULES_MAN@\n-IMPORT_MODULES_SRC:=@IMPORT_MODULES_SRC@\n-IMPORT_MODULES_MAKE:=@IMPORT_MODULES_MAKE@\n-\n-COPYRIGHT_YEAR:=@COPYRIGHT_YEAR@\n-HOTSPOT_BUILD_TIME:=@HOTSPOT_BUILD_TIME@\n+WORKSPACE_ROOT := @WORKSPACE_ROOT@\n+IMPORT_MODULES_CLASSES := @IMPORT_MODULES_CLASSES@\n+IMPORT_MODULES_CMDS := @IMPORT_MODULES_CMDS@\n+IMPORT_MODULES_LIBS := @IMPORT_MODULES_LIBS@\n+IMPORT_MODULES_CONF := @IMPORT_MODULES_CONF@\n+IMPORT_MODULES_LEGAL := @IMPORT_MODULES_LEGAL@\n+IMPORT_MODULES_MAN := @IMPORT_MODULES_MAN@\n+IMPORT_MODULES_SRC := @IMPORT_MODULES_SRC@\n+IMPORT_MODULES_MAKE := @IMPORT_MODULES_MAKE@\n+\n+COPYRIGHT_YEAR := @COPYRIGHT_YEAR@\n+HOTSPOT_BUILD_TIME := @HOTSPOT_BUILD_TIME@\n@@ -189,14 +189,14 @@\n-LAUNCHER_NAME:=@LAUNCHER_NAME@\n-PRODUCT_NAME:=@PRODUCT_NAME@\n-PRODUCT_SUFFIX:=@PRODUCT_SUFFIX@\n-JDK_RC_PLATFORM_NAME:=@JDK_RC_PLATFORM_NAME@\n-JDK_RC_NAME:=@JDK_RC_NAME@\n-COMPANY_NAME:=@COMPANY_NAME@\n-HOTSPOT_VM_DISTRO:=@HOTSPOT_VM_DISTRO@\n-MACOSX_BUNDLE_NAME_BASE=@MACOSX_BUNDLE_NAME_BASE@\n-MACOSX_BUNDLE_ID_BASE=@MACOSX_BUNDLE_ID_BASE@\n-MACOSX_BUNDLE_BUILD_VERSION=@MACOSX_BUNDLE_BUILD_VERSION@\n-USERNAME:=@USERNAME@\n-VENDOR_URL:=@VENDOR_URL@\n-VENDOR_URL_BUG:=@VENDOR_URL_BUG@\n-VENDOR_URL_VM_BUG:=@VENDOR_URL_VM_BUG@\n+LAUNCHER_NAME := @LAUNCHER_NAME@\n+PRODUCT_NAME := @PRODUCT_NAME@\n+PRODUCT_SUFFIX := @PRODUCT_SUFFIX@\n+JDK_RC_PLATFORM_NAME := @JDK_RC_PLATFORM_NAME@\n+JDK_RC_NAME := @JDK_RC_NAME@\n+COMPANY_NAME := @COMPANY_NAME@\n+HOTSPOT_VM_DISTRO := @HOTSPOT_VM_DISTRO@\n+MACOSX_BUNDLE_NAME_BASE := @MACOSX_BUNDLE_NAME_BASE@\n+MACOSX_BUNDLE_ID_BASE := @MACOSX_BUNDLE_ID_BASE@\n+MACOSX_BUNDLE_BUILD_VERSION := @MACOSX_BUNDLE_BUILD_VERSION@\n+USERNAME := @USERNAME@\n+VENDOR_URL := @VENDOR_URL@\n+VENDOR_URL_BUG := @VENDOR_URL_BUG@\n+VENDOR_URL_VM_BUG := @VENDOR_URL_VM_BUG@\n@@ -301,1 +301,1 @@\n-RUNTIME_NAME=$(PRODUCT_NAME) $(PRODUCT_SUFFIX)\n+RUNTIME_NAME = $(PRODUCT_NAME) $(PRODUCT_SUFFIX)\n@@ -304,2 +304,2 @@\n-DEBUG_LEVEL:=@DEBUG_LEVEL@\n-HOTSPOT_DEBUG_LEVEL:=@HOTSPOT_DEBUG_LEVEL@\n+DEBUG_LEVEL := @DEBUG_LEVEL@\n+HOTSPOT_DEBUG_LEVEL := @HOTSPOT_DEBUG_LEVEL@\n@@ -345,2 +345,2 @@\n-SUPPORT_OUTPUTDIR=$(OUTPUTDIR)\/support\n-BUILDTOOLS_OUTPUTDIR=$(OUTPUTDIR)\/buildtools\n+SUPPORT_OUTPUTDIR = $(OUTPUTDIR)\/support\n+BUILDTOOLS_OUTPUTDIR = $(OUTPUTDIR)\/buildtools\n@@ -348,6 +348,6 @@\n-HOTSPOT_OUTPUTDIR=$(OUTPUTDIR)\/hotspot\n-JDK_OUTPUTDIR=$(OUTPUTDIR)\/jdk\n-IMAGES_OUTPUTDIR=$(OUTPUTDIR)\/images\n-BUNDLES_OUTPUTDIR=$(OUTPUTDIR)\/bundles\n-TESTMAKE_OUTPUTDIR=$(OUTPUTDIR)\/test-make\n-MAKESUPPORT_OUTPUTDIR=$(OUTPUTDIR)\/make-support\n+HOTSPOT_OUTPUTDIR = $(OUTPUTDIR)\/hotspot\n+JDK_OUTPUTDIR = $(OUTPUTDIR)\/jdk\n+IMAGES_OUTPUTDIR = $(OUTPUTDIR)\/images\n+BUNDLES_OUTPUTDIR = $(OUTPUTDIR)\/bundles\n+TESTMAKE_OUTPUTDIR = $(OUTPUTDIR)\/test-make\n+MAKESUPPORT_OUTPUTDIR = $(OUTPUTDIR)\/make-support\n@@ -356,2 +356,2 @@\n-CONFIGURESUPPORT_OUTPUTDIR:=@CONFIGURESUPPORT_OUTPUTDIR@\n-BUILDJDK_OUTPUTDIR=$(OUTPUTDIR)\/buildjdk\n+CONFIGURESUPPORT_OUTPUTDIR := @CONFIGURESUPPORT_OUTPUTDIR@\n+BUILDJDK_OUTPUTDIR = $(OUTPUTDIR)\/buildjdk\n@@ -380,0 +380,1 @@\n+CAPSTONE_ARCH_AARCH64_NAME := @CAPSTONE_ARCH_AARCH64_NAME@\n@@ -383,1 +384,1 @@\n-BOOT_JDK:=@BOOT_JDK@\n+BOOT_JDK := @BOOT_JDK@\n@@ -385,3 +386,3 @@\n-BUILD_JDK:=@BUILD_JDK@\n-CREATE_BUILDJDK:=@CREATE_BUILDJDK@\n-EXTERNAL_BUILDJDK:=@EXTERNAL_BUILDJDK@\n+BUILD_JDK := @BUILD_JDK@\n+CREATE_BUILDJDK := @CREATE_BUILDJDK@\n+EXTERNAL_BUILDJDK := @EXTERNAL_BUILDJDK@\n@@ -390,1 +391,1 @@\n-BOOT_JDK_JAR_SUPPORTS_DATE:=@BOOT_JDK_JAR_SUPPORTS_DATE@\n+BOOT_JDK_JAR_SUPPORTS_DATE := @BOOT_JDK_JAR_SUPPORTS_DATE@\n@@ -394,1 +395,1 @@\n-BOOT_JDK_SOURCETARGET:=@BOOT_JDK_SOURCETARGET@\n+BOOT_JDK_SOURCETARGET := @BOOT_JDK_SOURCETARGET@\n@@ -397,3 +398,3 @@\n-NUM_CORES:=@NUM_CORES@\n-MEMORY_SIZE:=@MEMORY_SIZE@\n-ENABLE_JAVAC_SERVER:=@ENABLE_JAVAC_SERVER@\n+NUM_CORES := @NUM_CORES@\n+MEMORY_SIZE := @MEMORY_SIZE@\n+ENABLE_JAVAC_SERVER := @ENABLE_JAVAC_SERVER@\n@@ -402,1 +403,1 @@\n-JAVAC_SERVER_DIR=$(MAKESUPPORT_OUTPUTDIR)\/javacservers\n+JAVAC_SERVER_DIR = $(MAKESUPPORT_OUTPUTDIR)\/javacservers\n@@ -405,2 +406,2 @@\n-JOBS?=@JOBS@\n-TEST_JOBS?=@TEST_JOBS@\n+JOBS ?= @JOBS@\n+TEST_JOBS ?= @TEST_JOBS@\n@@ -409,2 +410,2 @@\n-DEFAULT_MAKE_TARGET:=@DEFAULT_MAKE_TARGET@\n-DEFAULT_LOG:=@DEFAULT_LOG@\n+DEFAULT_MAKE_TARGET := @DEFAULT_MAKE_TARGET@\n+DEFAULT_LOG := @DEFAULT_LOG@\n@@ -413,13 +414,13 @@\n-ENABLE_FALLBACK_LINKER:=@ENABLE_FALLBACK_LINKER@\n-\n-FREETYPE_TO_USE:=@FREETYPE_TO_USE@\n-FREETYPE_LIBS:=@FREETYPE_LIBS@\n-FREETYPE_CFLAGS:=@FREETYPE_CFLAGS@\n-FONTCONFIG_CFLAGS:=@FONTCONFIG_CFLAGS@\n-CUPS_CFLAGS:=@CUPS_CFLAGS@\n-ALSA_LIBS:=@ALSA_LIBS@\n-ALSA_CFLAGS:=@ALSA_CFLAGS@\n-LIBFFI_LIBS:=@LIBFFI_LIBS@\n-LIBFFI_CFLAGS:=@LIBFFI_CFLAGS@\n-ENABLE_LIBFFI_BUNDLING:=@ENABLE_LIBFFI_BUNDLING@\n-LIBFFI_LIB_FILE:=@LIBFFI_LIB_FILE@\n+ENABLE_FALLBACK_LINKER := @ENABLE_FALLBACK_LINKER@\n+\n+FREETYPE_TO_USE := @FREETYPE_TO_USE@\n+FREETYPE_LIBS := @FREETYPE_LIBS@\n+FREETYPE_CFLAGS := @FREETYPE_CFLAGS@\n+FONTCONFIG_CFLAGS := @FONTCONFIG_CFLAGS@\n+CUPS_CFLAGS := @CUPS_CFLAGS@\n+ALSA_LIBS := @ALSA_LIBS@\n+ALSA_CFLAGS := @ALSA_CFLAGS@\n+LIBFFI_LIBS := @LIBFFI_LIBS@\n+LIBFFI_CFLAGS := @LIBFFI_CFLAGS@\n+ENABLE_LIBFFI_BUNDLING := @ENABLE_LIBFFI_BUNDLING@\n+LIBFFI_LIB_FILE := @LIBFFI_LIB_FILE@\n@@ -441,1 +442,1 @@\n-CACERTS_FILE=@CACERTS_FILE@\n+CACERTS_FILE := @CACERTS_FILE@\n@@ -443,1 +444,1 @@\n-CACERTS_SRC=@CACERTS_SRC@\n+CACERTS_SRC := @CACERTS_SRC@\n@@ -446,1 +447,1 @@\n-UNLIMITED_CRYPTO=@UNLIMITED_CRYPTO@\n+UNLIMITED_CRYPTO := @UNLIMITED_CRYPTO@\n@@ -448,5 +449,5 @@\n-GCOV_ENABLED=@GCOV_ENABLED@\n-JCOV_ENABLED=@JCOV_ENABLED@\n-JCOV_HOME=@JCOV_HOME@\n-JCOV_INPUT_JDK=@JCOV_INPUT_JDK@\n-JCOV_FILTERS=@JCOV_FILTERS@\n+GCOV_ENABLED := @GCOV_ENABLED@\n+JCOV_ENABLED := @JCOV_ENABLED@\n+JCOV_HOME := @JCOV_HOME@\n+JCOV_INPUT_JDK := @JCOV_INPUT_JDK@\n+JCOV_FILTERS := @JCOV_FILTERS@\n@@ -455,1 +456,1 @@\n-ASAN_ENABLED:=@ASAN_ENABLED@\n+ASAN_ENABLED := @ASAN_ENABLED@\n@@ -458,1 +459,1 @@\n-LSAN_ENABLED:=@LSAN_ENABLED@\n+LSAN_ENABLED := @LSAN_ENABLED@\n@@ -461,3 +462,3 @@\n-UBSAN_ENABLED:=@UBSAN_ENABLED@\n-UBSAN_CFLAGS:=@UBSAN_CFLAGS@\n-UBSAN_LDFLAGS:=@UBSAN_LDFLAGS@\n+UBSAN_ENABLED := @UBSAN_ENABLED@\n+UBSAN_CFLAGS := @UBSAN_CFLAGS@\n+UBSAN_LDFLAGS := @UBSAN_LDFLAGS@\n@@ -466,2 +467,2 @@\n-X_CFLAGS:=@X_CFLAGS@\n-X_LIBS:=@X_LIBS@\n+X_CFLAGS := @X_CFLAGS@\n+X_LIBS := @X_LIBS@\n@@ -470,1 +471,1 @@\n-MACOSX_VERSION_MIN=@MACOSX_VERSION_MIN@\n+MACOSX_VERSION_MIN := @MACOSX_VERSION_MIN@\n@@ -472,1 +473,1 @@\n-MACOSX_VERSION_MAX=@MACOSX_VERSION_MAX@\n+MACOSX_VERSION_MAX := @MACOSX_VERSION_MAX@\n@@ -475,2 +476,2 @@\n-MACOSX_CODESIGN_MODE:=@MACOSX_CODESIGN_MODE@\n-MACOSX_CODESIGN_IDENTITY=@MACOSX_CODESIGN_IDENTITY@\n+MACOSX_CODESIGN_MODE := @MACOSX_CODESIGN_MODE@\n+MACOSX_CODESIGN_IDENTITY := @MACOSX_CODESIGN_IDENTITY@\n@@ -479,1 +480,1 @@\n-TOOLCHAIN_TYPE:=@TOOLCHAIN_TYPE@\n+TOOLCHAIN_TYPE := @TOOLCHAIN_TYPE@\n@@ -488,2 +489,2 @@\n-COMPILER_TARGET_BITS_FLAG:=@COMPILER_TARGET_BITS_FLAG@\n-COMPILER_SUPPORTS_TARGET_BITS_FLAG=@COMPILER_SUPPORTS_TARGET_BITS_FLAG@\n+COMPILER_TARGET_BITS_FLAG := @COMPILER_TARGET_BITS_FLAG@\n+COMPILER_SUPPORTS_TARGET_BITS_FLAG := @COMPILER_SUPPORTS_TARGET_BITS_FLAG@\n@@ -492,1 +493,1 @@\n-COMPILER_COMMAND_FILE_FLAG:=@COMPILER_COMMAND_FILE_FLAG@\n+COMPILER_COMMAND_FILE_FLAG := @COMPILER_COMMAND_FILE_FLAG@\n@@ -496,1 +497,1 @@\n-COMPILER_BINDCMD_FILE_FLAG:=@COMPILER_BINDCMD_FILE_FLAG@\n+COMPILER_BINDCMD_FILE_FLAG := @COMPILER_BINDCMD_FILE_FLAG@\n@@ -498,3 +499,3 @@\n-CC_OUT_OPTION:=@CC_OUT_OPTION@\n-LD_OUT_OPTION:=@LD_OUT_OPTION@\n-AR_OUT_OPTION:=@AR_OUT_OPTION@\n+CC_OUT_OPTION := @CC_OUT_OPTION@\n+LD_OUT_OPTION := @LD_OUT_OPTION@\n+AR_OUT_OPTION := @AR_OUT_OPTION@\n@@ -503,12 +504,12 @@\n-C_O_FLAG_HIGHEST_JVM:=@C_O_FLAG_HIGHEST_JVM@\n-C_O_FLAG_HIGHEST:=@C_O_FLAG_HIGHEST@\n-C_O_FLAG_HI:=@C_O_FLAG_HI@\n-C_O_FLAG_NORM:=@C_O_FLAG_NORM@\n-C_O_FLAG_NONE:=@C_O_FLAG_NONE@\n-C_O_FLAG_SIZE:=@C_O_FLAG_SIZE@\n-CXX_O_FLAG_HIGHEST_JVM:=@CXX_O_FLAG_HIGHEST_JVM@\n-CXX_O_FLAG_HIGHEST:=@CXX_O_FLAG_HIGHEST@\n-CXX_O_FLAG_HI:=@CXX_O_FLAG_HI@\n-CXX_O_FLAG_NORM:=@CXX_O_FLAG_NORM@\n-CXX_O_FLAG_NONE:=@CXX_O_FLAG_NONE@\n-CXX_O_FLAG_SIZE:=@CXX_O_FLAG_SIZE@\n+C_O_FLAG_HIGHEST_JVM := @C_O_FLAG_HIGHEST_JVM@\n+C_O_FLAG_HIGHEST := @C_O_FLAG_HIGHEST@\n+C_O_FLAG_HI := @C_O_FLAG_HI@\n+C_O_FLAG_NORM := @C_O_FLAG_NORM@\n+C_O_FLAG_NONE := @C_O_FLAG_NONE@\n+C_O_FLAG_SIZE := @C_O_FLAG_SIZE@\n+CXX_O_FLAG_HIGHEST_JVM := @CXX_O_FLAG_HIGHEST_JVM@\n+CXX_O_FLAG_HIGHEST := @CXX_O_FLAG_HIGHEST@\n+CXX_O_FLAG_HI := @CXX_O_FLAG_HI@\n+CXX_O_FLAG_NORM := @CXX_O_FLAG_NORM@\n+CXX_O_FLAG_NONE := @CXX_O_FLAG_NONE@\n+CXX_O_FLAG_SIZE := @CXX_O_FLAG_SIZE@\n@@ -519,1 +520,1 @@\n-CFLAGS_WARNINGS_ARE_ERRORS:=@CFLAGS_WARNINGS_ARE_ERRORS@\n+CFLAGS_WARNINGS_ARE_ERRORS := @CFLAGS_WARNINGS_ARE_ERRORS@\n@@ -527,3 +528,3 @@\n-CFLAGS_CCACHE:=@CFLAGS_CCACHE@\n-ADLC_LANGSTD_CXXFLAGS=@ADLC_LANGSTD_CXXFLAGS@\n-ADLC_LDFLAGS=@ADLC_LDFLAGS@\n+CFLAGS_CCACHE := @CFLAGS_CCACHE@\n+ADLC_LANGSTD_CXXFLAGS := @ADLC_LANGSTD_CXXFLAGS@\n+ADLC_LDFLAGS := @ADLC_LDFLAGS@\n@@ -535,2 +536,2 @@\n-CFLAGS_JDKLIB:=@CFLAGS_JDKLIB@\n-CXXFLAGS_JDKLIB:=@CXXFLAGS_JDKLIB@\n+CFLAGS_JDKLIB := @CFLAGS_JDKLIB@\n+CXXFLAGS_JDKLIB := @CXXFLAGS_JDKLIB@\n@@ -539,2 +540,2 @@\n-CFLAGS_JDKEXE:=@CFLAGS_JDKEXE@\n-CXXFLAGS_JDKEXE:=@CXXFLAGS_JDKEXE@\n+CFLAGS_JDKEXE := @CFLAGS_JDKEXE@\n+CXXFLAGS_JDKEXE := @CXXFLAGS_JDKEXE@\n@@ -553,4 +554,4 @@\n-EXTRA_CFLAGS = @EXTRA_CFLAGS@\n-EXTRA_CXXFLAGS = @EXTRA_CXXFLAGS@\n-EXTRA_LDFLAGS = @EXTRA_LDFLAGS@\n-EXTRA_ASFLAGS = @EXTRA_ASFLAGS@\n+EXTRA_CFLAGS := @EXTRA_CFLAGS@\n+EXTRA_CXXFLAGS := @EXTRA_CXXFLAGS@\n+EXTRA_LDFLAGS := @EXTRA_LDFLAGS@\n+EXTRA_ASFLAGS := @EXTRA_ASFLAGS@\n@@ -568,2 +569,2 @@\n-LDFLAGS_JDKLIB:=@LDFLAGS_JDKLIB@\n-JDKLIB_LIBS:=@JDKLIB_LIBS@\n+LDFLAGS_JDKLIB := @LDFLAGS_JDKLIB@\n+JDKLIB_LIBS := @JDKLIB_LIBS@\n@@ -572,2 +573,2 @@\n-LDFLAGS_JDKEXE:=@LDFLAGS_JDKEXE@\n-JDKEXE_LIBS:=@JDKEXE_LIBS@\n+LDFLAGS_JDKEXE := @LDFLAGS_JDKEXE@\n+JDKEXE_LIBS := @JDKEXE_LIBS@\n@@ -576,1 +577,1 @@\n-LDFLAGS_CXX_JDK:=@LDFLAGS_CXX_JDK@\n+LDFLAGS_CXX_JDK := @LDFLAGS_CXX_JDK@\n@@ -579,1 +580,1 @@\n-LDFLAGS_CXX_PARTIAL_LINKING:=@LDFLAGS_CXX_PARTIAL_LINKING@\n+LDFLAGS_CXX_PARTIAL_LINKING := @LDFLAGS_CXX_PARTIAL_LINKING@\n@@ -584,1 +585,1 @@\n-LIBCXX:=@LIBCXX@\n+LIBCXX := @LIBCXX@\n@@ -587,1 +588,1 @@\n-LDFLAGS_TESTEXE:=@LDFLAGS_TESTEXE@\n+LDFLAGS_TESTEXE := @LDFLAGS_TESTEXE@\n@@ -598,4 +599,4 @@\n-BUILD_OBJCOPY:=@BUILD_OBJCOPY@\n-BUILD_STRIP:=@BUILD_STRIP@\n-BUILD_SYSROOT_CFLAGS:=@BUILD_SYSROOT_CFLAGS@\n-BUILD_SYSROOT_LDFLAGS:=@BUILD_SYSROOT_LDFLAGS@\n+BUILD_OBJCOPY := @BUILD_OBJCOPY@\n+BUILD_STRIP := @BUILD_STRIP@\n+BUILD_SYSROOT_CFLAGS := @BUILD_SYSROOT_CFLAGS@\n+BUILD_SYSROOT_LDFLAGS := @BUILD_SYSROOT_LDFLAGS@\n@@ -607,1 +608,1 @@\n-ARFLAGS:=@ARFLAGS@\n+ARFLAGS := @ARFLAGS@\n@@ -609,5 +610,5 @@\n-NM:=@NM@\n-NMFLAGS:=@NMFLAGS@\n-STRIP:=@STRIP@\n-OBJDUMP:=@OBJDUMP@\n-CXXFILT:=@CXXFILT@\n+NM := @NM@\n+NMFLAGS := @NMFLAGS@\n+STRIP := @STRIP@\n+OBJDUMP := @OBJDUMP@\n+CXXFILT := @CXXFILT@\n@@ -615,2 +616,2 @@\n-LIPO:=@LIPO@\n-INSTALL_NAME_TOOL:=@INSTALL_NAME_TOOL@\n+LIPO := @LIPO@\n+INSTALL_NAME_TOOL := @INSTALL_NAME_TOOL@\n@@ -622,1 +623,1 @@\n-SET_SHARED_LIBRARY_MAPFILE=@SET_SHARED_LIBRARY_MAPFILE@\n+SET_SHARED_LIBRARY_MAPFILE = @SET_SHARED_LIBRARY_MAPFILE@\n@@ -630,2 +631,2 @@\n-CFLAGS_DEBUG_SYMBOLS:=@CFLAGS_DEBUG_SYMBOLS@\n-ASFLAGS_DEBUG_SYMBOLS:=@ASFLAGS_DEBUG_SYMBOLS@\n+CFLAGS_DEBUG_SYMBOLS := @CFLAGS_DEBUG_SYMBOLS@\n+ASFLAGS_DEBUG_SYMBOLS := @ASFLAGS_DEBUG_SYMBOLS@\n@@ -635,1 +636,1 @@\n-COMPRESS_JARS=@COMPRESS_JARS@\n+COMPRESS_JARS := @COMPRESS_JARS@\n@@ -639,1 +640,1 @@\n-SET_SHARED_LIBRARY_NAME=@SET_SHARED_LIBRARY_NAME@\n+SET_SHARED_LIBRARY_NAME = @SET_SHARED_LIBRARY_NAME@\n@@ -641,1 +642,1 @@\n-SHARED_LIBRARY_FLAGS=@SHARED_LIBRARY_FLAGS@\n+SHARED_LIBRARY_FLAGS := @SHARED_LIBRARY_FLAGS@\n@@ -645,2 +646,2 @@\n-SET_SHARED_LIBRARY_ORIGIN=@SET_SHARED_LIBRARY_ORIGIN@\n-SET_EXECUTABLE_ORIGIN=@SET_EXECUTABLE_ORIGIN@\n+SET_SHARED_LIBRARY_ORIGIN = @SET_SHARED_LIBRARY_ORIGIN@\n+SET_EXECUTABLE_ORIGIN = @SET_EXECUTABLE_ORIGIN@\n@@ -649,1 +650,1 @@\n-# The SHARED_LIBRARY macro takes \"verify\" as and argument and returns:\n+# The SHARED_LIBRARY and STATIC_LIBRARY macros takes \"verify\" as and argument and returns:\n@@ -652,16 +653,17 @@\n-SHARED_LIBRARY=@SHARED_LIBRARY@\n-STATIC_LIBRARY=@STATIC_LIBRARY@\n-LIBRARY_PREFIX:=@LIBRARY_PREFIX@\n-SHARED_LIBRARY_SUFFIX:=@SHARED_LIBRARY_SUFFIX@\n-STATIC_LIBRARY_SUFFIX:=@STATIC_LIBRARY_SUFFIX@\n-EXECUTABLE_SUFFIX:=@EXECUTABLE_SUFFIX@\n-OBJ_SUFFIX:=@OBJ_SUFFIX@\n-STATIC_BUILD:=@STATIC_BUILD@\n-\n-STRIPFLAGS:=@STRIPFLAGS@\n-\n-JAVA_FLAGS:=@JAVA_FLAGS@\n-JAVA_FLAGS_BIG:=@JAVA_FLAGS_BIG@\n-JAVA_FLAGS_SMALL:=@JAVA_FLAGS_SMALL@\n-BUILDJDK_JAVA_FLAGS_SMALL:=@BUILDJDK_JAVA_FLAGS_SMALL@\n-JAVA_TOOL_FLAGS_SMALL:=@JAVA_TOOL_FLAGS_SMALL@\n+SHARED_LIBRARY = @SHARED_LIBRARY@\n+STATIC_LIBRARY = @STATIC_LIBRARY@\n+\n+LIBRARY_PREFIX := @LIBRARY_PREFIX@\n+SHARED_LIBRARY_SUFFIX := @SHARED_LIBRARY_SUFFIX@\n+STATIC_LIBRARY_SUFFIX := @STATIC_LIBRARY_SUFFIX@\n+EXECUTABLE_SUFFIX := @EXECUTABLE_SUFFIX@\n+OBJ_SUFFIX := @OBJ_SUFFIX@\n+STATIC_BUILD := @STATIC_BUILD@\n+\n+STRIPFLAGS := @STRIPFLAGS@\n+\n+JAVA_FLAGS := @JAVA_FLAGS@\n+JAVA_FLAGS_BIG := @JAVA_FLAGS_BIG@\n+JAVA_FLAGS_SMALL := @JAVA_FLAGS_SMALL@\n+BUILD_JAVA_FLAGS_SMALL := @BUILD_JAVA_FLAGS_SMALL@\n+JAVA_TOOL_FLAGS_SMALL := @JAVA_TOOL_FLAGS_SMALL@\n@@ -672,4 +674,4 @@\n-JAVA_CMD:=@JAVA@\n-JAVAC_CMD:=@JAVAC@\n-JAVADOC_CMD:=@JAVADOC@\n-JAR_CMD:=@JAR@\n+JAVA_CMD := @JAVA@\n+JAVAC_CMD := @JAVAC@\n+JAVADOC_CMD := @JAVADOC@\n+JAR_CMD := @JAR@\n@@ -692,3 +694,4 @@\n-BUILD_JAVA=@FIXPATH@ $(BUILD_JDK)\/bin\/java $(BUILD_JAVA_FLAGS)\n-BUILD_JAVAC=@FIXPATH@ $(BUILD_JDK)\/bin\/javac\n-BUILD_JAR=@FIXPATH@ $(BUILD_JDK)\/bin\/jar\n+BUILD_JAVA = @FIXPATH@ $(BUILD_JDK)\/bin\/java $(BUILD_JAVA_FLAGS)\n+BUILD_JAVA_SMALL = @FIXPATH@ $(BUILD_JDK)\/bin\/java $(BUILD_JAVA_FLAGS_SMALL)\n+BUILD_JAVAC = @FIXPATH@ $(BUILD_JDK)\/bin\/javac\n+BUILD_JAR = @FIXPATH@ $(BUILD_JDK)\/bin\/jar\n@@ -720,2 +723,2 @@\n-JAVAC_MAIN_CLASS = -m jdk.compiler.interim\/com.sun.tools.javac.Main\n-JAVADOC_MAIN_CLASS = -m jdk.javadoc.interim\/jdk.javadoc.internal.tool.Main\n+JAVAC_MAIN_CLASS := -m jdk.compiler.interim\/com.sun.tools.javac.Main\n+JAVADOC_MAIN_CLASS := -m jdk.javadoc.interim\/jdk.javadoc.internal.tool.Main\n@@ -725,1 +728,1 @@\n-NEW_JAVAC   = $(INTERIM_LANGTOOLS_ARGS) $(JAVAC_MAIN_CLASS)\n+NEW_JAVAC = $(INTERIM_LANGTOOLS_ARGS) $(JAVAC_MAIN_CLASS)\n@@ -728,2 +731,2 @@\n-JMOD_COMPRESS:=@JMOD_COMPRESS@\n-JLINK_KEEP_PACKAGED_MODULES:=@JLINK_KEEP_PACKAGED_MODULES@\n+JMOD_COMPRESS := @JMOD_COMPRESS@\n+JLINK_KEEP_PACKAGED_MODULES := @JLINK_KEEP_PACKAGED_MODULES@\n@@ -734,4 +737,4 @@\n-AWK:=@AWK@\n-BASENAME:=@BASENAME@\n-CAT:=@CAT@\n-CCACHE:=@CCACHE@\n+AWK := @AWK@\n+BASENAME := @BASENAME@\n+CAT := @CAT@\n+CCACHE := @CCACHE@\n@@ -739,62 +742,62 @@\n-CD:=cd\n-CHMOD:=@CHMOD@\n-CODESIGN:=@CODESIGN@\n-CP:=@CP@\n-CUT:=@CUT@\n-DATE:=@DATE@\n-IS_GNU_DATE:=@IS_GNU_DATE@\n-DIFF:=@DIFF@\n-DIRNAME:=@DIRNAME@\n-DSYMUTIL:=@DSYMUTIL@\n-FIND:=@FIND@\n-FIND_DELETE:=@FIND_DELETE@\n-FLOCK:=@FLOCK@\n-ECHO:=@ECHO@\n-EGREP:=@EGREP@\n-FGREP:=@FGREP@\n-GREP:=@GREP@\n-GZIP:=@GZIP@\n-HEAD:=@HEAD@\n-LS:=@LS@\n-LN:=@LN@\n-MIG:=@MIG@\n-MKDIR:=@MKDIR@\n-MV:=@MV@\n-NICE:=@NICE@\n-PANDOC:=@PANDOC@\n-PATCH:=@PATCH@\n-PRINTF:=@PRINTF@\n-READLINK:=@READLINK@\n-RM:=@RM@\n-RMDIR:=@RMDIR@\n-SED:=@SED@\n-SH:=@SH@\n-SORT:=@SORT@\n-TAR:=@TAR@\n-TAIL:=@TAIL@\n-TEE:=@TEE@\n-TIME:=@TIME@\n-IS_GNU_TIME:=@IS_GNU_TIME@\n-TR:=@TR@\n-TOUCH:=@TOUCH@\n-WC:=@WC@\n-XARGS:=@XARGS@\n-ZIPEXE:=@ZIPEXE@\n-UNZIP:=@UNZIP@\n-MT:=@MT@\n-RC:=@RC@\n-DUMPBIN:=@DUMPBIN@\n-PATHTOOL:=@PATHTOOL@\n-WSLPATH:=@WSLPATH@\n-LDD:=@LDD@\n-OTOOL:=@OTOOL@\n-READELF:=@READELF@\n-EXPR:=@EXPR@\n-FILE:=@FILE@\n-DOT:=@DOT@\n-GIT:=@GIT@\n-OBJCOPY:=@OBJCOPY@\n-SETFILE:=@SETFILE@\n-XATTR:=@XATTR@\n-JT_HOME:=@JT_HOME@\n-JIB_HOME:=@JIB_HOME@\n+CD := cd\n+CHMOD := @CHMOD@\n+CODESIGN := @CODESIGN@\n+CP := @CP@\n+CUT := @CUT@\n+DATE := @DATE@\n+IS_GNU_DATE := @IS_GNU_DATE@\n+DIFF := @DIFF@\n+DIRNAME := @DIRNAME@\n+DSYMUTIL := @DSYMUTIL@\n+FIND := @FIND@\n+FIND_DELETE := @FIND_DELETE@\n+FLOCK := @FLOCK@\n+ECHO := @ECHO@\n+EGREP := @EGREP@\n+FGREP := @FGREP@\n+GREP := @GREP@\n+GZIP := @GZIP@\n+HEAD := @HEAD@\n+LS := @LS@\n+LN := @LN@\n+MIG := @MIG@\n+MKDIR := @MKDIR@\n+MV := @MV@\n+NICE := @NICE@\n+PANDOC := @PANDOC@\n+PATCH := @PATCH@\n+PRINTF := @PRINTF@\n+READLINK := @READLINK@\n+RM := @RM@\n+RMDIR := @RMDIR@\n+SED := @SED@\n+SH := @SH@\n+SORT := @SORT@\n+TAR := @TAR@\n+TAIL := @TAIL@\n+TEE := @TEE@\n+TIME := @TIME@\n+IS_GNU_TIME := @IS_GNU_TIME@\n+TR := @TR@\n+TOUCH := @TOUCH@\n+WC := @WC@\n+XARGS := @XARGS@\n+ZIPEXE := @ZIPEXE@\n+UNZIP := @UNZIP@\n+MT := @MT@\n+RC := @RC@\n+DUMPBIN := @DUMPBIN@\n+PATHTOOL := @PATHTOOL@\n+WSLPATH := @WSLPATH@\n+LDD := @LDD@\n+OTOOL := @OTOOL@\n+READELF := @READELF@\n+EXPR := @EXPR@\n+FILE := @FILE@\n+DOT := @DOT@\n+GIT := @GIT@\n+OBJCOPY := @OBJCOPY@\n+SETFILE := @SETFILE@\n+XATTR := @XATTR@\n+JT_HOME := @JT_HOME@\n+JIB_HOME := @JIB_HOME@\n@@ -804,1 +807,1 @@\n-ULIMIT:=@ULIMIT@\n+ULIMIT := @ULIMIT@\n@@ -806,3 +809,3 @@\n-TAR_TYPE:=@TAR_TYPE@\n-TAR_INCLUDE_PARAM:=@TAR_INCLUDE_PARAM@\n-TAR_SUPPORTS_TRANSFORM:=@TAR_SUPPORTS_TRANSFORM@\n+TAR_TYPE := @TAR_TYPE@\n+TAR_INCLUDE_PARAM := @TAR_INCLUDE_PARAM@\n+TAR_SUPPORTS_TRANSFORM := @TAR_SUPPORTS_TRANSFORM@\n@@ -811,63 +814,12 @@\n-USE_EXTERNAL_LIBJPEG:=@USE_EXTERNAL_LIBJPEG@\n-USE_EXTERNAL_LIBGIF:=@USE_EXTERNAL_LIBGIF@\n-USE_EXTERNAL_LIBZ:=@USE_EXTERNAL_LIBZ@\n-LIBZ_CFLAGS:=@LIBZ_CFLAGS@\n-LIBZ_LIBS:=@LIBZ_LIBS@\n-LIBZIP_CAN_USE_MMAP:=@LIBZIP_CAN_USE_MMAP@\n-MSVCR_DLL:=@MSVCR_DLL@\n-VCRUNTIME_1_DLL:=@VCRUNTIME_1_DLL@\n-MSVCP_DLL:=@MSVCP_DLL@\n-UCRT_DLL_DIR:=@UCRT_DLL_DIR@\n-ENABLE_PANDOC:=@ENABLE_PANDOC@\n-PANDOC_MARKDOWN_FLAG:=@PANDOC_MARKDOWN_FLAG@\n-\n-####################################################\n-#\n-# INSTALLATION\n-#\n-\n-# Common prefix for all installed files. Defaults to \/usr\/local,\n-# but \/opt\/myjdk is another common version.\n-INSTALL_PREFIX=@prefix@\n-\n-# Directories containing architecture-dependent files should be relative to exec_prefix\n-INSTALL_EXECPREFIX=@exec_prefix@\n-\n-# java,javac,javap etc are installed here.\n-INSTALL_BINDIR=@bindir@\n-\n-# Read only architecture-independent data\n-INSTALL_DATADIR=@datadir@\n-\n-# Root of above.\n-INSTALL_DATAROOTDIR=@datarootdir@\n-\n-# Doc files, other than info and man.\n-INSTALL_DOCDIR=@docdir@\n-\n-# Html documentation\n-INSTALL_HTMLDIR=@htmldir@\n-\n-# Installing C header files, JNI headers for example.\n-INSTALL_INCLUDEDIR=@includedir@\n-\n-# Installing library files....\n-INSTALL_INCLUDEDIR=@libdir@\n-\n-# Executables that other programs run.\n-INSTALL_LIBEXECDIR=@libexecdir@\n-\n-# Locale-dependent but architecture-independent data, such as message catalogs.\n-INSTALL_LOCALEDIR=@localedir@\n-\n-# Modifiable single-machine data\n-INSTALL_LOCALSTATEDIR=@localstatedir@\n-\n-# Man pages\n-INSTALL_MANDIR=@mandir@\n-\n-# Modifiable architecture-independent data.\n-INSTALL_SHAREDSTATEDIR=@sharedstatedir@\n-\n-# Read-only single-machine data\n-INSTALL_SYSCONFDIR=@sysconfdir@\n+USE_EXTERNAL_LIBJPEG := @USE_EXTERNAL_LIBJPEG@\n+USE_EXTERNAL_LIBGIF := @USE_EXTERNAL_LIBGIF@\n+USE_EXTERNAL_LIBZ := @USE_EXTERNAL_LIBZ@\n+LIBZ_CFLAGS := @LIBZ_CFLAGS@\n+LIBZ_LIBS := @LIBZ_LIBS@\n+LIBZIP_CAN_USE_MMAP := @LIBZIP_CAN_USE_MMAP@\n+MSVCR_DLL := @MSVCR_DLL@\n+VCRUNTIME_1_DLL := @VCRUNTIME_1_DLL@\n+MSVCP_DLL := @MSVCP_DLL@\n+UCRT_DLL_DIR := @UCRT_DLL_DIR@\n+ENABLE_PANDOC := @ENABLE_PANDOC@\n+PANDOC_MARKDOWN_FLAG := @PANDOC_MARKDOWN_FLAG@\n@@ -880,3 +832,3 @@\n-USE_EXTERNAL_LCMS:=@USE_EXTERNAL_LCMS@\n-LCMS_CFLAGS:=@LCMS_CFLAGS@\n-LCMS_LIBS:=@LCMS_LIBS@\n+USE_EXTERNAL_LCMS := @USE_EXTERNAL_LCMS@\n+LCMS_CFLAGS := @LCMS_CFLAGS@\n+LCMS_LIBS := @LCMS_LIBS@\n@@ -884,3 +836,3 @@\n-USE_EXTERNAL_HARFBUZZ:=@USE_EXTERNAL_HARFBUZZ@\n-HARFBUZZ_CFLAGS:=@HARFBUZZ_CFLAGS@\n-HARFBUZZ_LIBS:=@HARFBUZZ_LIBS@\n+USE_EXTERNAL_HARFBUZZ := @USE_EXTERNAL_HARFBUZZ@\n+HARFBUZZ_CFLAGS := @HARFBUZZ_CFLAGS@\n+HARFBUZZ_LIBS := @HARFBUZZ_LIBS@\n@@ -888,3 +840,3 @@\n-USE_EXTERNAL_LIBPNG:=@USE_EXTERNAL_LIBPNG@\n-PNG_LIBS:=@PNG_LIBS@\n-PNG_CFLAGS:=@PNG_CFLAGS@\n+USE_EXTERNAL_LIBPNG := @USE_EXTERNAL_LIBPNG@\n+PNG_LIBS := @PNG_LIBS@\n+PNG_CFLAGS := @PNG_CFLAGS@\n@@ -897,3 +849,3 @@\n-INCLUDE_SA=@INCLUDE_SA@\n-INCLUDE_JVMCI=@INCLUDE_JVMCI@\n-INCLUDE_COMPILER2=@INCLUDE_COMPILER2@\n+INCLUDE_SA := @INCLUDE_SA@\n+INCLUDE_JVMCI := @INCLUDE_JVMCI@\n+INCLUDE_COMPILER2 := @INCLUDE_COMPILER2@\n@@ -901,3 +853,3 @@\n-OS_VERSION_MAJOR:=@OS_VERSION_MAJOR@\n-OS_VERSION_MINOR:=@OS_VERSION_MINOR@\n-OS_VERSION_MICRO:=@OS_VERSION_MICRO@\n+OS_VERSION_MAJOR := @OS_VERSION_MAJOR@\n+OS_VERSION_MINOR := @OS_VERSION_MINOR@\n+OS_VERSION_MICRO := @OS_VERSION_MICRO@\n@@ -906,2 +858,2 @@\n-JDK_IMAGE_SUBDIR:=jdk\n-JRE_IMAGE_SUBDIR:=jre\n+JDK_IMAGE_SUBDIR := jdk\n+JRE_IMAGE_SUBDIR := jre\n@@ -911,2 +863,2 @@\n-JDK_IMAGE_DIR=$(IMAGES_OUTPUTDIR)\/$(JDK_IMAGE_SUBDIR)\n-JRE_IMAGE_DIR=$(IMAGES_OUTPUTDIR)\/$(JRE_IMAGE_SUBDIR)\n+JDK_IMAGE_DIR = $(IMAGES_OUTPUTDIR)\/$(JDK_IMAGE_SUBDIR)\n+JRE_IMAGE_DIR = $(IMAGES_OUTPUTDIR)\/$(JRE_IMAGE_SUBDIR)\n@@ -916,2 +868,2 @@\n-TEST_IMAGE_SUBDIR:=test\n-TEST_IMAGE_DIR=$(IMAGES_OUTPUTDIR)\/$(TEST_IMAGE_SUBDIR)\n+TEST_IMAGE_SUBDIR := test\n+TEST_IMAGE_DIR = $(IMAGES_OUTPUTDIR)\/$(TEST_IMAGE_SUBDIR)\n@@ -920,2 +872,2 @@\n-SYMBOLS_IMAGE_SUBDIR:=symbols\n-SYMBOLS_IMAGE_DIR=$(IMAGES_OUTPUTDIR)\/$(SYMBOLS_IMAGE_SUBDIR)\n+SYMBOLS_IMAGE_SUBDIR := symbols\n+SYMBOLS_IMAGE_DIR = $(IMAGES_OUTPUTDIR)\/$(SYMBOLS_IMAGE_SUBDIR)\n@@ -950,14 +902,14 @@\n-JDK_MACOSX_BUNDLE_SUBDIR=jdk-bundle\n-JRE_MACOSX_BUNDLE_SUBDIR=jre-bundle\n-JDK_MACOSX_BUNDLE_SUBDIR_SIGNED=jdk-bundle-signed\n-JRE_MACOSX_BUNDLE_SUBDIR_SIGNED=jre-bundle-signed\n-JDK_MACOSX_BUNDLE_DIR=$(IMAGES_OUTPUTDIR)\/$(JDK_MACOSX_BUNDLE_SUBDIR)\n-JRE_MACOSX_BUNDLE_DIR=$(IMAGES_OUTPUTDIR)\/$(JRE_MACOSX_BUNDLE_SUBDIR)\n-JDK_MACOSX_BUNDLE_DIR_SIGNED=$(IMAGES_OUTPUTDIR)\/$(JDK_MACOSX_BUNDLE_SUBDIR_SIGNED)\n-JRE_MACOSX_BUNDLE_DIR_SIGNED=$(IMAGES_OUTPUTDIR)\/$(JRE_MACOSX_BUNDLE_SUBDIR_SIGNED)\n-JDK_MACOSX_BUNDLE_TOP_DIR=jdk-$(VERSION_NUMBER).jdk\n-JRE_MACOSX_BUNDLE_TOP_DIR=jre-$(VERSION_NUMBER).jre\n-JDK_MACOSX_CONTENTS_SUBDIR=$(JDK_MACOSX_BUNDLE_TOP_DIR)\/Contents\n-JRE_MACOSX_CONTENTS_SUBDIR=$(JRE_MACOSX_BUNDLE_TOP_DIR)\/Contents\n-JDK_MACOSX_CONTENTS_DIR=$(JDK_MACOSX_BUNDLE_DIR)\/$(JDK_MACOSX_CONTENTS_SUBDIR)\n-JRE_MACOSX_CONTENTS_DIR=$(JRE_MACOSX_BUNDLE_DIR)\/$(JRE_MACOSX_CONTENTS_SUBDIR)\n+JDK_MACOSX_BUNDLE_SUBDIR := jdk-bundle\n+JRE_MACOSX_BUNDLE_SUBDIR := jre-bundle\n+JDK_MACOSX_BUNDLE_SUBDIR_SIGNED := jdk-bundle-signed\n+JRE_MACOSX_BUNDLE_SUBDIR_SIGNED := jre-bundle-signed\n+JDK_MACOSX_BUNDLE_DIR = $(IMAGES_OUTPUTDIR)\/$(JDK_MACOSX_BUNDLE_SUBDIR)\n+JRE_MACOSX_BUNDLE_DIR = $(IMAGES_OUTPUTDIR)\/$(JRE_MACOSX_BUNDLE_SUBDIR)\n+JDK_MACOSX_BUNDLE_DIR_SIGNED = $(IMAGES_OUTPUTDIR)\/$(JDK_MACOSX_BUNDLE_SUBDIR_SIGNED)\n+JRE_MACOSX_BUNDLE_DIR_SIGNED = $(IMAGES_OUTPUTDIR)\/$(JRE_MACOSX_BUNDLE_SUBDIR_SIGNED)\n+JDK_MACOSX_BUNDLE_TOP_DIR = jdk-$(VERSION_NUMBER).jdk\n+JRE_MACOSX_BUNDLE_TOP_DIR = jre-$(VERSION_NUMBER).jre\n+JDK_MACOSX_CONTENTS_SUBDIR = $(JDK_MACOSX_BUNDLE_TOP_DIR)\/Contents\n+JRE_MACOSX_CONTENTS_SUBDIR = $(JRE_MACOSX_BUNDLE_TOP_DIR)\/Contents\n+JDK_MACOSX_CONTENTS_DIR = $(JDK_MACOSX_BUNDLE_DIR)\/$(JDK_MACOSX_CONTENTS_SUBDIR)\n+JRE_MACOSX_CONTENTS_DIR = $(JRE_MACOSX_BUNDLE_DIR)\/$(JRE_MACOSX_CONTENTS_SUBDIR)\n@@ -995,2 +947,2 @@\n-JRE_BUNDLE :=  $(BUNDLES_OUTPUTDIR)\/$(JRE_BUNDLE_NAME)\n-JDK_SYMBOLS_BUNDLE :=  $(BUNDLES_OUTPUTDIR)\/$(JDK_SYMBOLS_BUNDLE_NAME)\n+JRE_BUNDLE := $(BUNDLES_OUTPUTDIR)\/$(JRE_BUNDLE_NAME)\n+JDK_SYMBOLS_BUNDLE := $(BUNDLES_OUTPUTDIR)\/$(JDK_SYMBOLS_BUNDLE_NAME)\n@@ -998,4 +950,4 @@\n-TEST_BUNDLE :=  $(BUNDLES_OUTPUTDIR)\/$(TEST_BUNDLE_NAME)\n-DOCS_JDK_BUNDLE :=  $(BUNDLES_OUTPUTDIR)\/$(DOCS_JDK_BUNDLE_NAME)\n-DOCS_JAVASE_BUNDLE :=  $(BUNDLES_OUTPUTDIR)\/$(DOCS_JAVASE_BUNDLE_NAME)\n-DOCS_REFERENCE_BUNDLE :=  $(BUNDLES_OUTPUTDIR)\/$(DOCS_REFERENCE_BUNDLE_NAME)\n+TEST_BUNDLE := $(BUNDLES_OUTPUTDIR)\/$(TEST_BUNDLE_NAME)\n+DOCS_JDK_BUNDLE := $(BUNDLES_OUTPUTDIR)\/$(DOCS_JDK_BUNDLE_NAME)\n+DOCS_JAVASE_BUNDLE := $(BUNDLES_OUTPUTDIR)\/$(DOCS_JAVASE_BUNDLE_NAME)\n+DOCS_REFERENCE_BUNDLE := $(BUNDLES_OUTPUTDIR)\/$(DOCS_REFERENCE_BUNDLE_NAME)\n","filename":"make\/autoconf\/spec.gmk.in","additions":345,"deletions":393,"binary":false,"changes":738,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/common\/MakeIO.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/common\/Modules.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/common\/ProcessMarkdown.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -410,0 +410,2 @@\n+    var cross_compiling = input.build_platform != input.target_platform;\n+\n@@ -487,1 +489,0 @@\n-            build_cpu: \"x64\",\n@@ -490,1 +491,0 @@\n-                \"--openjdk-target=aarch64-linux-gnu\",\n@@ -494,1 +494,1 @@\n-            ],\n+\t    ].concat(cross_compiling ? [\"--openjdk-target=aarch64-linux-gnu\"] : []),\n","filename":"make\/conf\/jib-profiles.js","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -206,1 +206,0 @@\n-JVM_SupportsCX8\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/data\/ubsan\/ubsan_default_options.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/data\/ubsan\/ubsan_default_options.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/devkit\/createMacosxDevkit.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/hotspot\/lib\/CompileGtest.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/hotspot\/lib\/JvmFlags.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/ide\/eclipse\/CreateWorkspace.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/ide\/idea\/jdk\/template\/src\/idea\/JdkIdeaAntLogger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/ide\/idea\/langtools\/template\/src\/idea\/LangtoolsIdeaAntLogger.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/ide\/visualstudio\/hotspot\/CreateVSProject.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/ide\/visualstudio\/hotspot\/src\/classes\/build\/tools\/projectcreator\/WinGammaPlatformVC10.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/ResourceBundleGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/jdk\/src\/classes\/build\/tools\/depend\/Depend.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/jdk\/src\/classes\/build\/tools\/depend\/DependTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatecharacter\/PropList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,0 +153,1 @@\n+import java.nio.file.DirectoryStream;\n@@ -154,0 +155,1 @@\n+import java.util.function.Consumer;\n@@ -231,1 +233,1 @@\n-                              long timestamp, String currentVersion, String systemModules) throws IOException {\n+                              long timestamp, String currentVersion, String preReleaseTag, String moduleClasses) throws IOException {\n@@ -236,0 +238,14 @@\n+        int currentVersionParsed = Integer.parseInt(currentVersion);\n+\n+        currentVersion = Integer.toString(currentVersionParsed, Character.MAX_RADIX);\n+        currentVersion = currentVersion.toUpperCase(Locale.ROOT);\n+\n+        String previousVersion = Integer.toString(currentVersionParsed - 1, Character.MAX_RADIX);\n+\n+        previousVersion = previousVersion.toUpperCase(Locale.ROOT);\n+\n+        \/\/load current version classes:\n+        Path moduleClassPath = Paths.get(moduleClasses);\n+\n+        loadVersionClassesFromDirectory(data.classes, data.modules, moduleClassPath, currentVersion, previousVersion);\n+\n@@ -244,2 +260,0 @@\n-                List<String> versionsList =\n-                        Collections.singletonList(mhd.versions);\n@@ -249,1 +263,10 @@\n-                                        versionsList);\n+                                        mhd.versions,\n+                                        version -> {\n+                                            String versionString = Character.toString(version);\n+                                            int versionNumber = Integer.parseInt(versionString, Character.MAX_RADIX);\n+                                            versionString = Integer.toString(versionNumber);\n+                                            if (versionNumber == currentVersionParsed && !preReleaseTag.isEmpty()) {\n+                                                versionString = versionString + \"-\" + preReleaseTag;\n+                                            }\n+                                            return versionString;\n+                                        });\n@@ -296,7 +319,0 @@\n-        currentVersion = Integer.toString(Integer.parseInt(currentVersion), Character.MAX_RADIX);\n-        currentVersion = currentVersion.toUpperCase(Locale.ROOT);\n-\n-        openDirectory(directory2FileData, currentVersion + \"\/\")\n-                .add(new FileData(currentVersion + \"\/system-modules\",\n-                                  Files.readAllBytes(Paths.get(systemModules))));\n-\n@@ -791,1 +807,2 @@\n-                                 Iterable<String> versions)\n+                                 String versions,\n+                                 Function<Character, String> version2ModuleVersion)\n@@ -793,2 +810,5 @@\n-        for (String ver : versions) {\n-            writeModule(directory2FileData, moduleDescription, header, ver);\n+        \/\/ensure every module-info.class is written separatelly,\n+        \/\/so that the correct version is used for it:\n+        for (char ver : versions.toCharArray()) {\n+            writeModule(directory2FileData, moduleDescription, header, ver,\n+                        version2ModuleVersion);\n@@ -802,1 +822,2 @@\n-                    String version) throws IOException {\n+                    char version,\n+                    Function<Character, String> version2ModuleVersion) throws IOException {\n@@ -810,1 +831,3 @@\n-        addAttributes(moduleDescription, header, constantPool, attributesMap);\n+        String versionString = Character.toString(version);\n+        addAttributes(moduleDescription, header, constantPool, attributesMap,\n+                      version2ModuleVersion.apply(version));\n@@ -826,1 +849,1 @@\n-        doWrite(directory2FileData, version, moduleDescription.name, \"module-info\" + EXTENSION, classFile);\n+        doWrite(directory2FileData, versionString, moduleDescription.name, \"module-info\" + EXTENSION, classFile);\n@@ -927,1 +950,2 @@\n-                               Map<String, Attribute> attributes) {\n+                               Map<String, Attribute> attributes,\n+                               String moduleVersion) {\n@@ -948,0 +972,1 @@\n+        int versionIdx = addString(cp, moduleVersion);\n@@ -953,1 +978,1 @@\n-                             0,\n+                             versionIdx,\n@@ -1126,2 +1151,3 @@\n-                        .map(p -> new MethodParameters_attribute.Entry(addString(constantPool, p.name),\n-                                                                        p.flags))\n+                        .map(p -> new MethodParameters_attribute.Entry(p.name == null || p.name.isEmpty() ? 0\n+                                                                                                          : addString(constantPool, p.name),\n+                                                                       p.flags))\n@@ -1495,1 +1521,1 @@\n-        ExcludeIncludeList currentEIList = excludesIncludes;\n+        ExcludeIncludeList currentEIList;\n@@ -1512,0 +1538,2 @@\n+        } else {\n+            currentEIList = excludesIncludes;\n@@ -1515,0 +1543,1 @@\n+        Map<String, String> extraModulesPackagesToDerive = new HashMap<>();\n@@ -1519,1 +1548,20 @@\n-                                 currentEIList, version);\n+                                 currentEIList, version,\n+                                 cf -> {\n+                                     PermittedSubclasses_attribute permitted = (PermittedSubclasses_attribute) cf.getAttribute(Attribute.PermittedSubclasses);\n+                                     if (permitted != null) {\n+                                         try {\n+                                             String currentPack = cf.getName().substring(0, cf.getName().lastIndexOf('\/'));\n+\n+                                             for (int i = 0; i < permitted.subtypes.length; i++) {\n+                                                 String permittedClassName = cf.constant_pool.getClassInfo(permitted.subtypes[i]).getName();\n+                                                 if (!currentEIList.accepts(permittedClassName, false)) {\n+                                                     String permittedPack = permittedClassName.substring(0, permittedClassName.lastIndexOf('\/'));\n+\n+                                                     extraModulesPackagesToDerive.put(permittedPack, currentPack);\n+                                                 }\n+                                             }\n+                                         } catch (ConstantPoolException ex) {\n+                                             throw new IllegalStateException(ex);\n+                                         }\n+                                     }\n+                                 });\n@@ -1525,0 +1573,141 @@\n+        \/\/derive extra module packages for permitted types based on on their supertypes:\n+        boolean modified;\n+\n+        do {\n+            modified = false;\n+\n+            for (Iterator<Entry<String, String>> it = extraModulesPackagesToDerive.entrySet().iterator(); it.hasNext();) {\n+                Entry<String, String> e = it.next();\n+                Optional<ModuleHeaderDescription> module = currentVersionModules.values().stream().map(md -> md.header.get(0)).filter(d -> containsPackage(d, e.getValue())).findAny();\n+                if (module.isPresent()) {\n+                    if (!module.get().extraModulePackages.contains(e.getKey())) {\n+                        module.get().extraModulePackages.add(e.getKey());\n+                    }\n+                    it.remove();\n+                    modified = true;\n+                }\n+            }\n+        } while (modified);\n+\n+        if (!extraModulesPackagesToDerive.isEmpty()) {\n+            throw new AssertionError(\"Cannot derive some owning modules: \" + extraModulesPackagesToDerive);\n+        }\n+\n+        finishClassLoading(classes, modules, currentVersionModules, currentVersionClasses, currentEIList, version, baseline);\n+    }\n+\n+    private boolean containsPackage(ModuleHeaderDescription module, String pack) {\n+        return module.exports.stream().filter(ed -> ed.packageName().equals(pack)).findAny().isPresent() ||\n+               module.extraModulePackages.contains(pack);\n+    }\n+\n+    private void loadVersionClassesFromDirectory(ClassList classes,\n+                                    Map<String, ModuleDescription> modules,\n+                                    Path modulesDirectory,\n+                                    String version,\n+                                    String baseline) {\n+        Map<String, ModuleDescription> currentVersionModules =\n+                new HashMap<>();\n+        ClassList currentVersionClasses = new ClassList();\n+        Set<String> privateIncludes = new HashSet<>();\n+        Set<String> includes = new HashSet<>();\n+        ExcludeIncludeList currentEIList = new ExcludeIncludeList(includes,\n+                privateIncludes,\n+                Collections.emptySet());\n+\n+        try {\n+            Map<Path, ModuleHeaderDescription> modulePath2Header = new HashMap<>();\n+            List<Path> pendingExportedDirectories = new ArrayList<>();\n+\n+            try (DirectoryStream<Path> ds = Files.newDirectoryStream(modulesDirectory)) {\n+                for (Path p : ds) {\n+                    Path moduleInfo = p.resolve(\"module-info.class\");\n+\n+                    if (Files.isReadable(moduleInfo)) {\n+                        ModuleDescription md;\n+\n+                        try (InputStream in = Files.newInputStream(moduleInfo)) {\n+                            md = inspectModuleInfoClassFile(in,\n+                                    currentVersionModules, version);\n+                        }\n+                        if (md == null) {\n+                            continue;\n+                        }\n+\n+                        modulePath2Header.put(p, md.header.get(0));\n+\n+                        Set<String> currentModuleExports =\n+                                md.header.get(0).exports.stream()\n+                                                        .filter(e -> !e.isQualified())\n+                                                        .map(e -> e.packageName + '\/')\n+                                                        .collect(Collectors.toSet());\n+\n+                        for (String dir : currentModuleExports) {\n+                            includes.add(dir);\n+                            pendingExportedDirectories.add(p.resolve(dir));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            List<String> pendingExtraClasses = new ArrayList<>();\n+\n+            for (Path exported : pendingExportedDirectories) {\n+                try (DirectoryStream<Path> ds = Files.newDirectoryStream(exported)) {\n+                    for (Path p2 : ds) {\n+                        if (!Files.isRegularFile(p2) || !p2.getFileName().toString().endsWith(\".class\")) {\n+                            continue;\n+                        }\n+\n+                        loadFromDirectoryHandleClassFile(p2, currentVersionClasses,\n+                                                         currentEIList, version,\n+                                                         pendingExtraClasses);\n+                    }\n+                }\n+            }\n+\n+            while (!pendingExtraClasses.isEmpty()) {\n+                String current = pendingExtraClasses.remove(pendingExtraClasses.size() - 1);\n+\n+                if (currentVersionClasses.find(current, true) != null) {\n+                    continue;\n+                }\n+\n+                for (Entry<Path, ModuleHeaderDescription> e : modulePath2Header.entrySet()) {\n+                    Path currentPath = e.getKey().resolve(current + \".class\");\n+\n+                    if (Files.isReadable(currentPath)) {\n+                        String pack = current.substring(0, current.lastIndexOf('\/'));\n+\n+                        e.getValue().extraModulePackages.add(pack);\n+\n+                        loadFromDirectoryHandleClassFile(currentPath, currentVersionClasses,\n+                                                         currentEIList, version,\n+                                                         pendingExtraClasses);\n+                    }\n+                }\n+            }\n+        } catch (IOException | ConstantPoolException ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+\n+        finishClassLoading(classes, modules, currentVersionModules, currentVersionClasses, currentEIList, version, baseline);\n+    }\n+\n+    private void loadFromDirectoryHandleClassFile(Path path, ClassList currentVersionClasses,\n+                                                  ExcludeIncludeList currentEIList, String version,\n+                                                  List<String> todo) throws IOException, ConstantPoolException {\n+        try (InputStream in = Files.newInputStream(path)) {\n+            inspectClassFile(in, currentVersionClasses,\n+                             currentEIList, version,\n+                             cf -> {\n+                                 Set<String> superTypes = otherRelevantTypesWithOwners(cf);\n+\n+                                 currentEIList.privateIncludeList.addAll(superTypes);\n+                                 todo.addAll(superTypes);\n+                             });\n+        }\n+    }\n+\n+    private void finishClassLoading(ClassList classes, Map<String, ModuleDescription> modules, Map<String, ModuleDescription> currentVersionModules, ClassList currentVersionClasses, ExcludeIncludeList currentEIList, String version,\n+                                    String baseline) {\n@@ -1566,0 +1755,5 @@\n+                    if (header.permittedSubclasses != null) {\n+                        for (String i : header.permittedSubclasses) {\n+                            modified |= include(includedClasses, currentVersionClasses, i);\n+                        }\n+                    }\n@@ -1965,0 +2159,5 @@\n+        inspectClassFile(in, classes, excludesIncludes, version, cf -> {});\n+    }\n+\n+    private void inspectClassFile(InputStream in, ClassList classes, ExcludeIncludeList excludesIncludes, String version,\n+                                  Consumer<ClassFile> extraTask) throws IOException, ConstantPoolException {\n@@ -1975,0 +2174,2 @@\n+        extraTask.accept(cf);\n+\n@@ -2035,1 +2236,1 @@\n-    private void inspectModuleInfoClassFile(InputStream in,\n+    private ModuleDescription inspectModuleInfoClassFile(InputStream in,\n@@ -2041,1 +2242,1 @@\n-            return ;\n+            return null;\n@@ -2051,1 +2252,1 @@\n-                return ;\n+                return null;\n@@ -2065,0 +2266,2 @@\n+\n+        return moduleDesc;\n@@ -2075,3 +2278,5 @@\n-                if (cf.access_flags.is(AccessFlags.ACC_MODULE)) {\n-                    continue;\n-                }\n+                additionalIncludes.addAll(otherRelevantTypesWithOwners(cf));\n+            } catch (IOException | ConstantPoolException ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        }\n@@ -2079,1 +2284,2 @@\n-                Set<String> additionalClasses = new HashSet<>();\n+        return additionalIncludes;\n+    }\n@@ -2081,5 +2287,20 @@\n-                if (cf.super_class != 0) {\n-                    additionalClasses.add(cf.getSuperclassName());\n-                }\n-                for (int i = 0; i < cf.interfaces.length; i++) {\n-                    additionalClasses.add(cf.getInterfaceName(i));\n+    private Set<String> otherRelevantTypesWithOwners(ClassFile cf) {\n+        Set<String> supertypes = new HashSet<>();\n+\n+        try {\n+            if (cf.access_flags.is(AccessFlags.ACC_MODULE)) {\n+                return supertypes;\n+            }\n+\n+            Set<String> additionalClasses = new HashSet<>();\n+\n+            if (cf.super_class != 0) {\n+                additionalClasses.add(cf.getSuperclassName());\n+            }\n+            for (int i = 0; i < cf.interfaces.length; i++) {\n+                additionalClasses.add(cf.getInterfaceName(i));\n+            }\n+            PermittedSubclasses_attribute permitted = (PermittedSubclasses_attribute) cf.getAttribute(Attribute.PermittedSubclasses);\n+            if (permitted != null) {\n+                for (int i = 0; i < permitted.subtypes.length; i++) {\n+                    additionalClasses.add(cf.constant_pool.getClassInfo(permitted.subtypes[i]).getName());\n@@ -2087,0 +2308,1 @@\n+            }\n@@ -2088,2 +2310,2 @@\n-                for (String additional : additionalClasses) {\n-                    int dollar;\n+            for (String additional : additionalClasses) {\n+                int dollar;\n@@ -2091,1 +2313,1 @@\n-                    additionalIncludes.add(additional);\n+                supertypes.add(additional);\n@@ -2093,4 +2315,3 @@\n-                    while ((dollar = additional.lastIndexOf('$')) != (-1)) {\n-                        additional = additional.substring(0, dollar);\n-                        additionalIncludes.add(additional);\n-                    }\n+                while ((dollar = additional.lastIndexOf('$')) != (-1)) {\n+                    additional = additional.substring(0, dollar);\n+                    supertypes.add(additional);\n@@ -2098,2 +2319,0 @@\n-            } catch (IOException | ConstantPoolException ex) {\n-                throw new IllegalStateException(ex);\n@@ -2101,1 +2320,0 @@\n-        }\n@@ -2103,1 +2321,4 @@\n-        return additionalIncludes;\n+            return supertypes;\n+        } catch (ConstantPoolException ex) {\n+            throw new IllegalStateException(ex);\n+        }\n@@ -2118,1 +2339,3 @@\n-        headerDesc.versions += version;\n+        if (!headerDesc.versions.contains(version)) {\n+            headerDesc.versions += version;\n+        }\n@@ -2162,1 +2385,3 @@\n-        headerDesc.versions += version;\n+        if (!headerDesc.versions.contains(version)) {\n+            headerDesc.versions += version;\n+        }\n@@ -4418,1 +4643,2 @@\n-                String systemModules;\n+                String preReleaseTag;\n+                String moduleClasses;\n@@ -4420,1 +4646,1 @@\n-                if (args.length == 6) {\n+                if (args.length == 7) {\n@@ -4426,2 +4652,3 @@\n-                    systemModules = args[5];\n-                } else if (args.length == 7) {\n+                    preReleaseTag = args[5];\n+                    moduleClasses = args[6];\n+                } else if (args.length == 8) {\n@@ -4433,1 +4660,2 @@\n-                    systemModules = args[6];\n+                    preReleaseTag = args[6];\n+                    moduleClasses = args[7];\n@@ -4449,1 +4677,2 @@\n-                                                  systemModules);\n+                                                  preReleaseTag,\n+                                                  moduleClasses);\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":283,"deletions":54,"binary":false,"changes":337,"status":"modified"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package build.tools.symbolgenerator;\n-\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.Writer;\n-import java.nio.charset.Charset;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayDeque;\n-import java.util.Arrays;\n-import java.util.Deque;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.ModuleElement.RequiresDirective;\n-import javax.lang.model.util.Elements;\n-import javax.tools.JavaCompiler;\n-\n-import com.sun.tools.javac.api.JavacTaskImpl;\n-import com.sun.tools.javac.api.JavacTool;\n-import com.sun.tools.javac.code.Source;\n-import com.sun.tools.javac.code.Symbol.ModuleSymbol;\n-import com.sun.tools.javac.jvm.Target;\n-\n-\/**\n- * Write reflexive transitive closure of the given modules along their requires transitive edges into\n- * file <version>\/system-modules in the specified directory.\n- *\/\n-public class TransitiveDependencies {\n-\n-    private static void help() {\n-        System.err.println(\"java TransitiveDependencies <target-directory> <module-source-path> <root-modules>\");\n-    }\n-\n-    public static void main(String... args) throws IOException {\n-        if (args.length < 2) {\n-            help();\n-            return ;\n-        }\n-\n-        JavaCompiler compiler = JavacTool.create();\n-        List<String> options = List.of(\"-source\", Source.DEFAULT.name,\n-                                       \"-target\", Target.DEFAULT.name,\n-                                       \"-proc:only\",\n-                                       \"--system\", \"none\",\n-                                       \"--module-source-path\", args[1],\n-                                       \"--add-modules\", Arrays.stream(args)\n-                                                              .skip(2)\n-                                                              .collect(Collectors.joining(\",\")));\n-        List<String> jlObjectList = List.of(\"java.lang.Object\");\n-        JavacTaskImpl task = (JavacTaskImpl) compiler.getTask(null, null, null, options, jlObjectList, null);\n-        task.enter();\n-        Elements elements = task.getElements();\n-        Deque<String> todo = new ArrayDeque<>();\n-        Arrays.stream(args).skip(2).forEach(todo::add);\n-        Set<String> allModules = new HashSet<>();\n-\n-        while (!todo.isEmpty()) {\n-            String current = todo.removeFirst();\n-\n-            if (!allModules.add(current))\n-                continue;\n-\n-            ModuleSymbol mod = (ModuleSymbol) elements.getModuleElement(current);\n-\n-            if (mod == null) {\n-                throw new IllegalStateException(\"Missing: \" + current);\n-            }\n-\n-             \/\/use the internal structure to avoid unnecessarily completing the symbol using the UsesProvidesVisitor:\n-            for (RequiresDirective rd : mod.requires) {\n-                if (rd.isTransitive()) {\n-                    todo.offerLast(rd.getDependency().getQualifiedName().toString());\n-                }\n-            }\n-        }\n-\n-        allModules.add(\"java.base\");\n-        allModules.add(\"jdk.unsupported\");\n-\n-        Path targetFile = Paths.get(args[0]);\n-\n-        Files.createDirectories(targetFile.getParent());\n-\n-        try (Writer w = Files.newBufferedWriter(targetFile);\n-             PrintWriter out = new PrintWriter(w)) {\n-            allModules.stream()\n-                      .sorted()\n-                      .forEach(out::println);\n-        }\n-    }\n-\n-}\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/TransitiveDependencies.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/langtools\/tools\/javacserver\/client\/Client.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/java.base\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,0 +216,1 @@\n+    LDFLAGS_aix := -brtl -bexpfull, \\\n@@ -218,0 +219,1 @@\n+    LIBS_aix := -lc -lm -ldecNumber, \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/java.base\/gensrc\/GensrcCharacterData.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/java.datatransfer\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/java.desktop\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/java.logging\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/java.management\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/java.naming\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/java.rmi\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/java.security.jgss\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/java.sql.rowset\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/java.sql\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/java.xml.crypto\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+COPY += .dtd .xsd .xml\n","filename":"make\/modules\/java.xml\/Java.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.charsets\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,2 +38,6 @@\n-# Modules that should be visible for 9 - the documented modules:\n-CT_MODULES := $(DOCS_MODULES)\n+# Modules that should be visible - the documented modules:\n+CT_MODULES := $(filter-out $(MODULES_FILTER), $(DOCS_MODULES))\n+CT_TRANSITIVE_MODULES := $(call FindTransitiveIndirectDepsForModules, $(CT_MODULES))\n+CT_MODULES_API_TARGETS := \\\n+    $(foreach m, $(CT_MODULES) $(CT_TRANSITIVE_MODULES), \\\n+      $(call SetupJavaCompilationApiTarget, $m, $(JDK_OUTPUTDIR)\/modules\/$m))\n@@ -41,2 +45,1 @@\n-# Get the complete module source path:\n-CT_MODULESOURCEPATH := $(call GetModuleSrcPath)\n+SYMBOL_FILES := $(wildcard $(MODULE_SRC)\/share\/data\/symbols\/*)\n@@ -47,6 +50,6 @@\n-    --add-exports java.base\/jdk.internal.javac=java.compiler.interim,jdk.compiler.interim \\\n-    --add-exports jdk.internal.opt\/jdk.internal.opt=jdk.compiler.interim,jdk.javadoc.interim \\\n-    --add-exports jdk.compiler.interim\/com.sun.tools.javac.api=ALL-UNNAMED \\\n-    --add-exports jdk.compiler.interim\/com.sun.tools.javac.code=ALL-UNNAMED \\\n-    --add-exports jdk.compiler.interim\/com.sun.tools.javac.util=ALL-UNNAMED \\\n-    --add-exports jdk.compiler.interim\/com.sun.tools.javac.jvm=ALL-UNNAMED \\\n+    --add-modules jdk.compiler,jdk.jdeps \\\n+    --add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED \\\n+    --add-exports jdk.compiler\/com.sun.tools.javac.code=ALL-UNNAMED \\\n+    --add-exports jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED \\\n+    --add-exports jdk.compiler\/com.sun.tools.javac.jvm=ALL-UNNAMED \\\n+    --add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED \\\n@@ -55,0 +58,1 @@\n+# TODO: Unify with jdk.javadoc-gendata. Should only compile this once and share.\n@@ -56,3 +60,3 @@\n-    TARGET_RELEASE := $(TARGET_RELEASE_BOOTJDK), \\\n-    SRC := $(TOPDIR)\/make\/langtools\/src\/classes \\\n-        $(TOPDIR)\/src\/jdk.jdeps\/share\/classes, \\\n+    TARGET_RELEASE := $(TARGET_RELEASE_NEWJDK), \\\n+    COMPILER := buildjdk, \\\n+    SRC := $(TOPDIR)\/make\/langtools\/src\/classes, \\\n@@ -60,1 +64,1 @@\n-    BIN := $(BUILDTOOLS_OUTPUTDIR)\/create_symbols, \\\n+    BIN := $(BUILDTOOLS_OUTPUTDIR)\/create_symbols_javac, \\\n@@ -63,1 +67,0 @@\n-        $(INTERIM_LANGTOOLS_ARGS) \\\n@@ -67,4 +70,2 @@\n-$(SUPPORT_OUTPUTDIR)\/symbols\/ct.sym: \\\n-    $(COMPILE_CREATE_SYMBOLS) \\\n-    $(wildcard $(MODULE_SRC)\/share\/data\/symbols\/*) \\\n-    $(MODULE_INFOS)\n+$(SUPPORT_OUTPUTDIR)\/symbols\/ct.sym: $(COMPILE_CREATE_SYMBOLS) $(SYMBOL_FILES) \\\n+    $(MODULE_INFOS) $(CT_MODULES_API_TARGETS)\n@@ -74,1 +75,1 @@\n-\t$(JAVA_SMALL) $(INTERIM_LANGTOOLS_ARGS) \\\n+\t$(BUILD_JAVA_SMALL) \\\n@@ -76,8 +77,1 @@\n-\t    -classpath $(BUILDTOOLS_OUTPUTDIR)\/create_symbols \\\n-\t    build.tools.symbolgenerator.TransitiveDependencies \\\n-\t    $(@D)\/system-modules \\\n-\t    $(CT_MODULESOURCEPATH) \\\n-\t    $(CT_MODULES)\n-\t$(JAVA_SMALL) $(INTERIM_LANGTOOLS_ARGS) \\\n-\t    $(COMPILECREATESYMBOLS_ADD_EXPORTS) \\\n-\t    -classpath $(BUILDTOOLS_OUTPUTDIR)\/create_symbols \\\n+\t    -classpath $(BUILDTOOLS_OUTPUTDIR)\/create_symbols_javac \\\n@@ -90,1 +84,2 @@\n-\t    $(@D)\/system-modules\n+\t    \"$(VERSION_PRE)\" \\\n+\t    $(JDK_OUTPUTDIR)\/modules\/\n","filename":"make\/modules\/jdk.compiler\/Gendata.gmk","additions":24,"deletions":29,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.compiler\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.hotspot.agent\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.httpserver\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.internal.jvmstat\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.internal.le\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.internal.le\/Lib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.internal.opt\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.internal.vm.ci\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.jartool\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.javadoc\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.jcmd\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.jconsole\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.jdeps\/Gensrc.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.jdeps\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.jdeps\/Launcher.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.jdi\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.jpackage\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.jshell\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.localedata\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/modules\/jdk.sctp\/Java.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/scripts\/compare_exceptions.sh.incl","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/scripts\/fixpath.sh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"make\/test\/BuildFailureHandler.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1514,1 +1514,0 @@\n-  assert(VM_Version::supports_cx8(), \"wrong machine\");\n@@ -2703,0 +2702,1 @@\n+    assert_different_registers(obj, tmp, rscratch1, rscratch2, mdo_addr.base(), mdo_addr.index());\n@@ -2704,0 +2704,2 @@\n+  } else {\n+    assert_different_registers(obj, rscratch1, rscratch2, mdo_addr.base(), mdo_addr.index());\n@@ -2760,2 +2762,2 @@\n-          \/\/ There is a chance that the checks above (re-reading profiling\n-          \/\/ data from memory) fail if another thread has just set the\n+          \/\/ There is a chance that the checks above\n+          \/\/ fail if another thread has just set the\n@@ -2764,0 +2766,1 @@\n+          __ eor(tmp, tmp, rscratch2); \/\/ get back original value before XOR\n@@ -2788,0 +2791,4 @@\n+#ifdef ASSERT\n+        __ andr(tmp, tmp, TypeEntries::type_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -2819,0 +2826,4 @@\n+#ifdef ASSERT\n+        __ andr(tmp, tmp, TypeEntries::type_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/assembler.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"memory\/metaspace.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Helper function; reserve at an address that is compatible with EOR\n+static char* reserve_at_eor_compatible_address(size_t size, bool aslr) {\n+  char* result = nullptr;\n+\n+  log_debug(metaspace, map)(\"Trying to reserve at an EOR-compatible address\");\n+\n+  \/\/ We need immediates that are 32-bit aligned, since they should not intersect nKlass\n+  \/\/ bits. They should not be larger than the addressable space either, but we still\n+  \/\/ lack a good abstraction for that (see JDK-8320584), therefore we assume and hard-code\n+  \/\/ 2^48 as a reasonable higher ceiling.\n+  static const uint16_t immediates[] = {\n+      0x0001, 0x0002, 0x0003, 0x0004, 0x0006, 0x0007, 0x0008, 0x000c, 0x000e,\n+      0x000f, 0x0010, 0x0018, 0x001c, 0x001e, 0x001f, 0x0020, 0x0030, 0x0038,\n+      0x003c, 0x003e, 0x003f, 0x0040, 0x0060, 0x0070, 0x0078, 0x007c, 0x007e,\n+      0x007f, 0x0080, 0x00c0, 0x00e0, 0x00f0, 0x00f8, 0x00fc, 0x00fe, 0x00ff,\n+      0x0100, 0x0180, 0x01c0, 0x01e0, 0x01f0, 0x01f8, 0x01fc, 0x01fe, 0x01ff,\n+      0x0200, 0x0300, 0x0380, 0x03c0, 0x03e0, 0x03f0, 0x03f8, 0x03fc, 0x03fe,\n+      0x03ff, 0x0400, 0x0600, 0x0700, 0x0780, 0x07c0, 0x07e0, 0x07f0, 0x07f8,\n+      0x07fc, 0x07fe, 0x07ff, 0x0800, 0x0c00, 0x0e00, 0x0f00, 0x0f80, 0x0fc0,\n+      0x0fe0, 0x0ff0, 0x0ff8, 0x0ffc, 0x0ffe, 0x0fff, 0x1000, 0x1800, 0x1c00,\n+      0x1e00, 0x1f00, 0x1f80, 0x1fc0, 0x1fe0, 0x1ff0, 0x1ff8, 0x1ffc, 0x1ffe,\n+      0x1fff, 0x2000, 0x3000, 0x3800, 0x3c00, 0x3e00, 0x3f00, 0x3f80, 0x3fc0,\n+      0x3fe0, 0x3ff0, 0x3ff8, 0x3ffc, 0x3ffe, 0x3fff, 0x4000, 0x6000, 0x7000,\n+      0x7800, 0x7c00, 0x7e00, 0x7f00, 0x7f80, 0x7fc0, 0x7fe0, 0x7ff0, 0x7ff8,\n+      0x7ffc, 0x7ffe, 0x7fff\n+  };\n+  static constexpr int num_immediates = sizeof(immediates) \/ sizeof(immediates[0]);\n+  const int start_index = aslr ? os::random() : 0;\n+  constexpr int max_tries = 64;\n+  for (int ntry = 0; result == nullptr && ntry < max_tries; ntry ++) {\n+    \/\/ As in os::attempt_reserve_memory_between, we alternate between higher and lower\n+    \/\/ addresses; this maximizes the chance of early success if part of the address space\n+    \/\/ is not accessible (e.g. 39-bit address space).\n+    const int alt_index = (ntry & 1) ? 0 : num_immediates \/ 2;\n+    const int index = (start_index + ntry + alt_index) % num_immediates;\n+    const uint64_t immediate = ((uint64_t)immediates[index]) << 32;\n+    assert(immediate > 0 && Assembler::operand_valid_for_logical_immediate(\/*is32*\/false, immediate),\n+           \"Invalid immediate %d \" UINT64_FORMAT, index, immediate);\n+    result = os::attempt_reserve_memory_at((char*)immediate, size, false);\n+    if (result == nullptr) {\n+      log_trace(metaspace, map)(\"Failed to attach at \" UINT64_FORMAT_X, immediate);\n+    }\n+  }\n+  if (result == nullptr) {\n+    log_debug(metaspace, map)(\"Failed to reserve at any EOR-compatible address\");\n+  }\n+  return result;\n+}\n+char* CompressedKlassPointers::reserve_address_space_for_compressed_classes(size_t size, bool aslr, bool optimize_for_zero_base) {\n+\n+  char* result = nullptr;\n+\n+  \/\/ Optimize for base=0 shift=0\n+  if (optimize_for_zero_base) {\n+    result = reserve_address_space_for_unscaled_encoding(size, aslr);\n+  }\n+\n+  \/\/ If this fails, we don't bother aiming for zero-based encoding (base=0 shift>0), since it has no\n+  \/\/ advantages over EOR or movk mode.\n+\n+  \/\/ EOR-compatible reservation\n+  if (result == nullptr) {\n+    result = reserve_at_eor_compatible_address(size, aslr);\n+  }\n+\n+  \/\/ Movk-compatible reservation via probing.\n+  if (result == nullptr) {\n+    result = reserve_address_space_for_16bit_move(size, aslr);\n+  }\n+\n+  \/\/ Movk-compatible reservation via overallocation.\n+  \/\/ If that failed, attempt to allocate at any 4G-aligned address. Let the system decide where. For ASLR,\n+  \/\/ we now rely on the system.\n+  \/\/ Compared with the probing done above, this has two disadvantages:\n+  \/\/ - on a kernel with 52-bit address space we may get an address that has bits set between [48, 52).\n+  \/\/   In that case, we may need two movk moves (not yet implemented).\n+  \/\/ - this technique leads to temporary over-reservation of address space; it will spike the vsize of\n+  \/\/   the process. Therefore it may fail if a vsize limit is in place (e.g. ulimit -v).\n+  if (result == nullptr) {\n+    constexpr size_t alignment = nth_bit(32);\n+    log_debug(metaspace, map)(\"Trying to reserve at a 32-bit-aligned address\");\n+    result = os::reserve_memory_aligned(size, alignment, false);\n+  }\n+\n+  return result;\n+}\n+\n+void CompressedKlassPointers::initialize(address addr, size_t len) {\n+  constexpr uintptr_t unscaled_max = nth_bit(32);\n+  assert(len <= unscaled_max, \"Klass range larger than 32 bits?\");\n+\n+  \/\/ Shift is always 0 on aarch64.\n+  _shift = 0;\n+\n+  \/\/ On aarch64, we don't bother with zero-based encoding (base=0 shift>0).\n+  address const end = addr + len;\n+  _base = (end <= (address)unscaled_max) ? nullptr : addr;\n+\n+  _range = end - _base;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/compressedKlass_aarch64.cpp","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -1293,0 +1293,3 @@\n+ZLoadBarrierStubC2Aarch64::ZLoadBarrierStubC2Aarch64(const MachNode* node, Address ref_addr, Register ref)\n+  : ZLoadBarrierStubC2(node, ref_addr, ref), _test_and_branch_reachable_entry(), _offset(), _deferred_emit(false), _test_and_branch_reachable(false) {}\n+\n@@ -1322,0 +1325,6 @@\n+ZLoadBarrierStubC2Aarch64* ZLoadBarrierStubC2Aarch64::create(const MachNode* node, Address ref_addr, Register ref) {\n+  ZLoadBarrierStubC2Aarch64* const stub = new (Compile::current()->comp_arena()) ZLoadBarrierStubC2Aarch64(node, ref_addr, ref);\n+  register_stub(stub);\n+  return stub;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -268,0 +268,1 @@\n+  ZLoadBarrierStubC2Aarch64(const MachNode* node, Address ref_addr, Register ref);\n@@ -272,0 +273,1 @@\n+  static ZLoadBarrierStubC2Aarch64* create(const MachNode* node, Address ref_addr, Register ref);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  ZLoadBarrierStubC2* const stub = ZLoadBarrierStubC2::create(node, ref_addr, ref);\n+  ZLoadBarrierStubC2Aarch64* const stub = ZLoadBarrierStubC2Aarch64::create(node, ref_addr, ref);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1565,1 +1565,1 @@\n-  assert_different_registers(obj, rscratch1);\n+  assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n@@ -1587,1 +1587,0 @@\n-  ldr(rscratch1, mdo_addr);\n@@ -1591,2 +1590,2 @@\n-  \/\/ There is a chance that the checks above (re-reading profiling\n-  \/\/ data from memory) fail if another thread has just set the\n+  \/\/ There is a chance that the checks above\n+  \/\/ fail if another thread has just set the\n@@ -1594,0 +1593,1 @@\n+  eor(obj, obj, rscratch1); \/\/ get back original value before XOR\n@@ -1606,0 +1606,4 @@\n+#ifdef ASSERT\n+  andr(obj, obj, TypeEntries::type_mask);\n+  verify_klass_ptr(obj);\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-  _supports_cx8 = true;\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1388,1 +1388,0 @@\n-    assert(VM_Version::supports_cx8(), \"wrong machine\");\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -131,0 +131,4 @@\n+  \/\/ Future cleanup: if SUPPORTS_NATIVE_CX8 is defined then we should not need\n+  \/\/ any alternative solutions. At present this allows for the theoretical\n+  \/\/ possibility of building for ARMv7 and then running on ARMv5 or 6. If that\n+  \/\/ is impossible then the ARM port folk should clean this up.\n@@ -132,0 +136,1 @@\n+#ifndef SUPPORTS_NATIVE_CX8\n@@ -135,0 +140,1 @@\n+#endif\n@@ -281,1 +287,1 @@\n-  assert(_supports_cx8 && _supports_atomic_getset4 && _supports_atomic_getadd4\n+  assert(supports_cx8() && _supports_atomic_getset4 && _supports_atomic_getadd4\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3109,1 +3109,1 @@\n-        __ andi_(R0, klass, TypeEntries::type_unknown);\n+        __ andi_(R0, tmp, TypeEntries::type_unknown);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+char* CompressedKlassPointers::reserve_address_space_for_compressed_classes(size_t size, bool aslr, bool optimize_for_zero_base) {\n+\n+  char* result = nullptr;\n+\n+  \/\/ Optimize for base=0 shift=0; failing that, for base=0 shift>0\n+  if (optimize_for_zero_base) {\n+    result = reserve_address_space_for_unscaled_encoding(size, aslr);\n+    if (result == nullptr) {\n+      result = reserve_address_space_for_zerobased_encoding(size, aslr);\n+    }\n+  }\n+\n+  \/\/ Optimize for a single 16-bit move: a base that has only bits set in its third quadrant [32..48).\n+  if (result == nullptr) {\n+    result = reserve_address_space_for_16bit_move(size, aslr);\n+  }\n+\n+  return result;\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/compressedKlass_ppc.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -1777,1 +1777,1 @@\n-  andi_(R0, klass, TypeEntries::type_unknown);\n+  andi_(R0, tmp, TypeEntries::type_unknown);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-  static void invokevfinal_helper(Register Rcache, Register Rscratch1, Register Rscratch2, Register Rscratch3);\n+  static void invokevfinal_helper(Register Rcache, Register Rscratch1, Register Rscratch2, Register Rscratch3, Register Rscratch4);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3490,1 +3490,1 @@\n-  invokevfinal_helper(Rcache, R11_scratch1, R12_scratch2, Rflags \/* tmp *\/);\n+  invokevfinal_helper(Rcache, R11_scratch1, R12_scratch2, Rflags \/* tmp *\/, Rrecv \/* tmp *\/);\n@@ -3513,1 +3513,1 @@\n-  invokevfinal_helper(Rcache, R11_scratch1, R12_scratch2, R22_tmp2);\n+  invokevfinal_helper(Rcache, R11_scratch1, R12_scratch2, R22_tmp2, R23_tmp3);\n@@ -3516,1 +3516,2 @@\n-void TemplateTable::invokevfinal_helper(Register Rcache, Register Rscratch1, Register Rscratch2, Register Rscratch3) {\n+void TemplateTable::invokevfinal_helper(Register Rcache,\n+                                        Register Rscratch1, Register Rscratch2, Register Rscratch3, Register Rscratch4) {\n@@ -3518,1 +3519,1 @@\n-  assert_different_registers(Rcache, Rscratch1, Rscratch2, Rscratch3);\n+  assert_different_registers(Rcache, Rscratch1, Rscratch2, Rscratch3, Rscratch4);\n@@ -3520,3 +3521,4 @@\n-  \/\/ Load receiver from stack slot.\n-  Register Rmethod = Rscratch3;\n-  __ ld(Rmethod, in_bytes(ResolvedMethodEntry::method_offset()), Rcache);\n+  Register Rrecv     = Rscratch2,\n+           Rmethod   = Rscratch3,\n+           Rret_addr = Rscratch4;\n+  prepare_invoke(Rcache, Rret_addr, Rrecv, Rscratch1);\n@@ -3524,17 +3526,1 @@\n-  \/\/ Get return address.\n-  Register Rtable_addr = Rscratch2,\n-           Rret_addr   = Rcache,\n-           Rret_type   = Rscratch1;\n-  \/\/ Get return type. It's coded into the upper 4 bits of the lower half of the 64 bit value.\n-  __ lbz(Rret_type, in_bytes(ResolvedMethodEntry::type_offset()), Rcache);\n-  __ load_dispatch_table(Rtable_addr, Interpreter::invoke_return_entry_table());\n-  __ sldi(Rret_type, Rret_type, LogBytesPerWord);\n-  __ ldx(Rret_addr, Rret_type, Rtable_addr); \/\/ kills Rcache\n-\n-  Register Rnum_params = Rscratch2,\n-           Rrecv       = Rscratch2;\n-  __ ld(Rnum_params, in_bytes(Method::const_offset()), Rmethod);\n-  __ lhz(Rnum_params \/* number of params *\/, in_bytes(ConstMethod::size_of_parameters_offset()), Rnum_params);\n-\n-  \/\/ Load receiver and receiver null check.\n-  __ load_receiver(Rnum_params, Rrecv);\n+  \/\/ Receiver null check.\n@@ -3543,0 +3529,2 @@\n+  __ ld(Rmethod, in_bytes(ResolvedMethodEntry::method_offset()), Rcache);\n+\n@@ -3561,1 +3549,1 @@\n-                                               Rmethod, \/\/ Method* or itable index\n+                                               Rmethod, \/\/ Method*\n@@ -3563,1 +3551,1 @@\n-  prepare_invoke(Rcache, Rret_addr, Rreceiver, R11_scratch1); \/\/ recv\n+  prepare_invoke(Rcache, Rret_addr, Rreceiver, R11_scratch1);\n@@ -3581,4 +3569,4 @@\n-  load_resolved_method_entry_special_or_static(Rcache,  \/\/ ResolvedMethodEntry*\n-                                               R19_method, \/\/ Method* or itable index\n-                                               noreg); \/\/ flags\n-  prepare_invoke(Rcache, Rret_addr, noreg, R11_scratch1); \/\/ recv\n+  load_resolved_method_entry_special_or_static(Rcache,     \/\/ ResolvedMethodEntry*\n+                                               R19_method, \/\/ Method*\n+                                               noreg);     \/\/ flags\n+  prepare_invoke(Rcache, Rret_addr, noreg, R11_scratch1);\n@@ -3642,1 +3630,1 @@\n-  prepare_invoke(Rcache, Rret_addr, Rreceiver, Rscratch1); \/\/ recv\n+  prepare_invoke(Rcache, Rret_addr, Rreceiver, Rscratch1);\n@@ -3760,1 +3748,1 @@\n-                                    Rmethod, \/\/ Method* or itable index\n+                                    Rmethod, \/\/ Method*\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":20,"deletions":32,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -203,4 +203,0 @@\n-  \/\/ PPC64 supports 8-byte compare-exchange operations (see Atomic::cmpxchg)\n-  \/\/ and 'atomic long memory ops' (see Unsafe_GetLongVolatile).\n-  _supports_cx8 = true;\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1254,1 +1254,0 @@\n-  assert(VM_Version::supports_cx8(), \"wrong machine\");\n@@ -1657,2 +1656,2 @@\n-      \/\/ There is a chance that the checks above (re-reading profiling\n-      \/\/ data from memory) fail if another thread has just set the\n+      \/\/ There is a chance that the checks above\n+      \/\/ fail if another thread has just set the\n@@ -1661,0 +1660,1 @@\n+      __ xorr(tmp, tmp, t1); \/\/ get back original value before XOR\n@@ -1687,0 +1687,4 @@\n+#ifdef ASSERT\n+    __ andi(tmp, tmp, TypeEntries::type_mask);\n+    __ verify_klass_ptr(tmp);\n+#endif\n@@ -1721,0 +1725,4 @@\n+#ifdef ASSERT\n+    __ andi(tmp, tmp, TypeEntries::type_mask);\n+    __ verify_klass_ptr(tmp);\n+#endif\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1039,2 +1039,3 @@\n-                                    Register cnt1, Register cnt2, Register result, Register tmp1, Register tmp2,\n-                                    Register tmp3, int ae)\n+                                       Register cnt1, Register cnt2, Register result,\n+                                       Register tmp1, Register tmp2, Register tmp3,\n+                                       int ae)\n@@ -1043,2 +1044,2 @@\n-      DIFFERENCE, NEXT_WORD, SHORT_LOOP_TAIL, SHORT_LAST2, SHORT_LAST_INIT,\n-      SHORT_LOOP_START, TAIL_CHECK, L;\n+        DIFFERENCE, NEXT_WORD, SHORT_LOOP_TAIL, SHORT_LAST2, SHORT_LAST_INIT,\n+        SHORT_LOOP_START, TAIL_CHECK, L;\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+char* CompressedKlassPointers::reserve_address_space_for_compressed_classes(size_t size, bool aslr, bool optimize_for_zero_base) {\n+\n+  char* result = nullptr;\n+\n+  \/\/ RiscV loads a 64-bit immediate in up to four separate steps, splitting it into four different sections\n+  \/\/ (two 32-bit sections, each split into two subsections of 20\/12 bits).\n+  \/\/\n+  \/\/ 63 ....... 44 43 ... 32 31 ....... 12 11 ... 0\n+  \/\/       D           C          B           A\n+  \/\/\n+  \/\/ A \"good\" base is, in this order:\n+  \/\/ 1) only bits in A; this would be an address < 4KB, which is unrealistic on normal Linux boxes since\n+  \/\/    the typical default for vm.mmap_min_address is 64KB. We ignore that.\n+  \/\/ 2) only bits in B: a 12-bit-aligned address below 4GB. 12 bit = 4KB, but since mmap reserves at\n+  \/\/    page boundaries, we can ignore the alignment.\n+  \/\/ 3) only bits in C: a 4GB-aligned address that is lower than 16TB.\n+  \/\/ 4) only bits in D: a 16TB-aligned address.\n+\n+  \/\/ First, attempt to allocate < 4GB. We do this unconditionally:\n+  \/\/ - if can_optimize_for_zero_base, a <4GB mapping start would allow us to run unscaled (base = 0, shift = 0)\n+  \/\/ - if !can_optimize_for_zero_base, a <4GB mapping start is still good, the resulting immediate can be encoded\n+  \/\/   with one instruction (2)\n+  result = reserve_address_space_for_unscaled_encoding(size, aslr);\n+\n+  \/\/ Failing that, attempt to reserve for base=zero shift>0\n+  if (result == nullptr && optimize_for_zero_base) {\n+    result = reserve_address_space_for_zerobased_encoding(size, aslr);\n+  }\n+\n+  \/\/ Failing that, optimize for case (3) - a base with only bits set between [33-44)\n+  if (result == nullptr) {\n+    const uintptr_t from = nth_bit(32 + (optimize_for_zero_base ? LogKlassAlignmentInBytes : 0));\n+    constexpr uintptr_t to = nth_bit(44);\n+    constexpr size_t alignment = nth_bit(32);\n+    result = reserve_address_space_X(from, to, size, alignment, aslr);\n+  }\n+\n+  \/\/ Failing that, optimize for case (4) - a base with only bits set between [44-64)\n+  if (result == nullptr) {\n+    constexpr uintptr_t from = nth_bit(44);\n+    constexpr uintptr_t to = UINT64_MAX;\n+    constexpr size_t alignment = nth_bit(44);\n+    result = reserve_address_space_X(from, to, size, alignment, aslr);\n+  }\n+\n+  return result;\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/compressedKlass_riscv.cpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -1630,2 +1630,2 @@\n-  ld(t0, mdo_addr);\n-  xorr(obj, obj, t0);\n+  ld(tmp, mdo_addr);\n+  xorr(obj, obj, tmp);\n@@ -1641,6 +1641,5 @@\n-  ld(t0, mdo_addr);\n-  beqz(t0, none);\n-  mv(tmp, (u1)TypeEntries::null_seen);\n-  beq(t0, tmp, none);\n-  \/\/ There is a chance that the checks above (re-reading profiling\n-  \/\/ data from memory) fail if another thread has just set the\n+  beqz(tmp, none);\n+  mv(t0, (u1)TypeEntries::null_seen);\n+  beq(tmp, t0, none);\n+  \/\/ There is a chance that the checks above\n+  \/\/ fail if another thread has just set the\n@@ -1648,2 +1647,3 @@\n-  ld(t0, mdo_addr);\n-  xorr(obj, obj, t0);\n+  xorr(obj, obj, tmp); \/\/ get back original value before XOR\n+  ld(tmp, mdo_addr);\n+  xorr(obj, obj, tmp);\n@@ -1660,0 +1660,4 @@\n+#ifdef ASSERT\n+  andi(obj, obj, TypeEntries::type_mask);\n+  verify_klass_ptr(obj);\n+#endif\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2051,17 +2051,0 @@\n-\/\/ Multiply and multiply-accumulate unsigned 64-bit registers.\n-void MacroAssembler::wide_mul(Register prod_lo, Register prod_hi, Register n, Register m) {\n-  assert_different_registers(prod_lo, prod_hi);\n-\n-  mul(prod_lo, n, m);\n-  mulhu(prod_hi, n, m);\n-}\n-void MacroAssembler::wide_madd(Register sum_lo, Register sum_hi, Register n,\n-                Register m, Register tmp1, Register tmp2) {\n-  assert_different_registers(sum_lo, sum_hi);\n-  assert_different_registers(sum_hi, tmp2);\n-\n-  wide_mul(tmp1, tmp2, n, m);\n-  cad(sum_lo, sum_lo, tmp1, tmp1);  \/\/ Add tmp1 to sum_lo with carry output to tmp1\n-  adc(sum_hi, sum_hi, tmp2, tmp1);  \/\/ Add tmp2 with carry to sum_hi\n-}\n-\n@@ -2539,0 +2522,103 @@\n+\/\/ Look up the method for a megamorphic invokeinterface call in a single pass over itable:\n+\/\/ - check recv_klass (actual object class) is a subtype of resolved_klass from CompiledICHolder\n+\/\/ - find a holder_klass (class that implements the method) vtable offset and get the method from vtable by index\n+\/\/ The target method is determined by <holder_klass, itable_index>.\n+\/\/ The receiver klass is in recv_klass.\n+\/\/ On success, the result will be in method_result, and execution falls through.\n+\/\/ On failure, execution transfers to the given label.\n+void MacroAssembler::lookup_interface_method_stub(Register recv_klass,\n+                                                  Register holder_klass,\n+                                                  Register resolved_klass,\n+                                                  Register method_result,\n+                                                  Register temp_itbl_klass,\n+                                                  Register scan_temp,\n+                                                  int itable_index,\n+                                                  Label& L_no_such_interface) {\n+  \/\/ 'method_result' is only used as output register at the very end of this method.\n+  \/\/ Until then we can reuse it as 'holder_offset'.\n+  Register holder_offset = method_result;\n+  assert_different_registers(resolved_klass, recv_klass, holder_klass, temp_itbl_klass, scan_temp, holder_offset);\n+\n+  int vtable_start_offset_bytes = in_bytes(Klass::vtable_start_offset());\n+  int scan_step = itableOffsetEntry::size() * wordSize;\n+  int ioffset_bytes = in_bytes(itableOffsetEntry::interface_offset());\n+  int ooffset_bytes = in_bytes(itableOffsetEntry::offset_offset());\n+  int itmentry_off_bytes = in_bytes(itableMethodEntry::method_offset());\n+  const int vte_scale = exact_log2(vtableEntry::size_in_bytes());\n+\n+  Label L_loop_search_resolved_entry, L_resolved_found, L_holder_found;\n+\n+  lwu(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));\n+  add(recv_klass, recv_klass, vtable_start_offset_bytes + ioffset_bytes);\n+  \/\/ itableOffsetEntry[] itable = recv_klass + Klass::vtable_start_offset()\n+  \/\/                            + sizeof(vtableEntry) * (recv_klass->_vtable_len);\n+  \/\/ scan_temp = &(itable[0]._interface)\n+  \/\/ temp_itbl_klass = itable[0]._interface;\n+  shadd(scan_temp, scan_temp, recv_klass, scan_temp, vte_scale);\n+  ld(temp_itbl_klass, Address(scan_temp));\n+  mv(holder_offset, zr);\n+\n+  \/\/ Initial checks:\n+  \/\/   - if (holder_klass != resolved_klass), go to \"scan for resolved\"\n+  \/\/   - if (itable[0] == holder_klass), shortcut to \"holder found\"\n+  \/\/   - if (itable[0] == 0), no such interface\n+  bne(resolved_klass, holder_klass, L_loop_search_resolved_entry);\n+  beq(holder_klass, temp_itbl_klass, L_holder_found);\n+  beqz(temp_itbl_klass, L_no_such_interface);\n+\n+  \/\/ Loop: Look for holder_klass record in itable\n+  \/\/   do {\n+  \/\/     temp_itbl_klass = *(scan_temp += scan_step);\n+  \/\/     if (temp_itbl_klass == holder_klass) {\n+  \/\/       goto L_holder_found; \/\/ Found!\n+  \/\/     }\n+  \/\/   } while (temp_itbl_klass != 0);\n+  \/\/   goto L_no_such_interface \/\/ Not found.\n+  Label L_search_holder;\n+  bind(L_search_holder);\n+    add(scan_temp, scan_temp, scan_step);\n+    ld(temp_itbl_klass, Address(scan_temp));\n+    beq(holder_klass, temp_itbl_klass, L_holder_found);\n+    bnez(temp_itbl_klass, L_search_holder);\n+\n+  j(L_no_such_interface);\n+\n+  \/\/ Loop: Look for resolved_class record in itable\n+  \/\/   while (true) {\n+  \/\/     temp_itbl_klass = *(scan_temp += scan_step);\n+  \/\/     if (temp_itbl_klass == 0) {\n+  \/\/       goto L_no_such_interface;\n+  \/\/     }\n+  \/\/     if (temp_itbl_klass == resolved_klass) {\n+  \/\/        goto L_resolved_found;  \/\/ Found!\n+  \/\/     }\n+  \/\/     if (temp_itbl_klass == holder_klass) {\n+  \/\/        holder_offset = scan_temp;\n+  \/\/     }\n+  \/\/   }\n+  \/\/\n+  Label L_loop_search_resolved;\n+  bind(L_loop_search_resolved);\n+    add(scan_temp, scan_temp, scan_step);\n+    ld(temp_itbl_klass, Address(scan_temp));\n+  bind(L_loop_search_resolved_entry);\n+    beqz(temp_itbl_klass, L_no_such_interface);\n+    beq(resolved_klass, temp_itbl_klass, L_resolved_found);\n+    bne(holder_klass, temp_itbl_klass, L_loop_search_resolved);\n+    mv(holder_offset, scan_temp);\n+    j(L_loop_search_resolved);\n+\n+  \/\/ See if we already have a holder klass. If not, go and scan for it.\n+  bind(L_resolved_found);\n+  beqz(holder_offset, L_search_holder);\n+  mv(scan_temp, holder_offset);\n+\n+  \/\/ Finally, scan_temp contains holder_klass vtable offset\n+  bind(L_holder_found);\n+  lwu(method_result, Address(scan_temp, ooffset_bytes - ioffset_bytes));\n+  add(recv_klass, recv_klass, itable_index * wordSize + itmentry_off_bytes\n+                              - vtable_start_offset_bytes - ioffset_bytes); \/\/ substract offsets to restore the original value of recv_klass\n+  add(method_result, recv_klass, method_result);\n+  ld(method_result, Address(method_result));\n+}\n+\n@@ -3579,0 +3665,18 @@\n+\/\/ Multiply and multiply-accumulate unsigned 64-bit registers.\n+void MacroAssembler::wide_mul(Register prod_lo, Register prod_hi, Register n, Register m) {\n+  assert_different_registers(prod_lo, prod_hi);\n+\n+  mul(prod_lo, n, m);\n+  mulhu(prod_hi, n, m);\n+}\n+\n+void MacroAssembler::wide_madd(Register sum_lo, Register sum_hi, Register n,\n+                               Register m, Register tmp1, Register tmp2) {\n+  assert_different_registers(sum_lo, sum_hi);\n+  assert_different_registers(sum_hi, tmp2);\n+\n+  wide_mul(tmp1, tmp2, n, m);\n+  cad(sum_lo, sum_lo, tmp1, tmp1);  \/\/ Add tmp1 to sum_lo with carry output to tmp1\n+  adc(sum_hi, sum_hi, tmp2, tmp1);  \/\/ Add tmp2 with carry to sum_hi\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":121,"deletions":17,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -201,4 +201,0 @@\n-  void wide_mul(Register prod_lo, Register prod_hi, Register n, Register m);\n-  void wide_madd(Register sum_lo, Register sum_hi, Register n,\n-                Register m, Register tmp1, Register tmp2);\n-\n@@ -261,0 +257,9 @@\n+  void lookup_interface_method_stub(Register recv_klass,\n+                                    Register holder_klass,\n+                                    Register resolved_klass,\n+                                    Register method_result,\n+                                    Register temp_reg,\n+                                    Register temp_reg2,\n+                                    int itable_index,\n+                                    Label& L_no_such_interface);\n+\n@@ -1207,0 +1212,3 @@\n+  void wide_mul(Register prod_lo, Register prod_hi, Register n, Register m);\n+  void wide_madd(Register sum_lo, Register sum_hi, Register n,\n+                 Register m, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -8648,1 +8648,1 @@\n-  format %{ \"fmv.x.w  $dst, $src\\t#@MoveL2D_reg_stack\" %}\n+  format %{ \"fmv.x.w  $dst, $src\\t#@MoveF2I_reg_reg\" %}\n@@ -8702,1 +8702,1 @@\n-  format %{ \"fmv.d.x  $dst, $src\\t#@MoveD2L_reg_reg\" %}\n+  format %{ \"fmv.d.x  $dst, $src\\t#@MoveL2D_reg_reg\" %}\n@@ -8723,1 +8723,2 @@\n-            \"addi   $dst, $dst, -1\\t#@cmpF3_reg_reg\"\n+            \"addi   $dst, $dst, -1\\n\\t\"\n+            \"done:\"\n@@ -8743,1 +8744,2 @@\n-            \"addi   $dst, $dst, -1\\t#@cmpD3_reg_reg\"\n+            \"addi   $dst, $dst, -1\\n\\t\"\n+            \"done:\"\n@@ -8761,2 +8763,3 @@\n-            \"slt  $dst, $op1, $op2\\n\\t\"\n-            \"neg   $dst, $dst\\t#@cmpL3_reg_reg\"\n+            \"slt   $dst, $op1, $op2\\n\\t\"\n+            \"neg   $dst, $dst\\n\\t\"\n+            \"done:\"\n@@ -8780,1 +8783,2 @@\n-            \"neg   $dst, $dst\\t#@cmpUL3_reg_reg\"\n+            \"neg   $dst, $dst\\n\\t\"\n+            \"done:\"\n@@ -8798,1 +8802,2 @@\n-            \"neg   $dst, $dst\\t#@cmpU3_reg_reg\"\n+            \"neg   $dst, $dst\\n\\t\"\n+            \"done:\"\n@@ -8943,1 +8948,1 @@\n-    \"ble $src1, $src2, Lsrc1.\\t#@minI_rReg\\n\\t\"\n+    \"ble $src1, $src2, Lsrc1\\t#@minI_rReg\\n\\t\"\n@@ -8946,1 +8951,1 @@\n-    \"bind Lsrc1\\n\\t\"\n+    \"Lsrc1:\\n\\t\"\n@@ -8948,1 +8953,1 @@\n-    \"bind\\t#@minI_rReg\"\n+    \"Ldone:\"\n@@ -8975,1 +8980,1 @@\n-    \"bind Lsrc1\\n\\t\"\n+    \"Lsrc1:\\n\\t\"\n@@ -8977,1 +8982,1 @@\n-    \"bind\\t#@maxI_rReg\"\n+    \"Ldone:\"\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-  _supports_cx8 = true;\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-  const Register resolved_klass_reg = xmethod; \/\/ resolved interface klass (REFC)\n+  const Register resolved_klass_reg = x30; \/\/ resolved interface klass (REFC)\n@@ -198,10 +198,0 @@\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface\n-                             recv_klass_reg, resolved_klass_reg, noreg,\n-                             \/\/ outputs:  scan temp. reg1, scan temp. reg2\n-                             temp_reg2, temp_reg,\n-                             L_no_such_interface,\n-                             \/*return_method=*\/false);\n-\n-  const ptrdiff_t typecheckSize = __ pc() - start_pc;\n-  start_pc = __ pc();\n-\n@@ -209,7 +199,2 @@\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface, itable index\n-                             recv_klass_reg, holder_klass_reg, itable_index,\n-                             \/\/ outputs: method, scan temp. reg\n-                             xmethod, temp_reg,\n-                             L_no_such_interface);\n-\n-  const ptrdiff_t lookupSize = __ pc() - start_pc;\n+  __ lookup_interface_method_stub(recv_klass_reg, holder_klass_reg, resolved_klass_reg, xmethod,\n+                                  temp_reg, temp_reg2, itable_index, L_no_such_interface);\n@@ -219,1 +204,1 @@\n-  const ptrdiff_t codesize = typecheckSize + lookupSize;\n+  const ptrdiff_t codesize = __ pc() - start_pc;\n","filename":"src\/hotspot\/cpu\/riscv\/vtableStubs_riscv.cpp","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2673,1 +2673,0 @@\n-    assert(VM_Version::supports_cx8(), \"wrong machine\");\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+char* CompressedKlassPointers::reserve_address_space_for_compressed_classes(size_t size, bool aslr, bool optimize_for_zero_base) {\n+\n+  char* result = nullptr;\n+\n+  uintptr_t tried_below = 0;\n+\n+  \/\/ First, attempt to allocate < 4GB. We do this unconditionally:\n+  \/\/ - if optimize_for_zero_base, a <4GB mapping start allows us to use base=0 shift=0\n+  \/\/ - if !optimize_for_zero_base, a <4GB mapping start allows us to use algfi\n+  result = reserve_address_space_for_unscaled_encoding(size, aslr);\n+\n+  \/\/ Failing that, try optimized for base=0 shift>0\n+  if (result == nullptr && optimize_for_zero_base) {\n+    result = reserve_address_space_for_zerobased_encoding(size, aslr);\n+  }\n+\n+  \/\/ Failing that, aim for a base that is 4G-aligned; such a base can be set with aih.\n+  if (result == nullptr) {\n+    result = reserve_address_space_for_16bit_move(size, aslr);\n+  }\n+\n+  return result;\n+}\n","filename":"src\/hotspot\/cpu\/s390\/compressedKlass_s390.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -290,5 +290,0 @@\n-  \/\/ z\/Architecture supports 8-byte compare-exchange operations\n-  \/\/ (see Atomic::cmpxchg)\n-  \/\/ and 'atomic long memory ops' (see Unsafe_GetLongVolatile).\n-  _supports_cx8 = true;\n-\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3420,0 +3420,21 @@\n+void Assembler::evmovntdquq(Address dst, XMMRegister src, int vector_len) {\n+  \/\/ Unmasked instruction\n+  evmovntdquq(dst, k0, src, \/*merge*\/ true, vector_len);\n+}\n+\n+void Assembler::evmovntdquq(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(src != xnoreg, \"sanity\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_NObit);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(dst, 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0xE7);\n+  emit_operand(src, dst, 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1618,0 +1618,3 @@\n+  void evmovntdquq(Address dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evmovntdquq(Address dst, XMMRegister src, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1932,1 +1932,1 @@\n-  if (LP64_ONLY(false &&) op->code() == lir_cas_long && VM_Version::supports_cx8()) {\n+  if (LP64_ONLY(false &&) op->code() == lir_cas_long) {\n@@ -3632,2 +3632,13 @@\n-  if (tmp != obj) {\n-    __ mov(tmp, obj);\n+#ifdef ASSERT\n+  if (obj == tmp) {\n+#ifdef _LP64\n+    assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+    assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());\n+#endif\n+  } else {\n+#ifdef _LP64\n+    assert_different_registers(obj, tmp, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+    assert_different_registers(obj, tmp, mdo_addr.base(), mdo_addr.index());\n+#endif\n@@ -3635,0 +3646,1 @@\n+#endif\n@@ -3636,1 +3648,1 @@\n-    __ testptr(tmp, tmp);\n+    __ testptr(obj, obj);\n@@ -3639,0 +3651,8 @@\n+      __ testptr(mdo_addr, TypeEntries::null_seen);\n+#ifndef ASSERT\n+      __ jccb(Assembler::notZero, next); \/\/ already set\n+#else\n+      __ jcc(Assembler::notZero, next); \/\/ already set\n+#endif\n+      \/\/ atomic update to prevent overwriting Klass* with 0\n+      __ lock();\n@@ -3649,1 +3669,1 @@\n-    __ testptr(tmp, tmp);\n+    __ testptr(obj, obj);\n@@ -3661,1 +3681,1 @@\n-      __ load_klass(tmp, tmp, tmp_load_klass);\n+      __ load_klass(tmp, obj, tmp_load_klass);\n@@ -3676,1 +3696,1 @@\n-          __ load_klass(tmp, tmp, tmp_load_klass);\n+          __ load_klass(tmp, obj, tmp_load_klass);\n@@ -3678,1 +3698,3 @@\n-\n+#ifdef _LP64\n+        __ mov(rscratch1, tmp); \/\/ save original value before XOR\n+#endif\n@@ -3689,4 +3711,3 @@\n-          __ cmpptr(mdo_addr, 0);\n-          __ jccb(Assembler::equal, none);\n-          __ cmpptr(mdo_addr, TypeEntries::null_seen);\n-          __ jccb(Assembler::equal, none);\n+          __ testptr(mdo_addr, TypeEntries::type_mask);\n+          __ jccb(Assembler::zero, none);\n+#ifdef _LP64\n@@ -3696,0 +3717,1 @@\n+          __ mov(tmp, rscratch1); \/\/ get back original value before XOR\n@@ -3699,0 +3721,1 @@\n+#endif\n@@ -3704,2 +3727,1 @@\n-        __ movptr(tmp, mdo_addr);\n-        __ testptr(tmp, TypeEntries::type_unknown);\n+        __ testptr(mdo_addr, TypeEntries::type_unknown);\n@@ -3718,0 +3740,4 @@\n+#ifdef ASSERT\n+        __ andptr(tmp, TypeEntries::type_klass_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -3732,4 +3758,2 @@\n-          __ cmpptr(mdo_addr, 0);\n-          __ jcc(Assembler::equal, ok);\n-          __ cmpptr(mdo_addr, TypeEntries::null_seen);\n-          __ jcc(Assembler::equal, ok);\n+          __ testptr(mdo_addr, TypeEntries::type_mask);\n+          __ jcc(Assembler::zero, ok);\n@@ -3751,0 +3775,4 @@\n+#ifdef ASSERT\n+        __ andptr(tmp, TypeEntries::type_klass_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -3755,2 +3783,1 @@\n-        __ movptr(tmp, mdo_addr);\n-        __ testptr(tmp, TypeEntries::type_unknown);\n+        __ testptr(mdo_addr, TypeEntries::type_unknown);\n@@ -3762,2 +3789,0 @@\n-\n-    __ bind(next);\n@@ -3765,0 +3790,1 @@\n+  __ bind(next);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":48,"deletions":22,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef _LP64\n+\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+char* CompressedKlassPointers::reserve_address_space_for_compressed_classes(size_t size, bool aslr, bool optimize_for_zero_base) {\n+\n+  char* result = nullptr;\n+\n+  \/\/ Optimize for unscaled encoding; failing that, for zero-based encoding:\n+  if (optimize_for_zero_base) {\n+    result = reserve_address_space_for_unscaled_encoding(size, aslr);\n+    if (result == nullptr) {\n+      result = reserve_address_space_for_zerobased_encoding(size, aslr);\n+    }\n+  } \/\/ end: low-address reservation\n+\n+  \/\/ Nothing more to optimize for on x64. If base != 0, we will always emit the full 64-bit immediate.\n+  return result;\n+}\n+\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/compressedKlass_x86.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -36,1 +36,0 @@\n-  predicate(VM_Version::supports_cx8());\n@@ -98,1 +97,0 @@\n-  predicate(VM_Version::supports_cx8());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoah_x86_64.ad","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,6 @@\n+#ifdef _LP64\n+  assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+  assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());\n+#endif\n+\n@@ -61,0 +67,4 @@\n+  testptr(mdo_addr, TypeEntries::null_seen);\n+  jccb(Assembler::notZero, next); \/\/ null already seen. Nothing to do anymore.\n+  \/\/ atomic update to prevent overwriting Klass* with 0\n+  lock();\n@@ -66,0 +76,3 @@\n+#ifdef _LP64\n+  mov(rscratch1, obj);\n+#endif\n@@ -80,0 +93,1 @@\n+#ifdef _LP64\n@@ -83,0 +97,1 @@\n+  mov(obj, rscratch1);\n@@ -86,0 +101,1 @@\n+#endif\n@@ -94,0 +110,4 @@\n+#ifdef ASSERT\n+  andptr(obj, TypeEntries::type_klass_mask);\n+  verify_klass_ptr(obj);\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -897,0 +897,1 @@\n+  void testptr(Address src, int32_t imm32) {  LP64_ONLY(testq(src, imm32)) NOT_LP64(testl(src, imm32)); }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -190,0 +190,4 @@\n+  void arraycopy_avx3_special_cases_256(XMMRegister xmm, KRegister mask, Register from,\n+                                    Register to, Register count, int shift,\n+                                    Register index, Register temp, Label& L_exit);\n+\n@@ -195,0 +199,5 @@\n+  void arraycopy_avx3_large(Register to, Register from, Register temp1, Register temp2,\n+                            Register temp3, Register temp4, Register count,\n+                            XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                            XMMRegister xmm4, int shift);\n+\n@@ -202,0 +211,3 @@\n+  void copy256_avx3(Register dst, Register src, Register index, XMMRegister xmm1, XMMRegister xmm2,\n+                                XMMRegister xmm3, XMMRegister xmm4, int shift, int offset = 0);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -518,0 +518,1 @@\n+  const int large_threshold = 2621440; \/\/ 2.5 MB\n@@ -520,0 +521,1 @@\n+  Label L_copy_large, L_finish;\n@@ -580,0 +582,6 @@\n+    if (MaxVectorSize == 64) {\n+      __ movq(temp2, temp1);\n+      __ shlq(temp2, shift);\n+      __ cmpq(temp2, large_threshold);\n+      __ jcc(Assembler::greaterEqual, L_copy_large);\n+    }\n@@ -706,0 +714,1 @@\n+  __ BIND(L_finish);\n@@ -720,0 +729,5 @@\n+  if (MaxVectorSize == 64) {\n+    __ BIND(L_copy_large);\n+    arraycopy_avx3_large(to, from, temp1, temp2, temp3, temp4, count, xmm1, xmm2, xmm3, xmm4, shift);\n+    __ jmp(L_finish);\n+  }\n@@ -723,0 +737,63 @@\n+void StubGenerator::arraycopy_avx3_large(Register to, Register from, Register temp1, Register temp2,\n+                                         Register temp3, Register temp4, Register count,\n+                                         XMMRegister xmm1, XMMRegister xmm2, XMMRegister xmm3,\n+                                         XMMRegister xmm4, int shift) {\n+\n+  \/\/ Type(shift)           byte(0), short(1), int(2),   long(3)\n+  int loop_size[]        = { 256,     128,       64,      32};\n+  int threshold[]        = { 4096,    2048,     1024,    512};\n+\n+  Label L_main_loop_large;\n+  Label L_tail_large;\n+  Label L_exit_large;\n+  Label L_entry_large;\n+  Label L_main_pre_loop_large;\n+  Label L_pre_main_post_large;\n+\n+  assert(MaxVectorSize == 64, \"vector length != 64\");\n+  __ BIND(L_entry_large);\n+\n+  __ BIND(L_pre_main_post_large);\n+  \/\/ Partial copy to make dst address 64 byte aligned.\n+  __ movq(temp2, to);\n+  __ andq(temp2, 63);\n+  __ jcc(Assembler::equal, L_main_pre_loop_large);\n+\n+  __ negptr(temp2);\n+  __ addq(temp2, 64);\n+  if (shift) {\n+    __ shrq(temp2, shift);\n+  }\n+  __ movq(temp3, temp2);\n+  copy64_masked_avx(to, from, xmm1, k2, temp3, temp4, temp1, shift, 0, true);\n+  __ movq(temp4, temp2);\n+  __ movq(temp1, count);\n+  __ subq(temp1, temp2);\n+\n+  __ cmpq(temp1, loop_size[shift]);\n+  __ jcc(Assembler::less, L_tail_large);\n+\n+  __ BIND(L_main_pre_loop_large);\n+  __ subq(temp1, loop_size[shift]);\n+\n+  \/\/ Main loop with aligned copy block size of 256 bytes at 64 byte copy granularity.\n+  __ align32();\n+  __ BIND(L_main_loop_large);\n+  copy256_avx3(to, from, temp4, xmm1, xmm2, xmm3, xmm4, shift, 0);\n+  __ addptr(temp4, loop_size[shift]);\n+  __ subq(temp1, loop_size[shift]);\n+  __ jcc(Assembler::greater, L_main_loop_large);\n+  \/\/ fence needed because copy256_avx3 uses non-temporal stores\n+  __ sfence();\n+\n+  __ addq(temp1, loop_size[shift]);\n+  \/\/ Zero length check.\n+  __ jcc(Assembler::lessEqual, L_exit_large);\n+  __ BIND(L_tail_large);\n+  \/\/ Tail handling using 64 byte [masked] vector copy operations.\n+  __ cmpq(temp1, 0);\n+  __ jcc(Assembler::lessEqual, L_exit_large);\n+  arraycopy_avx3_special_cases_256(xmm1, k2, from, to, temp1, shift,\n+                               temp4, temp3, L_exit_large);\n+  __ BIND(L_exit_large);\n+}\n@@ -968,0 +1045,49 @@\n+void StubGenerator::arraycopy_avx3_special_cases_256(XMMRegister xmm, KRegister mask, Register from,\n+                                                     Register to, Register count, int shift, Register index,\n+                                                     Register temp, Label& L_exit) {\n+  Label L_entry_64, L_entry_128, L_entry_192, L_entry_256;\n+\n+  int size_mat[][4] = {\n+  \/* T_BYTE *\/ {64, 128, 192, 256},\n+  \/* T_SHORT*\/ {32, 64 , 96 , 128},\n+  \/* T_INT  *\/ {16, 32 , 48 ,  64},\n+  \/* T_LONG *\/ { 8, 16 , 24 ,  32}\n+  };\n+\n+  assert(MaxVectorSize == 64, \"vector length != 64\");\n+  \/\/ Case A) Special case for length less than or equal to 64 bytes.\n+  __ BIND(L_entry_64);\n+  __ cmpq(count, size_mat[shift][0]);\n+  __ jccb(Assembler::greater, L_entry_128);\n+  copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 0, true);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case B) Special case for length less than or equal to 128 bytes.\n+  __ BIND(L_entry_128);\n+  __ cmpq(count, size_mat[shift][1]);\n+  __ jccb(Assembler::greater, L_entry_192);\n+  copy64_avx(to, from, index, xmm, false, shift, 0, true);\n+  __ subq(count, 64 >> shift);\n+  copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 64, true);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case C) Special case for length less than or equal to 192 bytes.\n+  __ BIND(L_entry_192);\n+  __ cmpq(count, size_mat[shift][2]);\n+  __ jcc(Assembler::greater, L_entry_256);\n+  copy64_avx(to, from, index, xmm, false, shift, 0, true);\n+  copy64_avx(to, from, index, xmm, false, shift, 64, true);\n+  __ subq(count, 128 >> shift);\n+  copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 128, true);\n+  __ jmp(L_exit);\n+\n+  \/\/ Case D) Special case for length less than or equal to 256 bytes.\n+  __ BIND(L_entry_256);\n+  copy64_avx(to, from, index, xmm, false, shift, 0, true);\n+  copy64_avx(to, from, index, xmm, false, shift, 64, true);\n+  copy64_avx(to, from, index, xmm, false, shift, 128, true);\n+  __ subq(count, 192 >> shift);\n+  copy64_masked_avx(to, from, xmm, mask, count, index, temp, shift, 192, true);\n+  __ jmp(L_exit);\n+}\n+\n@@ -1043,0 +1169,27 @@\n+void StubGenerator::copy256_avx3(Register dst, Register src, Register index, XMMRegister xmm1,\n+                                XMMRegister xmm2, XMMRegister xmm3, XMMRegister xmm4,\n+                                int shift, int offset) {\n+  if (MaxVectorSize == 64) {\n+    Address::ScaleFactor scale = (Address::ScaleFactor)(shift);\n+    __ prefetcht0(Address(src, index, scale, offset + 0x200));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x240));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x280));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x2C0));\n+\n+    __ prefetcht0(Address(src, index, scale, offset + 0x400));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x440));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x480));\n+    __ prefetcht0(Address(src, index, scale, offset + 0x4C0));\n+\n+    __ evmovdquq(xmm1, Address(src, index, scale, offset), Assembler::AVX_512bit);\n+    __ evmovdquq(xmm2, Address(src, index, scale, offset + 0x40), Assembler::AVX_512bit);\n+    __ evmovdquq(xmm3, Address(src, index, scale, offset + 0x80), Assembler::AVX_512bit);\n+    __ evmovdquq(xmm4, Address(src, index, scale, offset + 0xC0), Assembler::AVX_512bit);\n+\n+    __ evmovntdquq(Address(dst, index, scale, offset), xmm1, Assembler::AVX_512bit);\n+    __ evmovntdquq(Address(dst, index, scale, offset + 0x40), xmm2, Assembler::AVX_512bit);\n+    __ evmovntdquq(Address(dst, index, scale, offset + 0x80), xmm3, Assembler::AVX_512bit);\n+    __ evmovntdquq(Address(dst, index, scale, offset + 0xC0), xmm4, Assembler::AVX_512bit);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":153,"deletions":0,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -819,1 +819,0 @@\n-  _supports_cx8 = supports_cmpxchg8();\n@@ -3239,1 +3238,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -646,1 +646,0 @@\n-  static bool supports_cmpxchg8()     { return (_features & CPU_CX8) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1513,3 +1513,0 @@\n-      if (!VM_Version::supports_cx8()) {\n-        return false;\n-      }\n@@ -10122,2 +10119,0 @@\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7284,1 +7284,0 @@\n-  predicate(VM_Version::supports_cx8());\n@@ -7353,1 +7352,0 @@\n-  predicate(VM_Version::supports_cx8());\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -7177,1 +7177,1 @@\n-  predicate(VM_Version::supports_cx8() && n->as_LoadStore()->barrier_data() == 0);\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n@@ -7200,1 +7200,0 @@\n-  predicate(VM_Version::supports_cx8());\n@@ -7361,1 +7360,0 @@\n-  predicate(VM_Version::supports_cx8());\n@@ -7395,1 +7393,1 @@\n-  predicate(VM_Version::supports_cx8() && n->as_LoadStore()->barrier_data() == 0);\n+  predicate(n->as_LoadStore()->barrier_data() == 0);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,0 +140,8 @@\n+\n+#ifndef SUPPORTS_NATIVE_CX8\n+  \/\/ Supports 8-byte cmpxchg with compiler built-ins.\n+  \/\/ These built-ins are supposed to be implemented on\n+  \/\/ all platforms (even if not natively), so we claim\n+  \/\/ the support unconditionally.\n+  _supports_cx8 = true;\n+#endif\n@@ -148,6 +156,0 @@\n-  \/\/ Supports 8-byte cmpxchg with compiler built-ins.\n-  \/\/ These built-ins are supposed to be implemented on\n-  \/\/ all platforms (even if not natively), so we claim\n-  \/\/ the support unconditionally.\n-  _supports_cx8 = true;\n-\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1020,0 +1020,4 @@\n+void os::prepare_native_symbols() {\n+  LoadedLibraries::reload();\n+}\n+\n@@ -1917,4 +1921,0 @@\n-char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {\n-  return end;\n-}\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -898,0 +898,3 @@\n+void os::prepare_native_symbols() {\n+}\n+\n@@ -1677,5 +1680,0 @@\n-char *os::scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found) {\n-  return end;\n-}\n-\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1473,0 +1473,3 @@\n+void os::prepare_native_symbols() {\n+}\n+\n@@ -3015,6 +3018,0 @@\n-char *os::scan_pages(char *start, char* end, page_info* page_expected,\n-                     page_info* page_found) {\n-  return end;\n-}\n-\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -346,1 +346,1 @@\n-  assert((alignment & (os::vm_allocation_granularity() - 1)) == 0,\n+  assert(is_aligned(alignment, os::vm_allocation_granularity()),\n@@ -348,1 +348,2 @@\n-  assert((size & (alignment -1)) == 0, \"size must be 'alignment' aligned\");\n+  assert(is_aligned(size, os::vm_allocation_granularity()),\n+      \"Size must be a multiple of allocation granularity (page size)\");\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1401,0 +1401,3 @@\n+void os::prepare_native_symbols() {\n+}\n+\n@@ -3331,3 +3334,4 @@\n-  assert((alignment & (os::vm_allocation_granularity() - 1)) == 0,\n-         \"Alignment must be a multiple of allocation granularity (page size)\");\n-  assert((size & (alignment -1)) == 0, \"size must be 'alignment' aligned\");\n+  assert(is_aligned(alignment, os::vm_allocation_granularity()),\n+      \"Alignment must be a multiple of allocation granularity (page size)\");\n+  assert(is_aligned(size, os::vm_allocation_granularity()),\n+      \"Size must be a multiple of allocation granularity (page size)\");\n@@ -3828,5 +3832,0 @@\n-char *os::scan_pages(char *start, char* end, page_info* page_expected,\n-                     page_info* page_found) {\n-  return end;\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -156,1 +156,0 @@\n-  assert(VM_Version::supports_cx8(), \"Atomic compare and exchange int64_t not supported on this architecture!\");\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/atomic_linux_arm.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-        register unsigned long __v;                             \\\n+        unsigned long __v;                                      \\\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,0 @@\n-    if (!VM_Version::supports_cx8()) return false;\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2520,0 +2520,2 @@\n+          \/\/ locals are preserved\n+          \/\/ stack will be truncated\n@@ -2569,5 +2571,1 @@\n-      if (_compilation->env()->should_retain_local_variables()) {\n-        cur_state = cur_state->copy(ValueStack::ExceptionState, cur_state->bci());\n-      } else {\n-        cur_state = cur_state->copy(ValueStack::EmptyExceptionState, cur_state->bci());\n-      }\n+      \/\/ Stack and locals are invalidated but not truncated in caller state.\n@@ -2575,0 +2573,4 @@\n+        assert(instruction->exception_state() != nullptr, \"missed set?\");\n+        ValueStack::Kind exc_kind = ValueStack::empty_exception_kind(true \/* caller *\/);\n+        cur_state = cur_state->copy(exc_kind, cur_state->bci());\n+        \/\/ reset caller exception state\n@@ -2576,2 +2578,6 @@\n-      }\n-      if (instruction->exception_state() == nullptr) {\n+      } else {\n+        assert(instruction->exception_state() == nullptr, \"already set\");\n+        \/\/ set instruction exception state\n+        \/\/ truncate stack\n+        ValueStack::Kind exc_kind = ValueStack::empty_exception_kind();\n+        cur_state = cur_state->copy(exc_kind, cur_state->bci());\n@@ -3490,5 +3496,3 @@\n-    if (_compilation->env()->should_retain_local_variables()) {\n-      s = state()->copy(ValueStack::ExceptionState, bci);\n-    } else {\n-      s = state()->copy(ValueStack::EmptyExceptionState, bci);\n-    }\n+    \/\/ no handler, no need to retain locals\n+    ValueStack::Kind exc_kind = ValueStack::empty_exception_kind();\n+    s = state()->copy(exc_kind, bci);\n@@ -3509,1 +3513,0 @@\n-\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -406,2 +406,14 @@\n-    if (s->kind() == ValueStack::EmptyExceptionState) {\n-      assert(s->stack_size() == 0 && s->locals_size() == 0 && (s->locks_size() == 0 || s->locks_size() == 1), \"state must be empty\");\n+    if (s->kind() == ValueStack::EmptyExceptionState ||\n+        s->kind() == ValueStack::CallerEmptyExceptionState)\n+    {\n+#ifdef ASSERT\n+      int index;\n+      Value value;\n+      for_each_stack_value(s, index, value) {\n+        fatal(\"state must be empty\");\n+      }\n+      for_each_local_value(s, index, value) {\n+        fatal(\"state must be empty\");\n+      }\n+#endif\n+      assert(s->locks_size() == 0 || s->locks_size() == 1, \"state must be empty\");\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2924,9 +2924,1 @@\n-    assert(locals->length() == cur_scope->method()->max_locals(), \"wrong number of locals\");\n-    assert(locals->length() == cur_state->locals_size(), \"wrong number of locals\");\n-  } else if (cur_scope->method()->max_locals() > 0) {\n-    assert(cur_state->kind() == ValueStack::EmptyExceptionState, \"should be\");\n-    nof_locals = cur_scope->method()->max_locals();\n-    locals = new GrowableArray<ScopeValue*>(nof_locals);\n-    for(int i = 0; i < nof_locals; i++) {\n-      locals->append(_illegal_value);\n-    }\n+    assert(locals->length() == nof_locals, \"wrong number of locals\");\n@@ -2934,0 +2926,2 @@\n+  assert(nof_locals == cur_scope->method()->max_locals(), \"wrong number of locals\");\n+  assert(nof_locals == cur_state->locals_size(), \"wrong number of locals\");\n@@ -2942,2 +2936,2 @@\n-      Value expression = cur_state->stack_at_inc(pos);\n-      append_scope_value(op_id, expression, expressions);\n+      Value expression = cur_state->stack_at(pos);\n+      pos += append_scope_value(op_id, expression, expressions);\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -54,2 +54,10 @@\n-  assert(kind != EmptyExceptionState || !Compilation::current()->env()->should_retain_local_variables(), \"need locals\");\n-  if (kind != EmptyExceptionState) {\n+  switch (kind) {\n+  case EmptyExceptionState:\n+  case CallerEmptyExceptionState:\n+    assert(!Compilation::current()->env()->should_retain_local_variables(), \"need locals\");\n+    \/\/ set to all nulls, like clear_locals()\n+    for (int i = 0; i < copy_from->locals_size(); ++i) {\n+      _locals.append(nullptr);\n+    }\n+    break;\n+  default:\n@@ -59,1 +67,13 @@\n-  if (kind != ExceptionState && kind != EmptyExceptionState) {\n+  switch (kind) {\n+  case ExceptionState:\n+  case EmptyExceptionState:\n+    assert(stack_size() == 0, \"fix stack_size_for_copy\");\n+    break;\n+  case CallerExceptionState:\n+  case CallerEmptyExceptionState:\n+    \/\/ set to all nulls\n+    for (int i = 0; i < copy_from->stack_size(); ++i) {\n+      _stack.append(nullptr);\n+    }\n+    break;\n+  default:\n@@ -71,4 +91,1 @@\n-  if (kind != EmptyExceptionState) {\n-    return locals_size();\n-  }\n-  return 0;\n+  return locals_size();\n@@ -224,0 +241,1 @@\n+      tty->print(\"stack %d \", i);\n@@ -225,3 +243,7 @@\n-      tty->print(\"%2d  \", i);\n-      tty->print(\"%c%d \", t->type()->tchar(), t->id());\n-      ip.print_instr(t);\n+      if (t == nullptr) {\n+        tty->print(\"null\");\n+      } else {\n+        tty->print(\"%2d  \", i);\n+        tty->print(\"%c%d \", t->type()->tchar(), t->id());\n+        ip.print_instr(t);\n+      }\n@@ -287,1 +309,3 @@\n-    if (v == nullptr) {\n+    if (kind() == empty_exception_kind(true \/* caller *\/)) {\n+      assert(v == nullptr, \"should be empty\");\n+    } else if (v == nullptr) {\n@@ -296,1 +320,3 @@\n-    if (v != nullptr && v->type()->is_double_word()) {\n+    if (kind() == EmptyExceptionState) {\n+      assert(v == nullptr, \"should be empty\");\n+    } else if (v != nullptr && v->type()->is_double_word()) {\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.cpp","additions":38,"deletions":12,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -37,2 +37,12 @@\n-    ExceptionState,      \/\/ Exception handling of instruction\n-    EmptyExceptionState, \/\/ Exception handling of instructions not covered by an xhandler\n+    \/\/ Exception states for an instruction.\n+    \/\/ Dead stack items or locals may be invalidated or cleared\/removed.\n+    \/\/ Locals are retained if needed for JVMTI.\n+    \/\/ \"empty\" exception states are used when there is no handler,\n+    \/\/ and invalidate the locals.\n+    \/\/ \"leaf\" exception states clear the stack.\n+    \/\/ \"caller\" exception states are used for the parent\/caller,\n+    \/\/ and invalidate the stack.\n+    ExceptionState,      \/\/ Exception state for leaf with handler, stack cleared\n+    EmptyExceptionState, \/\/ Exception state for leaf w\/o handler, stack cleared, locals invalidated\n+    CallerExceptionState, \/\/ Exception state for parent with handler, stack invalidated\n+    CallerEmptyExceptionState, \/\/ Exception state for parent w\/o handler, stack+locals invalidated\n@@ -78,0 +88,7 @@\n+  \/\/ Used when no exception handler is found\n+  static Kind empty_exception_kind(bool caller = false) {\n+    return Compilation::current()->env()->should_retain_local_variables() ?\n+      (caller ? CallerExceptionState : ExceptionState) : \/\/ retain locals\n+      (caller ? CallerEmptyExceptionState : EmptyExceptionState);   \/\/ clear locals\n+  }\n+\n@@ -79,3 +96,2 @@\n-    assert(kind() == EmptyExceptionState ||\n-           (Compilation::current()->env()->should_retain_local_variables() && kind() == ExceptionState),\n-           \"only EmptyExceptionStates can be modified\");\n+    assert(kind() == empty_exception_kind(false) || kind() == empty_exception_kind(true),\n+           \"only empty exception states can be modified\");\n@@ -136,1 +152,1 @@\n-    assert(!x->type()->is_double_word() ||\n+    assert(x == nullptr || !x->type()->is_double_word() ||\n@@ -143,1 +159,1 @@\n-    i += x->type()->size();\n+    i += ((x == nullptr) ? 1 : x->type()->size());\n@@ -263,1 +279,2 @@\n-       index += value->type()->size())\n+       index += (value == nullptr ? 1 : value->type()->size()))                                \\\n+    if (value != nullptr)\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.hpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -144,5 +144,10 @@\n-#ifdef _LP64\n-  return CompressedKlassPointers::is_valid_base((address)shared_base);\n-#else\n-  return true;\n-#endif\n+  \/\/ We check user input for SharedBaseAddress at dump time. We must weed out values\n+  \/\/ we already know to be invalid later.\n+\n+  \/\/ At CDS runtime, \"shared_base\" will be the (attempted) mapping start. It will also\n+  \/\/ be the encoding base, since the the headers of archived base objects (and with Lilliput,\n+  \/\/ the prototype mark words) carry pre-computed narrow Klass IDs that refer to the mapping\n+  \/\/ start as base.\n+  \/\/\n+  \/\/ Therefore, \"shared_base\" must be later usable as encoding base.\n+  return AARCH64_ONLY(is_aligned(shared_base, 4 * G)) NOT_AARCH64(true);\n@@ -1260,6 +1265,0 @@\n-#ifdef _LP64\n-    if (Metaspace::using_class_space()) {\n-      assert(CompressedKlassPointers::is_valid_base(base_address),\n-             \"Archive base address invalid: \" PTR_FORMAT \".\", p2i(base_address));\n-    }\n-#endif\n@@ -1335,2 +1334,2 @@\n-      \/\/ case we reserve whereever possible, but the start address needs to be encodable as narrow Klass\n-      \/\/ encoding base since the archived heap objects contain nKlass IDs precalculated toward the start\n+      \/\/ case we reserve wherever possible, but the start address needs to be encodable as narrow Klass\n+      \/\/ encoding base since the archived heap objects contain nKlass IDs pre-calculated toward the start\n@@ -1339,1 +1338,1 @@\n-      total_space_rs = Metaspace::reserve_address_space_for_compressed_classes(total_range_size, false \/* try_in_low_address_ranges *\/);\n+      total_space_rs = Metaspace::reserve_address_space_for_compressed_classes(total_range_size, false \/* optimize_for_zero_base *\/);\n@@ -1351,1 +1350,0 @@\n-    assert(CompressedKlassPointers::is_valid_base((address)total_space_rs.base()), \"Sanity\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+  _parameters_data_offset(0),\n+  _exception_handlers_data_offset(0),\n@@ -53,2 +55,1 @@\n-  _orig(),\n-  _parameters(nullptr) {}\n+  _orig() {}\n@@ -137,2 +138,10 @@\n-                              (HeapWord*)((address) _data + _data_size),\n-                              (_extra_data_size - mdo->parameters_size_in_bytes()) \/ HeapWordSize);\n+                              (HeapWord*) extra_data_base(),\n+                              \/\/ copy everything from extra_data_base() up to parameters_data_base()\n+                              pointer_delta(parameters_data_base(), extra_data_base(), HeapWordSize));\n+\n+  \/\/ skip parameter data copying. Already done in 'load_data'\n+\n+  \/\/ copy exception handler data\n+  Copy::disjoint_words_atomic((HeapWord*) mdo->exception_handler_data_base(),\n+                              (HeapWord*) exception_handler_data_base(),\n+                              exception_handler_data_size() \/ HeapWordSize);\n@@ -198,0 +207,3 @@\n+  \/\/  param_data_limit: ---------------------------\n+  \/\/                    | ex handler data entries |\n+  \/\/                    |           ...           |\n@@ -203,1 +215,3 @@\n-  \/\/ args_data_limit = data_base + total_size - parameter_data_size\n+  \/\/ args_data_limit = param_data_base\n+  \/\/ param_data_limit = exception_handler_data_base\n+  \/\/ extra_data_limit = extra_data_limit\n@@ -221,0 +235,3 @@\n+  \/\/ Copy offsets. This is used below\n+  _parameters_data_offset = mdo->parameters_type_data_di();\n+  _exception_handlers_data_offset = mdo->exception_handlers_data_di();\n@@ -225,2 +242,2 @@\n-    Copy::disjoint_words_atomic((HeapWord*) mdo->args_data_limit(),\n-                                (HeapWord*) ((address)_data + total_size - parameters_data_size),\n+    Copy::disjoint_words_atomic((HeapWord*) mdo->parameters_data_base(),\n+                                (HeapWord*) parameters_data_base(),\n@@ -240,2 +257,2 @@\n-    _parameters = data_layout_at(mdo->parameters_type_data_di());\n-    ciParametersTypeData* parameters = new ciParametersTypeData(_parameters);\n+    DataLayout* parameters_data = data_layout_at(_parameters_data_offset);\n+    ciParametersTypeData* parameters = new ciParametersTypeData(parameters_data);\n@@ -245,1 +262,1 @@\n-  assert((DataLayout*) ((address)_data + total_size - parameters_data_size) == args_data_limit(),\n+  assert((DataLayout*) ((address)_data + total_size - parameters_data_size - exception_handler_data_size()) == args_data_limit(),\n@@ -370,1 +387,1 @@\n-DataLayout* ciMethodData::next_data_layout(DataLayout* current) {\n+DataLayout* ciMethodData::next_data_layout_helper(DataLayout* current, bool extra) {\n@@ -373,1 +390,1 @@\n-  if (out_of_bounds(next_index)) {\n+  if (extra ? out_of_bounds_extra(next_index) : out_of_bounds(next_index)) {\n@@ -380,0 +397,8 @@\n+DataLayout* ciMethodData::next_data_layout(DataLayout* current) {\n+  return next_data_layout_helper(current, false);\n+}\n+\n+DataLayout* ciMethodData::next_extra_data_layout(DataLayout* current) {\n+  return next_data_layout_helper(current, true);\n+}\n+\n@@ -441,0 +466,13 @@\n+ciBitData ciMethodData::exception_handler_bci_to_data(int bci) {\n+  assert(ProfileExceptionHandlers, \"not profiling\");\n+  assert(_data != nullptr, \"must be initialized\");\n+  for (DataLayout* data = exception_handler_data_base(); data < exception_handler_data_limit(); data = next_extra_data_layout(data)) {\n+    assert(data != nullptr, \"out of bounds?\");\n+    if (data->bci() == bci) {\n+      return ciBitData(data);\n+    }\n+  }\n+  \/\/ called with invalid bci or wrong Method\/MethodData\n+  ShouldNotReachHere();\n+}\n+\n@@ -615,1 +653,1 @@\n-  return _parameters != nullptr ? new ciParametersTypeData(_parameters) : nullptr;\n+  return parameter_data_size() != 0 ? new ciParametersTypeData(data_layout_at(_parameters_data_offset)) : nullptr;\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":51,"deletions":13,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -382,0 +382,4 @@\n+  \/\/ layout of _data\n+  int _parameters_data_offset;\n+  int _exception_handlers_data_offset;\n+\n@@ -406,6 +410,0 @@\n-  \/\/ Area dedicated to parameters. null if no parameter profiling for this method.\n-  DataLayout* _parameters;\n-  int parameters_size() const {\n-    return _parameters == nullptr ? 0 : parameters_type_data()->size_in_bytes();\n-  }\n-\n@@ -417,0 +415,2 @@\n+  int parameter_data_size() const { return _exception_handlers_data_offset - _parameters_data_offset; }\n+  int exception_handler_data_size() const { return dp_to_di((address) exception_handler_data_limit()) - _exception_handlers_data_offset; }\n@@ -428,1 +428,1 @@\n-    assert(data_index % sizeof(intptr_t) == 0, \"unaligned\");\n+    assert(data_index % sizeof(intptr_t) == 0, \"unaligned: %d\", data_index);\n@@ -436,0 +436,6 @@\n+  bool out_of_bounds_extra(int data_index) {\n+    return data_index < data_size() || data_index >= data_size() + extra_data_size();\n+  }\n+\n+  DataLayout* next_data_layout_helper(DataLayout* current, bool extra);\n+\n@@ -503,1 +509,1 @@\n-  int dp_to_di(address dp) {\n+  int dp_to_di(address dp) const {\n@@ -514,0 +520,1 @@\n+  DataLayout* next_extra_data_layout(DataLayout* current);\n@@ -517,0 +524,3 @@\n+  \/\/ pointers to sections in _data\n+  \/\/ NOTE: these may be called before ciMethodData::load_data\n+  \/\/       this works out since everything is initialized to 0 (i.e. there will appear to be no data)\n@@ -518,2 +528,7 @@\n-  DataLayout* args_data_limit() const  { return data_layout_at(data_size() + extra_data_size() -\n-                                                               parameters_size()); }\n+  DataLayout* extra_data_limit() const { return data_layout_at(data_size() + extra_data_size()); }\n+  \/\/ pointers to sections in extra data\n+  DataLayout* args_data_limit() const  { return parameters_data_base(); }\n+  DataLayout* parameters_data_base() const { return data_layout_at(_parameters_data_offset); }\n+  DataLayout* parameters_data_limit() const { return exception_handler_data_base(); }\n+  DataLayout* exception_handler_data_base() const { return data_layout_at(_exception_handlers_data_offset); }\n+  DataLayout* exception_handler_data_limit() const { return extra_data_limit(); }\n@@ -525,0 +540,2 @@\n+  ciBitData exception_handler_bci_to_data(int bci);\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-  _buffer = new StubQueue(new ICStubInterface, 10*K, InlineCacheBuffer_lock, \"InlineCacheBuffer\");\n+  _buffer = new StubQueue(new ICStubInterface, checked_cast<int>(InlineCacheBufferSize), InlineCacheBuffer_lock, \"InlineCacheBuffer\");\n","filename":"src\/hotspot\/share\/code\/icBuffer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -221,2 +221,0 @@\n-  guarantee(_buffer_size  % stub_alignment() == 0, \"_buffer_size  not aligned\");\n-  guarantee(_buffer_limit % stub_alignment() == 0, \"_buffer_limit not aligned\");\n","filename":"src\/hotspot\/share\/code\/stubs.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -501,0 +501,5 @@\n+  } else if (InlineCacheBufferSize > NonNMethodCodeHeapSize \/ 2) {\n+    jio_fprintf(defaultStream::error_stream(),\n+                \"Invalid InlineCacheBufferSize=\" SIZE_FORMAT \"K. Must be less than or equal to \" SIZE_FORMAT \"K.\\n\",\n+                InlineCacheBufferSize\/K, NonNMethodCodeHeapSize\/2\/K);\n+    status = false;\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -300,2 +300,5 @@\n-DirectiveSet::DirectiveSet(CompilerDirectives* d) :_inlinematchers(nullptr), _directive(d) {\n-  _ideal_phase_name_mask = 0;\n+DirectiveSet::DirectiveSet(CompilerDirectives* d) :\n+  _inlinematchers(nullptr),\n+  _directive(d),\n+  _ideal_phase_name_set(PHASE_NUM_TYPES, mtCompiler)\n+{\n@@ -430,1 +433,1 @@\n-    \/\/ Parse PrintIdealPhaseName and create an efficient lookup mask\n+    \/\/ Parse PrintIdealPhaseName and create a lookup set\n@@ -434,1 +437,1 @@\n-      \/\/ Parse ccstr and create mask\n+      \/\/ Parse ccstr and create set\n@@ -437,2 +440,1 @@\n-        uint64_t mask = 0;\n-        PhaseNameValidator validator(option, mask);\n+        PhaseNameValidator validator(option);\n@@ -440,2 +442,2 @@\n-          assert(mask != 0, \"Must be set\");\n-          set.cloned()->_ideal_phase_name_mask = mask;\n+          assert(!validator.phase_name_set().is_empty(), \"Phase name set must be non-empty\");\n+          set.cloned()->set_ideal_phase_name_set(validator.phase_name_set());\n@@ -624,1 +626,1 @@\n-  set->_ideal_phase_name_mask = src->_ideal_phase_name_mask;\n+  set->set_ideal_phase_name_set(src->_ideal_phase_name_set);\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"opto\/phasetype.hpp\"\n+#include \"utilities\/bitMap.hpp\"\n@@ -131,1 +133,1 @@\n-  uint64_t _ideal_phase_name_mask;\n+  CHeapBitMap _ideal_phase_name_set;\n@@ -200,2 +202,6 @@\n-  void set_ideal_phase_mask(uint64_t mask) { _ideal_phase_name_mask = mask; };\n-  uint64_t ideal_phase_mask() { return _ideal_phase_name_mask; };\n+  void set_ideal_phase_name_set(const BitMap& set) {\n+    _ideal_phase_name_set.set_from(set);\n+  };\n+  bool should_print_phase(const CompilerPhaseType cpt) const {\n+    return _ideal_phase_name_set.at(cpt);\n+  };\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -780,2 +780,1 @@\n-        uint64_t mask = 0;\n-        PhaseNameValidator validator(value, mask);\n+        PhaseNameValidator validator(value);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -339,2 +339,1 @@\n-          uint64_t mask = 0;\n-          PhaseNameValidator validator(s, mask);\n+          PhaseNameValidator validator(s);\n@@ -344,1 +343,1 @@\n-            set->set_ideal_phase_mask(mask);\n+            set->set_ideal_phase_name_set(validator.phase_name_set());\n","filename":"src\/hotspot\/share\/compiler\/directivesParser.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -81,1 +81,0 @@\n-#include \"gc\/shared\/gcLocker.inline.hpp\"\n@@ -84,1 +83,0 @@\n-#include \"gc\/shared\/generationSpec.hpp\"\n@@ -415,4 +413,3 @@\n-  \/\/ We will loop until a) we manage to successfully perform the\n-  \/\/ allocation or b) we successfully schedule a collection which\n-  \/\/ fails to perform the allocation. b) is the only case when we'll\n-  \/\/ return null.\n+  \/\/ We will loop until a) we manage to successfully perform the allocation or b)\n+  \/\/ successfully schedule a collection which fails to perform the allocation.\n+  \/\/ Case b) is the only case when we'll return null.\n@@ -420,2 +417,1 @@\n-  for (uint try_count = 1, gclocker_retry_count = 0; \/* we'll return *\/; try_count += 1) {\n-    bool should_try_gc;\n+  for (uint try_count = 1; \/* we'll return *\/; try_count++) {\n@@ -434,16 +430,0 @@\n-      \/\/ If the GCLocker is active and we are bound for a GC, try expanding young gen.\n-      \/\/ This is different to when only GCLocker::needs_gc() is set: try to avoid\n-      \/\/ waiting because the GCLocker is active to not wait too long.\n-      if (GCLocker::is_active_and_needs_gc() && policy()->can_expand_young_list()) {\n-        \/\/ No need for an ergo message here, can_expand_young_list() does this when\n-        \/\/ it returns true.\n-        result = _allocator->attempt_allocation_force(word_size);\n-        if (result != nullptr) {\n-          return result;\n-        }\n-      }\n-\n-      \/\/ Only try a GC if the GCLocker does not signal the need for a GC. Wait until\n-      \/\/ the GCLocker initiated GC has been performed and then retry. This includes\n-      \/\/ the case when the GC Locker is not active but has not been performed.\n-      should_try_gc = !GCLocker::needs_gc();\n@@ -454,32 +434,6 @@\n-    if (should_try_gc) {\n-      bool succeeded;\n-      result = do_collection_pause(word_size, gc_count_before, &succeeded, GCCause::_g1_inc_collection_pause);\n-      if (result != nullptr) {\n-        assert(succeeded, \"only way to get back a non-null result\");\n-        log_trace(gc, alloc)(\"%s: Successfully scheduled collection returning \" PTR_FORMAT,\n-                             Thread::current()->name(), p2i(result));\n-        return result;\n-      }\n-\n-      if (succeeded) {\n-        \/\/ We successfully scheduled a collection which failed to allocate. No\n-        \/\/ point in trying to allocate further. We'll just return null.\n-        log_trace(gc, alloc)(\"%s: Successfully scheduled collection failing to allocate \"\n-                             SIZE_FORMAT \" words\", Thread::current()->name(), word_size);\n-        return nullptr;\n-      }\n-      log_trace(gc, alloc)(\"%s: Unsuccessfully scheduled collection allocating \" SIZE_FORMAT \" words\",\n-                           Thread::current()->name(), word_size);\n-    } else {\n-      \/\/ Failed to schedule a collection.\n-      if (gclocker_retry_count > GCLockerRetryAllocationCount) {\n-        log_warning(gc, alloc)(\"%s: Retried waiting for GCLocker too often allocating \"\n-                               SIZE_FORMAT \" words\", Thread::current()->name(), word_size);\n-        return nullptr;\n-      }\n-      log_trace(gc, alloc)(\"%s: Stall until clear\", Thread::current()->name());\n-      \/\/ The GCLocker is either active or the GCLocker initiated\n-      \/\/ GC has not yet been performed. Stall until it is and\n-      \/\/ then retry the allocation.\n-      GCLocker::stall_until_clear();\n-      gclocker_retry_count += 1;\n+    bool succeeded;\n+    result = do_collection_pause(word_size, gc_count_before, &succeeded, GCCause::_g1_inc_collection_pause);\n+    if (succeeded) {\n+      log_trace(gc, alloc)(\"%s: Successfully scheduled collection returning \" PTR_FORMAT,\n+                           Thread::current()->name(), p2i(result));\n+      return result;\n@@ -488,7 +442,8 @@\n-    \/\/ We can reach here if we were unsuccessful in scheduling a\n-    \/\/ collection (because another thread beat us to it) or if we were\n-    \/\/ stalled due to the GC locker. In either can we should retry the\n-    \/\/ allocation attempt in case another thread successfully\n-    \/\/ performed a collection and reclaimed enough space. We do the\n-    \/\/ first attempt (without holding the Heap_lock) here and the\n-    \/\/ follow-on attempt will be at the start of the next loop\n+    log_trace(gc, alloc)(\"%s: Unsuccessfully scheduled collection allocating \" SIZE_FORMAT \" words\",\n+                         Thread::current()->name(), word_size);\n+\n+    \/\/ We can reach here if we were unsuccessful in scheduling a collection (because\n+    \/\/ another thread beat us to it). In this case immeditealy retry the allocation\n+    \/\/ attempt because another thread successfully performed a collection and possibly\n+    \/\/ reclaimed enough space. The first attempt (without holding the Heap_lock) is\n+    \/\/ here and the follow-on attempt will be at the start of the next loop\n@@ -677,4 +632,3 @@\n-  \/\/ We will loop until a) we manage to successfully perform the\n-  \/\/ allocation or b) we successfully schedule a collection which\n-  \/\/ fails to perform the allocation. b) is the only case when we'll\n-  \/\/ return null.\n+  \/\/ We will loop until a) we manage to successfully perform the allocation or b)\n+  \/\/ successfully schedule a collection which fails to perform the allocation.\n+  \/\/ Case b) is the only case when we'll return null.\n@@ -682,2 +636,1 @@\n-  for (uint try_count = 1, gclocker_retry_count = 0; \/* we'll return *\/; try_count += 1) {\n-    bool should_try_gc;\n+  for (uint try_count = 1; \/* we'll return *\/; try_count++) {\n@@ -701,4 +654,0 @@\n-      \/\/ Only try a GC if the GCLocker does not signal the need for a GC. Wait until\n-      \/\/ the GCLocker initiated GC has been performed and then retry. This includes\n-      \/\/ the case when the GC Locker is not active but has not been performed.\n-      should_try_gc = !GCLocker::needs_gc();\n@@ -709,3 +658,5 @@\n-    if (should_try_gc) {\n-      bool succeeded;\n-      result = do_collection_pause(word_size, gc_count_before, &succeeded, GCCause::_g1_humongous_allocation);\n+    bool succeeded;\n+    result = do_collection_pause(word_size, gc_count_before, &succeeded, GCCause::_g1_humongous_allocation);\n+    if (succeeded) {\n+      log_trace(gc, alloc)(\"%s: Successfully scheduled collection returning \" PTR_FORMAT,\n+                           Thread::current()->name(), p2i(result));\n@@ -713,3 +664,0 @@\n-        assert(succeeded, \"only way to get back a non-null result\");\n-        log_trace(gc, alloc)(\"%s: Successfully scheduled collection returning \" PTR_FORMAT,\n-                             Thread::current()->name(), p2i(result));\n@@ -719,18 +667,0 @@\n-        return result;\n-      }\n-\n-      if (succeeded) {\n-        \/\/ We successfully scheduled a collection which failed to allocate. No\n-        \/\/ point in trying to allocate further. We'll just return null.\n-        log_trace(gc, alloc)(\"%s: Successfully scheduled collection failing to allocate \"\n-                             SIZE_FORMAT \" words\", Thread::current()->name(), word_size);\n-        return nullptr;\n-      }\n-      log_trace(gc, alloc)(\"%s: Unsuccessfully scheduled collection allocating \" SIZE_FORMAT \"\",\n-                           Thread::current()->name(), word_size);\n-    } else {\n-      \/\/ Failed to schedule a collection.\n-      if (gclocker_retry_count > GCLockerRetryAllocationCount) {\n-        log_warning(gc, alloc)(\"%s: Retried waiting for GCLocker too often allocating \"\n-                               SIZE_FORMAT \" words\", Thread::current()->name(), word_size);\n-        return nullptr;\n@@ -738,6 +668,1 @@\n-      log_trace(gc, alloc)(\"%s: Stall until clear\", Thread::current()->name());\n-      \/\/ The GCLocker is either active or the GCLocker initiated\n-      \/\/ GC has not yet been performed. Stall until it is and\n-      \/\/ then retry the allocation.\n-      GCLocker::stall_until_clear();\n-      gclocker_retry_count += 1;\n+      return result;\n@@ -746,0 +671,2 @@\n+    log_trace(gc, alloc)(\"%s: Unsuccessfully scheduled collection allocating \" SIZE_FORMAT \"\",\n+                         Thread::current()->name(), word_size);\n@@ -747,5 +674,2 @@\n-    \/\/ We can reach here if we were unsuccessful in scheduling a\n-    \/\/ collection (because another thread beat us to it) or if we were\n-    \/\/ stalled due to the GC locker. In either can we should retry the\n-    \/\/ allocation attempt in case another thread successfully\n-    \/\/ performed a collection and reclaimed enough space.\n+    \/\/ We can reach here if we were unsuccessful in scheduling a collection (because\n+    \/\/ another thread beat us to it).\n@@ -758,1 +682,1 @@\n-      log_warning(gc, alloc)(\"%s: Retried allocation %u times for \" SIZE_FORMAT \" words\",\n+      log_warning(gc, alloc)(\"%s: Retried allocation %u times for %zu words\",\n@@ -912,5 +836,0 @@\n-  if (GCLocker::check_active_before_gc()) {\n-    \/\/ Full GC was not completed.\n-    return false;\n-  }\n-\n@@ -1273,3 +1192,5 @@\n-  \/\/ Override the default _filler_array_max_size so that no humongous filler\n-  \/\/ objects are created.\n-  _filler_array_max_size = _humongous_object_threshold_in_words;\n+  \/\/ Since filler arrays are never referenced, we can make them region sized.\n+  \/\/ This simplifies filling up the region in case we have some potentially\n+  \/\/ unreferenced (by Java code, but still in use by native code) pinned objects\n+  \/\/ in there.\n+  _filler_array_max_size = HeapRegion::GrainWords;\n@@ -1908,6 +1829,0 @@\n-    if (GCLocker::is_active_and_needs_gc()) {\n-      \/\/ If GCLocker is active, wait until clear before retrying.\n-      LOG_COLLECT_CONCURRENTLY(cause, \"gc-locker stall\");\n-      GCLocker::stall_until_clear();\n-    }\n-\n@@ -1939,5 +1854,0 @@\n-\n-    if (GCLocker::is_active_and_needs_gc()) {\n-      \/\/ If GCLocker is active, wait until clear before retrying.\n-      GCLocker::stall_until_clear();\n-    }\n@@ -1953,5 +1863,0 @@\n-  } else if (GCLocker::should_discard(cause, counters_before.total_collections())) {\n-    \/\/ Indicate failure to be consistent with VMOp failure due to\n-    \/\/ another collection slipping in after our gc_count but before\n-    \/\/ our request is processed.\n-    return false;\n@@ -2183,8 +2088,0 @@\n-void G1CollectedHeap::pin_object(JavaThread* thread, oop obj) {\n-  GCLocker::lock_critical(thread);\n-}\n-\n-void G1CollectedHeap::unpin_object(JavaThread* thread, oop obj) {\n-  GCLocker::unlock_critical(thread);\n-}\n-\n@@ -2493,4 +2390,0 @@\n-  if (GCLocker::check_active_before_gc()) {\n-    return false;\n-  }\n-\n@@ -2651,0 +2544,2 @@\n+  assert(!hr->has_pinned_objects(),\n+         \"must not free a region which contains pinned objects\");\n@@ -2768,1 +2663,1 @@\n-   if (hr->is_humongous()) {\n+  if (hr->is_humongous()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":41,"deletions":146,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -563,0 +563,3 @@\n+  void pin_object(JavaThread* thread, oop obj) override;\n+  void unpin_object(JavaThread* thread, oop obj) override;\n+\n@@ -616,1 +619,1 @@\n-    _region_attr.set_in_young(r->hrm_index());\n+    _region_attr.set_in_young(r->hrm_index(), r->has_pinned_objects());\n@@ -1295,3 +1298,0 @@\n-  void pin_object(JavaThread* thread, oop obj) override;\n-  void unpin_object(JavaThread* thread, oop obj) override;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -212,0 +212,2 @@\n+  assert(!region_at(index)->has_pinned_objects(), \"must be\");\n+  assert(region_at(index)->rem_set()->is_complete(), \"must be\");\n@@ -221,0 +223,1 @@\n+  _region_attr.set_is_pinned(r->hrm_index(), r->has_pinned_objects());\n@@ -224,0 +227,2 @@\n+  assert(!r->has_pinned_objects(), \"must be\");\n+  assert(r->rem_set()->is_complete(), \"must be\");\n@@ -260,0 +265,15 @@\n+inline void G1CollectedHeap::pin_object(JavaThread* thread, oop obj) {\n+  assert(obj != nullptr, \"obj must not be null\");\n+  assert(!is_gc_active(), \"must not pin objects during a GC\");\n+  assert(obj->is_typeArray(), \"must be typeArray\");\n+  HeapRegion *r = heap_region_containing(obj);\n+  r->increment_pinned_object_count();\n+}\n+\n+inline void G1CollectedHeap::unpin_object(JavaThread* thread, oop obj) {\n+  assert(obj != nullptr, \"obj must not be null\");\n+  assert(!is_gc_active(), \"must not unpin objects during a GC\");\n+  HeapRegion *r = heap_region_containing(obj);\n+  r->decrement_pinned_object_count();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -273,0 +273,3 @@\n+\/\/ Always evacuate out pinned regions (apart from object types that can actually be\n+\/\/ pinned by JNI) to allow faster future evacuation. We already \"paid\" for this work\n+\/\/ when sizing the young generation.\n@@ -320,0 +323,13 @@\n+\/\/ The current mechanism skips evacuation of pinned old regions like g1 does for\n+\/\/ young regions:\n+\/\/ * evacuating pinned marking collection set candidate regions (available during mixed\n+\/\/   gc) like young regions would not result in any memory gain but only take additional\n+\/\/   time away from processing regions that would actually result in memory being freed.\n+\/\/   To advance mixed gc progress (we committed to evacuate all marking collection set\n+\/\/   candidate regions within the maximum number of mixed gcs in the phase), move them\n+\/\/   to the optional collection set candidates to reclaim them asap as time permits.\n+\/\/ * evacuating out retained collection set candidates would also just take up time with\n+\/\/   no actual space freed in old gen. Better to concentrate on others.\n+\/\/   Retained collection set candidates are aged out, ie. made to regular old regions\n+\/\/   without remembered sets after a few attempts to save computation costs of keeping\n+\/\/   them candidates for very long living pinned regions.\n@@ -328,0 +344,2 @@\n+    G1CollectionCandidateRegionList pinned_marking_regions;\n+    G1CollectionCandidateRegionList pinned_retained_regions;\n@@ -333,1 +351,2 @@\n-                                                                  &_optional_old_regions);\n+                                                                  &_optional_old_regions,\n+                                                                  &pinned_marking_regions);\n@@ -341,1 +360,2 @@\n-                                             &_optional_old_regions);\n+                                             &_optional_old_regions,\n+                                             &pinned_retained_regions);\n@@ -347,0 +367,7 @@\n+    \/\/ Move pinned marking regions we came across to retained candidates so that\n+    \/\/ there is progress in the mixed gc phase.\n+    move_pinned_marking_to_retained(&pinned_marking_regions);\n+    \/\/ Drop pinned retained regions to make progress with retained regions. Regions\n+    \/\/ in that list must have been pinned for at least G1NumCollectionsKeepPinned\n+    \/\/ GCs and hence are considered \"long lived\".\n+    drop_pinned_retained_regions(&pinned_retained_regions);\n@@ -381,0 +408,26 @@\n+void G1CollectionSet::move_pinned_marking_to_retained(G1CollectionCandidateRegionList* regions) {\n+  if (regions->length() == 0) {\n+    return;\n+  }\n+  candidates()->remove(regions);\n+\n+  for (HeapRegion* r : *regions) {\n+    assert(r->has_pinned_objects(), \"must be pinned\");\n+    assert(r->rem_set()->is_complete(), \"must be complete\");\n+    candidates()->add_retained_region_unsorted(r);\n+  }\n+  candidates()->sort_by_efficiency();\n+}\n+\n+void G1CollectionSet::drop_pinned_retained_regions(G1CollectionCandidateRegionList* regions) {\n+  if (regions->length() == 0) {\n+    return;\n+  }\n+  candidates()->remove(regions);\n+\n+  \/\/ We can now drop these region's remembered sets.\n+  for (HeapRegion* r : *regions) {\n+    r->rem_set()->clear(true \/* only_cardset *\/);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":55,"deletions":2,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -180,0 +180,6 @@\n+  \/\/ Moves given old regions from the marking candidates to the retained candidates.\n+  \/\/ This makes sure that marking candidates will not remain there to unnecessarily\n+  \/\/ prolong the mixed phase.\n+  void move_pinned_marking_to_retained(G1CollectionCandidateRegionList* regions);\n+  \/\/ Removes the given list of regions from the retained candidates.\n+  void drop_pinned_retained_regions(G1CollectionCandidateRegionList* regions);\n@@ -189,2 +195,2 @@\n-  \/\/ Select the old regions of the initial collection set and determine how many optional\n-  \/\/ regions we might be able to evacuate in this pause.\n+  \/\/ Select the regions comprising the initial and optional collection set from marking\n+  \/\/ and retained collection set candidates.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-void G1CollectionCandidateList::set(G1CollectionCandidateList::CandidateInfo* candidate_infos, uint num_infos) {\n+void G1CollectionCandidateList::set(G1CollectionSetCandidateInfo* candidate_infos, uint num_infos) {\n@@ -37,1 +37,1 @@\n-  GrowableArrayFromArray<G1CollectionCandidateList::CandidateInfo> a(candidate_infos, (int)num_infos);\n+  GrowableArrayFromArray<G1CollectionSetCandidateInfo> a(candidate_infos, (int)num_infos);\n@@ -42,1 +42,1 @@\n-  CandidateInfo c(r, r->calc_gc_efficiency());\n+  G1CollectionSetCandidateInfo c(r, r->calc_gc_efficiency());\n@@ -61,1 +61,1 @@\n-  GrowableArray<CandidateInfo> new_list(new_length, mtGC);\n+  GrowableArray<G1CollectionSetCandidateInfo> new_list(new_length, mtGC);\n@@ -84,1 +84,1 @@\n-  CandidateInfo* prev = nullptr;\n+  G1CollectionSetCandidateInfo* prev = nullptr;\n@@ -87,1 +87,1 @@\n-    CandidateInfo& ci = _candidates.at(i);\n+    G1CollectionSetCandidateInfo& ci = _candidates.at(i);\n@@ -97,1 +97,1 @@\n-int G1CollectionCandidateList::compare(CandidateInfo* ci1, CandidateInfo* ci2) {\n+int G1CollectionCandidateList::compare(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2) {\n@@ -185,1 +185,1 @@\n-void G1CollectionSetCandidates::set_candidates_from_marking(G1CollectionCandidateList::CandidateInfo* candidate_infos,\n+void G1CollectionSetCandidates::set_candidates_from_marking(G1CollectionSetCandidateInfo* candidate_infos,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -67,0 +69,14 @@\n+struct G1CollectionSetCandidateInfo {\n+  HeapRegion* _r;\n+  double _gc_efficiency;\n+  uint _num_unreclaimed;          \/\/ Number of GCs this region has been found unreclaimable.\n+\n+  G1CollectionSetCandidateInfo() : G1CollectionSetCandidateInfo(nullptr, 0.0) { }\n+  G1CollectionSetCandidateInfo(HeapRegion* r, double gc_efficiency) : _r(r), _gc_efficiency(gc_efficiency), _num_unreclaimed(0) { }\n+\n+  bool update_num_unreclaimed() {\n+    ++_num_unreclaimed;\n+    return _num_unreclaimed < G1NumCollectionsKeepPinned;\n+  }\n+};\n+\n@@ -75,1 +91,1 @@\n-  HeapRegion* operator*();\n+  G1CollectionSetCandidateInfo* operator*();\n@@ -86,11 +102,1 @@\n-public:\n-  struct CandidateInfo {\n-    HeapRegion* _r;\n-    double _gc_efficiency;\n-\n-    CandidateInfo() : CandidateInfo(nullptr, 0.0) { }\n-    CandidateInfo(HeapRegion* r, double gc_efficiency) : _r(r), _gc_efficiency(gc_efficiency) { }\n-  };\n-\n-private:\n-  GrowableArray<CandidateInfo> _candidates;\n+  GrowableArray<G1CollectionSetCandidateInfo> _candidates;\n@@ -102,1 +108,1 @@\n-  void set(CandidateInfo* candidate_infos, uint num_infos);\n+  void set(G1CollectionSetCandidateInfo* candidate_infos, uint num_infos);\n@@ -117,1 +123,1 @@\n-  CandidateInfo& at(uint position) { return _candidates.at(position); }\n+  G1CollectionSetCandidateInfo& at(uint position) { return _candidates.at(position); }\n@@ -126,1 +132,1 @@\n-  static int compare(CandidateInfo* ci1, CandidateInfo* ci2);\n+  static int compare(G1CollectionSetCandidateInfo* ci1, G1CollectionSetCandidateInfo* ci2);\n@@ -141,1 +147,1 @@\n-  uint _position;\n+    uint _position;\n@@ -143,1 +149,1 @@\n-public:\n+  public:\n@@ -201,1 +207,1 @@\n-  void set_candidates_from_marking(G1CollectionCandidateList::CandidateInfo* candidate_infos,\n+  void set_candidates_from_marking(G1CollectionSetCandidateInfo* candidate_infos,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-inline HeapRegion* G1CollectionCandidateListIterator::operator*() {\n-  return _which->_candidates.at(_position)._r;\n+inline G1CollectionSetCandidateInfo* G1CollectionCandidateListIterator::operator*() {\n+  return &_which->_candidates.at(_position);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  using CandidateInfo = G1CollectionCandidateList::CandidateInfo;\n+  using CandidateInfo = G1CollectionSetCandidateInfo;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1134,5 +1134,2 @@\n-      size_t const obj_size_in_words = cast_to_oop(hr->bottom())->size();\n-\n-      \/\/ \"Distributing\" zero words means that we only note end of marking for these\n-      \/\/ regions.\n-      assert(marked_bytes == 0 || obj_size_in_words * HeapWordSize == marked_bytes,\n+      \/\/ Dead humongous objects (marked_bytes == 0) may have already been unloaded.\n+      assert(marked_bytes == 0 || cast_to_oop(hr->bottom())->size() * HeapWordSize == marked_bytes,\n@@ -1140,1 +1137,1 @@\n-             obj_size_in_words * HeapWordSize, marked_bytes);\n+             cast_to_oop(hr->bottom())->size() * HeapWordSize, marked_bytes);\n@@ -1151,4 +1148,0 @@\n-\n-      assert(marked_bytes == 0,\n-             \"%zu bytes left after distributing space across %zu regions\",\n-             marked_bytes, G1CollectedHeap::humongous_obj_size_in_regions(obj_size_in_words));\n@@ -1373,1 +1366,4 @@\n-      if (hr->used() > 0 && hr->live_bytes() == 0 && !hr->is_young()) {\n+      bool can_reclaim = hr->used() > 0 && hr->live_bytes() == 0 &&\n+                         !hr->is_young() && !hr->has_pinned_objects();\n+\n+      if (can_reclaim) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,3 +36,5 @@\n-  _regions_failed_evacuation(mtGC),\n-  _evac_failure_regions(nullptr),\n-  _evac_failure_regions_cur_length(0) { }\n+  _regions_evac_failed(mtGC),\n+  _regions_pinned(mtGC),\n+  _regions_alloc_failed(mtGC),\n+  _evac_failed_regions(nullptr),\n+  _num_regions_evac_failed(0) { }\n@@ -41,1 +43,1 @@\n-  assert(_evac_failure_regions == nullptr, \"not cleaned up\");\n+  assert(_evac_failed_regions == nullptr, \"not cleaned up\");\n@@ -45,3 +47,5 @@\n-  Atomic::store(&_evac_failure_regions_cur_length, 0u);\n-  _regions_failed_evacuation.resize(max_regions);\n-  _evac_failure_regions = NEW_C_HEAP_ARRAY(uint, max_regions, mtGC);\n+  Atomic::store(&_num_regions_evac_failed, 0u);\n+  _regions_evac_failed.resize(max_regions);\n+  _regions_pinned.resize(max_regions);\n+  _regions_alloc_failed.resize(max_regions);\n+  _evac_failed_regions = NEW_C_HEAP_ARRAY(uint, max_regions, mtGC);\n@@ -51,1 +55,3 @@\n-  _regions_failed_evacuation.resize(0);\n+  _regions_evac_failed.resize(0);\n+  _regions_pinned.resize(0);\n+  _regions_alloc_failed.resize(0);\n@@ -53,2 +59,2 @@\n-  FREE_C_HEAP_ARRAY(uint, _evac_failure_regions);\n-  _evac_failure_regions = nullptr;\n+  FREE_C_HEAP_ARRAY(uint, _evac_failed_regions);\n+  _evac_failed_regions = nullptr;\n@@ -58,1 +64,1 @@\n-  return _regions_failed_evacuation.par_at(region_idx, memory_order_relaxed);\n+  return _regions_evac_failed.par_at(region_idx, memory_order_relaxed);\n@@ -66,2 +72,2 @@\n-                                                     _evac_failure_regions,\n-                                                     Atomic::load(&_evac_failure_regions_cur_length),\n+                                                     _evac_failed_regions,\n+                                                     Atomic::load(&_num_regions_evac_failed),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"runtime\/atomic.hpp\"\n@@ -32,1 +31,0 @@\n-class G1HeapRegionChunkClosure;\n@@ -36,3 +34,11 @@\n-\/\/ This class records for every region on the heap whether evacuation failed for it,\n-\/\/ and records for every evacuation failure region to speed up iteration of these\n-\/\/ regions in post evacuation phase.\n+\/\/ This class records for every region on the heap whether it had experienced an\n+\/\/ evacuation failure.\n+\/\/ An evacuation failure may occur due to pinning or due to allocation failure\n+\/\/ (not enough to-space). For every such occurrence the class records region\n+\/\/ information to speed up iteration of these regions in various gc phases.\n+\/\/\n+\/\/ Pinned regions may experience an allocation failure at the same time as G1\n+\/\/ tries to evacuate anything but objects that are possible to be pinned. So\n+\/\/\n+\/\/   _num_regions_pinned + _num_regions_alloc_failed >= _num_regions_evac_failed\n+\/\/\n@@ -40,4 +46,9 @@\n-  \/\/ Records for every region on the heap whether evacuation failed for it.\n-  CHeapBitMap _regions_failed_evacuation;\n-  \/\/ Regions (index) of evacuation failed in the current collection.\n-  uint* _evac_failure_regions;\n+  \/\/ Records for every region on the heap whether the region has experienced an\n+  \/\/ evacuation failure.\n+  CHeapBitMap _regions_evac_failed;\n+  \/\/ Records for every region on the heap whether the evacuation failure cause\n+  \/\/ has been allocation failure or region pinning.\n+  CHeapBitMap _regions_pinned;\n+  CHeapBitMap _regions_alloc_failed;\n+  \/\/ Evacuation failed regions (indexes) in the current collection.\n+  uint* _evac_failed_regions;\n@@ -45,1 +56,1 @@\n-  volatile uint _evac_failure_regions_cur_length;\n+  volatile uint _num_regions_evac_failed;\n@@ -52,2 +63,2 @@\n-    assert(idx < _evac_failure_regions_cur_length, \"precondition\");\n-    return _evac_failure_regions[idx];\n+    assert(idx < _num_regions_evac_failed, \"precondition\");\n+    return _evac_failed_regions[idx];\n@@ -69,3 +80,1 @@\n-  uint num_regions_failed_evacuation() const {\n-    return Atomic::load(&_evac_failure_regions_cur_length);\n-  }\n+  inline uint num_regions_evac_failed() const;\n@@ -73,3 +82,3 @@\n-  bool evacuation_failed() const {\n-    return num_regions_failed_evacuation() > 0;\n-  }\n+  inline bool has_regions_evac_failed() const;\n+  inline bool has_regions_evac_pinned() const;\n+  inline bool has_regions_alloc_failed() const;\n@@ -80,1 +89,1 @@\n-  inline bool record(uint region_idx);\n+  inline bool record(uint worker_id, uint region_idx, bool cause_pinned);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":28,"deletions":19,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/g1\/g1GCPhaseTimes.hpp\"\n@@ -32,3 +33,25 @@\n-bool G1EvacFailureRegions::record(uint region_idx) {\n-  bool success = _regions_failed_evacuation.par_set_bit(region_idx,\n-                                                        memory_order_relaxed);\n+uint G1EvacFailureRegions::num_regions_evac_failed() const {\n+  return Atomic::load(&_num_regions_evac_failed);\n+}\n+\n+bool G1EvacFailureRegions::has_regions_evac_failed() const {\n+  return num_regions_evac_failed() > 0;\n+}\n+\n+bool G1EvacFailureRegions::has_regions_evac_pinned() const {\n+  G1GCPhaseTimes* p = G1CollectedHeap::heap()->phase_times();\n+  size_t count = p->sum_thread_work_items(G1GCPhaseTimes::RestoreEvacuationFailedRegions,\n+                                          G1GCPhaseTimes::RestoreEvacFailureRegionsPinnedNum);\n+  return count != 0;\n+}\n+\n+bool G1EvacFailureRegions::has_regions_alloc_failed() const {\n+  G1GCPhaseTimes* p = G1CollectedHeap::heap()->phase_times();\n+  size_t count = p->sum_thread_work_items(G1GCPhaseTimes::RestoreEvacuationFailedRegions,\n+                                          G1GCPhaseTimes::RestoreEvacFailureRegionsAllocFailedNum);\n+  return count != 0;\n+}\n+\n+bool G1EvacFailureRegions::record(uint worker_id, uint region_idx, bool cause_pinned) {\n+  bool success = _regions_evac_failed.par_set_bit(region_idx,\n+                                                  memory_order_relaxed);\n@@ -36,2 +59,2 @@\n-    size_t offset = Atomic::fetch_then_add(&_evac_failure_regions_cur_length, 1u);\n-    _evac_failure_regions[offset] = region_idx;\n+    size_t offset = Atomic::fetch_then_add(&_num_regions_evac_failed, 1u);\n+    _evac_failed_regions[offset] = region_idx;\n@@ -43,0 +66,18 @@\n+\n+  if (cause_pinned) {\n+    if (_regions_pinned.par_set_bit(region_idx, memory_order_relaxed)) {\n+      G1GCPhaseTimes* p = G1CollectedHeap::heap()->phase_times();\n+      p->record_or_add_thread_work_item(G1GCPhaseTimes::RestoreEvacuationFailedRegions,\n+                                        worker_id,\n+                                        1,\n+                                        G1GCPhaseTimes::RestoreEvacFailureRegionsPinnedNum);\n+    }\n+  } else {\n+    if (_regions_alloc_failed.par_set_bit(region_idx, memory_order_relaxed)) {\n+      G1GCPhaseTimes* p = G1CollectedHeap::heap()->phase_times();\n+      p->record_or_add_thread_work_item(G1GCPhaseTimes::RestoreEvacuationFailedRegions,\n+                                        worker_id,\n+                                        1,\n+                                        G1GCPhaseTimes::RestoreEvacFailureRegionsAllocFailedNum);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.inline.hpp","additions":46,"deletions":5,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+    hr->prepare_for_full_gc();\n@@ -259,3 +260,3 @@\n-  } else if (hr->is_humongous()) {\n-    \/\/ Humongous objects will never be moved in the \"main\" compaction phase, but\n-    \/\/ afterwards in a special phase if needed.\n+  } else if (hr->is_humongous() || hr->has_pinned_objects()) {\n+    \/\/ Humongous objects or pinned regions will never be moved in the \"main\"\n+    \/\/ compaction phase, but non-pinned regions might afterwards in a special phase.\n@@ -456,2 +457,7 @@\n-      uint num_regions = humongous_cp->forward_humongous(hr);\n-      region_index += num_regions; \/\/ Skip over the continues humongous regions.\n+      size_t obj_size = cast_to_oop(hr->bottom())->size();\n+      uint num_regions = (uint)G1CollectedHeap::humongous_obj_size_in_regions(obj_size);\n+      \/\/ Even during last-ditch compaction we should not move pinned humongous objects.\n+      if (!hr->has_pinned_objects()) {\n+        humongous_cp->forward_humongous(hr);\n+      }\n+      region_index += num_regions; \/\/ Advance over all humongous regions.\n@@ -460,0 +466,1 @@\n+      assert(!hr->has_pinned_objects(), \"pinned regions should not be compaction targets\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+  assert(!hr->has_pinned_objects(), \"Should be no region with pinned objects in compaction queue\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-uint G1FullGCCompactionPoint::forward_humongous(HeapRegion* hr) {\n+void G1FullGCCompactionPoint::forward_humongous(HeapRegion* hr) {\n@@ -156,1 +156,1 @@\n-    return num_regions;\n+    return;\n@@ -164,1 +164,1 @@\n-    return num_regions;\n+    return;\n@@ -180,1 +180,1 @@\n-  return num_regions;\n+  return;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  uint forward_humongous(HeapRegion* hr);\n+  void forward_humongous(HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  if (hr->is_humongous()) {\n+  if (hr->is_humongous() || hr->has_pinned_objects()) {\n@@ -76,0 +76,5 @@\n+static bool has_pinned_objects(HeapRegion* hr) {\n+  return hr->has_pinned_objects() ||\n+      (hr->is_humongous() && hr->humongous_start_region()->has_pinned_objects());\n+}\n+\n@@ -80,10 +85,15 @@\n-  } else {\n-    assert(hr->containing_set() == nullptr, \"already cleared by PrepareRegionsClosure\");\n-    if (hr->is_humongous()) {\n-      oop obj = cast_to_oop(hr->humongous_start_region()->bottom());\n-      bool is_empty = !_collector->mark_bitmap()->is_marked(obj);\n-      if (is_empty) {\n-        free_empty_humongous_region(hr);\n-      } else {\n-        _collector->set_has_humongous();\n-      }\n+    return false;\n+  }\n+\n+  assert(hr->containing_set() == nullptr, \"already cleared by PrepareRegionsClosure\");\n+  if (has_pinned_objects(hr)) {\n+    \/\/ First check regions with pinned objects: they need to be skipped regardless\n+    \/\/ of region type and never be considered for reclamation.\n+    assert(_collector->is_skip_compacting(hr->hrm_index()), \"pinned region %u must be skip_compacting\", hr->hrm_index());\n+    log_trace(gc, phases)(\"Phase 2: skip compaction region index: %u (%s), has pinned objects\",\n+                          hr->hrm_index(), hr->get_short_type_str());\n+  } else if (hr->is_humongous()) {\n+    oop obj = cast_to_oop(hr->humongous_start_region()->bottom());\n+    bool is_empty = !_collector->mark_bitmap()->is_marked(obj);\n+    if (is_empty) {\n+      free_empty_humongous_region(hr);\n@@ -91,2 +101,5 @@\n-      assert(MarkSweepDeadRatio > 0,\n-             \"only skip compaction for other regions when MarkSweepDeadRatio > 0\");\n+      _collector->set_has_humongous();\n+    }\n+  } else {\n+    assert(MarkSweepDeadRatio > 0,\n+           \"only skip compaction for other regions when MarkSweepDeadRatio > 0\");\n@@ -94,3 +107,3 @@\n-      \/\/ Too many live objects in the region; skip compacting it.\n-      _collector->update_from_compacting_to_skip_compacting(hr->hrm_index());\n-      log_trace(gc, phases)(\"Phase 2: skip compaction region index: %u, live words: \" SIZE_FORMAT,\n+    \/\/ Too many live objects in the region; skip compacting it.\n+    _collector->update_from_compacting_to_skip_compacting(hr->hrm_index());\n+    log_trace(gc, phases)(\"Phase 2: skip compaction region index: %u, live words: \" SIZE_FORMAT,\n@@ -98,1 +111,0 @@\n-    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.inline.hpp","additions":29,"deletions":17,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -92,1 +92,2 @@\n-    assert(_collector->mark_bitmap()->is_marked(obj), \"must be live\");\n+    assert(hr->humongous_start_region()->has_pinned_objects() ||\n+           _collector->mark_bitmap()->is_marked(obj), \"must be live\");\n@@ -94,2 +95,2 @@\n-    assert(_collector->live_words(region_index) > _collector->scope()->region_compaction_threshold(),\n-           \"should be quite full\");\n+    assert(hr->has_pinned_objects() || _collector->live_words(region_index) > _collector->scope()->region_compaction_threshold(),\n+           \"should be quite full or pinned %u\", region_index);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-  _gc_par_phases[RestoreRetainedRegions] = new WorkerDataArray<double>(\"RestoreRetainedRegions\", \"Restore Retained Regions (ms):\", max_gc_threads);\n+  _gc_par_phases[RestoreEvacuationFailedRegions] = new WorkerDataArray<double>(\"RestoreEvacuationFailedRegions\", \"Restore Evacuation Failed Regions (ms):\", max_gc_threads);\n@@ -135,2 +135,3 @@\n-  _gc_par_phases[RestoreRetainedRegions]->create_thread_work_items(\"Evacuation Failed Regions:\", RestoreRetainedRegionsFailedNum);\n-  _gc_par_phases[RestoreRetainedRegions]->create_thread_work_items(\"New Retained Regions:\", RestoreRetainedRegionsRetainedNum);\n+  _gc_par_phases[RestoreEvacuationFailedRegions]->create_thread_work_items(\"Evacuation Failed Regions:\", RestoreEvacFailureRegionsEvacFailedNum);\n+  _gc_par_phases[RestoreEvacuationFailedRegions]->create_thread_work_items(\"Pinned Regions:\", RestoreEvacFailureRegionsPinnedNum);\n+  _gc_par_phases[RestoreEvacuationFailedRegions]->create_thread_work_items(\"Allocation Failed Regions:\", RestoreEvacFailureRegionsAllocFailedNum);\n@@ -505,1 +506,1 @@\n-    debug_phase(_gc_par_phases[RestoreRetainedRegions], 1);\n+    debug_phase(_gc_par_phases[RestoreEvacuationFailedRegions], 1);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-    RestoreRetainedRegions,\n+    RestoreEvacuationFailedRegions,\n@@ -149,3 +149,4 @@\n-  enum RestoreRetainedRegionsWorkItems {\n-    RestoreRetainedRegionsFailedNum,\n-    RestoreRetainedRegionsRetainedNum\n+  enum RestoreEvacFailureRegionsWorkItems {\n+    RestoreEvacFailureRegionsEvacFailedNum,       \/\/ How many regions experienced an evacuation failure (pinned or allocation failure)\n+    RestoreEvacFailureRegionsPinnedNum,           \/\/ How many regions were found as pinned.\n+    RestoreEvacFailureRegionsAllocFailedNum       \/\/ How many regions were found experiencing an allocation failure.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+  \/\/ _is_pinned_t is essentially bool, but we want precise control\n+  \/\/ on the size, and sizeof(bool) is implementation specific.\n+  typedef uint8_t is_pinned_t;\n@@ -43,0 +46,1 @@\n+  is_pinned_t _is_pinned;\n@@ -62,3 +66,2 @@\n-  G1HeapRegionAttr(region_type_t type = NotInCSet, bool remset_is_tracked = false) :\n-    _remset_is_tracked(remset_is_tracked), _type(type) {\n-\n+  G1HeapRegionAttr(region_type_t type = NotInCSet, bool remset_is_tracked = false, bool is_pinned = false) :\n+    _remset_is_tracked(remset_is_tracked ? 1 : 0), _type(type), _is_pinned(is_pinned ? 1 : 0) {\n@@ -85,0 +88,2 @@\n+  bool is_pinned() const               { return _is_pinned != 0; }\n+\n@@ -90,0 +95,1 @@\n+\n@@ -91,0 +97,1 @@\n+  void set_is_pinned(bool value)       { _is_pinned = value ? 1 : 0; }\n@@ -139,1 +146,3 @@\n-    set_by_index(index, G1HeapRegionAttr(G1HeapRegionAttr::HumongousCandidate, remset_is_tracked));\n+    \/\/ Humongous candidates can not be pinned.\n+    const bool region_is_pinned = false;\n+    set_by_index(index, G1HeapRegionAttr(G1HeapRegionAttr::HumongousCandidate, remset_is_tracked, region_is_pinned));\n@@ -154,1 +163,5 @@\n-  void set_in_young(uintptr_t index) {\n+  void set_is_pinned(uintptr_t index, bool is_pinned) {\n+    get_ref_by_index(index)->set_is_pinned(is_pinned);\n+  }\n+\n+  void set_in_young(uintptr_t index, bool is_pinned) {\n@@ -157,1 +170,1 @@\n-    set_by_index(index, G1HeapRegionAttr(G1HeapRegionAttr::Young, true));\n+    set_by_index(index, G1HeapRegionAttr(G1HeapRegionAttr::Young, true, is_pinned));\n@@ -163,1 +176,3 @@\n-    set_by_index(index, G1HeapRegionAttr(G1HeapRegionAttr::Old, remset_is_tracked));\n+    \/\/ We do not select regions with pinned objects into the collection set.\n+    const bool region_is_pinned = false;\n+    set_by_index(index, G1HeapRegionAttr(G1HeapRegionAttr::Old, remset_is_tracked, region_is_pinned));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionAttr.hpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -250,5 +250,4 @@\n-  \/\/ Max length includes any potential extensions to the young gen\n-  \/\/ we'll do when the GC locker is active.\n-  uint young_list_max_length = _g1h->policy()->young_list_max_length();\n-  assert(young_list_max_length >= survivor_list_length, \"invariant\");\n-  uint eden_list_max_length = young_list_max_length - survivor_list_length;\n+\n+  uint young_list_target_length = _g1h->policy()->young_list_target_length();\n+  assert(young_list_target_length >= survivor_list_length, \"invariant\");\n+  uint eden_list_max_length = young_list_target_length - survivor_list_length;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonitoringSupport.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -431,1 +431,1 @@\n-bool G1ParScanThreadState::inject_evacuation_failure(uint region_idx) {\n+bool G1ParScanThreadState::inject_allocation_failure(uint region_idx) {\n@@ -464,0 +464,5 @@\n+  \/\/ JNI only allows pinning of typeArrays, so we only need to keep those in place.\n+  if (region_attr.is_pinned() && klass->is_typeArray_klass()) {\n+    return handle_evacuation_failure_par(old, old_mark, word_sz, true \/* cause_pinned *\/);\n+  }\n+\n@@ -478,1 +483,1 @@\n-      return handle_evacuation_failure_par(old, old_mark, word_sz);\n+      return handle_evacuation_failure_par(old, old_mark, word_sz, false \/* cause_pinned *\/);\n@@ -486,1 +491,1 @@\n-  if (inject_evacuation_failure(from_region->hrm_index())) {\n+  if (inject_allocation_failure(from_region->hrm_index())) {\n@@ -490,1 +495,1 @@\n-    return handle_evacuation_failure_par(old, old_mark, word_sz);\n+    return handle_evacuation_failure_par(old, old_mark, word_sz, false \/* cause_pinned *\/);\n@@ -627,1 +632,1 @@\n-oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markWord m, size_t word_sz) {\n+oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markWord m, size_t word_sz, bool cause_pinned) {\n@@ -635,1 +640,1 @@\n-    if (_evac_failure_regions->record(r->hrm_index())) {\n+    if (_evac_failure_regions->record(_worker_id, r->hrm_index(), cause_pinned)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  bool inject_evacuation_failure(uint region_idx) EVAC_FAILURE_INJECTOR_RETURN_( return false; );\n+  bool inject_allocation_failure(uint region_idx) EVAC_FAILURE_INJECTOR_RETURN_( return false; );\n@@ -234,1 +234,1 @@\n-  oop handle_evacuation_failure_par(oop obj, markWord m, size_t word_sz);\n+  oop handle_evacuation_failure_par(oop obj, markWord m, size_t word_sz, bool cause_pinned);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-  _young_list_max_length(0),\n@@ -201,1 +200,0 @@\n-  uint new_young_list_max_length = calculate_young_max_length(new_young_list_target_length);\n@@ -203,1 +201,1 @@\n-  log_trace(gc, ergo, heap)(\"Young list length update: pending cards %zu card_rs_length %zu old target %u desired: %u target: %u max: %u\",\n+  log_trace(gc, ergo, heap)(\"Young list length update: pending cards %zu card_rs_length %zu old target %u desired: %u target: %u\",\n@@ -208,2 +206,1 @@\n-                            new_young_list_target_length,\n-                            new_young_list_max_length);\n+                            new_young_list_target_length);\n@@ -220,1 +217,0 @@\n-  Atomic::store(&_young_list_max_length, new_young_list_max_length);\n@@ -324,2 +320,1 @@\n-    \/\/ young list length concurrently, or caused by gclocker). Do not allow more,\n-    \/\/ potentially resulting in GC.\n+    \/\/ young list length concurrently). Do not allow more, potentially resulting in GC.\n@@ -499,1 +494,3 @@\n-  for (HeapRegion* r : candidates()->marking_regions()) {\n+  for (G1CollectionSetCandidateInfo* ci : candidates()->marking_regions()) {\n+    \/\/ We optimistically assume that any of these marking candidate regions will\n+    \/\/ not be pinned, so just consider them as normal.\n@@ -503,1 +500,1 @@\n-    predicted_region_evac_time_ms += predict_region_total_time_ms(r, false \/* for_young_only_phase *\/);\n+    predicted_region_evac_time_ms += predict_region_total_time_ms(ci->_r, false \/* for_young_only_phase *\/);\n@@ -526,0 +523,2 @@\n+  uint num_pinned_regions = 0;\n+\n@@ -532,1 +531,7 @@\n-  for (HeapRegion* r : list) {\n+  for (G1CollectionSetCandidateInfo* ci : list) {\n+    HeapRegion* r = ci->_r;\n+    \/\/ We optimistically assume that any of these marking candidate regions will\n+    \/\/ be reclaimable the next gc, so just consider them as normal.\n+    if (r->has_pinned_objects()) {\n+      num_pinned_regions++;\n+    }\n@@ -542,2 +547,2 @@\n-  log_trace(gc, ergo, heap)(\"Selected %u of %u retained candidates taking %1.3fms additional time\",\n-                            num_regions, list.length(), result);\n+  log_trace(gc, ergo, heap)(\"Selected %u of %u retained candidates (pinned %u) taking %1.3fms additional time\",\n+                            num_regions, list.length(), num_pinned_regions, result);\n@@ -658,1 +663,1 @@\n-  size_t live_bytes= _g1h->region_at(index)->live_bytes();\n+  size_t live_bytes = _g1h->region_at(index)->live_bytes();\n@@ -660,0 +665,2 @@\n+#ifdef ASSERT\n+  HeapRegion* r = _g1h->region_at(index);\n@@ -661,3 +668,3 @@\n-         \"live bytes not set for %u used %zu garbage %zu cm-live %zu\",\n-         index, _g1h->region_at(index)->used(), _g1h->region_at(index)->garbage_bytes(), live_bytes);\n-\n+         \"live bytes not set for %u used %zu garbage %zu cm-live %zu pinned %d\",\n+         index, r->used(), r->garbage_bytes(), live_bytes, r->has_pinned_objects());\n+#endif\n@@ -787,1 +794,1 @@\n-void G1Policy::record_young_collection_end(bool concurrent_operation_is_full_mark, bool evacuation_failure) {\n+void G1Policy::record_young_collection_end(bool concurrent_operation_is_full_mark, bool allocation_failure) {\n@@ -813,1 +820,1 @@\n-  bool update_stats = !evacuation_failure;\n+  bool update_stats = !allocation_failure;\n@@ -829,1 +836,1 @@\n-  record_pause(this_pause, start_time_sec, end_time_sec, evacuation_failure);\n+  record_pause(this_pause, start_time_sec, end_time_sec, allocation_failure);\n@@ -1156,5 +1163,0 @@\n-bool G1Policy::can_expand_young_list() const {\n-  uint young_list_length = _g1h->young_regions_count();\n-  return young_list_length < young_list_max_length();\n-}\n-\n@@ -1184,14 +1186,0 @@\n-uint G1Policy::calculate_young_max_length(uint target_young_length) const {\n-  uint expansion_region_num = 0;\n-  if (GCLockerEdenExpansionPercent > 0) {\n-    double perc = GCLockerEdenExpansionPercent \/ 100.0;\n-    double expansion_region_num_d = perc * young_list_target_length();\n-    \/\/ We use ceiling so that if expansion_region_num_d is > 0.0 (but\n-    \/\/ less than 1.0) we'll get 1.\n-    expansion_region_num = (uint) ceil(expansion_region_num_d);\n-  }\n-  uint max_length = target_young_length + expansion_region_num;\n-  assert(target_young_length <= max_length, \"overflow\");\n-  return max_length;\n-}\n-\n@@ -1380,1 +1368,1 @@\n-                            bool evacuation_failure) {\n+                            bool allocation_failure) {\n@@ -1386,1 +1374,1 @@\n-  if (!evacuation_failure) {\n+  if (!allocation_failure) {\n@@ -1480,1 +1468,2 @@\n-                                                G1CollectionCandidateRegionList* optional_old_regions) {\n+                                                G1CollectionCandidateRegionList* optional_old_regions,\n+                                                G1CollectionCandidateRegionList* pinned_old_regions) {\n@@ -1487,0 +1476,1 @@\n+  uint num_pinned_regions = 0;\n@@ -1499,1 +1489,1 @@\n-                            \"Min %u regions, max %u regions, \"\n+                            \"Min %u regions, max %u regions, available %u regions\"\n@@ -1501,1 +1491,1 @@\n-                            min_old_cset_length, max_old_cset_length, time_remaining_ms, optional_threshold_ms);\n+                            min_old_cset_length, max_old_cset_length, marking_list->length(), time_remaining_ms, optional_threshold_ms);\n@@ -1510,1 +1500,12 @@\n-    HeapRegion* hr = *iter;\n+    HeapRegion* hr = (*iter)->_r;\n+    \/\/ Skip evacuating pinned marking regions because we are not getting any free\n+    \/\/ space from them (and we expect to get free space from marking candidates).\n+    \/\/ Also prepare to move them to retained regions to be evacuated optionally later\n+    \/\/ to not impact the mixed phase too much.\n+    if (hr->has_pinned_objects()) {\n+      num_pinned_regions++;\n+      (*iter)->update_num_unreclaimed();\n+      log_trace(gc, ergo, cset)(\"Marking candidate %u can not be reclaimed currently. Skipping.\", hr->hrm_index());\n+      pinned_old_regions->append(hr);\n+      continue;\n+    }\n@@ -1554,1 +1555,1 @@\n-  log_debug(gc, ergo, cset)(\"Finish adding marking candidates to collection set. Initial: %u, optional: %u, \"\n+  log_debug(gc, ergo, cset)(\"Finish adding marking candidates to collection set. Initial: %u, optional: %u, pinned: %u, \"\n@@ -1556,1 +1557,1 @@\n-                            num_initial_regions_selected, num_optional_regions_selected,\n+                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n@@ -1567,1 +1568,2 @@\n-                                               G1CollectionCandidateRegionList* optional_old_regions) {\n+                                               G1CollectionCandidateRegionList* optional_old_regions,\n+                                               G1CollectionCandidateRegionList* pinned_old_regions) {\n@@ -1574,0 +1576,1 @@\n+  uint num_pinned_regions = 0;\n@@ -1587,1 +1590,1 @@\n-                            \"Min %u regions, \"\n+                            \"Min %u regions, available %u, \"\n@@ -1589,1 +1592,1 @@\n-                            min_regions, time_remaining_ms, optional_time_remaining_ms);\n+                            min_regions, retained_list->length(), time_remaining_ms, optional_time_remaining_ms);\n@@ -1591,1 +1594,2 @@\n-  for (HeapRegion* r : *retained_list) {\n+  for (G1CollectionSetCandidateInfo* ci : *retained_list) {\n+    HeapRegion* r = ci->_r;\n@@ -1594,0 +1598,11 @@\n+    \/\/ If we can't reclaim that region ignore it for now.\n+    if (r->has_pinned_objects()) {\n+      num_pinned_regions++;\n+      if (ci->update_num_unreclaimed()) {\n+        log_trace(gc, ergo, cset)(\"Retained candidate %u can not be reclaimed currently. Skipping.\", r->hrm_index());\n+      } else {\n+        log_trace(gc, ergo, cset)(\"Retained candidate %u can not be reclaimed currently. Dropping.\", r->hrm_index());\n+        pinned_old_regions->append(r);\n+      }\n+      continue;\n+    }\n@@ -1623,1 +1638,1 @@\n-  log_debug(gc, ergo, cset)(\"Finish adding retained candidates to collection set. Initial: %u, optional: %u, \"\n+  log_debug(gc, ergo, cset)(\"Finish adding retained candidates to collection set. Initial: %u, optional: %u, pinned: %u, \"\n@@ -1626,1 +1641,1 @@\n-                            num_initial_regions_selected, num_optional_regions_selected,\n+                            num_initial_regions_selected, num_optional_regions_selected, num_pinned_regions,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":68,"deletions":53,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -246,3 +246,0 @@\n-  \/\/ The GCLocker might cause us to need more regions than the target. Calculate\n-  \/\/ the maximum number of regions to use in that case.\n-  uint calculate_young_max_length(uint target_young_length) const;\n@@ -278,1 +275,1 @@\n-                    bool evacuation_failure = false);\n+                    bool allocation_failure = false);\n@@ -317,1 +314,1 @@\n-  void record_young_collection_end(bool concurrent_operation_is_full_mark, bool evacuation_failure);\n+  void record_young_collection_end(bool concurrent_operation_is_full_mark, bool allocation_failure);\n@@ -338,1 +335,1 @@\n-  \/\/ Calculate and fill in the initial and optional old gen candidate regions from\n+  \/\/ Calculate and fill in the initial, optional and pinned old gen candidate regions from\n@@ -344,1 +341,2 @@\n-                                        G1CollectionCandidateRegionList* optional_old_regions);\n+                                        G1CollectionCandidateRegionList* optional_old_regions,\n+                                        G1CollectionCandidateRegionList* pinned_old_regions);\n@@ -349,1 +347,2 @@\n-                                       G1CollectionCandidateRegionList* optional_old_regions);\n+                                       G1CollectionCandidateRegionList* optional_old_regions,\n+                                       G1CollectionCandidateRegionList* pinned_old_regions);\n@@ -386,1 +385,0 @@\n-  uint young_list_max_length() const { return Atomic::load(&_young_list_max_length); }\n@@ -390,2 +388,0 @@\n-  bool can_expand_young_list() const;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -71,5 +71,3 @@\n-  \/\/ got scheduled and prevented the scheduling of the concurrent start GC. The\n-  \/\/ second is that the GC locker may be active and the heap can't be expanded.\n-  \/\/ In both cases we want to retry the GC so that the concurrent start pause is\n-  \/\/ actually scheduled. In the second case, however, we should stall until\n-  \/\/ until the GC locker is no longer active and then retry the concurrent start GC.\n+  \/\/ got scheduled and prevented the scheduling of the concurrent start GC.\n+  \/\/ In this case we want to retry the GC so that the concurrent start pause is\n+  \/\/ actually scheduled.\n@@ -106,8 +104,0 @@\n-  } else if (!g1h->do_collection_pause_at_safepoint()) {\n-    \/\/ Failure to perform the collection at all occurs because GCLocker is\n-    \/\/ active, and we have the bad luck to be the collection request that\n-    \/\/ makes a later _gc_locker collection needed.  (Else we would have hit\n-    \/\/ the GCLocker check in the prologue.)\n-    _transient_failure = true;\n-  } else if (g1h->should_upgrade_to_full_gc()) {\n-    _gc_succeeded = g1h->upgrade_to_full_collection();\n@@ -115,1 +105,2 @@\n-    _gc_succeeded = true;\n+    _gc_succeeded = g1h->do_collection_pause_at_safepoint();\n+    assert(_gc_succeeded, \"No reason to fail\");\n@@ -128,16 +119,0 @@\n-  if (_word_size > 0) {\n-    \/\/ An allocation has been requested. So, try to do that first.\n-    \/\/ During the execution of this VM operation, there may have been a concurrent active\n-    \/\/ GCLocker, potentially leading to expansion of the Eden space by other mutators.\n-    \/\/ If the Eden space were expanded, this allocation request might succeed without\n-    \/\/ the need for triggering a garbage collection.\n-    _result = g1h->attempt_allocation_at_safepoint(_word_size,\n-                                                   false \/* expect_null_cur_alloc_region *\/);\n-    if (_result != nullptr) {\n-      \/\/ If we can successfully allocate before we actually do the\n-      \/\/ pause then we will consider this pause successful.\n-      _gc_succeeded = true;\n-      return;\n-    }\n-  }\n-\n@@ -147,0 +122,1 @@\n+  assert(_gc_succeeded, \"no reason to fail\");\n@@ -148,11 +124,9 @@\n-  if (_gc_succeeded) {\n-    if (_word_size > 0) {\n-      \/\/ An allocation had been requested. Do it, eventually trying a stronger\n-      \/\/ kind of GC.\n-      _result = g1h->satisfy_failed_allocation(_word_size, &_gc_succeeded);\n-    } else if (g1h->should_upgrade_to_full_gc()) {\n-      \/\/ There has been a request to perform a GC to free some space. We have no\n-      \/\/ information on how much memory has been asked for. In case there are\n-      \/\/ absolutely no regions left to allocate into, do a full compaction.\n-      _gc_succeeded = g1h->upgrade_to_full_collection();\n-    }\n+  if (_word_size > 0) {\n+    \/\/ An allocation had been requested. Do it, eventually trying a stronger\n+    \/\/ kind of GC.\n+    _result = g1h->satisfy_failed_allocation(_word_size, &_gc_succeeded);\n+  } else if (g1h->should_upgrade_to_full_gc()) {\n+    \/\/ There has been a request to perform a GC to free some space. We have no\n+    \/\/ information on how much memory has been asked for. In case there are\n+    \/\/ absolutely no regions left to allocate into, do a full compaction.\n+    _gc_succeeded = g1h->upgrade_to_full_collection();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":15,"deletions":41,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/g1\/g1EvacFailureRegions.inline.hpp\"\n@@ -80,0 +81,11 @@\n+    char evacuation_failed_string[48];\n+    evacuation_failed_string[0] = '\\0';\n+\n+    if (_collector->evacuation_failed()) {\n+      snprintf(evacuation_failed_string,\n+               ARRAY_SIZE(evacuation_failed_string),\n+               \" (Evacuation Failure: %s%s%s)\",\n+               _collector->evacuation_alloc_failed() ? \"Allocation\" : \"\",\n+               _collector->evacuation_alloc_failed() && _collector->evacuation_pinned() ? \" \/ \" : \"\",\n+               _collector->evacuation_pinned() ? \"Pinned\" : \"\");\n+    }\n@@ -85,1 +97,1 @@\n-             _collector->evacuation_failed() ? \" (Evacuation Failure)\" : \"\");\n+             evacuation_failed_string);\n@@ -317,0 +329,4 @@\n+      \/\/ We also cannot collect the humongous object if it is pinned.\n+      if (region->has_pinned_objects()) {\n+        return false;\n+      }\n@@ -389,1 +405,2 @@\n-      log_debug(gc, humongous)(\"Humongous region %u (object size %zu @ \" PTR_FORMAT \") remset %zu code roots %zu marked %d reclaim candidate %d type array %d\",\n+      log_debug(gc, humongous)(\"Humongous region %u (object size %zu @ \" PTR_FORMAT \") remset %zu code roots %zu \"\n+                               \"marked %d pinned count %u reclaim candidate %d type array %d\",\n@@ -396,0 +413,1 @@\n+                               hr->pinned_count(),\n@@ -762,1 +780,1 @@\n-  while (!evacuation_failed() && collection_set()->optional_region_length() > 0) {\n+  while (!evacuation_alloc_failed() && collection_set()->optional_region_length() > 0) {\n@@ -1013,1 +1031,9 @@\n-  return _evac_failure_regions.evacuation_failed();\n+  return _evac_failure_regions.has_regions_evac_failed();\n+}\n+\n+bool G1YoungCollector::evacuation_pinned() const {\n+  return _evac_failure_regions.has_regions_evac_pinned();\n+}\n+\n+bool G1YoungCollector::evacuation_alloc_failed() const {\n+  return _evac_failure_regions.has_regions_alloc_failed();\n@@ -1086,1 +1112,1 @@\n-    policy()->record_young_collection_end(_concurrent_operation_is_full_mark, evacuation_failed());\n+    policy()->record_young_collection_end(_concurrent_operation_is_full_mark, evacuation_alloc_failed());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-  \/\/ True iff an evacuation has failed in the most-recent collection.\n+  \/\/ True iff an evacuation failure of any kind occurred in the most-recent collection.\n@@ -136,0 +136,4 @@\n+  \/\/ True iff an evacuation had pinned regions in the most-recent collection.\n+  bool evacuation_pinned() const;\n+  \/\/ True iff an evacuation had allocation failures in the most-recent collection.\n+  bool evacuation_alloc_failed() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n+#include \"gc\/g1\/g1EvacFailureRegions.inline.hpp\"\n@@ -106,1 +106,1 @@\n-class G1PostEvacuateCollectionSetCleanupTask1::RestoreRetainedRegionsTask : public G1AbstractSubTask {\n+class G1PostEvacuateCollectionSetCleanupTask1::RestoreEvacFailureRegionsTask : public G1AbstractSubTask {\n@@ -268,2 +268,2 @@\n-  RestoreRetainedRegionsTask(G1EvacFailureRegions* evac_failure_regions) :\n-    G1AbstractSubTask(G1GCPhaseTimes::RestoreRetainedRegions),\n+  RestoreEvacFailureRegionsTask(G1EvacFailureRegions* evac_failure_regions) :\n+    G1AbstractSubTask(G1GCPhaseTimes::RestoreEvacuationFailedRegions),\n@@ -275,1 +275,1 @@\n-    _num_evac_fail_regions = _evac_failure_regions->num_regions_failed_evacuation();\n+    _num_evac_fail_regions = _evac_failure_regions->num_regions_evac_failed();\n@@ -287,1 +287,1 @@\n-    assert(_evac_failure_regions->evacuation_failed(), \"Should not call this if not executed\");\n+    assert(_evac_failure_regions->has_regions_evac_failed(), \"Should not call this if there were no evacuation failures\");\n@@ -290,1 +290,1 @@\n-    return workers_per_region * _evac_failure_regions->num_regions_failed_evacuation();\n+    return workers_per_region * _evac_failure_regions->num_regions_evac_failed();\n@@ -311,1 +311,1 @@\n-  bool evacuation_failed = evac_failure_regions->evacuation_failed();\n+  bool evac_failed = evac_failure_regions->has_regions_evac_failed();\n@@ -314,1 +314,1 @@\n-  add_serial_task(new RecalculateUsedTask(evacuation_failed));\n+  add_serial_task(new RecalculateUsedTask(evac_failed));\n@@ -319,2 +319,2 @@\n-  if (evacuation_failed) {\n-    add_parallel_task(new RestoreRetainedRegionsTask(evac_failure_regions));\n+  if (evac_failed) {\n+    add_parallel_task(new RestoreEvacFailureRegionsTask(evac_failure_regions));\n@@ -572,1 +572,1 @@\n-    return _evac_failure_regions->num_regions_failed_evacuation();\n+    return _evac_failure_regions->num_regions_evac_failed();\n@@ -760,1 +760,1 @@\n-    p->record_or_add_thread_work_item(G1GCPhaseTimes::RestoreRetainedRegions,\n+    p->record_or_add_thread_work_item(G1GCPhaseTimes::RestoreEvacuationFailedRegions,\n@@ -763,1 +763,1 @@\n-                                      G1GCPhaseTimes::RestoreRetainedRegionsFailedNum);\n+                                      G1GCPhaseTimes::RestoreEvacFailureRegionsEvacFailedNum);\n@@ -847,0 +847,1 @@\n+  volatile uint     _num_retained_regions;\n@@ -872,1 +873,2 @@\n-    _evac_failure_regions(evac_failure_regions) {\n+    _evac_failure_regions(evac_failure_regions),\n+    _num_retained_regions(0) {\n@@ -880,4 +882,1 @@\n-    G1GCPhaseTimes* p = _g1h->phase_times();\n-    bool has_new_retained_regions =\n-      p->sum_thread_work_items(G1GCPhaseTimes::RestoreRetainedRegions, G1GCPhaseTimes::RestoreRetainedRegionsRetainedNum) != 0;\n-\n+    bool has_new_retained_regions = Atomic::load(&_num_retained_regions) != 0;\n@@ -894,0 +893,2 @@\n+\n+    G1GCPhaseTimes* p = _g1h->phase_times();\n@@ -895,0 +896,1 @@\n+\n@@ -914,4 +916,2 @@\n-    _g1h->phase_times()->record_or_add_thread_work_item(G1GCPhaseTimes::RestoreRetainedRegions,\n-                                                        worker_id,\n-                                                        cl.num_retained_regions(),\n-                                                        G1GCPhaseTimes::RestoreRetainedRegionsRetainedNum);\n+\n+    Atomic::add(&_num_retained_regions, cl.num_retained_regions(), memory_order_relaxed);\n@@ -958,1 +958,1 @@\n-  if (evac_failure_regions->evacuation_failed()) {\n+  if (evac_failure_regions->has_regions_evac_failed()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-\/\/ - Restore retained regions (on evacuation failure)\n+\/\/ - Restore evac failure regions (on evacuation failure)\n@@ -47,1 +47,1 @@\n-  class RestoreRetainedRegionsTask;\n+  class RestoreEvacFailureRegionsTask;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -327,0 +327,4 @@\n+  product(uint, G1NumCollectionsKeepPinned, 8, DIAGNOSTIC,                  \\\n+          \"After how many GCs a region has been found pinned G1 should \"    \\\n+          \"give up reclaiming it.\")                                         \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -235,1 +235,2 @@\n-  _node_index(G1NUMA::UnknownNodeIndex)\n+  _node_index(G1NUMA::UnknownNodeIndex),\n+  _pinned_object_count(0)\n@@ -426,0 +427,1 @@\n+  st->print(\"|%3u\", Atomic::load(&_pinned_object_count));\n@@ -729,3 +731,14 @@\n-  \/\/ Fill the dead range with objects. G1 might need to create two objects if\n-  \/\/ the range is larger than half a region, which is the max_fill_size().\n-  CollectedHeap::fill_with_objects(start, range_size);\n+  \/\/ We must be a bit careful with regions that contain pinned objects. While the\n+  \/\/ ranges passed in here corresponding to the space between live objects, it is\n+  \/\/ possible that there is a pinned object that is not any more referenced by\n+  \/\/ Java code (only by native).\n+  \/\/\n+  \/\/ In this case we must not zap contents of such an array but we can overwrite\n+  \/\/ the header; since only pinned typearrays are allowed, this fits nicely with\n+  \/\/ putting filler arrays into the dead range as the object header sizes match and\n+  \/\/ no user data is overwritten.\n+  \/\/\n+  \/\/ In particular String Deduplication might change the reference to the character\n+  \/\/ array of the j.l.String after native code obtained a raw reference to it (via\n+  \/\/ GetStringCritical()).\n+  CollectedHeap::fill_with_objects(start, range_size, !has_pinned_objects());\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  void prepare_for_full_gc();\n@@ -232,5 +233,11 @@\n-  \/\/ is equal to bottom except from Remark and until the region has been\n-  \/\/ scrubbed concurrently. The scrubbing ensures that all dead objects (with\n-  \/\/ possibly unloaded classes) have beenreplaced with filler objects that\n-  \/\/ are parsable. Below this limit the marking bitmap must be used to\n-  \/\/ determine size and liveness.\n+  \/\/ is equal to bottom except\n+  \/\/\n+  \/\/ * from Remark and until the region has been scrubbed concurrently. The\n+  \/\/   scrubbing ensures that all dead objects (with possibly unloaded classes)\n+  \/\/   have been replaced with filler objects that are parsable.\n+  \/\/ * after the marking phase in the Full GC pause until the objects have been\n+  \/\/   moved. Some (debug) code iterates over the heap after marking but before\n+  \/\/   compaction.\n+  \/\/\n+  \/\/ Below this limit the marking bitmap must be used to determine size and\n+  \/\/ liveness.\n@@ -252,0 +259,3 @@\n+  \/\/ Number of objects in this region that are currently pinned.\n+  volatile uint _pinned_object_count;\n+\n@@ -295,0 +305,3 @@\n+  inline void increment_pinned_object_count();\n+  inline void decrement_pinned_object_count();\n+\n@@ -398,0 +411,3 @@\n+  uint pinned_count() const { return Atomic::load(&_pinned_object_count); }\n+  bool has_pinned_objects() const { return pinned_count() > 0; }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -170,0 +170,7 @@\n+inline void HeapRegion::prepare_for_full_gc() {\n+  \/\/ After marking and class unloading the heap temporarily contains dead objects\n+  \/\/ with unloaded klasses. Moving parsable_bottom makes some (debug) code correctly\n+  \/\/ skip dead objects.\n+  _parsable_bottom = top();\n+}\n+\n@@ -191,1 +198,1 @@\n-  _parsable_bottom = bottom();\n+  reset_parsable_bottom();\n@@ -549,0 +556,8 @@\n+inline void HeapRegion::increment_pinned_object_count() {\n+  Atomic::add(&_pinned_object_count, 1u, memory_order_relaxed);\n+}\n+\n+inline void HeapRegion::decrement_pinned_object_count() {\n+  Atomic::sub(&_pinned_object_count, 1u, memory_order_relaxed);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  nonstatic_field(HeapRegion, _pinned_object_count, volatile uint)            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/vmStructs_g1.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -145,0 +145,5 @@\n+int MutableNUMASpace::lgrp_space_index(int lgrp_id) const {\n+  return lgrp_spaces()->find_if([&](LGRPSpace* space) {\n+    return space->lgrp_id() == checked_cast<uint>(lgrp_id);\n+  });\n+}\n@@ -163,1 +168,1 @@\n-  int i = lgrp_spaces()->find(&lgrp_id, LGRPSpace::equals);\n+  int i = lgrp_space_index(lgrp_id);\n@@ -182,1 +187,1 @@\n-  int i = lgrp_spaces()->find(&lgrp_id, LGRPSpace::equals);\n+  int i = lgrp_space_index(lgrp_id);\n@@ -202,1 +207,1 @@\n-  int i = lgrp_spaces()->find(&lgrp_id, LGRPSpace::equals);\n+  int i = lgrp_space_index(lgrp_id);\n@@ -239,14 +244,0 @@\n-\n-  scan_pages(NUMAPageScanRate);\n-}\n-\n-\/\/ Scan pages. Free pages that have smaller size or wrong placement.\n-void MutableNUMASpace::scan_pages(size_t page_count)\n-{\n-  size_t pages_per_chunk = page_count \/ lgrp_spaces()->length();\n-  if (pages_per_chunk > 0) {\n-    for (int i = 0; i < lgrp_spaces()->length(); i++) {\n-      LGRPSpace *ls = lgrp_spaces()->at(i);\n-      ls->scan_pages(page_size(), pages_per_chunk);\n-    }\n-  }\n@@ -586,1 +577,1 @@\n-  int i = lgrp_spaces()->find(&lgrp_id, LGRPSpace::equals);\n+  int i = lgrp_space_index(lgrp_id);\n@@ -694,40 +685,0 @@\n-\n-\/\/ Scan page_count pages and verify if they have the right size and right placement.\n-\/\/ If invalid pages are found they are freed in hope that subsequent reallocation\n-\/\/ will be more successful.\n-void MutableNUMASpace::LGRPSpace::scan_pages(size_t page_size, size_t page_count)\n-{\n-  char* range_start = (char*)align_up(space()->bottom(), page_size);\n-  char* range_end = (char*)align_down(space()->end(), page_size);\n-\n-  if (range_start > last_page_scanned() || last_page_scanned() >= range_end) {\n-    set_last_page_scanned(range_start);\n-  }\n-\n-  char *scan_start = last_page_scanned();\n-  char* scan_end = MIN2(scan_start + page_size * page_count, range_end);\n-\n-  os::page_info page_expected, page_found;\n-  page_expected.size = page_size;\n-  page_expected.lgrp_id = checked_cast<uint>(lgrp_id());\n-\n-  char *s = scan_start;\n-  while (s < scan_end) {\n-    char *e = os::scan_pages(s, (char*)scan_end, &page_expected, &page_found);\n-    if (e == nullptr) {\n-      break;\n-    }\n-    if (e != scan_end) {\n-      assert(e < scan_end, \"e: \" PTR_FORMAT \" scan_end: \" PTR_FORMAT, p2i(e), p2i(scan_end));\n-\n-      if ((page_expected.size != page_size || checked_cast<uint>(page_expected.lgrp_id) != lgrp_id())\n-          && page_expected.size != 0) {\n-        os::free_memory(s, pointer_delta(e, s, sizeof(char)), page_size);\n-      }\n-      page_expected = page_found;\n-    }\n-    s = e;\n-  }\n-\n-  set_last_page_scanned(scan_end);\n-}\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":9,"deletions":58,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -86,3 +86,0 @@\n-    char* _last_page_scanned;\n-    char* last_page_scanned()            { return _last_page_scanned; }\n-    void set_last_page_scanned(char* p)  { _last_page_scanned = p;    }\n@@ -90,1 +87,1 @@\n-    LGRPSpace(uint l, size_t alignment) : _lgrp_id(l), _allocation_failed(false), _last_page_scanned(nullptr) {\n+    LGRPSpace(uint l, size_t alignment) : _lgrp_id(l), _allocation_failed(false) {\n@@ -99,4 +96,0 @@\n-    static bool equals(void* lgrp_id_value, LGRPSpace* p) {\n-      return *(uint*)lgrp_id_value == p->lgrp_id();\n-    }\n-\n@@ -128,1 +121,0 @@\n-    void scan_pages(size_t page_size, size_t page_count);\n@@ -159,2 +151,0 @@\n-  \/\/ Scan and free invalid pages.\n-  void scan_pages(size_t page_count);\n@@ -167,0 +157,2 @@\n+  int lgrp_space_index(int lgrp_id) const;\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -172,16 +172,0 @@\n-\/\/ If the remaining free space in the old generation is less that\n-\/\/ that expected to be needed by the next collection, do a full\n-\/\/ collection now.\n-bool PSAdaptiveSizePolicy::should_full_GC(size_t old_free_in_bytes) {\n-\n-  \/\/ A similar test is done in the scavenge's should_attempt_scavenge().  If\n-  \/\/ this is changed, decide if that test should also be changed.\n-  bool result = padded_average_promoted_in_bytes() > (float) old_free_in_bytes;\n-  log_trace(gc, ergo)(\"%s after scavenge average_promoted \" SIZE_FORMAT \" padded_average_promoted \" SIZE_FORMAT \" free in old gen \" SIZE_FORMAT,\n-                      result ? \"Full\" : \"No full\",\n-                      (size_t) average_promoted_in_bytes(),\n-                      (size_t) padded_average_promoted_in_bytes(),\n-                      old_free_in_bytes);\n-  return result;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -309,4 +309,0 @@\n-  \/\/ Given the amount of live data in the heap, should we\n-  \/\/ perform a Full GC?\n-  bool should_full_GC(size_t live_in_old_gen);\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -242,2 +242,1 @@\n-  const bool need_full_gc = !scavenge_done ||\n-    policy->should_full_GC(heap->old_gen()->free_in_bytes());\n+  const bool need_full_gc = !scavenge_done;\n@@ -706,2 +705,0 @@\n-  \/\/ A similar test is done in the policy's should_full_GC().  If this is\n-  \/\/ changed, decide if that test should also be changed.\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"memory\/allocation.inline.hpp\"\n@@ -33,258 +32,1 @@\n-#include \"oops\/access.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-\/\/ A dirty card to oop closure for contiguous spaces (ContiguousSpace and\n-\/\/ sub-classes). It knows how to filter out objects that are outside of the\n-\/\/ _boundary.\n-\/\/ (Note that because of the imprecise nature of the write barrier, this may\n-\/\/ iterate over oops beyond the region.)\n-\/\/\n-\/\/ Assumptions:\n-\/\/ 1. That the actual top of any area in a memory region\n-\/\/    contained by the space is bounded by the end of the contiguous\n-\/\/    region of the space.\n-\/\/ 2. That the space is really made up of objects and not just\n-\/\/    blocks.\n-\n-class DirtyCardToOopClosure: public MemRegionClosure {\n-protected:\n-  OopIterateClosure* _cl;\n-  TenuredSpace* _sp;\n-  HeapWord* _min_done;          \/\/ Need a downwards traversal to compensate\n-                                \/\/ imprecise write barrier; this is the\n-                                \/\/ lowest location already done (or,\n-                                \/\/ alternatively, the lowest address that\n-                                \/\/ shouldn't be done again.  null means infinity.)\n-  NOT_PRODUCT(HeapWord* _last_bottom;)\n-\n-  \/\/ Get the actual top of the area on which the closure will\n-  \/\/ operate, given where the top is assumed to be (the end of the\n-  \/\/ memory region passed to do_MemRegion) and where the object\n-  \/\/ at the top is assumed to start. For example, an object may\n-  \/\/ start at the top but actually extend past the assumed top,\n-  \/\/ in which case the top becomes the end of the object.\n-  HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj);\n-\n-  \/\/ Walk the given memory region from bottom to (actual) top\n-  \/\/ looking for objects and applying the oop closure (_cl) to\n-  \/\/ them. The base implementation of this treats the area as\n-  \/\/ blocks, where a block may or may not be an object. Sub-\n-  \/\/ classes should override this to provide more accurate\n-  \/\/ or possibly more efficient walking.\n-  void walk_mem_region(MemRegion mr, HeapWord* bottom, HeapWord* top);\n-\n-  \/\/ Walk the given memory region, from bottom to top, applying\n-  \/\/ the given oop closure to (possibly) all objects found. The\n-  \/\/ given oop closure may or may not be the same as the oop\n-  \/\/ closure with which this closure was created, as it may\n-  \/\/ be a filtering closure which makes use of the _boundary.\n-  \/\/ We offer two signatures, so the FilteringClosure static type is\n-  \/\/ apparent.\n-  void walk_mem_region_with_cl(MemRegion mr,\n-                               HeapWord* bottom, HeapWord* top,\n-                               OopIterateClosure* cl);\n-public:\n-  DirtyCardToOopClosure(TenuredSpace* sp, OopIterateClosure* cl) :\n-    _cl(cl), _sp(sp), _min_done(nullptr) {\n-    NOT_PRODUCT(_last_bottom = nullptr);\n-  }\n-\n-  void do_MemRegion(MemRegion mr) override;\n-};\n-\n-HeapWord* DirtyCardToOopClosure::get_actual_top(HeapWord* top,\n-                                                HeapWord* top_obj) {\n-  if (top_obj != nullptr && top_obj < _sp->top()) {\n-    if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n-      \/\/ An arrayOop is starting on the dirty card - since we do exact\n-      \/\/ store checks for objArrays we are done.\n-    } else {\n-      \/\/ Otherwise, it is possible that the object starting on the dirty\n-      \/\/ card spans the entire card, and that the store happened on a\n-      \/\/ later card.  Figure out where the object ends.\n-      top = top_obj + cast_to_oop(top_obj)->size();\n-    }\n-  } else {\n-    top = _sp->top();\n-  }\n-  return top;\n-}\n-\n-void DirtyCardToOopClosure::walk_mem_region(MemRegion mr,\n-                                            HeapWord* bottom,\n-                                            HeapWord* top) {\n-  \/\/ Note that this assumption won't hold if we have a concurrent\n-  \/\/ collector in this space, which may have freed up objects after\n-  \/\/ they were dirtied and before the stop-the-world GC that is\n-  \/\/ examining cards here.\n-  assert(bottom < top, \"ought to be at least one obj on a dirty card.\");\n-\n-  walk_mem_region_with_cl(mr, bottom, top, _cl);\n-}\n-\n-\/\/ We get called with \"mr\" representing the dirty region\n-\/\/ that we want to process. Because of imprecise marking,\n-\/\/ we may need to extend the incoming \"mr\" to the right,\n-\/\/ and scan more. However, because we may already have\n-\/\/ scanned some of that extended region, we may need to\n-\/\/ trim its right-end back some so we do not scan what\n-\/\/ we (or another worker thread) may already have scanned\n-\/\/ or planning to scan.\n-void DirtyCardToOopClosure::do_MemRegion(MemRegion mr) {\n-  HeapWord* bottom = mr.start();\n-  HeapWord* last = mr.last();\n-  HeapWord* top = mr.end();\n-  HeapWord* bottom_obj;\n-  HeapWord* top_obj;\n-\n-  assert(_last_bottom == nullptr || top <= _last_bottom,\n-         \"Not decreasing\");\n-  NOT_PRODUCT(_last_bottom = mr.start());\n-\n-  bottom_obj = _sp->block_start(bottom);\n-  top_obj    = _sp->block_start(last);\n-\n-  assert(bottom_obj <= bottom, \"just checking\");\n-  assert(top_obj    <= top,    \"just checking\");\n-\n-  \/\/ Given what we think is the top of the memory region and\n-  \/\/ the start of the object at the top, get the actual\n-  \/\/ value of the top.\n-  top = get_actual_top(top, top_obj);\n-\n-  \/\/ If the previous call did some part of this region, don't redo.\n-  if (_min_done != nullptr && _min_done < top) {\n-    top = _min_done;\n-  }\n-\n-  \/\/ Top may have been reset, and in fact may be below bottom,\n-  \/\/ e.g. the dirty card region is entirely in a now free object\n-  \/\/ -- something that could happen with a concurrent sweeper.\n-  bottom = MIN2(bottom, top);\n-  MemRegion extended_mr = MemRegion(bottom, top);\n-  assert(bottom <= top &&\n-         (_min_done == nullptr || top <= _min_done),\n-         \"overlap!\");\n-\n-  \/\/ Walk the region if it is not empty; otherwise there is nothing to do.\n-  if (!extended_mr.is_empty()) {\n-    walk_mem_region(extended_mr, bottom_obj, top);\n-  }\n-\n-  _min_done = bottom;\n-}\n-\n-void DirtyCardToOopClosure::walk_mem_region_with_cl(MemRegion mr,\n-                                                    HeapWord* bottom,\n-                                                    HeapWord* top,\n-                                                    OopIterateClosure* cl) {\n-  bottom += cast_to_oop(bottom)->oop_iterate_size(cl, mr);\n-  if (bottom < top) {\n-    HeapWord* next_obj = bottom + cast_to_oop(bottom)->size();\n-    while (next_obj < top) {\n-      \/* Bottom lies entirely below top, so we can call the *\/\n-      \/* non-memRegion version of oop_iterate below. *\/\n-      cast_to_oop(bottom)->oop_iterate(cl);\n-      bottom = next_obj;\n-      next_obj = bottom + cast_to_oop(bottom)->size();\n-    }\n-    \/* Last object. *\/\n-    cast_to_oop(bottom)->oop_iterate(cl, mr);\n-  }\n-}\n-\n-class ClearNoncleanCardWrapper: public MemRegionClosure {\n-  DirtyCardToOopClosure* _dirty_card_closure;\n-  CardTableRS* _ct;\n-\n-public:\n-\n-  typedef CardTable::CardValue CardValue;\n-private:\n-  \/\/ Clears the given card, return true if the corresponding card should be\n-  \/\/ processed.\n-  inline bool clear_card(CardValue* entry);\n-  \/\/ check alignment of pointer\n-  bool is_word_aligned(CardValue* entry);\n-\n-public:\n-  ClearNoncleanCardWrapper(DirtyCardToOopClosure* dirty_card_closure, CardTableRS* ct);\n-  void do_MemRegion(MemRegion mr) override;\n-};\n-\n-inline bool ClearNoncleanCardWrapper::clear_card(CardValue* entry) {\n-  assert(*entry == CardTableRS::dirty_card_val(), \"Only look at dirty cards.\");\n-  *entry = CardTableRS::clean_card_val();\n-  return true;\n-}\n-\n-ClearNoncleanCardWrapper::ClearNoncleanCardWrapper(\n-  DirtyCardToOopClosure* dirty_card_closure, CardTableRS* ct) :\n-    _dirty_card_closure(dirty_card_closure), _ct(ct) {\n-}\n-\n-bool ClearNoncleanCardWrapper::is_word_aligned(CardTable::CardValue* entry) {\n-  return (((intptr_t)entry) & (BytesPerWord-1)) == 0;\n-}\n-\n-\/\/ The regions are visited in *decreasing* address order.\n-\/\/ This order aids with imprecise card marking, where a dirty\n-\/\/ card may cause scanning, and summarization marking, of objects\n-\/\/ that extend onto subsequent cards.\n-void ClearNoncleanCardWrapper::do_MemRegion(MemRegion mr) {\n-  assert(mr.word_size() > 0, \"Error\");\n-  assert(_ct->is_aligned(mr.start()), \"mr.start() should be card aligned\");\n-  \/\/ mr.end() may not necessarily be card aligned.\n-  CardValue* cur_entry = _ct->byte_for(mr.last());\n-  const CardValue* limit = _ct->byte_for(mr.start());\n-  HeapWord* end_of_non_clean = mr.end();\n-  HeapWord* start_of_non_clean = end_of_non_clean;\n-  while (cur_entry >= limit) {\n-    HeapWord* cur_hw = _ct->addr_for(cur_entry);\n-    if ((*cur_entry != CardTableRS::clean_card_val()) && clear_card(cur_entry)) {\n-      \/\/ Continue the dirty range by opening the\n-      \/\/ dirty window one card to the left.\n-      start_of_non_clean = cur_hw;\n-    } else {\n-      \/\/ We hit a \"clean\" card; process any non-empty\n-      \/\/ \"dirty\" range accumulated so far.\n-      if (start_of_non_clean < end_of_non_clean) {\n-        const MemRegion mrd(start_of_non_clean, end_of_non_clean);\n-        _dirty_card_closure->do_MemRegion(mrd);\n-      }\n-\n-      \/\/ fast forward through potential continuous whole-word range of clean cards beginning at a word-boundary\n-      if (is_word_aligned(cur_entry)) {\n-        CardValue* cur_row = cur_entry - BytesPerWord;\n-        while (cur_row >= limit && *((intptr_t*)cur_row) ==  CardTableRS::clean_card_row_val()) {\n-          cur_row -= BytesPerWord;\n-        }\n-        cur_entry = cur_row + BytesPerWord;\n-        cur_hw = _ct->addr_for(cur_entry);\n-      }\n-\n-      \/\/ Reset the dirty window, while continuing to look\n-      \/\/ for the next dirty card that will start a\n-      \/\/ new dirty window.\n-      end_of_non_clean = cur_hw;\n-      start_of_non_clean = cur_hw;\n-    }\n-    \/\/ Note that \"cur_entry\" leads \"start_of_non_clean\" in\n-    \/\/ its leftward excursion after this point\n-    \/\/ in the loop and, when we hit the left end of \"mr\",\n-    \/\/ will point off of the left end of the card-table\n-    \/\/ for \"mr\".\n-    cur_entry--;\n-  }\n-  \/\/ If the first card of \"mr\" was dirty, we will have\n-  \/\/ been left with a dirty window, co-initial with \"mr\",\n-  \/\/ which we now process.\n-  if (start_of_non_clean < end_of_non_clean) {\n-    const MemRegion mrd(start_of_non_clean, end_of_non_clean);\n-    _dirty_card_closure->do_MemRegion(mrd);\n-  }\n-}\n+#include \"utilities\/align.hpp\"\n@@ -297,1 +39,3 @@\n-  non_clean_card_iterate(sp, urasm, cl, this);\n+  if (!urasm.is_empty()) {\n+    non_clean_card_iterate(sp, urasm, cl, this);\n+  }\n@@ -604,0 +348,103 @@\n+\/\/ Implemented word-iteration to skip long consecutive clean cards.\n+CardTable::CardValue* CardTableRS::find_first_dirty_card(CardValue* const start_card,\n+                                                         CardValue* const end_card) {\n+  using Word = uintptr_t;\n+\n+  CardValue* current_card = start_card;\n+\n+  while (!is_aligned(current_card, sizeof(Word))) {\n+    if (current_card >= end_card) {\n+      return end_card;\n+    }\n+    if (is_dirty(current_card)) {\n+      return current_card;\n+    }\n+    ++current_card;\n+  }\n+\n+  \/\/ Word comparison\n+  while (current_card + sizeof(Word) <= end_card) {\n+    Word* current_word = reinterpret_cast<Word*>(current_card);\n+    if (*current_word != (Word)clean_card_row_val()) {\n+      \/\/ Found a dirty card in this word; fall back to per-CardValue comparison.\n+      break;\n+    }\n+    current_card += sizeof(Word);\n+  }\n+\n+  \/\/ Per-CardValue comparison.\n+  for (\/* empty *\/; current_card < end_card; ++current_card) {\n+    if (is_dirty(current_card)) {\n+      return current_card;\n+    }\n+  }\n+\n+  return end_card;\n+}\n+\n+\/\/ Because non-objArray objs can be imprecisely-marked (only obj-start card is\n+\/\/ dirty instead of the part containing old-to-young pointers), if the\n+\/\/ obj-start of a non-objArray is dirty, all cards that obj completely resides\n+\/\/ on are considered as dirty, since that obj will be iterated (scanned for\n+\/\/ old-to-young pointers) as a whole.\n+template<typename Func>\n+CardTable::CardValue* CardTableRS::find_first_clean_card(CardValue* const start_card,\n+                                                         CardValue* const end_card,\n+                                                         CardTableRS* ct,\n+                                                         Func& object_start) {\n+  for (CardValue* current_card = start_card; current_card < end_card; \/* empty *\/) {\n+    if (is_dirty(current_card)) {\n+      current_card++;\n+      continue;\n+    }\n+\n+    \/\/ A potential candidate.\n+    HeapWord* addr = ct->addr_for(current_card);\n+    HeapWord* obj_start_addr = object_start(addr);\n+\n+    if (obj_start_addr == addr) {\n+      return current_card;\n+    }\n+\n+    \/\/ Final obj in dirty-chunk crosses card-boundary.\n+    oop obj = cast_to_oop(obj_start_addr);\n+    if (obj->is_objArray()) {\n+      \/\/ ObjArrays are always precisely-marked so we are not allowed to jump to\n+      \/\/ the end of the current object.\n+      return current_card;\n+    }\n+\n+    \/\/ Card occupied by next obj.\n+    CardValue* next_obj_card = ct->byte_for(obj_start_addr + obj->size());\n+    if (is_clean(next_obj_card)) {\n+      return next_obj_card;\n+    }\n+\n+    \/\/ Continue the search after this known-dirty card...\n+    current_card = next_obj_card + 1;\n+  }\n+\n+  return end_card;\n+}\n+\n+void CardTableRS::clear_cards(CardValue* start, CardValue* end) {\n+  size_t num_cards = pointer_delta(end, start, sizeof(CardValue));\n+  memset(start, clean_card_val(), num_cards);\n+}\n+\n+static void prefetch_write(void *p) {\n+  if (PrefetchScanIntervalInBytes >= 0) {\n+    Prefetch::write(p, PrefetchScanIntervalInBytes);\n+  }\n+}\n+\n+static void scan_obj_with_limit(oop obj,\n+                                OopIterateClosure* cl,\n+                                HeapWord* start,\n+                                HeapWord* end) {\n+  if (!obj->is_typeArray()) {\n+    prefetch_write(start);\n+    obj->oop_iterate(cl, MemRegion(start, end));\n+  }\n+}\n+\n@@ -607,6 +454,30 @@\n-                                         CardTableRS* ct)\n-{\n-  if (mr.is_empty()) {\n-    return;\n-  }\n-  \/\/ clear_cl finds contiguous dirty ranges of cards to process and clear.\n+                                         CardTableRS* ct) {\n+  struct {\n+    HeapWord* start_addr;\n+    HeapWord* end_addr;\n+  } cached_obj { nullptr, mr.start() };\n+\n+  auto object_start = [&] (const HeapWord* const addr) {\n+    if (addr < cached_obj.end_addr) {\n+      assert(cached_obj.start_addr != nullptr, \"inv\");\n+      return cached_obj.start_addr;\n+    }\n+    HeapWord* result = sp->block_start_const(addr);\n+\n+    cached_obj.start_addr = result;\n+    cached_obj.end_addr = result + cast_to_oop(result)->size();\n+\n+    return result;\n+  };\n+\n+  CardValue* const start_card = ct->byte_for(mr.start());\n+  CardValue* const end_card = ct->byte_for(mr.last()) + 1;\n+\n+  \/\/ if mr.end() is not card-aligned, that final card should not be cleared\n+  \/\/ because it can be annotated dirty due to old-to-young pointers in\n+  \/\/ newly-promoted objs on that card.\n+  CardValue* const clear_limit_card = is_card_aligned(mr.end()) ? end_card - 1\n+                                                                : end_card - 2;\n+\n+  for (CardValue* current_card = start_card; current_card < end_card; \/* empty *\/) {\n+    CardValue* const dirty_l = find_first_dirty_card(current_card, end_card);\n@@ -614,2 +485,25 @@\n-  DirtyCardToOopClosure dcto_cl{sp, cl};\n-  ClearNoncleanCardWrapper clear_cl(&dcto_cl, ct);\n+    if (dirty_l == end_card) {\n+      \/\/ No dirty cards to iterate.\n+      return;\n+    }\n+\n+    HeapWord* const addr_l = ct->addr_for(dirty_l);\n+    HeapWord* obj_addr = object_start(addr_l);\n+\n+    CardValue* const dirty_r = find_first_clean_card(dirty_l + 1,\n+                                                     end_card,\n+                                                     ct,\n+                                                     object_start);\n+    assert(dirty_l < dirty_r, \"inv\");\n+    HeapWord* const addr_r = dirty_r == end_card ? mr.end()\n+                                                 : ct->addr_for(dirty_r);\n+\n+    clear_cards(MIN2(dirty_l, clear_limit_card),\n+                MIN2(dirty_r, clear_limit_card));\n+\n+    while (true) {\n+      assert(obj_addr < addr_r, \"inv\");\n+\n+      oop obj = cast_to_oop(obj_addr);\n+      const bool is_obj_array = obj->is_objArray();\n+      HeapWord* const obj_end_addr = obj_addr + obj->size();\n@@ -617,1 +511,16 @@\n-  clear_cl.do_MemRegion(mr);\n+      if (is_obj_array) {\n+        \/\/ ObjArrays are always precise-marked.\n+        scan_obj_with_limit(obj, cl, addr_l, addr_r);\n+      } else {\n+        scan_obj_with_limit(obj, cl, addr_l, obj_end_addr);\n+      }\n+\n+      if (obj_end_addr >= addr_r) {\n+        current_card = dirty_r + 1;\n+        break;\n+      }\n+\n+      \/\/ Move to next obj inside this dirty chunk.\n+      obj_addr = obj_end_addr;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.cpp","additions":178,"deletions":269,"binary":false,"changes":447,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-class DirtyCardToOopClosure;\n@@ -44,1 +43,0 @@\n-  friend class ClearNoncleanCardWrapper;\n@@ -48,0 +46,19 @@\n+  static bool is_dirty(const CardValue* const v) {\n+    return !is_clean(v);\n+  }\n+\n+  static bool is_clean(const CardValue* const v) {\n+    return *v == clean_card_val();\n+  }\n+\n+  static void clear_cards(CardValue* start, CardValue* end);\n+\n+  static CardValue* find_first_dirty_card(CardValue* start_card,\n+                                          CardValue* end_card);\n+\n+  template<typename Func>\n+  CardValue* find_first_clean_card(CardValue* start_card,\n+                                   CardValue* end_card,\n+                                   CardTableRS* ct,\n+                                   Func& object_start);\n+\n@@ -60,4 +77,0 @@\n-  bool is_aligned(HeapWord* addr) {\n-    return is_card_aligned(addr);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/cardTableRS.hpp","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"gc\/shared\/generationSpec.hpp\"\n@@ -563,1 +562,1 @@\n-  size_t min_new_size = initial_size();\n+  size_t min_new_size = NewSize;\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"gc\/shared\/generationSpec.hpp\"\n@@ -60,8 +59,0 @@\n-size_t Generation::initial_size() {\n-  SerialHeap* serial_heap = SerialHeap::heap();\n-  if (serial_heap->is_young_gen(this)) {\n-    return serial_heap->young_gen_spec()->init_size();\n-  }\n-  return serial_heap->old_gen_spec()->init_size();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-class GenerationSpec;\n@@ -116,2 +115,0 @@\n-  \/\/ Space inquiries (results in bytes)\n-  size_t initial_size();\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"gc\/shared\/generationSpec.hpp\"\n@@ -168,1 +167,1 @@\n-  minimum_desired_capacity = MAX2(minimum_desired_capacity, initial_size());\n+  minimum_desired_capacity = MAX2(minimum_desired_capacity, OldSize);\n@@ -207,1 +206,1 @@\n-    maximum_desired_capacity = MAX2(maximum_desired_capacity, initial_size());\n+    maximum_desired_capacity = MAX2(maximum_desired_capacity, OldSize);\n@@ -237,1 +236,1 @@\n-                               initial_size() \/ (double) K, maximum_desired_capacity \/ (double) K);\n+                               OldSize \/ (double) K, maximum_desired_capacity \/ (double) K);\n@@ -307,6 +306,2 @@\n-  guarantee(_rs->is_aligned(reserved_mr.start()), \"generation must be card aligned\");\n-  if (reserved_mr.end() != SerialHeap::heap()->reserved_region().end()) {\n-    \/\/ Don't check at the very end of the heap as we'll assert that we're probing off\n-    \/\/ the end if we try.\n-    guarantee(_rs->is_aligned(reserved_mr.end()), \"generation must be card aligned\");\n-  }\n+  guarantee(_rs->is_card_aligned(reserved_mr.start()), \"generation must be card aligned\");\n+  guarantee(_rs->is_card_aligned(reserved_mr.end()), \"generation must be card aligned\");\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -115,2 +115,1 @@\n-    CardValue* pcard = byte_for(p);\n-    return (addr_for(pcard) == p);\n+    return is_aligned(p, card_size());\n@@ -199,1 +198,1 @@\n-  static intptr_t clean_card_row_val()   { return clean_card_row; }\n+  static constexpr intptr_t clean_card_row_val()   { return clean_card_row; }\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -168,1 +168,0 @@\n-  static inline size_t filler_array_min_size();\n@@ -170,0 +169,3 @@\n+  static size_t filler_array_min_size();\n+\n+protected:\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/serial\/tenuredGeneration.hpp\"\n@@ -50,1 +51,0 @@\n-#include \"gc\/shared\/generationSpec.hpp\"\n@@ -88,8 +88,0 @@\n-  _young_gen_spec(new GenerationSpec(young,\n-                                     NewSize,\n-                                     MaxNewSize,\n-                                     GenAlignment)),\n-  _old_gen_spec(new GenerationSpec(old,\n-                                   OldSize,\n-                                   MaxOldSize,\n-                                   GenAlignment)),\n@@ -118,2 +110,2 @@\n-  ReservedSpace young_rs = heap_rs.first_part(_young_gen_spec->max_size());\n-  ReservedSpace old_rs = heap_rs.last_part(_young_gen_spec->max_size());\n+  ReservedSpace young_rs = heap_rs.first_part(MaxNewSize);\n+  ReservedSpace old_rs = heap_rs.last_part(MaxNewSize);\n@@ -128,2 +120,2 @@\n-  _young_gen = _young_gen_spec->init(young_rs, rem_set());\n-  _old_gen = _old_gen_spec->init(old_rs, rem_set());\n+  _young_gen = new DefNewGeneration(young_rs, NewSize, MinNewSize, MaxNewSize);\n+  _old_gen = new TenuredGeneration(old_rs, OldSize, MinOldSize, MaxOldSize, rem_set());\n@@ -146,2 +138,2 @@\n-  size_t total_reserved = _young_gen_spec->max_size() + _old_gen_spec->max_size();\n-  if (total_reserved < _young_gen_spec->max_size()) {\n+  size_t total_reserved = MaxNewSize + MaxOldSize;\n+  if (total_reserved < MaxNewSize) {\n@@ -202,8 +194,0 @@\n-GenerationSpec* GenCollectedHeap::young_gen_spec() const {\n-  return _young_gen_spec;\n-}\n-\n-GenerationSpec* GenCollectedHeap::old_gen_spec() const {\n-  return _old_gen_spec;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":7,"deletions":23,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-class GenerationSpec;\n@@ -65,3 +64,0 @@\n-  GenerationSpec* _young_gen_spec;\n-  GenerationSpec* _old_gen_spec;\n-\n@@ -147,3 +143,0 @@\n-  GenerationSpec* young_gen_spec() const;\n-  GenerationSpec* old_gen_spec() const;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/serial\/cardTableRS.hpp\"\n-#include \"gc\/shared\/generationSpec.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"utilities\/macros.hpp\"\n-#if INCLUDE_SERIALGC\n-#include \"gc\/serial\/defNewGeneration.hpp\"\n-#include \"gc\/serial\/tenuredGeneration.hpp\"\n-#endif\n-\n-Generation* GenerationSpec::init(ReservedSpace rs, CardTableRS* remset) {\n-  switch (name()) {\n-#if INCLUDE_SERIALGC\n-    case Generation::DefNew:\n-      return new DefNewGeneration(rs, _init_size, _min_size, _max_size);\n-\n-    case Generation::MarkSweepCompact:\n-      return new TenuredGeneration(rs, _init_size, _min_size, _max_size, remset);\n-#endif\n-\n-    default:\n-      guarantee(false, \"unrecognized GenerationName\");\n-      return nullptr;\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/generationSpec.cpp","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_GENERATIONSPEC_HPP\n-#define SHARE_GC_SHARED_GENERATIONSPEC_HPP\n-\n-#include \"gc\/serial\/generation.hpp\"\n-#include \"utilities\/align.hpp\"\n-\n-\/\/ The specification of a generation.  This class also encapsulates\n-\/\/ some generation-specific behavior.  This is done here rather than as a\n-\/\/ virtual function of Generation because these methods are needed in\n-\/\/ initialization of the Generations.\n-class GenerationSpec : public CHeapObj<mtGC> {\n-  friend class VMStructs;\n-private:\n-  Generation::Name _name;\n-  size_t           _init_size;\n-  size_t           _min_size;\n-  size_t           _max_size;\n-\n-public:\n-  GenerationSpec(Generation::Name name, size_t init_size, size_t max_size, size_t alignment) :\n-    _name(name),\n-    _init_size(align_up(init_size, alignment)),\n-    _min_size(_init_size),\n-    _max_size(align_up(max_size, alignment))\n-  { }\n-\n-  Generation* init(ReservedSpace rs, CardTableRS* remset);\n-\n-  Generation::Name name() const { return _name; }\n-  size_t init_size()      const { return _init_size; }\n-  size_t min_size()       const { return _min_size; }\n-  size_t max_size()       const { return _max_size; }\n-};\n-\n-typedef GenerationSpec* GenerationSpecPtr;\n-\n-#endif \/\/ SHARE_GC_SHARED_GENERATIONSPEC_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/generationSpec.hpp","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shared\/generationSpec.hpp\"\n@@ -117,4 +116,0 @@\n-  nonstatic_field(GenerationSpec,              _name,                                         Generation::Name)                      \\\n-  nonstatic_field(GenerationSpec,              _init_size,                                    size_t)                                \\\n-  nonstatic_field(GenerationSpec,              _max_size,                                     size_t)                                \\\n-                                                                                                                                     \\\n@@ -123,2 +118,0 @@\n-  nonstatic_field(GenCollectedHeap,            _young_gen_spec,                               GenerationSpec*)                       \\\n-  nonstatic_field(GenCollectedHeap,            _old_gen_spec,                                 GenerationSpec*)                       \\\n@@ -175,1 +168,0 @@\n-  declare_toplevel_type(GenerationSpec)                                   \\\n@@ -193,1 +185,0 @@\n-  declare_toplevel_type(GenerationSpec**)                                 \\\n","filename":"src\/hotspot\/share\/gc\/shared\/vmStructs_gc.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1396,1 +1396,1 @@\n-    if (ShenandoahSelfFixing) {\n+    {\n@@ -1399,2 +1399,0 @@\n-    } else {\n-      addr = phase->igvn().zerocon(T_OBJECT);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,6 +42,0 @@\n-\n-  \/\/ If class unloading is globally enabled, aggressive does unloading even with\n-  \/\/ concurrent cycles.\n-  if (ClassUnloading) {\n-    SHENANDOAH_ERGO_OVERRIDE_DEFAULT(ShenandoahUnloadClassesFrequency, 1);\n-  }\n@@ -67,1 +61,1 @@\n-  if (!can_unload_classes_normal()) return false;\n+  if (!can_unload_classes()) return false;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAggressiveHeuristics.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,5 +57,0 @@\n-  \/\/ No unloading during concurrent mark? Communicate that to heuristics\n-  if (!ClassUnloadingWithConcurrentMark) {\n-    FLAG_SET_DEFAULT(ShenandoahUnloadClassesFrequency, 0);\n-  }\n-\n@@ -261,8 +256,0 @@\n-bool ShenandoahHeuristics::can_unload_classes_normal() {\n-  if (!can_unload_classes()) return false;\n-  if (has_metaspace_oom()) return true;\n-  if (!ClassUnloadingWithConcurrentMark) return false;\n-  if (ShenandoahUnloadClassesFrequency == 0) return false;\n-  return true;\n-}\n-\n@@ -270,1 +257,1 @@\n-  if (!can_unload_classes_normal()) return false;\n+  if (!can_unload_classes()) return false;\n@@ -272,6 +259,1 @@\n-  size_t cycle = ShenandoahHeap::heap()->shenandoah_policy()->cycle_counter();\n-  \/\/ Unload classes every Nth GC cycle.\n-  \/\/ This should not happen in the same cycle as process_references to amortize costs.\n-  \/\/ Offsetting by one is enough to break the rendezvous when periods are equal.\n-  \/\/ When periods are not equal, offsetting by one is just as good as any other guess.\n-  return (cycle + 1) % ShenandoahUnloadClassesFrequency == 0;\n+  return ClassUnloadingWithConcurrentMark;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -157,1 +157,0 @@\n-  virtual bool can_unload_classes_normal();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-  if (ShenandoahSelfFixing && load_addr != nullptr && fwd != obj) {\n+  if (load_addr != nullptr && fwd != obj) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,5 +171,0 @@\n-  product(uintx, ShenandoahUnloadClassesFrequency, 1, EXPERIMENTAL,         \\\n-          \"Unload the classes every Nth cycle. Normally affects concurrent \"\\\n-          \"GC cycles, as degenerated and full GCs would try to unload \"     \\\n-          \"classes regardless. Set to zero to disable class unloading.\")    \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -229,0 +230,1 @@\n+  AARCH64_ONLY(fatal(\"Should use ZLoadBarrierStubC2Aarch64::create\"));\n@@ -278,0 +280,1 @@\n+  AARCH64_ONLY(fatal(\"Should use ZStoreBarrierStubC2Aarch64::create\"));\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-public:\n@@ -58,0 +57,1 @@\n+public:\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -784,6 +784,0 @@\n-\/*\n- * java.util.concurrent.atomic.AtomicLong\n- *\/\n-JNIEXPORT jboolean JNICALL\n-JVM_SupportsCX8(void);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -463,0 +463,1 @@\n+\/\/ Note that the implementation of this method assumes it's only called when an exception has actually occured\n@@ -577,0 +578,1 @@\n+    h_method->set_exception_handler_entered(handler_bci); \/\/ profiling\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -247,0 +247,1 @@\n+  case Bytecodes::_fast_invokevfinal:\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -528,0 +528,27 @@\n+static Symbol** allocate_symbol_array(bool c_heap, int length, Thread* thread) {\n+  return c_heap ?\n+           NEW_C_HEAP_ARRAY(Symbol*, length, mtTracing) :\n+           NEW_RESOURCE_ARRAY_IN_THREAD(thread, Symbol*, length);\n+}\n+\n+Symbol** JfrJavaSupport::symbol_array(jobjectArray string_array, JavaThread* thread, intptr_t* result_array_size, bool c_heap \/* false *\/) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(thread));\n+  assert(string_array != nullptr, \"invariant\");\n+  assert(result_array_size != nullptr, \"invariant\");\n+  objArrayOop arrayOop = objArrayOop(resolve_non_null(string_array));\n+  const int length = arrayOop->length();\n+  *result_array_size = length;\n+  Symbol** result_array = allocate_symbol_array(c_heap, length, thread);\n+  assert(result_array != nullptr, \"invariant\");\n+  for (int i = 0; i < length; i++) {\n+    oop object = arrayOop->obj_at(i);\n+    Symbol* symbol = nullptr;\n+    if (object != nullptr) {\n+      const char* text = c_str(arrayOop->obj_at(i), thread, c_heap);\n+      symbol = SymbolTable::new_symbol(text);\n+    }\n+    result_array[i] = symbol;\n+  }\n+  return result_array;\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+  static Symbol** symbol_array(jobjectArray string_array, JavaThread* thread, intptr_t* result_size, bool c_heap = false);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+#include \"jfr\/recorder\/stacktrace\/jfrStackFilter.hpp\"\n+#include \"jfr\/recorder\/stacktrace\/jfrStackFilterRegistry.hpp\"\n@@ -242,2 +244,2 @@\n-JVM_ENTRY_NO_ENV(jlong, jfr_stacktrace_id(JNIEnv* env, jclass jvm, jint skip))\n-  return JfrStackTraceRepository::record(thread, skip);\n+JVM_ENTRY_NO_ENV(jlong, jfr_stacktrace_id(JNIEnv* env, jclass jvm, jint skip, jlong stack_filter_id))\n+  return JfrStackTraceRepository::record(thread, skip, stack_filter_id);\n@@ -400,0 +402,8 @@\n+\n+JVM_ENTRY_NO_ENV(jlong, jfr_register_stack_filter(JNIEnv* env,  jclass jvm, jobjectArray classes, jobjectArray methods))\n+  return JfrStackFilterRegistry::add(classes, methods, thread);\n+JVM_END\n+\n+JVM_ENTRY_NO_ENV(void, jfr_unregister_stack_filter(JNIEnv* env,  jclass jvm, jlong id))\n+  JfrStackFilterRegistry::remove(id);\n+JVM_END\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-jlong JNICALL jfr_stacktrace_id(JNIEnv* env, jclass jvm, jint skip);\n+jlong JNICALL jfr_stacktrace_id(JNIEnv* env, jclass jvm, jint skip, jlong stack_filter_id);\n@@ -162,0 +162,4 @@\n+jlong JNICALL jfr_register_stack_filter(JNIEnv* env, jobject classes, jobject methods);\n+\n+jlong JNICALL jfr_unregister_stack_filter(JNIEnv* env, jlong start_filter_id);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-      (char*)\"getStackTraceId\", (char*)\"(I)J\", (void*)jfr_stacktrace_id,\n+      (char*)\"getStackTraceId\", (char*)\"(IJ)J\", (void*)jfr_stacktrace_id,\n@@ -100,1 +100,3 @@\n-      (char*)\"emitDataLoss\", (char*)\"(J)V\", (void*)jfr_emit_data_loss\n+      (char*)\"emitDataLoss\", (char*)\"(J)V\", (void*)jfr_emit_data_loss,\n+      (char*)\"registerStackFilter\", (char*)\"([Ljava\/lang\/String;[Ljava\/lang\/String;)J\", (void*)jfr_register_stack_filter,\n+      (char*)\"unregisterStackFilter\", (char*)\"(J)V\", (void*)jfr_unregister_stack_filter\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"runtime\/vm_version.hpp\"\n@@ -43,1 +42,0 @@\n-  assert(VM_Version::supports_cx8(), \"invariant\");\n@@ -297,1 +295,0 @@\n-\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/recorder\/stacktrace\/jfrStackFilter.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"oops\/symbol.hpp\"\n+\n+JfrStackFilter::JfrStackFilter(Symbol** class_names, Symbol** method_names, size_t count)\n+  : _count(count),\n+    _class_names(class_names),\n+    _method_names(method_names) {\n+  assert(_class_names != nullptr, \"invariant\");\n+  assert(_method_names != nullptr, \"invariant\");\n+}\n+\n+bool JfrStackFilter::match(const Method* method) const {\n+  assert(method != nullptr, \"Invariant\");\n+  const Symbol* const method_name = method->name();\n+  const Symbol* const klass_name = method->klass_name();\n+  for (size_t i = 0; i < _count; i++) {\n+    const Symbol* m = _method_names[i];\n+    if (m == nullptr || m == method_name) {\n+      const Symbol* c = _class_names[i];\n+      if (c == nullptr || c == klass_name) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+JfrStackFilter::~JfrStackFilter() {\n+  for (size_t i = 0; i < _count; i++) {\n+    Symbol::maybe_decrement_refcount(_method_names[i]);\n+    Symbol::maybe_decrement_refcount(_class_names[i]);\n+  }\n+  FREE_C_HEAP_ARRAY(Symbol*, _method_names);\n+  FREE_C_HEAP_ARRAY(Symbol*, _class_names);\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackFilter.cpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_RECORDER_STACKTRACE_JFRSTACKFILTER_HPP\n+#define SHARE_JFR_RECORDER_STACKTRACE_JFRSTACKFILTER_HPP\n+\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+\n+class Mathod;\n+class Symbol;\n+\n+class JfrStackFilter : public JfrCHeapObj {\n+ private:\n+  size_t _count;\n+  Symbol** _class_names;\n+  Symbol** _method_names;\n+\n+ public:\n+  JfrStackFilter(Symbol** class_names, Symbol** method_names, size_t count);\n+  ~JfrStackFilter();\n+  bool match(const Method* method) const;\n+};\n+\n+#endif \/\/ SHARE_JFR_RECORDER_STACKTRACE_JFRSTACKFILTER_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackFilter.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n+#include \"jfr\/recorder\/stacktrace\/jfrStackFilter.hpp\"\n+#include \"jfr\/recorder\/stacktrace\/jfrStackFilterRegistry.hpp\"\n+#include \"logging\/log.hpp\"\n+\n+static const intptr_t STACK_FILTER_ELEMENTS_SIZE = 4096;\n+static const intptr_t STACK_FILTER_ERROR_CODE = -1;\n+static const JfrStackFilter* _elements[STACK_FILTER_ELEMENTS_SIZE];\n+static intptr_t _free_list[STACK_FILTER_ELEMENTS_SIZE];\n+static intptr_t _index = 0;\n+static intptr_t _free_list_index = 0;\n+\n+int64_t JfrStackFilterRegistry::add(jobjectArray classes, jobjectArray methods, JavaThread* jt) {\n+  intptr_t c_size = 0;\n+  Symbol** class_names = JfrJavaSupport::symbol_array(classes, jt, &c_size, true);\n+  assert(class_names != nullptr, \"invariant\");\n+  intptr_t m_size = 0;\n+  Symbol** method_names = JfrJavaSupport::symbol_array(methods, jt, &m_size, true);\n+  assert(method_names != nullptr, \"invariant\");\n+  if (c_size != m_size) {\n+    FREE_C_HEAP_ARRAY(Symbol*, class_names);\n+    FREE_C_HEAP_ARRAY(Symbol*, method_names);\n+    JfrJavaSupport::throw_internal_error(\"Method array size doesn't match class array size\", jt);\n+    return STACK_FILTER_ERROR_CODE;\n+  }\n+  assert(c_size >= 0, \"invariant\");\n+  const JfrStackFilter* filter = new JfrStackFilter(class_names, method_names, static_cast<size_t>(c_size));\n+  return JfrStackFilterRegistry::add(filter);\n+}\n+\n+#ifdef ASSERT\n+static bool range_check(int64_t idx) {\n+  return idx < STACK_FILTER_ELEMENTS_SIZE && idx >= 0;\n+}\n+#endif\n+\n+int64_t JfrStackFilterRegistry::add(const JfrStackFilter* filter) {\n+  if (_free_list_index > 0) {\n+    assert(range_check(_free_list_index), \"invariant\");\n+    const intptr_t free_index = _free_list[_free_list_index - 1];\n+    _elements[free_index] = filter;\n+    _free_list_index--;\n+    return free_index;\n+  }\n+  if (_index >= STACK_FILTER_ELEMENTS_SIZE - 1) {\n+    log_warning(jfr)(\"Maximum number of @StackFrame in use has been reached.\");\n+    return STACK_FILTER_ERROR_CODE;\n+  }\n+  assert(range_check(_index), \"invariant\");\n+  _elements[_index] = filter;\n+  return _index++;\n+}\n+\n+const JfrStackFilter* JfrStackFilterRegistry::lookup(int64_t id) {\n+  if (id < 0) {\n+    return nullptr;\n+  }\n+  assert(range_check(id), \"invariant\");\n+  return _elements[id];\n+}\n+\n+void JfrStackFilterRegistry::remove(int64_t index) {\n+  assert(range_check(index), \"invariant\");\n+  delete _elements[index];\n+  if (_free_list_index < STACK_FILTER_ELEMENTS_SIZE - 1) {\n+    assert(range_check(_free_list_index), \"invariant\");\n+    _free_list[_free_list_index++] = index;\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackFilterRegistry.cpp","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_RECORDER_STACKTRACE_JFRSTCKFILTERREGISTRY_HPP\n+#define SHARE_JFR_RECORDER_STACKTRACE_JFRSTCKFILTERREGISTRY_HPP\n+\n+#include \"jni.h\"\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+\n+class JavaThread;\n+class JfrStackFilter;\n+\n+class JfrStackFilterRegistry : AllStatic {\n+ private:\n+  static int64_t add(const JfrStackFilter* frame);\n+ public:\n+  static int64_t add(jobjectArray classes, jobjectArray methods, JavaThread* jt);\n+  static void remove(int64_t id);\n+  static const JfrStackFilter* lookup(int64_t id);\n+};\n+\n+#endif \/\/ SHARE_JFR_RECORDER_STACKTRACE_JFRSTCKFILTERREGISTRY_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackFilterRegistry.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -33,0 +33,2 @@\n+#include \"jfrStackFilter.hpp\"\n+#include \"jfrStackFilterRegistry.hpp\"\n@@ -287,1 +289,1 @@\n-bool JfrStackTrace::record(JavaThread* jt, const frame& frame, int skip) {\n+bool JfrStackTrace::record(JavaThread* jt, const frame& frame, int skip, int64_t stack_filter_id) {\n@@ -305,0 +307,1 @@\n+  const JfrStackFilter* stack_filter = JfrStackFilterRegistry::lookup(stack_filter_id);\n@@ -312,0 +315,6 @@\n+    if (stack_filter != nullptr) {\n+      if (stack_filter->match(method)) {\n+        vfs.next_vframe();\n+        continue;\n+      }\n+    }\n@@ -338,1 +347,1 @@\n-bool JfrStackTrace::record(JavaThread* current_thread, int skip) {\n+bool JfrStackTrace::record(JavaThread* current_thread, int skip, int64_t stack_filter_id) {\n@@ -344,1 +353,1 @@\n-  return record(current_thread, current_thread->last_frame(), skip);\n+  return record(current_thread, current_thread->last_frame(), skip, stack_filter_id);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -96,2 +96,2 @@\n-  bool record(JavaThread* current_thread, int skip);\n-  bool record(JavaThread* current_thread, const frame& frame, int skip);\n+  bool record(JavaThread* current_thread, int skip, int64_t stack_frame_id);\n+  bool record(JavaThread* current_thread, const frame& frame, int skip, int64_t stack_frame_id);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-traceid JfrStackTraceRepository::record(Thread* current_thread, int skip \/* 0 *\/) {\n+traceid JfrStackTraceRepository::record(Thread* current_thread, int skip \/* 0 *\/, int64_t stack_filter_id \/* -1 *\/) {\n@@ -166,1 +166,1 @@\n-  return instance().record(JavaThread::cast(current_thread), skip, frames, tl->stackdepth());\n+  return instance().record(JavaThread::cast(current_thread), skip, stack_filter_id, frames, tl->stackdepth());\n@@ -169,1 +169,1 @@\n-traceid JfrStackTraceRepository::record(JavaThread* current_thread, int skip, JfrStackFrame *frames, u4 max_frames) {\n+traceid JfrStackTraceRepository::record(JavaThread* current_thread, int skip, int64_t stack_filter_id, JfrStackFrame *frames, u4 max_frames) {\n@@ -171,1 +171,1 @@\n-  return stacktrace.record(current_thread, skip) ? add(instance(), stacktrace) : 0;\n+  return stacktrace.record(current_thread, skip, stack_filter_id) ? add(instance(), stacktrace) : 0;\n@@ -173,0 +173,1 @@\n+\n@@ -194,1 +195,1 @@\n-  stacktrace.record(current_thread, skip);\n+  stacktrace.record(current_thread, skip, -1);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  traceid record(JavaThread* current_thread, int skip, JfrStackFrame* frames, u4 max_frames);\n+  traceid record(JavaThread* current_thread, int skip, int64_t stack_filter_id, JfrStackFrame* frames, u4 max_frames);\n@@ -73,1 +73,1 @@\n-  static traceid record(Thread* current_thread, int skip = 0);\n+  static traceid record(Thread* current_thread, int skip = 0, int64_t stack_filter_id = -1);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/vm_version.hpp\"\n@@ -39,1 +38,0 @@\n-  assert(VM_Version::supports_cx8(), \"unsupported\");\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrAllocation.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-\/\/ this utility could be useful for non cx8 platforms\n-\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSpinlockHelper.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-    JVMCI_event_1(\"[%s:%d] Error pushing local JNI frame (err: %d)\", _file, _line, _init_error);\n+    JVMCI_event_1(\"[%s:%d] Error pushing local JNI frame (err: %d)\", _file, _line, result);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n@@ -581,2 +582,1 @@\n-ReservedSpace Metaspace::reserve_address_space_for_compressed_classes(size_t size, bool try_in_low_address_ranges) {\n-\n+ReservedSpace Metaspace::reserve_address_space_for_compressed_classes(size_t size, bool optimize_for_zero_base) {\n@@ -584,15 +584,0 @@\n-  const bool randomize = RandomizeClassSpaceLocation;\n-\n-  \/\/ First try to reserve in low address ranges.\n-  if (try_in_low_address_ranges) {\n-    constexpr uintptr_t unscaled_max = ((uintptr_t)UINT_MAX + 1);\n-    log_debug(metaspace, map)(\"Trying below \" SIZE_FORMAT_X \" for unscaled narrow Klass encoding\", unscaled_max);\n-    result = os::attempt_reserve_memory_between(nullptr, (char*)unscaled_max,\n-                                                size, Metaspace::reserve_alignment(), randomize);\n-    if (result == nullptr) {\n-      constexpr uintptr_t zerobased_max = unscaled_max << LogKlassAlignmentInBytes;\n-      log_debug(metaspace, map)(\"Trying below \" SIZE_FORMAT_X \" for zero-based narrow Klass encoding\", zerobased_max);\n-      result = os::attempt_reserve_memory_between((char*)unscaled_max, (char*)zerobased_max,\n-                                                  size, Metaspace::reserve_alignment(), randomize);\n-    }\n-  } \/\/ end: low-address reservation\n@@ -600,26 +585,3 @@\n-#if defined(AARCH64) || defined(PPC64) || defined(S390)\n-  if (result == nullptr) {\n-    \/\/ Failing zero-based allocation, or in strict_base mode, try to come up with\n-    \/\/ an optimized start address that is amenable to JITs that use 16-bit moves to\n-    \/\/ load the encoding base as a short immediate.\n-    \/\/ Therefore we try here for an address that when right-shifted by\n-    \/\/ LogKlassAlignmentInBytes has only 1s in the third 16-bit quadrant.\n-    \/\/\n-    \/\/ Example: for shift=3, the address space searched would be\n-    \/\/ [0x0080_0000_0000 - 0xFFF8_0000_0000].\n-\n-    \/\/ Number of least significant bits that should be zero\n-    constexpr int lo_zero_bits = 32 + LogKlassAlignmentInBytes;\n-    \/\/ Number of most significant bits that should be zero\n-    constexpr int hi_zero_bits = 16;\n-\n-    constexpr size_t alignment = nth_bit(lo_zero_bits);\n-    assert(alignment >= Metaspace::reserve_alignment(), \"Sanity\");\n-    constexpr uint64_t min = alignment;\n-    constexpr uint64_t max = nth_bit(64 - hi_zero_bits);\n-\n-    log_debug(metaspace, map)(\"Trying between \" UINT64_FORMAT_X \" and \" UINT64_FORMAT_X\n-                              \" with \" SIZE_FORMAT_X \" alignment\", min, max, alignment);\n-    result = os::attempt_reserve_memory_between((char*)min, (char*)max, size, alignment, randomize);\n-  }\n-#endif \/\/ defined(AARCH64) || defined(PPC64) || defined(S390)\n+  NOT_ZERO(result =\n+      (char*) CompressedKlassPointers::reserve_address_space_for_compressed_classes(size, RandomizeClassSpaceLocation,\n+                                                                                    optimize_for_zero_base));\n@@ -628,1 +590,1 @@\n-    \/\/ Fallback: reserve anywhere and hope the resulting block is usable.\n+    \/\/ Fallback: reserve anywhere\n@@ -636,0 +598,1 @@\n+    log_debug(metaspace, map)(\"Mapped at \" PTR_FORMAT, p2i(result));\n@@ -640,0 +603,1 @@\n+    log_debug(metaspace, map)(\"Failed to map.\");\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":8,"deletions":44,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  static ReservedSpace reserve_address_space_for_compressed_classes(size_t size, bool try_in_low_address_ranges);\n+  static ReservedSpace reserve_address_space_for_compressed_classes(size_t size, bool optimize_for_zero_base);\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    output()->print(\", largest_committed=\" SIZE_FORMAT \"%s\", amount_in_current_scale(peak), scale);\n+    output()->print(\", peak=\" SIZE_FORMAT \"%s\", amount_in_current_scale(peak), scale);\n@@ -96,0 +96,1 @@\n+  outputStream* out = output();\n@@ -97,2 +98,7 @@\n-  output()->print(\"(mmap: reserved=\" SIZE_FORMAT \"%s, committed=\" SIZE_FORMAT \"%s, largest_committed=\" SIZE_FORMAT \"%s)\",\n-    amount_in_current_scale(reserved), scale, amount_in_current_scale(committed), scale, amount_in_current_scale(peak), scale);\n+  out->print(\"(mmap: reserved=\" SIZE_FORMAT \"%s, committed=\" SIZE_FORMAT \"%s, \",\n+    amount_in_current_scale(reserved), scale, amount_in_current_scale(committed), scale);\n+  if (peak == committed) {\n+    out->print_raw(\"at peak)\");\n+  } else {\n+    out->print(\"peak=\" SIZE_FORMAT \"%s)\", amount_in_current_scale(peak), scale);\n+  }\n@@ -207,5 +213,14 @@\n-  if (amount_in_current_scale(reserved_amount) > 0) {\n-    outputStream* out   = output();\n-    const char*   scale = current_scale();\n-    out->print(\"-%26s (\", NMTUtil::flag_to_name(flag));\n-    print_total(reserved_amount, committed_amount);\n+  \/\/ Omit printing if the current reserved value as well as all historical peaks (malloc, mmap committed, arena)\n+  \/\/ fall below scale threshold\n+  const size_t pk_vm = virtual_memory->peak_size();\n+  const size_t pk_malloc = malloc_memory->malloc_peak_size();\n+  const size_t pk_arena = malloc_memory->arena_peak_size();\n+\n+  if (amount_in_current_scale(MAX4(reserved_amount, pk_vm, pk_malloc, pk_arena)) == 0) {\n+    return;\n+  }\n+\n+  outputStream* out   = output();\n+  const char*   scale = current_scale();\n+  out->print(\"-%26s (\", NMTUtil::flag_to_name(flag));\n+  print_total(reserved_amount, committed_amount);\n@@ -213,5 +228,5 @@\n-    if (flag == mtClassShared) {\n-        size_t read_only_bytes = FileMapInfo::readonly_total();\n-      output()->print(\", readonly=\" SIZE_FORMAT \"%s\",\n-                      amount_in_current_scale(read_only_bytes), scale);\n-    }\n+  if (flag == mtClassShared) {\n+      size_t read_only_bytes = FileMapInfo::readonly_total();\n+    output()->print(\", readonly=\" SIZE_FORMAT \"%s\",\n+                    amount_in_current_scale(read_only_bytes), scale);\n+  }\n@@ -219,1 +234,1 @@\n-    out->print_cr(\")\");\n+  out->print_cr(\")\");\n@@ -221,23 +236,21 @@\n-    if (flag == mtClass) {\n-      \/\/ report class count\n-      out->print_cr(\"%27s (classes #\" SIZE_FORMAT \")\",\n-        \" \", (_instance_class_count + _array_class_count));\n-      out->print_cr(\"%27s (  instance classes #\" SIZE_FORMAT \", array classes #\" SIZE_FORMAT \")\",\n-        \" \", _instance_class_count, _array_class_count);\n-    } else if (flag == mtThread) {\n-      if (ThreadStackTracker::track_as_vm()) {\n-        const VirtualMemory* thread_stack_usage =\n-         _vm_snapshot->by_type(mtThreadStack);\n-        \/\/ report thread count\n-        out->print_cr(\"%27s (threads #\" SIZE_FORMAT \")\", \" \", ThreadStackTracker::thread_count());\n-        out->print(\"%27s (stack: \", \" \");\n-        print_total(thread_stack_usage->reserved(), thread_stack_usage->committed(), thread_stack_usage->peak_size());\n-      } else {\n-        MallocMemory* thread_stack_memory = _malloc_snapshot->by_type(mtThreadStack);\n-        const char* scale = current_scale();\n-        \/\/ report thread count\n-        out->print_cr(\"%27s (threads #\" SIZE_FORMAT \")\", \" \", thread_stack_memory->malloc_count());\n-        out->print(\"%27s (Stack: \" SIZE_FORMAT \"%s\", \" \",\n-          amount_in_current_scale(thread_stack_memory->malloc_size()), scale);\n-      }\n-      out->print_cr(\")\");\n+  if (flag == mtClass) {\n+    \/\/ report class count\n+    out->print_cr(\"%27s (classes #\" SIZE_FORMAT \")\",\n+      \" \", (_instance_class_count + _array_class_count));\n+    out->print_cr(\"%27s (  instance classes #\" SIZE_FORMAT \", array classes #\" SIZE_FORMAT \")\",\n+      \" \", _instance_class_count, _array_class_count);\n+  } else if (flag == mtThread) {\n+    if (ThreadStackTracker::track_as_vm()) {\n+      const VirtualMemory* thread_stack_usage =\n+       _vm_snapshot->by_type(mtThreadStack);\n+      \/\/ report thread count\n+      out->print_cr(\"%27s (threads #\" SIZE_FORMAT \")\", \" \", ThreadStackTracker::thread_count());\n+      out->print(\"%27s (stack: \", \" \");\n+      print_total(thread_stack_usage->reserved(), thread_stack_usage->committed(), thread_stack_usage->peak_size());\n+    } else {\n+      MallocMemory* thread_stack_memory = _malloc_snapshot->by_type(mtThreadStack);\n+      const char* scale = current_scale();\n+      \/\/ report thread count\n+      out->print_cr(\"%27s (threads #\" SIZE_FORMAT \")\", \" \", thread_stack_memory->malloc_count());\n+      out->print(\"%27s (Stack: \" SIZE_FORMAT \"%s\", \" \",\n+        amount_in_current_scale(thread_stack_memory->malloc_size()), scale);\n@@ -245,0 +258,2 @@\n+    out->print_cr(\")\");\n+  }\n@@ -246,5 +261,4 @@\n-     \/\/ report malloc'd memory\n-    if (amount_in_current_scale(malloc_memory->malloc_size()) > 0\n-        || amount_in_current_scale(malloc_memory->malloc_peak_size()) > 0) {\n-      print_malloc_line(malloc_memory->malloc_counter());\n-    }\n+   \/\/ report malloc'd memory\n+  if (amount_in_current_scale(MAX2(malloc_memory->malloc_size(), pk_malloc)) > 0) {\n+    print_malloc_line(malloc_memory->malloc_counter());\n+  }\n@@ -252,4 +266,3 @@\n-    if (amount_in_current_scale(virtual_memory->reserved()) > 0\n-        DEBUG_ONLY(|| amount_in_current_scale(virtual_memory->peak_size()) > 0)) {\n-      print_virtual_memory_line(virtual_memory->reserved(), virtual_memory->committed(), virtual_memory->peak_size());\n-    }\n+  if (amount_in_current_scale(MAX2(virtual_memory->reserved(), pk_vm)) > 0) {\n+    print_virtual_memory_line(virtual_memory->reserved(), virtual_memory->committed(), virtual_memory->peak_size());\n+  }\n@@ -257,4 +270,3 @@\n-    if (amount_in_current_scale(malloc_memory->arena_size()) > 0\n-        DEBUG_ONLY(|| amount_in_current_scale(malloc_memory->arena_peak_size()) > 0)) {\n-      print_arena_line(malloc_memory->arena_counter());\n-    }\n+  if (amount_in_current_scale(MAX2(malloc_memory->arena_size(), pk_arena)) > 0) {\n+    print_arena_line(malloc_memory->arena_counter());\n+  }\n@@ -262,10 +274,9 @@\n-    if (flag == mtNMT &&\n-      amount_in_current_scale(_malloc_snapshot->malloc_overhead()) > 0) {\n-      out->print_cr(\"%27s (tracking overhead=\" SIZE_FORMAT \"%s)\", \" \",\n-        amount_in_current_scale(_malloc_snapshot->malloc_overhead()), scale);\n-    } else if (flag == mtClass) {\n-      \/\/ Metadata information\n-      report_metadata(Metaspace::NonClassType);\n-      if (Metaspace::using_class_space()) {\n-        report_metadata(Metaspace::ClassType);\n-      }\n+  if (flag == mtNMT &&\n+    amount_in_current_scale(_malloc_snapshot->malloc_overhead()) > 0) {\n+    out->print_cr(\"%27s (tracking overhead=\" SIZE_FORMAT \"%s)\", \" \",\n+      amount_in_current_scale(_malloc_snapshot->malloc_overhead()), scale);\n+  } else if (flag == mtClass) {\n+    \/\/ Metadata information\n+    report_metadata(Metaspace::NonClassType);\n+    if (Metaspace::using_class_space()) {\n+      report_metadata(Metaspace::ClassType);\n@@ -273,1 +284,0 @@\n-    out->print_cr(\" \");\n@@ -275,0 +285,1 @@\n+  out->print_cr(\" \");\n@@ -324,3 +335,2 @@\n-    \/\/ Don't report if site has never allocated less than one unit of whatever our scale is\n-    if (scale() > 1 && amount_in_current_scale(malloc_site->size()) == 0\n-                       DEBUG_ONLY(&& amount_in_current_scale(malloc_site->peak_size()) == 0)) {\n+    \/\/ Omit printing if the current value and the historic peak value both fall below the reporting scale threshold\n+    if (amount_in_current_scale(MAX2(malloc_site->size(), malloc_site->peak_size())) == 0) {\n@@ -356,2 +366,4 @@\n-    \/\/ Don't report if site has reserved less than one unit of whatever our scale is\n-    if (scale() > 1 && amount_in_current_scale(virtual_memory_site->reserved()) == 0) {\n+    \/\/ Omit printing if the current value and the historic peak value both fall below the\n+    \/\/ reporting scale threshold\n+    if (amount_in_current_scale(MAX2(virtual_memory_site->reserved(),\n+                                     virtual_memory_site->peak_size())) == 0) {\n@@ -389,1 +401,10 @@\n-  \/\/ Don't report if size is too small\n+  \/\/ We don't bother about reporting peaks here.\n+  \/\/ That is because peaks - in the context of virtual memory, peak of committed areas - make little sense\n+  \/\/ when we report *by region*, which are identified by their location in memory. There is a philosophical\n+  \/\/ question about identity here: e.g. a committed region that has been split into three regions by\n+  \/\/ uncommitting a middle section of it, should that still count as \"having peaked\" before the split? If\n+  \/\/ yes, which of the three new regions would be the spiritual successor? Rather than introducing more\n+  \/\/ complexity, we avoid printing peaks altogether. Note that peaks should still be printed when reporting\n+  \/\/ usage *by callsite*.\n+\n+  \/\/ Don't report if size is too small.\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":88,"deletions":67,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#ifdef ASSERT\n@@ -49,1 +48,0 @@\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#ifdef ASSERT\n@@ -48,1 +47,0 @@\n-#endif \/\/ ASSERT\n@@ -51,3 +49,1 @@\n-  VirtualMemory() : _reserved(0), _committed(0) {\n-    DEBUG_ONLY(_peak_size  = 0;)\n-  }\n+  VirtualMemory() : _reserved(0), _committed(0), _peak_size(0) {}\n@@ -58,1 +54,0 @@\n-    DEBUG_ONLY(update_peak(sz);)\n@@ -60,0 +55,1 @@\n+    update_peak(_committed);\n@@ -75,1 +71,1 @@\n-    return DEBUG_ONLY(Atomic::load(&_peak_size)) NOT_DEBUG(0);\n+    return Atomic::load(&_peak_size);\n@@ -88,2 +84,0 @@\n-  inline void uncommit_memory(size_t sz) { _c.uncommit_memory(sz); }\n-  inline void release_memory(size_t sz)  { _c.release_memory(sz);  }\n@@ -92,0 +86,1 @@\n+  inline size_t peak_size() const { return _c.peak_size(); }\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/vm_version.hpp\"\n@@ -37,48 +36,0 @@\n-  \/\/ VM_Version::supports_cx8() is a surrogate for 'supports atomic long memory ops'.\n-  \/\/\n-  \/\/ On platforms which do not support atomic compare-and-swap of jlong (8 byte)\n-  \/\/ values we have to use a lock-based scheme to enforce atomicity. This has to be\n-  \/\/ applied to all Unsafe operations that set the value of a jlong field. Even so\n-  \/\/ the compareAndSwapLong operation will not be atomic with respect to direct stores\n-  \/\/ to the field from Java code. It is important therefore that any Java code that\n-  \/\/ utilizes these Unsafe jlong operations does not perform direct stores. To permit\n-  \/\/ direct loads of the field from Java code we must also use Atomic::store within the\n-  \/\/ locked regions. And for good measure, in case there are direct stores, we also\n-  \/\/ employ Atomic::load within those regions. Note that the field in question must be\n-  \/\/ volatile and so must have atomic load\/store accesses applied at the Java level.\n-  \/\/\n-  \/\/ The locking scheme could utilize a range of strategies for controlling the locking\n-  \/\/ granularity: from a lock per-field through to a single global lock. The latter is\n-  \/\/ the simplest and is used for the current implementation. Note that the Java object\n-  \/\/ that contains the field, can not, in general, be used for locking. To do so can lead\n-  \/\/ to deadlocks as we may introduce locking into what appears to the Java code to be a\n-  \/\/ lock-free path.\n-  \/\/\n-  \/\/ As all the locked-regions are very short and themselves non-blocking we can treat\n-  \/\/ them as leaf routines and elide safepoint checks (ie we don't perform any thread\n-  \/\/ state transitions even when blocking for the lock). Note that if we do choose to\n-  \/\/ add safepoint checks and thread state transitions, we must ensure that we calculate\n-  \/\/ the address of the field _after_ we have acquired the lock, else the object may have\n-  \/\/ been moved by the GC\n-\n-#ifndef SUPPORTS_NATIVE_CX8\n-\n-  \/\/ This is intentionally in the cpp file rather than the .inline.hpp file. It seems\n-  \/\/ desirable to trade faster JDK build times (not propagating vm_version.hpp)\n-  \/\/ for slightly worse runtime atomic jlong performance on 32 bit machines with\n-  \/\/ support for 64 bit atomics.\n-  bool wide_atomic_needs_locking() {\n-    return !VM_Version::supports_cx8();\n-  }\n-\n-  AccessLocker::AccessLocker() {\n-    assert(!VM_Version::supports_cx8(), \"why else?\");\n-    UnsafeJlong_lock->lock_without_safepoint_check();\n-  }\n-\n-  AccessLocker::~AccessLocker() {\n-    UnsafeJlong_lock->unlock();\n-  }\n-\n-#endif\n-\n","filename":"src\/hotspot\/share\/oops\/accessBackend.cpp","additions":0,"deletions":49,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -84,9 +84,0 @@\n-  \/\/ This metafunction returns whether it is possible for a type T to require\n-  \/\/ locking to support wide atomics or not.\n-  template <typename T>\n-#ifdef SUPPORTS_NATIVE_CX8\n-  struct PossiblyLockedAccess: public std::false_type {};\n-#else\n-  struct PossiblyLockedAccess: public std::integral_constant<bool, (sizeof(T) > 4)> {};\n-#endif\n-\n@@ -143,7 +134,0 @@\n-  class AccessLocker {\n-  public:\n-    AccessLocker();\n-    ~AccessLocker();\n-  };\n-  bool wide_atomic_needs_locking();\n-\n@@ -284,28 +268,0 @@\n-  \/\/ The following *_locked mechanisms serve the purpose of handling atomic operations\n-  \/\/ that are larger than a machine can handle, and then possibly opt for using\n-  \/\/ a slower path using a mutex to perform the operation.\n-\n-  template <DecoratorSet ds, typename T>\n-  static inline typename EnableIf<\n-    !AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-  atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value) {\n-    return atomic_cmpxchg_internal<ds>(addr, compare_value, new_value);\n-  }\n-\n-  template <DecoratorSet ds, typename T>\n-  static typename EnableIf<\n-    AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-  atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value);\n-\n-  template <DecoratorSet ds, typename T>\n-  static inline typename EnableIf<\n-    !AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-  atomic_xchg_maybe_locked(void* addr, T new_value) {\n-    return atomic_xchg_internal<ds>(addr, new_value);\n-  }\n-\n-  template <DecoratorSet ds, typename T>\n-  static typename EnableIf<\n-    AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-  atomic_xchg_maybe_locked(void* addr, T new_value);\n-\n@@ -325,1 +281,1 @@\n-    return atomic_cmpxchg_maybe_locked<decorators>(addr, compare_value, new_value);\n+    return atomic_cmpxchg_internal<decorators>(addr, compare_value, new_value);\n@@ -330,1 +286,1 @@\n-    return atomic_xchg_maybe_locked<decorators>(addr, new_value);\n+    return atomic_xchg_internal<decorators>(addr, new_value);\n","filename":"src\/hotspot\/share\/oops\/accessBackend.hpp","additions":2,"deletions":46,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -217,38 +217,0 @@\n-\/\/ For platforms that do not have native support for wide atomics,\n-\/\/ we can emulate the atomicity using a lock. So here we check\n-\/\/ whether that is necessary or not.\n-\n-template <DecoratorSet ds>\n-template <DecoratorSet decorators, typename T>\n-inline typename EnableIf<\n-  AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-RawAccessBarrier<ds>::atomic_xchg_maybe_locked(void* addr, T new_value) {\n-  if (!AccessInternal::wide_atomic_needs_locking()) {\n-    return atomic_xchg_internal<ds>(addr, new_value);\n-  } else {\n-    AccessInternal::AccessLocker access_lock;\n-    volatile T* p = reinterpret_cast<volatile T*>(addr);\n-    T old_val = RawAccess<>::load(p);\n-    RawAccess<>::store(p, new_value);\n-    return old_val;\n-  }\n-}\n-\n-template <DecoratorSet ds>\n-template <DecoratorSet decorators, typename T>\n-inline typename EnableIf<\n-  AccessInternal::PossiblyLockedAccess<T>::value, T>::type\n-RawAccessBarrier<ds>::atomic_cmpxchg_maybe_locked(void* addr, T compare_value, T new_value) {\n-  if (!AccessInternal::wide_atomic_needs_locking()) {\n-    return atomic_cmpxchg_internal<ds>(addr, compare_value, new_value);\n-  } else {\n-    AccessInternal::AccessLocker access_lock;\n-    volatile T* p = reinterpret_cast<volatile T*>(addr);\n-    T old_val = RawAccess<>::load(p);\n-    if (old_val == compare_value) {\n-      RawAccess<>::store(p, new_value);\n-    }\n-    return old_val;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/accessBackend.inline.hpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"memory\/metaspace.hpp\"\n@@ -28,0 +30,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -38,0 +41,7 @@\n+#ifdef ASSERT\n+void CompressedKlassPointers::assert_is_valid_encoding(address addr, size_t len, address base, int shift) {\n+  assert(base + nth_bit(32 + shift) >= addr + len, \"Encoding (base=\" PTR_FORMAT \", shift=%d) does not \"\n+         \"fully cover the class range \" PTR_FORMAT \"-\" PTR_FORMAT, p2i(base), shift, p2i(addr), p2i(addr + len));\n+}\n+#endif\n+\n@@ -42,1 +52,0 @@\n-  assert(is_valid_base(requested_base), \"Address must be a valid encoding base\");\n@@ -54,4 +63,3 @@\n-  set_base(requested_base);\n-  set_shift(requested_shift);\n-  set_range(encoding_range_size);\n-}\n+  _base = requested_base;\n+  _shift = requested_shift;\n+  _range = encoding_range_size;\n@@ -59,7 +67,2 @@\n-\/\/ Given an address range [addr, addr+len) which the encoding is supposed to\n-\/\/  cover, choose base, shift and range.\n-\/\/  The address range is the expected range of uncompressed Klass pointers we\n-\/\/  will encounter (and the implicit promise that there will be no Klass\n-\/\/  structures outside this range).\n-void CompressedKlassPointers::initialize(address addr, size_t len) {\n-  address const end = addr + len;\n+  DEBUG_ONLY(assert_is_valid_encoding(addr, len, _base, _shift);)\n+}\n@@ -67,3 +70,4 @@\n-  address base;\n-  int shift;\n-  size_t range;\n+char* CompressedKlassPointers::reserve_address_space_X(uintptr_t from, uintptr_t to, size_t size, size_t alignment, bool aslr) {\n+  alignment = MAX2(Metaspace::reserve_alignment(), alignment);\n+  return os::attempt_reserve_memory_between((char*)from, (char*)to, size, alignment, aslr);\n+}\n@@ -71,6 +75,3 @@\n-  \/\/ Attempt to run with encoding base == zero\n-  if (end <= (address)KlassEncodingMetaspaceMax) {\n-    base = 0;\n-  } else {\n-    base = addr;\n-  }\n+char* CompressedKlassPointers::reserve_address_space_for_unscaled_encoding(size_t size, bool aslr) {\n+  return reserve_address_space_X(0, nth_bit(32), size, Metaspace::reserve_alignment(), aslr);\n+}\n@@ -78,2 +79,3 @@\n-  \/\/ Highest offset a Klass* can ever have in relation to base.\n-  range = end - base;\n+char* CompressedKlassPointers::reserve_address_space_for_zerobased_encoding(size_t size, bool aslr) {\n+  return reserve_address_space_X(nth_bit(32), nth_bit(32 + LogKlassAlignmentInBytes), size, Metaspace::reserve_alignment(), aslr);\n+}\n@@ -81,7 +83,3 @@\n-  \/\/ We may not even need a shift if the range fits into 32bit:\n-  const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);\n-  if (range <= UnscaledClassSpaceMax) {\n-    shift = 0;\n-  } else {\n-    shift = LogKlassAlignmentInBytes;\n-  }\n+char* CompressedKlassPointers::reserve_address_space_for_16bit_move(size_t size, bool aslr) {\n+  return reserve_address_space_X(nth_bit(32), nth_bit(48), size, nth_bit(32), aslr);\n+}\n@@ -89,3 +87,11 @@\n-  set_base(base);\n-  set_shift(shift);\n-  set_range(range);\n+#ifndef AARCH64\n+\/\/ On aarch64 we have an own version; all other platforms use the default version\n+void CompressedKlassPointers::initialize(address addr, size_t len) {\n+  \/\/ The default version of this code tries, in order of preference:\n+  \/\/ -unscaled    (base=0 shift=0)\n+  \/\/ -zero-based  (base=0 shift>0)\n+  \/\/ -nonzero-base (base>0 shift=0)\n+  \/\/ Note that base>0 shift>0 should never be needed, since the klass range will\n+  \/\/ never exceed 4GB.\n+  constexpr uintptr_t unscaled_max = nth_bit(32);\n+  assert(len <= unscaled_max, \"Klass range larger than 32 bits?\");\n@@ -93,2 +99,1 @@\n-  assert(is_valid_base(_base), \"Address must be a valid encoding base\");\n-}\n+  constexpr uintptr_t zerobased_max = nth_bit(32 + LogKlassAlignmentInBytes);\n@@ -96,8 +101,12 @@\n-\/\/ Given an address p, return true if p can be used as an encoding base.\n-\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n-bool CompressedKlassPointers::is_valid_base(address p) {\n-#ifdef AARCH64\n-  \/\/ Below 32G, base must be aligned to 4G.\n-  \/\/ Above that point, base must be aligned to 32G\n-  if (p < (address)(32 * G)) {\n-    return is_aligned(p, 4 * G);\n+  address const end = addr + len;\n+  if (end <= (address)unscaled_max) {\n+    _base = nullptr;\n+    _shift = 0;\n+  } else {\n+    if (end <= (address)zerobased_max) {\n+      _base = nullptr;\n+      _shift = LogKlassAlignmentInBytes;\n+    } else {\n+      _base = addr;\n+      _shift = 0;\n+    }\n@@ -105,4 +114,3 @@\n-  return is_aligned(p, (4 << LogKlassAlignmentInBytes) * G);\n-#else\n-  return true;\n-#endif\n+  _range = end - _base;\n+\n+  DEBUG_ONLY(assert_is_valid_encoding(addr, len, _base, _shift);)\n@@ -110,0 +118,1 @@\n+#endif \/\/ !AARCH64\n@@ -117,15 +126,0 @@\n-void CompressedKlassPointers::set_base(address base) {\n-  assert(UseCompressedClassPointers, \"no compressed klass ptrs?\");\n-  _base   = base;\n-}\n-\n-void CompressedKlassPointers::set_shift(int shift)       {\n-  assert(shift == 0 || shift == LogKlassAlignmentInBytes, \"invalid shift for klass ptrs\");\n-  _shift   = shift;\n-}\n-\n-void CompressedKlassPointers::set_range(size_t range) {\n-  assert(UseCompressedClassPointers, \"no compressed klass ptrs?\");\n-  _range = range;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":56,"deletions":62,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -59,3 +59,7 @@\n-  static void set_base(address base);\n-  static void set_range(size_t range);\n-  static void set_shift(int shift);\n+  \/\/ Helper function for common cases.\n+  static char* reserve_address_space_X(uintptr_t from, uintptr_t to, size_t size, size_t alignment, bool aslr);\n+  static char* reserve_address_space_for_unscaled_encoding(size_t size, bool aslr);\n+  static char* reserve_address_space_for_zerobased_encoding(size_t size, bool aslr);\n+  static char* reserve_address_space_for_16bit_move(size_t size, bool aslr);\n+\n+  DEBUG_ONLY(static void assert_is_valid_encoding(address addr, size_t len, address base, int shift);)\n@@ -65,4 +69,3 @@\n-  \/\/ Given an address p, return true if p can be used as an encoding base.\n-  \/\/  (Some platforms have restrictions of what constitutes a valid base\n-  \/\/   address).\n-  static bool is_valid_base(address p);\n+  \/\/ Reserve a range of memory that is to contain Klass strucutures which are referenced by narrow Klass IDs.\n+  \/\/ If optimize_for_zero_base is true, the implementation will attempt to reserve optimized for zero-based encoding.\n+  static char* reserve_address_space_for_compressed_classes(size_t size, bool aslr, bool optimize_for_zero_base);\n@@ -72,1 +75,2 @@\n-  \/\/ archived heap objects.\n+  \/\/ archived heap objects. In this case, we don't have the freedom to choose base and shift; they are handed to\n+  \/\/ us from CDS.\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4228,0 +4228,17 @@\n+\/\/ This nulls out jmethodIDs for all methods in 'klass'\n+\/\/ It needs to be called explicitly for all previous versions of a class because these may not be cleaned up\n+\/\/ during class unloading.\n+\/\/ We can not use the jmethodID cache associated with klass directly because the 'previous' versions\n+\/\/ do not have the jmethodID cache filled in. Instead, we need to lookup jmethodID for each method and this\n+\/\/ is expensive - O(n) for one jmethodID lookup. For all contained methods it is O(n^2).\n+\/\/ The reason for expensive jmethodID lookup for each method is that there is no direct link between method and jmethodID.\n+void InstanceKlass::clear_jmethod_ids(InstanceKlass* klass) {\n+  Array<Method*>* method_refs = klass->methods();\n+  for (int k = 0; k < method_refs->length(); k++) {\n+    Method* method = method_refs->at(k);\n+    if (method != nullptr && method->is_obsolete()) {\n+      method->clear_jmethod_id();\n+    }\n+  }\n+}\n+\n@@ -4271,0 +4288,1 @@\n+      clear_jmethod_ids(pv_node); \/\/ jmethodID maintenance for the unloaded class\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1083,0 +1083,2 @@\n+  \/\/ This nulls out jmethodIDs for all methods in 'klass'\n+  static void clear_jmethod_ids(InstanceKlass* klass);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -651,0 +651,10 @@\n+void Method::set_exception_handler_entered(int handler_bci) {\n+  if (ProfileExceptionHandlers) {\n+    MethodData* mdo = method_data();\n+    if (mdo != nullptr) {\n+      BitData handler_data = mdo->exception_handler_bci_to_data(handler_bci);\n+      handler_data.set_exception_handler_entered();\n+    }\n+  }\n+}\n+\n@@ -2266,0 +2276,14 @@\n+void Method::clear_jmethod_id() {\n+  \/\/ Being at a safepoint prevents racing against other class redefinitions\n+  assert(SafepointSynchronize::is_at_safepoint(), \"should be at safepoint\");\n+  \/\/ The jmethodID is not stored in the Method instance, we need to look it up first\n+  jmethodID methodid = find_jmethod_id_or_null();\n+  \/\/ We need to make sure that jmethodID actually resolves to this method\n+  \/\/ - multiple redefined versions may share jmethodID slots and if a method\n+  \/\/   has already been rewired to a newer version we could be removing reference\n+  \/\/   to a still existing method instance\n+  if (methodid != nullptr && *((Method**)methodid) == this) {\n+    *((Method**)methodid) = nullptr;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -311,0 +311,3 @@\n+  \/\/ mark an exception handler as entered (used to prune dead catch blocks in C2)\n+  void set_exception_handler_entered(int handler_bci);\n+\n@@ -718,0 +721,1 @@\n+  void clear_jmethod_id();\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -968,0 +968,6 @@\n+\n+  if (ProfileExceptionHandlers && method()->has_exception_handler()) {\n+    int num_exception_handlers = method()->exception_table_length();\n+    object_size += num_exception_handlers * single_exception_handler_data_size();\n+  }\n+\n@@ -1278,0 +1284,1 @@\n+  int parm_data_size = 0;\n@@ -1279,1 +1286,2 @@\n-    object_size += DataLayout::compute_size_in_bytes(parms_cell);\n+    parm_data_size = DataLayout::compute_size_in_bytes(parms_cell);\n+    object_size += parm_data_size;\n@@ -1287,0 +1295,11 @@\n+  _exception_handler_data_di = data_size + extra_size + arg_data_size + parm_data_size;\n+  if (ProfileExceptionHandlers && method()->has_exception_handler()) {\n+    int num_exception_handlers = method()->exception_table_length();\n+    object_size += num_exception_handlers * single_exception_handler_data_size();\n+    ExceptionTableElement* exception_handlers = method()->exception_table_start();\n+    for (int i = 0; i < num_exception_handlers; i++) {\n+      DataLayout *dp = exception_handler_data_at(i);\n+      dp->initialize(DataLayout::bit_data_tag, exception_handlers[i].handler_pc, single_exception_handler_data_cell_count());\n+    }\n+  }\n+\n@@ -1381,0 +1400,22 @@\n+DataLayout* MethodData::exception_handler_bci_to_data_helper(int bci) {\n+  assert(ProfileExceptionHandlers, \"not profiling\");\n+  for (int i = 0; i < num_exception_handler_data(); i++) {\n+    DataLayout* exception_handler_data = exception_handler_data_at(i);\n+    if (exception_handler_data->bci() == bci) {\n+      return exception_handler_data;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+BitData* MethodData::exception_handler_bci_to_data_or_null(int bci) {\n+  DataLayout* data = exception_handler_bci_to_data_helper(bci);\n+  return data != nullptr ? new BitData(data) : nullptr;\n+}\n+\n+BitData MethodData::exception_handler_bci_to_data(int bci) {\n+  DataLayout* data = exception_handler_bci_to_data_helper(bci);\n+  assert(data != nullptr, \"invalid bci\");\n+  return BitData(data);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -494,1 +494,2 @@\n-      null_seen_flag              = DataLayout::first_flag + 0\n+      null_seen_flag              = DataLayout::first_flag + 0,\n+      exception_handler_entered_flag     = null_seen_flag + 1\n@@ -497,1 +498,1 @@\n-    , exception_seen_flag         = null_seen_flag + 1\n+    , exception_seen_flag         = exception_handler_entered_flag + 1\n@@ -528,0 +529,4 @@\n+  \/\/ true if a ex handler block at this bci was entered\n+  bool exception_handler_entered() { return flag_at(exception_handler_entered_flag); }\n+  void set_exception_handler_entered() { set_flag_at(exception_handler_entered_flag); }\n+\n@@ -2066,0 +2071,3 @@\n+  \/\/ data index of exception handler profiling data\n+  int _exception_handler_data_di;\n+\n@@ -2067,0 +2075,1 @@\n+  \/\/ See comment in ciMethodData::load_data\n@@ -2081,0 +2090,16 @@\n+  static int single_exception_handler_data_cell_count() {\n+    return BitData::static_cell_count();\n+  }\n+\n+  static int single_exception_handler_data_size() {\n+    return DataLayout::compute_size_in_bytes(single_exception_handler_data_cell_count());\n+  }\n+\n+  DataLayout* exception_handler_data_at(int exception_handler_index) const {\n+    return data_layout_at(_exception_handler_data_di + (exception_handler_index * single_exception_handler_data_size()));\n+  }\n+\n+  int num_exception_handler_data() const {\n+    return exception_handlers_data_size() \/ single_exception_handler_data_size();\n+  }\n+\n@@ -2146,0 +2171,2 @@\n+  DataLayout* exception_handler_bci_to_data_helper(int bci);\n+\n@@ -2282,2 +2309,5 @@\n-    ParametersTypeData* param = parameters_type_data();\n-    return param == nullptr ? 0 : param->size_in_bytes();\n+    return pointer_delta_as_int((address) parameters_data_limit(), (address) parameters_data_base());\n+  }\n+\n+  int exception_handlers_data_size() const {\n+    return pointer_delta_as_int((address) exception_handler_data_limit(), (address) exception_handler_data_base());\n@@ -2336,0 +2366,3 @@\n+  BitData* exception_handler_bci_to_data_or_null(int bci);\n+  BitData exception_handler_bci_to_data(int bci);\n+\n@@ -2337,0 +2370,1 @@\n+  \/\/ Only valid after 'set_size' is called at the end of MethodData::initialize\n@@ -2339,2 +2373,13 @@\n-  DataLayout* args_data_limit() const  { return (DataLayout*)((address)this + size_in_bytes() -\n-                                                              parameters_size_in_bytes()); }\n+  \/\/ pointers to sections in extra data\n+  DataLayout* args_data_limit() const  { return parameters_data_base(); }\n+  DataLayout* parameters_data_base() const {\n+    assert(_parameters_type_data_di != parameters_uninitialized, \"called too early\");\n+    return _parameters_type_data_di != no_parameters ? data_layout_at(_parameters_type_data_di) : parameters_data_limit();\n+  }\n+  DataLayout* parameters_data_limit() const {\n+    assert(_parameters_type_data_di != parameters_uninitialized, \"called too early\");\n+    return exception_handler_data_base();\n+  }\n+  DataLayout* exception_handler_data_base() const { return data_layout_at(_exception_handler_data_di); }\n+  DataLayout* exception_handler_data_limit() const { return extra_data_limit(); }\n+\n@@ -2388,2 +2433,6 @@\n-    assert(_parameters_type_data_di != parameters_uninitialized && _parameters_type_data_di != no_parameters, \"no args type data\");\n-    return _parameters_type_data_di;\n+    assert(_parameters_type_data_di != parameters_uninitialized, \"called too early\");\n+    return _parameters_type_data_di != no_parameters ? _parameters_type_data_di : exception_handlers_data_di();\n+  }\n+\n+  int exception_handlers_data_di() const {\n+    return _exception_handler_data_di;\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":57,"deletions":8,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -786,0 +786,2 @@\n+  develop(bool, StressPrunedExceptionHandlers, false,                       \\\n+          \"Always prune exception handlers\")                                \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -593,1 +593,5 @@\n-    xtty->print(\"%s\", ss.as_string()); \/\/ print to tty would use xml escape encoding\n+  }\n+\n+  tty->print(\"%s\", ss.as_string());\n+\n+  if (xtty != nullptr) {\n@@ -595,2 +599,0 @@\n-  } else {\n-    tty->print(\"%s\", ss.as_string());\n@@ -5144,1 +5146,1 @@\n-  if ((_directive->ideal_phase_mask() & CompilerPhaseTypeHelper::to_bitmask(cpt)) != 0) {\n+  if (_directive->should_print_phase(cpt)) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -944,1 +944,1 @@\n-  if (has_ex_handler() && !ex_type->klass_is_exact()) {\n+  if (has_exception_handler() && !ex_type->klass_is_exact()) {\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-\/\/-----------------------------has_ex_handler----------------------------------\n+\/\/-----------------------------has_exception_handler----------------------------------\n@@ -186,1 +186,1 @@\n-bool GraphKit::has_ex_handler() {\n+bool GraphKit::has_exception_handler() {\n@@ -551,1 +551,1 @@\n-        && has_ex_handler()) {\n+        && has_exception_handler()) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-  bool has_ex_handler();\n+  bool has_exception_handler();\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1300,3 +1300,0 @@\n-  if (t2 == TypeInt::INT)\n-    return TypeInt::INT;\n-\n@@ -1308,1 +1305,1 @@\n-  if (r2->is_con()) {\n+  if (!r1->is_con() && r2->is_con()) {\n@@ -1330,1 +1327,11 @@\n-  if( !r1->is_con() || !r2->is_con() )\n+  if (!r1->is_con() || !r2->is_con()) {\n+    \/\/ If the left input is non-negative the result must also be non-negative, regardless of what the right input is.\n+    if (r1->_lo >= 0) {\n+      return TypeInt::make(0, r1->_hi, MAX2(r1->_widen, r2->_widen));\n+    }\n+\n+    \/\/ Conversely, if the left input is negative then the result must be negative.\n+    if (r1->_hi <= -1) {\n+      return TypeInt::make(r1->_lo, -1, MAX2(r1->_widen, r2->_widen));\n+    }\n+\n@@ -1332,0 +1339,1 @@\n+  }\n@@ -1334,1 +1342,1 @@\n-  return TypeInt::make( r1->get_con() >> (r2->get_con()&31) );\n+  return TypeInt::make(r1->get_con() >> (r2->get_con() & 31));\n@@ -1362,3 +1370,0 @@\n-  if (t2 == TypeInt::INT)\n-    return TypeLong::LONG;\n-\n@@ -1370,1 +1375,1 @@\n-  if (r2->is_con()) {\n+  if (!r1->is_con() && r2->is_con()) {\n@@ -1392,1 +1397,15 @@\n-  return TypeLong::LONG;                \/\/ Give up\n+  if (!r1->is_con() || !r2->is_con()) {\n+    \/\/ If the left input is non-negative the result must also be non-negative, regardless of what the right input is.\n+    if (r1->_lo >= 0) {\n+      return TypeLong::make(0, r1->_hi, MAX2(r1->_widen, r2->_widen));\n+    }\n+\n+    \/\/ Conversely, if the left input is negative then the result must be negative.\n+    if (r1->_hi <= -1) {\n+      return TypeLong::make(r1->_lo, -1, MAX2(r1->_widen, r2->_widen));\n+    }\n+\n+    return TypeLong::LONG;\n+  }\n+\n+  return TypeLong::make(r1->get_con() >> (r2->get_con() & 63));\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":30,"deletions":11,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -172,0 +172,5 @@\n+  \/\/ Return an integer less than, equal to, or greater than zero\n+  \/\/ if the stack offset of the first argument is respectively\n+  \/\/ less than, equal to, or greater than the second.\n+  int compare_two_spill_nodes(Node* first, Node* second);\n+\n@@ -2274,0 +2279,23 @@\n+int Scheduling::compare_two_spill_nodes(Node* first, Node* second) {\n+  assert(first->is_MachSpillCopy() && second->is_MachSpillCopy(), \"\");\n+\n+  OptoReg::Name first_src_lo = _regalloc->get_reg_first(first->in(1));\n+  OptoReg::Name first_dst_lo = _regalloc->get_reg_first(first);\n+  OptoReg::Name second_src_lo = _regalloc->get_reg_first(second->in(1));\n+  OptoReg::Name second_dst_lo = _regalloc->get_reg_first(second);\n+\n+  \/\/ Comparison between stack -> reg and stack -> reg\n+  if (OptoReg::is_stack(first_src_lo) && OptoReg::is_stack(second_src_lo) &&\n+      OptoReg::is_reg(first_dst_lo) && OptoReg::is_reg(second_dst_lo)) {\n+    return _regalloc->reg2offset(first_src_lo) - _regalloc->reg2offset(second_src_lo);\n+  }\n+\n+  \/\/ Comparison between reg -> stack and reg -> stack\n+  if (OptoReg::is_stack(first_dst_lo) && OptoReg::is_stack(second_dst_lo) &&\n+      OptoReg::is_reg(first_src_lo) && OptoReg::is_reg(second_src_lo)) {\n+    return _regalloc->reg2offset(first_dst_lo) - _regalloc->reg2offset(second_dst_lo);\n+  }\n+\n+  return 0; \/\/ Not comparable\n+}\n+\n@@ -2285,1 +2313,4 @@\n-  \/\/ Insert in latency order (insertion sort)\n+  \/\/ Insert in latency order (insertion sort). If two MachSpillCopyNodes\n+  \/\/ for stack spilling or unspilling have the same latency, we sort\n+  \/\/ them in the order of stack offset. Some ports (e.g. aarch64) may also\n+  \/\/ have more opportunities to do ld\/st merging\n@@ -2287,2 +2318,2 @@\n-  for ( i=0; i < _available.size(); i++ )\n-    if (_current_latency[_available[i]->_idx] > latency)\n+  for (i = 0; i < _available.size(); i++) {\n+    if (_current_latency[_available[i]->_idx] > latency) {\n@@ -2290,0 +2321,6 @@\n+    } else if (_current_latency[_available[i]->_idx] == latency &&\n+               n->is_MachSpillCopy() && _available[i]->is_MachSpillCopy() &&\n+               compare_two_spill_nodes(n, _available[i]) > 0) {\n+      break;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1535,0 +1535,16 @@\n+  if (ProfileExceptionHandlers && block()->is_handler()) {\n+    ciMethodData* methodData = method()->method_data();\n+    if (methodData->is_mature()) {\n+      ciBitData data = methodData->exception_handler_bci_to_data(block()->start());\n+      if (!data.exception_handler_entered() || StressPrunedExceptionHandlers) {\n+        \/\/ dead catch block\n+        \/\/ Emit an uncommon trap instead of processing the block.\n+        set_parse_bci(block()->start());\n+        uncommon_trap(Deoptimization::Reason_unreached,\n+                      Deoptimization::Action_reinterpret,\n+                      nullptr, \"dead catch block\");\n+        return;\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"utilities\/bitMap.inline.hpp\"\n+\n@@ -103,3 +105,0 @@\n-  static uint64_t to_bitmask(CompilerPhaseType cpt) {\n-    return (UINT64_C(1) << cpt);\n-  }\n@@ -160,0 +159,1 @@\n+  CHeapBitMap _phase_name_set;\n@@ -164,1 +164,5 @@\n-  PhaseNameValidator(ccstrlist option, uint64_t& mask) : _valid(true), _bad(nullptr) {\n+  PhaseNameValidator(ccstrlist option) :\n+    _phase_name_set(PHASE_NUM_TYPES, mtCompiler),\n+    _valid(true),\n+    _bad(nullptr)\n+  {\n@@ -175,1 +179,1 @@\n-        mask = ~(UINT64_C(0));\n+        _phase_name_set.set_range(0, PHASE_NUM_TYPES);\n@@ -177,2 +181,2 @@\n-        assert(cpt < 64, \"out of bounds\");\n-        mask |= CompilerPhaseTypeHelper::to_bitmask(cpt);\n+        assert(cpt < PHASE_NUM_TYPES, \"out of bounds\");\n+        _phase_name_set.set_bit(cpt);\n@@ -189,0 +193,5 @@\n+  const BitMap& phase_name_set() const {\n+    assert(is_valid(), \"Use of invalid phase name set\");\n+    return _phase_name_set;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3589,6 +3589,0 @@\n-\/\/ Atomic \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-JVM_LEAF(jboolean, JVM_SupportsCX8())\n-  return VM_Version::supports_cx8();\n-JVM_END\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3142,0 +3142,7 @@\n+  \/\/ If the current thread is attaching from native and its Java thread object\n+  \/\/ is being allocated, things are not ready for allocation sampling.\n+  JavaThread* jt = JavaThread::cast(thread);\n+  if (jt->is_attaching_via_jni() && jt->threadObj() == nullptr) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -122,8 +122,0 @@\n-bool GrowableCache::equals(void* v, GrowableElement *e2) {\n-  GrowableElement *e1 = (GrowableElement *) v;\n-  assert(e1 != nullptr, \"e1 != nullptr\");\n-  assert(e2 != nullptr, \"e2 != nullptr\");\n-\n-  return e1->equals(e2);\n-}\n-\n@@ -166,2 +158,2 @@\n-int GrowableCache::find(GrowableElement* e) {\n-  return _elements->find(e, GrowableCache::equals);\n+int GrowableCache::find(const GrowableElement* e) const {\n+  return _elements->find_if([&](const GrowableElement* other_e) { return e->equals(other_e); });\n@@ -219,1 +211,1 @@\n-bool JvmtiBreakpoint::equals(JvmtiBreakpoint& bp) {\n+bool JvmtiBreakpoint::equals(const JvmtiBreakpoint& bp) const {\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -69,3 +69,3 @@\n-  virtual address getCacheValue()          =0;\n-  virtual bool equals(GrowableElement* e)  =0;\n-  virtual GrowableElement *clone()         =0;\n+  virtual address getCacheValue()                     =0;\n+  virtual bool equals(const GrowableElement* e) const =0;\n+  virtual GrowableElement* clone()                    =0;\n@@ -91,2 +91,0 @@\n-  static bool equals(void *, GrowableElement *);\n-\n@@ -107,1 +105,1 @@\n-  int find(GrowableElement* e);\n+  int find(const GrowableElement* e) const;\n@@ -168,1 +166,1 @@\n-  bool equals(JvmtiBreakpoint& bp);\n+  bool equals(const JvmtiBreakpoint& bp) const;\n@@ -180,1 +178,1 @@\n-  bool equals(GrowableElement* e) { return equals((JvmtiBreakpoint&) *e); }\n+  bool equals(const GrowableElement* e) const { return equals((const JvmtiBreakpoint&) *e); }\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -81,4 +81,0 @@\n-  if (thread_oop == nullptr) {  \/\/ Then thread should not be null (see assert above).\n-    thread_oop = thread->jvmti_vthread() != nullptr ? thread->jvmti_vthread() : thread->threadObj();\n-  }\n-\n@@ -88,2 +84,5 @@\n-  if (state == nullptr && thread != nullptr && thread->is_exiting()) {\n-    \/\/ Don't add a JvmtiThreadState to a thread that is exiting.\n+  if (state == nullptr && thread != nullptr &&\n+      (thread->is_exiting() || thread->is_attaching_via_jni())) {\n+    \/\/ Don't add a JvmtiThreadState to a thread that is exiting or is attaching.\n+    \/\/ When a thread is attaching, it may not have a Java level thread object\n+    \/\/ created yet.\n@@ -92,0 +91,11 @@\n+\n+  \/\/ Make sure we don't see an incomplete state. An incomplete state can cause\n+  \/\/ a duplicate JvmtiThreadState being created below and bound to the 'thread'\n+  \/\/ incorrectly, which leads to stale JavaThread* from the JvmtiThreadState\n+  \/\/ after the thread exits.\n+  assert(state == nullptr || state->get_thread_oop() != nullptr,\n+         \"incomplete state\");\n+\n+  if (thread_oop == nullptr) {  \/\/ Then thread should not be null (see assert above).\n+    thread_oop = thread->jvmti_vthread() != nullptr ? thread->jvmti_vthread() : thread->threadObj();\n+  }\n@@ -101,0 +111,1 @@\n+  assert(state != nullptr, \"sanity check\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.inline.hpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -38,13 +38,17 @@\n-class CloseScopedMemoryFindOopClosure : public OopClosure {\n-  oop _deopt;\n-  bool _found;\n-\n-public:\n-  CloseScopedMemoryFindOopClosure(jobject deopt) :\n-      _deopt(JNIHandles::resolve(deopt)),\n-      _found(false) {}\n-\n-  template <typename T>\n-  void do_oop_work(T* p) {\n-    if (_found) {\n-      return;\n+static bool is_in_scoped_access(JavaThread* jt, oop session) {\n+  const int max_critical_stack_depth = 10;\n+  int depth = 0;\n+  for (vframeStream stream(jt); !stream.at_end(); stream.next()) {\n+    Method* m = stream.method();\n+    if (m->is_scoped()) {\n+      StackValueCollection* locals = stream.asJavaVFrame()->locals();\n+      for (int i = 0; i < locals->size(); i++) {\n+        StackValue* var = locals->at(i);\n+        if (var->type() == T_OBJECT) {\n+          if (var->get_obj() == session) {\n+            assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n+            return true;\n+          }\n+        }\n+      }\n+      break;\n@@ -52,2 +56,4 @@\n-    if (RawAccess<>::oop_load(p) == _deopt) {\n-      _found = true;\n+    depth++;\n+#ifndef ASSERT\n+    if (depth >= max_critical_stack_depth) {\n+      break;\n@@ -55,0 +61,1 @@\n+#endif\n@@ -57,3 +64,5 @@\n-  virtual void do_oop(oop* p) {\n-    do_oop_work(p);\n-  }\n+  return false;\n+}\n+\n+class ScopedAsyncExceptionHandshake : public AsyncExceptionHandshake {\n+  OopHandle _session;\n@@ -61,2 +70,7 @@\n-  virtual void do_oop(narrowOop* p) {\n-    do_oop_work(p);\n+public:\n+  ScopedAsyncExceptionHandshake(OopHandle& session, OopHandle& error)\n+    : AsyncExceptionHandshake(error),\n+      _session(session) {}\n+\n+  ~ScopedAsyncExceptionHandshake() {\n+    _session.release(Universe::vm_global());\n@@ -65,2 +79,7 @@\n-  bool found() {\n-    return _found;\n+  virtual void do_thread(Thread* thread) {\n+    JavaThread* jt = JavaThread::cast(thread);\n+    ResourceMark rm;\n+    if (is_in_scoped_access(jt, _session.resolve())) {\n+      \/\/ Throw exception to unwind out from the scoped access\n+      AsyncExceptionHandshake::do_thread(thread);\n+    }\n@@ -71,1 +90,2 @@\n-  jobject _deopt;\n+  jobject _session;\n+  jobject _error;\n@@ -74,3 +94,1 @@\n-  jboolean _found;\n-\n-  CloseScopedMemoryClosure(jobject deopt, jobject exception)\n+  CloseScopedMemoryClosure(jobject session, jobject error)\n@@ -78,2 +96,2 @@\n-    , _deopt(deopt)\n-    , _found(false) {}\n+    , _session(session)\n+    , _error(error) {}\n@@ -82,1 +100,0 @@\n-\n@@ -86,0 +103,1 @@\n+      \/\/ No frames; not in a scoped memory access\n@@ -100,11 +118,4 @@\n-    if (_deopt != nullptr && last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n-      CloseScopedMemoryFindOopClosure cl(_deopt);\n-      CompiledMethod* cm = last_frame.cb()->as_compiled_method();\n-\n-      \/* FIXME: this doesn't work if reachability fences are violated by C2\n-      last_frame.oops_do(&cl, nullptr, &register_map);\n-      if (cl.found()) {\n-           \/\/Found the deopt oop in a compiled method; deoptimize.\n-           Deoptimization::deoptimize(jt, last_frame);\n-      }\n-      so... we unconditionally deoptimize, for now: *\/\n+    if (last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n+      \/\/ FIXME: we would like to conditionally deoptimize only if the corresponding\n+      \/\/ _session is reachable from the frame, but reachabilityFence doesn't currently\n+      \/\/ work the way it should. Therefore we deopt unconditionally for now.\n@@ -114,24 +125,14 @@\n-    const int max_critical_stack_depth = 10;\n-    int depth = 0;\n-    for (vframeStream stream(jt); !stream.at_end(); stream.next()) {\n-      Method* m = stream.method();\n-      if (m->is_scoped()) {\n-        StackValueCollection* locals = stream.asJavaVFrame()->locals();\n-        for (int i = 0; i < locals->size(); i++) {\n-          StackValue* var = locals->at(i);\n-          if (var->type() == T_OBJECT) {\n-            if (var->get_obj() == JNIHandles::resolve(_deopt)) {\n-              assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n-              _found = true;\n-              return;\n-            }\n-          }\n-        }\n-        break;\n-      }\n-      depth++;\n-#ifndef ASSERT\n-      if (depth >= max_critical_stack_depth) {\n-        break;\n-      }\n-#endif\n+    if (jt->has_async_exception_condition()) {\n+      \/\/ Target thread just about to throw an async exception using async handshakes,\n+      \/\/ we will then unwind out from the scoped memory access.\n+      return;\n+    }\n+\n+    if (is_in_scoped_access(jt, JNIHandles::resolve(_session))) {\n+      \/\/ We have found that the target thread is inside of a scoped access.\n+      \/\/ An asynchronous handshake is sent to the target thread, telling it\n+      \/\/ to throw an exception, which will unwind the target thread out from\n+      \/\/ the scoped access.\n+      OopHandle session(Universe::vm_global(), JNIHandles::resolve(_session));\n+      OopHandle error(Universe::vm_global(), JNIHandles::resolve(_error));\n+      jt->install_async_exception(new ScopedAsyncExceptionHandshake(session, error));\n@@ -149,2 +150,2 @@\n-JVM_ENTRY(jboolean, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt, jobject exception))\n-  CloseScopedMemoryClosure cl(deopt, exception);\n+JVM_ENTRY(void, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject session, jobject error))\n+  CloseScopedMemoryClosure cl(session, error);\n@@ -152,1 +153,0 @@\n-  return !cl._found;\n@@ -160,2 +160,2 @@\n-#define MEMACCESS \"ScopedMemoryAccess\"\n-#define SCOPE PKG_FOREIGN \"MemorySessionImpl;\"\n+#define SCOPED_SESSION PKG_FOREIGN \"MemorySessionImpl;\"\n+#define SCOPED_ERROR PKG_MISC \"ScopedMemoryAccess$ScopedAccessError;\"\n@@ -167,1 +167,1 @@\n-    {CC \"closeScope0\",   CC \"(\" SCOPE \")Z\",           FN_PTR(ScopedMemoryAccess_closeScope)},\n+  {CC \"closeScope0\", CC \"(\" SCOPED_SESSION SCOPED_ERROR \")V\", FN_PTR(ScopedMemoryAccess_closeScope)},\n@@ -175,2 +175,2 @@\n-#undef MEMACCESS\n-#undef SCOPE\n+#undef SCOPED_SESSION\n+#undef SCOPED_ERROR\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":72,"deletions":72,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-\n@@ -80,0 +79,24 @@\n+\/\/ Note that scoped accesses (cf. scopedMemoryAccess.cpp) can install\n+\/\/ an async handshake on the entry to an Unsafe method. When that happens,\n+\/\/ it is expected that we are not allowed to touch the underlying memory\n+\/\/ that might have gotten unmapped. Therefore, we check at the entry\n+\/\/ to unsafe functions, if we have such async exception conditions,\n+\/\/ and return immediately if that is the case.\n+\/\/\n+\/\/ We also use NoSafepointVerifier to block potential safepoints.\n+\/\/ It would be problematic if an async exception handshake were installed later on\n+\/\/ during another safepoint in the function, but before the memory access happens,\n+\/\/ as the memory will be freed after the handshake is installed. We must notice\n+\/\/ the installed handshake and return early before doing the memory access to prevent\n+\/\/ accesses to freed memory.\n+\/\/\n+\/\/ Note also that we MUST do a scoped memory access in the VM (or Java) thread\n+\/\/ state. Since we rely on a handshake to check for threads that are accessing\n+\/\/ scoped memory, and we need the handshaking thread to wait until we get to a\n+\/\/ safepoint, in order to make sure we are not in the middle of accessing memory\n+\/\/ that is about to be freed. (i.e. there can be no UNSAFE_LEAF_SCOPED)\n+#define UNSAFE_ENTRY_SCOPED(result_type, header) \\\n+  JVM_ENTRY(static result_type, header) \\\n+  if (thread->has_async_exception_condition()) {return (result_type)0;} \\\n+  NoSafepointVerifier nsv;\n+\n@@ -282,1 +305,1 @@\n-UNSAFE_ENTRY(java_type, Unsafe_Get##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n+UNSAFE_ENTRY_SCOPED(java_type, Unsafe_Get##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n@@ -286,1 +309,1 @@\n-UNSAFE_ENTRY(void, Unsafe_Put##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_Put##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n@@ -305,1 +328,1 @@\n-UNSAFE_ENTRY(java_type, Unsafe_Get##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n+UNSAFE_ENTRY_SCOPED(java_type, Unsafe_Get##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n@@ -309,1 +332,1 @@\n-UNSAFE_ENTRY(void, Unsafe_Put##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_Put##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n@@ -365,1 +388,1 @@\n-UNSAFE_ENTRY(void, Unsafe_SetMemory0(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong size, jbyte value)) {\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_SetMemory0(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong size, jbyte value)) {\n@@ -374,1 +397,1 @@\n-UNSAFE_ENTRY(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size)) {\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size)) {\n@@ -393,5 +416,1 @@\n-\/\/ This function is a leaf since if the source and destination are both in native memory\n-\/\/ the copy may potentially be very large, and we don't want to disable GC if we can avoid it.\n-\/\/ If either source or destination (or both) are on the heap, the function will enter VM using\n-\/\/ JVM_ENTRY_FROM_LEAF\n-UNSAFE_LEAF(void, Unsafe_CopySwapMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size, jlong elemSize)) {\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_CopySwapMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size, jlong elemSize)) {\n@@ -401,16 +420,2 @@\n-  if (srcObj == nullptr && dstObj == nullptr) {\n-    \/\/ Both src & dst are in native memory\n-    address src = (address)srcOffset;\n-    address dst = (address)dstOffset;\n-\n-    {\n-      JavaThread* thread = JavaThread::thread_from_jni_environment(env);\n-      GuardUnsafeAccess guard(thread);\n-      Copy::conjoint_swap(src, dst, sz, esz);\n-    }\n-  } else {\n-    \/\/ At least one of src\/dst are on heap, transition to VM to access raw pointers\n-\n-    JVM_ENTRY_FROM_LEAF(env, void, Unsafe_CopySwapMemory0) {\n-      oop srcp = JNIHandles::resolve(srcObj);\n-      oop dstp = JNIHandles::resolve(dstObj);\n+  oop srcp = JNIHandles::resolve(srcObj);\n+  oop dstp = JNIHandles::resolve(dstObj);\n@@ -418,2 +423,2 @@\n-      address src = (address)index_oop_from_field_offset_long(srcp, srcOffset);\n-      address dst = (address)index_oop_from_field_offset_long(dstp, dstOffset);\n+  address src = (address)index_oop_from_field_offset_long(srcp, srcOffset);\n+  address dst = (address)index_oop_from_field_offset_long(dstp, dstOffset);\n@@ -421,5 +426,3 @@\n-      {\n-        GuardUnsafeAccess guard(thread);\n-        Copy::conjoint_swap(src, dst, sz, esz);\n-      }\n-    } JVM_END\n+  {\n+    GuardUnsafeAccess guard(thread);\n+    Copy::conjoint_swap(src, dst, sz, esz);\n@@ -721,1 +724,1 @@\n-UNSAFE_ENTRY(jint, Unsafe_CompareAndExchangeInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n+UNSAFE_ENTRY_SCOPED(jint, Unsafe_CompareAndExchangeInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n@@ -727,1 +730,1 @@\n-UNSAFE_ENTRY(jlong, Unsafe_CompareAndExchangeLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n+UNSAFE_ENTRY_SCOPED(jlong, Unsafe_CompareAndExchangeLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n@@ -742,1 +745,1 @@\n-UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n+UNSAFE_ENTRY_SCOPED(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n@@ -748,1 +751,1 @@\n-UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n+UNSAFE_ENTRY_SCOPED(jboolean, Unsafe_CompareAndSetLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":42,"deletions":39,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -404,1 +404,1 @@\n-    return !(hr->is_young());\n+    return hr->is_old_or_humongous();\n@@ -2596,0 +2596,26 @@\n+WB_ENTRY(void, WB_PinObject(JNIEnv* env, jobject wb, jobject o))\n+#if INCLUDE_G1GC\n+  if (!UseG1GC) {\n+    ShouldNotReachHere();\n+    return;\n+  }\n+  oop obj = JNIHandles::resolve(o);\n+  G1CollectedHeap::heap()->pin_object(thread, obj);\n+#else\n+  ShouldNotReachHere();\n+#endif \/\/ INCLUDE_G1GC\n+WB_END\n+\n+WB_ENTRY(void, WB_UnpinObject(JNIEnv* env, jobject wb, jobject o))\n+#if INCLUDE_G1GC\n+  if (!UseG1GC) {\n+    ShouldNotReachHere();\n+    return;\n+  }\n+  oop obj = JNIHandles::resolve(o);\n+  G1CollectedHeap::heap()->unpin_object(thread, obj);\n+#else\n+  ShouldNotReachHere();\n+#endif \/\/ INCLUDE_G1GC\n+WB_END\n+\n@@ -2620,0 +2646,4 @@\n+WB_ENTRY(void, WB_CleanMetaspaces(JNIEnv* env, jobject target))\n+  ClassLoaderDataGraph::safepoint_and_clean_metaspaces();\n+WB_END\n+\n@@ -2902,0 +2932,2 @@\n+  {CC\"pinObject\",       CC\"(Ljava\/lang\/Object;)V\",    (void*)&WB_PinObject},\n+  {CC\"unpinObject\",     CC\"(Ljava\/lang\/Object;)V\",    (void*)&WB_UnpinObject},\n@@ -2904,0 +2936,1 @@\n+  {CC\"cleanMetaspaces\", CC\"()V\",                      (void*)&WB_CleanMetaspaces},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#ifndef SUPPORTS_NATIVE_CX8\n@@ -39,0 +40,1 @@\n+#endif\n@@ -243,0 +245,10 @@\n+      #elif _MSC_VER == 1934\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.4 (VS2022)\"\n+      #elif _MSC_VER == 1935\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.5 (VS2022)\"\n+      #elif _MSC_VER == 1936\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.6 (VS2022)\"\n+      #elif _MSC_VER == 1937\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.7 (VS2022)\"\n+      #elif _MSC_VER == 1938\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.8 (VS2022)\"\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#ifndef SUPPORTS_NATIVE_CX8\n@@ -63,0 +64,1 @@\n+#endif\n@@ -136,0 +138,2 @@\n+  \/\/ Required to be true but still dynamically checked at runtime\n+  \/\/ for platforms that don't set SUPPORTS_NATIVE_CX8\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -512,0 +512,1 @@\n+  { \"RegisterFinalizersAtInit\",     JDK_Version::jdk(22), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,5 +58,7 @@\n-  \/\/ Atomic operations on int64 types are not available on all 32-bit\n-  \/\/ platforms. If atomic ops on int64 are defined here they must only\n-  \/\/ be used from code that verifies they are available at runtime and\n-  \/\/ can provide an alternative action if not - see supports_cx8() for\n-  \/\/ a means to test availability.\n+  \/\/ Atomic operations on int64 types are required to be available on\n+  \/\/ all platforms. At a minimum a 64-bit cmpxchg must be available\n+  \/\/ from which other atomic operations can be constructed if needed.\n+  \/\/ The legacy `Abstract_VMVersion::supports_cx8()` function used to\n+  \/\/ indicate if this support existed, allowing for alternative lock-\n+  \/\/ based mechanism to be used. But today this function is required\n+  \/\/ to return true and in the future will be removed entirely.\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1501,15 +1501,15 @@\n-static bool monitors_on_stack(JavaThread* thread) {\n-  ContinuationEntry* ce = thread->last_continuation();\n-  RegisterMap map(thread,\n-                  RegisterMap::UpdateMap::include,\n-                  RegisterMap::ProcessFrames::include,\n-                  RegisterMap::WalkContinuation::skip);\n-  map.set_include_argument_oops(false);\n-  for (frame f = thread->last_frame(); Continuation::is_frame_in_continuation(ce, f); f = f.sender(&map)) {\n-    if ((f.is_interpreted_frame() && ContinuationHelper::InterpretedFrame::is_owning_locks(f)) ||\n-        (f.is_compiled_frame() && ContinuationHelper::CompiledFrame::is_owning_locks(map.thread(), &map, f))) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n+\/\/ static bool monitors_on_stack(JavaThread* thread) {\n+\/\/   ContinuationEntry* ce = thread->last_continuation();\n+\/\/   RegisterMap map(thread,\n+\/\/                   RegisterMap::UpdateMap::include,\n+\/\/                   RegisterMap::ProcessFrames::include,\n+\/\/                   RegisterMap::WalkContinuation::skip);\n+\/\/   map.set_include_argument_oops(false);\n+\/\/   for (frame f = thread->last_frame(); Continuation::is_frame_in_continuation(ce, f); f = f.sender(&map)) {\n+\/\/     if ((f.is_interpreted_frame() && ContinuationHelper::InterpretedFrame::is_owning_locks(f)) ||\n+\/\/         (f.is_compiled_frame() && ContinuationHelper::CompiledFrame::is_owning_locks(map.thread(), &map, f))) {\n+\/\/       return true;\n+\/\/     }\n+\/\/   }\n+\/\/   return false;\n+\/\/ }\n@@ -1578,2 +1578,2 @@\n-  assert(monitors_on_stack(current) == ((current->held_monitor_count() - current->jni_monitor_count()) > 0),\n-         \"Held monitor count and locks on stack invariant: \" INT64_FORMAT \" JNI: \" INT64_FORMAT, (int64_t)current->held_monitor_count(), (int64_t)current->jni_monitor_count());\n+  \/\/ assert(monitors_on_stack(current) == ((current->held_monitor_count() - current->jni_monitor_count()) > 0),\n+  \/\/        \"Held monitor count and locks on stack invariant: \" INT64_FORMAT \" JNI: \" INT64_FORMAT, (int64_t)current->held_monitor_count(), (int64_t)current->jni_monitor_count());\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2447,0 +2447,11 @@\n+    if (ProfileExceptionHandlers && trap_mdo != nullptr) {\n+      BitData* exception_handler_data = trap_mdo->exception_handler_bci_to_data_or_null(trap_bci);\n+      if (exception_handler_data != nullptr) {\n+        \/\/ uncommon trap at the start of an exception handler.\n+        \/\/ C2 generates these for un-entered exception handlers.\n+        \/\/ mark the handler as entered to avoid generating\n+        \/\/ another uncommon trap the next time the handler is compiled\n+        exception_handler_data->set_exception_handler_entered();\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -298,0 +298,3 @@\n+  product(size_t, InlineCacheBufferSize, 10*K, EXPERIMENTAL,                \\\n+          \"InlineCacheBuffer size\")                                         \\\n+                                                                            \\\n@@ -670,2 +673,2 @@\n-          \"Register finalizable objects at end of Object.<init> or \"        \\\n-          \"after allocation\")                                               \\\n+          \"(Deprecated) Register finalizable objects at end of \"            \\\n+          \"Object.<init> or after allocation\")                              \\\n@@ -736,0 +739,4 @@\n+  product(intx, MonitorUnlinkBatch, 500, DIAGNOSTIC,                        \\\n+          \"The maximum number of monitors to unlink in one batch. \")        \\\n+          range(1, max_jint)                                                \\\n+                                                                            \\\n@@ -838,0 +845,7 @@\n+  product(intx, UserThreadWaitAttemptsAtExit, 30,                           \\\n+          \"The number of times to wait for user threads to stop executing \" \\\n+          \"native code during JVM exit. Each wait lasts 10 milliseconds. \"  \\\n+          \"The maximum number of waits is 1000, to wait at most 10 \"        \\\n+          \"seconds.\")                                                       \\\n+          range(0, 1000)                                                    \\\n+                                                                            \\\n@@ -1987,0 +2001,7 @@\n+                                                                            \\\n+  develop(bool, SimulateFullAddressSpace, false,                            \\\n+          \"Simulates a very populated, fragmented address space; no \"       \\\n+          \"targeted reservations will succeed.\")                            \\\n+                                                                            \\\n+  product(bool, ProfileExceptionHandlers, true,                             \\\n+          \"Profile exception handlers\")                                     \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -409,8 +409,0 @@\n-#define JVM_ENTRY_FROM_LEAF(env, result_type, header)                \\\n-  { {                                                                \\\n-    JavaThread* thread=JavaThread::thread_from_jni_environment(env); \\\n-    ThreadInVMfromNative __tiv(thread);                              \\\n-    debug_only(VMNativeEntryWrapper __vew;)                          \\\n-    VM_ENTRY_BASE_FROM_LEAF(result_type, header, thread)\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -228,1 +228,0 @@\n-  void install_async_exception(AsyncExceptionHandshake* aec = nullptr);\n@@ -231,0 +230,1 @@\n+  void install_async_exception(AsyncExceptionHandshake* aec = nullptr);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,3 +84,0 @@\n-  \/\/ Pops an oop from this lock-stack.\n-  inline oop pop();\n-\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,13 +71,0 @@\n-inline oop LockStack::pop() {\n-  verify(\"pre-pop\");\n-  assert(to_index(_top) > 0, \"underflow, probably unbalanced push\/pop\");\n-  _top -= oopSize;\n-  oop o = _base[to_index(_top)];\n-#ifdef ASSERT\n-  _base[to_index(_top)] = nullptr;\n-#endif\n-  assert(!contains(o), \"entries must be unique: \" PTR_FORMAT, p2i(o));\n-  verify(\"post-pop\");\n-  return o;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -126,3 +126,0 @@\n-#ifndef SUPPORTS_NATIVE_CX8\n-Mutex*   UnsafeJlong_lock             = nullptr;\n-#endif\n@@ -301,4 +298,0 @@\n-#ifndef SUPPORTS_NATIVE_CX8\n-  MUTEX_DEFN(UnsafeJlong_lock                , PaddedMutex  , nosafepoint);\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -139,4 +139,0 @@\n-#ifndef SUPPORTS_NATIVE_CX8\n-extern Mutex*   UnsafeJlong_lock;                \/\/ provides Unsafe atomic updates to jlongs on platforms that don't support cx8\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -279,4 +279,1 @@\n-  if (!_object.is_null()) {\n-    \/\/ Release object's oop storage if it hasn't already been done.\n-    release_object();\n-  }\n+  _object.release(_oop_storage);\n@@ -287,3 +284,0 @@\n-  if (_object.is_null()) {\n-    return nullptr;\n-  }\n@@ -294,3 +288,0 @@\n-  if (_object.is_null()) {\n-    return nullptr;\n-  }\n@@ -591,3 +582,0 @@\n-  \/\/ Release object's oop storage since the ObjectMonitor has been deflated:\n-  release_object();\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -367,1 +367,0 @@\n-  void      release_object() { _object.release(_oop_storage); }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1813,1 +1813,1 @@\n-  char* result = pd_attempt_reserve_memory_at(addr, bytes, executable);\n+  char* result = SimulateFullAddressSpace ? nullptr : pd_attempt_reserve_memory_at(addr, bytes, executable);\n@@ -1821,1 +1821,0 @@\n-\n@@ -1877,1 +1876,1 @@\n-#define ARGSFMT \" range [\" PTR_FORMAT \"-\" PTR_FORMAT \"), size \" SIZE_FORMAT_X \", alignment \" SIZE_FORMAT_X \", randomize: %d\"\n+#define ARGSFMT \"range [\" PTR_FORMAT \"-\" PTR_FORMAT \"), size \" SIZE_FORMAT_X \", alignment \" SIZE_FORMAT_X \", randomize: %d\"\n@@ -1880,1 +1879,1 @@\n-  log_trace(os, map) (\"reserve_between (\" ARGSFMT \")\", ARGSFMTARGS);\n+  log_debug(os, map) (\"reserve_between (\" ARGSFMT \")\", ARGSFMTARGS);\n@@ -1990,1 +1989,1 @@\n-    result = os::pd_attempt_reserve_memory_at(candidate, bytes, false);\n+    result = SimulateFullAddressSpace ? nullptr : os::pd_attempt_reserve_memory_at(candidate, bytes, false);\n@@ -2008,0 +2007,2 @@\n+  } else {\n+    log_debug(os, map)(\"failed to attach anywhere in [\" PTR_FORMAT \"-\" PTR_FORMAT \")\", p2i(min), p2i(max));\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -526,2 +526,0 @@\n-  static char*  scan_pages(char *start, char* end, page_info* page_expected, page_info* page_found);\n-\n@@ -676,0 +674,2 @@\n+  static void           prepare_native_symbols();\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -188,0 +188,4 @@\n+bool PerfData::name_equals(const char* name) const {\n+  return strcmp(name, this->name()) == 0;\n+}\n+\n@@ -504,8 +508,0 @@\n-bool PerfDataList::by_name(void* name, PerfData* pd) {\n-\n-  if (pd == nullptr)\n-    return false;\n-\n-  return strcmp((const char*)name, pd->name()) == 0;\n-}\n-\n@@ -514,1 +510,1 @@\n-  int i = _set->find((void*)name, PerfDataList::by_name);\n+  int i = _set->find_if([&](PerfData* pd) { return pd->name_equals(name); });\n","filename":"src\/hotspot\/share\/runtime\/perfData.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -322,1 +322,2 @@\n-    const char* name() { return _name; }\n+    const char* name() const { return _name; }\n+    bool name_equals(const char* name) const;\n@@ -579,1 +580,1 @@\n-    static bool by_name(void* name, PerfData* pd);\n+    static bool by_name(const char* name, PerfData* pd);\n","filename":"src\/hotspot\/share\/runtime\/perfData.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -680,0 +680,1 @@\n+\/\/ Note that the implementation of this method assumes it's only called when an exception has actually occured\n@@ -782,0 +783,3 @@\n+  if (handler_bci != -1) { \/\/ did we find a handler in this method?\n+    sd->method()->set_exception_handler_entered(handler_bci); \/\/ profile\n+  }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,2 +87,2 @@\n-\/\/ Walk the in-use list and unlink (at most MonitorDeflationMax) deflated\n-\/\/ ObjectMonitors. Returns the number of unlinked ObjectMonitors.\n+\/\/ Walk the in-use list and unlink deflated ObjectMonitors.\n+\/\/ Returns the number of unlinked ObjectMonitors.\n@@ -91,0 +91,1 @@\n+                                    size_t deflated_count,\n@@ -94,2 +95,2 @@\n-  ObjectMonitor* head = Atomic::load_acquire(&_head);\n-  ObjectMonitor* m = head;\n+  ObjectMonitor* m = Atomic::load_acquire(&_head);\n+\n@@ -99,1 +100,3 @@\n-      \/\/ Find next live ObjectMonitor.\n+      \/\/ Find next live ObjectMonitor. Batch up the unlinkable monitors, so we can\n+      \/\/ modify the list once per batch. The batch starts at \"m\".\n+      size_t unlinked_batch = 0;\n@@ -101,0 +104,4 @@\n+      \/\/ Look for at most MonitorUnlinkBatch monitors, or the number of\n+      \/\/ deflated and not unlinked monitors, whatever comes first.\n+      assert(deflated_count >= unlinked_count, \"Sanity: underflow\");\n+      size_t unlinked_batch_limit = MIN2<size_t>(deflated_count - unlinked_count, MonitorUnlinkBatch);\n@@ -103,1 +110,1 @@\n-        unlinked_count++;\n+        unlinked_batch++;\n@@ -106,2 +113,8 @@\n-        if (unlinked_count >= (size_t)MonitorDeflationMax) {\n-          \/\/ Reached the max so bail out on the gathering loop.\n+        if (unlinked_batch >= unlinked_batch_limit) {\n+          \/\/ Reached the max batch, so bail out of the gathering loop.\n+          break;\n+        }\n+        if (prev == nullptr && Atomic::load(&_head) != m) {\n+          \/\/ Current batch used to be at head, but it is not at head anymore.\n+          \/\/ Bail out and figure out where we currently are. This avoids long\n+          \/\/ walks searching for new prev during unlink under heavy list inserts.\n@@ -111,0 +124,2 @@\n+\n+      \/\/ Unlink the found batch.\n@@ -112,3 +127,5 @@\n-        ObjectMonitor* prev_head = Atomic::cmpxchg(&_head, head, next);\n-        if (prev_head != head) {\n-          \/\/ Find new prev ObjectMonitor that just got inserted.\n+        \/\/ The current batch is the first batch, so there is a chance that it starts at head.\n+        \/\/ Optimistically assume no inserts happened, and try to unlink the entire batch from the head.\n+        ObjectMonitor* prev_head = Atomic::cmpxchg(&_head, m, next);\n+        if (prev_head != m) {\n+          \/\/ Something must have updated the head. Figure out the actual prev for this batch.\n@@ -118,0 +135,1 @@\n+          assert(prev != nullptr, \"Should have found the prev for the current batch\");\n@@ -121,0 +139,3 @@\n+        \/\/ The current batch is preceded by another batch. This guarantees the current batch\n+        \/\/ does not start at head. Unlink the entire current batch without updating the head.\n+        assert(Atomic::load(&_head) != m, \"Sanity\");\n@@ -123,2 +144,5 @@\n-      if (unlinked_count >= (size_t)MonitorDeflationMax) {\n-        \/\/ Reached the max so bail out on the searching loop.\n+\n+      unlinked_count += unlinked_batch;\n+      if (unlinked_count >= deflated_count) {\n+        \/\/ Reached the max so bail out of the searching loop.\n+        \/\/ There should be no more deflated monitors left.\n@@ -140,0 +164,14 @@\n+\n+#ifdef ASSERT\n+  \/\/ Invariant: the code above should unlink all deflated monitors.\n+  \/\/ The code that runs after this unlinking does not expect deflated monitors.\n+  \/\/ Notably, attempting to deflate the already deflated monitor would break.\n+  {\n+    ObjectMonitor* m = Atomic::load_acquire(&_head);\n+    while (m != nullptr) {\n+      assert(!m->is_being_async_deflated(), \"All deflated monitors should be unlinked\");\n+      m = m->next_om();\n+    }\n+  }\n+#endif\n+\n@@ -602,7 +640,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT && monitor->is_owner_anonymous()) {\n-    \/\/ It must be owned by us. Pop lock object from lock stack.\n-    LockStack& lock_stack = current->lock_stack();\n-    oop popped = lock_stack.pop();\n-    assert(popped == object, \"must be owned by this thread\");\n-    monitor->set_owner_from_anonymous(current);\n-  }\n+  assert(!monitor->is_owner_anonymous(), \"must not be\");\n@@ -1584,1 +1616,2 @@\n-static size_t delete_monitors(GrowableArray<ObjectMonitor*>* delete_list) {\n+static size_t delete_monitors(JavaThread* current, GrowableArray<ObjectMonitor*>* delete_list,\n+                              LogStream* ls, elapsedTimer* timer_p) {\n@@ -1586,1 +1619,1 @@\n-  size_t count = 0;\n+  size_t deleted_count = 0;\n@@ -1589,1 +1622,4 @@\n-    count++;\n+    deleted_count++;\n+    \/\/ A JavaThread must check for a safepoint\/handshake and honor it.\n+    ObjectSynchronizer::chk_for_block_req(current, \"deletion\", \"deleted_count\",\n+                                          deleted_count, ls, timer_p);\n@@ -1591,1 +1627,1 @@\n-  return count;\n+  return deleted_count;\n@@ -1630,1 +1666,1 @@\n-    unlinked_count = _in_use_list.unlink_deflated(current, ls, &timer, &delete_list);\n+    unlinked_count = _in_use_list.unlink_deflated(current, ls, &timer, deflated_count, &delete_list);\n@@ -1665,24 +1701,1 @@\n-    if (current->is_Java_thread()) {\n-      if (ls != NULL) {\n-        timer.stop();\n-        ls->print_cr(\"before setting blocked: unlinked_count=\" SIZE_FORMAT\n-                     \", in_use_list stats: ceiling=\" SIZE_FORMAT \", count=\"\n-                     SIZE_FORMAT \", max=\" SIZE_FORMAT,\n-                     unlinked_count, in_use_list_ceiling(),\n-                     _in_use_list.count(), _in_use_list.max());\n-      }\n-      \/\/ Mark the calling JavaThread blocked (safepoint safe) while we free\n-      \/\/ the ObjectMonitors so we don't delay safepoints whilst doing that.\n-      ThreadBlockInVM tbivm(JavaThread::cast(current));\n-      if (ls != NULL) {\n-        ls->print_cr(\"after setting blocked: in_use_list stats: ceiling=\"\n-                     SIZE_FORMAT \", count=\" SIZE_FORMAT \", max=\" SIZE_FORMAT,\n-                     in_use_list_ceiling(), _in_use_list.count(), _in_use_list.max());\n-        timer.start();\n-      }\n-      deleted_count = delete_monitors(&delete_list);\n-      \/\/ ThreadBlockInVM is destroyed here\n-    } else {\n-      \/\/ A non-JavaThread can just free the ObjectMonitors:\n-      deleted_count = delete_monitors(&delete_list);\n-    }\n+    deleted_count = delete_monitors(JavaThread::cast(current), &delete_list, ls, &timer);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":62,"deletions":49,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+                         size_t deflated_count,\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,5 +74,0 @@\n-\n-bool match_oop_entry(void *op, UnhandledOopEntry e) {\n-  return (e.oop_ptr() == op);\n-}\n-\n@@ -86,1 +81,3 @@\n-  int i = _oop_list->find_from_end(op, match_oop_entry);\n+  int i = _oop_list->find_from_end_if([&](const UnhandledOopEntry& e) {\n+    return e.match_oop_entry(op);\n+  });\n@@ -108,1 +105,3 @@\n-  int i = _oop_list->find_from_end(op, match_oop_entry);\n+  int i = _oop_list->find_from_end_if([&](const UnhandledOopEntry& e) {\n+    return e.match_oop_entry(op);\n+  });\n","filename":"src\/hotspot\/share\/runtime\/unhandledOops.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -56,0 +56,5 @@\n+\n+  bool match_oop_entry(oop* op) const {\n+    return _oop_ptr == op;\n+  }\n+\n@@ -57,1 +62,0 @@\n-  oop* oop_ptr() { return _oop_ptr; }\n@@ -63,1 +67,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/unhandledOops.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -497,4 +497,3 @@\n-  int max_wait_user_thread = 30;                  \/\/ at least 300 milliseconds\n-  int max_wait_compiler_thread = 1000;            \/\/ at least 10 seconds\n-\n-  int max_wait = max_wait_compiler_thread;\n+  int wait_time_per_attempt = 10;               \/\/ in milliseconds\n+  int max_wait_attempts_user_thread = UserThreadWaitAttemptsAtExit;\n+  int max_wait_attempts_compiler_thread = 1000; \/\/ at least 10 seconds\n@@ -533,1 +532,1 @@\n-    } else if (attempts > max_wait) {\n+    } else if (attempts >= max_wait_attempts_compiler_thread) {\n@@ -535,1 +534,2 @@\n-    } else if (num_active_compiler_thread == 0 && attempts > max_wait_user_thread) {\n+    } else if (num_active_compiler_thread == 0 &&\n+               attempts >= max_wait_attempts_user_thread) {\n@@ -542,1 +542,1 @@\n-    ml.wait(10);\n+    ml.wait(wait_time_per_attempt);\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1111,0 +1111,1 @@\n+  declare_unsigned_integer_type(volatile uint)                            \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-\n+  guarantee(VM_Version::supports_cx8(), \"Support for 64-bit atomic operations is required\");\n","filename":"src\/hotspot\/share\/runtime\/vm_version.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -147,3 +147,2 @@\n-bool DCmdInfo::by_name(void* cmd_name, DCmdInfo* info) {\n-  if (info == nullptr) return false;\n-  return strcmp((const char*)cmd_name, info->name()) == 0;\n+bool DCmdInfo::name_equals(const char* name) const {\n+  return strcmp(name, this->name()) == 0;\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+  bool name_equals(const char* cmd_name) const;\n@@ -148,2 +149,0 @@\n-\n-  static bool by_name(void* name, DCmdInfo* info);\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2007,1 +2007,3 @@\n-    int pos = info_list->find((void*)cmd_name,DCmdInfo::by_name);\n+    int pos = info_list->find_if([&](DCmdInfo* info) {\n+      return info->name_equals(cmd_name);\n+    });\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -212,1 +212,7 @@\n-  int  find(void* token, bool f(void*, E)) const {\n+  \/\/ Find first element that matches the given predicate.\n+  \/\/\n+  \/\/ Predicate: bool predicate(const E& elem)\n+  \/\/\n+  \/\/ Returns the index of the element or -1 if no element matches the predicate\n+  template<typename Predicate>\n+  int find_if(Predicate predicate) const {\n@@ -214,1 +220,1 @@\n-      if (f(token, _data[i])) return i;\n+      if (predicate(_data[i])) return i;\n@@ -219,1 +225,7 @@\n-  int  find_from_end(void* token, bool f(void*, E)) const {\n+  \/\/ Find last element that matches the given predicate.\n+  \/\/\n+  \/\/ Predicate: bool predicate(const E& elem)\n+  \/\/\n+  \/\/ Returns the index of the element or -1 if no element matches the predicate\n+  template<typename Predicate>\n+  int find_from_end_if(Predicate predicate) const {\n@@ -222,1 +234,1 @@\n-      if (f(token, _data[i])) return i;\n+      if (predicate(_data[i])) return i;\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    for (int index = 0; index < indent; index ++) out->print(\" \");\n+    out->fill_to(indent);\n@@ -91,2 +91,5 @@\n-      \/\/ Print indent\n-      for (int index = 0; index < indent; index ++) out->print(\" \");\n+      out->fill_to(indent);\n+      out->print(\"[\" PTR_FORMAT \"]\", p2i(pc));\n+      \/\/ Print function and library; shorten library name to just its last component\n+      \/\/ for brevity, and omit it completely for libjvm.so\n+      bool function_printed = false;\n@@ -94,3 +97,15 @@\n-        out->print(\"[\" PTR_FORMAT \"] %s+0x%x\", p2i(pc), buf, offset);\n-      } else {\n-        out->print(\"[\" PTR_FORMAT \"]\", p2i(pc));\n+        out->print(\"%s+0x%x\", buf, offset);\n+        function_printed = true;\n+      }\n+      if ((!function_printed || !os::address_is_in_vm(pc)) &&\n+          os::dll_address_to_library_name(pc, buf, sizeof(buf), &offset)) {\n+        const char* libname = strrchr(buf, os::file_separator()[0]);\n+        if (libname != nullptr) {\n+          libname++;\n+        } else {\n+          libname = buf;\n+        }\n+        out->print(\" in %s\", libname);\n+        if (!function_printed) {\n+          out->print(\"+0x%x\", offset);\n+        }\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.cpp","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -77,4 +77,0 @@\n-#ifdef AIX\n-#include \"loadlib_aix.hpp\"\n-#endif\n-\n@@ -728,0 +724,5 @@\n+  \/\/ avoid the cache update for malloc\/mmap errors\n+  if (should_report_bug(_id)) {\n+    os::prepare_native_symbols();\n+  }\n+\n@@ -1350,1 +1351,1 @@\n-  AIX_ONLY(LoadedLibraries::reload());\n+  os::prepare_native_symbols();\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -32,0 +33,48 @@\n+\/\/ Implements the striped semaphore wait barrier.\n+\/\/\n+\/\/ To guarantee progress and safety, we need to make sure that new barrier tag\n+\/\/ starts with the completely empty set of waiters and free semaphore. This\n+\/\/ requires either waiting for all threads to leave wait() for current barrier\n+\/\/ tag on disarm(), or waiting for all threads to leave the previous tag before\n+\/\/ reusing the semaphore in arm().\n+\/\/\n+\/\/ When there are multiple threads, it is normal for some threads to take\n+\/\/ significant time to leave the barrier. Waiting for these threads introduces\n+\/\/ stalls on barrier reuse.\n+\/\/\n+\/\/ If we wait on disarm(), this stall is nearly guaranteed to happen if some threads\n+\/\/ are de-scheduled by prior wait(). It would be especially bad if there are more\n+\/\/ waiting threads than CPUs: every thread would need to wake up and register itself\n+\/\/ as leaving, before we can unblock from disarm().\n+\/\/\n+\/\/ If we wait on arm(), we can get lucky that most threads would be able to catch up,\n+\/\/ exit wait(), and so we arrive to arm() with semaphore ready for reuse. However,\n+\/\/ that is still insufficient in practice.\n+\/\/\n+\/\/ Therefore, this implementation goes a step further and implements the _striped_\n+\/\/ semaphores. We maintain several semaphores in cells. The barrier tags are assigned\n+\/\/ to cells in some simple manner. Most of the current uses have sequential barrier\n+\/\/ tags, so simple modulo works well. We then operate on a cell like we would operate\n+\/\/ on a single semaphore: we wait at arm() for all threads to catch up before reusing\n+\/\/ the cell. For the cost of maintaining just a few cells, we have enough window for\n+\/\/ threads to catch up.\n+\/\/\n+\/\/ The correctness is guaranteed by using a single atomic state variable per cell,\n+\/\/ with updates always done with CASes:\n+\/\/\n+\/\/   [.......... barrier tag ..........][.......... waiters ..........]\n+\/\/  63                                  31                            0\n+\/\/\n+\/\/ Cell starts with zero tag and zero waiters. Arming the cell swings barrier tag from\n+\/\/ zero to some tag, while checking that no waiters have appeared. Disarming swings\n+\/\/ the barrier tag back from tag to zero. Every waiter registers itself by incrementing\n+\/\/ the \"waiters\", while checking that barrier tag is still the same. Every completing waiter\n+\/\/ decrements the \"waiters\". When all waiters complete, a cell ends up in initial state,\n+\/\/ ready to be armed again. This allows accurate tracking of how many signals\n+\/\/ to issue and does not race with disarm.\n+\/\/\n+\/\/ The implementation uses the strongest (default) barriers for extra safety, even\n+\/\/ when not strictly required to do so for correctness. Extra barrier overhead is\n+\/\/ dominated by the actual wait\/notify latency anyway.\n+\/\/\n+\n@@ -33,4 +82,10 @@\n-  assert(_barrier_tag == 0, \"Already armed\");\n-  assert(_waiters == 0, \"We left a thread hanging\");\n-  _barrier_tag = barrier_tag;\n-  _waiters = 0;\n+  assert(barrier_tag != 0, \"Pre arm: Should be arming with armed value\");\n+  assert(Atomic::load(&_barrier_tag) == 0,\n+         \"Pre arm: Should not be already armed. Tag: %d\",\n+         Atomic::load(&_barrier_tag));\n+  Atomic::release_store(&_barrier_tag, barrier_tag);\n+\n+  Cell &cell = tag_to_cell(barrier_tag);\n+  cell.arm(barrier_tag);\n+\n+  \/\/ API specifies arm() must provide a trailing fence.\n@@ -40,16 +95,10 @@\n-int GenericWaitBarrier::wake_if_needed() {\n-  assert(_barrier_tag == 0, \"Not disarmed\");\n-  int w = _waiters;\n-  if (w == 0) {\n-    \/\/ Load of _barrier_threads in caller must not pass the load of _waiters.\n-    OrderAccess::loadload();\n-    return 0;\n-  }\n-  assert(w > 0, \"Bad counting\");\n-  \/\/ We need an exact count which never goes below zero,\n-  \/\/ otherwise the semaphore may be signalled too many times.\n-  if (Atomic::cmpxchg(&_waiters, w, w - 1) == w) {\n-    _sem_barrier.signal();\n-    return w - 1;\n-  }\n-  return w;\n+void GenericWaitBarrier::disarm() {\n+  int barrier_tag = Atomic::load_acquire(&_barrier_tag);\n+  assert(barrier_tag != 0, \"Pre disarm: Should be armed. Tag: %d\", barrier_tag);\n+  Atomic::release_store(&_barrier_tag, 0);\n+\n+  Cell &cell = tag_to_cell(barrier_tag);\n+  cell.disarm(barrier_tag);\n+\n+  \/\/ API specifies disarm() must provide a trailing fence.\n+  OrderAccess::fence();\n@@ -58,5 +107,7 @@\n-void GenericWaitBarrier::disarm() {\n-  assert(_barrier_tag != 0, \"Not armed\");\n-  _barrier_tag = 0;\n-  \/\/ Loads of _barrier_threads\/_waiters must not float above disarm store and\n-  \/\/ disarm store must not sink below.\n+void GenericWaitBarrier::wait(int barrier_tag) {\n+  assert(barrier_tag != 0, \"Pre wait: Should be waiting on armed value\");\n+\n+  Cell &cell = tag_to_cell(barrier_tag);\n+  cell.wait(barrier_tag);\n+\n+  \/\/ API specifies wait() must provide a trailing fence.\n@@ -64,1 +115,8 @@\n-  int left;\n+}\n+\n+void GenericWaitBarrier::Cell::arm(int32_t requested_tag) {\n+  \/\/ Before we continue to arm, we need to make sure that all threads\n+  \/\/ have left the previous cell.\n+\n+  int64_t state;\n+\n@@ -66,4 +124,74 @@\n-  do {\n-    left = GenericWaitBarrier::wake_if_needed();\n-    if (left == 0 && _barrier_threads > 0) {\n-      \/\/ There is no thread to wake but we still have barrier threads.\n+  while (true) {\n+    state = Atomic::load_acquire(&_state);\n+    assert(decode_tag(state) == 0,\n+           \"Pre arm: Should not be armed. \"\n+           \"Tag: \" INT32_FORMAT \"; Waiters: \" INT32_FORMAT,\n+           decode_tag(state), decode_waiters(state));\n+    if (decode_waiters(state) == 0) {\n+      break;\n+    }\n+    sp.wait();\n+  }\n+\n+  \/\/ Try to swing cell to armed. This should always succeed after the check above.\n+  int64_t new_state = encode(requested_tag, 0);\n+  int64_t prev_state = Atomic::cmpxchg(&_state, state, new_state);\n+  if (prev_state != state) {\n+    fatal(\"Cannot arm the wait barrier. \"\n+          \"Tag: \" INT32_FORMAT \"; Waiters: \" INT32_FORMAT,\n+          decode_tag(prev_state), decode_waiters(prev_state));\n+  }\n+}\n+\n+int GenericWaitBarrier::Cell::signal_if_needed(int max) {\n+  int signals = 0;\n+  while (true) {\n+    int cur = Atomic::load_acquire(&_outstanding_wakeups);\n+    if (cur == 0) {\n+      \/\/ All done, no more waiters.\n+      return 0;\n+    }\n+    assert(cur > 0, \"Sanity\");\n+\n+    int prev = Atomic::cmpxchg(&_outstanding_wakeups, cur, cur - 1);\n+    if (prev != cur) {\n+      \/\/ Contention, return to caller for early return or backoff.\n+      return prev;\n+    }\n+\n+    \/\/ Signal!\n+    _sem.signal();\n+\n+    if (++signals >= max) {\n+      \/\/ Signalled requested number of times, break out.\n+      return prev;\n+    }\n+  }\n+}\n+\n+void GenericWaitBarrier::Cell::disarm(int32_t expected_tag) {\n+  int32_t waiters;\n+\n+  while (true) {\n+    int64_t state = Atomic::load_acquire(&_state);\n+    int32_t tag = decode_tag(state);\n+    waiters = decode_waiters(state);\n+\n+    assert((tag == expected_tag) && (waiters >= 0),\n+           \"Mid disarm: Should be armed with expected tag and have sane waiters. \"\n+           \"Tag: \" INT32_FORMAT \"; Waiters: \" INT32_FORMAT,\n+           tag, waiters);\n+\n+    int64_t new_state = encode(0, waiters);\n+    if (Atomic::cmpxchg(&_state, state, new_state) == state) {\n+      \/\/ Successfully disarmed.\n+      break;\n+    }\n+  }\n+\n+  \/\/ Wake up waiters, if we have at least one.\n+  \/\/ Allow other threads to assist with wakeups, if possible.\n+  if (waiters > 0) {\n+    Atomic::release_store(&_outstanding_wakeups, waiters);\n+    SpinYield sp;\n+    while (signal_if_needed(INT_MAX) > 0) {\n@@ -72,4 +200,2 @@\n-    \/\/ We must loop here until there are no waiters or potential waiters.\n-  } while (left > 0 || _barrier_threads > 0);\n-  \/\/ API specifies disarm() must provide a trailing fence.\n-  OrderAccess::fence();\n+  }\n+  assert(Atomic::load(&_outstanding_wakeups) == 0, \"Post disarm: Should not have outstanding wakeups\");\n@@ -78,6 +204,23 @@\n-void GenericWaitBarrier::wait(int barrier_tag) {\n-  assert(barrier_tag != 0, \"Trying to wait on disarmed value\");\n-  if (barrier_tag != _barrier_tag) {\n-    \/\/ API specifies wait() must provide a trailing fence.\n-    OrderAccess::fence();\n-    return;\n+void GenericWaitBarrier::Cell::wait(int32_t expected_tag) {\n+  \/\/ Try to register ourselves as pending waiter.\n+  while (true) {\n+    int64_t state = Atomic::load_acquire(&_state);\n+    int32_t tag = decode_tag(state);\n+    if (tag != expected_tag) {\n+      \/\/ Cell tag had changed while waiting here. This means either the cell had\n+      \/\/ been disarmed, or we are late and the cell was armed with a new tag.\n+      \/\/ Exit without touching anything else.\n+      return;\n+    }\n+    int32_t waiters = decode_waiters(state);\n+\n+    assert((tag == expected_tag) && (waiters >= 0 && waiters < INT32_MAX),\n+           \"Before wait: Should be armed with expected tag and waiters are in range. \"\n+           \"Tag: \" INT32_FORMAT \"; Waiters: \" INT32_FORMAT,\n+           tag, waiters);\n+\n+    int64_t new_state = encode(tag, waiters + 1);\n+    if (Atomic::cmpxchg(&_state, state, new_state) == state) {\n+      \/\/ Success! Proceed to wait.\n+      break;\n+    }\n@@ -85,7 +228,28 @@\n-  Atomic::add(&_barrier_threads, 1);\n-  if (barrier_tag != 0 && barrier_tag == _barrier_tag) {\n-    Atomic::add(&_waiters, 1);\n-    _sem_barrier.wait();\n-    \/\/ We help out with posting, but we need to do so before we decrement the\n-    \/\/ _barrier_threads otherwise we might wake threads up in next wait.\n-    GenericWaitBarrier::wake_if_needed();\n+\n+  \/\/ Wait for notification.\n+  _sem.wait();\n+\n+  \/\/ Unblocked! We help out with waking up two siblings. This allows to avalanche\n+  \/\/ the wakeups for many threads, even if some threads are lagging behind.\n+  \/\/ Note that we can only do this *before* reporting back as completed waiter,\n+  \/\/ otherwise we might prematurely wake up threads for another barrier tag.\n+  \/\/ Current arm() sequence protects us from this trouble by waiting until all waiters\n+  \/\/ leave.\n+  signal_if_needed(2);\n+\n+  \/\/ Register ourselves as completed waiter before leaving.\n+  while (true) {\n+    int64_t state = Atomic::load_acquire(&_state);\n+    int32_t tag = decode_tag(state);\n+    int32_t waiters = decode_waiters(state);\n+\n+    assert((tag == 0) && (waiters > 0),\n+           \"After wait: Should be not armed and have non-complete waiters. \"\n+           \"Tag: \" INT32_FORMAT \"; Waiters: \" INT32_FORMAT,\n+           tag, waiters);\n+\n+    int64_t new_state = encode(tag, waiters - 1);\n+    if (Atomic::cmpxchg(&_state, state, new_state) == state) {\n+      \/\/ Success!\n+      break;\n+    }\n@@ -93,1 +257,0 @@\n-  Atomic::add(&_barrier_threads, -1);\n","filename":"src\/hotspot\/share\/utilities\/waitBarrier_generic.cpp","additions":212,"deletions":49,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/padded.hpp\"\n@@ -32,2 +33,0 @@\n-\/\/ In addition to the barrier tag, it uses two counters to keep the semaphore\n-\/\/ count correct and not leave any late thread waiting.\n@@ -35,0 +34,52 @@\n+private:\n+  class Cell : public CHeapObj<mtInternal> {\n+  private:\n+    \/\/ Pad out the cells to avoid interference between the cells.\n+    \/\/ This would insulate from stalls when adjacent cells have returning\n+    \/\/ workers and contend over the cache line for current latency-critical\n+    \/\/ cell.\n+    DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);\n+\n+    Semaphore _sem;\n+\n+    \/\/ Cell state, tracks the arming + waiters status\n+    volatile int64_t _state;\n+\n+    \/\/ Wakeups to deliver for current waiters\n+    volatile int _outstanding_wakeups;\n+\n+    int signal_if_needed(int max);\n+\n+    static int64_t encode(int32_t barrier_tag, int32_t waiters) {\n+      int64_t val = (((int64_t) barrier_tag) << 32) |\n+                    (((int64_t) waiters) & 0xFFFFFFFF);\n+      assert(decode_tag(val) == barrier_tag, \"Encoding is reversible\");\n+      assert(decode_waiters(val) == waiters, \"Encoding is reversible\");\n+      return val;\n+    }\n+\n+    static int32_t decode_tag(int64_t value) {\n+      return (int32_t)(value >> 32);\n+    }\n+\n+    static int32_t decode_waiters(int64_t value) {\n+      return (int32_t)(value & 0xFFFFFFFF);\n+    }\n+\n+  public:\n+    Cell() : _sem(0), _state(encode(0, 0)), _outstanding_wakeups(0) {}\n+    NONCOPYABLE(Cell);\n+\n+    void arm(int32_t requested_tag);\n+    void disarm(int32_t expected_tag);\n+    void wait(int32_t expected_tag);\n+  };\n+\n+  \/\/ Should be enough for most uses without exploding the footprint.\n+  static constexpr int CELLS_COUNT = 16;\n+\n+  Cell _cells[CELLS_COUNT];\n+\n+  \/\/ Trailing padding to protect the last cell.\n+  DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);\n+\n@@ -36,6 +87,5 @@\n-  \/\/ The number of threads waiting on or about to wait on the semaphore.\n-  volatile int _waiters;\n-  \/\/ The number of threads in the wait path, before or after the tag check.\n-  \/\/ These threads can become waiters.\n-  volatile int _barrier_threads;\n-  Semaphore _sem_barrier;\n+\n+  \/\/ Trailing padding to insulate the rest of the barrier from adjacent\n+  \/\/ data structures. The leading padding is not needed, as cell padding\n+  \/\/ handles this for us.\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, 0);\n@@ -45,1 +95,1 @@\n-  int wake_if_needed();\n+  Cell& tag_to_cell(int tag) { return _cells[tag & (CELLS_COUNT - 1)]; }\n@@ -47,2 +97,2 @@\n- public:\n-  GenericWaitBarrier() : _barrier_tag(0), _waiters(0), _barrier_threads(0), _sem_barrier(0) {}\n+public:\n+  GenericWaitBarrier() : _cells(), _barrier_tag(0) {}\n@@ -51,1 +101,1 @@\n-  const char* description() { return \"semaphore\"; }\n+  const char* description() { return \"striped semaphore\"; }\n","filename":"src\/hotspot\/share\/utilities\/waitBarrier_generic.hpp","additions":62,"deletions":12,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, IBM Corp.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Note: the include below is not strictly required, as dependencies will be pulled using linker flags.\n+\/\/ Adding at least one #include removes unwanted warnings on some platforms.\n+#include <string.h>\n+#include <math.h>\n+\n+\/\/ Addresses of functions to be referenced using static linking.\n+void* funcs[] = {\n+    \/\/string.h\n+    &strlen,\n+    &strcat,\n+    \/\/math.h\n+    &abs,\n+    &fabs,\n+    &fabsf,\n+    &fabsl,\n+    &fmod,\n+    &fmodf,\n+    &fmodl,\n+    &remainder,\n+    &remainderf,\n+    &remainderl,\n+    &remquo,\n+    &remquof,\n+    &remquol,\n+    &fma,\n+    &fmaf,\n+    &fmal,\n+    &fmax,\n+    &fmaxf,\n+    &fmaxl,\n+    &fmin,\n+    &fminf,\n+    &fminl,\n+    &fdim,\n+    &fdimf,\n+    &fdiml,\n+    &nan,\n+    &nanf,\n+    &nanl,\n+    &exp,\n+    &expf,\n+    &expl,\n+    &exp2,\n+    &exp2f,\n+    &exp2l,\n+    &expm1,\n+    &expm1f,\n+    &expm1l,\n+    &log,\n+    &logf,\n+    &logl,\n+    &log10,\n+    &log10f,\n+    &log10l,\n+    &log2,\n+    &log2f,\n+    &log2l,\n+    &log1p,\n+    &log1pf,\n+    &log1pl,\n+    &pow,\n+    &powf,\n+    &powl,\n+    &sqrt,\n+    &sqrtf,\n+    &sqrtl,\n+    &cbrt,\n+    &cbrtf,\n+    &cbrtl,\n+    &hypot,\n+    &hypotf,\n+    &hypotl,\n+    &sin,\n+    &sinf,\n+    &sinl,\n+    &cos,\n+    &cosf,\n+    &cosl,\n+    &tan,\n+    &tanf,\n+    &tanl,\n+    &asin,\n+    &asinf,\n+    &asinl,\n+    &acos,\n+    &acosf,\n+    &acosl,\n+    &atan,\n+    &atanf,\n+    &atanl,\n+    &atan2,\n+    &atan2f,\n+    &atan2l,\n+    &sinh,\n+    &sinhf,\n+    &sinhl,\n+    &cosh,\n+    &coshf,\n+    &coshl,\n+    &tanh,\n+    &tanhf,\n+    &tanhl,\n+    &asinh,\n+    &asinhf,\n+    &asinhl,\n+    &acosh,\n+    &acoshf,\n+    &acoshl,\n+    &atanh,\n+    &atanhf,\n+    &atanhl,\n+    &erf,\n+    &erff,\n+    &erfl,\n+    &erfc,\n+    &erfcf,\n+    &erfcl,\n+    &tgamma,\n+    &tgammaf,\n+    &tgammal,\n+    &lgamma,\n+    &lgammaf,\n+    &lgammal,\n+    &ceil,\n+    &ceilf,\n+    &ceill,\n+    &floor,\n+    &floorf,\n+    &floorl,\n+    &trunc,\n+    &truncf,\n+    &truncl,\n+    &round,\n+    &roundf,\n+    &roundl,\n+    &lround,\n+    &lroundf,\n+    &lroundl,\n+    &llround,\n+    &llroundf,\n+    &llroundl,\n+    &nearbyint,\n+    &nearbyintf,\n+    &nearbyintl,\n+    &rintf,\n+    &rintl,\n+    &lrint,\n+    &lrintf,\n+    &lrintl,\n+    &llrint,\n+    &llrintf,\n+    &llrintl,\n+    &frexpf,\n+    &ldexpf,\n+    &modff,\n+    &scalbn,\n+    &scalbnf,\n+    &scalbnl,\n+    &scalbln,\n+    &scalblnf,\n+    &scalblnl,\n+    &ilogb,\n+    &ilogbf,\n+    &ilogbl,\n+    &logb,\n+    &logbf,\n+    &logbl,\n+    &nextafter,\n+    &nextafterf,\n+    &nextafterl,\n+    &nexttoward,\n+    &nexttowardf,\n+    &nexttowardl,\n+    &copysign,\n+    &copysignf,\n+    &copysignl,\n+    &isnan\n+};\n","filename":"src\/java.base\/aix\/native\/libsyslookup\/syslookup.c","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -237,1 +237,1 @@\n- * real number line).\n+ * real number line.)\n@@ -319,1 +319,1 @@\n- * while(d != 1.0) { \/\/ Surprising infinite loop\n+ * while (d != 1.0) { \/\/ Surprising infinite loop\n@@ -328,1 +328,1 @@\n- * for(int i = 0; i < 10; i++) {\n+ * for (int i = 0; i < 10; i++) {\n@@ -338,1 +338,1 @@\n- *  while(d <= 1.0) {\n+ *  while (d <= 1.0) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,0 +37,2 @@\n+import java.lang.reflect.AccessFlag;\n+import java.util.ArrayList;\n@@ -36,0 +41,2 @@\n+import java.util.Optional;\n+import java.util.function.BiPredicate;\n@@ -38,0 +45,3 @@\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.instruction.SwitchCase;\n@@ -40,0 +50,2 @@\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;\n@@ -57,4 +69,0 @@\n-    private static final MethodHandle INSTANCEOF_CHECK;\n-    private static final MethodHandle INTEGER_EQ_CHECK;\n-    private static final MethodHandle OBJECT_EQ_CHECK;\n-    private static final MethodHandle ENUM_EQ_CHECK;\n@@ -66,0 +74,3 @@\n+    private static final MethodTypeDesc TYPES_SWITCH_DESCRIPTOR =\n+            MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;ILjava\/util\/function\/BiPredicate;Ljava\/util\/List;)I\");\n+\n@@ -68,9 +79,0 @@\n-            INSTANCEOF_CHECK = MethodHandles.permuteArguments(LOOKUP.findVirtual(Class.class, \"isInstance\",\n-                                                                                 MethodType.methodType(boolean.class, Object.class)),\n-                                                              MethodType.methodType(boolean.class, Object.class, Class.class), 1, 0);\n-            INTEGER_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"integerEqCheck\",\n-                                           MethodType.methodType(boolean.class, Object.class, Integer.class));\n-            OBJECT_EQ_CHECK = LOOKUP.findStatic(Objects.class, \"equals\",\n-                                           MethodType.methodType(boolean.class, Object.class, Object.class));\n-            ENUM_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"enumEqCheck\",\n-                                           MethodType.methodType(boolean.class, Object.class, EnumDesc.class, MethodHandles.Lookup.class, ResolvedEnumLabel.class));\n@@ -158,1 +160,3 @@\n-        MethodHandle target = createMethodHandleSwitch(lookup, labels);\n+        MethodHandle target = generateInnerClass(lookup, labels);\n+\n+        target = withIndexCheck(target, labels.length);\n@@ -176,73 +180,0 @@\n-    \/*\n-     * Construct test chains for labels inside switch, to handle switch repeats:\n-     * switch (idx) {\n-     *     case 0 -> if (selector matches label[0]) return 0; else if (selector matches label[1]) return 1; else ...\n-     *     case 1 -> if (selector matches label[1]) return 1; else ...\n-     *     ...\n-     * }\n-     *\/\n-    private static MethodHandle createRepeatIndexSwitch(MethodHandles.Lookup lookup, Object[] labels) {\n-        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n-        MethodHandle[] testChains = new MethodHandle[labels.length];\n-        List<Object> labelsList = List.of(labels).reversed();\n-\n-        for (int i = 0; i < labels.length; i++) {\n-            MethodHandle test = def;\n-            int idx = labels.length - 1;\n-            List<Object> currentLabels = labelsList.subList(0, labels.length - i);\n-\n-            for (int j = 0; j < currentLabels.size(); j++, idx--) {\n-                Object currentLabel = currentLabels.get(j);\n-                if (j + 1 < currentLabels.size() && currentLabels.get(j + 1) == currentLabel) continue;\n-                MethodHandle currentTest;\n-                if (currentLabel instanceof Class<?>) {\n-                    currentTest = INSTANCEOF_CHECK;\n-                } else if (currentLabel instanceof Integer) {\n-                    currentTest = INTEGER_EQ_CHECK;\n-                } else if (currentLabel instanceof EnumDesc) {\n-                    currentTest = MethodHandles.insertArguments(ENUM_EQ_CHECK, 2, lookup, new ResolvedEnumLabel());\n-                } else {\n-                    currentTest = OBJECT_EQ_CHECK;\n-                }\n-                test = MethodHandles.guardWithTest(MethodHandles.insertArguments(currentTest, 1, currentLabel),\n-                                                   MethodHandles.dropArguments(MethodHandles.constant(int.class, idx), 0, Object.class),\n-                                                   test);\n-            }\n-            testChains[i] = MethodHandles.dropArguments(test, 0, int.class);\n-        }\n-\n-        return MethodHandles.tableSwitch(MethodHandles.dropArguments(def, 0, int.class), testChains);\n-    }\n-\n-    \/*\n-     * Construct code that maps the given selector and repeat index to a case label number:\n-     * if (selector == null) return -1;\n-     * else return \"createRepeatIndexSwitch(labels)\"\n-     *\/\n-    private static MethodHandle createMethodHandleSwitch(MethodHandles.Lookup lookup, Object[] labels) {\n-        MethodHandle mainTest;\n-        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n-        if (labels.length > 0) {\n-            mainTest = createRepeatIndexSwitch(lookup, labels);\n-        } else {\n-            mainTest = MethodHandles.dropArguments(def, 0, int.class);\n-        }\n-        MethodHandle body =\n-                MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),\n-                                            MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, Object.class),\n-                                            mainTest);\n-        MethodHandle switchImpl =\n-                MethodHandles.permuteArguments(body, MethodType.methodType(int.class, Object.class, int.class), 1, 0);\n-        return withIndexCheck(switchImpl, labels.length);\n-    }\n-\n-    private static boolean integerEqCheck(Object value, Integer constant) {\n-        if (value instanceof Number input && constant.intValue() == input.intValue()) {\n-            return true;\n-        } else if (value instanceof Character input && constant.intValue() == input.charValue()) {\n-            return true;\n-        }\n-\n-        return false;\n-    }\n-\n@@ -333,1 +264,1 @@\n-            \/\/else return \"createRepeatIndexSwitch(labels)\"\n+            \/\/else return \"typeSwitch(labels)\"\n@@ -338,1 +269,1 @@\n-                                                                            createRepeatIndexSwitch(lookup, labels),\n+                                                                            generateInnerClass(lookup, labels),\n@@ -342,1 +273,1 @@\n-            target = createMethodHandleSwitch(lookup, labels);\n+            target = generateInnerClass(lookup, labels);\n@@ -363,1 +294,1 @@\n-            return EnumDesc.of(enumClassTemplate.describeConstable().get(), (String) label);\n+            return EnumDesc.of(enumClassTemplate.describeConstable().orElseThrow(), (String) label);\n@@ -392,8 +323,2 @@\n-    private static boolean enumEqCheck(Object value, EnumDesc<?> label, MethodHandles.Lookup lookup, ResolvedEnumLabel resolvedEnum) {\n-        if (resolvedEnum.resolvedEnum == null) {\n-            Object resolved;\n-\n-            try {\n-                if (!(value instanceof Enum<?> enumValue)) {\n-                    return false;\n-                }\n+    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n+        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n@@ -401,1 +326,2 @@\n-                Class<?> clazz = label.constantType().resolveConstantDesc(lookup);\n+        return MethodHandles.filterArguments(target, 1, checkIndex);\n+    }\n@@ -403,3 +329,1 @@\n-                if (enumValue.getDeclaringClass() != clazz) {\n-                    return false;\n-                }\n+    private static final class ResolvedEnumLabels implements BiPredicate<Integer, Object> {\n@@ -407,4 +331,4 @@\n-                resolved = label.resolveConstantDesc(lookup);\n-            } catch (IllegalArgumentException | ReflectiveOperationException ex) {\n-                resolved = SENTINEL;\n-            }\n+        private final MethodHandles.Lookup lookup;\n+        private final EnumDesc<?>[] enumDescs;\n+        @Stable\n+        private Object[] resolvedEnum;\n@@ -412,1 +336,4 @@\n-            resolvedEnum.resolvedEnum = resolved;\n+        public ResolvedEnumLabels(MethodHandles.Lookup lookup, EnumDesc<?>[] enumDescs) {\n+            this.lookup = lookup;\n+            this.enumDescs = enumDescs;\n+            this.resolvedEnum = new Object[enumDescs.length];\n@@ -415,2 +342,3 @@\n-        return value == resolvedEnum.resolvedEnum;\n-    }\n+        @Override\n+        public boolean test(Integer labelIndex, Object value) {\n+            Object result = resolvedEnum[labelIndex];\n@@ -418,2 +346,5 @@\n-    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n-        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n+            if (result == null) {\n+                try {\n+                    if (!(value instanceof Enum<?> enumValue)) {\n+                        return false;\n+                    }\n@@ -421,2 +352,2 @@\n-        return MethodHandles.filterArguments(target, 1, checkIndex);\n-    }\n+                    EnumDesc<?> label = enumDescs[labelIndex];\n+                    Class<?> clazz = label.constantType().resolveConstantDesc(lookup);\n@@ -424,3 +355,14 @@\n-    private static final class ResolvedEnumLabel {\n-        @Stable\n-        public Object resolvedEnum;\n+                    if (enumValue.getDeclaringClass() != clazz) {\n+                        return false;\n+                    }\n+\n+                    result = label.resolveConstantDesc(lookup);\n+                } catch (IllegalArgumentException | ReflectiveOperationException ex) {\n+                    result = SENTINEL;\n+                }\n+\n+                resolvedEnum[labelIndex] = result;\n+            }\n+\n+            return result == value;\n+        }\n@@ -433,0 +375,169 @@\n+\n+    \/*\n+     * Construct test chains for labels inside switch, to handle switch repeats:\n+     * switch (idx) {\n+     *     case 0 -> if (selector matches label[0]) return 0;\n+     *     case 1 -> if (selector matches label[1]) return 1;\n+     *     ...\n+     * }\n+     *\/\n+    @SuppressWarnings(\"removal\")\n+    private static MethodHandle generateInnerClass(MethodHandles.Lookup caller, Object[] labels) {\n+        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n+        List<Class<?>> extraClassLabels = new ArrayList<>();\n+\n+        byte[] classBytes = Classfile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())), clb -> {\n+            clb.withFlags(AccessFlag.FINAL, AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n+               .withMethodBody(\"typeSwitch\",\n+                               TYPES_SWITCH_DESCRIPTOR,\n+                               Classfile.ACC_FINAL | Classfile.ACC_PUBLIC | Classfile.ACC_STATIC,\n+                               cb -> {\n+                    cb.aload(0);\n+                    Label nonNullLabel = cb.newLabel();\n+                    cb.if_nonnull(nonNullLabel);\n+                    cb.iconst_m1();\n+                    cb.ireturn();\n+                    cb.labelBinding(nonNullLabel);\n+                    if (labels.length == 0) {\n+                        cb.constantInstruction(0)\n+                          .ireturn();\n+                        return ;\n+                    }\n+                    cb.iload(1);\n+                    Label dflt = cb.newLabel();\n+                    record Element(Label target, Label next, Object caseLabel) {}\n+                    List<Element> cases = new ArrayList<>();\n+                    List<SwitchCase> switchCases = new ArrayList<>();\n+                    Object lastLabel = null;\n+                    for (int idx = labels.length - 1; idx >= 0; idx--) {\n+                        Object currentLabel = labels[idx];\n+                        Label target = cb.newLabel();\n+                        Label next;\n+                        if (lastLabel == null) {\n+                            next = dflt;\n+                        } else if (lastLabel.equals(currentLabel)) {\n+                            next = cases.getLast().next();\n+                        } else {\n+                            next = cases.getLast().target();\n+                        }\n+                        lastLabel = currentLabel;\n+                        cases.add(new Element(target, next, currentLabel));\n+                        switchCases.add(SwitchCase.of(idx, target));\n+                    }\n+                    cases = cases.reversed();\n+                    switchCases = switchCases.reversed();\n+                    cb.tableswitch(0, labels.length - 1, dflt, switchCases);\n+                    for (int idx = 0; idx < cases.size(); idx++) {\n+                        Element element = cases.get(idx);\n+                        Label next = element.next();\n+                        cb.labelBinding(element.target());\n+                        if (element.caseLabel() instanceof Class<?> classLabel) {\n+                            Optional<ClassDesc> classLabelConstableOpt = classLabel.describeConstable();\n+                            if (classLabelConstableOpt.isPresent()) {\n+                                cb.aload(0);\n+                                cb.instanceof_(classLabelConstableOpt.orElseThrow());\n+                                cb.ifeq(next);\n+                            } else {\n+                                cb.aload(3);\n+                                cb.constantInstruction(extraClassLabels.size());\n+                                cb.invokeinterface(ConstantDescs.CD_List,\n+                                                   \"get\",\n+                                                   MethodTypeDesc.of(ConstantDescs.CD_Object,\n+                                                                     ConstantDescs.CD_int));\n+                                cb.checkcast(ConstantDescs.CD_Class);\n+                                cb.aload(0);\n+                                cb.invokevirtual(ConstantDescs.CD_Class,\n+                                                 \"isInstance\",\n+                                                 MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                                   ConstantDescs.CD_Object));\n+                                cb.ifeq(next);\n+                                extraClassLabels.add(classLabel);\n+                            }\n+                        } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n+                            int enumIdx = enumDescs.size();\n+                            enumDescs.add(enumLabel);\n+                            cb.aload(2);\n+                            cb.constantInstruction(enumIdx);\n+                            cb.invokestatic(ConstantDescs.CD_Integer,\n+                                            \"valueOf\",\n+                                            MethodTypeDesc.of(ConstantDescs.CD_Integer,\n+                                                              ConstantDescs.CD_int));\n+                            cb.aload(0);\n+                            cb.invokeinterface(BiPredicate.class.describeConstable().orElseThrow(),\n+                                               \"test\",\n+                                               MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                                 ConstantDescs.CD_Object,\n+                                                                 ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                        } else if (element.caseLabel() instanceof String stringLabel) {\n+                            cb.ldc(stringLabel);\n+                            cb.aload(0);\n+                            cb.invokevirtual(ConstantDescs.CD_Object,\n+                                             \"equals\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                               ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                        } else if (element.caseLabel() instanceof Integer integerLabel) {\n+                            Label compare = cb.newLabel();\n+                            Label notNumber = cb.newLabel();\n+                            cb.aload(0);\n+                            cb.instanceof_(ConstantDescs.CD_Number);\n+                            cb.ifeq(notNumber);\n+                            cb.aload(0);\n+                            cb.checkcast(ConstantDescs.CD_Number);\n+                            cb.invokevirtual(ConstantDescs.CD_Number,\n+                                             \"intValue\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_int));\n+                            cb.goto_(compare);\n+                            cb.labelBinding(notNumber);\n+                            cb.aload(0);\n+                            cb.instanceof_(ConstantDescs.CD_Character);\n+                            cb.ifeq(next);\n+                            cb.aload(0);\n+                            cb.checkcast(ConstantDescs.CD_Character);\n+                            cb.invokevirtual(ConstantDescs.CD_Character,\n+                                             \"charValue\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_char));\n+                            cb.labelBinding(compare);\n+                            cb.ldc(integerLabel);\n+                            cb.if_icmpne(next);\n+                        } else {\n+                            throw new InternalError(\"Unsupported label type: \" +\n+                                                    element.caseLabel().getClass());\n+                        }\n+                        cb.constantInstruction(idx);\n+                        cb.ireturn();\n+                    }\n+                    cb.labelBinding(dflt);\n+                    cb.constantInstruction(cases.size());\n+                    cb.ireturn();\n+                });\n+        });\n+\n+        try {\n+            \/\/ this class is linked at the indy callsite; so define a hidden nestmate\n+            MethodHandles.Lookup lookup;\n+            lookup = caller.defineHiddenClass(classBytes, true, NESTMATE, STRONG);\n+            MethodHandle typeSwitch = lookup.findStatic(lookup.lookupClass(),\n+                                                        \"typeSwitch\",\n+                                                        MethodType.methodType(int.class,\n+                                                                              Object.class,\n+                                                                              int.class,\n+                                                                              BiPredicate.class,\n+                                                                              List.class));\n+            return MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(EnumDesc[]::new)),\n+                                                                List.copyOf(extraClassLabels));\n+        } catch (Throwable t) {\n+            throw new IllegalArgumentException(t);\n+        }\n+    }\n+\n+    \/\/based on src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java:\n+    private static String typeSwitchClassName(Class<?> targetClass) {\n+        String name = targetClass.getName();\n+        if (targetClass.isHidden()) {\n+            \/\/ use the original class name\n+            name = name.replace('\/', '_');\n+        }\n+        return name + \"$$TypeSwitch\";\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":228,"deletions":117,"binary":false,"changes":345,"status":"modified"},{"patch":"@@ -607,0 +607,6 @@\n+     * <p>If the socket was initially bound to the wildcard address and\n+     * is now {@link #isConnected connected}, then the address returned\n+     * may be the local address selected as the source address for\n+     * datagrams sent on this socket instead of the wildcard address.\n+     * When {@link #disconnect()} is called, the bound address reverts\n+     * to the wildcard address.\n@@ -717,0 +723,6 @@\n+     * <p>If the socket was initially bound to the wildcard address and\n+     * is now {@link #isConnected connected}, then the address returned\n+     * may be the local address selected as the source address for\n+     * datagrams sent on the socket instead of the wildcard address.\n+     * When {@link #disconnect()} is called, the bound address reverts\n+     * to the wildcard address.\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocket.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+     * @throws IllegalArgumentException if the implementation encounters malformed\n+     * escape sequences\n@@ -116,3 +118,0 @@\n-     * @implNote This implementation will throw an {@link java.lang.IllegalArgumentException}\n-     * when illegal strings are encountered.\n-     *\n@@ -127,0 +126,2 @@\n+     * @throws IllegalArgumentException if the implementation encounters malformed\n+     * escape sequences\n@@ -147,2 +148,4 @@\n-     * what characters are represented by any consecutive sequences of the\n-     * form \"<i>{@code %xy}<\/i>\".\n+     * what characters are represented by any consecutive escape sequences of\n+     * the form \"<i>{@code %xy}<\/i>\". Erroneous bytes are replaced with the\n+     * supplied {@code Charset}'s {@linkplain java.nio.charset.CharsetDecoder##cae\n+     * replacement value}.\n@@ -156,3 +159,0 @@\n-     * @implNote This implementation will throw an {@link java.lang.IllegalArgumentException}\n-     * when illegal strings are encountered.\n-     *\n@@ -163,2 +163,2 @@\n-     * @throws IllegalArgumentException if the implementation encounters illegal\n-     * characters\n+     * @throws IllegalArgumentException if the implementation encounters malformed\n+     * escape sequences\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLDecoder.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -203,1 +203,6 @@\n-     * <em><strong>Note:<\/strong> The <a href=\n+     * If the input string is malformed, or if the input cannot be mapped\n+     * to a valid byte sequence in the given {@code Charset}, then the\n+     * erroneous input will be replaced with the {@code Charset}'s\n+     * {@linkplain CharsetEncoder##cae replacement values}.\n+     *\n+     * @apiNote The <a href=\n@@ -206,2 +211,1 @@\n-     * UTF-8 should be used. Not doing so may introduce incompatibilities.<\/em>\n-     *\n+     * UTF-8 should be used. Not doing so may introduce incompatibilities.\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLEncoder.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -648,0 +648,7 @@\n+     * If the channel's socket was initially bound to the wildcard address and\n+     * is now {@link #isConnected connected}, then the address returned\n+     * may be the local address selected as the source address for\n+     * datagrams sent via this channel instead of the wildcard address.\n+     * When {@link #disconnect} is called, the bound address reverts\n+     * to the wildcard address.\n+     * <p>\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/DatagramChannel.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,14 +58,0 @@\n-    \/**\n-     * Records whether the underlying JVM supports lockless\n-     * compareAndSet for longs. While the intrinsic compareAndSetLong\n-     * method works in either case, some constructions should be\n-     * handled at Java level to avoid locking user-visible locks.\n-     *\/\n-    static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8();\n-\n-    \/**\n-     * Returns whether underlying JVM supports lockless CompareAndSet\n-     * for longs. Called only once and cached in VM_SUPPORTS_LONG_CAS.\n-     *\/\n-    private static native boolean VMSupportsCS8();\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicLong.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -93,4 +93,1 @@\n-        if (AtomicLong.VM_SUPPORTS_LONG_CAS)\n-            return new CASUpdater<U>(tclass, fieldName, caller);\n-        else\n-            return new LockedUpdater<U>(tclass, fieldName, caller);\n+        return new CASUpdater<U>(tclass, fieldName, caller);\n@@ -518,120 +515,0 @@\n-    private static final class LockedUpdater<T> extends AtomicLongFieldUpdater<T> {\n-        private static final Unsafe U = Unsafe.getUnsafe();\n-        private final long offset;\n-        \/**\n-         * if field is protected, the subclass constructing updater, else\n-         * the same as tclass\n-         *\/\n-        private final Class<?> cclass;\n-        \/** class holding the field *\/\n-        private final Class<T> tclass;\n-\n-        @SuppressWarnings(\"removal\")\n-        LockedUpdater(final Class<T> tclass, final String fieldName,\n-                      final Class<?> caller) {\n-            final Field field;\n-            final int modifiers;\n-            try {\n-                field = AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<Field>() {\n-                        public Field run() throws NoSuchFieldException {\n-                            return tclass.getDeclaredField(fieldName);\n-                        }\n-                    });\n-                modifiers = field.getModifiers();\n-                sun.reflect.misc.ReflectUtil.ensureMemberAccess(\n-                    caller, tclass, null, modifiers);\n-                ClassLoader cl = tclass.getClassLoader();\n-                ClassLoader ccl = caller.getClassLoader();\n-                if ((ccl != null) && (ccl != cl) &&\n-                    ((cl == null) || !isAncestor(cl, ccl))) {\n-                    sun.reflect.misc.ReflectUtil.checkPackageAccess(tclass);\n-                }\n-            } catch (PrivilegedActionException pae) {\n-                throw new RuntimeException(pae.getException());\n-            } catch (Exception ex) {\n-                throw new RuntimeException(ex);\n-            }\n-\n-            if (field.getType() != long.class)\n-                throw new IllegalArgumentException(\"Must be long type\");\n-\n-            if (!Modifier.isVolatile(modifiers))\n-                throw new IllegalArgumentException(\"Must be volatile type\");\n-\n-            \/\/ Access to protected field members is restricted to receivers only\n-            \/\/ of the accessing class, or one of its subclasses, and the\n-            \/\/ accessing class must in turn be a subclass (or package sibling)\n-            \/\/ of the protected member's defining class.\n-            \/\/ If the updater refers to a protected field of a declaring class\n-            \/\/ outside the current package, the receiver argument will be\n-            \/\/ narrowed to the type of the accessing class.\n-            this.cclass = (Modifier.isProtected(modifiers) &&\n-                           tclass.isAssignableFrom(caller) &&\n-                           !isSamePackage(tclass, caller))\n-                          ? caller : tclass;\n-            this.tclass = tclass;\n-            this.offset = U.objectFieldOffset(field);\n-        }\n-\n-        \/**\n-         * Checks that target argument is instance of cclass.  On\n-         * failure, throws cause.\n-         *\/\n-        private final void accessCheck(T obj) {\n-            if (!cclass.isInstance(obj))\n-                throw accessCheckException(obj);\n-        }\n-\n-        \/**\n-         * Returns access exception if accessCheck failed due to\n-         * protected access, else ClassCastException.\n-         *\/\n-        private final RuntimeException accessCheckException(T obj) {\n-            if (cclass == tclass)\n-                return new ClassCastException();\n-            else\n-                return new RuntimeException(\n-                    new IllegalAccessException(\n-                        \"Class \" +\n-                        cclass.getName() +\n-                        \" can not access a protected member of class \" +\n-                        tclass.getName() +\n-                        \" using an instance of \" +\n-                        obj.getClass().getName()));\n-        }\n-\n-        public final boolean compareAndSet(T obj, long expect, long update) {\n-            accessCheck(obj);\n-            synchronized (this) {\n-                long v = U.getLong(obj, offset);\n-                if (v != expect)\n-                    return false;\n-                U.putLong(obj, offset, update);\n-                return true;\n-            }\n-        }\n-\n-        public final boolean weakCompareAndSet(T obj, long expect, long update) {\n-            return compareAndSet(obj, expect, update);\n-        }\n-\n-        public final void set(T obj, long newValue) {\n-            accessCheck(obj);\n-            synchronized (this) {\n-                U.putLong(obj, offset, newValue);\n-            }\n-        }\n-\n-        public final void lazySet(T obj, long newValue) {\n-            set(obj, newValue);\n-        }\n-\n-        public final long get(T obj) {\n-            accessCheck(obj);\n-            synchronized (this) {\n-                return U.getLong(obj, offset);\n-            }\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicLongFieldUpdater.java","additions":1,"deletions":124,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- *    {@snippet :\n+ *    {@snippet lang=\"java\" :\n@@ -59,1 +59,1 @@\n- *          while((ze= zis.getNextEntry()) != null) {\n+ *          while ((ze = zis.getNextEntry()) != null) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipInputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1397,1 +1397,1 @@\n-            if (sym.isArray()) {\n+            if (isArray()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-    static final int CLOSING = -1;\n-    static final int CLOSED = -2;\n+    static final int CLOSED = -1;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSING);\n+        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSED);\n@@ -86,5 +86,1 @@\n-        boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n-        STATE.setVolatile(this, success ? CLOSED : OPEN);\n-        if (!success) {\n-            throw alreadyAcquired(1);\n-        }\n+        SCOPED_MEMORY_ACCESS.closeScope(this, ALREADY_CLOSED);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n-    public boolean closeScope(MemorySessionImpl session) {\n-        return closeScope0(session);\n+    public void closeScope(MemorySessionImpl session, ScopedAccessError error) {\n+        closeScope0(session, error);\n@@ -90,1 +90,1 @@\n-    native boolean closeScope0(MemorySessionImpl session);\n+    native void closeScope0(MemorySessionImpl session, ScopedAccessError error);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -557,1 +557,1 @@\n-        String result = super.toString() + nkeys + \" pairs: \";\n+        String result = super.toString() + \" \" + nkeys + \" pairs: \";\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/MessageHeader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-        return super.useAuthCache() && cacheSPNEGO;\n+        return false;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/NegotiateAuthentication.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-\n@@ -177,1 +176,1 @@\n-            throw new SignatureException(\"Invalid key\");\n+            throw new SignatureException(\"Invalid key\", e);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs10\/PKCS10.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include <malloc.h>\n@@ -33,0 +32,1 @@\n+#include <stdlib.h>\n","filename":"src\/java.base\/share\/native\/libfallbackLinker\/fallbackLinker.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include <jvm.h>\n-#include \"java_util_concurrent_atomic_AtomicLong.h\"\n-\n-JNIEXPORT jboolean JNICALL\n-Java_java_util_concurrent_atomic_AtomicLong_VMSupportsCS8(JNIEnv *env, jclass cls)\n-{\n-    return JVM_SupportsCX8();\n-}\n","filename":"src\/java.base\/share\/native\/libjava\/AtomicLong.c","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -77,1 +77,2 @@\n-     *  22: tbd\n+     *  22: Unnamed Variables & Patterns (Statements before super(...)\n+     *      in Preview)\n@@ -395,1 +396,1 @@\n-     * Record Patterns<\/a>\n+     * JEP 440: Record Patterns<\/a>\n@@ -397,1 +398,1 @@\n-     * Pattern Matching for switch<\/a>\n+     * JEP 441: Pattern Matching for switch<\/a>\n@@ -405,0 +406,3 @@\n+     * Additions in this release include unnamed variables and unnamed\n+     * patterns.\n+     *\n@@ -410,0 +414,2 @@\n+     * @see <a href=\"https:\/\/openjdk.org\/jeps\/456\">\n+     * JEP 456: Unnamed Variables &amp; Patterns<\/a>\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -218,3 +218,6 @@\n-        context.getPainter().paintProgressBarBackground(context,\n-                          g, 0, 0, c.getWidth(), c.getHeight(),\n-                          progressBar.getOrientation());\n+\n+        if (((JProgressBar) c).isBorderPainted()) {\n+            context.getPainter().paintProgressBarBackground(context,\n+                    g, 0, 0, c.getWidth(), c.getHeight(),\n+                    progressBar.getOrientation());\n+        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthProgressBarUI.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2968,0 +2968,11 @@\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(svalue);\n+        }\n+\n+        @Override\n+        public boolean equals(Object val) {\n+            return val instanceof CSS.BackgroundImage img\n+                   && Objects.equals(svalue, img.svalue);\n+        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/CSS.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-    ResponseTimerEvent responseTimerEvent;\n+    volatile ResponseTimerEvent responseTimerEvent;\n@@ -234,0 +234,1 @@\n+            responseTimerEvent = null;\n@@ -460,0 +461,1 @@\n+                            cancelTimer();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * @LastModified: July 2023\n+ * @LastModified: Nov 2023\n@@ -153,4 +153,1 @@\n-        for (CatalogFeatures.Feature f : CatalogFeatures.Feature.values()) {\n-            supportedProps.put(f.getPropertyName(), null);\n-        }\n-\n+        JdkXmlUtils.initCatalogFeatures(supportedProps);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/PropertyManager.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n- * @LastModified: July 2023\n+ * @LastModified: Nov 2023\n@@ -346,0 +346,7 @@\n+    \/**\n+     * Properties to determine whether to use a user-specified Catalog:\n+     * Feature USE_CATALOG, Resolve and Catalog File\n+     *\/\n+    protected boolean fUseCatalog = true;\n+    protected String fCatalogFile;\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/XMLDocumentFragmentScannerImpl.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import javax.xml.XMLConstants;\n@@ -49,0 +50,1 @@\n+import jdk.xml.internal.JdkXmlUtils;\n@@ -72,1 +74,1 @@\n- * @LastModified: July 2023\n+ * @LastModified: Nov 2023\n@@ -284,0 +286,3 @@\n+        fUseCatalog = (Boolean)propertyManager.getProperty(XMLConstants.USE_CATALOG);\n+        fCatalogFile = (String)propertyManager.getProperty(JdkXmlUtils.CATALOG_FILES);\n+\n@@ -330,0 +335,2 @@\n+        fUseCatalog = componentManager.getFeature(XMLConstants.USE_CATALOG, true);\n+        fCatalogFile = (String)componentManager.getProperty(JdkXmlUtils.CATALOG_FILES);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/XMLDocumentScannerImpl.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import jdk.xml.internal.JdkCatalog;\n@@ -96,1 +97,1 @@\n- * @LastModified: July 2023\n+ * @LastModified: Nov 2023\n@@ -268,3 +269,0 @@\n-    \/\/ should be diplayed trace resolving messages\n-    private static final boolean DEBUG_RESOLVER = false ;\n-\n@@ -358,0 +356,1 @@\n+    XMLSecurityPropertyManager fSecurityPropertyMgr;\n@@ -421,0 +420,1 @@\n+    \/\/ user-specified Catalog Resolver\n@@ -423,0 +423,2 @@\n+    \/\/ the default JDK Catalog Resolver\n+    CatalogResolver fDefCR;\n@@ -437,0 +439,4 @@\n+        this(null, new XMLSecurityManager(true));\n+    }\n+\n+    public XMLEntityManager(XMLSecurityPropertyManager securityPropertyMgr, XMLSecurityManager securityManager) {\n@@ -438,1 +444,2 @@\n-        fSecurityManager = new XMLSecurityManager(true);\n+        fSecurityManager = securityManager;\n+        fSecurityPropertyMgr = securityPropertyMgr;\n@@ -441,1 +448,1 @@\n-    } \/\/ <init>()\n+    }\n@@ -656,1 +663,5 @@\n-                    stream = connect.getInputStream();\n+                    if (expandedSystemId.startsWith(\"jrt:\/java.xml\")) {\n+                        stream = SecuritySupport.getInputStream(connect);\n+                    } else {\n+                        stream = connect.getInputStream();\n+                    }\n@@ -1015,3 +1026,0 @@\n-        if(DEBUG_RESOLVER){\n-            System.out.println(\"BEFORE Calling resolveEntity\") ;\n-        }\n@@ -1020,2 +1028,2 @@\n-        \/\/either of Stax or Xerces would be null\n-        if(fStaxEntityResolver != null){\n+        \/\/ Step 1: custom resolver, either StAX or Entity\n+        if (fStaxEntityResolver != null) {\n@@ -1023,1 +1031,4 @@\n-            if(staxInputSource != null) {\n+        } else if (fEntityResolver != null) {\n+            xmlInputSource = fEntityResolver.resolveEntity(ri);\n+            if (xmlInputSource != null) {\n+                \/\/wrap it in StaxXMLInputSource\n@@ -1025,0 +1036,1 @@\n+                staxInputSource = new StaxXMLInputSource(xmlInputSource, fISCreatedByResolver);\n@@ -1028,4 +1040,5 @@\n-        if(fEntityResolver != null){\n-            xmlInputSource = fEntityResolver.resolveEntity(ri);\n-            if(xmlInputSource != null) {\n-                fISCreatedByResolver = true;\n+        \/\/ Step 2: custom catalog if specified\n+        if (staxInputSource == null && (fUseCatalog && fCatalogFile != null)) {\n+            if (fCatalogResolver == null) {\n+                fCatalogFeatures = JdkXmlUtils.getCatalogFeatures(fDefer, fCatalogFile, fPrefer, fResolve);\n+                fCatalogResolver = CatalogManager.catalogResolver(fCatalogFeatures);\n@@ -1033,1 +1046,0 @@\n-        }\n@@ -1035,3 +1047,1 @@\n-        if(xmlInputSource != null){\n-            \/\/wrap this XMLInputSource to StaxInputSource\n-            staxInputSource = new StaxXMLInputSource(xmlInputSource, fISCreatedByResolver);\n+            staxInputSource = resolveWithCatalogStAX(fCatalogResolver, fCatalogFile, publicId, literalSystemId);\n@@ -1040,20 +1050,5 @@\n-        if (staxInputSource == null && fUseCatalog) {\n-            if (fCatalogFeatures == null) {\n-                fCatalogFeatures = JdkXmlUtils.getCatalogFeatures(fDefer, fCatalogFile, fPrefer, fResolve);\n-            }\n-            fCatalogFile = fCatalogFeatures.get(Feature.FILES);\n-            if (fCatalogFile != null) {\n-                try {\n-                    if (fCatalogResolver == null) {\n-                        fCatalogResolver = CatalogManager.catalogResolver(fCatalogFeatures);\n-                    }\n-                    InputSource is = fCatalogResolver.resolveEntity(publicId, literalSystemId);\n-                    if (is != null && !is.isEmpty()) {\n-                        staxInputSource = new StaxXMLInputSource(new XMLInputSource(is, true), true);\n-                    }\n-                } catch (CatalogException e) {\n-                    fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\"CatalogException\",\n-                    new Object[]{SecuritySupport.sanitizePath(fCatalogFile)},\n-                    XMLErrorReporter.SEVERITY_FATAL_ERROR, e );\n-                }\n-            }\n+        \/\/ Step 3: use the default JDK Catalog Resolver if Step 2's resolve is continue\n+        if (staxInputSource == null && JdkXmlUtils.isResolveContinue(fCatalogFeatures)) {\n+            initJdkCatalogResolver();\n+\n+            staxInputSource = resolveWithCatalogStAX(fDefCR, JdkCatalog.JDKCATALOG, publicId, literalSystemId);\n@@ -1062,7 +1057,6 @@\n-        \/\/ do default resolution\n-        \/\/this works for both stax & Xerces, if staxInputSource is null,\n-        \/\/it means parser need to revert to default resolution\n-        if (staxInputSource == null) {\n-            \/\/ REVISIT: when systemId is null, I think we should return null.\n-            \/\/          is this the right solution? -SG\n-            \/\/if (systemId != null)\n+        \/\/ Step 4: default resolution if not resolved by a resolver and the RESOLVE\n+        \/\/ feature is set to 'continue'\n+        if (staxInputSource != null) {\n+            fISCreatedByResolver = true;\n+        } else if (JdkXmlUtils.isResolveContinue(fCatalogFeatures) &&\n+                fSecurityManager.is(Limit.JDKCATALOG_RESOLVE, JdkConstants.CONTINUE)) {\n@@ -1071,2 +1065,0 @@\n-        }else if(staxInputSource.hasXMLStreamOrXMLEventReader()){\n-            \/\/Waiting for the clarification from EG. - nb\n@@ -1075,3 +1067,7 @@\n-        if (DEBUG_RESOLVER) {\n-            System.err.println(\"XMLEntityManager.resolveEntity(\" + publicId + \")\");\n-            System.err.println(\" = \" + xmlInputSource);\n+        return staxInputSource;\n+\n+    }\n+\n+    private void initJdkCatalogResolver() {\n+        if (fDefCR == null) {\n+            fDefCR = fSecurityManager.getJDKCatalogResolver();\n@@ -1079,0 +1075,1 @@\n+    }\n@@ -1080,1 +1077,13 @@\n-        return staxInputSource;\n+    \/**\n+     * Resolves the external resource using the Catalog specified and returns\n+     * a StaxXMLInputSource.\n+     *\/\n+    private StaxXMLInputSource resolveWithCatalogStAX(CatalogResolver cr, String cFile,\n+            String publicId, String systemId) {\n+        InputSource is = resolveWithCatalog(cr, cFile, publicId, systemId);\n+        \/\/ note that empty source isn't considered resolved\n+        if (is != null) {\n+            return new StaxXMLInputSource(new XMLInputSource(is, true), true);\n+        }\n+        return null;\n+    }\n@@ -1082,0 +1091,55 @@\n+    \/**\n+     * Resolves the external resource using the Catalog specified and returns\n+     * a InputSource.\n+     *\/\n+    private InputSource resolveWithCatalog(CatalogResolver cr, String cFile,\n+            String publicId, String systemId) {\n+        if (cr != null) {\n+            try {\n+                return cr.resolveEntity(publicId, systemId);\n+            } catch (CatalogException e) {\n+                fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\"CatalogException\",\n+                        new Object[]{SecuritySupport.sanitizePath(cFile)},\n+                        XMLErrorReporter.SEVERITY_FATAL_ERROR, e );\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Resolves the external resource using the Catalog specified and returns\n+     * a XMLInputSource. Since the Resolve method can be called from various processors,\n+     * this method attempts to resolve the resource as an EntityResolver first\n+     * and then URIResolver if no match is found.\n+     *\/\n+    private XMLInputSource resolveEntityOrURI(CatalogResolver cr, String publicId, String systemId, String base) {\n+        XMLInputSource xis = resolveEntity(cr, publicId, systemId, base);\n+\n+        if (xis != null) {\n+            return xis;\n+        } else if (systemId != null) {\n+            Source source = null;\n+            try {\n+                source = cr.resolve(systemId, base);\n+            } catch (CatalogException e) {\n+                throw new XNIException(e);\n+            }\n+            if (source != null && !source.isEmpty()) {\n+                return new XMLInputSource(publicId, source.getSystemId(), base, true);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private XMLInputSource resolveEntity(CatalogResolver cr, String publicId, String systemId, String base) {\n+        InputSource is = null;\n+        try {\n+            if (publicId != null || systemId != null) {\n+                is = cr.resolveEntity(publicId, systemId);\n+            }\n+        } catch (CatalogException e) {}\n+\n+        if (is != null && !is.isEmpty()) {\n+            return new XMLInputSource(is, true);\n+        }\n+        return null;\n@@ -1131,1 +1195,1 @@\n-        \/\/ give the entity resolver a chance\n+        \/\/ Step 1: custom Entity resolver\n@@ -1140,2 +1204,4 @@\n-        if (xmlInputSource == null && fUseCatalog) {\n-            if (fCatalogFeatures == null) {\n+        \/\/ Step 2: custom catalog if specified\n+        if ((publicId != null || literalSystemId != null || resourceIdentifier.getNamespace() !=null)\n+                && xmlInputSource == null && (fUseCatalog && fCatalogFile != null)) {\n+            if (fCatalogResolver == null) {\n@@ -1143,0 +1209,1 @@\n+                fCatalogResolver = CatalogManager.catalogResolver(fCatalogFeatures);\n@@ -1144,36 +1211,2 @@\n-            fCatalogFile = fCatalogFeatures.get(Feature.FILES);\n-            if (fCatalogFile != null) {\n-                \/*\n-                 since the method can be called from various processors, both\n-                 EntityResolver and URIResolver are used to attempt to find\n-                 a match\n-                *\/\n-                InputSource is = null;\n-                try {\n-                    if (fCatalogResolver == null) {\n-                        fCatalogResolver = CatalogManager.catalogResolver(fCatalogFeatures);\n-                    }\n-                    String pid = (publicId != null? publicId : resourceIdentifier.getNamespace());\n-                    if (pid != null || literalSystemId != null) {\n-                        is = fCatalogResolver.resolveEntity(pid, literalSystemId);\n-                    }\n-                } catch (CatalogException e) {}\n-\n-                if (is != null && !is.isEmpty()) {\n-                    xmlInputSource = new XMLInputSource(is, true);\n-                } else if (literalSystemId != null) {\n-                    if (fCatalogResolver == null) {\n-                        fCatalogResolver = CatalogManager.catalogResolver(fCatalogFeatures);\n-                    }\n-\n-                    Source source = null;\n-                    try {\n-                        source = fCatalogResolver.resolve(literalSystemId, baseSystemId);\n-                    } catch (CatalogException e) {\n-                        throw new XNIException(e);\n-                    }\n-                    if (source != null && !source.isEmpty()) {\n-                        xmlInputSource = new XMLInputSource(publicId, source.getSystemId(), baseSystemId, true);\n-                    }\n-                }\n-            }\n+            String pid = (publicId != null? publicId : resourceIdentifier.getNamespace());\n+            xmlInputSource = resolveEntityOrURI(fCatalogResolver, pid, literalSystemId, baseSystemId);\n@@ -1182,10 +1215,6 @@\n-        \/\/ do default resolution\n-        \/\/ REVISIT: what's the correct behavior if the user provided an entity\n-        \/\/ resolver (fEntityResolver != null), but resolveEntity doesn't return\n-        \/\/ an input source (xmlInputSource == null)?\n-        \/\/ do we do default resolution, or do we just return null? -SG\n-        if (xmlInputSource == null) {\n-            \/\/ REVISIT: when systemId is null, I think we should return null.\n-            \/\/          is this the right solution? -SG\n-            \/\/if (systemId != null)\n-            xmlInputSource = new XMLInputSource(publicId, literalSystemId, baseSystemId, false);\n+        \/\/ Step 3: use the default JDK Catalog Resolver if Step 2's resolve is continue\n+        if ((publicId != null || literalSystemId != null)\n+                && xmlInputSource == null && JdkXmlUtils.isResolveContinue(fCatalogFeatures)) {\n+            initJdkCatalogResolver();\n+            \/\/ unlike a custom catalog, the JDK Catalog only contains entity references\n+            xmlInputSource = resolveEntity(fDefCR, publicId, literalSystemId, baseSystemId);\n@@ -1194,3 +1223,5 @@\n-        if (DEBUG_RESOLVER) {\n-            System.err.println(\"XMLEntityManager.resolveEntity(\" + publicId + \")\");\n-            System.err.println(\" = \" + xmlInputSource);\n+        \/\/ Step 4: default resolution if not resolved by a resolver and the RESOLVE\n+        \/\/ feature is set to 'continue'\n+        if ((xmlInputSource == null) && JdkXmlUtils.isResolveContinue(fCatalogFeatures) &&\n+                fSecurityManager.is(Limit.JDKCATALOG_RESOLVE, JdkConstants.CONTINUE)) {\n+            xmlInputSource = new XMLInputSource(publicId, literalSystemId, baseSystemId, false);\n@@ -1414,1 +1445,1 @@\n-                                             XMLErrorReporter.SEVERITY_FATAL_ERROR );\n+                    XMLErrorReporter.SEVERITY_FATAL_ERROR );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/XMLEntityManager.java","additions":138,"deletions":107,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    public static synchronized final SchemaDVFactory getInstance() throws DVFactoryException {\n+    public static final SchemaDVFactory getInstance() throws DVFactoryException {\n@@ -69,1 +69,1 @@\n-    public static synchronized final SchemaDVFactory getInstance(String factoryClass) throws DVFactoryException {\n+    public static final SchemaDVFactory getInstance(String factoryClass) throws DVFactoryException {\n@@ -81,1 +81,1 @@\n-    protected SchemaDVFactory(){}\n+    protected SchemaDVFactory() {}\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/impl\/dv\/SchemaDVFactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n- * @LastModified: July 2023\n+ * @LastModified: Nov 2023\n@@ -405,1 +405,1 @@\n-            super();\n+            super(null, null, securityPropertyMgr, securityManager);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/jaxp\/SAXParserImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -165,3 +165,0 @@\n-        for (Feature f : Feature.values()) {\n-            fXMLSchemaLoader.setProperty(f.getPropertyName(), null);\n-        }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/jaxp\/validation\/XMLSchemaFactory.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @LastModified: Sep 2023\n+ * @LastModified: Nov 2023\n@@ -94,1 +94,1 @@\n-        initSecurityManager();\n+        initSecurityManager(null, null);\n@@ -101,1 +101,1 @@\n-        this(null, null);\n+        this(null, null, null, null);\n@@ -108,1 +108,1 @@\n-        this(symbolTable, null);\n+        this(symbolTable, null, null, null);\n@@ -116,0 +116,5 @@\n+        this(symbolTable, grammarPool, null, null);\n+    }\n+\n+    public SAXParser(SymbolTable symbolTable, XMLGrammarPool grammarPool,\n+            XMLSecurityPropertyManager securityPropertyMgr, XMLSecurityManager securityManager) {\n@@ -131,1 +136,1 @@\n-        initSecurityManager();\n+        initSecurityManager(securityPropertyMgr, securityManager);\n@@ -175,21 +180,0 @@\n-\n-    \/**\n-     * Initiates the SecurityManager. This becomes necessary when the SAXParser\n-     * is constructed directly by, for example, XMLReaderFactory rather than\n-     * through SAXParserFactory.\n-     *\/\n-    private void initSecurityManager() {\n-        try {\n-            if (securityManager == null) {\n-                securityManager = new XMLSecurityManager(true);\n-                super.setProperty(Constants.SECURITY_MANAGER, securityManager);\n-            }\n-\n-            if (securityPropertyManager == null) {\n-                securityPropertyManager = new XMLSecurityPropertyManager();\n-                super.setProperty(JdkConstants.XML_SECURITY_PROPERTY_MANAGER, securityPropertyManager);\n-            }\n-        } catch (SAXException e) {\n-            Utils.dPrint(() -> e.getMessage());\n-        }\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/parsers\/SAXParser.java","additions":10,"deletions":26,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +27,1 @@\n+import com.sun.org.apache.xerces.internal.utils.XMLSecurityPropertyManager;\n@@ -36,0 +36,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -43,0 +44,1 @@\n+ * @LastModified: Nov 2023\n@@ -91,1 +93,1 @@\n-        this(null, null, null);\n+        this(null, null, null, null, null);\n@@ -100,1 +102,1 @@\n-        this(symbolTable, null, null);\n+        this(symbolTable, null, null, null, null);\n@@ -114,1 +116,1 @@\n-        this(symbolTable, grammarPool, null);\n+        this(symbolTable, grammarPool, null, null, null);\n@@ -126,3 +128,1 @@\n-    public XIncludeAwareParserConfiguration(\n-            SymbolTable symbolTable,\n-            XMLGrammarPool grammarPool,\n+    public XIncludeAwareParserConfiguration(SymbolTable symbolTable, XMLGrammarPool grammarPool,\n@@ -130,1 +130,7 @@\n-        super(symbolTable, grammarPool, parentSettings);\n+        this(symbolTable, grammarPool, parentSettings, null, null);\n+    }\n+\n+    public XIncludeAwareParserConfiguration(SymbolTable symbolTable, XMLGrammarPool grammarPool,\n+            XMLComponentManager parentSettings, XMLSecurityPropertyManager securityPropertyMgr,\n+            XMLSecurityManager securityManager) {\n+        super(symbolTable, grammarPool, parentSettings, securityPropertyMgr, securityManager);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/parsers\/XIncludeAwareParserConfiguration.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import com.sun.org.apache.xerces.internal.utils.XMLSecurityPropertyManager;\n@@ -73,0 +74,1 @@\n+import jdk.xml.internal.XMLSecurityManager;\n@@ -81,1 +83,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Nov 2023\n@@ -435,1 +437,1 @@\n-        this(null, null, null);\n+        this(null, null, null, null, null);\n@@ -444,1 +446,1 @@\n-        this(symbolTable, null, null);\n+        this(symbolTable, null, null, null, null);\n@@ -459,1 +461,1 @@\n-        this(symbolTable, grammarPool, null);\n+        this(symbolTable, grammarPool, null, null, null);\n@@ -474,4 +476,8 @@\n-    public XML11Configuration(\n-        SymbolTable symbolTable,\n-        XMLGrammarPool grammarPool,\n-        XMLComponentManager parentSettings) {\n+    public XML11Configuration(SymbolTable symbolTable, XMLGrammarPool grammarPool,\n+            XMLComponentManager parentSettings) {\n+        this(symbolTable, grammarPool, parentSettings, null, null);\n+    }\n+\n+    public XML11Configuration(SymbolTable symbolTable, XMLGrammarPool grammarPool,\n+            XMLComponentManager parentSettings, XMLSecurityPropertyManager securityPropertyMgr,\n+            XMLSecurityManager securityManager) {\n@@ -595,1 +601,1 @@\n-        fEntityManager = new XMLEntityManager();\n+        fEntityManager = new XMLEntityManager(securityPropertyMgr, securityManager);\n@@ -643,5 +649,0 @@\n-        \/\/ Initialize Catalog features\n-        for( CatalogFeatures.Feature f : CatalogFeatures.Feature.values()) {\n-            fProperties.put(f.getPropertyName(), null);\n-        }\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/parsers\/XML11Configuration.java","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.xml.internal.Utils;\n@@ -32,0 +33,1 @@\n+import org.xml.sax.SAXException;\n@@ -51,1 +53,1 @@\n- * @LastModified: July 2023\n+ * @LastModified: Nov 2023\n@@ -130,9 +132,1 @@\n-        if (securityManager == null) {\n-            securityManager = new XMLSecurityManager(true);\n-            fConfiguration.setProperty(Constants.SECURITY_MANAGER, securityManager);\n-        }\n-        if (securityPropertyManager == null) {\n-            securityPropertyManager = new XMLSecurityPropertyManager();\n-            fConfiguration.setProperty(JdkConstants.XML_SECURITY_PROPERTY_MANAGER, securityPropertyManager);\n-        }\n-\n+        initSecurityManager(null, null);\n@@ -144,0 +138,17 @@\n+    \/**\n+     * Initiates the SecurityManager. This becomes necessary when the Parser\n+     * is constructed directly by, for example, XMLReaderFactory rather than\n+     * through SAXParserFactory.\n+     *\/\n+    void initSecurityManager(XMLSecurityPropertyManager spm, XMLSecurityManager sm) {\n+        if (securityManager == null) {\n+            securityManager = sm != null ? sm : new XMLSecurityManager(true);\n+        }\n+        fConfiguration.setProperty(Constants.SECURITY_MANAGER, securityManager);\n+\n+        if (securityPropertyManager == null) {\n+            securityPropertyManager = spm != null ? spm : new XMLSecurityPropertyManager();\n+        }\n+        fConfiguration.setProperty(JdkConstants.XML_SECURITY_PROPERTY_MANAGER, securityPropertyManager);\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/parsers\/XMLParser.java","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.xml.internal.JdkXmlUtils;\n@@ -45,1 +46,1 @@\n- * @LastModified: Apr 2019\n+ * @LastModified: Nov 2023\n@@ -100,0 +101,2 @@\n+        \/\/ Initialize Catalog features\n+        JdkXmlUtils.initCatalogFeatures(fProperties);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xerces\/internal\/util\/ParserConfigurationSettings.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-                        if (f1.isFile()) {\n+                        if (SecuritySupport.isFile(f1)) {\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/catalog\/Util.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.xml.internal;\n+\n+import java.net.URI;\n+import javax.xml.catalog.Catalog;\n+import javax.xml.catalog.CatalogFeatures;\n+import javax.xml.catalog.CatalogManager;\n+\n+\/**\n+ * Represents the built-in Catalog that hosts the DTDs for the Java platform.\n+ *\/\n+public class JdkCatalog {\n+    public static final String JDKCATALOG = \"\/jdk\/xml\/internal\/jdkcatalog\/JDKCatalog.xml\";\n+    private static final String JDKCATALOG_URL = SecuritySupport.getResource(JDKCATALOG).toExternalForm();\n+    public static Catalog catalog;\n+\n+    public static void init(String resolve) {\n+        if (catalog == null) {\n+            CatalogFeatures cf = JdkXmlUtils.getCatalogFeatures(null, JDKCATALOG_URL, null, resolve);\n+            catalog = CatalogManager.catalog(cf, URI.create(JDKCATALOG_URL));\n+        }\n+    }\n+}\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/JdkCatalog.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -294,0 +294,1 @@\n+     * @since 22\n@@ -302,0 +303,11 @@\n+    \/**\n+     * System Property for the JDKCatalog' RESOLVE property\n+     * @since 22\n+     *\/\n+    public static final String JDKCATALOG_RESOLVE = \"jdk.xml.jdkcatalog.resolve\";\n+\n+    \/\/ Catalog Resolve Integer mappings for String values\n+    public static final int CONTINUE = 0;\n+    \/\/public static final int IGNORE = 1; \/\/ same as that of DTD\n+    public static final int STRICT = 2;\n+\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/JdkConstants.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.Map;\n@@ -159,0 +160,25 @@\n+    \/**\n+     * Initialize catalog features, including setting the default values and reading\n+     * from the JAXP configuration file and System Properties.\n+     *\n+     * @param properties the Map object that holds the properties\n+     *\/\n+    public static void initCatalogFeatures(Map<String, Object> properties) {\n+        CatalogFeatures cf = getCatalogFeatures();\n+        for( CatalogFeatures.Feature f : CatalogFeatures.Feature.values()) {\n+            properties.put(f.getPropertyName(), cf.get(f));\n+        }\n+    }\n+\n+    \/**\n+     * Creates an instance of a CatalogFeatures with default settings.\n+     * Note: the CatalogFeatures is initialized with settings in the following\n+     * order:\n+     *     Default values -> values in the config -> values set with System Properties\n+     *\n+     * @return an instance of a CatalogFeatures\n+     *\/\n+    public static CatalogFeatures getCatalogFeatures() {\n+        return CatalogFeatures.builder().build();\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/JdkXmlUtils.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.net.URLConnection;\n@@ -269,0 +270,12 @@\n+    \/**\n+     * Tests whether the input is file.\n+     *\n+     * @param f the file to be tested\n+     * @return true if the input is file, false otherwise\n+     *\/\n+    @SuppressWarnings(\"removal\")\n+    public static boolean isFile(final File f) {\n+        return (AccessController.doPrivileged((PrivilegedAction<Boolean>) ()\n+                -> f.isFile()));\n+    }\n+\n@@ -286,0 +299,17 @@\n+    \/**\n+     * Returns an InputStream from a URLConnection.\n+     * @param uc the URLConnection\n+     * @return the InputStream\n+     * @throws IOException if an I\/O error occurs while creating the input stream\n+     *\/\n+    @SuppressWarnings(\"removal\")\n+    public static InputStream getInputStream(final URLConnection uc)\n+            throws IOException {\n+        try {\n+            return AccessController.doPrivileged((PrivilegedExceptionAction<InputStream>) ()\n+                    -> uc.getInputStream());\n+        } catch (PrivilegedActionException e) {\n+            throw (IOException) e.getException();\n+        }\n+    }\n+\n@@ -297,0 +327,11 @@\n+    \/**\n+     * Returns the resource by the name.\n+     * @param name the resource name\n+     * @return the resource\n+     *\/\n+    @SuppressWarnings(\"removal\")\n+    public static URL getResource(final String name) {\n+        return AccessController.doPrivileged((PrivilegedAction<URL>) () ->\n+                SecuritySupport.class.getResource(name));\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/SecuritySupport.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+import javax.xml.catalog.CatalogManager;\n+import javax.xml.catalog.CatalogResolver;\n+import javax.xml.catalog.CatalogResolver.NotFoundAction;\n@@ -70,0 +73,12 @@\n+    \/\/ Valid values for Catalog Resolve, and mappings between the string and\n+    \/\/ interger values\n+    static final Map<String, Integer> CR_MAP;\n+    \/\/ Source Level JDK 8\n+    static {\n+        Map<String, Integer> map = new HashMap<>();\n+        map.put(\"continue\", 0);\n+        map.put(\"ignore\", 1);\n+        map.put(\"strict\", 2);\n+        CR_MAP = Collections.unmodifiableMap(map);\n+    }\n+\n@@ -76,1 +91,1 @@\n-    \/\/ DTD value map\n+    \/\/ DTD value mapper\n@@ -79,0 +94,3 @@\n+    \/\/ Catalog Resolve value mapper\n+    private static final StringMapper CRMAPPER = new StringMapper(CR_MAP);\n+\n@@ -112,0 +130,2 @@\n+        JDKCATALOG_RESOLVE(\"JDKCatalogResolve\", JdkConstants.JDKCATALOG_RESOLVE, JdkConstants.JDKCATALOG_RESOLVE, null,\n+                JdkConstants.CONTINUE, JdkConstants.CONTINUE, Processor.PARSER, CRMAPPER),\n@@ -269,0 +289,42 @@\n+        \/\/ prepare the JDK Catalog\n+        prepareCatalog();\n+    }\n+\n+    \/**\n+     * Flag indicating whether the JDK Catalog has been initialized\n+     *\/\n+    static volatile boolean jdkcatalogInitialized = false;\n+    private final Object lock = new Object();\n+\n+    private void prepareCatalog() {\n+        if (!jdkcatalogInitialized) {\n+            synchronized (lock) {\n+                if (!jdkcatalogInitialized) {\n+                    jdkcatalogInitialized = true;\n+                    String resolve = getLimitValueAsString(Limit.JDKCATALOG_RESOLVE);\n+                    JdkCatalog.init(resolve);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns the JDKCatalogResolver with the current setting of the RESOLVE\n+     * property.\n+     *\n+     * @return the JDKCatalogResolver\n+     *\/\n+    public CatalogResolver getJDKCatalogResolver() {\n+        String resolve = getLimitValueAsString(Limit.JDKCATALOG_RESOLVE);\n+        return CatalogManager.catalogResolver(JdkCatalog.catalog, toActionType(resolve));\n+    }\n+\n+    \/\/ convert the string value of the RESOLVE property to the corresponding\n+    \/\/ action type\n+    private NotFoundAction toActionType(String resolve) {\n+        for (NotFoundAction type : NotFoundAction.values()) {\n+            if (type.toString().equals(resolve)) {\n+                return type;\n+            }\n+        }\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/XMLSecurityManager.java","additions":63,"deletions":1,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+-->\n+<!--\n+   Catalog of DTDs for the Java platform\n+\n+   @implNote: DTDs in the built-in catalog are resolved against its URI and the\n+              xml:base attribute. The preferences.dtd for example is resolved as:\n+\n+              jrt:\/java.xml\/jdk\/xml\/internal\/jdkcatalog\/java\/dtd\/preferences.dtd\n+-->\n+<catalog xmlns=\"urn:oasis:names:tc:entity:xmlns:xml:catalog\">\n+    <group id=\"javadtds\" prefer = \"system\" xml:base = \"java\/dtd\/\">\n+        <system systemId=\"http:\/\/java.sun.com\/dtd\/preferences.dtd\" uri=\"preferences.dtd\"\/>\n+        <system systemId=\"http:\/\/java.sun.com\/dtd\/properties.dtd\" uri=\"properties.dtd\"\/>\n+    <\/group>\n+<\/catalog>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/JDKCatalog.xml","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+<!--\n+Copyright 2001 Sun Microsystems, Inc. 901 San Antonio Road,\n+Palo Alto, CA  94303, U.S.A.  All rights reserved.\n+\n+This product or document is protected by copyright and distributed\n+under licenses restricting its use, copying, distribution, and\n+decompilation.  No part of this product or documentation may be\n+reproduced in any form by any means without prior written authorization\n+of Sun and its licensors, if any.\n+\n+Third party software, including font technology, is copyrighted and\n+licensed from Sun suppliers.\n+\n+Sun, Sun Microsystems, the Sun Logo, Solaris, Java, JavaServer Pages, Java\n+Naming and Directory Interface, JDBC, JDK, JavaMail and Enterprise JavaBeans,\n+are trademarks or registered trademarks of Sun Microsystems, Inc in the U.S.\n+and other countries.\n+\n+All SPARC trademarks are used under license and are trademarks\n+or registered trademarks of SPARC International, Inc.\n+in the U.S. and other countries. Products bearing SPARC\n+trademarks are based upon an architecture developed by Sun Microsystems, Inc.\n+\n+PostScript is a registered trademark of Adobe Systems, Inc.\n+\n+Federal Acquisitions: Commercial Software - Government Users Subject to\n+Standard License Terms and Conditions.\n+\n+DOCUMENTATION IS PROVIDED \"AS IS\" AND ALL EXPRESS OR IMPLIED\n+CONDITIONS, REPRESENTATIONS AND WARRANTIES, INCLUDING ANY\n+IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n+PURPOSE OR NON-INFRINGEMENT, ARE DISCLAIMED, EXCEPT\n+TO THE EXTENT THAT SUCH DISCLAIMERS ARE HELD TO BE LEGALLY\n+INVALID.\n+\n+_________________________________________________________________________\n+\n+Copyright 2000-2001 Sun Microsystems, Inc.,\n+901 San Antonio Road, Palo Alto, CA  94303, Etats-Unis.\n+Tous droits re'serve's.\n+\n+\n+Ce produit ou document est prote'ge' par un copyright et distribue' avec\n+des licences qui en restreignent l'utilisation, la copie, la distribution,\n+et la de'compilation.  Aucune partie de ce produit ou de sa documentation\n+associe'e ne peut e^tre reproduite sous aucune forme, par quelque moyen\n+que ce soit, sans l'autorisation pre'alable et e'crite de Sun et de ses\n+bailleurs de licence, s'il y en a.\n+\n+Le logiciel de'tenu par des tiers, et qui comprend la technologie\n+relative aux polices de caracte`res, est prote'ge' par un copyright\n+et licencie' par des fournisseurs de Sun.\n+\n+Sun, Sun Microsystems, le logo Sun, Solaris, Java, JavaServer Pages, Java\n+Naming and Directory Interface, JDBC, JDK, JavaMail, et Enterprise JavaBeans,\n+sont des marques de fabrique ou des marques de'pose'es de Sun\n+Microsystems, Inc. aux Etats-Unis et dans d'autres pays.\n+\n+Toutes les marques SPARC sont utilise'es sous licence et sont\n+des marques de fabrique ou des marques de'pose'es de SPARC\n+International, Inc. aux Etats-Unis et  dans\n+d'autres pays. Les produits portant les marques SPARC sont\n+base's sur une architecture de'veloppe'e par Sun Microsystems, Inc.\n+\n+Postcript est une marque enregistre'e d'Adobe Systems Inc.\n+\n+LA DOCUMENTATION EST FOURNIE \"EN L'ETAT\" ET TOUTES AUTRES CONDITIONS,\n+DECLARATIONS ET GARANTIES EXPRESSES OU TACITES SONT FORMELLEMENT EXCLUES,\n+DANS LA MESURE AUTORISEE PAR LA LOI APPLICABLE, Y COMPRIS NOTAMMENT\n+TOUTE GARANTIE IMPLICITE RELATIVE A LA QUALITE MARCHANDE, A L'APTITUDE\n+A UNE UTILISATION PARTICULIERE OU A L'ABSENCE DE CONTREFACON.\n+-->\n+\n+\n+<!-- DTD for a Preferences tree. -->\n+\n+<!-- The preferences element is at the root of an XML document\n+     representing a Preferences tree. -->\n+<!ELEMENT preferences (root)>\n+\n+<!-- The preferences element contains an optional version attribute,\n+      which specifies version of DTD. -->\n+<!ATTLIST preferences EXTERNAL_XML_VERSION CDATA \"0.0\" >  \n+\n+<!-- The root element has a map representing the root's preferences\n+     (if any), and one node for each child of the root (if any). -->\n+<!ELEMENT root (map, node*) >\n+\n+<!-- Additionally, the root contains a type attribute, which\n+     specifies whether it's the system or user root. -->\n+<!ATTLIST root\n+          type (system|user) #REQUIRED >\n+\n+<!-- Each node has a map representing its preferences (if any),\n+     and one node for each child (if any). -->\n+<!ELEMENT node (map, node*) >\n+\n+<!-- Additionally, each node has a name attribute -->\n+<!ATTLIST node\n+          name CDATA #REQUIRED >\n+\n+<!-- A map represents the preferences stored at a node (if any). -->\n+<!ELEMENT map (entry*) >\n+\n+<!-- An entry represents a single preference, which is simply\n+      a key-value pair. -->\n+<!ELEMENT entry EMPTY >\n+<!ATTLIST entry\n+          key   CDATA #REQUIRED\n+          value CDATA #REQUIRED >\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/java\/dtd\/preferences.dtd","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+<!--\n+   Copyright 2006 Sun Microsystems, Inc.  All rights reserved.\n+  -->\n+\n+<!-- DTD for properties -->\n+\n+<!ELEMENT properties ( comment?, entry* ) >\n+\n+<!ATTLIST properties version CDATA #FIXED \"1.0\">\n+\n+<!ELEMENT comment (#PCDATA) >\n+\n+<!ELEMENT entry (#PCDATA) >\n+\n+<!ATTLIST entry key CDATA #REQUIRED>\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/jdkcatalog\/java\/dtd\/properties.dtd","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -405,0 +405,5 @@\n+ * <li><a href=\"#JDKCATALOG\">JDK built-in Catalog<\/a>\n+ *      <ul>\n+ *      <li><a href=\"#JC_PROCESS\">External Resource Resolution Process with the built-in Catalog<\/a><\/li>\n+ *      <\/ul>\n+ * <\/li>\n@@ -414,0 +419,27 @@\n+ * <h2 id=\"JDKCATALOG\">JDK built-in Catalog<\/h2>\n+ * The JDK has a built-in catalog that hosts the following DTDs defined by the Java Platform:\n+ * <ul>\n+ * <li>DTD for {@link java.util.prefs.Preferences java.util.prefs.Preferences}, preferences.dtd<\/li>\n+ * <li>DTD for {@link java.util.Properties java.util.Properties}, properties.dtd<\/li>\n+ * <\/ul>\n+ * <p>\n+ * The catalog is loaded once when the first JAXP processor factory is created.\n+ *\n+ * <h3 id=\"JC_PROCESS\">External Resource Resolution Process with the built-in Catalog<\/h3>\n+ * The JDK creates a {@link javax.xml.catalog.CatalogResolver CatalogResolver}\n+ * with the built-in catalog when needed. This CatalogResolver is used as the\n+ * default external resource resolver.\n+ * <p>\n+ * XML processors may use resolvers (such as {@link org.xml.sax.EntityResolver EntityResolver},\n+ * {@link javax.xml.stream.XMLResolver XMLResolver}, and {@link javax.xml.catalog.CatalogResolver CatalogResolver})\n+ * to handle external references. In the absence of the user-defined resolvers,\n+ * the JDK XML processors fall back to the default CatalogResolver to attempt to\n+ * find a resolution before making a connection to fetch the resources. The fall-back\n+ * also takes place if a user-defined resolver exists but allows the process to\n+ * continue when unable to resolve the resource.\n+ * <p>\n+ * If the default CatalogResolver is unable to locate a resource, it may signal\n+ * the XML processors to continue processing, or skip the resource, or\n+ * throw a CatalogException. The behavior is configured with the\n+ * <a href=\"#JDKCATALOG_RESOLVE\">{@code jdk.xml.jdkcatalog.resolve}<\/a> property.\n+ *\n@@ -755,1 +787,1 @@\n- * <td style=\"text-align:center\" rowspan=\"4\">yes<\/td>\n+ * <td style=\"text-align:center\" rowspan=\"5\">yes<\/td>\n@@ -838,0 +870,34 @@\n+ *     <a href=\"#StAX\">StAX<\/a><br>\n+ *     <a href=\"#Validation\">Validation<\/a><br>\n+ *     <a href=\"#Transform\">Transform<\/a>\n+ * <\/td>\n+ * <td style=\"text-align:center\"><a href=\"#Processor\">Method 1<\/a><\/td>\n+ * <td style=\"text-align:center\">22<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <td id=\"JDKCATALOG_RESOLVE\">{@systemProperty jdk.xml.jdkcatalog.resolve}<\/td>\n+ * <td>Instructs the JDK default CatalogResolver to act in accordance with the setting\n+ * of this property when unable to resolve an external reference with the built-in Catalog.\n+ * The options are:\n+ * <ul>\n+ * <li><p>\n+ * {@code continue} -- Indicates that the processing should continue\n+ * <\/li>\n+ * <li><p>\n+ * {@code ignore} -- Indicates that the reference is skipped\n+ * <\/li>\n+ * <li><p>\n+ * {@code strict} -- Indicates that the resolver should throw a CatalogException\n+ * <\/li>\n+ * <\/ul>\n+ * <\/td>\n+ * <td style=\"text-align:center\">String<\/td>\n+ * <td>\n+ * {@code continue, ignore, and strict}. Values are case-insensitive.\n+ * <\/td>\n+ * <td style=\"text-align:center\">continue<\/td>\n+ * <td style=\"text-align:center\">No<\/td>\n+ * <td style=\"text-align:center\">Yes<\/td>\n+ * <td style=\"text-align:center\">\n+ *     <a href=\"#DOM\">DOM<\/a><br>\n+ *     <a href=\"#SAX\">SAX<\/a><br>\n","filename":"src\/java.xml\/share\/classes\/module-info.java","additions":67,"deletions":1,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -50,3 +50,3 @@\n-# For example, the FILES property in CatalogFeatures has an associated system\n-# property called javax.xml.catalog.files. An entry for the FILES property in the\n-# configuration file would therefore use javax.xml.catalog.files as the key, that\n+# For example, the RESOLVE property in CatalogFeatures has an associated system\n+# property called javax.xml.catalog.resolve. An entry for the RESOLVE property in the\n+# configuration file would therefore use javax.xml.catalog.resolve as the key, that\n@@ -54,1 +54,1 @@\n-#     javax.xml.catalog.files=strict\n+#     javax.xml.catalog.resolve=strict\n@@ -131,0 +131,18 @@\n+# Implementation Specific Properties - jdkcatalog.resolve\n+#\n+# This property instructs the JDK default CatalogResolver to act in accordance with\n+# the setting when unable to resolve an external reference with the built-in Catalog.\n+# The options are:\n+#     continue -- indicates that the processing should continue\n+#     ignore -- indicates that the reference is skipped\n+#     strict -- indicates that the resolver should throw a CatalogException\n+#\n+# The following setting would cause the resolve to throw a CatalogException when\n+# unable to resolve an external reference:\n+# jdk.xml.jdkcatalog.resolve=strict\n+#\n+# Implementation Specific Properties - DTD\n+#\n+# This property instructs the parsers to: deny, ignore or allow DTD processing.\n+# The following setting would cause the parser to reject DTD by throwing an exception.\n+# jdk.xml.dtd.support=deny\n","filename":"src\/java.xml\/share\/conf\/jaxp.properties","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -352,4 +352,0 @@\n-            this(option, false);\n-        }\n-\n-        LintCategory(String option, boolean hidden) {\n@@ -357,1 +353,0 @@\n-            this.hidden = hidden;\n@@ -366,1 +361,0 @@\n-        public final boolean hidden;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -214,0 +214,1 @@\n+            case SUPER_INIT -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -251,0 +251,1 @@\n+        SUPER_INIT(JDK22, Fragments.FeatureSuperInit, DiagKind.NORMAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -940,0 +940,2 @@\n+        boolean ctorProloguePrev = env.info.ctorPrologue;\n+        env.info.ctorPrologue = false;\n@@ -962,3 +964,2 @@\n-                \/\/ If this class appears as an anonymous class\n-                \/\/ in a superclass constructor call\n-                \/\/ disable implicit outer instance from being passed.\n+                \/\/ If this class appears as an anonymous class in a constructor\n+                \/\/ prologue, disable implicit outer instance from being passed.\n@@ -966,2 +967,1 @@\n-                if (env.info.isSelfCall &&\n-                        env.tree.hasTag(NEWCLASS)) {\n+                if (ctorProloguePrev && env.tree.hasTag(NEWCLASS)) {\n@@ -975,0 +975,1 @@\n+            env.info.ctorPrologue = ctorProloguePrev;\n@@ -984,0 +985,2 @@\n+        boolean ctorProloguePrev = env.info.ctorPrologue;\n+        env.info.ctorPrologue = false;\n@@ -1047,0 +1050,3 @@\n+            \/\/ Is this method a constructor?\n+            boolean isConstructor = TreeInfo.isConstructor(tree);\n+\n@@ -1074,1 +1080,1 @@\n-                if (tree.name == names.init) {\n+                if (isConstructor) {\n@@ -1077,5 +1083,2 @@\n-                        JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);\n-                        if (app == null ||\n-                                TreeInfo.name(app.meth) != names._this ||\n-                                !checkFirstConstructorStat(app, tree, false)) {\n-                            log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor(env.enclClass.sym));\n+                        if (!TreeInfo.hasConstructorCall(tree, names._this)) {\n+                            log.error(tree, Errors.NonCanonicalConstructorInvokeAnotherConstructor(env.enclClass.sym));\n@@ -1107,5 +1110,1 @@\n-                            JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);\n-                            if (app != null &&\n-                                    (TreeInfo.name(app.meth) == names._this ||\n-                                            TreeInfo.name(app.meth) == names._super) &&\n-                                    checkFirstConstructorStat(app, tree, false)) {\n+                            if (TreeInfo.hasAnyConstructorCall(tree)) {\n@@ -1189,5 +1188,3 @@\n-                if (tree.name == names.init && owner.type != syms.objectType) {\n-                    JCBlock body = tree.body;\n-                    if (body.stats.isEmpty() ||\n-                            TreeInfo.getConstructorInvocationName(body.stats, names) == names.empty) {\n-                        JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),\n+                if (isConstructor && owner.type != syms.objectType) {\n+                    if (!TreeInfo.hasAnyConstructorCall(tree)) {\n+                        JCStatement supCall = make.at(tree.body.pos).Exec(make.Apply(List.nil(),\n@@ -1195,1 +1192,1 @@\n-                        body.stats = body.stats.prepend(supCall);\n+                        tree.body.stats = tree.body.stats.prepend(supCall);\n@@ -1198,1 +1195,1 @@\n-                            TreeInfo.isSuperCall(body.stats.head)) {\n+                            TreeInfo.hasConstructorCall(tree, names._super)) {\n@@ -1228,0 +1225,3 @@\n+                \/\/ Start of constructor prologue\n+                localEnv.info.ctorPrologue = isConstructor;\n+\n@@ -1237,0 +1237,1 @@\n+            env.info.ctorPrologue = ctorProloguePrev;\n@@ -2521,7 +2522,0 @@\n-            \/\/ We are seeing a ...this(...) or ...super(...) call.\n-            \/\/ Check that this is the first statement in a constructor.\n-            checkFirstConstructorStat(tree, env.enclMethod, true);\n-\n-            \/\/ Record the fact\n-            \/\/ that this is a constructor call (using isSelfCall).\n-            localEnv.info.isSelfCall = true;\n@@ -2530,1 +2524,0 @@\n-            localEnv.info.constructorArgs = true;\n@@ -2532,1 +2525,0 @@\n-            localEnv.info.constructorArgs = false;\n@@ -2536,0 +2528,3 @@\n+            \/\/ Done with this()\/super() parameters. End of constructor prologue.\n+            env.info.ctorPrologue = false;\n+\n@@ -2664,20 +2659,0 @@\n-        \/** Check that given application node appears as first statement\n-         *  in a constructor call.\n-         *  @param tree          The application node\n-         *  @param enclMethod    The enclosing method of the application.\n-         *  @param error         Should an error be issued?\n-         *\/\n-        boolean checkFirstConstructorStat(JCMethodInvocation tree, JCMethodDecl enclMethod, boolean error) {\n-            if (enclMethod != null && enclMethod.name == names.init) {\n-                JCBlock body = enclMethod.body;\n-                if (body.stats.head.hasTag(EXEC) &&\n-                    ((JCExpressionStatement) body.stats.head).expr == tree)\n-                    return true;\n-            }\n-            if (error) {\n-                log.error(tree.pos(),\n-                        Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));\n-            }\n-            return false;\n-        }\n-\n@@ -4356,10 +4331,0 @@\n-        \/\/ In a constructor body,\n-        \/\/ if symbol is a field or instance method, check that it is\n-        \/\/ not accessed before the supertype constructor is called.\n-        if (symEnv.info.isSelfCall &&\n-            sym.kind.matches(KindSelector.VAL_MTH) &&\n-            sym.owner.kind == TYP &&\n-            (sym.flags() & STATIC) == 0) {\n-            chk.earlyRefError(tree.pos(), sym.kind == VAR ?\n-                                          sym : thisSym(tree.pos(), env));\n-        }\n@@ -4477,12 +4442,1 @@\n-            if (sym.name == names._this || sym.name == names._super) {\n-                \/\/ If `C' is the currently compiled class, check that\n-                \/\/ `C.this' does not appear in an explicit call to a constructor\n-                \/\/ also make sure that `super` is not used in constructor invocations\n-                if (env.info.isSelfCall &&\n-                        ((sym.name == names._this &&\n-                        site.tsym == env.enclClass.sym) ||\n-                        sym.name == names._super && env.info.constructorArgs &&\n-                        (sitesym.isInterface() || site.tsym == env.enclClass.sym))) {\n-                    chk.earlyRefError(tree.pos(), sym);\n-                }\n-            } else {\n+            if (sym.name != names._this && sym.name != names._super) {\n@@ -5677,0 +5631,3 @@\n+        \/\/ Check for proper placement of super()\/this() calls.\n+        chk.checkSuperInitCalls(tree);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":31,"deletions":74,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    \/** Is this an environment for a this(...) or super(...) call?\n+    \/** Are we in the 'prologue' part of a constructor, prior to an explicit this()\/super()?\n@@ -54,5 +54,1 @@\n-    boolean isSelfCall = false;\n-\n-    \/** are we analyzing the arguments for a constructor invocation?\n-     *\/\n-    boolean constructorArgs = false;\n+    boolean ctorPrologue = false;\n@@ -139,2 +135,1 @@\n-        info.isSelfCall = isSelfCall;\n-        info.constructorArgs = constructorArgs;\n+        info.ctorPrologue = ctorPrologue;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/AttrContext.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -362,9 +362,0 @@\n-    \/** Report an error that symbol cannot be referenced before super\n-     *  has been called.\n-     *  @param pos        Position to be used for error reporting.\n-     *  @param sym        The referenced symbol.\n-     *\/\n-    void earlyRefError(DiagnosticPosition pos, Symbol sym) {\n-        log.error(pos, Errors.CantRefBeforeCtorCalled(sym));\n-    }\n-\n@@ -3937,4 +3928,5 @@\n-            JCMethodInvocation app = TreeInfo.firstConstructorCall(l.head);\n-            if (app == null) continue;\n-            JCMethodDecl meth = (JCMethodDecl) l.head;\n-            if (TreeInfo.name(app.meth) == names._this) {\n+            if (!TreeInfo.isConstructor(l.head))\n+                continue;\n+            JCMethodDecl meth = (JCMethodDecl)l.head;\n+            JCMethodInvocation app = TreeInfo.findConstructorCall(meth);\n+            if (app != null && TreeInfo.name(app.meth) == names._this) {\n@@ -3973,0 +3965,122 @@\n+\/* *************************************************************************\n+ * Verify the proper placement of super()\/this() calls.\n+ *\n+ *    - super()\/this() may only appear in constructors\n+ *    - There must be at most one super()\/this() call per constructor\n+ *    - The super()\/this() call, if any, must be a top-level statement in the\n+ *      constructor, i.e., not nested inside any other statement or block\n+ *    - There must be no return statements prior to the super()\/this() call\n+ **************************************************************************\/\n+\n+    void checkSuperInitCalls(JCClassDecl tree) {\n+        new SuperThisChecker().check(tree);\n+    }\n+\n+    private class SuperThisChecker extends TreeScanner {\n+\n+        \/\/ Match this scan stack: 1=JCMethodDecl, 2=JCExpressionStatement, 3=JCMethodInvocation\n+        private static final int MATCH_SCAN_DEPTH = 3;\n+\n+        private boolean constructor;        \/\/ is this method a constructor?\n+        private boolean firstStatement;     \/\/ at the first statement in method?\n+        private JCReturn earlyReturn;       \/\/ first return prior to the super()\/init(), if any\n+        private Name initCall;              \/\/ whichever of \"super\" or \"init\" we've seen already\n+        private int scanDepth;              \/\/ current scan recursion depth in method body\n+\n+        public void check(JCClassDecl classDef) {\n+            scan(classDef.defs);\n+        }\n+\n+        @Override\n+        public void visitMethodDef(JCMethodDecl tree) {\n+            Assert.check(!constructor);\n+            Assert.check(earlyReturn == null);\n+            Assert.check(initCall == null);\n+            Assert.check(scanDepth == 1);\n+\n+            \/\/ Initialize state for this method\n+            constructor = TreeInfo.isConstructor(tree);\n+            try {\n+\n+                \/\/ Scan method body\n+                if (tree.body != null) {\n+                    firstStatement = true;\n+                    for (List<JCStatement> l = tree.body.stats; l.nonEmpty(); l = l.tail) {\n+                        scan(l.head);\n+                        firstStatement = false;\n+                    }\n+                }\n+\n+                \/\/ Verify no 'return' seen prior to an explicit super()\/this() call\n+                if (constructor && earlyReturn != null && initCall != null)\n+                    log.error(earlyReturn.pos(), Errors.ReturnBeforeSuperclassInitialized);\n+            } finally {\n+                firstStatement = false;\n+                constructor = false;\n+                earlyReturn = null;\n+                initCall = null;\n+            }\n+        }\n+\n+        @Override\n+        public void scan(JCTree tree) {\n+            scanDepth++;\n+            try {\n+                super.scan(tree);\n+            } finally {\n+                scanDepth--;\n+            }\n+        }\n+\n+        @Override\n+        public void visitApply(JCMethodInvocation apply) {\n+            do {\n+\n+                \/\/ Is this a super() or this() call?\n+                Name methodName = TreeInfo.name(apply.meth);\n+                if (methodName != names._super && methodName != names._this)\n+                    break;\n+\n+                \/\/ super()\/this() calls must only appear in a constructor\n+                if (!constructor) {\n+                    log.error(apply.pos(), Errors.CallMustOnlyAppearInCtor);\n+                    break;\n+                }\n+\n+                \/\/ super()\/this() calls must be a top level statement\n+                if (scanDepth != MATCH_SCAN_DEPTH) {\n+                    log.error(apply.pos(), Errors.CtorCallsNotAllowedHere);\n+                    break;\n+                }\n+\n+                \/\/ super()\/this() calls must not appear more than once\n+                if (initCall != null) {\n+                    log.error(apply.pos(), Errors.RedundantSuperclassInit);\n+                    break;\n+                }\n+\n+                \/\/ If super()\/this() isn't first, require \"statements before super()\" feature\n+                if (!firstStatement)\n+                    preview.checkSourceLevel(apply.pos(), Feature.SUPER_INIT);\n+\n+                \/\/ We found a legitimate super()\/this() call; remember it\n+                initCall = methodName;\n+            } while (false);\n+\n+            \/\/ Proceed\n+            super.visitApply(apply);\n+        }\n+\n+        @Override\n+        public void visitReturn(JCReturn tree) {\n+            if (constructor && initCall == null && earlyReturn == null)\n+                earlyReturn = tree;             \/\/ we have seen a return but not (yet) a super()\/this()\n+            super.visitReturn(tree);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ don't descend any further\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":127,"deletions":13,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -209,1 +209,0 @@\n-        localEnv.info.isSelfCall = false;\n@@ -262,1 +261,0 @@\n-        localEnv.info.isSelfCall = false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.Consumer;\n@@ -389,0 +390,7 @@\n+        \/** A class whose initializers we are scanning. Because initializer\n+         *  scans can be triggered out of sequence when visiting certain nodes\n+         *  (e.g., super()), we protect against infinite loops that could be\n+         *  triggered by incorrect code (e.g., super() inside initializer).\n+         *\/\n+        JCClassDecl initScanClass;\n+\n@@ -474,0 +482,18 @@\n+\n+        \/\/ Do something with all static or non-static field initializers and initialization blocks.\n+        \/\/ Note: This method also sends nested class definitions to the handler.\n+        protected void forEachInitializer(JCClassDecl classDef, boolean isStatic, Consumer<? super JCTree> handler) {\n+            if (classDef == initScanClass)          \/\/ avoid infinite loops\n+                return;\n+            JCClassDecl initScanClassPrev = initScanClass;\n+            initScanClass = classDef;\n+            try {\n+                for (List<JCTree> defs = classDef.defs; defs.nonEmpty(); defs = defs.tail) {\n+                    JCTree def = defs.head;\n+                    if (!def.hasTag(METHODDEF) && ((TreeInfo.flags(def) & STATIC) != 0) == isStatic)\n+                        handler.accept(def);\n+                }\n+            } finally {\n+                initScanClass = initScanClassPrev;\n+            }\n+        }\n@@ -539,7 +565,4 @@\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) != 0) {\n-                        scanDef(l.head);\n-                        clearPendingExits(false);\n-                    }\n-                }\n+                forEachInitializer(tree, true, def -> {\n+                    scanDef(def);\n+                    clearPendingExits(false);\n+                });\n@@ -548,7 +571,4 @@\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) == 0) {\n-                        scanDef(l.head);\n-                        clearPendingExits(false);\n-                    }\n-                }\n+                forEachInitializer(tree, false, def -> {\n+                    scanDef(def);\n+                    clearPendingExits(false);\n+                });\n@@ -1365,34 +1385,4 @@\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) != 0) {\n-                        scan(l.head);\n-                        errorUncaught();\n-                    }\n-                }\n-\n-                \/\/ add intersection of all throws clauses of initial constructors\n-                \/\/ to set of caught exceptions, unless class is anonymous.\n-                if (!anonymousClass) {\n-                    boolean firstConstructor = true;\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (TreeInfo.isInitialConstructor(l.head)) {\n-                            List<Type> mthrown =\n-                                ((JCMethodDecl) l.head).sym.type.getThrownTypes();\n-                            if (firstConstructor) {\n-                                caught = mthrown;\n-                                firstConstructor = false;\n-                            } else {\n-                                caught = chk.intersect(mthrown, caught);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                \/\/ process all the instance initializers\n-                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                    if (!l.head.hasTag(METHODDEF) &&\n-                        (TreeInfo.flags(l.head) & STATIC) == 0) {\n-                        scan(l.head);\n-                        errorUncaught();\n-                    }\n-                }\n+                forEachInitializer(tree, true, def -> {\n+                    scan(def);\n+                    errorUncaught();\n+                });\n@@ -1453,1 +1443,1 @@\n-                if (TreeInfo.isInitialConstructor(tree))\n+                if (TreeInfo.hasConstructorCall(tree, names._super))\n@@ -1754,0 +1744,2 @@\n+\n+            \/\/ Mark as thrown the exceptions thrown by the method being invoked\n@@ -1756,0 +1748,8 @@\n+\n+            \/\/ After super(), scan initializers to uncover any exceptions they throw\n+            if (TreeInfo.name(tree.meth) == names._super) {\n+                forEachInitializer(classDef, false, def -> {\n+                    scan(def);\n+                    errorUncaught();\n+                });\n+            }\n@@ -2098,1 +2098,1 @@\n-        private boolean isInitialConstructor = false;\n+        private boolean isConstructor;\n@@ -2102,1 +2102,1 @@\n-            if (!isInitialConstructor) {\n+            if (!isConstructor) {\n@@ -2349,7 +2349,4 @@\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (!l.head.hasTag(METHODDEF) &&\n-                            (TreeInfo.flags(l.head) & STATIC) != 0) {\n-                            scan(l.head);\n-                            clearPendingExits(false);\n-                        }\n-                    }\n+                    forEachInitializer(tree, true, def -> {\n+                        scan(def);\n+                        clearPendingExits(false);\n+                    });\n@@ -2379,9 +2376,0 @@\n-                    \/\/ process all the instance initializers\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (!l.head.hasTag(METHODDEF) &&\n-                            (TreeInfo.flags(l.head) & STATIC) == 0) {\n-                            scan(l.head);\n-                            clearPendingExits(false);\n-                        }\n-                    }\n-\n@@ -2426,1 +2414,1 @@\n-                boolean lastInitialConstructor = isInitialConstructor;\n+                boolean isConstructorPrev = isConstructor;\n@@ -2428,1 +2416,1 @@\n-                    isInitialConstructor = TreeInfo.isInitialConstructor(tree);\n+                    isConstructor = TreeInfo.isConstructor(tree);\n@@ -2430,1 +2418,2 @@\n-                    if (!isInitialConstructor) {\n+                    \/\/ We only track field initialization inside constructors\n+                    if (!isConstructor) {\n@@ -2433,0 +2422,2 @@\n+\n+                    \/\/ Mark all method parameters as DA\n@@ -2448,1 +2439,1 @@\n-                    if (isInitialConstructor) {\n+                    if (isConstructor) {\n@@ -2490,1 +2481,1 @@\n-                    isInitialConstructor = lastInitialConstructor;\n+                    isConstructor = isConstructorPrev;\n@@ -2506,1 +2497,1 @@\n-                if (inMethod && isInitialConstructor) {\n+                if (inMethod && isConstructor) {\n@@ -2962,0 +2953,22 @@\n+\n+            \/\/ Handle superclass constructor invocations\n+            if (isConstructor) {\n+\n+                \/\/ If super(): at this point all initialization blocks will execute\n+                Name name = TreeInfo.name(tree.meth);\n+                if (name == names._super) {\n+                    forEachInitializer(classDef, false, def -> {\n+                        scan(def);\n+                        clearPendingExits(false);\n+                    });\n+                }\n+\n+                \/\/ If this(): at this point all final uninitialized fields will get initialized\n+                else if (name == names._this) {\n+                    for (int address = firstadr; address < nextadr; address++) {\n+                        VarSymbol sym = vardecls[address].sym;\n+                        if (isFinalUninitializedField(sym) && !sym.isStatic())\n+                            letInit(tree.pos(), sym);\n+                    }\n+                }\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":86,"deletions":73,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -1862,1 +1862,1 @@\n-                chk.earlyRefError(pos, c);\n+                log.error(pos, Errors.NoEnclInstanceOfTypeInScope(c));\n@@ -1902,1 +1902,0 @@\n-            Assert.error();\n@@ -1914,1 +1913,0 @@\n-                    Assert.error();\n@@ -2354,2 +2352,2 @@\n-        \/\/ If this$n was accessed, add the field definition and\n-        \/\/ update initial constructors to initialize it\n+        \/\/ If this$n was accessed, add the field definition and prepend\n+        \/\/ initializer code to any super() invocation to initialize it\n@@ -2360,5 +2358,7 @@\n-           for (JCTree def : tree.defs) {\n-                if (TreeInfo.isInitialConstructor(def)) {\n-                  JCMethodDecl mdef = (JCMethodDecl) def;\n-                  mdef.body.stats = mdef.body.stats.prepend(\n-                      initOuterThis(mdef.body.pos, mdef.params.head.sym));\n+            for (JCTree def : tree.defs) {\n+                if (TreeInfo.isConstructor(def)) {\n+                    JCMethodDecl mdef = (JCMethodDecl)def;\n+                    if (TreeInfo.hasConstructorCall(mdef, names._super)) {\n+                        List<JCStatement> initializer = List.of(initOuterThis(mdef.body.pos, mdef.params.head.sym));\n+                        TreeInfo.mapSuperCalls(mdef.body, supercall -> make.Block(0, initializer.append(supercall)));\n+                    }\n@@ -2829,4 +2829,2 @@\n-            \/\/ If this is an initial constructor, i.e., it does not start with\n-            \/\/ this(...), insert initializers for this$n and proxies\n-            \/\/ before (pre-1.4, after) the call to superclass constructor.\n-            JCStatement selfCall = translate(tree.body.stats.head);\n+            \/\/ Determine whether this constructor has a super() invocation\n+            boolean invokesSuper = TreeInfo.hasConstructorCall(tree, names._super);\n@@ -2834,1 +2832,2 @@\n-            List<JCStatement> added = List.nil();\n+            \/\/ Create initializers for this$n and proxies\n+            ListBuffer<JCStatement> added = new ListBuffer<>();\n@@ -2841,1 +2840,1 @@\n-                    if (TreeInfo.isInitialConstructor(tree)) {\n+                    if (invokesSuper) {\n@@ -2855,0 +2854,9 @@\n+            \/\/ Recursively translate existing local statements\n+            tree.body.stats = translate(tree.body.stats);\n+\n+            \/\/ Prepend initializers in front of super() call\n+            if (added.nonEmpty()) {\n+                List<JCStatement> initializers = added.toList();\n+                TreeInfo.mapSuperCalls(tree.body, supercall -> make.Block(0, initializers.append(supercall)));\n+            }\n+\n@@ -2858,4 +2866,0 @@\n-            \/\/ recursively translate following local statements and\n-            \/\/ combine with this- or super-call\n-            List<JCStatement> stats = translate(tree.body.stats.tail);\n-            tree.body.stats = stats.prepend(selfCall).prependList(added);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1506,2 +1506,1 @@\n-                if (staticOnly &&\n-                        sym.kind == VAR &&\n+                if (sym.kind == VAR &&\n@@ -1509,4 +1508,7 @@\n-                        (sym.flags() & STATIC) == 0)\n-                    return new StaticError(sym);\n-                else\n-                    return sym;\n+                        (sym.flags() & STATIC) == 0) {\n+                    if (staticOnly)\n+                        return new StaticError(sym);\n+                    if (env1.info.ctorPrologue && (sym.flags_field & SYNTHETIC) == 0)\n+                        return new RefBeforeCtorCalledError(sym);\n+                }\n+                return sym;\n@@ -2009,5 +2011,9 @@\n-                    if (staticOnly &&\n-                        sym.kind == MTH &&\n-                        sym.owner.kind == TYP &&\n-                        (sym.flags() & STATIC) == 0) return new StaticError(sym);\n-                    else return sym;\n+                    if (sym.kind == MTH &&\n+                            sym.owner.kind == TYP &&\n+                            (sym.flags() & STATIC) == 0) {\n+                        if (staticOnly)\n+                            return new StaticError(sym);\n+                        if (env1.info.ctorPrologue && env1 == env)\n+                            return new RefBeforeCtorCalledError(sym);\n+                    }\n+                    return sym;\n@@ -3770,1 +3776,4 @@\n-                    if (staticOnly) sym = new StaticError(sym);\n+                    if (staticOnly)\n+                        sym = new StaticError(sym);\n+                    else if (env1.info.ctorPrologue)\n+                        sym = new RefBeforeCtorCalledError(sym);\n@@ -3784,0 +3793,2 @@\n+                    if (env.info.ctorPrologue)\n+                        log.error(pos, Errors.CantRefBeforeCtorCalled(name));\n@@ -3885,2 +3896,2 @@\n-        if (env.info.isSelfCall && thisType.tsym == env.enclClass.sym) {\n-            log.error(pos, Errors.CantRefBeforeCtorCalled(\"this\"));\n+        if (env.info.ctorPrologue && thisType.tsym == env.enclClass.sym) {\n+            log.error(pos, Errors.CantRefBeforeCtorCalled(names._this));\n@@ -4591,1 +4602,5 @@\n-            super(STATICERR, sym, \"static error\");\n+            this(sym, \"static error\");\n+        }\n+\n+        StaticError(Symbol sym, String debugName) {\n+            super(STATICERR, sym, debugName);\n@@ -4610,0 +4625,26 @@\n+    \/**\n+     * Specialization of {@link InvalidSymbolError} for illegal\n+     * early accesses within a constructor prologue.\n+     *\/\n+    class RefBeforeCtorCalledError extends StaticError {\n+\n+        RefBeforeCtorCalledError(Symbol sym) {\n+            super(sym, \"prologue error\");\n+        }\n+\n+        @Override\n+        JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,\n+                DiagnosticPosition pos,\n+                Symbol location,\n+                Type site,\n+                Name name,\n+                List<Type> argtypes,\n+                List<Type> typeargtypes) {\n+            Symbol errSym = ((sym.kind == TYP && sym.type.hasTag(CLASS))\n+                ? types.erasure(sym.type).tsym\n+                : sym);\n+            return diags.create(dkind, log.currentSource(), pos,\n+                    \"cant.ref.before.ctor.called\", errSym);\n+        }\n+    }\n+\n@@ -4723,1 +4764,1 @@\n-            super(sym);\n+            super(sym, \"bad method ref error\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":57,"deletions":16,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -573,1 +573,0 @@\n-            localEnv.info.isSelfCall = false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2335,1 +2335,6 @@\n-            mt.restype = addTypeAnnotations(mt.restype, TargetType.METHOD_RETURN);\n+            \/* possible information loss if the type of the method is void then we can't add type\n+             * annotations to it\n+             *\/\n+            if (!mt.restype.hasTag(TypeTag.VOID)) {\n+                mt.restype = addTypeAnnotations(mt.restype, TargetType.METHOD_RETURN);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -544,1 +544,1 @@\n-    \/** Insert instance initializer code into initial constructor.\n+    \/** Insert instance initializer code into constructors prior to the super() call.\n@@ -551,31 +551,5 @@\n-        if (md.name == names.init && TreeInfo.isInitialConstructor(md)) {\n-            \/\/ We are seeing a constructor that does not call another\n-            \/\/ constructor of the same class.\n-            List<JCStatement> stats = md.body.stats;\n-            ListBuffer<JCStatement> newstats = new ListBuffer<>();\n-\n-            if (stats.nonEmpty()) {\n-                \/\/ Copy initializers of synthetic variables generated in\n-                \/\/ the translation of inner classes.\n-                while (TreeInfo.isSyntheticInit(stats.head)) {\n-                    newstats.append(stats.head);\n-                    stats = stats.tail;\n-                }\n-                \/\/ Copy superclass constructor call\n-                newstats.append(stats.head);\n-                stats = stats.tail;\n-                \/\/ Copy remaining synthetic initializers.\n-                while (stats.nonEmpty() &&\n-                       TreeInfo.isSyntheticInit(stats.head)) {\n-                    newstats.append(stats.head);\n-                    stats = stats.tail;\n-                }\n-                \/\/ Now insert the initializer code.\n-                newstats.appendList(initCode);\n-                \/\/ And copy all remaining statements.\n-                while (stats.nonEmpty()) {\n-                    newstats.append(stats.head);\n-                    stats = stats.tail;\n-                }\n-            }\n-            md.body.stats = newstats.toList();\n+        if (TreeInfo.isConstructor(md) && TreeInfo.hasConstructorCall(md, names._super)) {\n+            \/\/ We are seeing a constructor that has a super() call.\n+            \/\/ Find the super() invocation and append the given initializer code.\n+            TreeInfo.mapSuperCalls(md.body, supercall -> make.Block(0, initCode.prepend(supercall)));\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Gen.java","additions":6,"deletions":32,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n@@ -69,0 +70,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.Fragment;\n@@ -524,1 +526,1 @@\n-                        reportDiag(Warnings.TargetDefaultSourceConflict(targetString, source.requiredTarget()));\n+                        reportDiag(Errors.TargetDefaultSourceConflict(source.name, targetString));\n@@ -526,1 +528,1 @@\n-                        reportDiag(Warnings.SourceTargetConflict(sourceString, source.requiredTarget()));\n+                        reportDiag(Errors.SourceTargetConflict(sourceString, targetString));\n@@ -572,1 +574,1 @@\n-                        log.warning(LintCategory.OPTIONS, Warnings.SourceNoBootclasspath(source.name));\n+                        log.warning(LintCategory.OPTIONS, Warnings.SourceNoBootclasspath(source.name, releaseNote(source, targetString)));\n@@ -575,1 +577,1 @@\n-                        log.warning(LintCategory.OPTIONS, Warnings.SourceNoSystemModulesPath(source.name));\n+                        log.warning(LintCategory.OPTIONS, Warnings.SourceNoSystemModulesPath(source.name, releaseNote(source, targetString)));\n@@ -643,0 +645,16 @@\n+    private Fragment releaseNote(Source source, String targetString) {\n+        if (source.compareTo(Source.JDK8) <= 0) {\n+            if (targetString != null) {\n+                return Fragments.SourceNoBootclasspathWithTarget(source.name, targetString);\n+            } else {\n+                return Fragments.SourceNoBootclasspath(source.name);\n+            }\n+        } else {\n+            if (targetString != null) {\n+                return Fragments.SourceNoSystemModulesPathWithTarget(source.name, targetString);\n+            } else {\n+                return Fragments.SourceNoSystemModulesPath(source.name);\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Arguments.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.net.URI;\n@@ -51,2 +50,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -74,2 +71,0 @@\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n@@ -176,7 +171,0 @@\n-                        if (result == null) {\n-                            \/\/in jrt:\/\/, the classfile may have the .class extension:\n-                            result = (JavaFileObject) getFileForInput(location,\n-                                                                      \"\",\n-                                                                      fileName + \".class\");\n-                        }\n-\n@@ -185,2 +173,0 @@\n-                        } else {\n-                            return null;\n@@ -265,1 +251,0 @@\n-                    Path systemModules = root.resolve(ctSymVersion).resolve(\"system-modules\");\n@@ -284,12 +269,0 @@\n-                    } else if (Files.isRegularFile(systemModules)) {\n-                        fm.handleOption(\"--system\", Arrays.asList(\"none\").iterator());\n-\n-                        Path jrtModules =\n-                                FileSystems.getFileSystem(URI.create(\"jrt:\/\"))\n-                                           .getPath(\"modules\");\n-                        try (Stream<String> lines =\n-                                Files.lines(systemModules, UTF_8)) {\n-                            lines.map(line -> jrtModules.resolve(line))\n-                                 .filter(mod -> Files.exists(mod))\n-                                 .forEach(mod -> setModule(fm, mod));\n-                        }\n@@ -330,10 +303,0 @@\n-        private static void setModule(StandardJavaFileManager fm, Path mod) {\n-            try {\n-                fm.setLocationForModule(StandardLocation.SYSTEM_MODULES,\n-                                        mod.getFileName().toString(),\n-                                        Collections.singleton(mod));\n-            } catch (IOException ex) {\n-                throw new IllegalStateException(ex);\n-            }\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/platform\/JDKPlatformProvider.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -236,3 +236,11 @@\n-# 0: name\n-compiler.err.call.must.be.first.stmt.in.ctor=\\\n-    call to {0} must be first statement in constructor\n+compiler.err.call.must.only.appear.in.ctor=\\\n+    explicit constructor invocation may only appear within a constructor body\n+\n+compiler.err.redundant.superclass.init=\\\n+    redundant explicit constructor invocation\n+\n+compiler.err.ctor.calls.not.allowed.here=\\\n+    explicit constructor invocation not allowed here\n+\n+compiler.err.return.before.superclass.initialized=\\\n+    ''return'' not allowed before explicit constructor invocation\n@@ -390,1 +398,1 @@\n-# 0: symbol or string\n+# 0: symbol or name\n@@ -2114,1 +2122,1 @@\n-# 0: string\n+# 0: string, 1: fragment\n@@ -2116,1 +2124,1 @@\n-    bootstrap class path not set in conjunction with -source {0}\n+    bootstrap class path is not set in conjunction with -source {0}\\n{1}\n@@ -2118,1 +2126,1 @@\n-# 0: string\n+# 0: string, 1: fragment\n@@ -2120,1 +2128,21 @@\n-    system modules path not set in conjunction with -source {0}\n+    location of system modules is not set in conjunction with -source {0}\\n{1}\n+\n+# 0: string\n+compiler.misc.source.no.bootclasspath=\\\n+  not setting the bootstrap class path may lead to class files that cannot run on JDK {0}\\n\\\n+  --release {0} is recommended instead of -source {0} because it sets the bootstrap class path automatically\n+\n+# 0: string\n+compiler.misc.source.no.system.modules.path=\\\n+  not setting the location of system modules may lead to class files that cannot run on JDK {0}\\n\\\n+  --release {0} is recommended instead of -source {0} because it sets the location of system modules automatically\n+\n+# 0: string, 1: string\n+compiler.misc.source.no.bootclasspath.with.target=\\\n+  not setting the bootstrap class path may lead to class files that cannot run on JDK 8\\n\\\n+  --release {0} is recommended instead of -source {0} -target {1} because it sets the bootstrap class path automatically\n+\n+# 0: string, 1: string\n+compiler.misc.source.no.system.modules.path.with.target=\\\n+  not setting the location of system modules may lead to class files that cannot run on JDK {0}\\n\\\n+  --release {0} is recommended instead of -source {0} -target {1} because it sets the location of system modules automatically\n@@ -3196,0 +3224,3 @@\n+compiler.misc.feature.super.init=\\\n+    statements before super()\n+\n@@ -3898,2 +3929,2 @@\n-compiler.err.first.statement.must.be.call.to.another.constructor=\\\n-    constructor is not canonical, so its first statement must invoke another constructor of class {0}\n+compiler.err.non.canonical.constructor.invoke.another.constructor=\\\n+    constructor is not canonical, so it must invoke another constructor of class {0}\n@@ -3964,3 +3995,4 @@\n-# 0: string, 1: target\n-compiler.warn.source.target.conflict=\\\n-    source release {0} requires target release {1}\n+# 0: string, 1: string\n+compiler.err.source.target.conflict=\\\n+    specified target release {1} is too old for the specified source release {0}\\n\\\n+    --release {1} is recommended when compiling code to run on JDK {1}\n@@ -3968,3 +4000,4 @@\n-# 0: string, 1: target\n-compiler.warn.target.default.source.conflict=\\\n-    target release {0} conflicts with default source release {1}\n+# 0: string, 1: string\n+compiler.err.target.default.source.conflict=\\\n+    specified target release {1} is too old for the default source release {0}\\n\\\n+    --release {1} is recommended when compiling code to run on JDK {1}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":49,"deletions":16,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import java.util.function.Function;\n@@ -116,19 +117,0 @@\n-    \/** Is there a constructor invocation in the given list of trees?\n-     *\/\n-    public static Name getConstructorInvocationName(List<? extends JCTree> trees, Names names) {\n-        for (JCTree tree : trees) {\n-            if (tree.hasTag(EXEC)) {\n-                JCExpressionStatement stat = (JCExpressionStatement)tree;\n-                if (stat.expr.hasTag(APPLY)) {\n-                    JCMethodInvocation apply = (JCMethodInvocation)stat.expr;\n-                    Name methName = TreeInfo.name(apply.meth);\n-                    if (methName == names._this ||\n-                        methName == names._super) {\n-                        return methName;\n-                    }\n-                }\n-            }\n-        }\n-        return names.empty;\n-    }\n-\n@@ -173,12 +155,0 @@\n-    \/** Is this a call to this or super?\n-     *\/\n-    public static boolean isSelfCall(JCTree tree) {\n-        Name name = calledMethodName(tree);\n-        if (name != null) {\n-            Names names = name.table.names;\n-            return name==names._this || name==names._super;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n@@ -241,2 +211,15 @@\n-    \/** Is this a constructor whose first (non-synthetic) statement is not\n-     *  of the form this(...)?\n+    \/** Is the given method a constructor containing a super() or this() call?\n+      *\/\n+    public static boolean hasAnyConstructorCall(JCMethodDecl tree) {\n+        return hasConstructorCall(tree, null);\n+    }\n+\n+    \/** Is the given method a constructor containing a super() and\/or this() call?\n+      * The \"target\" is either names._this, names._super, or null for either\/both.\n+      *\/\n+    public static boolean hasConstructorCall(JCMethodDecl tree, Name target) {\n+        JCMethodInvocation app = findConstructorCall(tree);\n+        return app != null && (target == null || target == name(app.meth));\n+    }\n+\n+    \/** Find the first super() or init() call in the given constructor.\n@@ -244,5 +227,4 @@\n-    public static boolean isInitialConstructor(JCTree tree) {\n-        JCMethodInvocation app = firstConstructorCall(tree);\n-        if (app == null) return false;\n-        Name meth = name(app.meth);\n-        return meth == null || meth != meth.table.names._this;\n+    public static JCMethodInvocation findConstructorCall(JCMethodDecl md) {\n+        if (!TreeInfo.isConstructor(md) || md.body == null)\n+            return null;\n+        return new ConstructorCallFinder(md.name.table.names).find(md).head;\n@@ -251,16 +233,75 @@\n-    \/** Return the first call in a constructor definition. *\/\n-    public static JCMethodInvocation firstConstructorCall(JCTree tree) {\n-        if (!tree.hasTag(METHODDEF)) return null;\n-        JCMethodDecl md = (JCMethodDecl) tree;\n-        Names names = md.name.table.names;\n-        if (md.name != names.init) return null;\n-        if (md.body == null) return null;\n-        List<JCStatement> stats = md.body.stats;\n-        \/\/ Synthetic initializations can appear before the super call.\n-        while (stats.nonEmpty() && isSyntheticInit(stats.head))\n-            stats = stats.tail;\n-        if (stats.isEmpty()) return null;\n-        if (!stats.head.hasTag(EXEC)) return null;\n-        JCExpressionStatement exec = (JCExpressionStatement) stats.head;\n-        if (!exec.expr.hasTag(APPLY)) return null;\n-        return (JCMethodInvocation)exec.expr;\n+    \/** Finds all calls to this() and\/or super() in a given constructor.\n+     *  We can't assume they will be \"top level\" statements, because\n+     *  some synthetic calls to super() are added inside { } blocks.\n+     *  So we must recurse through the method's entire syntax tree.\n+     *\/\n+    private static class ConstructorCallFinder extends TreeScanner {\n+\n+        final ListBuffer<JCMethodInvocation> calls = new ListBuffer<>();\n+        final Names names;\n+\n+        ConstructorCallFinder(Names names) {\n+            this.names = names;\n+        }\n+\n+        List<JCMethodInvocation> find(JCMethodDecl meth) {\n+            scan(meth);\n+            return calls.toList();\n+        }\n+\n+        @Override\n+        public void visitApply(JCMethodInvocation invoke) {\n+            Name name = TreeInfo.name(invoke.meth);\n+            if ((name == names._this || name == names._super))\n+                calls.append(invoke);\n+            super.visitApply(invoke);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ don't descend any further\n+        }\n+\n+        @Override\n+        public void visitLambda(JCLambda tree) {\n+            \/\/ don't descend any further\n+        }\n+    }\n+\n+    \/** Finds super() invocations and translates them using the given mapping.\n+     *\/\n+    public static void mapSuperCalls(JCBlock block, Function<? super JCExpressionStatement, ? extends JCStatement> mapper) {\n+        block.stats = block.stats.map(new TreeInfo.SuperCallTranslator(mapper)::translate);\n+    }\n+\n+    \/** Finds all super() invocations and translates them somehow.\n+     *\/\n+    private static class SuperCallTranslator extends TreeTranslator {\n+\n+        final Function<? super JCExpressionStatement, ? extends JCStatement> translator;\n+\n+        \/** Constructor.\n+         *\n+         * @param translator translates super() invocations, returning replacement statement or null for no change\n+         *\/\n+        SuperCallTranslator(Function<? super JCExpressionStatement, ? extends JCStatement> translator) {\n+            this.translator = translator;\n+        }\n+\n+        \/\/ Because it returns void, anywhere super() can legally appear must be a location where a JCStatement\n+        \/\/ could also appear, so it's OK that we are replacing a JCExpressionStatement with a JCStatement here.\n+        @Override\n+        public void visitExec(JCExpressionStatement stat) {\n+            if (!TreeInfo.isSuperCall(stat) || (result = this.translator.apply(stat)) == null)\n+                super.visitExec(stat);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            \/\/ don't descend any further\n+        }\n+\n+        @Override\n+        public void visitLambda(JCLambda tree) {\n+            \/\/ don't descend any further\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":95,"deletions":54,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -1114,0 +1114,3 @@\n+                          if (!bad && region.isPinned()) {\n+                            anno += \"Pinned \";\n+                          }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HSDB.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+    private static CIntegerField pinnedCountField;\n+\n@@ -74,0 +76,2 @@\n+        pinnedCountField = type.getCIntegerField(\"_pinned_object_count\");\n+\n@@ -127,0 +131,4 @@\n+    public boolean isPinned() {\n+        return pinnedCountField.getValue(addr) != 0;\n+    }\n+\n@@ -137,1 +145,1 @@\n-        tty.println(\":\" + type.typeAnnotation());\n+        tty.println(\":\" + type.typeAnnotation() + (isPinned() ? \" Pinned\" : \"\"));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegion.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,3 +42,0 @@\n-  private static AddressField youngGenSpecField;\n-  private static AddressField oldGenSpecField;\n-\n@@ -60,2 +57,0 @@\n-    youngGenSpecField = type.getAddressField(\"_young_gen_spec\");\n-    oldGenSpecField = type.getAddressField(\"_old_gen_spec\");\n@@ -118,20 +113,0 @@\n-  \/** Package-private access to GenerationSpecs *\/\n-  GenerationSpec spec(int level) {\n-    if (Assert.ASSERTS_ENABLED) {\n-      Assert.that((level == 0) || (level == 1), \"Index \" + level +\n-                  \" out of range (should be 0 or 1)\");\n-    }\n-\n-    if ((level != 0) && (level != 1)) {\n-      return null;\n-    }\n-\n-    if (level == 0) {\n-      return VMObjectFactory.newObject(GenerationSpec.class,\n-              youngGenSpecField.getAddress());\n-    } else {\n-      return VMObjectFactory.newObject(GenerationSpec.class,\n-              oldGenSpecField.getAddress());\n-    }\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shared\/GenCollectedHeap.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package sun.jvm.hotspot.gc.shared;\n-\n-import java.util.*;\n-\n-import sun.jvm.hotspot.debugger.*;\n-import sun.jvm.hotspot.runtime.*;\n-import sun.jvm.hotspot.types.*;\n-import sun.jvm.hotspot.utilities.Observable;\n-import sun.jvm.hotspot.utilities.Observer;\n-\n-public class GenerationSpec extends VMObject {\n-  private static CIntegerField nameField;\n-  private static CIntegerField initSizeField;\n-  private static CIntegerField maxSizeField;\n-\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static synchronized void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"GenerationSpec\");\n-\n-    nameField       = type.getCIntegerField(\"_name\");\n-    initSizeField = type.getCIntegerField(\"_init_size\");\n-    maxSizeField  = type.getCIntegerField(\"_max_size\");\n-  }\n-\n-  public GenerationSpec(Address addr) {\n-    super(addr);\n-  }\n-\n-  public Generation.Name name() {\n-    return Generation.nameForEnum((int)nameField.getValue(addr));\n-  }\n-\n-  public long initSize() {\n-    return initSizeField.getValue(addr);\n-  }\n-\n-  public long maxSize() {\n-    return maxSizeField.getValue(addr);\n-  }\n-}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/shared\/GenerationSpec.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -120,1 +120,1 @@\n-     * @param isLinkPlain   {@code true} if the link should be presented in \"plain\" font,\n+     * @param isPlain       {@code true} if the link should be presented in \"plain\" font,\n@@ -133,1 +133,1 @@\n-                                   boolean isLinkPlain,\n+                                   boolean isPlain,\n@@ -140,1 +140,1 @@\n-        Content labelContent = plainOrCode(isLinkPlain, label);\n+        Content labelContent = plainOrCode(isPlain, label);\n@@ -143,1 +143,1 @@\n-        Content text = plainOrCode(isLinkPlain,\n+        Content text = plainOrCode(isPlain,\n@@ -173,1 +173,1 @@\n-                    labelContent = plainOrCode(isLinkPlain,\n+                    labelContent = plainOrCode(isPlain,\n@@ -205,1 +205,1 @@\n-                    return plainOrCode(isLinkPlain, htmlWriter.getLink(\n+                    return plainOrCode(isPlain, htmlWriter.getLink(\n@@ -208,1 +208,1 @@\n-                labelContent = plainOrCode(isLinkPlain, Text.of(utils.getSimpleName(refClass)));\n+                labelContent = plainOrCode(isPlain, Text.of(utils.getSimpleName(refClass)));\n@@ -270,1 +270,1 @@\n-                            ? plainOrCode(isLinkPlain, Text.of(refMemName))\n+                            ? plainOrCode(isPlain, Text.of(refMemName))\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LinkTaglet.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import com.sun.source.doctree.TextTree;\n@@ -177,1 +178,1 @@\n-                        false,\n+                        isPlain(refSignature, label),\n@@ -192,0 +193,56 @@\n+    }\n+\n+    \/**\n+     * {@return {@code true} if the label should be rendered in plain font}\n+     *\n+     * The method uses a heuristic, to see if the string form of the label\n+     * is a substring of the reference. Thus, for example:\n+     *\n+     * <ul>\n+     * <li>{@code @see MyClass.MY_CONSTANT MY_CONSTANT}  returns {@code true}\n+     * <li>{@code @see MyClass.MY_CONSTANT a constant}  returns {@code false}\n+     * <\/ul>\n+     *\n+     * The result will be {@code true} (meaning, displayed in plain font) if\n+     * any of the following are true about the label:\n+     *\n+     * <ul>\n+     * <li>There is more than a single item in the list of nodes,\n+     *     suggesting there may be formatting nodes.\n+     * <li>There is whitespace outside any parentheses,\n+     *     suggesting the label is a phrase\n+     * <li>There are nested parentheses, or content after the parentheses,\n+     *     which cannot occur in a standalone signature\n+     * <li>The simple name inferred from the reference does not match\n+     *     any simple name inferred from the label\n+     * <\/ul>\n+     *\n+     * @param refSignature the signature of the target of the reference\n+     * @param label the label\n+     *\/\n+    private boolean isPlain(String refSignature, List<? extends DocTree> label) {\n+        if (label.isEmpty()) {\n+            return false;\n+        } else if (label.size() > 1) {\n+            return true;\n+        }\n+\n+        var l0 = label.get(0);\n+        String s;\n+        if (l0 instanceof TextTree t) {\n+            s = t.getBody().trim();\n+        } else {\n+            return true;\n+        }\n+\n+        \/\/ look for whitespace outside any parens, nested parens, or characters after parens:\n+        \/\/ all of which will not be found in a simple signature\n+        var inParens = false;\n+        var ids = new ArrayList<String>();\n+        var sb = new StringBuilder();\n+        for (var i = 0; i < s.length(); i++) {\n+             var ch = s.charAt(i);\n+             if (!sb.isEmpty() && !Character.isJavaIdentifierPart(ch)) {\n+                 ids.add(sb.toString());\n+                 sb.setLength(0);\n+             }\n@@ -193,0 +250,61 @@\n+             switch (ch) {\n+                 case '(' -> {\n+                     if (inParens) {\n+                         return true;\n+                     } else {\n+                         inParens = true;\n+                     }\n+                 }\n+                 case ')' -> {\n+                     if (inParens && i < s.length() - 1) {\n+                         return true;\n+                     } else {\n+                         inParens = false;\n+                     }\n+                 }\n+                 default -> {\n+                     if (!inParens) {\n+                         if (Character.isJavaIdentifierStart(ch)\n+                                 || (!sb.isEmpty() && Character.isJavaIdentifierPart(ch))) {\n+                             sb.append(ch);\n+                         } else if (Character.isWhitespace(ch)) {\n+                             return true;\n+                         }\n+                     }\n+                 }\n+             }\n+        }\n+\n+        if (!sb.isEmpty()) {\n+            ids.add(sb.toString());\n+        }\n+\n+        if (ids.isEmpty()) {\n+            return true;\n+        }\n+\n+        \/\/ final check: does the simple name inferred from the label\n+        \/\/ match the simple name inferred from the reference\n+        var labelSimpleName = ids.get(ids.size() - 1);\n+        var refSimpleName = getSimpleName(refSignature);\n+        return !labelSimpleName.equals((refSimpleName));\n+    }\n+\n+    \/**\n+     * {@return the simple name from a signature}\n+     *\n+     * If there is a member part in the signature, the simple name is the\n+     * identifier after the {@code #} character.\n+     * Otherwise, the simple name is the last identifier in the signature.\n+     *\n+     * @param sig the signature\n+     *\/\n+    private String getSimpleName(String sig) {\n+        int hash = sig.indexOf('#');\n+        if (hash == -1 ) {\n+            int lastDot = sig.lastIndexOf(\".\");\n+            return lastDot == -1 ? sig : sig.substring(lastDot + 1);\n+        } else {\n+            int parens = sig.indexOf(\"(\", hash);\n+            return parens == -1 ? sig.substring(hash + 1) : sig.substring(hash + 1, parens);\n+        }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SeeTaglet.java","additions":119,"deletions":1,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -1251,8 +1251,2 @@\n-        if (env.currElement.getKind() == ElementKind.CONSTRUCTOR) {\n-            \/\/ A synthetic default constructor has the same pos as the\n-            \/\/ enclosing class\n-            TreePath p = env.currPath;\n-            return env.getPos(p) == env.getPos(p.getParentPath());\n-        } else {\n-            return false;\n-        }\n+        return env.currElement.getKind() == ElementKind.CONSTRUCTOR\n+                && env.elements.getOrigin(env.currElement) == Elements.Origin.MANDATED;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+@StackFilter({\"java.lang.ProcessBuilder\", \"java.lang.Runtime::exec\"})\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ProcessStartEvent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+@StackFilter({\"java.security.Security::setProperty\"})\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SecurityPropertyModificationEvent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+@StackFilter({\"java.security.Provider::getService\"})\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/SecurityProviderServiceEvent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+package jdk.jfr.events;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import jdk.jfr.MetadataDefinition;\n+\n+\/**\n+* Event annotation, specifies method names or classes to exclude in a stack\n+* trace.\n+* <p>\n+* The following example illustrates how the {@code StackFilter} annotation can\n+* be used to remove the {@code Logger::log} method in a stack trace:\n+*\n+* {@snippet :\n+* package com.example;\n+*\n+* @Name(\"example.LogMessage\")\n+* @Label(\"Log Message\")\n+* @StackFilter(\"com.example.Logger::log\")\n+* class LogMessage extends Event {\n+*     @Label(\"Message\")\n+*     String message;\n+* }\n+*\n+* public class Logger {\n+*\n+*     public static void log(String message) {\n+*         System.out.print(Instant.now() + \" : \" + message);\n+*         LogMessage event = new LogMessage();\n+*         event.message = message;\n+*         event.commit();\n+*     }\n+* }\n+* }\n+*\n+* @since 22\n+*\/\n+@Target({ ElementType.TYPE })\n+@Inherited\n+@Retention(RetentionPolicy.RUNTIME)\n+@MetadataDefinition\n+public @interface StackFilter {\n+    \/**\n+     * The methods or classes that should not be part of an event stack trace.\n+     * <p>\n+     * A filter is formed by using the fully qualified class name concatenated with\n+     * the method name using {@code \"::\"} as separator, for example\n+     * {@code \"java.lang.String::toString\"}\n+     * <p>\n+     * If only the name of a class is specified, for example {@code\n+     * \"java.lang.String\"}, all methods in that class are filtered out.\n+     * <p>\n+     * Methods can't be qualified using method parameters or return types.\n+     * <p>\n+     * Instance methods belonging to an interface can't be filtered out.\n+     * <p>\n+     * Wilcards are not permitted.\n+     *\n+     * @return the method names, not {@code null}\n+     *\/\n+     String[] value();\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/StackFilter.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+@StackFilter(\"sun.security.ssl.Finished::recordEvent\")\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/TLSHandshakeEvent.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+@StackFilter({\"java.lang.Thread::afterSleep\",\n+              \"java.lang.Thread::sleepNanos\",\n+              \"java.lang.Thread::sleep\"})\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/ThreadSleepEvent.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.module.Checks;\n@@ -47,0 +48,2 @@\n+import jdk.jfr.events.StackFilter;\n+import jdk.jfr.internal.JVM;\n@@ -68,0 +71,1 @@\n+    private static final long STACK_FILTER_ID = Type.getTypeId(StackFilter.class);\n@@ -92,0 +96,1 @@\n+        addStackFilters(eventType);\n@@ -99,0 +104,1 @@\n+        remove(eventType, aes, StackFilter.class);\n@@ -104,0 +110,72 @@\n+    private void addStackFilters(PlatformEventType eventType) {\n+        String[] filter = getStackFilter(eventType);\n+        if (filter != null) {\n+            int size = filter.length;\n+            List<String> types = new ArrayList<>(size);\n+            List<String> methods = new ArrayList<>(size);\n+            for (String frame : filter) {\n+                int index = frame.indexOf(\"::\");\n+                String clazz = null;\n+                String method = null;\n+                boolean valid = false;\n+                if (index != -1) {\n+                    clazz = frame.substring(0, index);\n+                    method = frame.substring(index + 2);\n+                    if (clazz.isEmpty()) {\n+                        clazz = null;\n+                        valid = isValidMethod(method);\n+                    } else {\n+                        valid = isValidType(clazz) && isValidMethod(method);\n+                    }\n+                } else {\n+                    clazz = frame;\n+                    valid = isValidType(frame);\n+                }\n+                if (valid) {\n+                    if (clazz == null) {\n+                        types.add(null);\n+                    } else {\n+                        types.add(clazz.replace(\".\", \"\/\"));\n+                    }\n+                    \/\/ If unqualified class name equals method name, it's a constructor\n+                    String className = clazz.substring(clazz.lastIndexOf(\".\") + 1);\n+                    if (className.equals(method)) {\n+                        method = \"<init>\";\n+                    }\n+                    methods.add(method);\n+                } else {\n+                    Logger.log(LogTag.JFR, LogLevel.WARN, \"@StackFrameFilter element ignored, not a valid Java identifier.\");\n+                }\n+            }\n+            if (!types.isEmpty()) {\n+                String[] typeArray = types.toArray(new String[0]);\n+                String[] methodArray = methods.toArray(new String[0]);\n+                long id = MetadataRepository.getInstance().registerStackFilter(typeArray, methodArray);\n+                eventType.setStackFilterId(id);\n+            }\n+        }\n+    }\n+\n+    private String[] getStackFilter(PlatformEventType eventType) {\n+        for (var a : eventType.getAnnotationElements()) {\n+            if (a.getTypeId() == STACK_FILTER_ID) {\n+                return (String[])a.getValue(\"value\");\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private boolean isValidType(String className) {\n+        if (className.length() < 1 || className.length() > 65535) {\n+            return false;\n+        }\n+        return Checks.isClassName(className);\n+    }\n+\n+    private boolean isValidMethod(String method) {\n+        if (method.length() < 1 || method.length() > 65535) {\n+            return false;\n+        }\n+        return Checks.isJavaIdentifier(method);\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -152,1 +152,6 @@\n-     * @param skipCount number of frames to skip\n+     * @param skipCount number of frames to skip, or 0 if no frames should be\n+     *                  skipped\n+     *\n+     * @param ID        ID of the filter that should be used, or -1 if no filter should\n+     *                  be used\n+     *\n@@ -155,1 +160,1 @@\n-    public static native long getStackTraceId(int skipCount);\n+    public static native long getStackTraceId(int skipCount, long stackFilerId);\n@@ -631,0 +636,26 @@\n+\n+    \/**\n+     * Registers stack filters that should be used with getStackTrace(int, long)\n+     * <p>\n+     * Method name at an array index is for class at the same array index.\n+     * <p>\n+     * This method should be called holding the MetadataRepository lock and before\n+     * bytecode for the associated event class has been added.\n+     *\n+     * @param classes, name of classes, for example {\"java\/lang\/String\"}, not\n+     *                 {@code null}\n+     * @param methods, name of method, for example {\"toString\"}, not {@code null}\n+     *\n+     * @return an ID that can be used to unregister the start frames, or -1 if it could not be registered\n+     *\/\n+    public static native long registerStackFilter(String[] classes, String[] methods);\n+\n+    \/**\n+     * Unregisters a set of stack filters.\n+     * <p>\n+     * This method should be called holding the MetadataRepository lock and after\n+     * the associated event class has been unloaded.\n+     *\n+     * @param stackFilterId the stack filter ID to unregister\n+     *\/\n+    public static native void unregisterStackFilter(long stackFilterId);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -324,0 +324,3 @@\n+                            if (pe.hasStackFilters()) {\n+                                JVM.unregisterStackFilter(pe.getStackFilterId());\n+                            }\n@@ -358,0 +361,4 @@\n+\n+    public synchronized long registerStackFilter(String[] typeArray, String[] methodArray) {\n+        return JVM.registerStackFilter(typeArray, methodArray);\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+    private long startFilterId = -1;\n@@ -342,0 +343,12 @@\n+\n+    public void setStackFilterId(long id) {\n+        startFilterId = id;\n+    }\n+\n+    public boolean hasStackFilters() {\n+        return startFilterId >= 0;\n+    }\n+\n+    public long getStackFilterId() {\n+        return startFilterId;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import jdk.internal.module.Modules;\n@@ -168,1 +169,0 @@\n-\n@@ -181,0 +181,9 @@\n+        \/\/ Add export from JDK proxy module\n+        if (annotation.getClass().getClassLoader() == null) {\n+            if (annotation.getClass().getName().contains(\"Proxy\")) {\n+                Module proxyModule = annotation.getClass().getModule();\n+                String proxyPackage = annotation.getClass().getPackageName();\n+                Module jfrModule = TypeLibrary.class.getModule();\n+                Modules.addExports(proxyModule, proxyPackage, jfrModule);\n+            }\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/TypeLibrary.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-            putLong(JVM.getStackTraceId(eventType.getStackTraceOffset()));\n+            putLong(JVM.getStackTraceId(eventType.getStackTraceOffset(), eventType.getStackFilterId()));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+    private static final String COMMON_SCRIPTS = \"COMMON_SCRIPTS\";\n@@ -68,1 +69,1 @@\n-            COMMANDS_INSTALL, COMMANDS_UNINSTALL, SCRIPTS);\n+            COMMANDS_INSTALL, COMMANDS_UNINSTALL, SCRIPTS, COMMON_SCRIPTS);\n@@ -232,2 +233,0 @@\n-        boolean needCleanupScripts = !associations.isEmpty();\n-\n@@ -244,4 +243,0 @@\n-            if (!integration.associations.isEmpty()) {\n-                needCleanupScripts = true;\n-            }\n-\n@@ -257,4 +252,2 @@\n-        if (needCleanupScripts) {\n-            \/\/ Pull in desktop_utils.sh scrips library.\n-            data.put(SCRIPTS, stringifyTextFile(\"desktop_utils.sh\"));\n-        }\n+        data.put(COMMON_SCRIPTS, stringifyTextFile(\"common_utils.sh\"));\n+        data.put(SCRIPTS, stringifyTextFile(\"desktop_utils.sh\"));\n@@ -298,1 +291,3 @@\n-            unregisterDesktopFileCmd = String.join(\" \", \"xdg-desktop-menu\",\n+            unregisterDesktopFileCmd = String.join(\" \",\n+                    \"do_if_file_belongs_to_single_package\", desktopFile.\n+                            installPath().toString(), \"xdg-desktop-menu\",\n@@ -306,2 +301,4 @@\n-            unregisterFileAssociationsCmd = String.join(\" \", \"xdg-mime\",\n-                    \"uninstall\", mimeInfoFile.installPath().toString());\n+            unregisterFileAssociationsCmd = String.join(\" \",\n+                    \"do_if_file_belongs_to_single_package\", mimeInfoFile.\n+                            installPath().toString(), \"xdg-mime\", \"uninstall\",\n+                    mimeInfoFile.installPath().toString());\n@@ -323,3 +320,5 @@\n-                    \"uninstall_default_mime_handler\",\n-                    desktopFile.installPath().getFileName().toString(),\n-                    String.join(\" \", getMimeTypeNamesFromFileAssociations()));\n+                    \"do_if_file_belongs_to_single_package\", desktopFile.\n+                            installPath().toString(),\n+                    \"desktop_uninstall_default_mime_handler\", desktopFile.\n+                            installPath().getFileName().toString(), String.join(\n+                            \" \", getMimeTypeNamesFromFileAssociations()));\n@@ -331,4 +330,0 @@\n-        void addIcon(String mimeType, Path iconFile) {\n-            addIcon(mimeType, iconFile, getSquareSizeOfImage(iconFile.toFile()));\n-        }\n-\n@@ -341,2 +336,4 @@\n-            unregisterIconCmds.add(String.join(\" \", \"xdg-icon-resource\",\n-                    \"uninstall\", dashMime, \"--size\", Integer.toString(imgSize)));\n+            unregisterIconCmds.add(String.join(\" \",\n+                    \"do_if_file_belongs_to_single_package\", iconFile.toString(),\n+                    \"xdg-icon-resource\", \"uninstall\", dashMime, \"--size\",\n+                    Integer.toString(imgSize)));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n@@ -45,0 +47,14 @@\n+    @Override\n+    protected List<String> replacementStringIds() {\n+        return LINUX_REPLACEMENT_STRING_IDS;\n+    }\n+\n+    @Override\n+    protected Map<String, String> createImpl() throws IOException {\n+        var data = super.createImpl();\n+        if (!data.isEmpty()) {\n+            data.put(COMMON_SCRIPTS, stringifyTextFile(\"common_utils.sh\"));\n+        }\n+        return data;\n+    }\n+\n@@ -48,1 +64,1 @@\n-            return ShellCustomAction.nop(REPLACEMENT_STRING_IDS);\n+            return ShellCustomAction.nop(LINUX_REPLACEMENT_STRING_IDS);\n@@ -87,0 +103,12 @@\n+\n+    private static final String COMMON_SCRIPTS = \"COMMON_SCRIPTS\";\n+\n+    private static final List<String> LINUX_REPLACEMENT_STRING_IDS;\n+\n+    static {\n+        ArrayList<String> buf = new ArrayList<>();\n+        buf.addAll(UnixLaunchersAsServices.REPLACEMENT_STRING_IDS);\n+        buf.add(COMMON_SCRIPTS);\n+\n+        LINUX_REPLACEMENT_STRING_IDS = Collections.unmodifiableList(buf);\n+    }\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxLaunchersAsServices.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,2 @@\n-                data.putAll(ca.instance.create());\n+                ShellCustomAction.mergeReplacementData(data, ca.instance.\n+                        create());\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBundler.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,23 @@\n+file_belongs_to_single_package ()\n+{\n+  if [ ! -e \"$1\" ]; then\n+    false\n+  elif [ \"$package_type\" = rpm ]; then\n+    test `rpm -q --whatprovides \"$1\" | wc -l` = 1\n+  elif [ \"$package_type\" = deb ]; then\n+    test `dpkg -S \"$1\" | wc -l` = 1\n+  else\n+    exit 1\n+  fi\n+}\n+\n+\n+do_if_file_belongs_to_single_package ()\n+{\n+  local file=\"$1\"\n+  shift\n+\n+  if file_belongs_to_single_package \"$file\"; then\n+    \"$@\"\n+  fi\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/common_utils.sh","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -5,1 +5,1 @@\n-_filter_out_default_mime_handler ()\n+desktop_filter_out_default_mime_handler ()\n@@ -53,1 +53,1 @@\n-_uninstall_default_mime_handler ()\n+desktop_uninstall_default_mime_handler_0 ()\n@@ -69,1 +69,1 @@\n-    _filter_out_default_mime_handler \"$desktop_file\" \"$mime\" \"$tmpfile1\" > \"$tmpfile2\"\n+    desktop_filter_out_default_mime_handler \"$desktop_file\" \"$mime\" \"$tmpfile1\" > \"$tmpfile2\"\n@@ -76,1 +76,1 @@\n-      trace Remove $desktop_file default handler for $mime mime type from $defaults_list file\n+      desktop_trace Remove $desktop_file default handler for $mime mime type from $defaults_list file\n@@ -82,1 +82,1 @@\n-    trace \"$defaults_list\" file updated\n+    desktop_trace \"$defaults_list\" file updated\n@@ -93,1 +93,1 @@\n-uninstall_default_mime_handler ()\n+desktop_uninstall_default_mime_handler ()\n@@ -96,1 +96,1 @@\n-    _uninstall_default_mime_handler \"$f\" \"$@\"\n+    desktop_uninstall_default_mime_handler_0 \"$f\" \"$@\"\n@@ -101,1 +101,1 @@\n-trace ()\n+desktop_trace ()\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/desktop_utils.sh","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,13 +26,0 @@\n-\n-file_belongs_to_single_package ()\n-{\n-  if [ ! -e \"$1\" ]; then\n-    false\n-  elif [ \"$package_type\" = rpm ]; then\n-    test `rpm -q --whatprovides \"$1\" | wc -l` = 1\n-  elif [ \"$package_type\" = deb ]; then\n-    test `dpkg -S \"$1\" | wc -l` = 1\n-  else\n-    exit 1\n-  fi\n-}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/services_utils.sh","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -17,0 +17,1 @@\n+COMMON_SCRIPTS\n@@ -22,1 +23,1 @@\n-  true; LAUNCHER_AS_SERVICE_COMMANDS_UNINSTALL\n+  :; LAUNCHER_AS_SERVICE_COMMANDS_UNINSTALL\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/template.preinst","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -21,0 +21,1 @@\n+COMMON_SCRIPTS\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/template.prerm","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+COMMON_SCRIPTS\n@@ -87,2 +88,2 @@\n-if [ \"$1\" = 2 ]; then\n-  true; LAUNCHER_AS_SERVICE_COMMANDS_UNINSTALL\n+if [ \"$1\" -gt 1 ]; then\n+  :; LAUNCHER_AS_SERVICE_COMMANDS_UNINSTALL\n@@ -93,0 +94,1 @@\n+COMMON_SCRIPTS\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/template.spec","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.util.Objects;\n@@ -77,0 +78,20 @@\n+    static void mergeReplacementData(Map<String, String> target,\n+            Map<String, String> newValues) {\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(newValues);\n+\n+        for (var kvp : newValues.entrySet()) {\n+            String newValue = kvp.getValue();\n+            String existingValue = target.putIfAbsent(kvp.getKey(), newValue);\n+            if (existingValue != null) {\n+                if (existingValue.isEmpty()) {\n+                    target.replace(kvp.getKey(), newValue);\n+                } else if (!newValue.isEmpty() && !newValue.\n+                        equals(existingValue)) {\n+                    throw new IllegalArgumentException(String.format(\n+                            \"Key [%s] value mismatch\", kvp.getKey()));\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/unix\/classes\/jdk\/jpackage\/internal\/ShellCustomAction.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,2 +68,2 @@\n-    final protected List<String> replacementStringIds() {\n-        return List.of(COMMANDS_INSTALL, COMMANDS_UNINSTALL, SCRIPTS);\n+    protected List<String> replacementStringIds() {\n+        return REPLACEMENT_STRING_IDS;\n@@ -73,1 +73,1 @@\n-    final protected Map<String, String> createImpl() throws IOException {\n+    protected Map<String, String> createImpl() throws IOException {\n@@ -90,5 +90,1 @@\n-        try {\n-            data.put(SCRIPTS, stringifyTextFile(\"services_utils.sh\"));\n-        } catch (IOException ex) {\n-            throw new RuntimeException(ex);\n-        }\n+        data.put(SCRIPTS, stringifyTextFile(\"services_utils.sh\"));\n","filename":"src\/jdk.jpackage\/unix\/classes\/jdk\/jpackage\/internal\/UnixLaunchersAsServices.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,0 +134,1 @@\n+            final boolean resourceUnlockedSuccess;\n@@ -137,1 +138,1 @@\n-                    for (UpdateResourceAction extraAction: extraActions) {\n+                    for (UpdateResourceAction extraAction : extraActions) {\n@@ -142,2 +143,4 @@\n-                if (resourceLock != 0) {\n-                    unlockResource(resourceLock);\n+                if (resourceLock == 0) {\n+                    resourceUnlockedSuccess = true;\n+                } else {\n+                    resourceUnlockedSuccess = unlockResource(resourceLock);\n@@ -146,0 +149,5 @@\n+\n+            if (!resourceUnlockedSuccess) {\n+                throw new RuntimeException(MessageFormat.format(I18N.getString(\n+                        \"error.unlock-resource\"), target));\n+            }\n@@ -253,1 +261,1 @@\n-    private static native void unlockResource(long resourceLock);\n+    private static native boolean unlockResource(long resourceLock);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/ExecutableRebrander.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+error.unlock-resource=Failed to unlock: {0}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+error.unlock-resource=Failed to unlock: {0}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_de.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+error.unlock-resource=Failed to unlock: {0}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_ja.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+error.unlock-resource=Failed to unlock: {0}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources_zh_CN.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+    notifyUnlockFailed();\n@@ -48,0 +49,1 @@\n+    notifyUnlockFailed();\n@@ -53,0 +55,3 @@\n+        if (unlockFailed) {\n+            *unlockFailed = true;\n+        }\n@@ -55,0 +60,2 @@\n+    } else if (unlockFailed) {\n+        *unlockFailed = false;\n","filename":"src\/jdk.jpackage\/windows\/native\/libjpackage\/ResourceEditor.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-        void discard(bool v = true) {\n+        FileLock& discard(bool v = true) {\n@@ -48,0 +48,6 @@\n+            return *this;\n+        }\n+\n+        FileLock& notifyUnlockFailed(bool* v = 0) {\n+            unlockFailed = v;\n+            return *this;\n@@ -62,0 +68,1 @@\n+        bool* unlockFailed;\n","filename":"src\/jdk.jpackage\/windows\/native\/libjpackage\/ResourceEditor.h","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-     * Signature: (J;)V\n+     * Signature: (J;)Z\n@@ -61,1 +61,1 @@\n-    JNIEXPORT void JNICALL\n+    JNIEXPORT jboolean JNICALL\n@@ -65,0 +65,1 @@\n+        bool unlockFailed = false;\n@@ -67,1 +68,3 @@\n-                reinterpret_cast<HANDLE>(jResourceLock)).ownHandle(true);\n+                reinterpret_cast<HANDLE>(jResourceLock))\n+                        .ownHandle(true)\n+                        .notifyUnlockFailed(&unlockFailed);\n@@ -69,0 +72,2 @@\n+\n+        return unlockFailed ? JNI_FALSE : JNI_TRUE;\n","filename":"src\/jdk.jpackage\/windows\/native\/libjpackage\/jpackage.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCMethodDecl;\n@@ -431,1 +432,3 @@\n-                                     .map(TreeInfo::firstConstructorCall)\n+                                     .filter(JCMethodDecl.class::isInstance)\n+                                     .map(JCMethodDecl.class::cast)\n+                                     .map(TreeInfo::findConstructorCall)\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/ExpressionToTypeInfo.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.util.Collections;\n@@ -51,0 +50,1 @@\n+import java.io.PrintStream;\n@@ -54,0 +54,1 @@\n+import jdk.jshell.execution.JdiDefaultExecutionControl.JdiStarter.TargetDescription;\n@@ -97,2 +98,1 @@\n-    static ExecutionControl create(ExecutionEnv env, String remoteAgent,\n-            boolean isLaunch, String host, int timeout) throws IOException {\n+    static ExecutionControl create(ExecutionEnv env, Map<String, String> parameters, String remoteAgent, int timeout, JdiStarter starter) throws IOException {\n@@ -110,0 +110,26 @@\n+            ExecutionEnv augmentedEnv = new ExecutionEnv() {\n+                @Override\n+                public InputStream userIn() {\n+                    return env.userIn();\n+                }\n+\n+                @Override\n+                public PrintStream userOut() {\n+                    return env.userOut();\n+                }\n+\n+                @Override\n+                public PrintStream userErr() {\n+                    return env.userErr();\n+                }\n+\n+                @Override\n+                public List<String> extraRemoteVMOptions() {\n+                    return augmentedremoteVMOptions;\n+                }\n+\n+                @Override\n+                public void closeDown() {\n+                    env.closeDown();\n+                }\n+            };\n@@ -112,5 +138,3 @@\n-            JdiInitiator jdii = new JdiInitiator(port,\n-                    augmentedremoteVMOptions, remoteAgent, isLaunch, host,\n-                    timeout, Collections.emptyMap());\n-            VirtualMachine vm = jdii.vm();\n-            Process process = jdii.process();\n+            TargetDescription target = starter.start(augmentedEnv, parameters, port);\n+            VirtualMachine vm = target.vm();\n+            Process process = target.process();\n@@ -297,0 +321,27 @@\n+    \/**\n+     * Start an external process where the user's snippets can be run.\n+     *\n+     * @since 22\n+     *\/\n+    public interface JdiStarter {\n+        \/**\n+         * Start the external process based on the given parameters. The external\n+         * process should connect to the given {@code port} to communicate with the\n+         * driving instance of JShell.\n+         *\n+         * @param env the execution context\n+         * @param parameters additional execution parameters\n+         * @param port the port to which the remote process should connect\n+         * @return a description of the started external process\n+         * @throws RuntimeException if the process cannot be started\n+         * @throws Error if the process cannot be started\n+         *\/\n+        public TargetDescription start(ExecutionEnv env, Map<String, String> parameters, int port);\n+\n+        \/**\n+         * The description of a started external process.\n+         * @param vm the JDI's {@code VirtualMachine}\n+         * @param process the external {@code Process}\n+         *\/\n+        public record TargetDescription(VirtualMachine vm, Process process) {}\n+    }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiDefaultExecutionControl.java","additions":60,"deletions":9,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Collections;\n@@ -32,0 +33,1 @@\n+import jdk.jshell.execution.JdiDefaultExecutionControl.JdiStarter;\n@@ -69,0 +71,2 @@\n+    private final JdiStarter starter;\n+\n@@ -76,0 +80,31 @@\n+        this(new JdiStarter() {\n+            @Override\n+            public TargetDescription start(ExecutionEnv env, Map<String, String> parameters, int port) {\n+                String remoteAgent = parameters.get(PARAM_REMOTE_AGENT);\n+                int timeout = Integer.parseUnsignedInt(\n+                    parameters.get(PARAM_TIMEOUT));\n+                String host = parameters.get(PARAM_HOST_NAME);\n+                String sIsLaunch = parameters.get(PARAM_LAUNCH)\n+                                             .toLowerCase(Locale.ROOT);\n+                boolean isLaunch = sIsLaunch.length() > 0\n+                    && (\"true\".startsWith(sIsLaunch) || \"yes\".startsWith(sIsLaunch));\n+\n+                JdiInitiator jdii = new JdiInitiator(port,\n+                    env.extraRemoteVMOptions(), remoteAgent, isLaunch, host,\n+                    timeout, Collections.emptyMap());\n+                return new TargetDescription(jdii.vm(), jdii.process());\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Create an instance.  An instance can be used to\n+     * {@linkplain  #generate generate} an {@link ExecutionControl} instance\n+     * that uses the Java Debug Interface as part of the control of a remote\n+     * process. The provided {@code start} will be used to start the remote process.\n+     *\n+     * @param starter starter that will create the remote process\n+     * @since 22\n+     *\/\n+    public JdiExecutionControlProvider(JdiStarter starter) {\n+        this.starter = starter;\n@@ -145,1 +180,2 @@\n-        String remoteAgent = parameters.getOrDefault(PARAM_REMOTE_AGENT, dp.get(PARAM_REMOTE_AGENT));\n+        parameters = new HashMap<>(parameters);\n+        String remoteAgent = parameters.computeIfAbsent(PARAM_REMOTE_AGENT, x -> dp.get(PARAM_REMOTE_AGENT));\n@@ -147,6 +183,5 @@\n-                parameters.getOrDefault(PARAM_TIMEOUT, dp.get(PARAM_TIMEOUT)));\n-        String host = parameters.getOrDefault(PARAM_HOST_NAME, dp.get(PARAM_HOST_NAME));\n-        String sIsLaunch = parameters.getOrDefault(PARAM_LAUNCH, dp.get(PARAM_LAUNCH)).toLowerCase(Locale.ROOT);\n-        boolean isLaunch = sIsLaunch.length() > 0\n-                && (\"true\".startsWith(sIsLaunch) || \"yes\".startsWith(sIsLaunch));\n-        return JdiDefaultExecutionControl.create(env, remoteAgent, isLaunch, host, timeout);\n+                parameters.computeIfAbsent(PARAM_TIMEOUT, x -> dp.get(PARAM_TIMEOUT)));\n+        parameters.putIfAbsent(PARAM_HOST_NAME, dp.get(PARAM_HOST_NAME));\n+        parameters.putIfAbsent(PARAM_LAUNCH, dp.get(PARAM_LAUNCH));\n+\n+        return JdiDefaultExecutionControl.create(env, parameters, remoteAgent, timeout, starter);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiExecutionControlProvider.java","additions":42,"deletions":7,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -156,0 +156,45 @@\n+        try {\n+            String addr;\n+\n+            try {\n+                \/\/ Start listening, get the JDI connection address\n+                addr = listener.startListening(connectorArgs);\n+                debug(\"Listening at address: \" + addr);\n+            } catch (Throwable t) {\n+                throw reportLaunchFail(t, \"listen\");\n+            }\n+\n+            runListenProcess(addr, port, remoteVMOptions, process -> {\n+                \/\/ Accept the connection from the remote agent\n+                vm = timedVirtualMachineCreation(() -> listener.accept(connectorArgs),\n+                        () -> process.waitFor());\n+                try {\n+                    listener.stopListening(connectorArgs);\n+                } catch (IOException | IllegalConnectorArgumentsException ex) {\n+                    \/\/ ignore\n+                }\n+            });\n+            return vm;\n+        } catch (Throwable ex) {\n+            try {\n+                listener.stopListening(connectorArgs);\n+            } catch (IOException | IllegalConnectorArgumentsException iex) {\n+                \/\/ ignore\n+            }\n+            throw ex;\n+        }\n+    }\n+\n+    \/**\n+     * Create a process that will attach to the given address.\n+     * @param jdiAddress address on which a JDI server is waiting for a connection\n+     * @param jshellControlPort the port which the remote agent should connect to\n+     * @param remoteVMOptions VM options for the remote agent VM\n+     * @param setupVM a callback that should be called then the remote agent process\n+     *                is created. The callback will setup the JDI's {@code VirtualMachine}.\n+     * @since 22\n+     *\/\n+    protected void runListenProcess(String jdiAddress,\n+                                    int jshellControlPort,\n+                                    List<String> remoteVMOptions,\n+                                    ProcessStarted setupVM) {\n@@ -160,4 +205,0 @@\n-            \/\/ Start listening, get the JDI connection address\n-            String addr = listener.startListening(connectorArgs);\n-            debug(\"Listening at address: \" + addr);\n-\n@@ -171,1 +212,1 @@\n-                    \",address=\" + addr);\n+                    \",address=\" + jdiAddress);\n@@ -174,1 +215,1 @@\n-            args.add(\"\" + port);\n+            args.add(\"\" + jshellControlPort);\n@@ -180,8 +221,2 @@\n-            \/\/ Accept the connection from the remote agent\n-            vm = timedVirtualMachineCreation(() -> listener.accept(connectorArgs),\n-                    () -> process.waitFor());\n-            try {\n-                listener.stopListening(connectorArgs);\n-            } catch (IOException | IllegalConnectorArgumentsException ex) {\n-                \/\/ ignore\n-            }\n+            setupVM.processStarted(process);\n+\n@@ -190,1 +225,0 @@\n-            return vm;\n@@ -195,5 +229,0 @@\n-            try {\n-                listener.stopListening(connectorArgs);\n-            } catch (IOException | IllegalConnectorArgumentsException iex) {\n-                \/\/ ignore\n-            }\n@@ -331,0 +360,15 @@\n+    \/**\n+     * Callback that should invoked when the remote process is invoked.\n+     *\n+     * @since 22\n+     *\/\n+    protected interface ProcessStarted {\n+        \/**\n+         * Notify the process has been started.\n+         *\n+         * @param p the {@code Process}\n+         * @throws Throwable thrown when anything goes wrong.\n+         *\/\n+        public void processStarted(Process p) throws Throwable;\n+    }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiInitiator.java","additions":64,"deletions":20,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,6 @@\n+\/* Undefine macro to avoid generating invalid C code.\n+   Capstone refactored cs_detail for AArch64 architecture\n+   from `cs_arm64 arm64` to `cs_aarch64 aarch64`\n+   and that causes invalid macro expansion.\n+*\/\n+#undef aarch64\n","filename":"src\/utils\/hsdis\/capstone\/hsdis-capstone.c","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-native.core.args=-c \".dump \/f core.%p;qd\" -p %p\n-native.core.params.timeout=3600000\n+native.core.args=-c \".dump \/mA core.%p;qd\" -p %p\n+native.core.params.timeout=600000\n","filename":"test\/failure_handler\/src\/share\/conf\/windows.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -188,2 +188,7 @@\n-  const uint nthreads = 4;\n-  const uint milliseconds_to_run = 1000;\n+\n+  \/\/ deallocation is slower than allocation, so lets create\n+  \/\/ more deallocation threads to prevent too large buildup of\n+  \/\/ free nodes (footprint)\n+  constexpr uint num_allocator_threads = 4;\n+  constexpr uint num_processor_threads = 6;\n+  constexpr uint milliseconds_to_run = 1000;\n@@ -196,2 +201,2 @@\n-  ProcessorThread* proc_threads[nthreads] = {};\n-  for (uint i = 0; i < nthreads; ++i) {\n+  ProcessorThread* proc_threads[num_processor_threads] = {};\n+  for (uint i = 0; i < num_processor_threads; ++i) {\n@@ -205,2 +210,2 @@\n-  AllocatorThread* alloc_threads[nthreads] = {};\n-  for (uint i = 0; i < nthreads; ++i) {\n+  AllocatorThread* alloc_threads[num_allocator_threads] = {};\n+  for (uint i = 0; i < num_allocator_threads; ++i) {\n@@ -222,1 +227,1 @@\n-  for (uint i = 0; i < nthreads; ++i) {\n+  for (uint i = 0; i < num_allocator_threads; ++i) {\n@@ -227,1 +232,1 @@\n-  for (uint i = 0; i < nthreads; ++i) {\n+  for (uint i = 0; i < num_processor_threads; ++i) {\n@@ -237,1 +242,1 @@\n-  const size_t buffer_capacity = 1024;\n+  const size_t buffer_capacity = DEFAULT_CACHE_LINE_SIZE \/ sizeof(void*);\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_bufferNodeAllocator.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -72,0 +72,3 @@\n+  \/\/ Caveat: BufferUpdater is not MT-safe. We use it only for testing.\n+  \/\/ We would observe missing loglines if we interleaved buffers.\n+  \/\/ Emit all logs between constructor and destructor of BufferUpdater.\n@@ -73,3 +76,1 @@\n-    auto writer = AsyncLogWriter::instance();\n-    if (writer != nullptr) {\n-      const size_t sz = 2000;\n+    const size_t sz = 2000;\n@@ -77,3 +78,4 @@\n-      \/\/ shrink async buffer.\n-      AsyncLogWriter::BufferUpdater saver(1024);\n-      LogMessage(logging) lm;\n+    \/\/ shrink async buffer.\n+    AsyncLogWriter::BufferUpdater saver(1024);\n+    test_asynclog_ls(); \/\/ roughly 200 bytes.\n+    LogMessage(logging) lm;\n@@ -81,5 +83,3 @@\n-      \/\/ write more messages than its capacity in burst\n-      for (size_t i = 0; i < sz; ++i) {\n-        lm.debug(\"a lot of log...\");\n-      }\n-      lm.flush();\n+    \/\/ write more messages than its capacity in burst\n+    for (size_t i = 0; i < sz; ++i) {\n+      lm.debug(\"a lot of log...\");\n@@ -87,0 +87,1 @@\n+    lm.flush();\n@@ -96,2 +97,1 @@\n-      \/\/ at least see \"header\"\n-      return fclose(f) == 0 && sz == written && sz >= 6;\n+      return fclose(f) == 0 && sz == written;\n@@ -247,0 +247,4 @@\n+  if (AsyncLogWriter::instance() == nullptr) {\n+    return;\n+  }\n+\n@@ -249,5 +253,1 @@\n-\n-  AsyncLogWriter::flush();\n-  if (AsyncLogWriter::instance() != nullptr) {\n-    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n-  }\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n@@ -258,1 +258,0 @@\n-  fprintf(stdout, \"header\");\n@@ -264,2 +263,7 @@\n-  test_asynclog_ls();\n-  test_asynclog_drop_messages();\n+  bool async = AsyncLogWriter::instance() != nullptr;\n+  if (async) {\n+    test_asynclog_drop_messages();\n+    AsyncLogWriter::flush();\n+  } else {\n+    test_asynclog_ls();\n+  }\n@@ -267,1 +271,0 @@\n-  AsyncLogWriter::flush();\n@@ -269,1 +272,0 @@\n-\n@@ -274,1 +276,0 @@\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"header\"));\n@@ -279,1 +280,1 @@\n-  if (AsyncLogWriter::instance() != nullptr) {\n+  if (async) {\n@@ -286,1 +287,0 @@\n-  fprintf(stderr, \"header\");\n@@ -292,2 +292,7 @@\n-  test_asynclog_ls();\n-  test_asynclog_drop_messages();\n+  bool async = AsyncLogWriter::instance() != nullptr;\n+  if (async) {\n+    test_asynclog_drop_messages();\n+    AsyncLogWriter::flush();\n+  } else {\n+    test_asynclog_ls();\n+  }\n@@ -295,1 +300,0 @@\n-  AsyncLogWriter::flush();\n@@ -297,1 +301,0 @@\n-\n@@ -302,1 +305,0 @@\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"header\"));\n@@ -307,1 +309,1 @@\n-  if (AsyncLogWriter::instance() != nullptr) {\n+  if (async) {\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":34,"deletions":32,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -63,3 +63,0 @@\n-  \/\/ Check if 64-bit atomics are available on the machine.\n-  if (!VM_Version::supports_cx8()) return;\n-\n@@ -112,3 +109,0 @@\n-  \/\/ Check if 64-bit atomics are available on the machine.\n-  if (!VM_Version::supports_cx8()) return;\n-\n@@ -352,3 +346,0 @@\n-  \/\/ Check if 64-bit atomics are available on the machine.\n-  if (!VM_Version::supports_cx8()) return;\n-\n@@ -359,3 +350,0 @@\n-  \/\/ Check if 64-bit atomics are available on the machine.\n-  if (!VM_Version::supports_cx8()) return;\n-\n","filename":"test\/hotspot\/gtest\/runtime\/test_atomic.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -604,0 +604,62 @@\n+\n+TEST(GrowableArrayCHeap, find_if) {\n+  struct Element {\n+    int value;\n+  };\n+  GrowableArrayCHeap<Element, mtTest> array;\n+  array.push({1});\n+  array.push({2});\n+  array.push({3});\n+\n+  {\n+    int index = array.find_if([&](const Element& elem) {\n+      return elem.value == 1;\n+    });\n+    ASSERT_EQ(index, 0);\n+  }\n+\n+  {\n+    int index = array.find_if([&](const Element& elem) {\n+      return elem.value > 1;\n+    });\n+    ASSERT_EQ(index, 1);\n+  }\n+\n+  {\n+    int index = array.find_if([&](const Element& elem) {\n+      return elem.value == 4;\n+    });\n+    ASSERT_EQ(index, -1);\n+  }\n+}\n+\n+TEST(GrowableArrayCHeap, find_from_end_if) {\n+  struct Element {\n+    int value;\n+  };\n+  GrowableArrayCHeap<Element, mtTest> array;\n+  array.push({1});\n+  array.push({2});\n+  array.push({3});\n+\n+  {\n+    int index = array.find_from_end_if([&](const Element& elem) {\n+      return elem.value == 1;\n+    });\n+    ASSERT_EQ(index, 0);\n+  }\n+\n+  {\n+    int index = array.find_from_end_if([&](const Element& elem) {\n+      return elem.value > 1;\n+    });\n+    ASSERT_EQ(index, 2);\n+  }\n+\n+  {\n+    int index = array.find_from_end_if([&](const Element& elem) {\n+      return elem.value == 4;\n+    });\n+    ASSERT_EQ(index, -1);\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_growableArray.cpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+compiler\/vectorapi\/reshape\/TestVectorReinterpret.java 8320897 aix-ppc64,linux-ppc64le\n@@ -89,2 +90,2 @@\n-gc\/stress\/gclocker\/TestGCLockerWithG1.java 8180622 generic-all\n-gc\/stress\/TestJNIBlockFullGC\/TestJNIBlockFullGC.java 8192647 generic-all\n+gc\/stress\/gclocker\/TestGCLockerWithSerial.java 8180622 generic-all\n+gc\/stress\/gclocker\/TestGCLockerWithShenandoah.java 8180622 generic-all\n@@ -137,1 +138,1 @@\n-serviceability\/attach\/ConcAttachTest.java 8290043 linux-all\n+serviceability\/attach\/ConcAttachTest.java 8290043,8318866 linux-all,macosx-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2;\n+\n+import java.io.PrintStream;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+\/*\n+ * @test id=default_config\n+ * @bug 8267532\n+ * @summary Test whether trap in place of pruned exception handler block works\n+ *\n+ * @run main\/othervm\n+ *   -Xbatch\n+ *   -Xlog:deoptimization=trace\n+ *   -XX:CompileCommand=PrintCompilation,compiler.c2.TestExHandlerTrap::payload\n+ *   -XX:CompileCommand=dontinline,compiler.c2.TestExHandlerTrap::payload\n+ *   -XX:CompileCommand=dontinline,compiler.c2.TestExHandlerTrap::maybeThrow\n+ *   compiler.c2.TestExHandlerTrap\n+ *\/\n+\n+\/*\n+ * @test id=no_profiling\n+ * @bug 8267532\n+ * @summary basic smoke test for disabled ex. handler profiling\n+ *\n+ * @run main\/othervm\n+ *   -Xbatch\n+ *   -Xlog:deoptimization=trace\n+ *   -XX:CompileCommand=PrintCompilation,compiler.c2.TestExHandlerTrap::payload\n+ *   -XX:CompileCommand=dontinline,compiler.c2.TestExHandlerTrap::payload\n+ *   -XX:CompileCommand=dontinline,compiler.c2.TestExHandlerTrap::maybeThrow\n+ *   -XX:-ProfileExceptionHandlers\n+ *   compiler.c2.TestExHandlerTrap\n+ *\/\n+\n+\/*\n+ * @test id=stress\n+ * @bug 8267532\n+ * @summary basic smoke test for stressing ex. handler pruning\n+ * @requires vm.debug\n+ *\n+ * @run main\/othervm\n+ *   -Xbatch\n+ *   -Xlog:deoptimization=trace\n+ *   -XX:CompileCommand=PrintCompilation,compiler.c2.TestExHandlerTrap::payload\n+ *   -XX:CompileCommand=dontinline,compiler.c2.TestExHandlerTrap::payload\n+ *   -XX:CompileCommand=dontinline,compiler.c2.TestExHandlerTrap::maybeThrow\n+ *   -XX:+StressPrunedExceptionHandlers\n+ *   compiler.c2.TestExHandlerTrap\n+ *\/\n+\n+public class TestExHandlerTrap {\n+\n+    private static final String EX_MESSAGE = \"Testing trap\";\n+\n+    public static void main(String[] args) throws Throwable {\n+        \/\/ warmup, compile payload\n+        for (int i = 0; i < 20_000; i++) {\n+            payload(false);\n+        }\n+\n+        try {\n+            \/\/ trigger uncommon trap in pruned catch block\n+            payload(true);\n+        } catch (IllegalStateException e) {\n+            if (!e.getMessage().equals(EX_MESSAGE)) {\n+                throw e;\n+            }\n+        }\n+\n+        \/\/ continue for a bit, to see if anything breaks\n+        for (int i = 0; i < 1_000; i++) {\n+            payload(false);\n+        }\n+    }\n+\n+    public static void payload(boolean shouldThrow) {\n+        doIt(shouldThrow); \/\/ mix in some inlining\n+    }\n+\n+    public static void doIt(boolean shouldThrow) {\n+        PrintStream err = System.err;\n+        try (ConfinedScope r = new ConfinedScope()) {\n+            r.addCloseAction(dummy);\n+            maybeThrow(shouldThrow); \/\/ out of line to prevent 'payload' from being deoptimized by unstable if\n+        } catch (IllegalArgumentException e) {\n+            \/\/ some side effects to see whether deopt is successful\n+            err.println(\"Exception message: \" + e.getMessage());\n+            err.println(\"shouldThrow: \" + shouldThrow);\n+        }\n+    }\n+\n+    private static void maybeThrow(boolean shouldThrow) {\n+        if (shouldThrow) {\n+            throw new IllegalStateException(EX_MESSAGE);\n+        }\n+    }\n+\n+    static final Runnable dummy = () -> {};\n+\n+    static class ConfinedScope implements AutoCloseable {\n+        final Thread owner;\n+        boolean closed;\n+        final List<Runnable> resources = new ArrayList<>();\n+\n+        private void checkState() {\n+            if (closed) {\n+                throw new AssertionError(\"Closed\");\n+            } else if (owner != Thread.currentThread()) {\n+                throw new AssertionError(\"Wrong thread\");\n+            }\n+        }\n+\n+        ConfinedScope() {\n+            this.owner = Thread.currentThread();\n+        }\n+\n+        void addCloseAction(Runnable runnable) {\n+            checkState();\n+            resources.add(runnable);\n+        }\n+\n+        public void close() {\n+            checkState();\n+            closed = true;\n+            for (Runnable r : resources) {\n+                r.run();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestExHandlerTrap.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8320330\n+ * @summary Test that RShiftINode optimizations are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.RShiftINodeIdealizationTests\n+ *\/\n+public class RShiftINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\" })\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        int b = RunInfo.getRandom().nextInt();\n+        int c = RunInfo.getRandom().nextInt();\n+        int d = RunInfo.getRandom().nextInt();\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(a, 0);\n+        assertResult(a, b);\n+        assertResult(b, a);\n+        assertResult(c, d);\n+        assertResult(d, c);\n+        assertResult(min, max);\n+        assertResult(max, min);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int x, int y) {\n+        Asserts.assertEQ((x >> y) >= 0 ? 0 : 1, test1(x, y));\n+        Asserts.assertEQ(((x & 127) >> y) >= 0 ? 0 : 1, test2(x, y));\n+        Asserts.assertEQ(((-(x & 127) - 1) >> y) >= 0 ? 0 : 1, test3(x, y));\n+        Asserts.assertEQ((x >> 30) > 4 ? 0 : 1, test4(x, y));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT, \"1\" })\n+    public int test1(int x, int y) {\n+        return (x >> y) >= 0 ? 0 : 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT })\n+    public int test2(int x, int y) {\n+        return ((x & 127) >> y) >= 0 ? 0 : 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT })\n+    public int test3(int x, int y) {\n+        return ((-(x & 127) - 1) >> y) >= 0 ? 0 : 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT })\n+    public int test4(int x, int y) {\n+        return (x >> 30) > 4 ? 0 : 1;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RShiftINodeIdealizationTests.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8320330\n+ * @summary Test that RShiftLNode optimizations are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.RShiftLNodeIdealizationTests\n+ *\/\n+public class RShiftLNodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\" })\n+    public void runMethod() {\n+        long a = RunInfo.getRandom().nextLong();\n+        long b = RunInfo.getRandom().nextLong();\n+        long c = RunInfo.getRandom().nextLong();\n+        long d = RunInfo.getRandom().nextLong();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(a, 0);\n+        assertResult(a, b);\n+        assertResult(b, a);\n+        assertResult(c, d);\n+        assertResult(d, c);\n+        assertResult(min, max);\n+        assertResult(max, min);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long x, long y) {\n+        Asserts.assertEQ((x >> y) >= 0 ? 0L : 1L, test1(x, y));\n+        Asserts.assertEQ(((x & 127) >> y) >= 0 ? 0L : 1L, test2(x, y));\n+        Asserts.assertEQ(((-(x & 127) - 1) >> y) >= 0 ? 0L : 1L, test3(x, y));\n+        Asserts.assertEQ((x >> 62) > 4 ? 0L : 1L, test4(x, y));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.RSHIFT, \"1\" })\n+    public long test1(long x, long y) {\n+        return (x >> y) >= 0 ? 0 : 1;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT })\n+    public long test2(long x, long y) {\n+        return ((x & 127) >> y) >= 0 ? 0L : 1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT })\n+    public long test3(long x, long y) {\n+        return ((-(x & 127) - 1) >> y) >= 0 ? 0L : 1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT })\n+    public long test4(long x, long y) {\n+        return (x >> 62) > 4 ? 0L : 1L;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/RShiftLNodeIdealizationTests.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8267532\n+ * @summary check that uncommon trap is generated for unhandled catch block\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestPrunedExHandler\n+ *\/\n+\n+public class TestPrunedExHandler {\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\n+            \"-XX:+TieredCompilation\", \/\/ we only profile in tier 3\n+            \"-XX:CompileCommand=inline,compiler.c2.irTests.TestPrunedExHandler::inlinee\",\n+            \"-XX:CompileCommand=dontinline,compiler.c2.irTests.TestPrunedExHandler::outOfLine\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UNREACHED_TRAP, \"1\"})\n+    public static void testTrap() {\n+        try {\n+            outOfLine(false);\n+        } catch (IllegalStateException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private static void outOfLine(boolean shouldThrow) {\n+        if (shouldThrow) {\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UNREACHED_TRAP, \"0\"})\n+    public static void testNoTrap(boolean shouldThrow) {\n+        try {\n+            outOfLine(shouldThrow);\n+        } catch (IllegalStateException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Run(test = \"testNoTrap\", mode = RunMode.STANDALONE)\n+    public static void runNoTrap(RunInfo info) {\n+        for (int i = 0; i < 2_000; i++) { \/\/ tier 3\n+            testNoTrap(false);\n+        }\n+\n+        TestFramework.assertCompiledAtLevel(info.getTest(), CompLevel.C1_FULL_PROFILE);\n+\n+        testNoTrap(true); \/\/ mark ex handler as entered\n+\n+        for (int i = 0; i < 20_000; i++) { \/\/ tier 4\n+            testNoTrap(false); \/\/ should have no trap\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UNREACHED_TRAP, \"0\"})\n+    public static void testNoTrapAfterDeopt(boolean shouldThrow) {\n+        try {\n+            outOfLine(shouldThrow);\n+        } catch (IllegalStateException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Run(test = \"testNoTrapAfterDeopt\", mode = RunMode.STANDALONE)\n+    public static void runNoTrapAfterDeopt(RunInfo info) {\n+        for (int i = 0; i < 20_000; i++) { \/\/ tier 4\n+            testNoTrapAfterDeopt(false);\n+        }\n+\n+        TestFramework.assertCompiledByC2(info.getTest());\n+\n+        testNoTrapAfterDeopt(true); \/\/ deopt + mark ex handler as entered\n+\n+        TestFramework.assertDeoptimizedByC2(info.getTest());\n+\n+        for (int i = 0; i < 20_000; i++) { \/\/ tier 4 again\n+            testNoTrapAfterDeopt(false); \/\/ should have no trap\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UNREACHED_TRAP, \"0\"})\n+    public static void testNoTrapAfterDeoptInlined(boolean shouldThrow) {\n+        \/\/ check that we handle exception thrown in inlinee, caught in caller.\n+        \/\/ C2 handles exception dispatch differently for those cases\n+        try {\n+            inlinee(shouldThrow);\n+        } catch (IllegalStateException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private static void inlinee(boolean shouldThrow) {\n+        outOfLine(shouldThrow);\n+    }\n+\n+    @Run(test = \"testNoTrapAfterDeoptInlined\", mode = RunMode.STANDALONE)\n+    public static void runNoTrapAfterDeoptInlined(RunInfo info) {\n+        for (int i = 0; i < 20_000; i++) { \/\/ tier 4\n+            testNoTrapAfterDeoptInlined(false);\n+        }\n+\n+        TestFramework.assertCompiledByC2(info.getTest());\n+\n+        testNoTrapAfterDeoptInlined(true); \/\/ deopt + mark ex handler as entered\n+\n+        TestFramework.assertDeoptimizedByC2(info.getTest());\n+\n+        for (int i = 0; i < 20_000; i++) { \/\/ tier 4 again\n+            testNoTrapAfterDeoptInlined(false); \/\/ should have no trap\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UNREACHED_TRAP, \"1\"})\n+    public static void testThrowBeforeProfiling(boolean shouldThrow) {\n+        try {\n+            outOfLine(shouldThrow);\n+        } catch (IllegalStateException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Run(test = \"testThrowBeforeProfiling\", mode = RunMode.STANDALONE)\n+    public static void runThrowBeforeProfiling(RunInfo info) {\n+        testThrowBeforeProfiling(true);\n+        \/\/ this exception should not be profiled, as MDO has not been created yet\n+\n+        for (int i = 0; i < 20_000; i++) { \/\/ tier 4\n+            testThrowBeforeProfiling(false);\n+        }\n+        \/\/ should have trap\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.UNREACHED_TRAP, \"0\"})\n+    public static void testInterpreterProfiling(boolean takeBranch, boolean shouldThrow) {\n+        if (takeBranch) {\n+            System.out.println(\"testInterpreterProfiling: branch taken\");\n+        }\n+\n+        try {\n+            outOfLine(shouldThrow);\n+        } catch (IllegalStateException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Run(test = \"testInterpreterProfiling\", mode = RunMode.STANDALONE)\n+    public static void runInterpreterProfiling(RunInfo info) {\n+        for (int i = 0; i < 20_000; i++) { \/\/ tier 4\n+            testInterpreterProfiling(false, false);\n+        }\n+        TestFramework.assertCompiledByC2(info.getTest());\n+        \/\/ should have no trap at this point\n+\n+        testInterpreterProfiling(true, false); \/\/ take branch -> deopt due to unstable if\n+        TestFramework.assertDeoptimizedByC2(info.getTest());\n+\n+        \/\/ continue in the interpreter:\n+        testInterpreterProfiling(false, false);\n+        \/\/ throw exception in the interpreter, test interpreter profiling:\n+        testInterpreterProfiling(false, true);\n+\n+        for (int i = 0; i < 20_000; i++) { \/\/ tier 4 again\n+            testInterpreterProfiling(false, false);\n+        }\n+        \/\/ should have no trap\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPrunedExHandler.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8316422\n+* @summary Test exception state used for deoptimization.\n+* @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack -XX:+DeoptimizeALot\n+*      -Xcomp -XX:TieredStopAtLevel=1 -XX:CompileOnly=compiler.exceptions.TestDeoptExceptionState::test\n+*      compiler.exceptions.TestDeoptExceptionState\n+*\/\n+\n+package compiler.exceptions;\n+\n+public class TestDeoptExceptionState {\n+    private static int res = 0;\n+\n+    public static void main(String args[]) {\n+        int x = 42;\n+        int y = 1 + test();\n+        System.out.println(\"Foo \" + x + \" \" + y);\n+    }\n+\n+    public static int test() {\n+      int x = 42;\n+      int y = 1 + test1();\n+      return x + y;\n+    }\n+\n+    public static int test1() {\n+        for (int i = 0; i < 100; i++) {\n+            try {\n+                divZero();\n+            } catch (ArithmeticException ea) {\n+                \/\/ Expected\n+            }\n+        }\n+        return 1;\n+    }\n+\n+    public static void divZero() {\n+        res += div(0, 0);\n+    }\n+\n+    public static long div(long dividend, long divisor) {\n+        return dividend \/ divisor;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/TestDeoptExceptionState.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -39,0 +39,3 @@\n+ * @requires (vm.cpu.features ~= \".*avx512.*\" | vm.cpu.features ~= \".*avx2.*\" | vm.cpu.features ~= \".*avx.*\") |\n+ *           (os.arch==\"aarch64\" & vm.cpu.features ~= \".*simd.*\") |\n+ *           (os.arch == \"riscv64\" & vm.cpu.features ~= \".*v,.*\")\n@@ -60,1 +63,1 @@\n-    private static boolean containsFuzzy(List<String> list, String sub) {\n+    private static boolean containsFuzzy(List<String> list, String sub, Boolean matchExactly) {\n@@ -62,1 +65,5 @@\n-            if (s.contains(sub)) return true;\n+            if (matchExactly) {\n+                if (s.equals(sub)) return true;\n+            } else {\n+                if (s.contains(sub)) return true;\n+            }\n@@ -82,1 +89,1 @@\n-            if (containsFuzzy(cpuFeatures, \"avx512\")) {\n+            if (containsFuzzy(cpuFeatures, \"avx512\", false)) {\n@@ -86,1 +93,1 @@\n-            if (containsFuzzy(cpuFeatures, \"avx2\")) {\n+            if (containsFuzzy(cpuFeatures, \"avx2\", false)) {\n@@ -90,1 +97,1 @@\n-            if (containsFuzzy(cpuFeatures, \"avx\")) {\n+            if (containsFuzzy(cpuFeatures, \"avx\", false)) {\n@@ -96,1 +103,1 @@\n-            if (containsFuzzy(cpuFeatures, \"simd\")) {\n+            if (containsFuzzy(cpuFeatures, \"simd\", false)) {\n@@ -100,0 +107,6 @@\n+        } else if (Platform.isRISCV64()) {\n+            \/\/ Riscv64 intrinsics require the vector instructions\n+            if (containsFuzzy(cpuFeatures, \"v\", true)) {\n+                System.out.println(\"Setting up vector worker\");\n+                configs.add(List.of(\"-XX:+UseRVV\"));\n+            }\n@@ -101,1 +114,1 @@\n-            \/\/ We only have ChaCha20 intrinsics on x64 and aarch64\n+            \/\/ We only have ChaCha20 intrinsics on x64, aarch64 and riscv64\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/chacha\/TestChaCha20.java","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -312,1 +312,2 @@\n-                                   Float.toHexString(f) + \"\/\" + Integer.toHexString(i) + \" to binary16 and back: \" + Integer.toHexString(0xffff & f_as_bin16) + \" f_prime: \" + Float.toHexString(f_prime));\n+                                   Float.toHexString(f) + \"\/\" + Integer.toHexString(i) + \" to binary16 and back: \" +\n+                                   Integer.toHexString(0xffff & f_as_bin16) + \" f_prime: \" + Float.toHexString(f_prime));\n@@ -329,1 +330,1 @@\n-            short s2 =    testAltFloatToFloat16(f);\n+            short s2 = testAltFloatToFloat16(f);\n@@ -333,1 +334,4 @@\n-                System.out.println(\"Different conversion of float value \" + Float.toHexString(f));\n+                System.out.println(\"Different conversion of float value (\" + f + \"\/\" +\n+                                    Integer.toHexString(Float.floatToRawIntBits(f)) + \"): \" +\n+                                    Integer.toHexString(s1 & 0xffff) + \"(\" + s1 + \")\" + \" != \" +\n+                                    Integer.toHexString(s2 & 0xffff) + \"(\" + s2 + \")\");\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16Conversion.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-    public static void verify(short sVal, float fVal, short sRes) {\n+    public static int verify(short sVal, float fVal, short sRes, String prefix) {\n+        int errors = 0;\n@@ -59,0 +60,1 @@\n+                errors++;\n@@ -62,1 +64,2 @@\n-              throw new RuntimeException(\"Inconsistent result for Float.floatToFloat16(\" + fVal + \"\/\" + fVal_hex + \"): \" + sRes_hex + \" != \" + sVal_hex);\n+                System.out.println(prefix + \"Inconsistent result for Float.floatToFloat16(\" + fVal + \"\/\" + fVal_hex + \"): \" +\n+                                   sRes_hex + \"(\" + sRes + \")\" + \" != \" + sVal_hex + \"(\" + sVal + \")\");\n@@ -65,0 +68,1 @@\n+        return errors;\n@@ -67,1 +71,2 @@\n-    public static void run() {\n+    public static int run() {\n+        int errors = 0;\n@@ -72,1 +77,1 @@\n-            verify(sVal, fVal, sRes);\n+            errors += verify(sVal, fVal, sRes, \"testFloatToFloat16: \");\n@@ -75,0 +80,1 @@\n+                errors++;\n@@ -78,1 +84,2 @@\n-                throw new RuntimeException(\"Inconsistent result for Float.float16ToFloat(\" + sVal_hex + \"): \" + fRes + \"\/\" + fRes_hex + \" != \" + fVal + \"\/\" + fVal_hex);\n+                System.out.println(\"Non-NaN res: \" + \"Inconsistent result for Float.float16ToFloat(\" + sVal_hex + \"): \" +\n+                                   fRes + \"\/\" + fRes_hex + \" != \" + fVal + \"\/\" + fVal_hex);\n@@ -81,1 +88,1 @@\n-            verify(sVal, fVal, sRes);\n+            errors += verify(sVal, fVal, sRes, \"testRoundTrip: \");\n@@ -83,0 +90,1 @@\n+                errors++;\n@@ -85,2 +93,3 @@\n-                String sfVal_hex = Integer.toHexString(Float.floatToFloat16(fVal)& 0xffff);\n-                throw new RuntimeException(\"Inconsistent result for Float.float16ToFloat(\" + sVal_hex + \"): \" + sfRes_hex + \" != \" + sfVal_hex);\n+                String sfVal_hex = Integer.toHexString(Float.floatToFloat16(fVal) & 0xffff);\n+                System.out.println(\"Float16 not equal: \" + \"Inconsistent result for Float.float16ToFloat(\" + sVal_hex + \"): \" +\n+                                   sfRes_hex + \" != \" + sfVal_hex);\n@@ -89,0 +98,1 @@\n+        return errors;\n@@ -92,0 +102,1 @@\n+        int errors = 0;\n@@ -94,1 +105,4 @@\n-            run();\n+            errors += run();\n+        }\n+        if (errors > 0) {\n+            throw new RuntimeException(errors + \" errors\");\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestAllFloat16ToFloat.java","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -130,1 +130,2 @@\n-    public static void run() {\n+    public static int run() {\n+        int errors = 0;\n@@ -138,0 +139,1 @@\n+                errors++;\n@@ -141,1 +143,2 @@\n-                throw new RuntimeException(\"Inconsistent result for Float.float16ToFloat(\" + cVal_hex + \"): \" + fRes[i] + \"\/\" + fRes_hex + \" != \" + fVal + \"\/\" + fVal_hex);\n+                System.out.println(\"Inconsistent result for Float.float16ToFloat(\" + cVal_hex + \"): \" +\n+                                    fRes[i] + \"\/\" + fRes_hex + \" != \" + fVal + \"\/\" + fVal_hex);\n@@ -151,0 +154,1 @@\n+                errors++;\n@@ -154,1 +158,2 @@\n-                throw new RuntimeException(\"Inconsistent result for Float.floatToFloat16(\" + fCon[i] + \"\/\" + cVal_hex + \"): \" + sRes_hex + \" != \" + sVal_hex);\n+                System.out.println(\"Inconsistent result for Float.floatToFloat16(\" + fCon[i] + \"\/\" + cVal_hex + \"): \" +\n+                                    sRes_hex + \"(\" + sRes + \")\" + \" != \" + sVal_hex + \"(\" + sVal + \")\");\n@@ -157,0 +162,1 @@\n+        return errors;\n@@ -161,0 +167,1 @@\n+        int errors = 0;\n@@ -163,1 +170,4 @@\n-            run();\n+            errors += run();\n+        }\n+        if (errors > 0) {\n+            throw new RuntimeException(errors + \" errors\");\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestConstFloat16ToFloat.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm -Xbatch -XX:CompileThreshold=100 compiler.intrinsics.string.TestStringIntrinsicRangeChecks\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:CompileThreshold=100 compiler.intrinsics.string.TestStringIntrinsicRangeChecks\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestStringIntrinsicRangeChecks.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -552,1 +552,1 @@\n-        trapNodes(INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP,\"intrinsic_or_type_checked_inlining\");\n+        trapNodes(INTRINSIC_OR_TYPE_CHECKED_INLINING_TRAP, \"intrinsic_or_type_checked_inlining\");\n@@ -557,1 +557,1 @@\n-        trapNodes(INTRINSIC_TRAP,\"intrinsic\");\n+        trapNodes(INTRINSIC_TRAP, \"intrinsic\");\n@@ -1043,1 +1043,1 @@\n-        trapNodes(NULL_ASSERT_TRAP,\"null_assert\");\n+        trapNodes(NULL_ASSERT_TRAP, \"null_assert\");\n@@ -1048,1 +1048,1 @@\n-        trapNodes(NULL_CHECK_TRAP,\"null_check\");\n+        trapNodes(NULL_CHECK_TRAP, \"null_check\");\n@@ -1132,1 +1132,1 @@\n-        trapNodes(PREDICATE_TRAP,\"predicate\");\n+        trapNodes(PREDICATE_TRAP, \"predicate\");\n@@ -1137,1 +1137,1 @@\n-        trapNodes(RANGE_CHECK_TRAP,\"range_check\");\n+        trapNodes(RANGE_CHECK_TRAP, \"range_check\");\n@@ -1489,1 +1489,1 @@\n-        trapNodes(TRAP,\"reason\");\n+        trapNodes(TRAP, \"reason\");\n@@ -1524,1 +1524,1 @@\n-        trapNodes(UNHANDLED_TRAP,\"unhandled\");\n+        trapNodes(UNHANDLED_TRAP, \"unhandled\");\n@@ -1529,1 +1529,6 @@\n-        trapNodes(UNSTABLE_IF_TRAP,\"unstable_if\");\n+        trapNodes(UNSTABLE_IF_TRAP, \"unstable_if\");\n+    }\n+\n+    public static final String UNREACHED_TRAP = PREFIX + \"UNREACHED_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(UNREACHED_TRAP, \"unreached\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.compiler1.enabled | vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandPrintMemStat.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main compiler.vectorapi.reshape.TestVectorCastAVX1\n+ * @run main\/timeout=300 compiler.vectorapi.reshape.TestVectorCastAVX1\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main compiler.vectorapi.reshape.TestVectorCastAVX2\n+ * @run main\/timeout=300 compiler.vectorapi.reshape.TestVectorCastAVX2\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main compiler.vectorapi.reshape.TestVectorCastAVX512\n+ * @run main\/timeout=300 compiler.vectorapi.reshape.TestVectorCastAVX512\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main compiler.vectorapi.reshape.TestVectorCastAVX512BW\n+ * @run main\/timeout=300 compiler.vectorapi.reshape.TestVectorCastAVX512BW\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512BW.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main compiler.vectorapi.reshape.TestVectorCastAVX512DQ\n+ * @run main\/timeout=300 compiler.vectorapi.reshape.TestVectorCastAVX512DQ\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512DQ.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main compiler.vectorapi.reshape.TestVectorCastNeon\n+ * @run main\/timeout=300 compiler.vectorapi.reshape.TestVectorCastNeon\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastNeon.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main compiler.vectorapi.reshape.TestVectorCastSVE\n+ * @run main\/timeout=300 compiler.vectorapi.reshape.TestVectorCastSVE\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastSVE.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @summary Ensure the output for a minor GC with G1 that has evacuation failure contains the correct strings.\n+ * @summary Ensure the output for a minor GC with G1 that has allocation failure contains the correct strings.\n@@ -58,1 +58,1 @@\n-        output.shouldContain(\"(Evacuation Failure)\");\n+        output.shouldContain(\"(Evacuation Failure:\");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEvacuationFailure.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-        new LogMessageWithLevel(\"Restore Retained Regions\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Restore Evacuation Failed Regions\", Level.DEBUG),\n@@ -270,1 +270,2 @@\n-        new LogMessageWithLevel(\"New Retained Regions\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Pinned Regions\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Allocation Failed Regions\", Level.DEBUG),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2018, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+ \/*\n+ * @test id=g1\n+ * @summary Make sure G1 can handle humongous allocation fragmentation with region pinning in the mix,\n+ *          i.e. moving humongous objects around other pinned humongous objects even in a last resort\n+ *          full gc.\n+ *          Adapted from gc\/TestAllocHumongousFragment.java\n+ * @key randomness\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xlog:gc+region=trace -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g\n+ *      -XX:VerifyGCType=full -XX:+VerifyDuringGC -XX:+VerifyAfterGC -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      gc.g1.pinnedobjs.TestPinnedHumongousFragmentation\n+ *\/\n+\n+package gc.g1.pinnedobjs;\n+\n+import java.util.*;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestPinnedHumongousFragmentation {\n+\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    static final long TARGET_MB = 30_000; \/\/ 30 Gb allocations\n+    static final long LIVE_MB   = 700;    \/\/ 700 Mb alive\n+    static final int  PINNED_PERCENT = 5; \/\/ 5% of objects pinned\n+\n+    static volatile Object sink;\n+\n+    class PinInformation {\n+        int[] object;\n+        long address;\n+\n+        PinInformation(int[] object) {\n+            this.object = object;\n+            wb.pinObject(object);\n+            this.address = wb.getObjectAddress(object);\n+        }\n+\n+        void release() {\n+            long newAddress = wb.getObjectAddress(object);\n+            if (address != newAddress) {\n+                Asserts.fail(\"Object at \" + address + \" moved to \" + newAddress);\n+            }\n+            wb.unpinObject(object);\n+            object = null;\n+        }\n+    }\n+\n+    static List<int[]> objects;\n+    static List<PinInformation> pinnedObjects;\n+\n+    public static void main(String[] args) throws Exception {\n+        (new TestPinnedHumongousFragmentation()).run();\n+    }\n+\n+    void run() throws Exception {\n+        final int min = 128 * 1024;\n+        final int max = 16 * 1024 * 1024;\n+        final long count = TARGET_MB * 1024 * 1024 \/ (16 + 4 * (min + (max - min) \/ 2));\n+\n+        objects = new ArrayList<int[]>();\n+        pinnedObjects = new ArrayList<PinInformation>();\n+        long current = 0;\n+\n+        Random rng = Utils.getRandomInstance();\n+        for (long c = 0; c < count; c++) {\n+            while (current > LIVE_MB * 1024 * 1024) {\n+                int idx = rng.nextInt(objects.size());\n+                int[] remove = objects.remove(idx);\n+                current -= remove.length * 4 + 16;\n+            }\n+\n+            \/\/ Pin random objects before the allocation that is (likely) going to\n+            \/\/ cause full gcs. Remember them for unpinning.\n+            for (int i = 0; i < objects.size() * PINNED_PERCENT \/ 100; i++) {\n+                int[] target = objects.get(rng.nextInt(objects.size()));\n+                pinnedObjects.add(new PinInformation(target));\n+            }\n+\n+            int[] newObj = new int[min + rng.nextInt(max - min)];\n+            current += newObj.length * 4 + 16;\n+            objects.add(newObj);\n+            sink = new Object();\n+\n+            \/\/ Unpin and clear remembered objects afterwards.\n+            for (int i = 0; i < pinnedObjects.size(); i++) {\n+                pinnedObjects.get(i).release();\n+            }\n+            pinnedObjects.clear();\n+\n+            System.out.println(\"Allocated: \" + (current \/ 1024 \/ 1024) + \" Mb\");\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedHumongousFragmentation.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test that pinned objects we lost all Java references to keep\n+ *          the region and contents alive.\n+ *          This test simulates this behavior using Whitebox\/Unsafe methods\n+ *          and not real native code for simplicity.\n+ * @requires vm.gc.G1\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc:+open\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. -XX:+ZapUnusedHeapArea -Xlog:gc,gc+ergo+cset=trace gc.g1.pinnedobjs.TestPinnedObjectContents\n+ *\/\n+\n+package gc.g1.pinnedobjs;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestPinnedObjectContents {\n+\n+    private static final jdk.internal.misc.Unsafe unsafe = Unsafe.getUnsafe();\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    public static long pinAndGetAddress(Object o) {\n+        wb.pinObject(o);\n+        return wb.getObjectAddress(o);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Remove garbage from VM initialization.\n+        wb.fullGC();\n+\n+        \/\/ Allocate to-be pinned object and fill with \"random\" data.\n+        final int ArraySize = 100;\n+        int[] o = new int[ArraySize];\n+        for (int i = 0; i < o.length; i++) {\n+            o[i] = i;\n+        }\n+\n+        Asserts.assertTrue(!wb.isObjectInOldGen(o), \"should not be in old gen already\");\n+\n+        \/\/ Remember memory offsets.\n+        long baseOffset = unsafe.arrayBaseOffset(o.getClass());\n+        long indexScale = unsafe.arrayIndexScale(o.getClass());\n+        long address = pinAndGetAddress(o);\n+\n+        o = null; \/\/ And forget the (Java) reference to the int array.\n+\n+        \/\/ Do garbage collections to zap the data surrounding the \"dead\" object.\n+        wb.youngGC();\n+        wb.youngGC();\n+\n+        for (int i = 0; i < ArraySize; i++) {\n+            int actual = unsafe.getInt(null, address + baseOffset + i * indexScale);\n+            if (actual != i) {\n+                Asserts.fail(\"Pinned array at offset \" + i + \" should contain the value \" + i + \" but is \" + actual);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedObjectContents.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test whether different object type can be pinned or not.\n+ * @requires vm.gc.G1\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver gc.g1.pinnedobjs.TestPinnedObjectTypes\n+ *\/\n+\n+package gc.g1.pinnedobjs;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestPinnedObjectTypes {\n+\n+    public static void main(String[] args) throws Exception {\n+        testPinning(\"Object\", false);\n+        testPinning(\"TypeArray\", true);\n+        testPinning(\"ObjArray\", false);\n+    }\n+\n+    private static void testPinning(String type, boolean shouldSucceed) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n+                                                                             \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                             \"-XX:+WhiteBoxAPI\",\n+                                                                             \"-Xbootclasspath\/a:.\",\n+                                                                             \"-Xmx32M\",\n+                                                                             \"-Xmn16M\",\n+                                                                             \"-Xlog:gc\",\n+                                                                             TestObjectPin.class.getName(),\n+                                                                             type);\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        System.out.println(output.getStdout());\n+        if (shouldSucceed) {\n+          output.shouldHaveExitValue(0);\n+        } else {\n+          output.shouldNotHaveExitValue(0);\n+        }\n+    }\n+\n+}\n+\n+class TestObjectPin {\n+\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        Object o = switch (args[0]) {\n+            case \"Object\" -> new Object();\n+            case \"TypeArray\" -> new int[100];\n+            case \"ObjArray\" -> new Object[100];\n+            default -> null;\n+        };\n+        wb.pinObject(o);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedObjectTypes.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test pinned objects lifecycle from young gen to eventual reclamation.\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver gc.g1.pinnedobjs.TestPinnedObjectsEvacuation\n+ *\/\n+\n+package gc.g1.pinnedobjs;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestPinnedObjectsEvacuation {\n+\n+    public static void main(String[] args) throws Exception {\n+        testPinnedEvacuation(0, 0, 0, 1);\n+        testPinnedEvacuation(1, 1, 0, 1);\n+        testPinnedEvacuation(2, 1, 1, 0);\n+        testPinnedEvacuation(3, 1, 1, 0);\n+    }\n+\n+    private static int numMatches(String stringToMatch, String pattern) {\n+        Pattern r = Pattern.compile(pattern);\n+        Matcher m = r.matcher(stringToMatch);\n+        return (int)m.results().count();\n+    }\n+\n+    private static void assertMatches(int expected, int actual, String what) {\n+        if (expected != actual) {\n+          Asserts.fail(\"Expected \" + expected + \" \" + what + \" events but got \" + actual);\n+        }\n+    }\n+\n+    private static void testPinnedEvacuation(int younGCsBeforeUnpin, int expectedSkipEvents, int expectedDropEvents, int expectedReclaimEvents) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n+                                                                             \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                             \"-XX:+WhiteBoxAPI\",\n+                                                                             \"-Xbootclasspath\/a:.\",\n+                                                                             \"-Xmx32M\",\n+                                                                             \"-Xmn16M\",\n+                                                                             \"-XX:G1NumCollectionsKeepPinned=2\",\n+                                                                             \"-XX:+VerifyAfterGC\",\n+                                                                             \"-Xlog:gc,gc+ergo+cset=trace\",\n+                                                                             TestObjectPin.class.getName(),\n+                                                                             String.valueOf(younGCsBeforeUnpin));\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        System.out.println(output.getStdout());\n+        output.shouldHaveExitValue(0);\n+\n+        assertMatches(expectedSkipEvents, numMatches(output.getStdout(), \".*Retained candidate \\\\d+ can not be reclaimed currently. Skipping.*\"), \"skip\");\n+        assertMatches(expectedDropEvents, numMatches(output.getStdout(), \".*Retained candidate \\\\d+ can not be reclaimed currently. Dropping.*\"), \"drop\");\n+        assertMatches(expectedReclaimEvents, numMatches(output.getStdout(), \".*Finish adding retained candidates to collection set. Initial: 1,.*\"), \"reclaim\");\n+    }\n+\n+}\n+\n+class TestObjectPin {\n+\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    public static long pinAndGetAddress(Object o) {\n+        wb.pinObject(o);\n+        return wb.getObjectAddress(o);\n+    }\n+\n+    public static void unpinAndCompareAddress(Object o, long expectedAddress) {\n+        Asserts.assertEQ(expectedAddress, wb.getObjectAddress(o), \"Object has moved during pinning.\");\n+        wb.unpinObject(o);\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        int youngGCBeforeUnpin = Integer.parseInt(args[0]);\n+\n+        \/\/ Remove garbage from VM initialization.\n+        wb.fullGC();\n+\n+        Object o = new int[100];\n+        Asserts.assertTrue(!wb.isObjectInOldGen(o), \"should not be pinned in old gen\");\n+\n+        long address = pinAndGetAddress(o);\n+\n+        \/\/ First young GC: should move the object into old gen.\n+        wb.youngGC();\n+        Asserts.assertTrue(wb.isObjectInOldGen(o), \"Pinned object not in old gen after young GC\");\n+\n+        \/\/ The object is (still) pinned. Do some configurable young gcs that fail to add it to the\n+        \/\/ collection set candidates.\n+        for (int i = 0; i < youngGCBeforeUnpin; i++) {\n+          wb.youngGC();\n+        }\n+        unpinAndCompareAddress(o, address);\n+\n+        \/\/ Unpinned the object. This next gc should take the region if not dropped.\n+        wb.youngGC();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedObjectsEvacuation.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,337 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test pinned objects lifecycle from old gen to eventual reclamation.\n+ * @requires vm.gc.G1\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver gc.g1.pinnedobjs.TestPinnedOldObjectsEvacuation\n+ *\/\n+\n+package gc.g1.pinnedobjs;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+class TestResultTracker {\n+    private int trackedRegion = -1;\n+    private int curGC = -1;\n+    private String stdout;\n+    private int expectedMarkingSkipEvents;      \/\/ How many times has the region from the \"marking\" collection set candidate set been \"skipped\".\n+    private int expectedRetainedSkipEvents;     \/\/ How many times has the region from the \"retained\" collection set candidate set been \"skipped\".\n+    private int expectedDropEvents;             \/\/ How many times has the region from the \"retained\" collection set candidate set been \"dropped\".\n+    private int expectedMarkingReclaimEvents;   \/\/ How many times has the region from the \"marking\" collection set candidate set been put into the collection set.\n+    private int expectedRetainedReclaimEvents;  \/\/ How many times has the region from the \"marking\" collection set candidate set been put into the collection set.\n+\n+    TestResultTracker(String stdout,\n+                      int expectedMarkingSkipEvents,\n+                      int expectedRetainedSkipEvents,\n+                      int expectedDropEvents,\n+                      int expectedMarkingReclaimEvents,\n+                      int expectedRetainedReclaimEvents) {\n+        this.stdout = stdout;\n+        this.expectedMarkingSkipEvents = expectedMarkingSkipEvents;\n+        this.expectedRetainedSkipEvents = expectedRetainedSkipEvents;\n+        this.expectedDropEvents = expectedDropEvents;\n+        this.expectedMarkingReclaimEvents = expectedMarkingReclaimEvents;\n+        this.expectedRetainedReclaimEvents = expectedRetainedReclaimEvents;\n+    }\n+\n+    private void updateOrCompareCurRegion(String phase, int curRegion) {\n+        if (trackedRegion == -1) {\n+            trackedRegion = curRegion;\n+        } else {\n+            if (trackedRegion != curRegion) {\n+                Asserts.fail(\"Expected region \" + trackedRegion + \" to be used but is \" + curRegion);\n+            }\n+        }\n+    }\n+\n+    private void expectMoreMatches(Matcher matcher, String event) {\n+        if (!matcher.find()) {\n+            Asserts.fail(\"Expected one more \" + event);\n+        }\n+    }\n+\n+    private int expectIncreasingGC(Matcher matcher) {\n+        int nextGC = Integer.parseInt(matcher.group(1));\n+        if (nextGC <= curGC) {\n+            Asserts.fail(\"Non-increasing GC number from \" + curGC + \" to \" + nextGC);\n+        }\n+        return nextGC;\n+    }\n+\n+    \/\/ Verify log messages based on expected events.\n+    \/\/\n+    \/\/ There are two log messages printed with -Xlog:ergo+cset=trace that report about success or failure to\n+    \/\/ evacuate particular regions (in this case) due to pinning:\n+    \/\/\n+    \/\/   1) GC(<x>) Marking\/Retained candidate <region-idx> can not be reclaimed currently. Skipping\/Dropping.\n+    \/\/\n+    \/\/ and\n+    \/\/\n+    \/\/   2) GC(<x>) Finish adding retained\/marking candidates to collection set. Initial: <y> ... pinned: <z>\n+    \/\/\n+    \/\/ 1) reports about whether the given region has been added to the collection set or not. The last word indicates whether the\n+    \/\/ region has been removed from the collection set candidates completely (\"Dropping\"), or just skipped for this collection\n+    \/\/ (\"Skipping\")\n+    \/\/\n+    \/\/ This message is printed for every such region, however since the test only pins a single object\/region and can only be\n+    \/\/ in one of the collection set candidate sets, there will be only one message per GC.\n+    \/\/\n+    \/\/ 2) reports statistics about how many regions were added to the initial collection set, optional collection set (not shown\n+    \/\/ here) and the amount of pinned regions for every kind of collection set candidate sets (\"marking\" or \"retained\").\n+    \/\/\n+    \/\/ There are two such messages per GC.\n+    \/\/\n+    \/\/ The code below tracks that single pinned region through the various stages as defined by the policy.\n+    \/\/\n+    public void verify() throws Exception {\n+        final String skipDropEvents = \"GC\\\\((\\\\d+)\\\\).*(Marking|Retained) candidate (\\\\d+) can not be reclaimed currently\\\\. (Skipping|Dropping)\";\n+        final String reclaimEvents = \"GC\\\\((\\\\d+)\\\\) Finish adding (retained|marking) candidates to collection set\\\\. Initial: (\\\\d+).*pinned: (\\\\d+)\";\n+\n+        Matcher skipDropMatcher = Pattern.compile(skipDropEvents, Pattern.MULTILINE).matcher(stdout);\n+        Matcher reclaimMatcher = Pattern.compile(reclaimEvents, Pattern.MULTILINE).matcher(stdout);\n+\n+        for (int i = 0; i < expectedMarkingSkipEvents; i++) {\n+            expectMoreMatches(skipDropMatcher, \"expectedMarkingSkipEvents\");\n+            curGC = expectIncreasingGC(skipDropMatcher);\n+\n+            Asserts.assertEQ(\"Marking\", skipDropMatcher.group(2), \"Expected \\\"Marking\\\" tag for GC \" + curGC + \" but got \\\"\" + skipDropMatcher.group(2) + \"\\\"\");\n+            updateOrCompareCurRegion(\"MarkingSkip\", Integer.parseInt(skipDropMatcher.group(3)));\n+            Asserts.assertEQ(\"Skipping\", skipDropMatcher.group(4), \"Expected \\\"Skipping\\\" tag for GC \" + curGC + \" but got \\\"\" + skipDropMatcher.group(4) + \"\\\"\");\n+\n+            while (true) {\n+                if (!reclaimMatcher.find()) {\n+                    Asserts.fail(\"Could not find \\\"Finish adding * candidates\\\" line for GC \" + curGC);\n+                }\n+                if (reclaimMatcher.group(2).equals(\"retained\")) {\n+                    continue;\n+                }\n+                if (Integer.parseInt(reclaimMatcher.group(1)) == curGC) {\n+                    int actual = Integer.parseInt(reclaimMatcher.group(4));\n+                    Asserts.assertEQ(actual, 1, \"Expected number of pinned to be 1 after marking skip but is \" + actual);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < expectedRetainedSkipEvents; i++) {\n+            expectMoreMatches(skipDropMatcher, \"expectedRetainedSkipEvents\");\n+            curGC = expectIncreasingGC(skipDropMatcher);\n+\n+            Asserts.assertEQ(\"Retained\", skipDropMatcher.group(2), \"Expected \\\"Retained\\\" tag for GC \" + curGC + \" but got \\\"\" + skipDropMatcher.group(2) + \"\\\"\");\n+            updateOrCompareCurRegion(\"RetainedSkip\", Integer.parseInt(skipDropMatcher.group(3)));\n+            Asserts.assertEQ(\"Skipping\", skipDropMatcher.group(4), \"Expected \\\"Skipping\\\" tag for GC \" + curGC + \" but got \\\"\" + skipDropMatcher.group(4) + \"\\\"\");\n+\n+            while (true) {\n+                if (!reclaimMatcher.find()) {\n+                    Asserts.fail(\"Could not find \\\"Finish adding * candidates\\\" line for GC \" + curGC);\n+                }\n+                if (reclaimMatcher.group(2).equals(\"marking\")) {\n+                    continue;\n+                }\n+                if (Integer.parseInt(reclaimMatcher.group(1)) == curGC) {\n+                    int actual = Integer.parseInt(reclaimMatcher.group(4));\n+                    Asserts.assertEQ(actual, 1, \"Expected number of pinned to be 1 after retained skip but is \" + actual);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < expectedDropEvents; i++) {\n+            expectMoreMatches(skipDropMatcher, \"expectedDropEvents\");\n+            curGC = expectIncreasingGC(skipDropMatcher);\n+\n+            Asserts.assertEQ(\"Retained\", skipDropMatcher.group(2), \"Expected \\\"Retained\\\" tag for GC \" + curGC + \" but got \\\"\" + skipDropMatcher.group(2) + \"\\\"\");\n+            updateOrCompareCurRegion(\"RetainedDrop\", Integer.parseInt(skipDropMatcher.group(3)));\n+            Asserts.assertEQ(\"Dropping\", skipDropMatcher.group(4), \"Expected \\\"Dropping\\\" tag for GC \" + curGC + \" but got \\\"\" + skipDropMatcher.group(4) + \"\\\"\");\n+\n+            while (true) {\n+                if (!reclaimMatcher.find()) {\n+                    Asserts.fail(\"Could not find \\\"Finish adding * candidates\\\" line for GC \" + curGC);\n+                }\n+                if (reclaimMatcher.group(2).equals(\"marking\")) {\n+                    continue;\n+                }\n+                if (Integer.parseInt(reclaimMatcher.group(1)) == curGC) {\n+                    int actual = Integer.parseInt(reclaimMatcher.group(4));\n+                    if (actual != 1) {\n+                        Asserts.fail(\"Expected number of pinned to be 1 after dropping but is \" + actual);\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < expectedMarkingReclaimEvents; i++) {\n+            expectMoreMatches(reclaimMatcher, \"\\\"Finish adding * candidates\\\" line for GC \" + curGC);\n+\n+            int nextGC = Integer.parseInt(reclaimMatcher.group(1));\n+            curGC = nextGC;\n+            if (reclaimMatcher.group(2).equals(\"retained\")) {\n+                continue;\n+            }\n+\n+            if (Integer.parseInt(reclaimMatcher.group(1)) == nextGC) {\n+                int actual = Integer.parseInt(reclaimMatcher.group(4));\n+                if (actual != 0) {\n+                    Asserts.fail(\"Expected number of pinned to be 0 after marking reclaim but is \" + actual);\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < expectedRetainedReclaimEvents; i++) {\n+            expectMoreMatches(reclaimMatcher, \"\\\"Finish adding * candidates\\\" line for GC \" + curGC);\n+\n+            int nextGC = Integer.parseInt(reclaimMatcher.group(1));\n+            curGC = nextGC;\n+            if (reclaimMatcher.group(2).equals(\"marking\")) {\n+                continue;\n+            }\n+\n+            if (Integer.parseInt(reclaimMatcher.group(1)) == nextGC) {\n+                int actual = Integer.parseInt(reclaimMatcher.group(4));\n+                if (actual != 0) {\n+                    Asserts.fail(\"Expected number of pinned to be 0 after retained reclaim but is \" + actual);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+public class TestPinnedOldObjectsEvacuation {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ younGCsBeforeUnpin, expectedMarkingSkipEvents, expectedRetainedSkipEvents, expectedDropEvents, expectedMarkingReclaimEvents, expectedRetainedReclaimEvents\n+        testPinnedEvacuation(1, 1, 0, 0, 0, 1);\n+        testPinnedEvacuation(2, 1, 1, 0, 0, 1);\n+        testPinnedEvacuation(3, 1, 2, 0, 0, 1);\n+        testPinnedEvacuation(4, 1, 2, 1, 0, 0);\n+    }\n+\n+    private static int numMatches(String stringToMatch, String pattern) {\n+        Pattern r = Pattern.compile(pattern);\n+        Matcher m = r.matcher(stringToMatch);\n+        return (int)m.results().count();\n+    }\n+\n+    private static void assertMatches(int expected, int actual, String what) {\n+        if (expected != actual) {\n+          Asserts.fail(\"Expected \" + expected + \" \" + what + \" events but got \" + actual);\n+        }\n+    }\n+\n+    private static void testPinnedEvacuation(int youngGCsBeforeUnpin,\n+                                             int expectedMarkingSkipEvents,\n+                                             int expectedRetainedSkipEvents,\n+                                             int expectedDropEvents,\n+                                             int expectedMarkingReclaimEvents,\n+                                             int expectedRetainedReclaimEvents) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n+                                                                             \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                             \"-XX:+WhiteBoxAPI\",\n+                                                                             \"-Xbootclasspath\/a:.\",\n+                                                                             \"-Xmx32M\",\n+                                                                             \"-Xmn16M\",\n+                                                                             \"-XX:MarkSweepDeadRatio=0\",\n+                                                                             \"-XX:G1NumCollectionsKeepPinned=3\",\n+                                                                             \"-XX:+UnlockExperimentalVMOptions\",\n+                                                                             \/\/ Take all old regions to make sure that the pinned one is included in the collection set.\n+                                                                             \"-XX:G1MixedGCLiveThresholdPercent=100\",\n+                                                                             \"-XX:G1HeapWastePercent=0\",\n+                                                                             \"-XX:+VerifyAfterGC\",\n+                                                                             \"-Xlog:gc,gc+ergo+cset=trace\",\n+                                                                             TestObjectPin.class.getName(),\n+                                                                             String.valueOf(youngGCsBeforeUnpin));\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        System.out.println(output.getStdout());\n+        output.shouldHaveExitValue(0);\n+\n+        TestResultTracker t = new TestResultTracker(output.getStdout(),\n+                                                    expectedMarkingSkipEvents,\n+                                                    expectedRetainedSkipEvents,\n+                                                    expectedDropEvents,\n+                                                    expectedMarkingReclaimEvents,\n+                                                    expectedRetainedReclaimEvents);\n+        t.verify();\n+    }\n+\n+}\n+\n+class TestObjectPin {\n+\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    public static long pinAndGetAddress(Object o) {\n+        wb.pinObject(o);\n+        return wb.getObjectAddress(o);\n+    }\n+\n+    public static void unpinAndCompareAddress(Object o, long expectedAddress) {\n+        Asserts.assertEQ(expectedAddress, wb.getObjectAddress(o), \"Object has moved during pinning.\");\n+        wb.unpinObject(o);\n+    }\n+\n+    public static void main(String[] args) {\n+\n+        int youngGCBeforeUnpin = Integer.parseInt(args[0]);\n+        \/\/ Remove garbage from VM initialization\n+        wb.fullGC();\n+\n+        Object o = new int[100];\n+        Asserts.assertTrue(!wb.isObjectInOldGen(o), \"should not be pinned in old gen\");\n+\n+        long address = pinAndGetAddress(o);\n+\n+        \/\/ Move pinned object into old gen. That region containing it should be almost completely empty,\n+        \/\/ so it will be picked up as collection set candidate.\n+        wb.fullGC();\n+        Asserts.assertTrue(wb.isObjectInOldGen(o), \"Pinned object not in old gen after young GC\");\n+\n+        \/\/ Do a concurrent cycle to move the region into the marking candidates.\n+        wb.g1RunConcurrentGC();\n+        \/\/ Perform the \"Prepare Mixed\" GC.\n+        wb.youngGC();\n+        \/\/ The object is (still) pinned. Do some configurable young gcs that fail to add it to the\n+        \/\/ collection set candidates.\n+        for (int i = 0; i < youngGCBeforeUnpin; i++) {\n+          wb.youngGC();\n+        }\n+        unpinAndCompareAddress(o, address);\n+\n+        \/\/ Unpinned the object. This next gc should take the region if not dropped.\n+        wb.youngGC();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedOldObjectsEvacuation.java","additions":337,"deletions":0,"binary":false,"changes":337,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Checks PLAB statistics on evacuation failure\n+ * @summary Checks PLAB statistics on evacuation\/allocation failure\n@@ -199,1 +199,1 @@\n-                .filter(line -> line.contains(\"(Evacuation Failure)\"))\n+                .filter(line -> line.contains(\"(Evacuation Failure\"))\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/plab\/TestPLABEvacuationFailure.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,2 +145,0 @@\n-                passWith(\"-XX:ShenandoahGCMode=\" + mode, \"-XX:ShenandoahGCHeuristics=\" + h, \"-XX:+ClassUnloading\", \"-XX:-ClassUnloadingWithConcurrentMark\", \"-XX:ShenandoahUnloadClassesFrequency=0\");\n-                passWith(\"-XX:ShenandoahGCMode=\" + mode, \"-XX:ShenandoahGCHeuristics=\" + h, \"-XX:+ClassUnloading\", \"-XX:+ClassUnloadingWithConcurrentMark\", \"-XX:ShenandoahUnloadClassesFrequency=0\");\n@@ -151,2 +149,0 @@\n-                failWith(\"-XX:ShenandoahGCMode=\" + mode, \"-XX:ShenandoahGCHeuristics=\" + h, \"-XX:-ClassUnloading\", \"-XX:+ClassUnloadingWithConcurrentMark\", \"-XX:ShenandoahUnloadClassesFrequency=1\");\n-                failWith(\"-XX:ShenandoahGCMode=\" + mode, \"-XX:ShenandoahGCHeuristics=\" + h, \"-XX:-ClassUnloading\", \"-XX:-ClassUnloadingWithConcurrentMark\", \"-XX:ShenandoahUnloadClassesFrequency=1\");\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/oom\/TestClassLoaderLeak.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,191 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2017 SAP SE and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.stress.TestJNIBlockFullGC;\n-\n-\/*\n- * @test TestJNIBlockFullGC\n- * @summary Check that in G1 a Full GC to reclaim space can not be blocked out by the GC locker.\n- * @key randomness\n- * @requires vm.gc.G1\n- * @library \/test\/lib\n- * @run main\/othervm\/native -Xmx64m -XX:+UseG1GC -Xlog:gc=info,gc+alloc=trace -XX:MaxGCPauseMillis=10 gc.stress.TestJNIBlockFullGC.TestJNIBlockFullGC 10 10000 10000 10000 30000 10000 0.7\n- *\/\n-\n-import java.lang.ref.SoftReference;\n-import java.util.Random;\n-import jdk.test.lib.Utils;\n-\n-public class TestJNIBlockFullGC {\n-    private static final Random rng = Utils.getRandomInstance();\n-\n-    static {\n-        System.loadLibrary(\"TestJNIBlockFullGC\");\n-    }\n-\n-    public static volatile Object tmp;\n-\n-    public static volatile boolean hadError = false;\n-\n-    private static native int TestCriticalArray0(int[] x);\n-\n-    public static class Node {\n-        public SoftReference<Node> next;\n-        long payload1;\n-        long payload2;\n-        long payload3;\n-        long payload4;\n-\n-        public Node(int load) {\n-            payload1 = payload2 = payload3 = payload4 = load;\n-        }\n-    }\n-\n-    public static void warmUp(long warmupEndTimeNanos, int size, long seed) {\n-        Random r = new Random(seed);\n-        \/\/ First let the GC assume most of our objects will die.\n-        Node[] roots = new Node[size];\n-\n-        while (System.nanoTime() - warmupEndTimeNanos < 0) {\n-            int index = (int) (r.nextDouble() * roots.length);\n-            roots[index] = new Node(1);\n-        }\n-\n-        \/\/ Make sure the young generation is empty.\n-        for (int i = 0; i < roots.length; ++i) {\n-            roots[i] = null;\n-        }\n-    }\n-\n-    public static void runTest(long endTimeNanos, int size, double alive, long seed) {\n-        Random r = new Random(seed);\n-        final int length = 10000;\n-        int[] array1 = new int[length];\n-        for (int x = 1; x < length; x++) {\n-            array1[x] = x;\n-        }\n-\n-        Node[] roots = new Node[size];\n-        try {\n-            int index = 0;\n-            roots[0] = new Node(0);\n-\n-            while (!hadError && (System.nanoTime() - endTimeNanos < 0)) {\n-                int test_val1 = TestCriticalArray0(array1);\n-\n-                if (r.nextDouble() > alive) {\n-                    tmp = new Node(test_val1);\n-                } else {\n-                    index = (int) (r.nextDouble() * roots.length);\n-\n-                    if (roots[index] != null) {\n-                        Node node = new Node(test_val1);\n-                        node.next = new SoftReference<Node>(roots[index]);\n-                        roots[index] = node;\n-                    } else {\n-                        roots[index] = new Node(test_val1);\n-                    }\n-                }\n-            }\n-        } catch (OutOfMemoryError e) {\n-            hadError = true;\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    private static void joinThreads(Thread[] threads) throws Exception {\n-        for (int i = 0; i < threads.length; i++) {\n-            try {\n-                if (threads[i] != null) {\n-                  threads[i].join();\n-                }\n-            } catch (InterruptedException e) {\n-                e.printStackTrace();\n-                throw e;\n-            }\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length < 7){\n-            System.out.println(\"Usage: java TestJNIBlockFullGC <warmupThreads> <warmup-time-in-millis> <warmup iterations> <threads> <time-in-millis> <iterations> <aliveFrac>\");\n-            System.exit(0);\n-        }\n-\n-        int warmupThreads = Integer.parseInt(args[0]);\n-        System.out.println(\"# Warmup Threads = \" + warmupThreads);\n-\n-        long warmupDurationNanos = 1_000_000L * Integer.parseInt(args[1]);\n-        System.out.println(\"WarmUp Duration Millis = \" + args[1]);\n-        int warmupIterations = Integer.parseInt(args[2]);\n-        System.out.println(\"# Warmup Iterations = \"+ warmupIterations);\n-\n-        int mainThreads = Integer.parseInt(args[3]);\n-        System.out.println(\"# Main Threads = \" + mainThreads);\n-        long mainDurationNanos = 1_000_000L * Integer.parseInt(args[4]);\n-        System.out.println(\"Main Duration Millis = \" + args[4]);\n-        int mainIterations = Integer.parseInt(args[5]);\n-        System.out.println(\"# Main Iterations = \" + mainIterations);\n-\n-        double liveFrac = Double.parseDouble(args[6]);\n-        System.out.println(\"Live Fraction = \" + liveFrac);\n-\n-        Thread threads[] = new Thread[Math.max(warmupThreads, mainThreads)];\n-\n-        System.out.println(\"Start warm-up threads!\");\n-        long warmupStartTimeNanos = System.nanoTime();\n-        for (int i = 0; i < warmupThreads; i++) {\n-            long seed = rng.nextLong();\n-            threads[i] = new Thread() {\n-                public void run() {\n-                    warmUp(warmupStartTimeNanos + warmupDurationNanos, warmupIterations, seed);\n-                };\n-            };\n-            threads[i].start();\n-        }\n-\n-        joinThreads(threads);\n-\n-        System.gc();\n-        System.out.println(\"Keep alive a lot\");\n-\n-        long startTimeNanos = System.nanoTime();\n-        for (int i = 0; i < mainThreads; i++) {\n-            long seed = rng.nextLong();\n-            threads[i] = new Thread() {\n-                public void run() {\n-                    runTest(startTimeNanos + mainDurationNanos, mainIterations, liveFrac, seed);\n-                };\n-            };\n-            threads[i].start();\n-        }\n-        System.out.println(\"All threads started\");\n-\n-        joinThreads(threads);\n-\n-        if (hadError) {\n-            throw new RuntimeException(\"Experienced an OoME during execution.\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestJNIBlockFullGC\/TestJNIBlockFullGC.java","additions":0,"deletions":191,"binary":false,"changes":191,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2017 SAP SE and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-\n-JNIEXPORT jint JNICALL\n-Java_gc_stress_TestJNIBlockFullGC_TestJNIBlockFullGC_TestCriticalArray0(JNIEnv *env, jclass jCls, jintArray jIn) {\n-  jint *bufIn = NULL;\n-  jint jInLen = (*env)->GetArrayLength(env, jIn);\n-  jint result = 0;\n-  jint i;\n-\n-  if (jInLen != 0) {\n-    bufIn = (jint*)(*env)->GetPrimitiveArrayCritical(env, jIn, 0);\n-  }\n-\n-  for (i = 0; i < jInLen; ++i) {\n-    result += bufIn[i]; \/\/ result = sum of all array elements\n-  }\n-\n-  if (bufIn != NULL) {\n-    (*env)->ReleasePrimitiveArrayCritical(env, jIn, bufIn, 0);\n-  }\n-\n-  return result;\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestJNIBlockFullGC\/libTestJNIBlockFullGC.c","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -34,0 +34,2 @@\n+ * @requires vm.gc != \"G1\"\n+ * @requires vm.gc != null\n@@ -154,1 +156,1 @@\n-        \"-Xmx1G\", \"-Xms1G\", \"-Xmn256M\", \"-Xlog:gc\" };\n+        \"-Xmx1G\", \"-Xms1G\", \"-Xmn256M\", \"-Xlog:gc,gc+ergo*=debug,gc+ergo+cset=trace:x.log\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+VerifyAfterGC\"};\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gclocker\/TestExcessGCLockerCollections.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test the various CPU-specific reservation schemes\n+ * @requires vm.bits == 64 & !vm.graal.enabled & vm.debug == true\n+ * @requires vm.flagless\n+ * @requires (os.family != \"windows\") & (os.family != \"aix\")\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver CompressedCPUSpecificClassSpaceReservation\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jtreg.SkippedException;\n+\n+import java.io.IOException;\n+\n+public class CompressedCPUSpecificClassSpaceReservation {\n+    \/\/ Note: windows: On windows, we currently have the issue that os::reserve_memory_aligned relies on\n+    \/\/ os::attempt_reserve_memory_at because VirtualAlloc cannot be unmapped in parts; this precludes use of\n+    \/\/ +SimulateFullAddressSpace (VM won't be able to reserve heap). Therefore we exclude the test for windows\n+    \/\/ for now.\n+\n+    private static void do_test(boolean CDS) throws IOException {\n+        \/\/ We start the VM with -XX:+SimulateFullAdressSpace, which means the JVM will go through all motions\n+        \/\/ of reserving the cds+class space, but never succeed. That means we see every single allocation attempt.\n+        \/\/ We start with -Xlog options enabled. The expected output goes like this:\n+        \/\/ [0.017s][debug][os,map] reserve_between (range [0x0000000000000000-0x0000000100000000), size 0x41000000, alignment 0x1000000, randomize: 1)\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                \"-Xshare:\" + (CDS ? \"on\" : \"off\"),\n+                \"-Xmx128m\",\n+                \"-XX:CompressedClassSpaceSize=128m\",\n+                \"-Xlog:metaspace*\", \"-Xlog:metaspace+map=trace\", \"-Xlog:os+map=trace\",\n+                \"-XX:+SimulateFullAddressSpace\", \/\/ So that no resevation attempt will succeed\n+                \"-version\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        final String tryReserveForUnscaled = \"reserve_between (range [0x0000000000000000-0x0000000100000000)\";\n+        final String tryReserveForZeroBased = \"reserve_between (range [0x0000000100000000-0x0000000800000000)\";\n+        final String tryReserveFor16bitMoveIntoQ3 = \"reserve_between (range [0x0000000100000000-0x0001000000000000)\";\n+        if (Platform.isAArch64()) {\n+            if (CDS) {\n+                output.shouldNotContain(tryReserveForUnscaled);\n+            } else {\n+                output.shouldContain(tryReserveForUnscaled);\n+            }\n+            output.shouldContain(\"Trying to reserve at an EOR-compatible address\");\n+            output.shouldNotContain(tryReserveForZeroBased);\n+            output.shouldContain(tryReserveFor16bitMoveIntoQ3);\n+        } else if (Platform.isPPC()) {\n+            if (CDS) {\n+                output.shouldNotContain(tryReserveForUnscaled);\n+                output.shouldNotContain(tryReserveForZeroBased);\n+            } else {\n+                output.shouldContain(tryReserveForUnscaled);\n+                output.shouldContain(tryReserveForZeroBased);\n+            }\n+            output.shouldContain(tryReserveFor16bitMoveIntoQ3);\n+        } else if (Platform.isRISCV64()) {\n+            output.shouldContain(tryReserveForUnscaled); \/\/ unconditionally\n+            if (CDS) {\n+                output.shouldNotContain(tryReserveForZeroBased);\n+                \/\/ bits 32..44\n+                output.shouldContain(\"reserve_between (range [0x0000000100000000-0x0000100000000000)\");\n+            } else {\n+                output.shouldContain(tryReserveForZeroBased);\n+                \/\/ bits 32..44, but not lower than zero-based limit\n+                output.shouldContain(\"reserve_between (range [0x0000000800000000-0x0000100000000000)\");\n+            }\n+            \/\/ bits 44..64\n+            output.shouldContain(\"reserve_between (range [0x0000100000000000-0xffffffffffffffff)\");\n+        } else if (Platform.isS390x()) {\n+            output.shouldContain(tryReserveForUnscaled); \/\/ unconditionally\n+            if (CDS) {\n+                output.shouldNotContain(tryReserveForZeroBased);\n+            } else {\n+                output.shouldContain(tryReserveForZeroBased);\n+            }\n+            output.shouldContain(tryReserveFor16bitMoveIntoQ3);\n+        } else if (Platform.isX64()) {\n+            if (CDS) {\n+                output.shouldNotContain(tryReserveForUnscaled);\n+                output.shouldNotContain(tryReserveForZeroBased);\n+            } else {\n+                output.shouldContain(tryReserveForUnscaled);\n+                output.shouldContain(tryReserveForZeroBased);\n+            }\n+        } else {\n+            throw new RuntimeException(\"Unexpected platform\");\n+        }\n+\n+        \/\/ In all cases we should have managed to map successfully eventually\n+        if (CDS) {\n+            output.shouldContain(\"CDS archive(s) mapped at:\");\n+        } else {\n+            output.shouldContain(\"CDS archive(s) not mapped\");\n+        }\n+        output.shouldContain(\"Compressed class space mapped at:\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"Test with CDS\");\n+        do_test(true);\n+        System.out.println(\"Test without CDS\");\n+        do_test(false);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedCPUSpecificClassSpaceReservation.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,10 @@\n+\/**\n+ * @test id=8320331\n+ * @bug 8320331\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.compiler\n+ * @run main\/othervm\/timeout=200 -XX:+UnlockDiagnosticVMOptions -XX:+VerifyDuringGC -Xmx1g FragmentMetaspace\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/FragmentMetaspace.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/*\n+ * @test id=defaults\n+ * @bug 8319048\n+ * @summary Test the MonitorUnlinkBatch options\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest defaults\n+ *\/\n+\n+\/*\n+ * @test id=legal\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest legal\n+ *\/\n+\n+\/*\n+ * @test id=illegal\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest illegal\n+ *\/\n+\n+\/*\n+ * @test id=aggressive\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest aggressive\n+ *\/\n+\n+\/*\n+ * @test id=lazy\n+ * @library \/test\/lib\n+ * @run driver MonitorUnlinkBatchTest lazy\n+ *\/\n+\n+\n+public class MonitorUnlinkBatchTest {\n+\n+    public static class Test {\n+        \/\/ Inflate a lot of monitors, so that threshold heuristics definitely fires\n+        private static final int MONITORS = 10_000;\n+\n+        \/\/ Use a handful of threads to inflate the monitors, to eat the cost of\n+        \/\/ wait(1) calls. This can be larger than available parallelism, since threads\n+        \/\/ would be time-waiting.\n+        private static final int THREADS = 16;\n+\n+        private static Thread[] threads;\n+        private static Object[] monitors;\n+\n+        public static void main(String... args) throws Exception {\n+            monitors = new Object[MONITORS];\n+            threads = new Thread[THREADS];\n+\n+            for (int t = 0; t < THREADS; t++) {\n+                int monStart = t * MONITORS \/ THREADS;\n+                int monEnd = (t + 1) * MONITORS \/ THREADS;\n+                threads[t] = new Thread(() -> {\n+                    for (int m = monStart; m < monEnd; m++) {\n+                        Object o = new Object();\n+                        synchronized (o) {\n+                            try {\n+                                o.wait(1);\n+                            } catch (InterruptedException e) {\n+                            }\n+                        }\n+                        monitors[m] = o;\n+                    }\n+                });\n+                threads[t].start();\n+            }\n+\n+            for (Thread t : threads) {\n+                t.join();\n+            }\n+\n+            try {\n+                Thread.sleep(10_000);\n+            } catch (InterruptedException ie) {\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length < 1) {\n+            throw new IllegalArgumentException(\"Expect the test label\");\n+        }\n+\n+        String test = args[0];\n+        switch (test) {\n+            case \"defaults\":\n+                test(\"\");\n+                break;\n+\n+            case \"legal\":\n+                \/\/ Legal, even if not useful settings\n+                test(\"\",\n+                     \"-XX:MonitorDeflationMax=100000\",\n+                     \"-XX:MonitorUnlinkBatch=100001\"\n+                     );\n+                break;\n+\n+            case \"illegal\":\n+                \/\/ Quick tests that should fail on JVM flags verification.\n+                test(\"outside the allowed range\",\n+                     \"-XX:MonitorUnlinkBatch=-1\"\n+                );\n+                test(\"outside the allowed range\",\n+                     \"-XX:MonitorUnlinkBatch=0\"\n+                );\n+                break;\n+\n+            case \"aggressive\":\n+                \/\/ The smallest batch possible.\n+                test(\"\",\n+                     \"-XX:MonitorUnlinkBatch=1\"\n+                );\n+                break;\n+\n+            case \"lazy\":\n+                \/\/ The largest batch possible.\n+                test(\"\",\n+                     \"-XX:MonitorDeflationMax=1000000\",\n+                     \"-XX:MonitorUnlinkBatch=1000000\"\n+                );\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"Unknown test: \" + test);\n+        }\n+    }\n+\n+    public static void test(String msg, String... args) throws Exception {\n+        List<String> opts = new ArrayList<>();\n+        opts.add(\"-Xmx128M\");\n+        opts.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        opts.add(\"-XX:GuaranteedAsyncDeflationInterval=100\");\n+        opts.addAll(Arrays.asList(args));\n+        opts.add(\"MonitorUnlinkBatchTest$Test\");\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(opts);\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        if (msg.isEmpty()) {\n+            oa.shouldHaveExitValue(0);\n+        } else {\n+            oa.shouldNotHaveExitValue(0);\n+            oa.shouldContain(msg);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorUnlinkBatchTest.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2023, Red Hat, Inc. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail HugeArenaTracking\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=summary HugeArenaTracking\n@@ -40,1 +40,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -45,1 +44,2 @@\n-  private static final long GB = 1024 * 1024 * 1024;\n+  private static final long MB = 1024 * 1024;\n+  private static final long GB = MB * 1024;\n@@ -48,1 +48,0 @@\n-    OutputAnalyzer output;\n@@ -51,4 +50,0 @@\n-    \/\/ Grab my own PID\n-    String pid = Long.toString(ProcessTools.getProcessId());\n-    ProcessBuilder pb = new ProcessBuilder();\n-\n@@ -58,4 +53,4 @@\n-    \/\/ Run 'jcmd <pid> VM.native_memory summary'\n-    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\"});\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=2KB, committed=2KB)\");\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[] { \"scale=K\" },\n+            new String[] { \"Test (reserved=2KB, committed=2KB)\",\n+                           \"(arena=2KB #2) (at peak)\" });\n@@ -68,4 +63,2 @@\n-      \/\/ Cap to 10M\n-      long inc = rand.nextInt(10 * 1024 * 1024);\n-      wb.NMTArenaMalloc(arena1, inc);\n-      total += inc;\n+      wb.NMTArenaMalloc(arena1, MB);\n+      total += MB;\n@@ -74,5 +67,12 @@\n-    ProcessBuilder pb2 = new ProcessBuilder();\n-    \/\/ Run 'jcmd <pid> VM.native_memory summary'\n-    pb2.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\", \"scale=GB\"});\n-    output = new OutputAnalyzer(pb2.start());\n-    output.shouldContain(\"Test (reserved=2GB, committed=2GB)\");\n+    \/\/ run a report at GB level. We should see our allocations; since they are rounded\n+    \/\/ to GB, we expect an exact output match\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[] { \"scale=G\" },\n+            new String[] { \"Test (reserved=2GB, committed=2GB)\",\n+                           \"(arena=2GB #2) (at peak)\" });\n+\n+    \/\/ Repeat at MB level; we expect the same behavior\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[] { \"scale=M\" },\n+            new String[] { \"Test (reserved=2048MB, committed=2048MB)\",\n+                           \"(arena=2048MB #2) (at peak)\" });\n@@ -82,2 +82,21 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=1KB, committed=1KB)\");\n+    \/\/ Repeat report at GB level. Reserved should be 0 now. Current usage is 1KB, since arena2 is left, but that\n+    \/\/ is below GB scale threshold, so should show up as 0.\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[] { \"scale=G\" },\n+            new String[] { \"Test (reserved=0GB, committed=0GB)\",\n+                           \"(arena=0GB #1) (peak=2GB #2)\" });\n+\n+    \/\/ Same, for MB scale\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[] { \"scale=M\" },\n+            new String[] { \"Test (reserved=0MB, committed=0MB)\",\n+                           \"(arena=0MB #1) (peak=2048MB #2)\" });\n+\n+    \/\/ At KB level we should see the remaining 1KB. Note that we refrain from testing peak here\n+    \/\/ since the number gets fuzzy: it depends on the size of the initially allocated chunk. At MB\n+    \/\/ and GB scale, these differences don't matter.\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[] { \"scale=K\" },\n+            new String[] { \"Test (reserved=1KB, committed=1KB)\",\n+                           \"(arena=1KB #1) (peak=\" });\n+\n@@ -86,2 +105,5 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldNotContain(\"Test (reserved\");\n+    \/\/ Everything free'd, current usage 0, peak should be preserved.\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[] { \"scale=G\" },\n+            new String[] { \"Test (reserved=0GB, committed=0GB)\",\n+                           \"(arena=0GB #0) (peak=2GB #2)\" });\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/HugeArenaTracking.java","additions":48,"deletions":26,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n@@ -36,4 +37,0 @@\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.JDKToolFinder;\n-\n@@ -46,1 +43,0 @@\n-        OutputAnalyzer output;\n@@ -49,4 +45,0 @@\n-        \/\/ Grab my own PID\n-        String pid = Long.toString(ProcessTools.getProcessId());\n-        ProcessBuilder pb = new ProcessBuilder();\n-\n@@ -66,5 +58,4 @@\n-                String expectedOut = (\"Test (reserved=\" + numKB + \"KB, committed=\" + numKB + \"KB)\");\n-\n-                pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\" });\n-                output = new OutputAnalyzer(pb.start());\n-                output.shouldContain(expectedOut);\n+                NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+                        \"Test (reserved=\" + numKB + \"KB, committed=\" + numKB + \"KB)\",\n+                        \"(malloc=\" + numKB + \"KB #1) (at peak)\"\n+                );\n@@ -73,0 +64,1 @@\n+\n@@ -74,3 +66,4 @@\n-                pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\" });\n-                output = new OutputAnalyzer(pb.start());\n-                output.shouldNotContain(\"Test (reserved=\");\n+                NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+                        \"Test (reserved=0KB, committed=0KB)\",\n+                        \"(malloc=0KB) (peak=\" + numKB + \"KB #1)\"\n+                );\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocRoundingReportTest.java","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n@@ -133,1 +134,1 @@\n-        output.shouldNotContain(\"Test (reserved=\");\n+        output.shouldContain(\"Test (reserved=0KB, committed=0KB)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocStressTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n@@ -35,3 +36,0 @@\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.JDKToolFinder;\n@@ -43,1 +41,0 @@\n-    OutputAnalyzer output;\n@@ -46,4 +43,0 @@\n-    \/\/ Grab my own PID\n-    String pid = Long.toString(ProcessTools.getProcessId());\n-    ProcessBuilder pb = new ProcessBuilder();\n-\n@@ -51,5 +44,10 @@\n-    long memAlloc3 = wb.NMTMalloc(128 * 1024);\n-    long memAlloc2 = wb.NMTMalloc(256 * 1024);\n-    wb.NMTFree(memAlloc3);\n-    long memAlloc1 = wb.NMTMalloc(512 * 1024);\n-    wb.NMTFree(memAlloc2);\n+    long memAlloc3 = wb.NMTMalloc(128 * 1024);  \/\/ current +128K #1 peak +128K #1\n+    long memAlloc2 = wb.NMTMalloc(256 * 1024);  \/\/ current +384K #2 peak +384K #2\n+\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[]{\"Test (reserved=384KB, committed=384KB)\",\n+                         \"(malloc=384KB #2) (at peak)\"});\n+\n+    wb.NMTFree(memAlloc3);                           \/\/ current +256K #1 peak +384K #2\n+    long memAlloc1 = wb.NMTMalloc(512 * 1024);  \/\/ current +768K #2 peak +768K #2\n+    wb.NMTFree(memAlloc2);                           \/\/ current +512K #1 peak +768K #2\n@@ -57,4 +55,3 @@\n-    \/\/ Run 'jcmd <pid> VM.native_memory summary'\n-    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\"});\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=512KB, committed=512KB)\");\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[]{\"Test (reserved=512KB, committed=512KB)\",\n+                         \"(malloc=512KB #1) (peak=768KB #2)\"});\n@@ -63,1 +60,1 @@\n-    wb.NMTFree(memAlloc1);\n+    wb.NMTFree(memAlloc1); \/\/ current 0K #0 peak +768K #2\n@@ -65,2 +62,3 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldNotContain(\"Test (reserved=\");\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            new String[]{\"Test (reserved=0KB, committed=0KB)\",\n+                         \"(malloc=0KB) (peak=768KB #2)\"});\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocTestType.java","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n@@ -34,1 +35,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail MallocTrackingVerify\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=summary MallocTrackingVerify\n@@ -56,5 +57,0 @@\n-        OutputAnalyzer output;\n-\n-        \/\/ Grab my own PID\n-        String pid = Long.toString(ProcessTools.getProcessId());\n-        ProcessBuilder pb = new ProcessBuilder();\n@@ -77,3 +73,4 @@\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\" });\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4KB, committed=4KB)\");\n+        NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+                \"Test (reserved=4KB, committed=4KB)\",\n+                \"(malloc=4KB #\" + mallocd_memory.size() + \") (at peak)\"\n+        );\n@@ -87,4 +84,5 @@\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid,\n-                \"VM.native_memory\", \"summary\" });\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldNotContain(\"Test (reserved=\");\n+        NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+                \"Test (reserved=0KB, committed=0KB)\",\n+                \"(malloc=0KB) (peak=4KB #\" + + mallocd_memory.size() + \")\"\n+        );\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocTrackingVerify.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NMTTestUtils {\n+\n+    public static OutputAnalyzer startJcmdVMNativeMemory(String... additional_args) throws Exception {\n+        if (additional_args == null) {\n+            additional_args = new String[] {};\n+        }\n+        String fullargs[] = new String[3 + additional_args.length];\n+        fullargs[0] = JDKToolFinder.getJDKTool(\"jcmd\");\n+        fullargs[1] = Long.toString(ProcessTools.getProcessId());\n+        fullargs[2] = \"VM.native_memory\";\n+        System.arraycopy(additional_args, 0, fullargs, 3, additional_args.length);\n+        ProcessBuilder pb = new ProcessBuilder();\n+        pb.command(fullargs);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        return output;\n+    }\n+\n+    public static OutputAnalyzer startJcmdVMNativeMemoryDetail(String... additional_args) throws Exception {\n+        return startJcmdVMNativeMemory(\"detail\");\n+    }\n+\n+    public static void runJcmdSummaryReportAndCheckOutput(String[] additional_args, String[] pattern, boolean verbose) throws Exception {\n+        OutputAnalyzer output = startJcmdVMNativeMemory(additional_args);\n+        output.stdoutShouldContainMultiLinePattern(pattern, true);\n+    }\n+\n+    public static void runJcmdSummaryReportAndCheckOutput(String[] additional_args, String[] pattern) throws Exception {\n+        runJcmdSummaryReportAndCheckOutput(additional_args, pattern, true);\n+    }\n+\n+    public static void runJcmdSummaryReportAndCheckOutput(String... pattern) throws Exception {\n+        runJcmdSummaryReportAndCheckOutput(null, pattern, true);\n+    }\n+\n+    public static void checkReservedCommittedSummary(OutputAnalyzer output, long reservedKB, long committedKB, long peakKB) {\n+        String peakString = (committedKB == peakKB) ? \"at peak\" : \"peak=\" + peakKB + \"KB\";\n+        output.stdoutShouldContainMultiLinePattern(\n+                \"Test (reserved=\" + reservedKB + \"KB, committed=\" + committedKB + \"KB)\",\n+                \"(mmap: reserved=\" + reservedKB + \"KB, committed=\" + committedKB + \"KB, \" + peakString + \")\"\n+        );\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTTestUtils.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n@@ -31,1 +32,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail ThreadedMallocTestType\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=summary ThreadedMallocTestType\n@@ -34,3 +35,0 @@\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.JDKToolFinder;\n@@ -45,1 +43,0 @@\n-    OutputAnalyzer output;\n@@ -48,4 +45,0 @@\n-    \/\/ Grab my own PID\n-    String pid = Long.toString(ProcessTools.getProcessId());\n-    ProcessBuilder pb = new ProcessBuilder();\n-\n@@ -69,3 +62,4 @@\n-    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"summary\"});\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=896KB, committed=896KB)\");\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            \"Test (reserved=896KB, committed=896KB)\",\n+            \"(malloc=896KB #3) (at peak)\"\n+    );\n@@ -85,2 +79,4 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldNotContain(\"Test (reserved=\");\n+    NMTTestUtils.runJcmdSummaryReportAndCheckOutput(\n+            \"Test (reserved=0KB, committed=0KB)\",\n+            \"(malloc=0KB) (peak=896KB #3)\"\n+    );\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/ThreadedMallocTestType.java","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n@@ -34,1 +35,0 @@\n-import jdk.test.lib.process.ProcessTools;\n@@ -36,1 +36,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -48,2 +47,0 @@\n-    String pid = Long.toString(ProcessTools.getProcessId());\n-    ProcessBuilder pb = new ProcessBuilder();\n@@ -59,3 +56,2 @@\n-    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"detail\"});\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=512KB, committed=0KB)\");\n+    output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+    checkReservedCommittedSummary(output,512, 0);\n@@ -72,2 +68,2 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=512KB, committed=128KB)\");\n+    output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+    checkReservedCommittedSummary(output,512, 128);\n@@ -84,1 +80,2 @@\n-    output = new OutputAnalyzer(pb.start());\n+    output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+    checkReservedCommittedSummary(output,512, 0);\n@@ -96,2 +93,2 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldNotContain(\"Test (reserved=\");\n+    output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+    checkReservedCommittedSummary(output,0, 0);\n@@ -101,0 +98,9 @@\n+  static long peakKB = 0;\n+\n+  public static void checkReservedCommittedSummary(OutputAnalyzer output, long reservedKB, long committedKB) {\n+    if (committedKB > peakKB) {\n+      peakKB = committedKB;\n+    }\n+    NMTTestUtils.checkReservedCommittedSummary(output, reservedKB, committedKB, peakKB);\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/ThreadedVirtualAllocTestType.java","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.test.lib.process.ProcessTools;\n@@ -41,1 +40,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -56,3 +54,0 @@\n-        String pid = Long.toString(ProcessTools.getProcessId());\n-        ProcessBuilder pb = new ProcessBuilder();\n-\n@@ -61,5 +56,2 @@\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid,\n-                \"VM.native_memory\", \"detail\" });\n-\n-        output = new OutputAnalyzer(pb.start());\n-        checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+        output = NMTTestUtils.startJcmdVMNativeMemory(\"detail\");\n+        checkReservedCommittedSummary(output, 4096, 0);\n@@ -78,2 +70,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -87,2 +79,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -96,2 +88,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -104,2 +96,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -113,2 +105,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -124,2 +116,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -137,2 +129,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -147,2 +139,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"256KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 256);\n@@ -157,2 +149,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -166,2 +158,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"256KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 256);\n@@ -176,2 +168,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -186,2 +178,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -197,2 +189,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -207,2 +199,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -218,2 +210,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -228,2 +220,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -239,2 +231,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -249,2 +241,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -260,2 +252,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -270,2 +262,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -281,2 +273,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -291,2 +283,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"384KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 384);\n@@ -302,2 +294,2 @@\n-            output = new OutputAnalyzer(pb.start());\n-            checkReservedCommittedSummary(output, \"4096KB\", \"0KB\");\n+            output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+            checkReservedCommittedSummary(output, 4096, 0);\n@@ -308,2 +300,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldNotContain(\"Test (reserved=\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 0, 0);\n@@ -314,2 +306,8 @@\n-    public static void checkReservedCommittedSummary(OutputAnalyzer output, String reservedString, String committedString) {\n-        output.shouldContain(\"Test (reserved=\" + reservedString + \", committed=\" + committedString + \")\");\n+    \/\/ running peak counter\n+    static long peakKB = 0;\n+\n+    public static void checkReservedCommittedSummary(OutputAnalyzer output, long reservedKB, long committedKB) {\n+        if (committedKB > peakKB) {\n+            peakKB = committedKB;\n+        }\n+        NMTTestUtils.checkReservedCommittedSummary(output, reservedKB, committedKB, peakKB);\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/VirtualAllocCommitMerge.java","additions":58,"deletions":60,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import jdk.test.lib.process.ProcessTools;\n@@ -38,2 +37,0 @@\n-import jdk.test.lib.JDKToolFinder;\n-\n@@ -52,3 +49,0 @@\n-        String pid = Long.toString(ProcessTools.getProcessId());\n-        ProcessBuilder pb = new ProcessBuilder();\n-\n@@ -57,5 +51,2 @@\n-        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid,\n-                \"VM.native_memory\", \"detail\" });\n-\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4096KB, committed=0KB)\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 4096, 0);\n@@ -79,2 +70,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4096KB, committed=512KB)\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 4096, 512);\n@@ -89,3 +80,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4096KB, committed=256KB)\");\n-\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 4096, 256);\n@@ -100,2 +90,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4096KB, committed=512KB)\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 4096, 512);\n@@ -109,2 +99,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4096KB, committed=384KB)\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 4096, 384);\n@@ -120,2 +110,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4096KB, committed=768KB)\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 4096, 768);\n@@ -134,2 +124,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"Test (reserved=4096KB, committed=0KB)\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 4096, 0);\n@@ -142,2 +132,2 @@\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldNotContain(\"Test (reserved=\");\n+        output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+        checkReservedCommittedSummary(output, 0, 0);\n@@ -147,0 +137,10 @@\n+\n+    \/\/ running peak counter\n+    static long peakKB = 0;\n+\n+    public static void checkReservedCommittedSummary(OutputAnalyzer output, long reservedKB, long committedKB) {\n+        if (committedKB > peakKB) {\n+            peakKB = committedKB;\n+        }\n+        NMTTestUtils.checkReservedCommittedSummary(output, reservedKB, committedKB, peakKB);\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/VirtualAllocCommitUncommitRecommit.java","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import jdk.test.lib.process.ProcessTools;\n@@ -37,1 +36,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -47,1 +45,1 @@\n-    long addr;\n+    long addr1, addr2;\n@@ -49,2 +47,1 @@\n-    String pid = Long.toString(ProcessTools.getProcessId());\n-    ProcessBuilder pb = new ProcessBuilder();\n+    String info = \"start\";\n@@ -52,2 +49,5 @@\n-    addr = wb.NMTReserveMemory(reserveSize);\n-    pb.command(new String[] { JDKToolFinder.getJDKTool(\"jcmd\"), pid, \"VM.native_memory\", \"detail\"});\n+    try {\n+      \/\/ ------\n+      \/\/ Reserve first mapping\n+      addr1 = wb.NMTReserveMemory(reserveSize);\n+      info = \"reserve 1: addr1=\" + addr1;\n@@ -55,3 +55,3 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=256KB, committed=0KB)\");\n-    output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr) + \" - 0x[0]*\" + Long.toHexString(addr + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 256, 0);\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n@@ -59,1 +59,4 @@\n-    wb.NMTCommitMemory(addr, commitSize);\n+      \/\/ ------\n+      \/\/ Reserve second mapping\n+      addr2 = wb.NMTReserveMemory(reserveSize);\n+      info = \"reserve 2: addr2=\" + addr2;\n@@ -61,0 +64,7 @@\n+      \/\/ If the second mapping happens to be adjacent to the first mapping, reserve another mapping and release the second mapping; for\n+      \/\/ this test, we want to see two disjunct mappings.\n+      if (addr2 == addr1 + reserveSize) {\n+        long tmp = wb.NMTReserveMemory(reserveSize);\n+        wb.NMTReleaseMemory(addr2, reserveSize);\n+        addr2 = tmp;\n+      }\n@@ -62,3 +72,4 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=256KB, committed=128KB)\");\n-    output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr) + \" - 0x[0]*\" + Long.toHexString(addr + commitSize) + \"\\\\] committed 128KB\");\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 512, 0);\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n@@ -66,1 +77,4 @@\n-    wb.NMTUncommitMemory(addr, commitSize);\n+      \/\/ ------\n+      \/\/ Now commit the first mapping\n+      wb.NMTCommitMemory(addr1, commitSize);\n+      info = \"commit 1\";\n@@ -68,0 +82,5 @@\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 512, 128);\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + commitSize) + \"\\\\] committed 128KB\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n@@ -69,3 +88,4 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldContain(\"Test (reserved=256KB, committed=0KB)\");\n-    output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr) + \" - 0x[0]*\" + Long.toHexString(addr + commitSize) + \"\\\\] committed\");\n+      \/\/ ------\n+      \/\/ Now commit the second mapping\n+      wb.NMTCommitMemory(addr2, commitSize);\n+      info = \"commit 2\";\n@@ -73,1 +93,6 @@\n-    wb.NMTReleaseMemory(addr, reserveSize);\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 512, 256);\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + commitSize) + \"\\\\] committed 128KB\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + commitSize) + \"\\\\] committed 128KB\");\n@@ -75,3 +100,60 @@\n-    output = new OutputAnalyzer(pb.start());\n-    output.shouldNotContain(\"Test (reserved=\");\n-    output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr) + \" - 0x[0]*\" + Long.toHexString(addr + reserveSize) + \"\\\\] reserved\");\n+      \/\/ ------\n+      \/\/ Now uncommit the second mapping\n+      wb.NMTUncommitMemory(addr2, commitSize);\n+      info = \"uncommit 2\";\n+\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 512, 128);\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + commitSize) + \"\\\\] committed 128KB\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + commitSize) + \"\\\\] committed 128KB\");\n+\n+      \/\/ ------\n+      \/\/ Now uncommit the first mapping\n+      wb.NMTUncommitMemory(addr1, commitSize);\n+      info = \"uncommit 1\";\n+\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 512, 0);\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + commitSize) + \"\\\\] committed 128KB\");\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + commitSize) + \"\\\\] committed 128KB\");\n+\n+      \/\/ ----------\n+      \/\/ Release second mapping\n+      wb.NMTReleaseMemory(addr2, reserveSize);\n+      info = \"release 2\";\n+\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 256, 0);\n+      output.shouldMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + commitSize) + \"\\\\] committed 128KB\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + commitSize) + \"\\\\] committed 128KB\");\n+\n+      \/\/ ----------\n+      \/\/ Release first mapping\n+      wb.NMTReleaseMemory(addr1, reserveSize);\n+      info = \"release 1\";\n+\n+      output = NMTTestUtils.startJcmdVMNativeMemoryDetail();\n+      checkReservedCommittedSummary(output, 0, 0);\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr1) + \" - 0x[0]*\" + Long.toHexString(addr1 + commitSize) + \"\\\\] committed 128KB\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + reserveSize) + \"\\\\] reserved 256KB for Test\");\n+      output.shouldNotMatch(\"\\\\[0x[0]*\" + Long.toHexString(addr2) + \" - 0x[0]*\" + Long.toHexString(addr2 + commitSize) + \"\\\\] committed 128KB\");\n+\n+    } catch (Exception e) {\n+      throw new RuntimeException(e.getMessage() + \" (\" + info + \")\");\n+    }\n+  }\n+\n+  static long peakKB = 0;\n+\n+  public static void checkReservedCommittedSummary(OutputAnalyzer output, long reservedKB, long committedKB) {\n+    if (committedKB > peakKB) {\n+      peakKB = committedKB;\n+    }\n+    NMTTestUtils.checkReservedCommittedSummary(output, reservedKB, committedKB, peakKB);\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/VirtualAllocTestType.java","additions":105,"deletions":23,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -47,0 +47,8 @@\n+            \/\/ We run the VM in interpreted mode, because the JIT might mark\n+            \/\/ a Java method as not-entrant, which means turning the first instruction\n+            \/\/ into an illegal one. Calling such a method after establishing\n+            \/\/ the new SIGILL signal handler with TestPosixSig.changeSigActionFor(4)\n+            \/\/ below, but before the JNI checker noted and reacted on this signal handler\n+            \/\/ modification, the JVM may crash or hang in an endless loop, where the\n+            \/\/ illegal instruction will be continously executed, raising SIGILL, and\n+            \/\/ the signal handler will return to the illegal instruction again...\n@@ -49,0 +57,1 @@\n+                \"-Xint\",\n","filename":"test\/hotspot\/jtreg\/runtime\/posixSig\/TestPosixSig.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8313816\n+ * @summary Test that a sequence of method retransformation and stacktrace capture while the old method\n+ *          version is still on stack does not lead to a crash when that method's jmethodID is used as\n+ *          an argument for JVMTI functions.\n+ * @requires vm.jvmti\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @modules java.instrument\n+ *          java.compiler\n+ * @compile GetStackTraceAndRetransformTest.java\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main RedefineClassHelper\n+ * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -javaagent:redefineagent.jar -agentlib:GetStackTraceAndRetransformTest GetStackTraceAndRetransformTest\n+ *\/\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+class Transformable {\n+  static final String newClass = \"\"\"\n+    class Transformable {\n+      static final String newClass = \"\";\n+      static void redefineAndStacktrace() throws Exception {}\n+      static void stacktrace() throws Exception {\n+        capture(Thread.currentThread());\n+      }\n+      public static native void capture(Thread thread);\n+    }\n+  \"\"\";\n+  static void redefineAndStacktrace() throws Exception {\n+    \/\/ This call will cause the class to be retransformed.\n+    \/\/ However, this method is still on stack so the subsequent attempt to capture the stacktrace\n+    \/\/ will result into this frame being identified by the jmethodID of the previous method version.\n+    RedefineClassHelper.redefineClass(Transformable.class, newClass);\n+    capture(Thread.currentThread());\n+  }\n+\n+  static void stacktrace() throws Exception {\n+  }\n+\n+  public static native void capture(Thread thread);\n+}\n+\n+public class GetStackTraceAndRetransformTest {\n+    public static void main(String args[]) throws Throwable {\n+        initialize(Transformable.class);\n+\n+        Transformable.redefineAndStacktrace();\n+        Transformable.stacktrace();\n+\n+        WhiteBox.getWhiteBox().cleanMetaspaces();\n+        check(2);\n+    }\n+\n+    public static native void initialize(Class<?> target);\n+    public static native void check(int expected);\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/GetStackTraceAndRetransformTest\/GetStackTraceAndRetransformTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+#include \"..\/get_stack_trace.h\"\n+\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jmethodID* ids = NULL;\n+static int ids_size = 0;\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  jint res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+  ids = (jmethodID*)malloc(sizeof(jmethodID) * 10);\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_GetStackTraceAndRetransformTest_initialize(JNIEnv *env, jclass cls, jclass tgt) {\n+  \/\/ we need to force jmethodids to be created for the methods we are going to retransform\n+  env->GetStaticMethodID(tgt, \"redefineAndStacktrace\", \"()V\");\n+  env->GetStaticMethodID(tgt, \"stacktrace\", \"()V\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_Transformable_capture(JNIEnv *env, jclass cls, jthread thread) {\n+  jint count;\n+  const int MAX_NUMBER_OF_FRAMES = 32;\n+  jvmtiFrameInfo frames[MAX_NUMBER_OF_FRAMES];\n+\n+  jvmtiError err = jvmti->GetStackTrace(thread, 0, MAX_NUMBER_OF_FRAMES, frames, &count);\n+  check_jvmti_status(env, err, \"GetStackTrace failed.\");\n+\n+  ids[ids_size++] = frames[1].method;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_GetStackTraceAndRetransformTest_check(JNIEnv *jni, jclass cls, jint expected) {\n+  if (ids_size != expected) {\n+    fprintf(stderr, \"Unexpected number methods captured: %d (expected %d)\\n\", ids_size, expected);\n+    exit(2);\n+  }\n+  for (int i = 0; i < ids_size; i++) {\n+    jclass rslt = NULL;\n+    char* class_name = NULL;\n+    jvmti->GetMethodDeclaringClass(ids[i], &rslt);\n+    if (rslt != NULL) {\n+        jvmti->GetClassSignature(rslt, &class_name, NULL);\n+    }\n+  }\n+}\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetStackTrace\/GetStackTraceAndRetransformTest\/libGetStackTraceAndRetransformTest.cpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -35,1 +35,1 @@\n- * @run main\/othervm nsk.stress.thread.thread007 500 2m 5s\n+ * @run main\/othervm\/timeout=300 nsk.stress.thread.thread007 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread007.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @run main\/othervm nsk.stress.thread.thread008 500 2m 5s\n+ * @run main\/othervm\/timeout=300 nsk.stress.thread.thread008 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread008.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+@SuppressWarnings(\"removal\")\n@@ -164,0 +165,1 @@\n+@SuppressWarnings(\"removal\")\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/libs\/jaxp\/library\/JAXPPolicyManager.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -374,1 +374,3 @@\n-        factory.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), catalog);\n+        if (catalog != null) {\n+            factory.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), catalog);\n+        }\n@@ -475,1 +477,3 @@\n-        parser.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), catalog);\n+        if (catalog != null) {\n+            parser.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), catalog);\n+        }\n@@ -498,1 +502,3 @@\n-        reader.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), catalog);\n+        if (catalog != null) {\n+            reader.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), catalog);\n+        }\n@@ -569,1 +575,3 @@\n-            xif.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), catalog);\n+            if (catalog != null) {\n+                xif.setProperty(CatalogFeatures.Feature.FILES.getPropertyName(), catalog);\n+            }\n@@ -1016,0 +1024,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/catalog\/CatalogSupportBase.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,361 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.catalog;\n+\n+import common.util.TestBase;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.validation.SchemaFactory;\n+\/\/import org.testng.annotations.DataProvider;\n+\n+\/**\n+ * Tests the JDK Catalog\n+ *\/\n+public class CatalogTestBase extends TestBase {\n+    \/*\n+     * DataProvider for testing configuring properties for parsers.\n+     *\n+     * Fields:\n+     *     file, FSP, state of setting, config file, system property, api property,\n+     *     Custom Catalog, error expected, error code or expected result\n+     *\/\n+    \/\/@DataProvider(name = \"configWCatalogForParsers\")\n+    public Object[][] getConfigs(Processor processor) {\n+        \/\/ file with an external DTD that's not in JdkCatalog\n+        String fileDTDNotInC = \"properties1.xml\";\n+        \/\/ file with an external DTD that's in the Custom Catalog\n+        String fileDTDInCC = \"test.xml\";\n+        \/\/ file with an external DTD that's in JdkCatalog\n+        String javaDTD = \"properties.xml\";\n+        \/\/ file with an external DTD thats in the Custom Catalog\n+        String w3cDTD = \"xhtml11.xml\";\n+\n+        \/\/ error code when CATALOG=strict; The cause for DOM\n+        String errCode = \"JAXP09040001\";\n+\n+        \/\/ error (not from catalog) is expect when CATALOG=continue\n+        boolean isErrExpected = true;\n+        String expected1 = UNKNOWN_HOST;\n+\n+        \/\/ expected when reference is resolved by Catalog\n+        String expected3 = \"\", expected4 = \"\";\n+        switch (processor) {\n+            case SAX:\n+                errCode = \"JAXP00090001\";\n+                break;\n+            case STAX:\n+                errCode = \"JAXP00090001\";\n+                \/\/errCode = \"JAXP00090001\";\n+                \/\/ StAX is non-validating parser\n+                isErrExpected = false;\n+                expected1 = \".*[\\\\w\\\\s]*(value1)[\\\\w\\\\s]*.*\";\n+                expected3 = \"Minimal XHTML 1.1 DocumentThis is a minimal XHTML 1.1 document.\";\n+                expected4 = \".*(123)[\\\\w\\\\s]*.*\";\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        return new Object[][]{\n+            \/\/ Case 1: external reference not in the JDKCatalog\n+            \/**\n+             * Case 1-1: default setting; no Config file; Catalog: continue (by default)\n+             * Expect: error as the parser continues and tries to access an invalid site\n+             *         java.net.UnknownHostException: invalid.site.com\n+             *\/\n+            {fileDTDNotInC, null, null, null, null, null, null, isErrExpected, expected1},\n+\n+            \/**\n+             * Case 1-2: set JDK Catalog to strict in a Config file\n+             * Expect: Exception since the external reference is not in the Catalog\n+             * Error Msg:\n+             * [Fatal Error] properties1.xml:2:75: JAXP00090001: The CatalogResolver is enabled with the catalog \"JdkCatalog.xml\", but a CatalogException is returned.\n+             * org.xml.sax.SAXException: javax.xml.catalog.CatalogException: JAXP09040001: No match found for publicId 'null' and systemId 'http:\/\/invalid.site.com\/dtd\/properties1.dtd'.\n+             * javax.xml.catalog.CatalogException: JAXP09040001: No match found for publicId 'null' and systemId 'http:\/\/invalid.site.com\/dtd\/properties1.dtd'.\n+             *\/\n+            {fileDTDNotInC, null, PropertyState.CONFIG_FILE, Properties.CONFIG_FILE_CATALOG_STRICT, null, null, null, true, errCode},\n+\n+            \/**\n+             * Case 1-3: set CATALOG back to continue through the System Property\n+             * Expect: error as the parser continues and tries to access an invalid site\n+             *         java.net.UnknownHostException: invalid.site.com\n+             *\/\n+            {fileDTDNotInC, null, PropertyState.CONFIG_FILE_SYSTEM, Properties.CONFIG_FILE_CATALOG_STRICT, new Properties[]{Properties.CATALOG0}, null, null, isErrExpected, expected1},\n+\n+            \/**\n+             * Case 1-4: override the settings in Case 3 with the API property, and set Catalog to strict\n+             * Expect: Exception since the external reference is not in the Catalog\n+             *\/\n+            {fileDTDNotInC, null, PropertyState.CONFIG_FILE_SYSTEM_API, Properties.CONFIG_FILE_CATALOG_STRICT, new Properties[]{Properties.CATALOG0}, new Properties[]{Properties.CATALOG2}, null, true, errCode},\n+\n+            \/\/ Case 2: external reference in the JDKCatalog\n+            \/**\n+             * Case 2-1: set CATALOG to strict in a Config file\n+             * Compare to: case 1-2\n+             * Expect: pass without error\n+             *\/\n+            {javaDTD, null, PropertyState.CONFIG_FILE, Properties.CONFIG_FILE_CATALOG_STRICT, null, null, null, false, expected1},\n+\n+            \/**\n+             * Case 2-2: override the settings in Case 3 with the API property, and set Catalog to strict\n+             * Compare to: case 1-4\n+             * Expect: pass without error\n+             *\/\n+            {javaDTD, null, PropertyState.CONFIG_FILE_SYSTEM_API, Properties.CONFIG_FILE_CATALOG_STRICT, new Properties[]{Properties.CATALOG0}, new Properties[]{Properties.CATALOG2}, null, false, expected1},\n+\n+            \/\/ Case 3: external reference in the Custom Catalog\n+            \/**\n+             * Case 3-1: set CATALOG to strict in a Config file\n+             * Compare to: case 1-2, would have resulted in an error without the\n+             *         custom catalog\n+             * Expect: pass without error because the external reference is in\n+             *         the custom catalog\n+             *\/\n+            {fileDTDInCC, null, PropertyState.CONFIG_FILE, Properties.CONFIG_FILE_CATALOG_STRICT, null, null, CustomCatalog.STRICT, false, expected4},\n+\n+            \/**\n+             * Case 3-2: override the settings in Case 3 with the API property, and set Catalog to strict\n+             * Compare to: case 1-4, would have resulted in an error without the\n+             *         custom catalog\n+             * Expect: pass without error\n+             *\/\n+            {fileDTDInCC, null, PropertyState.CONFIG_FILE_SYSTEM_API, Properties.CONFIG_FILE_CATALOG_STRICT, new Properties[]{Properties.CATALOG0}, new Properties[]{Properties.CATALOG2}, CustomCatalog.STRICT, false, expected4},\n+\n+            \/\/ Case 4: Parameter Entity reference\n+            \/**\n+             * Case 4-1: set CATALOG to strict in a Config file\n+             * Compare to: case 1-2, would have resulted in an error since the external\n+             * reference can not be found\n+             * Expect: pass without error because the external reference is in\n+             *         the custom catalog\n+             *\/\n+            {\"testExternalParameter.xml\", null, PropertyState.CONFIG_FILE, Properties.CONFIG_FILE_CATALOG_STRICT, null, null, CustomCatalog.STRICT, false, expected1},\n+\n+            \/\/ Case 5: resolve xInclude with the Custom Catalog\n+            \/**\n+             * Case 5-1: set CATALOG to strict in a Config file\n+             * Compare to: case 1-2, would have resulted in an error without the\n+             *         custom catalog\n+             * Expect: pass without error because the external reference is in\n+             *         the custom catalog\n+             *\/\n+            {\"XI_roottest.xml\", null, PropertyState.CONFIG_FILE, Properties.CONFIG_FILE_CATALOG_STRICT, null, null, CustomCatalog.STRICT, false, \"\"},\n+\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider for testing configuring properties for validation or transform.\n+     *\n+     * Fields:\n+     *     xml file, xsd or xsl file, FSP, state of setting, config file, system property,\n+     *     api property, Custom Catalog, error expected, error code or expected result\n+     *\/\n+    \/\/@DataProvider(name = \"validationOrTransform\")\n+    public Object[][] getConfig(String m) {\n+        \/\/ Schema Import\n+        String xmlFile = \"XSDImport_company.xsd\";\n+        String xsdOrXsl = null;\n+        String expected = \"\";\n+        String errCode = \"JAXP00090001\";\n+\n+        switch (m) {\n+            case \"SchemaTest2\":\n+                \/\/ Schema Include\n+                xmlFile = \"XSDInclude_company.xsd\";\n+                break;\n+            case \"Validation\":\n+                \/\/ Schema Location\n+                xmlFile = \"val_test.xml\";\n+                break;\n+            case \"Stylesheet\":\n+                errCode = \"JAXP09040001\";\n+                xmlFile = \"XSLDTD.xsl\";\n+                break;\n+            case \"Transform\":\n+                xmlFile = \"XSLPI.xml\";\n+                errCode = \"JAXP09040001\";\n+                xsdOrXsl = \"<?xml version='1.0'?>\"\n+                + \"<!DOCTYPE top SYSTEM 'test.dtd'\"\n+                + \"[\"\n+                + \"<!ENTITY % pe \\\"x\\\">\"\n+                + \"<!ENTITY   x1 \\\"AAAAA\\\">\"\n+                + \"<!ENTITY   x2 \\\"bbb\\\">\"\n+                +\"]>\"\n+                + \"<?xml-stylesheet href=\\\"\"\n+                + TEST_SOURCE_DIR\n+                + \"\/XSLPI_target.xsl\\\" type=\\\"text\/xml\\\"?>\"\n+                + \"<xsl:stylesheet \"\n+                + \"    xmlns:xsl='http:\/\/www.w3.org\/1999\/XSL\/Transform' \"\n+                + \"    version='1.0'>\"\n+                + \"<\/xsl:stylesheet> \";\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        return new Object[][]{\n+            \/\/ Case 1: external reference not in the JDKCatalog\n+            \/**\n+             * Case 1-1: default setting; no Config file; Catalog: continue\n+             * Expect: pass without error\n+             *\/\n+            {xmlFile, xsdOrXsl, null, null, null, null, null, null, false, expected},\n+\n+            \/**\n+             * Case 1-2: set CATALOG to strict in a Config file\n+             * Expect: Exception since the external reference is not in the Catalog\n+             * Sample Error Msg:\n+             * org.xml.sax.SAXParseException; systemId: file:path\/XSDImport_company.xsd;\n+             * lineNumber: 10; columnNumber: 11;\n+             * JAXP00090001: The CatalogResolver is enabled with the catalog \"JdkCatalog.xml\",\n+             * but a CatalogException is returned.\n+             *\/\n+            {xmlFile, xsdOrXsl, null, PropertyState.CONFIG_FILE, Properties.CONFIG_FILE_CATALOG_STRICT, null, null, null, true, errCode},\n+\n+            \/**\n+             * Case 1-3: set CATALOG back to continue through the System Property\n+             * Expect: pass without error\n+             *\/\n+            {xmlFile, xsdOrXsl, null, PropertyState.CONFIG_FILE_SYSTEM, Properties.CONFIG_FILE_CATALOG_STRICT, new Properties[]{Properties.CATALOG0}, null, null, false, expected},\n+\n+            \/**\n+             * Case 1-4: override the settings in Case 3 with the API property, and set Catalog to strict\n+             * Expect: Exception since the external reference is not in the Catalog\n+             *\/\n+            {xmlFile, xsdOrXsl, null, PropertyState.CONFIG_FILE_SYSTEM_API, Properties.CONFIG_FILE_CATALOG_STRICT, new Properties[]{Properties.CATALOG0}, new Properties[]{Properties.CATALOG2}, null, true, errCode},\n+\n+            \/**\n+             * Case 1-5: use Custom Catalog to resolve external references\n+             * Expect: pass without error\n+             *\/\n+            {xmlFile, xsdOrXsl, null, PropertyState.CONFIG_FILE_SYSTEM_API, Properties.CONFIG_FILE_CATALOG_STRICT, new Properties[]{Properties.CATALOG0}, new Properties[]{Properties.CATALOG2}, CustomCatalog.STRICT, false, expected},\n+\n+        };\n+    }\n+\n+\/\/    @Test(dataProvider = \"configWCatalogForParsers\", priority=0)\n+    public void testDOM(String filename, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp, CustomCatalog cc,\n+        boolean expectError, String error) throws Exception {\n+\n+        DocumentBuilderFactory dbf = getDBF(fsp, state, config, sysProp, apiProp, cc);\n+        process(filename, dbf, expectError, error);\n+    }\n+\n+\/\/    @Test(dataProvider = \"configWCatalogForParsers\")\n+    public void testSAX(String filename, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp, CustomCatalog cc,\n+        boolean expectError, String error) throws Exception {\n+\n+        SAXParser parser = getSAXParser(fsp, state, config, sysProp, apiProp, cc);\n+        process(filename, parser, expectError, error);\n+    }\n+\n+\/\/    @Test(dataProvider = \"configWCatalogForParsers\")\n+    public void testStAX(String filename, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp, CustomCatalog cc,\n+        boolean expectError, String error) throws Exception {\n+\n+        XMLInputFactory xif = getXMLInputFactory(state, config, sysProp, apiProp, cc);\n+        process(filename, xif, expectError, error);\n+    }\n+\n+\/\/    @Test(dataProvider = \"validationOrTransform\")\n+    public void testSchema1(String filename, String xsd, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp, CustomCatalog cc,\n+        boolean expectError, String error) throws Exception {\n+\n+        SchemaFactory sf = getSchemaFactory(fsp, state, config, sysProp, apiProp, cc);\n+        process(filename, sf, expectError, error);\n+    }\n+\n+\/\/    @Test(dataProvider = \"validationOrTransform\")\n+    public void testSchema2(String filename, String xsd, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp, CustomCatalog cc,\n+        boolean expectError, String error) throws Exception {\n+        testSchema1(filename, xsd, fsp, state, config, sysProp, apiProp, cc, expectError, error);\n+    }\n+\n+\/\/    @Test(dataProvider = \"validationOrTransform\")\n+    public void testValidation(String filename, String xsd, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp, CustomCatalog cc,\n+        boolean expectError, String error) throws Exception {\n+\n+        SchemaFactory sf = getSchemaFactory(fsp, state, config, sysProp, apiProp, cc);\n+        validate(filename, sf, expectError, error);\n+    }\n+\n+\/\/    @Test(dataProvider = \"validationOrTransform\")\n+    public void testStylesheet(String filename, String xsl, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp, CustomCatalog cc,\n+        boolean expectError, String error) throws Exception {\n+\n+        TransformerFactory tf = getTransformerFactory(fsp, state, config, sysProp, apiProp, cc);\n+        process(filename, tf, expectError, error);\n+    }\n+\n+\/\/    @Test(dataProvider = \"validationOrTransform\")\n+    public void testTransform(String filename, String xsl, Properties fsp, PropertyState state,\n+        Properties config, Properties[] sysProp, Properties[] apiProp, CustomCatalog cc,\n+        boolean expectError, String error) throws Exception {\n+\n+        TransformerFactory tf = getTransformerFactory(fsp, state, config, sysProp, apiProp, cc);\n+        transform(filename, xsl, tf, expectError, error);\n+    }\n+\n+    \/\/ parameters in the same order as the test method\n+    String filename; String xsd; String xsl; Properties fsp; PropertyState state;\n+    Properties config; Properties[] sysProp; Properties[] apiProp; CustomCatalog cc;\n+    boolean expectError; String error;\n+\n+    \/\/ Maps the DataProvider array to individual parameters\n+    public void paramMap(Processor processor, String method, String index) {\n+        int i = 0;\n+        Object[][] params;\n+        if (processor == Processor.VALIDATOR ||\n+                processor == Processor.TRANSFORMER) {\n+            params = getConfig(method);\n+            i = 1;\n+        } else {\n+            params = getConfigs(processor);\n+        }\n+        Object[] param = params[Integer.parseInt(index)];\n+        filename = (String)param[0];\n+        if (processor == Processor.VALIDATOR) {\n+            xsd = (String)param[i];\n+        } else if (processor == Processor.TRANSFORMER) {\n+            xsl = (String)param[i];\n+        }\n+        fsp = (Properties)param[i + 1];\n+        state = (PropertyState)param[i + 2];\n+        config = (Properties)param[i + 3];\n+        sysProp = (Properties[])param[i + 4];\n+        apiProp = (Properties[])param[i + 5];\n+        cc = (CustomCatalog)param[i + 6];\n+        expectError = (boolean)param[i + 7];\n+        error = (String)param[i + 8];\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/CatalogTestBase.java","additions":361,"deletions":0,"binary":false,"changes":361,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.catalog;\n+\n+\/**\n+ * @test @bug 8306055\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run driver common.catalog.DOMTest 0 \/\/ verifies default setting catalog.resolve=allow\n+ * @run driver common.catalog.DOMTest 1 \/\/ verifies overriding with catalog.resolve=strict in a config file\n+ * @run driver common.catalog.DOMTest 2 \/\/ verifies overriding with system property\n+ * @run driver common.catalog.DOMTest 3 \/\/ verifies overriding with factory setting (catalog.resolve=strict)\n+ * @run driver common.catalog.DOMTest 4 \/\/ verifies external DTD resolution with the JDK Catalog while resolve=strict in config file\n+ * @run driver common.catalog.DOMTest 5 \/\/ verifies external DTD resolution with the JDK Catalog while resolve=strict in API setting\n+ * @run driver common.catalog.DOMTest 6 \/\/ verifies external DTD resolution with a custom Catalog while resolve=strict in config file\n+ * @run driver common.catalog.DOMTest 7 \/\/ verifies external DTD resolution with a custom Catalog while resolve=strict in API setting\n+ * @run driver common.catalog.DOMTest 8 \/\/ verifies external parameter are resolved with a custom Catalog though resolve=strict in API setting\n+ * @run driver common.catalog.DOMTest 9 \/\/ verifies XInclude are resolved with a custom Catalog though resolve=strict in API setting\n+ * @summary verifies DOM's support of the JDK Catalog.\n+ *\/\n+public class DOMTest extends CatalogTestBase {\n+    public static void main(String args[]) throws Exception {\n+        new DOMTest().run(args[0]);\n+    }\n+\n+    public void run(String index) throws Exception {\n+        paramMap(Processor.DOM, null, index);\n+        super.testDOM(filename, fsp, state, config, sysProp, apiProp, cc, expectError, error);\n+\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/DOMTest.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.catalog;\n+\n+\/**\n+ * @test @bug 8306055\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run driver common.catalog.SAXTest 0 \/\/ verifies default setting catalog.resolve=allow\n+ * @run driver common.catalog.SAXTest 1 \/\/ verifies overriding with catalog.resolve=strict in a config file\n+ * @run driver common.catalog.SAXTest 2 \/\/ verifies overriding with system property\n+ * @run driver common.catalog.SAXTest 3 \/\/ verifies overriding with factory setting (catalog.resolve=strict)\n+ * @run driver common.catalog.SAXTest 4 \/\/ verifies external DTD resolution with the JDK Catalog while resolve=strict in config file\n+ * @run driver common.catalog.SAXTest 5 \/\/ verifies external DTD resolution with the JDK Catalog while resolve=strict in API setting\n+ * @run driver common.catalog.SAXTest 6 \/\/ verifies external DTD resolution with a custom Catalog while resolve=strict in config file\n+ * @run driver common.catalog.SAXTest 7 \/\/ verifies external DTD resolution with a custom Catalog while resolve=strict in API setting\n+ * @run driver common.catalog.SAXTest 8 \/\/ verifies external parameter are resolved with a custom Catalog though resolve=strict in API setting\n+ * @run driver common.catalog.SAXTest 9 \/\/ verifies XInclude are resolved with a custom Catalog though resolve=strict in API setting\n+ * @summary verifies DOM's support of the JDK Catalog.\n+\n+ *\/\n+public class SAXTest extends CatalogTestBase {\n+    public static void main(String args[]) throws Exception {\n+        new SAXTest().run(args[0]);\n+    }\n+\n+    public void run(String index) throws Exception {\n+        paramMap(Processor.SAX, null, index);\n+        super.testSAX(filename, fsp, state, config, sysProp, apiProp, cc, expectError, error);\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/SAXTest.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.catalog;\n+\n+\/**\n+ * @test @bug 8306632\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run driver common.catalog.SchemaTest SchemaTest1 0 \/\/ verifies default setting dtd.support=allow\n+ * @run driver common.catalog.SchemaTest SchemaTest1 1 \/\/ verifies overriding with config file\n+ * @run driver common.catalog.SchemaTest SchemaTest1 2 \/\/ verifies overriding with system property\n+ * @run driver common.catalog.SchemaTest SchemaTest1 3 \/\/ verifies overriding with factory setting (DTD=deny)\n+ * @run driver common.catalog.SchemaTest SchemaTest1 4 \/\/ verifies DTD=ignore\n+ * @run driver common.catalog.SchemaTest SchemaTest2 0 \/\/ verifies default setting dtd.support=allow\n+ * @run driver common.catalog.SchemaTest SchemaTest2 1 \/\/ verifies overriding with config file\n+ * @run driver common.catalog.SchemaTest SchemaTest2 2 \/\/ verifies overriding with system property\n+ * @run driver common.catalog.SchemaTest SchemaTest2 3 \/\/ verifies overriding with factory setting (DTD=deny)\n+ * @run driver common.catalog.SchemaTest SchemaTest2 4 \/\/ verifies DTD=ignore\n+ * @run driver common.catalog.SchemaTest Validation 0 \/\/ verifies default setting dtd.support=allow\n+ * @run driver common.catalog.SchemaTest Validation 1 \/\/ verifies overriding with config file\n+ * @run driver common.catalog.SchemaTest Validation 2 \/\/ verifies overriding with system property\n+ * @run driver common.catalog.SchemaTest Validation 3 \/\/ verifies overriding with factory setting (DTD=deny)\n+ * @run driver common.catalog.SchemaTest Validation 4 \/\/ verifies DTD=ignore\n+ * @summary verifies Schema and Validation's support of the property jdk.xml.dtd.support.\n+ *\/\n+public class SchemaTest extends CatalogTestBase {\n+\n+    public static void main(String args[]) throws Exception {\n+        new SchemaTest().run(args[0], args[1]);\n+    }\n+\n+    public void run(String method, String index) throws Exception {\n+        paramMap(Processor.VALIDATOR, method, index);\n+        switch (method) {\n+            case \"SchemaTest1\":\n+                super.testSchema1(filename, xsd, fsp, state, config, sysProp, apiProp, cc, expectError, error);\n+                break;\n+            case \"SchemaTest2\":\n+                super.testSchema2(filename, xsd, fsp, state, config, sysProp, apiProp, cc, expectError, error);\n+                break;\n+            case \"Validation\":\n+                super.testValidation(filename, xsd, fsp, state, config, sysProp, apiProp, cc, expectError, error);\n+                break;\n+        }\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/SchemaTest.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.catalog;\n+\n+\/**\n+ * @test @bug 8306055\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run driver common.catalog.StAXTest 0 \/\/ verifies default setting catalog.resolve=allow\n+ * @run driver common.catalog.StAXTest 1 \/\/ verifies overriding with catalog.resolve=strict in a config file\n+ * @run driver common.catalog.StAXTest 2 \/\/ verifies overriding with system property\n+ * @run driver common.catalog.StAXTest 3 \/\/ verifies overriding with factory setting (catalog.resolve=strict)\n+ * @run driver common.catalog.StAXTest 4 \/\/ verifies external DTD resolution with the JDK Catalog while resolve=strict in config file\n+ * @run driver common.catalog.StAXTest 5 \/\/ verifies external DTD resolution with the JDK Catalog while resolve=strict in API setting\n+ * @run driver common.catalog.StAXTest 6 \/\/ verifies external DTD resolution with a custom Catalog while resolve=strict in config file\n+ * @run driver common.catalog.StAXTest 7 \/\/ verifies external DTD resolution with a custom Catalog while resolve=strict in API setting\n+ * @run driver common.catalog.StAXTest 8 \/\/ verifies external parameter are resolved with a custom Catalog though resolve=strict in API setting\n+ * @run driver common.catalog.StAXTest 9 \/\/ verifies XInclude are resolved with a custom Catalog though resolve=strict in API setting\n+ * @summary verifies DOM's support of the JDK Catalog.\n+ *\/\n+public class StAXTest extends CatalogTestBase {\n+    public static void main(String args[]) throws Exception {\n+        new StAXTest().run(args[0]);\n+    }\n+\n+    public void run(String index) throws Exception {\n+        paramMap(Processor.STAX, null, index);\n+        super.testStAX(filename, fsp, state, config, sysProp, apiProp, cc, expectError, error);\n+\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/StAXTest.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package common.catalog;\n+\n+\/**\n+ * @test @bug 8306632\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @modules java.xml\/jdk.xml.internal\n+ * @run driver common.catalog.TransformTest Stylesheet 0 \/\/ verifies default setting dtd.support=allow\n+ * @run driver common.catalog.TransformTest Stylesheet 1 \/\/ verifies overriding with config file\n+ * @run driver common.catalog.TransformTest Stylesheet 2 \/\/ verifies overriding with system property\n+ * @run driver common.catalog.TransformTest Stylesheet 3 \/\/ verifies overriding with factory setting (DTD=deny)\n+ * @run driver common.catalog.TransformTest Stylesheet 4 \/\/ verifies DTD=ignore\n+ * @run driver common.catalog.TransformTest Transform 0 \/\/ verifies default setting dtd.support=allow\n+ * @run driver common.catalog.TransformTest Transform 1 \/\/ verifies overriding with config file\n+ * @run driver common.catalog.TransformTest Transform 2 \/\/ verifies overriding with system property\n+ * @run driver common.catalog.TransformTest Transform 3 \/\/ verifies overriding with factory setting (DTD=deny)\n+ * @run driver common.catalog.TransformTest Transform 4 \/\/ verifies DTD=ignore\n+ * @summary verifies Transform's support of the property jdk.xml.dtd.support.\n+ *\/\n+public class TransformTest extends CatalogTestBase {\n+\n+    public static void main(String args[]) throws Exception {\n+        new TransformTest().run(args[0], args[1]);\n+    }\n+\n+    public void run(String method, String index) throws Exception {\n+        paramMap(Processor.TRANSFORMER, method, index);\n+        switch (method) {\n+            case \"Stylesheet\":\n+                super.testStylesheet(filename, xsl, fsp, state, config, sysProp, apiProp, cc, expectError, error);\n+                break;\n+            case \"Transform\":\n+                super.testTransform(filename, xsl, fsp, state, config, sysProp, apiProp, cc, expectError, error);\n+                break;\n+        }\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/TransformTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<catalog xmlns=\"urn:oasis:names:tc:entity:xmlns:xml:catalog\">\n+    <!-- Catalog for testing the CATALOG property\n+    -->\n+\n+    <group id=\"dtds\" prefer = \"system\" xml:base = \"dtds\/\">\n+        <systemSuffix systemIdSuffix=\"test.dtd\" uri=\"test.dtd\"\/>\n+        <system systemId=\"file:\/externalParameterEntity\" uri=\"paramEntity.dtd\"\/>\n+        <system systemId=\"XSLDTD.dtd\" uri=\"XSLDTD.dtd\"\/>\n+        \n+    <\/group>\n+\n+    <group id=\"xsds\" prefer = \"system\" xml:base = \"xsds\/\">\n+        <system systemId=\"XSDImport_person.xsd\" uri=\"XSDImport_person.xsd\"\/>\n+        <system systemId=\"XSDImport_product.xsd\" uri=\"XSDImport_product.xsd\"\/>\n+        <system systemId=\"XSDInclude_person.xsd\" uri=\"XSDInclude_person.xsd\"\/>\n+        <system systemId=\"XSDInclude_product.xsd\" uri=\"XSDInclude_product.xsd\"\/>\n+        <!-- file:\/path\/val_test.xsd -->\n+        <systemSuffix systemIdSuffix=\"val_test.xsd\" uri=\"val_test.xsd\"\/>\n+    <\/group>\n+\n+    <group id=\"xi\" prefer = \"system\" xml:base = \"xinclude\/\">\n+\n+        <system systemId=\"XI_red.dtd\" uri=\"XI_red.dtd\"\/>\n+        <system systemId=\"XI_simple.xml\" uri=\"XI_simple.xml\"\/>\n+        <system systemId=\"XI_test2.xml\" uri=\"XI_test2.xml\"\/>\n+        <system systemId=\"XI_utf8.xml\" uri=\"XI_utf8.xml\"\/>\n+    <\/group>\n+    <!-- additional catalogs can be added a NextCatalog besides registering\n+         through the Feature.FILES (javax.xml.catalog.files) property -->\n+    <!-- nextCatalog catalog=\"pathto\/AnotherCatalog.xml\"\/-->\n+<\/catalog>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/testcatalog\/TestCatalog.xml","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/testcatalog\/dtds\/XSLDTD.dtd","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XSLDTD.dtd","status":"copied"},{"patch":"@@ -0,0 +1,2 @@\n+<!ENTITY  quantity \"2\">\r\n+<!ENTITY  unitPrice \"24.99\">\r\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/testcatalog\/dtds\/paramEntity.dtd","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/testcatalog\/dtds\/test.dtd","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/test.dtd","status":"copied"},{"patch":"","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/testcatalog\/xinclude\/XI_red.dtd","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/catalog\/XI_red.dtd","status":"copied"},{"patch":"","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/testcatalog\/xinclude\/XI_simple.xml","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/catalog\/XI_simple.xml","status":"copied"},{"patch":"@@ -0,0 +1,10 @@\n+<?xml version=\"1.1\"?>\n+<!-- comment before root -->\n+<!DOCTYPE red SYSTEM \"XI_red.dtd\">\n+<red xmlns:xinclude=\"http:\/\/www.w3.org\/2001\/XInclude\">\n+  <blue>\n+    <xinclude:include href=\"XI_utf8.xml\" parse=\"text\"\/>\n+  <\/blue>\n+<\/red>\n+<!-- comment after root -->\n+\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/testcatalog\/xinclude\/XI_test2.xml","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+<red>\n+    value1 trjsagdkasgdhasdgashgdhsadgashdg\n+<\/red>\n+\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/testcatalog\/xinclude\/XI_utf8.xml","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/testcatalog\/xsds\/XSDImport_person.xsd","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XSDImport_person.xsd","status":"copied"},{"patch":"","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/testcatalog\/xsds\/XSDImport_product.xsd","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XSDImport_product.xsd","status":"copied"},{"patch":"","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/testcatalog\/xsds\/XSDInclude_person.xsd","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/catalog\/XSDInclude_person.xsd","status":"copied"},{"patch":"","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/testcatalog\/xsds\/XSDInclude_product.xsd","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/catalog\/XSDInclude_product.xsd","status":"copied"},{"patch":"","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/catalog\/testcatalog\/xsds\/val_test.xsd","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/val_test.xsd","status":"copied"},{"patch":"@@ -0,0 +1,36 @@\n+################################################################################\n+#       XML Library (java.xml) Configuration File\n+#\n+# This file is in java.util.Properties format and typically located in the conf \n+# directory of the Java installation. It may contain key\/value pairs for specifying\n+# the implementation class of a factory and\/or properties that have corresponding\n+# system properties. \n+#\n+# This file can be replaced by specifying a filename with the java.xml.config.file \n+# system property. For example java -Djava.xml.config.file=myfile \n+################################################################################\n+\n+# ---- Config File: for testing the CATALOG property ----\n+#\n+# strict: report error if not resolved by the JDK Catalog\n+jdk.xml.jdkcatalog.resolve=strict\n+# Enable Extension Functions\n+jdk.xml.enableExtensionFunctions=true\n+# Disallow overriding the default parser\n+jdk.xml.overrideDefaultParser=false\n+#\n+# Implementation specific limits:\n+#\n+jdk.xml.entityExpansionLimit=64000\n+jdk.xml.elementAttributeLimit=10000\n+jdk.xml.maxOccurLimit=5000\n+jdk.xml.totalEntitySizeLimit=100000\n+jdk.xml.maxGeneralEntitySizeLimit=0\n+jdk.xml.maxParameterEntitySizeLimit=1000000\n+jdk.xml.entityReplacementLimit=300000\n+jdk.xml.maxElementDepth=0\n+jdk.xml.maxXMLNameLimit=1000\n+jdk.xml.xpathExprGrpLimit=10\n+jdk.xml.xpathExprOpLimit=100\n+jdk.xml.xpathTotalOpLimit=10000\n+\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/files\/catalog2.properties","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -50,3 +50,3 @@\n-# For example, the FILES property in CatalogFeatures has an associated system\n-# property called javax.xml.catalog.files. An entry for the FILES property in the\n-# configuration file would therefore use javax.xml.catalog.files as the key, that\n+# For example, the RESOLVE property in CatalogFeatures has an associated system\n+# property called javax.xml.catalog.resolve. An entry for the RESOLVE property in the\n+# configuration file would therefore use javax.xml.catalog.resolve as the key, that\n@@ -54,1 +54,1 @@\n-#     javax.xml.catalog.files=strict\n+#     javax.xml.catalog.resolve=strict\n@@ -131,0 +131,18 @@\n+# Implementation Specific Properties - jdkcatalog.resolve\n+#\n+# This property instructs the JDK default CatalogResolver to act in accordance with\n+# the setting when unable to resolve an external reference with the built-in Catalog.\n+# The options are:\n+#     continue -- indicates that the processing should continue\n+#     ignore -- indicates that the reference is skipped\n+#     strict -- indicates that the resolver should throw a CatalogException\n+#\n+# The following setting would cause the resolve to throw a CatalogException when\n+# unable to resolve an external reference:\n+# jdk.xml.jdkcatalog.resolve=strict\n+#\n+# Implementation Specific Properties - DTD\n+#\n+# This property instructs the parsers to: deny, ignore or allow DTD processing.\n+# The following setting would cause the parser to reject DTD by throwing an exception.\n+# jdk.xml.dtd.support=deny\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/config\/files\/jaxp.properties","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -20,9 +20,0 @@\n-    static final String SRC_DIR;\n-    static {\n-        String srcDir = System.getProperty(\"test.src\", \".\");\n-        if (IS_WINDOWS) {\n-            srcDir = srcDir.replace('\\\\', '\/');\n-        }\n-        SRC_DIR = srcDir;\n-        TEST_SOURCE_DIR = srcDir + \"\/..\/xmlfiles\/\";\n-    }\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/dtd\/DTDTestBase.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-    public static String SRC_DIR = System.getProperty(\"test.src\", \".\");\n-    public static String TEST_SOURCE_DIR;\n+    public static String SRC_DIR;\n+    public static String TEST_SOURCE_DIR, CONFIG_FILE_PATH, CATALOG_PATH;\n@@ -73,0 +73,14 @@\n+    static {\n+        String srcDir = System.getProperty(\"test.src\", \".\");\n+        if (IS_WINDOWS) {\n+            srcDir = srcDir.replace('\\\\', '\/');\n+        }\n+        SRC_DIR = srcDir;\n+        if (IS_WINDOWS) {\n+            CATALOG_PATH = \"file:\/\/\/\" + SRC_DIR + \"\/..\/catalog\/testcatalog\/TestCatalog.xml\";\n+        } else {\n+            CATALOG_PATH = \"file:\/\/\" + SRC_DIR + \"\/..\/catalog\/testcatalog\/TestCatalog.xml\";\n+        }\n+        TEST_SOURCE_DIR = srcDir + \"\/..\/xmlfiles\/\";\n+        CONFIG_FILE_PATH = SRC_DIR + \"\/..\/config\/files\/\";\n+    }\n@@ -77,0 +91,4 @@\n+    \/\/ CATALOG Abbreviation: C\n+    static final String C_FILE = CatalogFeatures.Feature.FILES.getPropertyName();\n+    static final String C_RESOLVE = CatalogFeatures.Feature.RESOLVE.getPropertyName();\n+\n@@ -87,0 +105,1 @@\n+    public static final String SP_CATALOG = \"jdk.xml.jdkcatalog.resolve\";\n@@ -100,1 +119,4 @@\n-    public static final String JCF_DTD2 = \"..\/config\/files\/dtd2.properties\";\n+    public static final String JCF_DTD2 = \"dtd2.properties\";\n+\n+    \/\/ CATALOG=strict\n+    public static final String CONFIG_CATALOG_STRICT = \"catalog2.properties\";\n@@ -102,0 +124,1 @@\n+    public static final String UNKNOWN_HOST = \"invalid.site.com\";\n@@ -110,1 +133,3 @@\n-        CONFIG_FILE_DTD2(null, CONFIG_FILE, Type.FEATURE, getPath(JCF_DTD2)),\n+        \/\/ config file: CATALOG = strict\n+        CONFIG_FILE_CATALOG_STRICT(null, CONFIG_FILE, Type.FEATURE, getPath(CONFIG_FILE_PATH, CONFIG_CATALOG_STRICT)),\n+        CONFIG_FILE_DTD2(null, CONFIG_FILE, Type.FEATURE, getPath(CONFIG_FILE_PATH, JCF_DTD2)),\n@@ -118,0 +143,3 @@\n+        CATALOG0(SP_CATALOG, \"ditto\", Type.PROPERTY, RESOLVE_CONTINUE),\n+        CATALOG1(SP_CATALOG, \"ditto\", Type.PROPERTY, RESOLVE_IGNORE),\n+        CATALOG2(SP_CATALOG, \"ditto\", Type.PROPERTY, RESOLVE_STRICT),\n@@ -184,0 +212,23 @@\n+    public static enum CustomCatalog {\n+        \/\/ continue processing if no match found\n+        CONTINUE(CATALOG_PATH, \"continue\"),\n+        \/\/ skip if no match found\n+        IGNORE(CATALOG_PATH, \"ignore\"),\n+        \/\/ throws CatalogException if no match found\n+        STRICT(CATALOG_PATH, \"strict\");\n+\n+        String file, resolve;\n+        CustomCatalog(String file, String resolve) {\n+            this.file = file;\n+            this.resolve = resolve;\n+        }\n+\n+        public String file() {\n+            return file;\n+        }\n+\n+        public String resolve() {\n+            return resolve;\n+        }\n+    }\n+\n@@ -188,1 +239,1 @@\n-        File file = new File(getPath(filename));\n+        File file = new File(getPath(TEST_SOURCE_DIR, filename));\n@@ -201,1 +252,1 @@\n-        File file = new File(getPath(filename));\n+        File file = new File(getPath(TEST_SOURCE_DIR, filename));\n@@ -214,1 +265,1 @@\n-        String xml = getPath(filename);\n+        String xml = getPath(TEST_SOURCE_DIR, filename);\n@@ -231,1 +282,1 @@\n-        String xsd = getPath(filename);\n+        String xsd = getPath(TEST_SOURCE_DIR, filename);\n@@ -243,1 +294,1 @@\n-        String xsl = getPath(filename);\n+        String xsl = getPath(TEST_SOURCE_DIR, filename);\n@@ -257,1 +308,1 @@\n-        String xmlSysId = getPath(xmlFile);\n+        String xmlSysId = getPath(TEST_SOURCE_DIR, xmlFile);\n@@ -267,1 +318,0 @@\n-            e.printStackTrace();\n@@ -274,1 +324,1 @@\n-        String xml = getPath(filename);\n+        String xml = getPath(TEST_SOURCE_DIR, filename);\n@@ -288,1 +338,0 @@\n-        \/\/e.printStackTrace();\n@@ -290,2 +339,0 @@\n-\/\/        System.out.println(\"Exp Msg: \" + str);\n-        \/\/e.printStackTrace();\n@@ -293,2 +340,1 @@\n-            Assert.assertTrue(false, \"Expected pass, but Exception is thrown \" +\n-                    str);\n+            Assert.assertTrue(false, \"Expected pass, but Exception is thrown \" + str);\n@@ -296,1 +342,7 @@\n-            Assert.assertTrue((str != null) && str.contains(error));\n+            \/\/ This check is necessary since errors other than UnknownHostException\n+            \/\/ can contain the host name in the System ID\n+            if (UNKNOWN_HOST.equals(error)) {\n+                Assert.assertTrue((str != null) && str.equals(error));\n+            } else {\n+                Assert.assertTrue((str != null) && str.contains(error));\n+            }\n@@ -312,0 +364,5 @@\n+        return getDBF(fsp, state, config, sysProp, apiProp, null);\n+    }\n+\n+    protected DocumentBuilderFactory getDBF(Properties fsp, PropertyState state,\n+            Properties config, Properties[] sysProp, Properties[] apiProp, CustomCatalog cc) {\n@@ -338,0 +395,4 @@\n+        if (cc != null) {\n+            dbf.setAttribute(C_FILE, cc.file());\n+            dbf.setAttribute(C_RESOLVE, cc.resolve());\n+        }\n@@ -358,0 +419,5 @@\n+        return getSAXParser(fsp, state, config, sysProp, apiProp, null);\n+    }\n+\n+    public SAXParser getSAXParser(Properties fsp, PropertyState state, Properties config,\n+            Properties[] sysProp, Properties[] apiProp, CustomCatalog cc) throws Exception {\n@@ -390,0 +456,5 @@\n+        if (cc != null) {\n+            parser.setProperty(C_FILE, cc.file());\n+            parser.setProperty(C_RESOLVE, cc.resolve());\n+        }\n+\n@@ -396,0 +467,5 @@\n+        return getXMLInputFactory(state, config, sysProp, apiProp, null);\n+    }\n+\n+    protected XMLInputFactory getXMLInputFactory(PropertyState state,\n+            Properties config, Properties[] sysProp, Properties[] apiProp, CustomCatalog cc) {\n@@ -405,0 +481,5 @@\n+        if (cc != null) {\n+            factory.setProperty(C_FILE, cc.file());\n+            factory.setProperty(C_RESOLVE, cc.resolve());\n+        }\n+\n@@ -413,0 +494,6 @@\n+        return getSchemaFactory(fsp, state, config, sysProp, apiProp, null);\n+    }\n+\n+    protected SchemaFactory getSchemaFactory(Properties fsp, PropertyState state,\n+            Properties config, Properties[] sysProp, Properties[] apiProp, CustomCatalog cc)\n+            throws Exception {\n@@ -430,0 +517,5 @@\n+        if (cc != null) {\n+            factory.setProperty(C_FILE, cc.file());\n+            factory.setProperty(C_RESOLVE, cc.resolve());\n+        }\n+\n@@ -438,0 +530,6 @@\n+        return getTransformerFactory(fsp, state, config, sysProp, apiProp, null);\n+    }\n+\n+    protected TransformerFactory getTransformerFactory(Properties fsp, PropertyState state,\n+            Properties config, Properties[] sysProp, Properties[] apiProp, CustomCatalog cc)\n+            throws Exception {\n@@ -453,0 +551,4 @@\n+        if (cc != null) {\n+            tf.setAttribute(C_FILE, cc.file());\n+            tf.setAttribute(C_RESOLVE, cc.resolve());\n+        }\n@@ -608,2 +710,2 @@\n-    static String getPath(String file) {\n-        String temp = TEST_SOURCE_DIR + file;\n+    static String getPath(String base, String file) {\n+        String temp = base + file;\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/util\/TestBase.java","additions":122,"deletions":20,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -0,0 +1,6 @@\n+<?xml version=\"1.1\"?>\n+<!-- comment before root 1 -->\n+<xinclude:include xmlns:xinclude=\"http:\/\/www.w3.org\/2001\/XInclude\"\n+  href=\"XI_simple.xml\"\/>\n+<!-- comment after root 1 -->\n+\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/XI_roottest.xml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+<!DOCTYPE top SYSTEM 'test.dtd'\r\n+[\r\n+<!ENTITY % pe0 \"x\">\r\n+        <!ENTITY   x1 \"A\">\r\n+        ]>\r\n+<top>123&x1;<\/top>\r\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/test.xml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+<?xml version='1.0' encoding ='utf-8'?>\n+<!DOCTYPE SupplierOrder [\n+<!ENTITY % paraEntity SYSTEM \"file:\/externalParameterEntity\">\n+%paraEntity;\n+]>\n+<SupplierOrder>\n+    value value1\n+    <OrderId>10016<\/OrderId>\n+    <LineItems>\n+        <LineItem categoryId=\"BIRDS\" itemId=\"EST-18\" lineNo=\"0\" productId=\"AV-CB-01\" quantity=\"&quantity;\" unitPrice=\"&unitPrice;\"\/>\n+    <\/LineItems>\n+<\/SupplierOrder>\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/common\/xmlfiles\/testExternalParameter.xml","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -490,1 +490,1 @@\n-java\/lang\/invoke\/lambda\/LambdaFileEncodingSerialization.java    8249079 linux-x64\n+java\/lang\/invoke\/lambda\/LambdaFileEncodingSerialization.java    8249079 linux-all\n@@ -573,0 +573,1 @@\n+java\/nio\/file\/Files\/probeContentType\/Basic.java                 8320943 windows-all\n@@ -625,6 +626,0 @@\n-sun\/security\/tools\/keytool\/NssTest.java                         8295343 generic-all\n-sun\/security\/pkcs11\/Signature\/TestRSAKeyLength.java             8295343 generic-all\n-sun\/security\/pkcs11\/rsa\/TestSignatures.java                     8295343 generic-all\n-sun\/security\/pkcs11\/rsa\/TestKeyPairGenerator.java               8295343 generic-all\n-sun\/security\/pkcs11\/rsa\/TestKeyFactory.java                     8295343 generic-all\n-sun\/security\/pkcs11\/KeyStore\/Basic.java                         8295343 generic-all\n@@ -669,0 +664,1 @@\n+javax\/swing\/JFileChooser\/8194044\/FileSystemRootTest.java 8320944 windows-all\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+    -:jdk_vector_sanity \\\n@@ -80,3 +81,3 @@\n-   -:jdk_svc_sanity \\\n-   -:jdk_vector_sanity \\\n-   -:svc_tools\n+    -:jdk_svc_sanity \\\n+    -:svc_tools \\\n+    :jdk_jpackage\n@@ -287,1 +288,1 @@\n-# Tool (and tool API) tests are split into core and svc groups\n+# Tool (and tool API) tests are mostly split into core and svc groups\n@@ -291,0 +292,1 @@\n+    -tools\/jpackage \\\n@@ -302,1 +304,2 @@\n-    :svc_tools\n+    :svc_tools \\\n+    :jdk_jpackage\n@@ -307,0 +310,3 @@\n+jdk_jpackage = \\\n+    tools\/jpackage\n+\n@@ -582,1 +588,3 @@\n-    :jdk_core_manual_no_input_security\n+    :jdk_security_manual_no_input \\\n+    :jdk_core_manual_interactive \\\n+    :jdk_security_manual_interactive\n@@ -601,1 +609,1 @@\n-jdk_core_manual_no_input_security = \\\n+jdk_security_manual_no_input = \\\n@@ -628,1 +636,0 @@\n-    sun\/security\/tools\/keytool\/i18n.java \\\n@@ -631,1 +638,4 @@\n-    java\/rmi\/registry\/nonLocalRegistry\/NonLocalSkeletonTest.java \\\n+    java\/rmi\/registry\/nonLocalRegistry\/NonLocalSkeletonTest.java\n+\n+jdk_security_manual_interactive = \\\n+    sun\/security\/tools\/keytool\/i18n.java \\\n@@ -635,1 +645,0 @@\n-\n","filename":"test\/jdk\/TEST.groups","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -51,0 +52,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -101,1 +103,1 @@\n-            outer: while (segment.scope().isAlive()) {\n+            while (segment.scope().isAlive()) {\n@@ -105,6 +107,9 @@\n-                    long delay = System.currentTimeMillis() - start.get();\n-                    System.out.println(\"Accessor #\" + id + \" suspending - elapsed (ms): \" + delay);\n-                    backoff();\n-                    delay = System.currentTimeMillis() - start.get();\n-                    System.out.println(\"Accessor #\" + id + \" resuming - elapsed (ms): \" + delay);\n-                    continue outer;\n+                    if (!failed.get()) {\n+                        \/\/ ignore - this means segment was alive, but was closed while we were accessing it\n+                        \/\/ next isAlive test should fail\n+                        assertFalse(segment.scope().isAlive());\n+                        failed.set(true);\n+                    } else {\n+                        \/\/ rethrow!\n+                        throw ex;\n+                    }\n@@ -177,0 +182,24 @@\n+    static class SegmentSwappyCopyAccessor extends AbstractSegmentAccessor {\n+\n+        MemorySegment first, second;\n+        ValueLayout sourceLayout, destLayout;\n+        long count;\n+\n+\n+        SegmentSwappyCopyAccessor(int id, MemorySegment segment, Arena _unused) {\n+            super(id, segment);\n+            long split = segment.byteSize() \/ 2;\n+            first = segment.asSlice(0, split);\n+            sourceLayout = JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN);\n+            second = segment.asSlice(split);\n+            destLayout = JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN);\n+            count = Math.min(first.byteSize() \/ sourceLayout.byteSize(),\n+                second.byteSize() \/ destLayout.byteSize());\n+        }\n+\n+        @Override\n+        public void doAccess() {\n+            MemorySegment.copy(first, sourceLayout, 0L, second, destLayout, 0L, count);\n+        }\n+    }\n+\n@@ -249,8 +278,1 @@\n-            while (true) {\n-                try {\n-                    arena.close();\n-                    break;\n-                } catch (IllegalStateException ex) {\n-                    Thread.onSpinWait();\n-                }\n-            }\n+            arena.close(); \/\/ This should NOT throw\n@@ -271,0 +293,1 @@\n+                { \"SegmentSwappyCopyAccessor\", (AccessorFactory)SegmentSwappyCopyAccessor::new },\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":38,"deletions":15,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#ifdef _AIX\n+#pragma align (natural)\n+#endif\n@@ -95,0 +98,4 @@\n+\n+#ifdef _AIX\n+#pragma align (reset)\n+#endif\n","filename":"test\/jdk\/java\/foreign\/nested\/libNested.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+#ifdef _AIX\n+#pragma align (natural)\n+#endif\n@@ -123,0 +126,4 @@\n+\n+#ifdef _AIX\n+#pragma align (reset)\n+#endif\n","filename":"test\/jdk\/java\/foreign\/shared.h","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -31,0 +33,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -33,0 +36,1 @@\n+import jdk.internal.classfile.Classfile;\n@@ -45,0 +49,1 @@\n+ * @modules java.base\/jdk.internal.classfile\n@@ -116,3 +121,6 @@\n-        testType(\"\", 0, 0, String.class, String.class, String.class);\n-        testType(\"\", 1, 1, String.class, String.class, String.class);\n-        testType(\"\", 2, 2, String.class, String.class, String.class);\n+        testType(\"\", 0, 0, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 1, 1, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 2, 2, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 3, 3, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 3, 3, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 4, 4, String.class, String.class, String.class, String.class, String.class);\n@@ -349,0 +357,28 @@\n+    public void testHiddenClassAsCaseLabel() throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        byte[] classBytes = createClass();\n+        Class<?> classA = lookup.defineHiddenClass(classBytes, false).lookupClass();\n+        Class<?> classB = lookup.defineHiddenClass(classBytes, false).lookupClass();\n+        Object[] labels = new Object[] {\n+            classA,\n+            classB,\n+        };\n+        testType(classA.getConstructor().newInstance(), 0, 0, labels);\n+        testType(classB.getConstructor().newInstance(), 0, 1, labels);\n+    }\n+\n+    private static byte[] createClass() {\n+        return Classfile.of().build(ClassDesc.of(\"C\"), clb -> {\n+            clb.withFlags(AccessFlag.SYNTHETIC)\n+               .withMethodBody(\"<init>\",\n+                               MethodTypeDesc.of(ConstantDescs.CD_void),\n+                               Classfile.ACC_PUBLIC,\n+                               cb -> {\n+                                   cb.aload(0);\n+                                   cb.invokespecial(ConstantDescs.CD_Object,\n+                                                    \"<init>\",\n+                                                    MethodTypeDesc.of(ConstantDescs.CD_void));\n+                                   cb.return_();\n+                               });\n+                    });\n+    }\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":39,"deletions":3,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304701\n+ * @summary Verifies that for a redirected request, the given HttpClient\n+ *          will clear and start a new response timer instead of throwing\n+ *          an HttpTimeoutException during the redirected request.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ * @run testng\/othervm -Djdk.httpclient.HttpClient.log=errors,trace -Djdk.internal.httpclient.debug=false RedirectTimeoutTest\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestResponseHeaders;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import org.testng.TestException;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+\n+import static java.net.http.HttpClient.Redirect.ALWAYS;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static jdk.test.lib.Utils.adjustTimeout;\n+\n+public class RedirectTimeoutTest {\n+\n+    static HttpTestServer h1TestServer, h2TestServer;\n+    static URI h1Uri, h1RedirectUri, h2Uri, h2RedirectUri, h2WarmupUri, testRedirectURI;\n+    private static final long TIMEOUT_MILLIS =  3000L; \/\/ 3s\n+    private static final long SLEEP_TIME = 1500L; \/\/ 1.5s\n+    public static final int ITERATIONS = 4;\n+    private static final PrintStream out = System.out;\n+\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        h1TestServer = HttpTestServer.create(HTTP_1_1);\n+        h2TestServer = HttpTestServer.create(HTTP_2);\n+        h1Uri = URI.create(\"http:\/\/\" + h1TestServer.serverAuthority() + \"\/h1_test\");\n+        h1RedirectUri = URI.create(\"http:\/\/\" + h1TestServer.serverAuthority() + \"\/h1_redirect\");\n+        h2Uri = URI.create(\"http:\/\/\" + h2TestServer.serverAuthority() + \"\/h2_test\");\n+        h2RedirectUri = URI.create(\"http:\/\/\" + h2TestServer.serverAuthority() + \"\/h2_redirect\");\n+        h2WarmupUri = URI.create(\"http:\/\/\" + h2TestServer.serverAuthority() + \"\/h2_warmup\");\n+        h1TestServer.addHandler(new GetHandler(), \"\/h1_test\");\n+        h1TestServer.addHandler(new RedirectHandler(), \"\/h1_redirect\");\n+        h2TestServer.addHandler(new GetHandler(), \"\/h2_test\");\n+        h2TestServer.addHandler(new RedirectHandler(), \"\/h2_redirect\");\n+        h2TestServer.addHandler(new Http2Warmup(), \"\/h2_warmup\");\n+        h1TestServer.start();\n+        h2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() {\n+        h1TestServer.stop();\n+        h2TestServer.stop();\n+    }\n+\n+    @DataProvider(name = \"testData\")\n+    public Object[][] testData() {\n+        return new Object[][] {\n+                { HTTP_1_1, h1Uri, h1RedirectUri },\n+                { HTTP_2, h2Uri, h2RedirectUri }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testData\")\n+    public void test(Version version, URI uri, URI redirectURI) throws InterruptedException {\n+        out.println(\"Testing for \" + version);\n+        testRedirectURI = redirectURI;\n+        HttpClient.Builder clientBuilder = HttpClient.newBuilder().followRedirects(ALWAYS);\n+        HttpRequest request = HttpRequest.newBuilder().uri(uri)\n+                .GET()\n+                .version(version)\n+                .timeout(Duration.ofMillis(adjustTimeout(TIMEOUT_MILLIS)))\n+                .build();\n+\n+        try (HttpClient client = clientBuilder.build()) {\n+            if (version.equals(HTTP_2))\n+                client.send(HttpRequest.newBuilder(h2WarmupUri).HEAD().build(), HttpResponse.BodyHandlers.discarding());\n+            \/*\n+                With TIMEOUT_MILLIS set to 1500ms and the server's RedirectHandler sleeping for 750ms before responding\n+                to each request, 4 iterations will take a guaranteed minimum time of 3000ms which will ensure that any\n+                uncancelled\/uncleared timers will fire within the test window.\n+             *\/\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                out.println(Instant.now() + \": Client: Sending request #\" + (i + 1));\n+                client.send(request, HttpResponse.BodyHandlers.ofString());\n+                out.println(\"Request complete\");\n+            }\n+        } catch (IOException e) {\n+            if (e.getClass() == HttpTimeoutException.class) {\n+                e.printStackTrace(System.out);\n+                throw new TestException(\"Timeout from original HttpRequest expired on redirect when it should have been cancelled.\");\n+            } else {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    public static class Http2Warmup implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            t.sendResponseHeaders(200, 0);\n+        }\n+    }\n+\n+    public static class GetHandler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(HttpTestExchange exchange) throws IOException {\n+            out.println(Instant.now() + \": Server: Get Handler Called\");\n+            HttpTestResponseHeaders responseHeaders = exchange.getResponseHeaders();\n+            responseHeaders.addHeader(\"Location\", testRedirectURI.toString());\n+            exchange.sendResponseHeaders(302, 0);\n+        }\n+    }\n+\n+    public static class RedirectHandler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(HttpTestExchange exchange) throws IOException {\n+            out.println(Instant.now() + \": Server: Redirect Handler Called\");\n+            byte[] data = \"Test\".getBytes(StandardCharsets.UTF_8);\n+            try {\n+                Thread.sleep(adjustTimeout(SLEEP_TIME));\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+            exchange.sendResponseHeaders(200, data.length);\n+            try (OutputStream os = exchange.getResponseBody()) {\n+                os.write(data);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/net\/httpclient\/RedirectTimeoutTest.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,7 @@\n-import static java.util.Calendar.*;\n+import java.util.stream.Stream;\n+\n+import static java.util.Calendar.DAY_OF_YEAR;\n+import static java.util.Calendar.ERA;\n+import static java.util.Calendar.FEBRUARY;\n+import static java.util.Calendar.LONG;\n+import static java.util.Calendar.YEAR;\n@@ -40,1 +46,0 @@\n-import jdk.test.lib.JDKToolLauncher;\n@@ -94,13 +99,12 @@\n-            throws Throwable{\n-        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"java\");\n-        launcher.addToolArg(\"-ea\")\n-                .addToolArg(\"-esa\")\n-                .addToolArg(\"-cp\")\n-                .addToolArg(Utils.TEST_CLASS_PATH)\n-                .addToolArg(\"-Djdk.calendar.japanese.supplemental.era=\" + property)\n-                .addToolArg(\"SupplementalJapaneseEraTest\");\n-        for (String para: javaParam) {\n-            launcher.addToolArg(para);\n-        }\n-        int exitCode = ProcessTools.executeCommand(launcher.getCommand())\n-                .getExitValue();\n+            throws Throwable {\n+        List<String> params = List.of(\n+                \"-ea\", \"-esa\",\n+                \"-cp\", Utils.TEST_CLASS_PATH,\n+                \"-Djdk.calendar.japanese.supplemental.era=\" + property,\n+                \"SupplementalJapaneseEraTest\");\n+        \/\/ Build process (with VM flags)\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Stream.concat(params.stream(), javaParam.stream()).toList());\n+        \/\/ Evaluate process status\n+        int exitCode = ProcessTools.executeCommand(pb).getExitValue();\n+\n","filename":"test\/jdk\/java\/util\/Calendar\/SupplementalJapaneseEraTestRun.java","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1,144 +0,0 @@\n-#!\/bin\/sh\n-\n-# Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# @test\n-# @bug 6332666 6863624 7180362 8003846 8074350 8074351 8130246 8149735 7102969\n-#      8157138 8190904\n-# @summary tests the capability of replacing the currency data with user\n-#     specified currency properties file\n-# @build PropertiesTest\n-# @run shell\/timeout=600 PropertiesTest.sh\n-\n-if [ \"${TESTSRC}\" = \"\" ]\n-then\n-  echo \"TESTSRC not set.  Test cannot execute.  Failed.\"\n-  exit 1\n-fi\n-echo \"TESTSRC=${TESTSRC}\"\n-if [ \"${TESTJAVA}\" = \"\" ]\n-then\n-  echo \"TESTJAVA not set.  Test cannot execute.  Failed.\"\n-  exit 1\n-fi\n-echo \"TESTJAVA=${TESTJAVA}\"\n-if [ \"${TESTCLASSES}\" = \"\" ]\n-then\n-  echo \"TESTCLASSES not set.  Test cannot execute.  Failed.\"\n-  exit 1\n-fi\n-echo \"TESTCLASSES=${TESTCLASSES}\"\n-echo \"CLASSPATH=${CLASSPATH}\"\n-\n-# set platform-dependent variables\n-OS=`uname -s`\n-case \"$OS\" in\n-  Linux | Darwin | AIX )\n-    PS=\":\"\n-    FS=\"\/\"\n-    ;;\n-  Windows* )\n-    PS=\";\"\n-    FS=\"\/\"\n-    ;;\n-  CYGWIN*|MSYS*|MINGW* )\n-    PS=\";\"\n-    FS=\"\/\"\n-    TESTJAVA=`cygpath -u ${TESTJAVA}`\n-    ;;\n-  * )\n-    echo \"Unrecognized system!\"\n-    exit 1;\n-    ;;\n-esac\n-\n-failures=0\n-\n-run() {\n-    echo ''\n-    ${TESTJAVA}${FS}bin${FS}java ${TESTVMOPTS} -cp ${TESTCLASSES} $* 2>&1\n-    if [ $? != 0 ]; then failures=`expr $failures + 1`; fi\n-}\n-\n-PROPS=${TESTSRC}${FS}currency.properties\n-\n-\n-# Dump built-in currency data\n-\n-run PropertiesTest -d dump1\n-if [ ! -f dump1 ]; then  echo \"file dump1 not created. Test cannot execute.  Failed.\"; exit 1; fi\n-\n-# Dump built-in currency data + overrides in properties file specified\n-# by system property.\n-\n-run -Djava.util.currency.data=${PROPS} PropertiesTest -d dump2\n-if [ ! -f dump2 ]; then  echo \"file dump2 not created. Test cannot execute.  Failed.\"; exit 1; fi\n-run PropertiesTest -c dump1 dump2 ${PROPS}\n-\n-\n-# Dump built-in currency data + overrides in properties file copied into\n-# JRE image.\n-\n-# Make a private copy of the jdk so we can write to the properties file location\n-# without disturbing other users, including concurrently executing tests.\n-WRITABLEJDK=.${FS}testjava\n-cp -H -R $TESTJAVA $WRITABLEJDK || exit 1\n-PROPLOCATION=${WRITABLEJDK}${FS}lib\n-chmod -R u+w $WRITABLEJDK || exit 1\n-cp ${PROPS} $PROPLOCATION || exit 1\n-echo \"Properties location: ${PROPLOCATION}\"\n-\n-# run\n-echo ''\n-${WRITABLEJDK}${FS}bin${FS}java ${TESTVMOPTS} -cp ${TESTCLASSES} PropertiesTest -d dump3\n-if [ $? != 0 ]; then failures=`expr $failures + 1`; fi\n-if [ ! -f dump3 ]; then  echo \"file dump3 not created. Test cannot execute.  Failed.\"; exit 1; fi\n-\n-# run bug7102969 test\n-echo ''\n-${WRITABLEJDK}${FS}bin${FS}java ${TESTVMOPTS} -cp ${TESTCLASSES} PropertiesTest bug7102969\n-if [ $? != 0 ]; then failures=`expr $failures + 1`; fi\n-\n-# run bug8157138 test\n-echo ''\n-${WRITABLEJDK}${FS}bin${FS}java ${TESTVMOPTS} -cp ${TESTCLASSES} PropertiesTest bug8157138\n-if [ $? != 0 ]; then failures=`expr $failures + 1`; fi\n-\n-# run bug8190904 test\n-echo ''\n-${WRITABLEJDK}${FS}bin${FS}java ${TESTVMOPTS} -cp ${TESTCLASSES} PropertiesTest bug8190904\n-if [ $? != 0 ]; then failures=`expr $failures + 1`; fi\n-\n-# Cleanup\n-rm -rf $WRITABLEJDK\n-\n-# compare the two dump files\n-run PropertiesTest -c dump1 dump3 ${PROPS}\n-\n-\n-# Results\n-echo ''\n-if [ $failures -gt 0 ];\n-  then echo \"$failures tests failed\";\n-  else echo \"All tests passed\"; fi\n-exit $failures\n","filename":"test\/jdk\/java\/util\/Currency\/PropertiesTest.sh","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6332666 6863624 7180362 8003846 8074350 8074351 8130246 8149735 7102969\n+ *      8157138 8190904 8210410\n+ * @summary Tests the capability of replacing the currency data with a user\n+ *          specified currency properties file in lib directory (old way) or\n+ *          via the system property in the cmdline (new way).\n+ * @library \/test\/lib\n+ * @build PropertiesTest\n+ * @run junit PropertiesTestRun\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class PropertiesTestRun {\n+\n+    \/\/ String paths used for the cmdline processes\n+    private static final String TEST_JDK = Utils.TEST_JDK;\n+    private static final String TEST_PROPS =\n+            Utils.TEST_SRC+Utils.FILE_SEPARATOR+\"currency.properties\";\n+    private static final String WRITABLE_JDK =\n+            \".\"+Utils.FILE_SEPARATOR+\"WRITABLE_JDK\";\n+    private static final String WRITABLE_JDK_LIB =\n+            WRITABLE_JDK+Utils.FILE_SEPARATOR+\"lib\";\n+    private static final String WRITABLE_JDK_BIN =\n+            WRITABLE_JDK+Utils.FILE_SEPARATOR+\"bin\";\n+    private static final String WRITABLE_JDK_JAVA_PATH =\n+            WRITABLE_JDK_BIN + Utils.FILE_SEPARATOR + \"java\";\n+\n+    \/\/ Create a writable JDK and set up dumps 1-3\n+    @BeforeAll\n+    static void setUp() throws Throwable {\n+        \/\/ Create separate JDK to supersede currencies via lib directory\n+        createWritableJDK();\n+        \/\/ Create dump without user defined prop file\n+        executeTestJDKMethod(\"PropertiesTest\", \"-d\", \"dump1\");\n+        \/\/ Create dump with user defined prop file (via system property)\n+        executeTestJDKMethod(\"-Djava.util.currency.data=\"+TEST_PROPS,\n+                \"PropertiesTest\", \"-d\", \"dump2\");\n+        \/\/ Create dump with user defined prop file (via lib)\n+        executeWritableJDKMethod(\"PropertiesTest\", \"-d\", \"dump3\");\n+    }\n+\n+    \/\/ Need to create a separate JDK to insert the user defined properties file\n+    \/\/ into the lib folder. Create separate JDK to not disturb current TEST JDK.\n+    private static void createWritableJDK() throws Throwable {\n+        \/\/ Copy Test JDK into a separate JDK folder\n+        executeProcess(new String[]{\"cp\", \"-H\", \"-R\", TEST_JDK, WRITABLE_JDK});\n+        \/\/ Make the separate JDK writable\n+        executeProcess(new String[]{\"chmod\", \"-R\", \"u+w\", WRITABLE_JDK_LIB});\n+        \/\/ Copy the properties file into the writable JDK lib folder\n+        executeProcess(new String[]{\"cp\", TEST_PROPS, WRITABLE_JDK_LIB});\n+    }\n+\n+    \/\/ Compares the dumped output is expected between the default currencies\n+    \/\/ and the user-defined custom currencies\n+    @Test\n+    void compareDumps() throws Throwable {\n+        \/\/ Compare dump (from sys prop)\n+        executeTestJDKMethod(\"PropertiesTest\", \"-c\", \"dump1\", \"dump2\",\n+                TEST_PROPS);\n+        \/\/ Compare dump (from lib)\n+        executeTestJDKMethod(\"PropertiesTest\", \"-c\", \"dump1\", \"dump3\",\n+                TEST_PROPS);\n+    }\n+\n+    \/\/ Launch a test from PropertiesTest. See PropertiesTest.java for more\n+    \/\/ detail regarding a specific test that was launched.\n+    @ParameterizedTest\n+    @MethodSource(\"PropertiesTestMethods\")\n+    void launchPropertiesTests(String methodName) throws Throwable {\n+        \/\/ Test via both the lib and system property\n+        executeWritableJDKMethod(\"PropertiesTest\", methodName);\n+        executeTestJDKMethod(\"-Djava.util.currency.data=\"+TEST_PROPS,\n+                \"PropertiesTest\", methodName);\n+    }\n+\n+    private static Stream<String> PropertiesTestMethods() {\n+        return Stream.of(\"bug7102969\", \"bug8157138\", \"bug8190904\");\n+    }\n+\n+    \/\/ Launch a PropertiesTest method using the TEST JDK\n+    private static void executeTestJDKMethod(String... params) throws Throwable {\n+        int exitStatus = ProcessTools.executeTestJvm(params).getExitValue();\n+        if (exitStatus != 0) {\n+            fail(\"Process started with: \" + Arrays.toString(params) + \" failed\");\n+        }\n+    }\n+\n+    \/\/ Launch a PropertiesTest method using the WRITABLE JDK\n+    private static void executeWritableJDKMethod(String... params) throws Throwable {\n+        \/\/ Need to include WritableJDK javapath, TEST JDK classpath\n+        String[] allParams = new String[3+params.length+Utils.getTestJavaOpts().length];\n+        \/\/ We don't use executeTestJvm() because we want to point to separate JDK java path\n+        allParams[0] = WRITABLE_JDK_JAVA_PATH;\n+        allParams[1] = \"-cp\";\n+        allParams[2] = System.getProperty(\"java.class.path\");\n+        \/\/ Add test.vm.opts and test.java.opts\n+        System.arraycopy(Utils.getTestJavaOpts(), 0, allParams, 3,\n+                Utils.getTestJavaOpts().length);\n+        \/\/ Add the rest of the actual arguments\n+        System.arraycopy(params, 0, allParams, Utils.getTestJavaOpts().length+3,\n+                params.length);\n+        \/\/ Launch the actual test method with all parameters set\n+        executeProcess(allParams);\n+    }\n+\n+    \/\/ Execute a process and fail if the command is not successful\n+    private static void executeProcess(String[] params) throws Throwable {\n+        System.out.println(\"Command line: \" + Arrays.toString(params));\n+        int exitStatus = ProcessTools.executeProcess(params).getExitValue();\n+        if (exitStatus != 0) {\n+            fail(\"Process started with: \" + Arrays.toString(params) + \" failed\");\n+        }\n+    }\n+\n+    @AfterAll\n+    static void tearDown() throws Throwable {\n+        \/\/ Remove the copied writable JDK image from scratch folder\n+        executeProcess(new String[]{\"rm\", \"-rf\", WRITABLE_JDK});\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Currency\/PropertiesTestRun.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @requires vm.flagless\n@@ -42,1 +43,0 @@\n-import jdk.test.lib.JDKToolLauncher;\n@@ -181,16 +181,12 @@\n-            String param1, String param2, String param3) throws Throwable{\n-        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"java\");\n-        launcher.addToolArg(\"-ea\")\n-                .addToolArg(\"-esa\")\n-                .addToolArg(\"-cp\")\n-                .addToolArg(Utils.TEST_CLASS_PATH)\n-                .addToolArg(\"-Djava.util.logging.config.class=LocaleProviders$LogConfig\")\n-                .addToolArg(\"-Djava.locale.providers=\" + prefList)\n-                .addToolArg(\"--add-exports=java.base\/sun.util.locale.provider=ALL-UNNAMED\")\n-                .addToolArg(\"LocaleProviders\")\n-                .addToolArg(methodName)\n-                .addToolArg(param1)\n-                .addToolArg(param2)\n-                .addToolArg(param3);\n-        int exitCode = ProcessTools.executeCommand(launcher.getCommand())\n-                .getExitValue();\n+            String param1, String param2, String param3) throws Throwable {\n+\n+        \/\/ Build process (without VM flags)\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                \"-ea\", \"-esa\",\n+                \"-cp\", Utils.TEST_CLASS_PATH,\n+                \"-Djava.util.logging.config.class=LocaleProviders$LogConfig\",\n+                \"-Djava.locale.providers=\" + prefList,\n+                \"--add-exports=java.base\/sun.util.locale.provider=ALL-UNNAMED\",\n+                \"LocaleProviders\", methodName, param1, param2, param3);\n+        \/\/ Evaluate process status\n+        int exitCode = ProcessTools.executeCommand(pb).getExitValue();\n","filename":"test\/jdk\/java\/util\/Locale\/LocaleProvidersRun.java","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,9 +87,7 @@\n-        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"java\");\n-        launcher.addToolArg(\"-ea\")\n-                .addToolArg(\"-esa\")\n-                .addToolArg(\"-cp\")\n-                .addToolArg(cp)\n-                .addToolArg(\"MissingResourceCauseTest\");\n-\n-        int exitCode = ProcessTools.executeCommand(launcher.getCommand())\n-                .getExitValue();\n+        \/\/ Build process (with VM flags)\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-ea\", \"-esa\",\n+                \"-cp\", cp,\n+                \"MissingResourceCauseTest\");\n+        \/\/ Evaluate process status\n+        int exitCode = ProcessTools.executeCommand(pb).getExitValue();\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/Control\/MissingResourceCauseTestRun.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import jdk.test.lib.Utils;\n@@ -136,11 +137,9 @@\n-        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"java\");\n-        launcher.addToolArg(\"-ea\")\n-                .addToolArg(\"-esa\")\n-                .addToolArg(\"-p\")\n-                .addToolArg(mp)\n-                .addToolArg(\"-m\")\n-                .addToolArg(mn);\n-        localeList.forEach(launcher::addToolArg);\n-\n-        int exitCode = ProcessTools.executeCommand(launcher.getCommand())\n-                                   .getExitValue();\n+        List<String> args = List.of(\n+                \"-ea\", \"-esa\",\n+                \"-p\", mp,\n+                \"-m\", mn);\n+        \/\/ Build process (with VM flags)\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Stream.concat(args.stream(), localeList.stream()).toList());\n+        \/\/ Evaluate process status\n+        int exitCode = ProcessTools.executeCommand(pb).getExitValue();\n@@ -164,10 +163,10 @@\n-        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"java\");\n-        launcher.addToolArg(\"-ea\")\n-                .addToolArg(\"-esa\")\n-                .addToolArg(\"-cp\")\n-                .addToolArg(cp)\n-                .addToolArg(\"-p\")\n-                .addToolArg(mp)\n-                .addToolArg(\"-m\")\n-                .addToolArg(mn);\n-        localeList.forEach(launcher::addToolArg);\n+        List<String> args = List.of(\n+                \"-ea\", \"-esa\",\n+                \"-cp\", cp,\n+                \"-p\", mp,\n+                \"-m\", mn);\n+        \/\/ Build process (with VM flags)\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Stream.concat(args.stream(), localeList.stream()).toList());\n+        \/\/ Evaluate process status\n+        int exitCode = ProcessTools.executeCommand(pb).getExitValue();\n@@ -175,2 +174,0 @@\n-        int exitCode = ProcessTools.executeCommand(launcher.getCommand())\n-                                   .getExitValue();\n@@ -201,9 +198,10 @@\n-        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"java\");\n-        launcher.addToolArg(\"-ea\")\n-                .addToolArg(\"-esa\")\n-                .addToolArg(\"-Djava.locale.useOldISOCodes=true\")\n-                .addToolArg(\"-p\")\n-                .addToolArg(mp)\n-                .addToolArg(\"-m\")\n-                .addToolArg(mn);\n-        localeList.forEach(launcher::addToolArg);\n+        List<String> args = List.of(\n+                \"-ea\", \"-esa\",\n+                \"-Djava.locale.useOldISOCodes=true\",\n+                \"-p\", mp,\n+                \"-m\", mn);\n+        \/\/ Build process (with VM flags)\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Stream.concat(args.stream(), localeList.stream()).toList());\n+        \/\/ Evaluate process status\n+        int exitCode = ProcessTools.executeCommand(pb).getExitValue();\n@@ -211,2 +209,0 @@\n-        int exitCode = ProcessTools.executeCommand(launcher.getCommand())\n-                .getExitValue();\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/modules\/ModuleTestUtil.java","additions":31,"deletions":35,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,10 +74,7 @@\n-        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"java\");\n-        launcher.addToolArg(\"-ea\")\n-                .addToolArg(\"-esa\")\n-                .addToolArg(\"-cp\")\n-                .addToolArg(Utils.TEST_CLASSES)\n-                .addToolArg(\"Main\")\n-                .addToolArg(Utils.TEST_CLASSES);\n-\n-        int exitCode = ProcessTools.executeCommand(launcher.getCommand())\n-                                   .getExitValue();\n+        \/\/ Build process (with VM flags)\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-ea\", \"-esa\",\n+                \"-cp\", Utils.TEST_CLASSES,\n+                \"Main\", Utils.TEST_CLASSES);\n+        \/\/ Evaluate process status\n+        int exitCode = ProcessTools.executeCommand(pb).getExitValue();\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/modules\/layer\/LayerTest.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import java.util.stream.Stream;\n@@ -76,14 +77,10 @@\n-        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"java\");\n-        launcher.addToolArg(\"-ea\")\n-                .addToolArg(\"-esa\")\n-                .addToolArg(\"-cp\")\n-                .addToolArg(Utils.TEST_CLASSES)\n-                .addToolArg(\"--module-path\")\n-                .addToolArg(MODS_DIR.toString())\n-                .addToolArg(\"--add-modules\")\n-                .addToolArg(\"bundles\")\n-                .addToolArg(\"Main\");\n-        LOCALE_LIST.forEach(launcher::addToolArg);\n-\n-        int exitCode = ProcessTools.executeCommand(launcher.getCommand())\n-                                   .getExitValue();\n+        List<String> args = List.of(\n+                \"-ea\", \"-esa\",\n+                \"-cp\", Utils.TEST_CLASSES,\n+                \"--module-path\", MODS_DIR.toString(),\n+                \"--add-modules\", \"bundles\",\n+                \"Main\");\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Stream.concat(args.stream(), LOCALE_LIST.stream()).toList());\n+        \/\/ Evaluate process status\n+        int exitCode = ProcessTools.executeCommand(pb).getExitValue();\n@@ -96,13 +93,9 @@\n-        launcher = JDKToolLauncher.createUsingTestJDK(\"java\");\n-        launcher.addToolArg(\"-ea\")\n-                .addToolArg(\"-esa\")\n-                .addToolArg(\"-cp\")\n-                .addToolArg(Utils.TEST_CLASSES)\n-                .addToolArg(\"--module-path\")\n-                .addToolArg(MODS_DIR.toString())\n-                .addToolArg(\"--add-modules\")\n-                .addToolArg(\"bundles\")\n-                .addToolArg(\"--add-opens\")\n-                .addToolArg(\"bundles\/jdk.test.internal.resources=ALL-UNNAMED\")\n-                .addToolArg(\"Main\");\n-        LOCALE_LIST.forEach(launcher::addToolArg);\n+        List<String> argsWithOpens = List.of(\n+                \"-ea\", \"-esa\",\n+                \"-cp\", Utils.TEST_CLASSES,\n+                \"--module-path\", MODS_DIR.toString(),\n+                \"--add-modules\", \"bundles\",\n+                \"--add-opens\", \"bundles\/jdk.test.internal.resources=ALL-UNNAMED\",\n+                \"Main\");\n+        pb = ProcessTools.createTestJavaProcessBuilder(\n+                Stream.concat(argsWithOpens.stream(), LOCALE_LIST.stream()).toList());\n@@ -110,2 +103,2 @@\n-        exitCode = ProcessTools.executeCommand(launcher.getCommand())\n-                               .getExitValue();\n+        \/\/ Evaluate process status\n+        exitCode = ProcessTools.executeCommand(pb).getExitValue();\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/modules\/unnamed\/UnNamedTest.java","additions":23,"deletions":30,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @requires vm.flagless\n@@ -42,0 +43,1 @@\n+import java.util.stream.Stream;\n@@ -46,0 +48,1 @@\n+\n@@ -331,6 +334,5 @@\n-        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"java\");\n-        launcher.addToolArg(\"-ea\")\n-                .addToolArg(\"-esa\");\n-        argsList.forEach(launcher::addToolArg);\n-\n-        return ProcessTools.executeCommand(launcher.getCommand()).getExitValue();\n+        \/\/ Build process (without VM flags)\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                Stream.concat(Stream.of(\"-ea\", \"-esa\"), argsList.stream()).toList());\n+        \/\/ Evaluate process status\n+        return ProcessTools.executeCommand(pb).getExitValue();\n@@ -338,1 +340,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/modules\/visibility\/VisibilityTest.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+\n@@ -34,1 +35,0 @@\n-import java.util.List;\n@@ -40,0 +40,1 @@\n+\n@@ -42,0 +43,1 @@\n+\n@@ -49,1 +51,1 @@\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(List.of(\"CustomTzIDCheckDST\", \"runTZTest\"));\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\"CustomTzIDCheckDST\", \"runTZTest\");\n","filename":"test\/jdk\/java\/util\/TimeZone\/CustomTzIDCheckDST.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,11 +69,9 @@\n-            JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"java\");\n-            launcher.addToolArg(\"-Djava.security.manager\")\n-                    .addToolArg(\"-Djava.security.debug=access,failure,policy\")\n-                    .addToolArg(\"-ea\")\n-                    .addToolArg(\"-esa\")\n-                    .addToolArg(\"-cp\")\n-                    .addToolArg(jarPath)\n-                    .addToolArg(\"TimeZoneDatePermissionCheck\");\n-\n-            int exitCode = ProcessTools.executeCommand(launcher.getCommand())\n-                    .getExitValue();\n+            \/\/ Build process (with VM flags)\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                    \"-Djava.security.manager\",\n+                    \"-Djava.security.debug=access,failure,policy\",\n+                    \"-ea\", \"-esa\",\n+                    \"-cp\", jarPath,\n+                    \"TimeZoneDatePermissionCheck\");\n+            \/\/ Evaluate process status\n+            int exitCode = ProcessTools.executeCommand(pb).getExitValue();\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneDatePermissionCheckRun.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4992443 4994819\n- * @modules java.base\/java.util.concurrent.atomic:open\n- * @run main VMSupportsCS8\n- * @summary Checks that the value of VMSupportsCS8 matches system properties.\n- *\/\n-\n-import java.lang.reflect.Field;\n-\n-public class VMSupportsCS8 {\n-    public static void main(String[] args) throws Exception {\n-        String isalist = System.getProperty(\"sun.cpu.isalist\");\n-        if (isalist != null && isalist.matches\n-            (\".*\\\\b(pentium_pro|ia64|amd64).*\")\n-            ||\n-            System.getProperty(\"os.arch\").matches\n-            (\".*\\\\b(ia64|amd64).*\")) {\n-\n-            System.out.println(\"This system is known to have hardware CS8\");\n-\n-            Class klass = Class.forName(\"java.util.concurrent.atomic.AtomicLong\");\n-            Field field = klass.getDeclaredField(\"VM_SUPPORTS_LONG_CAS\");\n-            field.setAccessible(true);\n-            boolean VMSupportsCS8 = field.getBoolean(null);\n-            if (! VMSupportsCS8)\n-                throw new Exception(\"Unexpected value for VMSupportsCS8\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/concurrent\/atomic\/VMSupportsCS8.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+ * @key randomness\n+ * @library \/test\/lib\n@@ -32,1 +34,0 @@\n- * @key randomness\n@@ -53,1 +54,0 @@\n-import java.util.Arrays;\n@@ -66,0 +66,2 @@\n+import jdk.test.lib.process.ProcessTools;\n+\n@@ -77,1 +79,3 @@\n-            ProcessBuilder pb = new ProcessBuilder(javaChildArgs);\n+            \/\/ Build process (with VM flags)\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                    javaChildArgs);\n@@ -154,3 +158,0 @@\n-    private static final String javaExe =\n-        System.getProperty(\"java.home\") +\n-        File.separator + \"bin\" + File.separator + \"java\";\n@@ -164,4 +165,2 @@\n-    private static final List<String> javaChildArgs =\n-        Arrays.asList(new String[]\n-            { javaExe, \"-classpath\", classpath,\n-              \"LoggingDeadlock2$JavaChild\"});\n+   private static final List<String> javaChildArgs = List.of(\n+       \"-classpath\", classpath, \"LoggingDeadlock2$JavaChild\");\n","filename":"test\/jdk\/java\/util\/logging\/LoggingDeadlock2.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.nio.file.Paths;\n@@ -164,5 +163,1 @@\n-        String javaHome = System.getProperty(\"java.home\");\n-        String java = Paths.get(javaHome, \"bin\", \"java\").toString();\n-        String[] cmd = { java, \"-jar\", zipFile.getName() };\n-        ProcessBuilder pb = new ProcessBuilder(cmd);\n-        OutputAnalyzer a = ProcessTools.executeProcess(pb);\n+        OutputAnalyzer a = ProcessTools.executeTestJvm(\"-jar\", zipFile.getName());\n","filename":"test\/jdk\/java\/util\/zip\/EntryCount64k.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,0 +80,1 @@\n+    private static final double RATIO_FAIL_VALUE = 2500.0;\n@@ -190,1 +191,1 @@\n-        if (ratio > 500.0)\n+        if (ratio > RATIO_FAIL_VALUE) {\n@@ -192,0 +193,1 @@\n+        }\n","filename":"test\/jdk\/javax\/management\/remote\/mandatory\/notif\/ListenerScaleTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-  \"${TESTCLASSES}${PS}${TESTCLASSES}\/badfactoty.jar\" \\\n+  \"${TESTCLASSES}${PS}${TESTCLASSES}\/badfactory.jar\" \\\n","filename":"test\/jdk\/javax\/script\/JDK_8196959\/BadFactoryTest.sh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.awt.Graphics;\n+import java.awt.image.BufferedImage;\n+import javax.imageio.ImageIO;\n+import javax.swing.JComponent;\n+import javax.swing.JProgressBar;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+\n+\/*\n+ * @test\n+ * @bug 8224261\n+ * @key headful\n+ * @library ..\/regtesthelpers\n+ * @build Util\n+ * @summary Verifies JProgressBar border is not painted when border\n+ *          painting is set to false\n+ * @run main TestProgressBarBorder\n+ *\/\n+\n+public class TestProgressBarBorder {\n+    public static void main(String[] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo laf :\n+                UIManager.getInstalledLookAndFeels()) {\n+            if (!laf.getName().contains(\"Nimbus\") && !laf.getName().contains(\"GTK\")) {\n+                continue;\n+            }\n+            System.out.println(\"Testing LAF: \" + laf.getName());\n+            SwingUtilities.invokeAndWait(() -> test(laf));\n+        }\n+    }\n+\n+    private static void test(UIManager.LookAndFeelInfo laf) {\n+        setLookAndFeel(laf);\n+        JProgressBar progressBar = createProgressBar();\n+        progressBar.setBorderPainted(true);\n+        BufferedImage withBorder = paintToImage(progressBar);\n+        progressBar.setBorderPainted(false);\n+        BufferedImage withoutBorder = paintToImage(progressBar);\n+\n+        boolean equal = Util.compareBufferedImages(withBorder, withoutBorder);\n+        if (equal) {\n+            try {\n+                ImageIO.write(withBorder, \"png\", new File(\"withBorder.png\"));\n+                ImageIO.write(withoutBorder, \"png\", new File(\"withoutBorder.png\"));\n+            } catch (IOException ignored) {}\n+\n+            throw new RuntimeException(\"JProgressBar border is painted when border \" +\n+                    \"painting is set to false\");\n+        }\n+    }\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported LAF: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static JProgressBar createProgressBar() {\n+        JProgressBar progressBar = new JProgressBar();\n+        progressBar.setSize(100, 50);\n+        progressBar.setValue(0);\n+        progressBar.setStringPainted(true);\n+        return progressBar;\n+    }\n+\n+    private static BufferedImage paintToImage(JComponent content) {\n+        BufferedImage im = new BufferedImage(content.getWidth(), content.getHeight(),\n+                TYPE_INT_RGB);\n+        Graphics g = im.getGraphics();\n+        content.paint(g);\n+        g.dispose();\n+        return im;\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JProgressBar\/TestProgressBarBorder.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n- * @bug 7083187\n+ * @bug 7083187 8318113\n@@ -75,0 +75,3 @@\n+\n+            \"background-image: none\",\n+            \"background-image: url(image.png)\",\n@@ -89,0 +92,2 @@\n+\n+            {\"background-image: none\", \"background-image: url(image.png)\"},\n","filename":"test\/jdk\/javax\/swing\/text\/html\/CSS\/CSSAttributeEqualityBug.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8305990 8320222\n+ * @bug 8305990 8320222 8320618\n@@ -46,1 +46,0 @@\n-import java.util.List;\n@@ -240,0 +239,12 @@\n+    @Test\n+    void testInvalidAALOADStack() {\n+        Classfile.of().build(ClassDesc.of(\"Test\"), clb\n+                -> clb.withMethodBody(\"test\", ConstantDescs.MTD_void, 0, cob\n+                        -> cob.bipush(10)\n+                              .anewarray(ConstantDescs.CD_Object)\n+                              .lconst_1() \/\/long on stack caused NPE, see 8320618\n+                              .aaload()\n+                              .astore(2)\n+                              .return_()));\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Byte128VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Byte128VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Byte256VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Byte256VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Byte512VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Byte512VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Byte64VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Byte64VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation ByteMaxVectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation ByteMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Double128VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Double128VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Double256VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Double256VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Double512VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Double512VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Double64VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Double64VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation DoubleMaxVectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation DoubleMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Float128VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Float128VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Float256VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Float256VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Float512VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Float512VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Float64VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Float64VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation FloatMaxVectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation FloatMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Int128VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Int128VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Int256VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Int256VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Int512VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Int512VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Int64VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Int64VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation IntMaxVectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation IntMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Long128VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Long128VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Long256VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Long256VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Long512VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Long512VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Long64VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Long64VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation LongMaxVectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation LongMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Short128VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Short128VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Short256VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Short256VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Short512VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Short512VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation Short64VectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation Short64VectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation ShortMaxVectorTests\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation ShortMaxVectorTests\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -ea -esa -Xbatch -XX:-TieredCompilation $vectorteststype$\n+ * @run testng\/othervm\/timeout=300 -ea -esa -Xbatch -XX:-TieredCompilation $vectorteststype$\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.metadata.annotations;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.jfr.api.metadata.annotations.UnloadableClass;\n+import jdk.jfr.Event;\n+import jdk.jfr.AnnotationElement;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordedStackTrace;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.events.StackFilter;\n+import jdk.jfr.Recording;\n+import jdk.jfr.Name;\n+import jdk.jfr.EventType;\n+import jdk.jfr.EventFactory;\n+import jdk.jfr.FlightRecorder;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.TestClassLoader;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @modules jdk.jfr\/jdk.jfr.events\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -Xlog:jfr=warning jdk.jfr.api.metadata.annotations.TestStackFilter\n+ *\/\n+public class TestStackFilter {\n+    private static class Quux {\n+        private static void one() throws Exception {\n+            two();\n+        }\n+        private static void two() throws Exception {\n+            three();\n+        }\n+\n+        private static void three() throws Exception {\n+            TestStackFilter.qux();\n+        }\n+    }\n+    private final static String PACKAGE = \"jdk.jfr.api.metadata.annotations.TestStackFilter\";\n+    private final static String M1 = PACKAGE + \"::foo\";\n+    private final static String M2 = PACKAGE + \"::baz\";\n+    private final static String C1 = PACKAGE + \"$Quux\";\n+\n+    @StackFilter({ M1, M2 })\n+    @Name(\"MethodFilter\")\n+    public static class MethodFilterEvent extends Event {\n+    }\n+\n+    @StackFilter(C1)\n+    @Name(\"ClassFilter\")\n+    public static class ClassFilterEvent extends Event {\n+    }\n+\n+    @StackFilter({})\n+    @Name(\"Empty\")\n+    public static class EmptyEvent extends Event {\n+    }\n+\n+    @StackFilter(PACKAGE + \"::testUnload\")\n+    @Name(\"Unload\")\n+    public static class UnloadEvent extends Event {\n+    }\n+\n+    @StackFilter(PACKAGE + \"::emitCommitter\")\n+    @Name(\"Reuse\")\n+    public static class ReuseEvent extends Event {\n+    }\n+\n+    @StackFilter(PACKAGE + \"::emitCommitter\")\n+    @Name(\"Max\")\n+    public static class ExceedMaxEvent extends Event {\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        testMethodFilter();\n+        testClassFilter();\n+        testUnload();\n+        testReuse();\n+        testExceedMax();\n+    }\n+\n+    \/\/ Use more stack filters than there is capacity for\n+    private static void testExceedMax() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+            \/\/ Maximum number of simultaneous event classes that can\n+            \/\/ use a filter is 4096. Additional filters will be ignored.\n+            var classes = new ArrayList<>();\n+            for (int i = 0; i < 4200; i++) {\n+                Class<ExceedMaxEvent> eventClass = UnloadableClass.load(ExceedMaxEvent.class);\n+                emitCommitter(eventClass);\n+                classes.add(eventClass);\n+            }\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            if (events.size() != 4200) {\n+                throw new Exception(\"Expected 4200 'Max' events\");\n+            }\n+            int emitCommitterCount = 0;\n+            int textExceedMaxCount = 0;\n+            for (RecordedEvent event : events) {\n+                RecordedStackTrace s = event.getStackTrace();\n+                if (s == null) {\n+                    System.out.println(event);\n+                    throw new Exception(\"Expected stack trace for 'Max' event\");\n+                }\n+\n+                RecordedFrame f = s.getFrames().get(0);\n+                if (!f.isJavaFrame()) {\n+                    throw new Exception(\"Expected Java frame for 'Max' event\");\n+                }\n+                String methodName = f.getMethod().getName();\n+                switch (methodName) {\n+                    case \"emitCommitter\":\n+                        emitCommitterCount++;\n+                        break;\n+                    case \"testExceedMax\":\n+                        textExceedMaxCount++;\n+                        break;\n+                    default:\n+                        System.out.println(event);\n+                        throw new Exception(\"Unexpected top frame \" + methodName + \" for 'Max' event\");\n+                }\n+            }\n+            \/\/ Can't match exact because filters from previous tests may be in use\n+            \/\/ or because filters added by JDK events filters\n+            if (emitCommitterCount == 0) {\n+                throw new Exception(\"Expected at least some events with emitCommitter() as top frame, found \" + emitCommitterCount);\n+            }\n+            if (textExceedMaxCount < 500) {\n+                throw new Exception(\"Expected at least 500 events with testExceedMax() as top frame, found \" + textExceedMaxCount);\n+            }\n+        }\n+    }\n+\n+    \/\/ Tests that event classes with @StackFilter that are unloaded\n+    \/\/ reuses the memory slot used to bookkeep things in native\n+    private static void testReuse() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(\"Reuse\");\n+            r.start();\n+            for (int i = 0; i < 48; i++) {\n+                Class<ReuseEvent> eventClass = UnloadableClass.load(ReuseEvent.class);\n+                emitCommitter(eventClass);\n+                if (i % 16 == 0) {\n+                    System.gc();\n+                    rotate();\n+                }\n+            }\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            if (events.size() != 48) {\n+                throw new Exception(\"Expected 48 'Reuse' events\");\n+            }\n+            for (RecordedEvent event : events) {\n+                assertTopFrame(event, \"testReuse\");\n+            }\n+        }\n+\n+    }\n+\n+    \/\/ This test registers a stack filter, emits an event with the filter\n+    \/\/ and unregisters it. While this is happening, another\n+    \/\/ filter is being used.\n+    private static void testUnload() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+            Class<UnloadEvent> eventClass = UnloadableClass.load(UnloadEvent.class);\n+            emitCommitter(eventClass);\n+            EventType type = getType(\"Unload\");\n+            if (type == null) {\n+                throw new Exception(\"Expected event type named 'Unload'\");\n+            }\n+            eventClass = null;\n+            while (true) {\n+                System.gc();\n+                rotate();\n+                type = getType(\"Unload\");\n+                if (type == null) {\n+                    return;\n+                }\n+                System.out.println(\"Unload class not unloaded. Retrying ...\");\n+            }\n+        }\n+    }\n+\n+    private static void testMethodFilter() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(MethodFilterEvent.class);\n+            r.start();\n+            foo();\n+            bar();\n+            empty();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            if (events.isEmpty()) {\n+                throw new Exception(\"Excected events\");\n+            }\n+\n+            RecordedEvent e1 = events.get(0);\n+            assertTopFrame(e1, \"testMethodFilter\");\n+\n+            RecordedEvent e2 = events.get(1);\n+            assertTopFrame(e2, \"bar\");\n+\n+            RecordedEvent e3 = events.get(2);\n+            assertTopFrame(e3, \"empty\");\n+        }\n+    }\n+\n+    private static void testClassFilter() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(MethodFilterEvent.class);\n+            r.start();\n+            Quux.one();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            if (events.isEmpty()) {\n+                throw new Exception(\"Excected events\");\n+            }\n+\n+            RecordedEvent e = events.get(0);\n+            assertTopFrame(e, \"qux\");\n+            for (RecordedFrame f : e.getStackTrace().getFrames()) {\n+                if (f.getMethod().getType().getName().contains(\"Quux\")) {\n+                    System.out.println(e);\n+                    throw new Exception(\"Didn't expect Quux class in stack trace\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void empty() {\n+        EmptyEvent event = new EmptyEvent();\n+        event.commit();\n+    }\n+\n+    static void foo() {\n+        baz();\n+    }\n+\n+    static void bar() {\n+        baz();\n+    }\n+\n+    static void baz() {\n+        MethodFilterEvent event = new MethodFilterEvent();\n+        event.commit();\n+    }\n+\n+    static void qux() {\n+        ClassFilterEvent event = new ClassFilterEvent();\n+        event.commit();\n+    }\n+\n+    private static void rotate() {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+        }\n+    }\n+\n+    private static EventType getType(String name) {\n+        for (EventType et : FlightRecorder.getFlightRecorder().getEventTypes()) {\n+            if (et.getName().equals(name)) {\n+                return et;\n+            }\n+\n+        }\n+        return null;\n+    }\n+\n+    private static void emitCommitter(Class<? extends Event> eventClass) throws Exception {\n+        Event event = eventClass.getConstructor().newInstance();\n+        event.commit();\n+    }\n+\n+    private static void assertTopFrame(RecordedEvent event, String methodName) throws Exception {\n+        RecordedStackTrace stackTrace = event.getStackTrace();\n+        if (stackTrace == null) {\n+            System.out.println(event);\n+            throw new Exception(\"No stack trace found when looking for top frame '\" + methodName + \"'\");\n+        }\n+        RecordedFrame frame = stackTrace.getFrames().get(0);\n+        RecordedMethod method = frame.getMethod();\n+        if (!methodName.equals(method.getName())) {\n+            System.out.println(event);\n+            throw new Exception(\"Expected top frame '\" + methodName + \"'\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/metadata\/annotations\/TestStackFilter.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.metadata.annotations;\n+\n+import java.io.DataInputStream;\n+import java.security.CodeSource;\n+import java.security.ProtectionDomain;\n+import java.security.cert.Certificate;\n+\n+\/* Purpose of this class is to load a specified class in its\n+ * own class loader, but delegate every other class.\n+ *\/\n+public final class UnloadableClass<T> extends ClassLoader {\n+    private final String className;\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static <T> Class<T> load(Class<T> clazz) throws ClassNotFoundException {\n+        UnloadableClass cl = new UnloadableClass(clazz.getName());\n+        return cl.loadClass(cl.className);\n+    }\n+\n+    private UnloadableClass(String className) {\n+        super(\"Class loader for class \" + className, ClassLoader.getSystemClassLoader());\n+        this.className = className;\n+    }\n+\n+    public Class<?> loadClass(String name) throws ClassNotFoundException {\n+        if (!className.equals(name)) {\n+            return super.loadClass(name);\n+        }\n+        String resourceName = name.replace('.', '\/') + \".class\";\n+        try (var is = getResourceAsStream(resourceName); var dis = new DataInputStream(is)) {\n+            int size = is.available();\n+            byte buffer[] = new byte[size];\n+            dis.readFully(buffer);\n+            CodeSource cs = new CodeSource(getResource(resourceName), (Certificate[]) null);\n+            ProtectionDomain pd = new ProtectionDomain(cs, null);\n+            return defineClass(name, buffer, 0, buffer.length, pd);\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/metadata\/annotations\/UnloadableClass.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -128,1 +128,1 @@\n-            \"RestoreRetainedRegions\",\n+            \"RestoreEvacuationFailedRegions\",\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestG1ParallelPhases.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-        String[] gcCauses = {\"Metadata GC Threshold\", \"GCLocker Initiated GC\", \"G1 Evacuation Pause\", \"G1 Preventive Collection\",\n+        String[] gcCauses = {\"Metadata GC Threshold\", \"G1 Evacuation Pause\", \"G1 Preventive Collection\",\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestGCCauseWithG1ConcurrentMark.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-        String[] gcCauses = {\"Metadata GC Threshold\", \"GCLocker Initiated GC\", \"G1 Evacuation Pause\", \"G1 Preventive Collection\",\n+        String[] gcCauses = {\"Metadata GC Threshold\", \"G1 Evacuation Pause\", \"G1 Preventive Collection\",\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestGCCauseWithG1FullCollection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n- * @requires vm.gc.G1\n+ * @requires vm.gc.Serial | vm.gc.Parallel\n+ * @requires vm.gc != null\n@@ -33,1 +34,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xmx32m -Xms32m -Xmn12m -XX:+UseG1GC jdk.jfr.event.gc.detailed.TestGCLockerEvent\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xmx32m -Xms32m -Xmn12m jdk.jfr.event.gc.detailed.TestGCLockerEvent\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/TestGCLockerEvent.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-            recording.enable(EVENT_NAME);\n+            recording.enable(EVENT_NAME).withStackTrace();\n@@ -77,0 +77,1 @@\n+                Events.assertTopFrame(event, TestProcessStart.class, \"main\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/os\/TestProcessStart.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,7 +59,1 @@\n-            Thread virtualThread  = Thread.ofVirtual().start(() -> {\n-                try {\n-                    Thread.sleep(SLEEP_TIME_MS);\n-                } catch (InterruptedException ie) {\n-                    throw new RuntimeException(ie);\n-                }\n-            });\n+            Thread virtualThread = Thread.ofVirtual().start(TestThreadSleepEvent::virtualSleep);\n@@ -77,0 +71,1 @@\n+                    Events.assertTopFrame(event, TestThreadSleepEvent.class, \"main\");\n@@ -81,0 +76,1 @@\n+                    Events.assertTopFrame(event, TestThreadSleepEvent.class, \"virtualSleep\");\n@@ -87,0 +83,8 @@\n+\n+    private static void virtualSleep() {\n+        try {\n+            Thread.sleep(SLEEP_TIME_MS);\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(ie);\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestThreadSleepEvent.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-            recording.enable(EventNames.SecurityProperty);\n+            recording.enable(EventNames.SecurityProperty).withStackTrace();\n@@ -81,0 +81,1 @@\n+                Events.assertTopFrame(e, TestSecurityPropertyModificationEvent.class, \"main\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/security\/TestSecurityPropertyModificationEvent.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,2 @@\n-                \"SunEC\", \"Cipher\", 1, Collections.emptyList());\n+                \"SunEC\", \"Cipher\", 1, Collections.emptyList(),\n+                javax.crypto.Cipher.class.getName(), \"getInstance\");\n@@ -57,1 +58,2 @@\n-                \"SunEC\", \"Signature\", 2, List.of(\"MessageDigest\"));\n+                \"SunEC\", \"Signature\", 2, List.of(\"MessageDigest\"),\n+                \"sun.security.jca.GetInstance\", \"getService\");\n@@ -59,1 +61,2 @@\n-                \"SunEC\", \"MessageDigest\", 1, Collections.emptyList());\n+                \"SunEC\", \"MessageDigest\", 1, Collections.emptyList(),\n+                \"sun.security.jca.GetInstance\", \"getService\");\n@@ -61,1 +64,2 @@\n-                \"SunEC\", \"KeyStore\", 1, Collections.emptyList());\n+                \"SunEC\", \"KeyStore\", 1, Collections.emptyList(),\n+                \"sun.security.jca.GetInstance\", \"getService\");\n@@ -63,1 +67,2 @@\n-                \"SunEC\", \"CertPathBuilder\", 2, List.of(\"CertificateFactory\"));\n+                \"SunEC\", \"CertPathBuilder\", 2, List.of(\"CertificateFactory\"),\n+                \"sun.security.jca.GetInstance\", \"getService\");\n@@ -68,1 +73,2 @@\n-                                int expected, List<String> other) throws Exception {\n+                                int expected, List<String> other,\n+                                String clazz, String method) throws Exception {\n@@ -73,1 +79,1 @@\n-            recording.enable(EventNames.SecurityProviderService);\n+            recording.enable(EventNames.SecurityProviderService).withStackTrace();\n@@ -80,1 +86,1 @@\n-            assertEvent(events, algType, alg, p.getName(), other);\n+            assertEvent(events, algType, alg, p.getName(), other, clazz, method);\n@@ -140,1 +146,2 @@\n-            String alg, String workingProv, List<String> other) {\n+            String alg, String workingProv, List<String> other, String clazz,\n+            String method) {\n@@ -151,0 +158,1 @@\n+            Events.assertTopFrame(e, clazz, method);\n@@ -155,1 +163,0 @@\n-\n","filename":"test\/jdk\/jdk\/jfr\/event\/security\/TestSecurityProviderServiceEvent.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-            recording.enable(EventNames.TLSHandshake);\n+            recording.enable(EventNames.TLSHandshake).withStackTrace();\n@@ -66,0 +66,4 @@\n+                var method = e.getStackTrace().getFrames().get(0).getMethod();\n+                if (method.getName().equals(\"recordEvent\")) {\n+                    throw new Exception(\"Didn't expected recordEvent as top frame\");\n+                }\n","filename":"test\/jdk\/jdk\/jfr\/event\/security\/TestTLSHandshakeEvent.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        Asserts.assertEquals(JVM.getStackTraceId(Integer.MAX_VALUE), 0L, \"Insane skip level \"\n+        Asserts.assertEquals(JVM.getStackTraceId(Integer.MAX_VALUE, -1), 0L, \"Insane skip level \"\n@@ -67,1 +67,1 @@\n-        return JVM.getStackTraceId(0);\n+        return JVM.getStackTraceId(0, -1);\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestGetStackTraceId.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import java.util.HashMap;\n@@ -261,3 +260,3 @@\n-        String[] nssLibDirs = getNssLibPaths(osid);\n-        if (nssLibDirs == null) {\n-            System.out.println(\"Warning: unsupported OS: \" + osid\n+        String nssLibDir = fetchNssLib(osid);\n+        if (nssLibDir == null) {\n+            throw new SkippedException(\"Warning: unsupported OS: \" + osid\n@@ -265,5 +264,0 @@\n-            return null;\n-        }\n-        if (nssLibDirs.length == 0) {\n-            System.out.println(\"Warning: NSS not supported on this platform, skipping test\");\n-            return null;\n@@ -272,11 +266,4 @@\n-        Path nssLibPath = null;\n-        for (String dir : nssLibDirs) {\n-            Path libPath = Paths.get(dir).resolve(System.mapLibraryName(library));\n-            if (Files.exists(libPath)) {\n-                nssLibPath = libPath;\n-                break;\n-            }\n-        }\n-        if (nssLibPath == null) {\n-            System.out.println(\"Warning: can't find NSS library on this machine, skipping test\");\n-            return null;\n+        String libraryName = System.mapLibraryName(library);\n+        Path libPath = Paths.get(nssLibDir).resolve(libraryName);\n+        if (!Files.exists(libPath)) {\n+            throw new SkippedException(\"NSS library \\\"\" + libraryName + \"\\\" was not found in \" + nssLibDir);\n@@ -284,1 +271,2 @@\n-        return nssLibPath;\n+\n+        return libPath;\n@@ -608,67 +596,0 @@\n-    \/\/ Location of the NSS libraries on each supported platform\n-    private static Map<String, String[]> getOsMap() {\n-        if (osMap != null) {\n-            return osMap;\n-        }\n-\n-        osMap = new HashMap<>();\n-        osMap.put(\"Linux-i386-32\", new String[]{\n-                \"\/usr\/lib\/i386-linux-gnu\/\",\n-                \"\/usr\/lib32\/\",\n-                \"\/usr\/lib\/\"});\n-        osMap.put(\"Linux-amd64-64\", new String[]{\n-                \"\/usr\/lib\/x86_64-linux-gnu\/\",\n-                \"\/usr\/lib\/x86_64-linux-gnu\/nss\/\",\n-                \"\/usr\/lib64\/\"});\n-        osMap.put(\"Linux-ppc64-64\", new String[]{\"\/usr\/lib64\/\"});\n-        osMap.put(\"Linux-ppc64le-64\", new String[]{\n-                 \"\/usr\/lib\/powerpc64le-linux-gnu\/\",\n-                 \"\/usr\/lib\/powerpc64le-linux-gnu\/nss\/\",\n-                 \"\/usr\/lib64\/\"});\n-        osMap.put(\"Linux-s390x-64\", new String[]{\"\/usr\/lib64\/\"});\n-        osMap.put(\"Windows-x86-32\", new String[]{});\n-        osMap.put(\"Windows-amd64-64\", new String[]{});\n-        osMap.put(\"MacOSX-x86_64-64\", new String[]{});\n-        osMap.put(\"Linux-arm-32\", new String[]{\n-                \"\/usr\/lib\/arm-linux-gnueabi\/nss\/\",\n-                \"\/usr\/lib\/arm-linux-gnueabihf\/nss\/\"});\n-        osMap.put(\"Linux-aarch64-64\", new String[] {\n-                \"\/usr\/lib\/aarch64-linux-gnu\/\",\n-                \"\/usr\/lib\/aarch64-linux-gnu\/nss\/\",\n-                \"\/usr\/lib64\/\" });\n-        return osMap;\n-    }\n-\n-    private static String[] getNssLibPaths(String osId) {\n-        String[] preferablePaths = getPreferableNssLibPaths(osId);\n-        if (preferablePaths.length != 0) {\n-            return preferablePaths;\n-        } else {\n-            return getOsMap().get(osId);\n-        }\n-    }\n-\n-    private static String[] getPreferableNssLibPaths(String osId) {\n-        List<String> nssLibPaths = new ArrayList<>();\n-\n-        String customNssLibPaths = System.getProperty(\"test.nss.lib.paths\");\n-        if (customNssLibPaths == null) {\n-            \/\/ If custom local NSS lib path is not provided,\n-            \/\/ try to download NSS libs from artifactory\n-            String path = fetchNssLib(osId);\n-            if (path != null) {\n-                nssLibPaths.add(path);\n-            }\n-        } else {\n-            String[] paths = customNssLibPaths.split(\",\");\n-            for (String path : paths) {\n-                if (!path.endsWith(File.separator)) {\n-                    nssLibPaths.add(path + File.separator);\n-                } else {\n-                    nssLibPaths.add(path);\n-                }\n-            }\n-        }\n-\n-        return nssLibPaths.toArray(new String[0]);\n-    }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":9,"deletions":88,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -7,3 +7,5 @@\n-1. Specified by system property test.nss.lib.paths\n-System property test.nss.lib.paths can specify a set of absolute paths to\n-the local NSS library directories. The paths are separated by comma.\n+1. Specified by system property jdk.test.lib.artifacts.<NAME>\n+The system property, jdk.test.lib.artifacts.<NAME>, can specify an absolute path\n+to the local NSS library directory. The <NAME> component should be replaced with\n+the name element of the appropriate @Artifact class.\n+(See `test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java`)\n@@ -12,3 +14,2 @@\n-If the value of system property test.nss.lib.paths is not set, the tests will try\n-to download pre-built NSS libraries from artifactory server. Currently, the\n-tests only looks for libraries for Windows and MacOSX platforms on artifactory.\n+If the value of system property jdk.test.lib.artifacts.<NAME> is not set, the\n+tests will try to download pre-built NSS libraries from artifactory server.\n","filename":"test\/jdk\/sun\/security\/pkcs11\/README","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,3 +61,4 @@\n-        Files.copy(dbPath.resolve(\"cert8.db\"), Paths.get(\"cert8.db\"));\n-        Files.copy(dbPath.resolve(\"key3.db\"), Paths.get(\"key3.db\"));\n-        Files.copy(dbPath.resolve(\"secmod.db\"), Paths.get(\"secmod.db\"));\n+        Path destDir = Path.of( \"tmpdb\");\n+        Files.createDirectory(destDir);\n+        Files.copy(dbPath.resolve(\"cert9.db\"), destDir.resolve(\"cert9.db\"));\n+        Files.copy(dbPath.resolve(\"key4.db\"), destDir.resolve(\"key4.db\"));\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/NssTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-nssArgs = \"configdir='.' certPrefix='' keyPrefix='' secmod='secmod.db'\"\n+nssArgs = \"configdir='sql:.\/tmpdb' certPrefix='' keyPrefix='' secmod='secmod.db'\"\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/p11-nss.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,5 @@\n+    final public AdditionalLauncher setVerifyUninstalled(boolean value) {\n+        verifyUninstalled = value;\n+        return this;\n+    }\n+\n@@ -144,0 +149,7 @@\n+        if (verifyUninstalled) {\n+            test.addUninstallVerifier(this::verifyUninstalled);\n+        }\n+    }\n+\n+    final public void verifyRemovedInUpgrade(PackageTest test) {\n+        test.addInstallVerifier(this::verifyUninstalled);\n@@ -321,0 +333,29 @@\n+    private void verifyInstalled(JPackageCommand cmd, boolean installed) throws IOException {\n+        if (TKit.isLinux() && !cmd.isImagePackageType() && !cmd.\n+                isPackageUnpacked(String.format(\n+                        \"Not verifying package and system .desktop files for [%s] launcher\",\n+                        cmd.appLauncherPath(name)))) {\n+            Path packageDesktopFile = LinuxHelper.getDesktopFile(cmd, name);\n+            Path systemDesktopFile = LinuxHelper.getSystemDesktopFilesFolder().\n+                    resolve(packageDesktopFile.getFileName());\n+            if (Files.exists(packageDesktopFile) && installed) {\n+                TKit.assertFileExists(systemDesktopFile);\n+                TKit.assertStringListEquals(Files.readAllLines(\n+                        packageDesktopFile),\n+                        Files.readAllLines(systemDesktopFile), String.format(\n+                        \"Check [%s] and [%s] files are equal\",\n+                        packageDesktopFile,\n+                        systemDesktopFile));\n+            } else {\n+                TKit.assertPathExists(packageDesktopFile, false);\n+                TKit.assertPathExists(systemDesktopFile, false);\n+            }\n+        }\n+    }\n+\n+    protected void verifyUninstalled(JPackageCommand cmd) throws IOException {\n+        verifyInstalled(cmd, false);\n+        Path launcherPath = cmd.appLauncherPath(name);\n+        TKit.assertPathExists(launcherPath, false);\n+    }\n+\n@@ -325,0 +366,1 @@\n+        verifyInstalled(cmd, true);\n@@ -397,0 +439,1 @@\n+    private boolean verifyUninstalled;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -891,4 +891,11 @@\n-        try ( Stream<Path> walk = ThrowingSupplier.toSupplier(() -> Files.walk(\n-                rootDir)).get()) {\n-            List<String> files = walk.filter(path -> path.getFileName().equals(\n-                    filename)).map(Path::toString).toList();\n+        try ( Stream<Path> walk = ThrowingSupplier.toSupplier(() -> {\n+            if (TKit.isLinux() && rootDir.equals(Path.of(\"\/\"))) {\n+                \/\/ Installed package with split app image on Linux. Iterate\n+                \/\/ through package file list instead of the entire file system.\n+                return LinuxHelper.getPackageFiles(this);\n+            } else {\n+                return Files.walk(rootDir);\n+            }\n+        }).get()) {\n+            List<String> files = walk.filter(path -> filename.equals(\n+                    path.getFileName())).map(Path::toString).toList();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.nio.file.FileSystemException;\n@@ -33,0 +34,1 @@\n+import java.util.function.Consumer;\n@@ -61,0 +63,5 @@\n+        public Builder setAdditionalLauncherCallback(Consumer<AdditionalLauncher> v) {\n+            additionalLauncherCallback = v;\n+            return this;\n+        }\n+\n@@ -64,1 +71,2 @@\n-                    expectedValue);\n+                    expectedValue,\n+                    launcherName != null ? additionalLauncherCallback : null);\n@@ -75,0 +83,1 @@\n+        private Consumer<AdditionalLauncher> additionalLauncherCallback;\n@@ -83,1 +92,2 @@\n-            String expectedArgValue) {\n+            String expectedArgValue,\n+            Consumer<AdditionalLauncher> additionalLauncherCallback) {\n@@ -87,0 +97,1 @@\n+        this.additionalLauncherCallback = additionalLauncherCallback;\n@@ -236,1 +247,1 @@\n-                TKit.deleteIfExists(outputFilePath);\n+                deleteOutputFile(outputFilePath);\n@@ -245,1 +256,1 @@\n-        new AdditionalLauncher(launcherName) {\n+        AdditionalLauncher al = new AdditionalLauncher(launcherName) {\n@@ -251,1 +262,1 @@\n-                    TKit.deleteIfExists(appOutputFilePathVerify(cmd));\n+                    deleteOutputFile(appOutputFilePathVerify(cmd));\n@@ -259,2 +270,20 @@\n-                .addDefaultArguments(expectedValue)\n-                .applyTo(pkg);\n+                .addDefaultArguments(expectedValue);\n+\n+        Optional.ofNullable(additionalLauncherCallback).ifPresent(v -> v.accept(al));\n+\n+        al.applyTo(pkg);\n+    }\n+\n+    private static void deleteOutputFile(Path file) throws IOException {\n+        try {\n+            TKit.deleteIfExists(file);\n+        } catch (FileSystemException ex) {\n+            if (TKit.isLinux() || TKit.isOSX()) {\n+                \/\/ Probably \"Operation no permitted\" error. Try with \"sudo\" as the\n+                \/\/ file is created by a launcher started under root account.\n+                Executor.of(\"sudo\", \"rm\", \"-f\").addArgument(file.toString()).\n+                        execute();\n+            } else {\n+                throw ex;\n+            }\n+        }\n@@ -340,0 +369,1 @@\n+    private final Consumer<AdditionalLauncher> additionalLauncherCallback;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherAsServiceVerifier.java","additions":38,"deletions":8,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -467,1 +467,1 @@\n-    private static Path getSystemDesktopFilesFolder() {\n+    static Path getSystemDesktopFilesFolder() {\n@@ -561,1 +561,0 @@\n-                .filter(str -> str.startsWith(xdgCmdName))\n@@ -565,0 +564,2 @@\n+            scriptletBodyStream = scriptletBodyStream.filter(str -> str.\n+                    startsWith(xdgCmdName));\n@@ -567,0 +568,4 @@\n+        } else {\n+            scriptletBodyStream = scriptletBodyStream.filter(str -> str.\n+                    contains(xdgCmdName)).filter(str -> str.startsWith(\n+                    \"do_if_file_belongs_to_single_package\"));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.LauncherAsServiceVerifier;\n+import jdk.jpackage.test.TKit;\n+\n+\/**\n+ * Test how services and desktop integration align together in the same package.\n+ * On Linux these features share common code in custom actions (common_utils.sh).\n+ * Test correctness of integration of this code.\n+ *\n+ * The test is not intended to be executed by SQE. It is for internal use only\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with desktop integration and services on Linux\n+ * @library ..\/helpers\n+ * @key jpackagePlatformPackage\n+ * @requires jpackage.test.SQETest == null\n+ * @build jdk.jpackage.test.*\n+ * @requires (os.family == \"linux\")\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile ServiceAndDesktopTest.java\n+ * @run main\/othervm\/timeout=720 jdk.jpackage.test.Main\n+ *  --jpt-run=ServiceAndDesktopTest\n+ *\/\n+\n+public class ServiceAndDesktopTest {\n+\n+    @Test\n+    public static void test() {\n+        var pkg = new PackageTest()\n+                .configureHelloApp()\n+                .addBundleDesktopIntegrationVerifier(true)\n+                .addInitializer(cmd -> {\n+                    \/\/ Want a .desktop file for the main launcher\n+                    cmd.addArguments(\"--icon\", GOLDEN_ICON.toString());\n+                });\n+        LauncherAsServiceVerifier.build().setLauncherName(\"foo\").\n+                setExpectedValue(\"Fun\").setAdditionalLauncherCallback(al -> {\n+                    \/\/ Don't want .desktop file for service launcher\n+                    al.setNoIcon();\n+                }).applyTo(pkg);\n+        pkg.run();\n+    }\n+\n+    private final static Path GOLDEN_ICON = TKit.TEST_SRC_ROOT.resolve(Path.of(\n+            \"resources\", \"icon\" + TKit.ICON_SUFFIX));\n+}\n","filename":"test\/jdk\/tools\/jpackage\/linux\/ServiceAndDesktopTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Map;\n+import java.nio.file.Path;\n+import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary Linux upgrade testing\n+ * @library ..\/helpers\n+ * @key jpackagePlatformPackage\n+ * @build jdk.jpackage.test.*\n+ * @requires (os.family == \"linux\")\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile UpgradeTest.java\n+ * @run main\/othervm\/timeout=360 jdk.jpackage.test.Main\n+ *  --jpt-run=UpgradeTest\n+ *\/\n+public class UpgradeTest {\n+\n+    @Test\n+    public void testDesktopFiles() {\n+        \/\/ Create two packages with the same name but different versions.\n+        \/\/ The first will have `launcherA`, and `launcherB` additional launchers.\n+        \/\/ The second will have `launcherB`, and `launcherC` additional launchers.\n+        \/\/ Launchers are configured in a way to have correpsonding .desktop files.\n+        \/\/ These files will be installed in system directories.\n+        \/\/ After the upgrade `launcherA`-related files must be deleted and\n+        \/\/ `launcherB`-related files from the first package must be replaced with\n+        \/\/ the files from the second package.\n+        \/\/ Checks that correct files are installed in system directories\n+        \/\/ encapsulated in AdditionalLauncher class.\n+\n+        var pkg = createPackageTest().disablePackageUninstaller();\n+\n+        var alA = createAdditionalLauncher(\"launcherA\");\n+\n+        alA.applyTo(pkg);\n+        createAdditionalLauncher(\"launcherB\").addRawProperties(Map.entry(\n+                \"description\", \"Foo\")).applyTo(pkg);\n+\n+        var pkg2 = createPackageTest().addInitializer(cmd -> {\n+            cmd.addArguments(\"--app-version\", \"2.0\");\n+        });\n+\n+        alA.verifyRemovedInUpgrade(pkg2);\n+        createAdditionalLauncher(\"launcherB\").addRawProperties(Map.entry(\n+                \"description\", \"Bar\")).applyTo(pkg2);\n+        createAdditionalLauncher(\"launcherC\").applyTo(pkg2);\n+\n+        new PackageTest.Group(pkg, pkg2).run();\n+    }\n+\n+    private static PackageTest createPackageTest() {\n+        return new PackageTest().configureHelloApp().addInitializer(\n+                JPackageCommand::setInputToEmptyDirectory).addInitializer(\n+                        JPackageCommand::setFakeRuntime).\n+                addBundleDesktopIntegrationVerifier(true);\n+    }\n+\n+    private static AdditionalLauncher createAdditionalLauncher(String name) {\n+        \/\/ Configure additionl launcher in a way to trigger jpackage create\n+        \/\/ corresponding .desktop file.\n+        return new AdditionalLauncher(name).setIcon(GOLDEN_ICON);\n+    }\n+\n+    private final static Path GOLDEN_ICON = TKit.TEST_SRC_ROOT.resolve(Path.of(\n+            \"resources\", \"icon\" + TKit.ICON_SUFFIX));\n+}\n","filename":"test\/jdk\/tools\/jpackage\/linux\/UpgradeTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacAppStoreJlinkOptionsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,2 +115,2 @@\n-                    s or interface in java.util\" class=\"external-link\"><code>Link to generic type with \\\n-                    label<\/code><\/a><\/li>\n+                    s or interface in java.util\" class=\"external-link\">Link to generic type with label<\\\n+                    \/a><\/li>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testGenericTypeLink\/TestGenericTypeLink.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,0 +114,2 @@\n+        } else {\n+            failed(\"Did not find all expected files\");\n@@ -171,1 +173,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLegalNotices\/TestLegalNotices.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-                    <li><a href=\"..\/p2\/Class2.html#class2main\"><code>See main heading in p2.Class2<\/code><\/a><\/li>\n-                    <li><a href=\"..\/p2\/package-summary.html#package-p2-heading\"><code>See heading in p2<\/code><\/a><\/li>\n+                    <li><a href=\"..\/p2\/Class2.html#class2main\">See main heading in p2.Class2<\/a><\/li>\n+                    <li><a href=\"..\/p2\/package-summary.html#package-p2-heading\">See heading in p2<\/a><\/li>\n@@ -92,1 +92,1 @@\n-                    <a href=\"Class2.html#class2-sub-heading\"><code>See sub heading in p2.Class2<\/code><\/a>\"\"\");\n+                    <a href=\"Class2.html#class2-sub-heading\">See sub heading in p2.Class2<\/a>\"\"\");\n@@ -98,1 +98,1 @@\n-                    <a href=\"..\/Class2.html#class2main\"><code>See main heading in p2.ClassB<\/code><\/a>\"\"\");\n+                    <a href=\"..\/Class2.html#class2main\">See main heading in p2.ClassB<\/a>\"\"\");\n@@ -114,1 +114,1 @@\n-                    <a href=\"..\/m2\/com\/m2\/Class2.html#main-heading\"><code>See main heading in Class2<\/code><\/a>\"\"\");\n+                    <a href=\"..\/m2\/com\/m2\/Class2.html#main-heading\">See main heading in Class2<\/a>\"\"\");\n@@ -119,2 +119,2 @@\n-                    <li><a href=\"..\/..\/..\/m2\/com\/m2\/Class2.html#main-heading\"><code>See main heading in Class2<\/code><\/a><\/li>\n-                    <li><a href=\"..\/..\/module-summary.html#module-m1-heading\"><code>See heading in module m1<\/code><\/a><\/li>\n+                    <li><a href=\"..\/..\/..\/m2\/com\/m2\/Class2.html#main-heading\">See main heading in Class2<\/a><\/li>\n+                    <li><a href=\"..\/..\/module-summary.html#module-m1-heading\">See heading in module m1<\/a><\/li>\n@@ -131,1 +131,1 @@\n-                    <li><a href=\"..\/..\/m1\/module-summary.html#module-m1-heading\"><code>Heading in module m1<\/code><\/a><\/li>\"\"\");\n+                    <li><a href=\"..\/..\/m1\/module-summary.html#module-m1-heading\">Heading in module m1<\/a><\/li>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSeeLinkAnchor\/TestSeeLinkAnchor.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-                <li><a href=\"Test.InnerOne.html#baz(float)\"><code>something<\/code><\/a><\/li>\n+                <li><a href=\"Test.InnerOne.html#baz(float)\">something<\/a><\/li>\n@@ -83,1 +83,1 @@\n-                <li><a href=\"Test.html\" title=\"class in pkg\"><code>See tag with very long label text<\/code><\/a><\/li>\n+                <li><a href=\"Test.html\" title=\"class in pkg\">See tag with very long label text<\/a><\/li>\n@@ -216,3 +216,3 @@\n-                    <li><a href=\"#noArgs()\"><code>no args<\/code><\/a><\/li>\n-                    <li><a href=\"#oneArg(int)\"><code>one arg<\/code><\/a><\/li>\n-                    <li><a href=\"#twoArgs(int,int)\"><code>two args<\/code><\/a><\/li>\n+                    <li><a href=\"#noArgs()\">no args<\/a><\/li>\n+                    <li><a href=\"#oneArg(int)\">one arg<\/a><\/li>\n+                    <li><a href=\"#twoArgs(int,int)\">two args<\/a><\/li>\n@@ -224,3 +224,3 @@\n-                    <li><a href=\"#noArgs()\"><code>no args<\/code><\/a><\/li>\n-                    <li><a href=\"#oneArg(int)\"><code>one arg<\/code><\/a><\/li>\n-                    <li><a href=\"#twoArgs(int,int)\"><code>two args with a comma , in the description<\/code><\/a><\/li>\n+                    <li><a href=\"#noArgs()\">no args<\/a><\/li>\n+                    <li><a href=\"#oneArg(int)\">one arg<\/a><\/li>\n+                    <li><a href=\"#twoArgs(int,int)\">two args with a comma , in the description<\/a><\/li>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSeeTag\/TestSeeTag.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8320207\n+ * @summary  doclet incorrectly chooses code font for a See Also link\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestSeeTagFont\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestSeeTagFont extends JavadocTester {\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestSeeTagFont();\n+        tester.runTests();\n+    }\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testPlain(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    import p2.Other;\n+                    \/**\n+                     * Description.\n+                     * @see Other multi-word phrase\n+                     * @see Other <em>Other<\/em>\n+                     * @see Other Other() with trailing text\n+                     * @see Other simpleNameMismatch\n+                     *\n+                     * @see Other#Other() multi-word phrase\n+                     * @see Other#Other() Other#Other() with trailing text\n+                     * @see Other#Other() simpleNameMismatch\n+                     *\n+                     * @see Other#m() <code>Other.m<\/code> with formatting and trailing text\n+                     *\/\n+                    public class C { }\n+                    \"\"\",\n+                \"\"\"\n+                    package p2;\n+                    \/** Lorem ipsum. *\/\n+                    public class Other {\n+                        \/** Lorem ipsum. *\/\n+                        public void m() { }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"-sourcepath\", src.toString(),\n+                \"p\", \"p2\");\n+        checkExit(Exit.OK);\n+\n+        \/\/ none of the following should contain <code>...<\/code>\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                        <ul class=\"tag-list-long\">\n+                        <li><a href=\"..\/p2\/Other.html\" title=\"class in p2\">multi-word phrase<\/a><\/li>\n+                        <li><a href=\"..\/p2\/Other.html\" title=\"class in p2\"><em>Other<\/em><\/a><\/li>\n+                        <li><a href=\"..\/p2\/Other.html\" title=\"class in p2\">Other() with trailing text<\/a><\/li>\n+                        <li><a href=\"..\/p2\/Other.html\" title=\"class in p2\">simpleNameMismatch<\/a><\/li>\n+                        <li><a href=\"..\/p2\/Other.html#%3Cinit%3E()\">multi-word phrase<\/a><\/li>\n+                        <li><a href=\"..\/p2\/Other.html#%3Cinit%3E()\">Other#Other() with trailing text<\/a><\/li>\n+                        <li><a href=\"..\/p2\/Other.html#%3Cinit%3E()\">simpleNameMismatch<\/a><\/li>\n+                        <li><a href=\"..\/p2\/Other.html#m()\"><code>Other.m<\/code> with formatting and trailing text<\/a><\/li>\n+                        <\/ul>\n+                        \"\"\");\n+    }\n+\n+    @Test\n+    public void testCode(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    import p2.Other;\n+                    \/**\n+                     * Description.\n+                     * @see Other\n+                     * @see p2.Other Other\n+                     *\n+                     * @see Other#Other() Other\n+                     * @see Other#m() m\n+                     * @see Other#m() Other.m\n+                     *\/\n+                    public class C { }\n+                    \"\"\",\n+                \"\"\"\n+                    package p2;\n+                    \/** Lorem ipsum. *\/\n+                    public class Other {\n+                        \/** Lorem ipsum. *\/\n+                        public void m() { }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"api\").toString(),\n+                \"-Xdoclint:none\",\n+                \"-sourcepath\", src.toString(),\n+                \"p\", \"p2\");\n+        checkExit(Exit.OK);\n+\n+        \/\/ all of the following should contain <code>...<\/code>\n+        checkOutput(\"p\/C.html\", true,\n+                \"\"\"\n+                    <ul class=\"tag-list\">\n+                    <li><a href=\"..\/p2\/Other.html\" title=\"class in p2\"><code>Other<\/code><\/a><\/li>\n+                    <li><a href=\"..\/p2\/Other.html\" title=\"class in p2\"><code>Other<\/code><\/a><\/li>\n+                    <li><a href=\"..\/p2\/Other.html#%3Cinit%3E()\"><code>Other<\/code><\/a><\/li>\n+                    <li><a href=\"..\/p2\/Other.html#m()\"><code>m<\/code><\/a><\/li>\n+                    <li><a href=\"..\/p2\/Other.html#m()\"><code>Other.m<\/code><\/a><\/li>\n+                    <\/ul>\n+                    \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSeeTag\/TestSeeTagFont.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -67,0 +67,1 @@\n+                .executionEngine(Presets.TEST_DEFAULT_EXECUTION)\n","filename":"test\/langtools\/jdk\/jshell\/AnalyzeSnippetTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -93,1 +93,2 @@\n-                    .start(\"--no-startup\");\n+                    .start(\"--no-startup\",\n+                           \"--execution\", Presets.TEST_DEFAULT_EXECUTION);\n","filename":"test\/langtools\/jdk\/jshell\/CustomInputToolBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.net.InetAddress;\n@@ -35,15 +34,2 @@\n-    String standardListenSpec() {\n-        String loopback = InetAddress.getLoopbackAddress().getHostAddress();\n-        return \"jdi:hostname(\" + loopback + \")\";\n-    }\n-\n-    String standardLaunchSpec() {\n-        return \"jdi:launch(true)\";\n-    }\n-\n-    String standardJdiSpec() {\n-        return \"jdi\";\n-    }\n-\n-    String standardSpecs() {\n-        return \"5(\" + standardListenSpec() + \"), 6(\" + standardLaunchSpec() + \"), 7(\" + standardJdiSpec() + \")\";\n+    String alwaysPassingSpec() {\n+        return \"5(local)\";\n","filename":"test\/langtools\/jdk\/jshell\/ExecutionControlTestBase.java","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,3 +132,1 @@\n-        pm.put(\"2\", standardListenSpec());\n-        pm.put(\"3\", standardLaunchSpec());\n-        pm.put(\"4\", standardJdiSpec());\n+        pm.put(\"2\", \"local\");\n@@ -162,3 +160,1 @@\n-                log.contains(\"Success failover -- 2 = \" + standardListenSpec())\n-                || log.contains(\"Success failover -- 3 = \" + standardLaunchSpec())\n-                || log.contains(\"Success failover -- 4 = \" + standardJdiSpec()),\n+                log.contains(\"Success failover -- 2 = local\"),\n","filename":"test\/langtools\/jdk\/jshell\/FailOverDirectExecutionControlTest.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-                    + standardSpecs()));\n+                    + alwaysPassingSpec()));\n","filename":"test\/langtools\/jdk\/jshell\/FailOverExecutionControlDyingLaunchTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-                        + standardSpecs()));\n+                        + alwaysPassingSpec()));\n","filename":"test\/langtools\/jdk\/jshell\/FailOverExecutionControlHangingLaunchTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-                        + standardSpecs()));\n+                        + alwaysPassingSpec()));\n","filename":"test\/langtools\/jdk\/jshell\/FailOverExecutionControlHangingListenTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-                + standardSpecs()));\n+                + alwaysPassingSpec()));\n","filename":"test\/langtools\/jdk\/jshell\/FailOverExecutionControlTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-                .err(new PrintStream(errStream));\n+                .err(new PrintStream(errStream))\n+                .executionEngine(Presets.TEST_DEFAULT_EXECUTION);\n","filename":"test\/langtools\/jdk\/jshell\/IdGeneratorTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8319311\n+ * @summary Tests JdiStarter\n+ * @modules jdk.jshell\/jdk.jshell jdk.jshell\/jdk.jshell.spi jdk.jshell\/jdk.jshell.execution\n+ * @run testng JdiStarterTest\n+ *\/\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import org.testng.annotations.Test;\n+import jdk.jshell.JShell;\n+import jdk.jshell.SnippetEvent;\n+import jdk.jshell.execution.JdiDefaultExecutionControl.JdiStarter;\n+import jdk.jshell.execution.JdiDefaultExecutionControl.JdiStarter.TargetDescription;\n+import jdk.jshell.execution.JdiExecutionControlProvider;\n+import jdk.jshell.execution.JdiInitiator;\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class JdiStarterTest {\n+\n+    public void jdiStarter() {\n+        \/\/ turn on logging of launch failures\n+        Logger.getLogger(\"jdk.jshell.execution\").setLevel(Level.ALL);\n+        JdiStarter starter = (env, parameters, port) -> {\n+            assertEquals(parameters.get(JdiExecutionControlProvider.PARAM_HOST_NAME), \"\");\n+            assertEquals(parameters.get(JdiExecutionControlProvider.PARAM_LAUNCH), \"false\");\n+            assertEquals(parameters.get(JdiExecutionControlProvider.PARAM_REMOTE_AGENT), \"jdk.jshell.execution.RemoteExecutionControl\");\n+            assertEquals(parameters.get(JdiExecutionControlProvider.PARAM_TIMEOUT), \"5000\");\n+            JdiInitiator jdii =\n+                    new JdiInitiator(port,\n+                                     env.extraRemoteVMOptions(),\n+                                     \"jdk.jshell.execution.RemoteExecutionControl\",\n+                                     false,\n+                                     null,\n+                                     5000,\n+                                     Collections.emptyMap());\n+            return new TargetDescription(jdii.vm(), jdii.process());\n+        };\n+        JShell jshell =\n+                JShell.builder()\n+                      .executionEngine(new JdiExecutionControlProvider(starter), Map.of())\n+                      .build();\n+        List<SnippetEvent> evts = jshell.eval(\"1 + 2\");\n+        assertEquals(1, evts.size());\n+        assertEquals(\"3\", evts.get(0).value());\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/JdiStarterTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -103,1 +103,3 @@\n-        JShell js = JShell.create();\n+        JShell js = JShell.builder()\n+                          .executionEngine(Presets.TEST_DEFAULT_EXECUTION)\n+                          .build();\n@@ -195,1 +197,2 @@\n-                .err(new PrintStream(errStream));\n+                .err(new PrintStream(errStream))\n+                .executionEngine(Presets.TEST_DEFAULT_EXECUTION);\n","filename":"test\/langtools\/jdk\/jshell\/KullaTesting.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.util.*;\n+\n+public class Presets {\n+    public static final String TEST_DEFAULT_EXECUTION;\n+    public static final String TEST_STANDARD_EXECUTION;\n+\n+    static {\n+        String loopback = InetAddress.getLoopbackAddress().getHostAddress();\n+\n+        TEST_DEFAULT_EXECUTION = \"failover:0(jdi:hostname(\" + loopback + \")),\" +\n+                                 \"1(jdi:launch(true)), 2(jdi), 3(local)\";\n+        TEST_STANDARD_EXECUTION = \"failover:0(jdi:hostname(\" + loopback + \")),\" +\n+                                  \"1(jdi:launch(true)), 2(jdi)\";\n+    }\n+\n+    public static String[] addExecutionIfMissing(String[] args) {\n+        if (Arrays.stream(args).noneMatch(Presets::remoteRelatedOption)) {\n+            List<String> augmentedArgs = new ArrayList<>();\n+\n+            augmentedArgs.add(\"--execution\");\n+            augmentedArgs.add(Presets.TEST_DEFAULT_EXECUTION);\n+            augmentedArgs.addAll(List.of(args));\n+\n+            return augmentedArgs.toArray(s -> new String[s]);\n+        }\n+\n+        return args;\n+    }\n+\n+    private static boolean remoteRelatedOption(String option) {\n+        return \"--execution\".equals(option) ||\n+               \"--add-modules\".equals(option) ||\n+               option.startsWith(\"-R\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/Presets.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -307,1 +307,1 @@\n-        testRawRun(locale, args);\n+        testRawRun(locale, Presets.addExecutionIfMissing(args));\n","filename":"test\/langtools\/jdk\/jshell\/ReplToolTesting.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-                    .start(args);\n+                    .start(Presets.addExecutionIfMissing(args));\n","filename":"test\/langtools\/jdk\/jshell\/StartOptionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-        test(\n+        test(new String[] {\"--execution\", Presets.TEST_STANDARD_EXECUTION},\n","filename":"test\/langtools\/jdk\/jshell\/ToolReloadTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,1 +96,2 @@\n-                        .run(\"--no-startup\");\n+                        .run(\"--no-startup\",\n+                             \"--execution\", Presets.TEST_DEFAULT_EXECUTION);\n","filename":"test\/langtools\/jdk\/jshell\/UITesting.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-AnonymousInSuperCallNegTest.java:23:49: compiler.err.cant.ref.before.ctor.called: x\n+AnonymousInSuperCallNegTest.java:23:49: compiler.err.no.encl.instance.of.type.in.scope: AnonymousInSuperCallNegTest.JavacBug\n","filename":"test\/langtools\/tools\/javac\/AnonymousClass\/AnonymousInSuperCallNegTest.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8194743\n+ * @summary Permit additional statements before this\/super in constructors\n+ * @compile\/fail\/ref=SuperInitFails.out -XDrawDiagnostics SuperInitFails.java\n+ * @enablePreview\n+ *\/\n+import java.util.concurrent.atomic.AtomicReference;\n+public class SuperInitFails extends AtomicReference<Object> implements Iterable<Object> {\n+\n+    private int x;\n+\n+\/\/\/ GOOD EXAMPLES\n+\n+    public SuperInitFails() {           \/\/ this should be OK\n+    }\n+\n+    public SuperInitFails(Object x) {\n+        this.x = x.hashCode();          \/\/ this should be OK\n+    }\n+\n+    public SuperInitFails(byte x) {\n+        super();                        \/\/ this should be OK\n+    }\n+\n+    public SuperInitFails(char x) {\n+        this((int)x);                   \/\/ this should be OK\n+    }\n+\n+\/\/\/ FAIL EXAMPLES\n+\n+    {\n+        this(1);                        \/\/ this should FAIL\n+    }\n+\n+    {\n+        super();                        \/\/ this should FAIL\n+    }\n+\n+    void normalMethod1() {\n+        super();                        \/\/ this should FAIL\n+    }\n+\n+    void normalMethod2() {\n+        this();                         \/\/ this should FAIL\n+    }\n+\n+    void normalMethod3() {\n+        Runnable r = () -> super();     \/\/ this should FAIL\n+    }\n+\n+    void normalMethod4() {\n+        Runnable r = () -> this();      \/\/ this should FAIL\n+    }\n+\n+    public SuperInitFails(short x) {\n+        hashCode();                     \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(float x) {\n+        this.hashCode();                \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(int x) {\n+        super.hashCode();               \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(long x) {\n+        SuperInitFails.this.hashCode();      \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(double x) {\n+        SuperInitFails.super.hashCode();     \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(byte[] x) {\n+        {\n+            super();                    \/\/ this should FAIL\n+        }\n+    }\n+\n+    public SuperInitFails(char[] x) {\n+        if (x.length == 0)\n+            return;                     \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(short[] x) {\n+        this.x = x.length;              \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(float[] x) {\n+        System.identityHashCode(this);  \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(int[] x) {\n+        this(this);                     \/\/ this should FAIL\n+    }\n+\n+    public SuperInitFails(long[] x) {\n+        this(Object.this);              \/\/ this should FAIL\n+    }\n+\n+    public SuperInitFails(double[] x) {\n+        Iterable.super.spliterator();   \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(byte[][] x) {\n+        super(new Object() {\n+            {\n+                super();                \/\/ this should FAIL\n+            }\n+        });\n+    }\n+\n+    public SuperInitFails(char[][] x) {\n+        new Inner1();                   \/\/ this should FAIL\n+        super();\n+    }\n+\n+    class Inner1 {\n+    }\n+\n+    record Record1(int value) {\n+        Record1(float x) {              \/\/ this should FAIL\n+        }\n+    }\n+\n+    record Record2(int value) {\n+        Record2(float x) {              \/\/ this should FAIL\n+            super();\n+        }\n+    }\n+\n+    @Override\n+    public java.util.Iterator<Object> iterator() {\n+        return null;\n+    }\n+\n+    public SuperInitFails(short[][] x) {\n+        class Foo {\n+            Foo() {\n+                SuperInitFails.this.hashCode();\n+            }\n+        };\n+        new Foo();                      \/\/ this should FAIL\n+        super();\n+    }\n+\n+    public SuperInitFails(float[][] x) {\n+        Runnable r = () -> {\n+            super();                    \/\/ this should FAIL\n+        };\n+    }\n+\n+    public SuperInitFails(int[][] z) {\n+        super((Runnable)() -> x);       \/\/ this should FAIL\n+    }\n+\n+    public SuperInitFails(long[][] z) {\n+        super(new Inner1());            \/\/ this should FAIL\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+SuperInitFails.java:57:9: compiler.err.cant.ref.before.ctor.called: hashCode()\n+SuperInitFails.java:62:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:67:9: compiler.err.cant.ref.before.ctor.called: super\n+SuperInitFails.java:72:23: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:77:23: compiler.err.cant.ref.before.ctor.called: super\n+SuperInitFails.java:94:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:99:33: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:104:14: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:108:20: compiler.err.not.encl.class: java.lang.Object\n+SuperInitFails.java:112:17: compiler.err.cant.ref.before.ctor.called: super\n+SuperInitFails.java:119:22: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:125:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:133:9: compiler.err.non.canonical.constructor.invoke.another.constructor: SuperInitFails.Record1\n+SuperInitFails.java:138:9: compiler.err.non.canonical.constructor.invoke.another.constructor: SuperInitFails.Record2\n+SuperInitFails.java:154:9: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:165:31: compiler.err.cant.ref.before.ctor.called: x\n+SuperInitFails.java:169:15: compiler.err.cant.ref.before.ctor.called: this\n+SuperInitFails.java:33:13: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:37:14: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:41:14: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:45:13: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:49:33: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:53:32: compiler.err.call.must.only.appear.in.ctor\n+SuperInitFails.java:83:18: compiler.err.ctor.calls.not.allowed.here\n+SuperInitFails.java:89:13: compiler.err.return.before.superclass.initialized\n+SuperInitFails.java:160:18: compiler.err.ctor.calls.not.allowed.here\n+- compiler.note.preview.filename: SuperInitFails.java, DEFAULT\n+- compiler.note.preview.recompile\n+26 errors\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.out","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,480 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8194743\n+ * @summary Test valid placements of super()\/this() in constructors\n+ * @enablePreview\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class SuperInitGood {\n+\n+    SuperInitGood(Object obj) {\n+    }\n+\n+    SuperInitGood(int x) {\n+    }\n+\n+    \/\/ Default constructor provided by compiler\n+    static class Test0 {\n+    }\n+\n+    \/\/ No explicit calls to this()\/super()\n+    static class Test1 {\n+        Test1() {\n+        }\n+        Test1(int a) {\n+            this.hashCode();\n+        }\n+    }\n+\n+    \/\/ Explicit calls to this()\/super()\n+    static class Test2<T> {\n+        static int i;\n+        Test2() {\n+            this(0);\n+        }\n+        Test2(int i) {\n+            Test2.i = i;\n+            super();\n+        }\n+        Test2(T obj) {\n+            this(java.util.Objects.hashCode(obj));\n+        }\n+        public T get() {\n+            return null;\n+        }\n+    }\n+\n+    \/\/ Explicit this()\/super() with stuff in front\n+    static class Test3 {\n+        int x;\n+        final int y;\n+        final int z;\n+\n+        Test3() {\n+            new Object().hashCode();\n+            new Object().hashCode();\n+            super();\n+            this.x = new Object().hashCode();\n+            this.y = new Object().hashCode() % 17;\n+            this.z = this.x + this.y;\n+        }\n+    }\n+\n+    \/\/ Reference within constructor to outer class that's also my superclass\n+    class Test5 extends SuperInitGood {\n+        Test5(Object obj) {\n+            if (obj == null)\n+                throw new IllegalArgumentException();\n+            super(SuperInitGood.this);      \/\/ NOT a 'this' reference\n+        }\n+    }\n+\n+    \/\/ Initialization blocks\n+    class Test6 {\n+        final long startTime;\n+        final int x;\n+        {\n+            this.x = 12;\n+        }\n+        Test6() {\n+            long now = System.nanoTime();\n+            long then = now + 1000000L;\n+            while (System.nanoTime() < then) {\n+                try {\n+                    Thread.sleep(1);\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    break;\n+                }\n+            }\n+            super();\n+            this.startTime = now;\n+        }\n+    }\n+\n+    \/\/ Mix up inner classes, proxies, and super() calls\n+    \/\/ Copied mostly from UnverifiableInitForNestedLocalClassTest.java\n+    public static void test7(final String arg) {\n+        final String inlined = \" inlined \";\n+        class LocalClass {\n+            String m() {\n+                return \"LocalClass \" + arg + inlined;\n+            }\n+\n+            class SubClass extends LocalClass {\n+                @Override\n+                String m() {\n+                    return \"SubClass \" + arg + inlined;\n+                }\n+            }\n+\n+            class SubSubClass extends SubClass {\n+                @Override\n+                String m() {\n+                    return \"SubSubClass \" + arg + inlined;\n+                }\n+            }\n+\n+            class AnotherLocal {\n+                class AnotherSub extends LocalClass {\n+                    AnotherSub() {\n+                    }\n+                    AnotherSub(int x) {\n+                        this((char)x);\n+                    }\n+                    AnotherSub(char y) {\n+                        super();\n+                    }\n+                    @Override\n+                    String m() {\n+                        return \"AnotherSub \" + arg + inlined;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Anonymous inner class\n+    public static void test8() {\n+        new Test2<Byte>(null) {\n+            @Override\n+            public Byte get() {\n+                return (byte)-1;\n+            }\n+        };\n+    }\n+\n+    \/\/ Qualified super() invocation\n+    public static class Test9 extends Test5 {\n+\n+        public Test9(SuperInitGood implicit, Object obj) {\n+            obj.hashCode();\n+            implicit.super(obj);\n+        }\n+    }\n+\n+    \/\/ Copied from WhichImplicitThis6\n+    public static class Test10 {\n+        private int i;\n+        public Test10(int i) {}\n+        public class Sub extends Test10 {\n+            public Sub() {\n+                super(i); \/\/ i is not inherited, so it is the enclosing i\n+            }\n+        }\n+    }\n+\n+    \/\/ Two constructors where only one invokes super()\n+    public static class Test11 {\n+        public Test11() {\n+        }\n+        public Test11(int x) {\n+            super();\n+        }\n+    }\n+\n+    \/\/ Nested version of the previous test\n+    public static class Test12 {\n+        Test12() {\n+            class Sub {\n+                public Sub() {\n+                }\n+                public Sub(int j) {\n+                    super();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Nested super()'s requiring initialization code appended\n+    public static class Test13 extends SuperInitGood {\n+        final int x = new Object().hashCode();\n+        Test13() {\n+            super(new Object() {\n+                public void foo() {\n+                    class Bar {\n+                        final int y = new Object().hashCode();\n+                        Bar() {\n+                            super();\n+                        }\n+                        Bar(int ignored) {\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+    }\n+\n+    \/\/ Initializer in initializer block\n+    public static class Test14 {\n+        final int x;                \/\/ initialized in constructor\n+        final int y;                \/\/ initialized in initialization block\n+        final int z = 13;           \/\/ initialized with intializer value\n+        public Test14() {\n+            this(0);\n+        }\n+        public Test14(boolean z) {\n+            this.x = z ? 1 : 0;\n+        }\n+        public Test14(int x) {\n+            super();\n+            this.x = x;\n+        }\n+        {\n+            this.y = -1;\n+        }\n+    }\n+\n+    \/\/ Qualified super() invocation with superclass instance\n+    public static class Test15 {\n+\n+        final String name;\n+\n+        public Test15(String name) {\n+            this.name = name;\n+        }\n+\n+        public class Test15b extends Test15 {\n+\n+            public Test15b(String name) {\n+                super(name);\n+            }\n+\n+            public String getName() {\n+                return Test15.this.name;\n+            }\n+        }\n+    }\n+\n+    public static class Test15c extends Test15.Test15b {\n+        public Test15c(Test15 a, String name) {\n+            a.super(name);\n+        }\n+    }\n+\n+    \/\/ Mixing up outer instances, proxies, and initializers\n+    public static class Test16 {\n+\n+        final String x = String.valueOf(new Object().hashCode());\n+\n+        public void run() {\n+\n+            final String y = String.valueOf(new Object().hashCode());\n+\n+            class Sub {\n+\n+                final String z;\n+\n+                Sub(String z, int ignored) {\n+                    this(z, (float)ignored);\n+                }\n+\n+                Sub(String z, float ignored) {\n+                    this.z = z;\n+                }\n+\n+                Sub(String z, byte ignored) {\n+                    super();\n+                    this.z = z;\n+                }\n+\n+                Sub(String z, char ignored) {\n+                    this(z, (int)ignored);\n+                }\n+\n+                String x() {\n+                    return x;\n+                }\n+\n+                String y() {\n+                    return y;\n+                }\n+\n+                String z() {\n+                    return z;\n+                }\n+            }\n+\n+            final String z = String.valueOf(new Object().hashCode());\n+\n+            final Sub[] subs = new Sub[] {\n+                new Sub(z, 1),\n+                new Sub(z, -1),\n+                new Sub(z, (float)0),\n+                new Sub(z, (byte)0),\n+                new Sub(z, (char)0)\n+            };\n+\n+            for (int i = 0; i < subs.length; i++) {\n+                \/\/System.err.println(\"i = \" + i);\n+                final Sub sub = subs[i];\n+                final String subx = sub.x();\n+                final String suby = sub.y();\n+                final String subz = sub.z();\n+                if (!x.equals(subx))\n+                    throw new RuntimeException(\"x=\" + x + \" but sub[\" + i + \"].x()=\" + subx);\n+                if (!y.equals(suby))\n+                    throw new RuntimeException(\"y=\" + y + \" but sub[\" + i + \"].y()=\" + suby);\n+                if (!z.equals(subz))\n+                    throw new RuntimeException(\"z=\" + z + \" but sub[\" + i + \"].z()=\" + subz);\n+            }\n+        }\n+    }\n+\n+    \/\/ Records\n+    public class Test17 {\n+\n+        record Rectangle(float length, float width) { }\n+\n+        record StringHolder(String string) {\n+            StringHolder {\n+                java.util.Objects.requireNonNull(string);\n+            }\n+        }\n+\n+        record ValueHolder(int value) {\n+            ValueHolder(float x) {\n+                if (Float.isNaN(x))\n+                    throw new IllegalArgumentException();\n+                this((int)x);\n+            }\n+        }\n+    }\n+\n+    \/\/ Exceptions thrown by initializer block\n+    public static class Test18 extends AtomicReference<Object> {\n+\n+        {\n+            if ((this.get().hashCode() % 3) == 0)\n+                throw new MyException();\n+        }\n+\n+        public Test18(Object obj) throws MyException {\n+            super(obj);\n+        }\n+\n+        public Test18(boolean fail) throws MyException {\n+            Object obj;\n+            for (obj = new Object(); true; obj = new Object()) {\n+                if (((obj.hashCode() % 3) == 0) != fail)\n+                    continue;\n+                break;\n+            }\n+            this(obj);\n+        }\n+\n+        public static class MyException extends Exception {\n+        }\n+    }\n+\n+    \/\/ super()\/this() within outer try block but inside inner class\n+    public static class Test19 {\n+        public Test19(int x) {\n+            try {\n+                new Test1(x) {\n+                    @Override\n+                    public int hashCode() {\n+                        return x ^ super.hashCode();\n+                    }\n+                };\n+            } catch (StackOverflowError e) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    \/\/ local class declared before super(), but not used until after super()\n+    public static class Test20 {\n+        public Test20() {\n+            class Foo {\n+                Foo() {\n+                    Test20.this.hashCode();\n+                }\n+            }\n+            super();\n+            new Foo();\n+        }\n+    }\n+\n+    \/\/ local class inside super() parameter list\n+    public static class Test21 extends AtomicReference<Object> {\n+        private int x;\n+        public Test21() {\n+            super(switch (\"foo\".hashCode()) {\n+                default -> {\n+                    class Nested {{ System.out.println(x); }}       \/\/ class is NOT instantiated - OK\n+                    yield \"bar\";\n+                }\n+            });\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        new Test0();\n+        new Test1();\n+        new Test1(7);\n+        new Test2<Byte>();\n+        new Test2<>(args);\n+        new Test3();\n+        new SuperInitGood(3).new Test5(3);\n+        new SuperInitGood(3).new Test6();\n+        SuperInitGood.test7(\"foo\");\n+        SuperInitGood.test8();\n+        new Test9(new SuperInitGood(5), \"abc\");\n+        new Test10(7);\n+        new Test11(9);\n+        new Test12();\n+        new Test13();\n+        Test14 t14 = new Test14();\n+        assert t14.x == 0 && t14.y == -1 && t14.z == 13;\n+        t14 = new Test14(7);\n+        assert t14.x == 7 && t14.y == -1 && t14.z == 13;\n+        new Test15c(new Test15(\"foo\"), \"bar\");\n+        new Test16().run();\n+        new Test17.StringHolder(\"foo\");\n+        try {\n+            new Test17.StringHolder(null);\n+            throw new Error();\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+        try {\n+            new Test18(true);\n+            assert false : \"expected exception\";\n+        } catch (Test18.MyException e) {\n+            \/\/ expected\n+        }\n+        try {\n+            new Test18(false);\n+        } catch (Test18.MyException e) {\n+            assert false : \"unexpected exception: \" + e;\n+        }\n+        new Test19(123);\n+        new Test20();\n+        new Test21();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitGood.java","additions":480,"deletions":0,"binary":false,"changes":480,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.warn.source.no.system.modules.path: 15\n+- compiler.warn.source.no.system.modules.path: 15, (compiler.misc.source.no.system.modules.path: 15)\n","filename":"test\/langtools\/tools\/javac\/T8222035\/MinContextOpTest_A.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8320001\n+ * @summary javac crashes while adding type annotations to the return type of a constructor\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main TypeAnnosOnConstructorsTest\n+ *\/\n+\n+import java.io.IOException;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import java.util.List;\n+import java.util.Set;\n+import javax.annotation.processing.AbstractProcessor;\n+import javax.annotation.processing.RoundEnvironment;\n+import javax.annotation.processing.SupportedAnnotationTypes;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.TypeElement;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.Task.Mode;\n+import toolbox.Task.OutputKind;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class TypeAnnosOnConstructorsTest extends TestRunner {\n+    protected ToolBox tb;\n+\n+    TypeAnnosOnConstructorsTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new TypeAnnosOnConstructorsTest().runTests();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    Path[] findJavaFiles(Path... paths) throws IOException {\n+        return tb.findJavaFiles(paths);\n+    }\n+\n+    @Test\n+    public void testAnnoOnConstructors(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path y = src.resolve(\"Y.java\");\n+        Path classes = base.resolve(\"classes\");\n+\n+        Files.createDirectories(classes);\n+\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                import java.lang.annotation.Target;\n+                import java.lang.annotation.ElementType;\n+                import java.lang.annotation.Retention;\n+                import java.lang.annotation.RetentionPolicy;\n+\n+                class Y {\n+                    @TA public Y() {}\n+                }\n+\n+                @Target(ElementType.TYPE_USE)\n+                @Retention(RetentionPolicy.RUNTIME)\n+                @interface TA {}\n+                \"\"\");\n+\n+        \/\/ we need to compile Y first\n+        new JavacTask(tb)\n+                .files(y)\n+                .outdir(classes)\n+                .run();\n+\n+        Path classDir = getClassDir();\n+        new JavacTask(tb)\n+                .classpath(classes, classDir)\n+                .options(\"-processor\", SimpleProcessor.class.getName())\n+                .classes(\"Y\")\n+                .outdir(classes)\n+                .run(Task.Expect.SUCCESS);\n+    }\n+\n+    public Path getClassDir() {\n+        String classes = ToolBox.testClasses;\n+        if (classes == null) {\n+            return Paths.get(\"build\");\n+        } else {\n+            return Paths.get(classes);\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    public static final class SimpleProcessor extends AbstractProcessor {\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            return false;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/TypeAnnosOnConstructorsTest.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -144,1 +144,0 @@\n-compiler.warn.preview.feature.use                       # preview feature support: not generated currently\n@@ -210,2 +209,2 @@\n-compiler.warn.source.target.conflict\n-compiler.warn.target.default.source.conflict\n+compiler.err.source.target.conflict\n+compiler.err.target.default.source.conflict\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.call.must.be.first.stmt.in.ctor\n-\n-class CallMustBeFirst {\n-    CallMustBeFirst() {\n-        int i = 0;\n-        super();\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CallMustBeFirst.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.call.must.only.appear.in.ctor\n+\n+class CallOnlyInConstructor {\n+    void foo() {\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CallOnlyInConstructor.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.ctor.calls.not.allowed.here\n+\n+class CallsNotAllowedHere {\n+    public CallsNotAllowedHere() {\n+        {\n+            super();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/CallsNotAllowedHere.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,1 @@\n-\/\/ key: compiler.warn.source.no.system.modules.path\n-\/\/ options: -source 15\n+\/\/ options: --release 15\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/EnumsMustBeStatic.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,1 @@\n-\/\/ key: compiler.warn.source.no.system.modules.path\n-\/\/ options: -source 15\n+\/\/ options: --release 15\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/Expected3.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.misc.feature.super.init\n+ \/\/ key: compiler.warn.preview.feature.use\n+ \/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class FeatureStatementsBeforeSuper {\n+    FeatureStatementsBeforeSuper() {\n+        System.out.println();\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FeatureStatementsBeforeSuper.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-\/\/ key: compiler.err.first.statement.must.be.call.to.another.constructor\n+\/\/ key: compiler.err.non.canonical.constructor.invoke.another.constructor\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FirstInvocationMustBeAnotherConstructor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,1 @@\n-\/\/ key: compiler.warn.source.no.system.modules.path\n-\/\/ options: -source 15\n+\/\/ options: --release 15\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InnerClassCantHaveStatic.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,1 @@\n-\/\/ key: compiler.warn.source.no.system.modules.path\n-\/\/ options: -source 15\n+\/\/ options: --release 15\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InterfaceNotAllowed.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,1 @@\n-\/\/ key: compiler.warn.source.no.system.modules.path\n-\/\/ options: -source 15\n+\/\/ options: --release 15\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/LocalEnum.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+\/\/ key: compiler.misc.source.no.bootclasspath.with.target\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ObsoleteSourceAndTarget.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+\/\/ key: compiler.misc.source.no.bootclasspath\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/OptionRemovedSource.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+\/\/ key: compiler.misc.source.no.bootclasspath.with.target\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/OptionRemovedTarget.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n-\/\/ key: compiler.warn.source.no.system.modules.path\n-\/\/ options: -source 15\n+\/\/ options: --release 15\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/Records.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.redundant.superclass.init\n+\n+class RedundantSuperclassInit {\n+    RedundantSuperclassInit() {\n+        super();\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RedundantSuperclassInit.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.return.before.superclass.initialized\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview -source ${jdk.version}\n+\n+class ReturnBeforeSuperclassInit {\n+    ReturnBeforeSuperclassInit(boolean maybe) {\n+        if (maybe)\n+            return;\n+        super();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ReturnBeforeSuperclassInit.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n-\/\/ key: compiler.warn.source.no.system.modules.path\n-\/\/ options: -source 16\n+\/\/ options: --release 16\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SealedTypes.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\/\/ key: compiler.misc.source.no.bootclasspath\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SourceNoBootclasspath.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\/\/ key: compiler.misc.source.no.system.modules.path\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SourceNoSystemModulesPath.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.source.no.system.modules.path\n+\/\/ key: compiler.misc.source.no.system.modules.path.with.target\n+\/\/ options: -source 9 -target 9\n+\n+class SourceNoSystemModulesPath { }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SourceNoSystemModulesPathWithTarget.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n- \/\/ key: compiler.warn.source.no.system.modules.path\n- \/\/ options: -source 14\n+ \/\/ options: --release 14\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/TextBlockSource.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n-\/\/ key: compiler.warn.source.no.system.modules.path\n-\/\/ options: -source 21\n+\/\/ options: --release 21\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnderscoreInLambdaExpression.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-                \"- compiler.warn.source.no.bootclasspath: 8\",\n+                \"- compiler.warn.source.no.bootclasspath: 8, (compiler.misc.source.no.bootclasspath: 8)\",\n@@ -128,1 +128,1 @@\n-                \"- compiler.warn.source.no.system.modules.path: 9\",\n+                \"- compiler.warn.source.no.system.modules.path: 9, (compiler.misc.source.no.system.modules.path: 9)\",\n","filename":"test\/langtools\/tools\/javac\/options\/BCPOrSystemNotSpecified.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.warn.source.no.bootclasspath: 8\n+- compiler.warn.source.no.bootclasspath: 8, (compiler.misc.source.no.bootclasspath: 8)\n","filename":"test\/langtools\/tools\/javac\/options\/T6900037.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-        doTest(base, String.format(\"warning: source release %s requires target release %s\", Source.DEFAULT.name, Source.DEFAULT.name),\n+        doTest(base, String.format(\"error: specified target release %s is too old for the specified source release %s\", Source.MIN.name, Source.DEFAULT.name),\n@@ -148,1 +148,1 @@\n-        doTest(base, String.format(\"warning: target release %s conflicts with default source release %s\", Source.MIN.name, Source.DEFAULT.name),\n+        doTest(base, String.format(\"error: specified target release %s is too old for the default source release %s\", Source.MIN.name, Source.DEFAULT.name),\n","filename":"test\/langtools\/tools\/javac\/options\/smokeTests\/OptionSmokeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-            var systemModules = targetDir.resolve(\"system-modules\");\n+            var modules = targetDir.resolve(\"modules\");\n@@ -115,1 +115,1 @@\n-            try (Writer w = Files.newBufferedWriter(systemModules)) {}\n+            Files.createDirectories(modules);\n@@ -129,1 +129,2 @@\n-                                               systemModules.toAbsolutePath().toString()});\n+                                               \"\",\n+                                               modules.toAbsolutePath().toString()});\n","filename":"test\/langtools\/tools\/javac\/platform\/CanHandleClassFilesTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318913\n+ * @summary Verify correct module versions are recorded when --release is used.\n+ * @library \/tools\/lib\n+ * @modules\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.platform\n+ *          jdk.compiler\/com.sun.tools.javac.util:+open\n+ * @run junit ModuleVersionTest\n+ *\/\n+\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.ModuleAttribute;\n+import jdk.internal.classfile.attribute.ModuleRequireInfo;\n+\n+import org.junit.Test;\n+\n+import toolbox.JavacTask;\n+import toolbox.ToolBox;\n+\n+import static org.junit.Assert.*;\n+public class ModuleVersionTest {\n+\n+    private static final Pattern VERSION_PATTERN =\n+            Pattern.compile(\"^([0-9]+)(.[0-9]+)*(-.*)?\");\n+\n+    @Test\n+    public void testVersionInDependency() throws Exception {\n+        doTestVersionInDependency(\"11\", \"11\");\n+\n+        String expectedVersion = System.getProperty(\"java.version\");\n+        Matcher m = VERSION_PATTERN.matcher(expectedVersion);\n+\n+        if (m.find()) {\n+            String preRelease = m.group(3);\n+\n+            expectedVersion = m.group(1);\n+\n+            if (preRelease != null) {\n+                expectedVersion += preRelease;\n+            }\n+        }\n+\n+        doTestVersionInDependency(System.getProperty(\"java.specification.version\"), expectedVersion);\n+    }\n+\n+    private void doTestVersionInDependency(String specificationVersion,\n+                                           String expectedVersion) throws Exception {\n+        Path root = Paths.get(\".\");\n+        Path classes = root.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+        ToolBox tb = new ToolBox();\n+\n+        new JavacTask(tb)\n+            .outdir(classes)\n+            .options(\"--release\", specificationVersion)\n+            .sources(\"\"\"\n+                     module test {}\n+                     \"\"\",\n+                     \"\"\"\n+                     package test;\n+                     public class Test {\n+                     }\n+                     \"\"\")\n+            .run()\n+            .writeAll();\n+\n+        Path moduleInfo = classes.resolve(\"module-info.class\");\n+        ClassModel clazz = Classfile.of().parse(moduleInfo);\n+\n+        assertTrue(clazz.isModuleInfo());\n+        ModuleAttribute module = clazz.findAttribute(Attributes.MODULE).get();\n+        ModuleRequireInfo req = module.requires().get(0);\n+        assertEquals(\"java.base\", req.requires().name().stringValue());\n+        assertEquals(expectedVersion, req.requiresVersion().get().stringValue());\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/platform\/ModuleVersionTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318913\n+ * @summary Verify no error is when compiling a class whose permitted types are not exported\n+ * @modules jdk.compiler\n+ * @compile\/fail\/ref=NonExportedPermittedTypes.out -XDrawDiagnostics NonExportedPermittedTypes.java\n+ * @compile\/fail\/ref=NonExportedPermittedTypes.out --release 21 -XDrawDiagnostics NonExportedPermittedTypes.java\n+ * @compile\/fail\/ref=NonExportedPermittedTypes.out --release ${jdk.version} -XDrawDiagnostics NonExportedPermittedTypes.java\n+ *\/\n+\n+\n+import java.lang.constant.ConstantDesc;\n+\n+public class NonExportedPermittedTypes {\n+\n+    public void test1(ConstantDesc cd) {\n+        switch (cd) {\n+            case String s -> {}\n+        }\n+    }\n+\n+    public void test2(ConstantDesc cd) {\n+        switch (cd) {\n+            case String s -> {}\n+            default -> {}\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/platform\/NonExportedPermittedTypes.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+NonExportedPermittedTypes.java:40:9: compiler.err.not.exhaustive.statement\n+1 error\n","filename":"test\/langtools\/tools\/javac\/platform\/NonExportedPermittedTypes.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @compile --release ${jdk.version} NonExportedSuperTypes.java\n","filename":"test\/langtools\/tools\/javac\/platform\/NonExportedSuperTypes.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318913\n+ * @summary Ensure release and enable-preview work well together.\n+ * @modules jdk.compiler\n+ * @compile --release ${jdk.version} --enable-preview ReleaseAndEnablePreview.java\n+ *\/\n+\n+public class ReleaseAndEnablePreview {\n+\n+    public String evt(String str) {\n+        return str.length() + \"\" + str.charAt(0);\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/platform\/ReleaseAndEnablePreview.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -754,1 +754,1 @@\n-        Path systemModules = ctSym.resolve(\"systemModules\");\n+        Path modules = ctSym.resolve(\"modules\");\n@@ -756,1 +756,1 @@\n-        Files.newBufferedWriter(systemModules).close();\n+        Files.createDirectories(modules);\n@@ -761,1 +761,1 @@\n-        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classesZip.toAbsolutePath().toString(), 0, \"9\", systemModules.toString());\n+        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classesZip.toAbsolutePath().toString(), 0, \"9\", \"\", modules.toString());\n@@ -1040,1 +1040,1 @@\n-        Path systemModules = descDest.resolve(\"systemModules\");\n+        Path modules = descDest.resolve(\"modules\");\n@@ -1042,1 +1042,1 @@\n-        Files.newBufferedWriter(systemModules).close();\n+        Files.createDirectories(modules);\n@@ -1045,1 +1045,1 @@\n-        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classDest, 0, \"8\", systemModules.toString());\n+        new CreateSymbols().createSymbols(null, symbolsDesc.toAbsolutePath().toString(), classDest, 0, \"8\", \"\", modules.toString());\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTestImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -406,2 +406,2 @@\n-        \/\/ first invocation should be one to the canonical\n-        assertFail(\"compiler.err.first.statement.must.be.call.to.another.constructor\",\n+        \/\/ constructor is not canonical, so it must only invoke another constructor\n+        assertFail(\"compiler.err.non.canonical.constructor.invoke.another.constructor\",\n@@ -410,1 +410,1 @@\n-        assertFail(\"compiler.err.first.statement.must.be.call.to.another.constructor\",\n+        assertFail(\"compiler.err.non.canonical.constructor.invoke.another.constructor\",\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.warn.source.no.system.modules.path: 10\n+- compiler.warn.source.no.system.modules.path: 10, (compiler.misc.source.no.system.modules.path: 10)\n","filename":"test\/langtools\/tools\/javac\/var_implicit_lambda\/VarInImplicitLambdaNegTest01_source10.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * 8245147 8245586 8257453 8286035 8306586\n+ * 8245147 8245586 8257453 8286035 8306586 8320806\n@@ -275,2 +275,2 @@\n-     * When version of the language get a new, non-preview feature, a\n-     * new source example enum constant should be added.\n+     * When a version of the language gets a new, non-preview feature,\n+     * a new source example enum constant should be added.\n@@ -378,0 +378,14 @@\n+         SOURCE_22(22, \"New22.java\",\n+             \/\/ New feature in 22: Unnamed Variables & Patterns\n+             \"\"\"\n+             public class New22 {\n+                 public static void main(String... args) {\n+                     Object o = new Object(){};\n+\n+                     System.out.println(switch (o) {\n+                                        case Integer _ -> \"Hello world.\";\n+                                        default        -> o.toString();\n+                                        });\n+                 }\n+             }\n+             \"\"\"),\n","filename":"test\/langtools\/tools\/javac\/versions\/Versions.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -368,0 +368,15 @@\n+    public static void assertTopFrame(RecordedEvent event, Class<?> expectedClass, String expectedMethodName) {\n+        assertTopFrame(event, expectedClass.getName(), expectedMethodName);\n+    }\n+\n+    public static void assertTopFrame(RecordedEvent event, String expectedClass, String expectedMethodName) {\n+        RecordedStackTrace stackTrace = event.getStackTrace();\n+        Asserts.assertNotNull(stackTrace, \"Missing stack trace\");\n+        RecordedFrame topFrame =  stackTrace.getFrames().get(0);\n+        if (isFrame(topFrame, expectedClass, expectedMethodName)) {\n+            return;\n+        }\n+        String expected = expectedClass + \"::\" + expectedMethodName;\n+        Asserts.fail(\"Expected top frame \" + expected + \". Found \" + topFrame);\n+    }\n+\n@@ -372,8 +387,2 @@\n-            if (frame.isJavaFrame()) {\n-                RecordedMethod method = frame.getMethod();\n-                RecordedClass type = method.getType();\n-                if (expectedClass.getName().equals(type.getName())) {\n-                    if (expectedMethodName.equals(method.getName())) {\n-                        return;\n-                    }\n-                }\n+            if (isFrame(frame, expectedClass.getName(), expectedMethodName)) {\n+                return;\n@@ -384,0 +393,13 @@\n+\n+    private static boolean isFrame(RecordedFrame frame, String expectedClass, String expectedMethodName) {\n+        if (frame.isJavaFrame()) {\n+            RecordedMethod method = frame.getMethod();\n+            RecordedClass type = method.getType();\n+            if (expectedClass.equals(type.getName())) {\n+                if (expectedMethodName.equals(method.getName())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/Events.java","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -624,0 +624,8 @@\n+    public List<String> stdoutAsLines() {\n+        return asLines(getStdout());\n+    }\n+\n+    public List<String> stderrAsLines() {\n+        return asLines(getStderr());\n+    }\n+\n@@ -789,0 +797,68 @@\n+    private void searchLinesForMultiLinePattern(String[] haystack, String[] needles, boolean verbose) {\n+\n+        if (needles.length == 0) {\n+            return;\n+        }\n+\n+        int firstNeedlePos = 0;\n+        for (int i = 0; i < haystack.length; i++) {\n+            if (verbose) {\n+                System.out.println(\"\" + i + \":\" + haystack[i]);\n+            }\n+            if (haystack[i].contains(needles[0])) {\n+                if (verbose) {\n+                    System.out.println(\"Matches pattern 0 (\\\"\" + needles[0] + \"\\\")\");\n+                }\n+                firstNeedlePos = i;\n+                break;\n+            }\n+        }\n+\n+        for (int i = 1; i < needles.length; i++) {\n+            int haystackPos = firstNeedlePos + i;\n+            if (haystackPos < haystack.length) {\n+                if (verbose) {\n+                    System.out.println(\"\" + haystackPos + \":\" + haystack[haystackPos]);\n+                }\n+                if (haystack[haystackPos].contains(needles[i])) {\n+                    if (verbose) {\n+                        System.out.println(\"Matches pattern \" + i  + \"(\\\"\" + needles[i] + \"\\\")\");\n+                    }\n+                } else {\n+                    String err = \"First unmatched pattern: \" + i + \" (\\\"\" + needles[i] + \"\\\")\";\n+                    if (!verbose) { \/\/ don't print twice\n+                        reportDiagnosticSummary();\n+                    }\n+                    throw new RuntimeException(err);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void stdoutShouldContainMultiLinePattern(String[] needles, boolean verbose) {\n+        String [] stdoutLines = stdoutAsLines().toArray(new String[0]);\n+        searchLinesForMultiLinePattern(stdoutLines, needles, verbose);\n+    }\n+\n+    public void stdoutShouldContainMultiLinePattern(String... needles) {\n+        stdoutShouldContainMultiLinePattern(needles, true);\n+    }\n+\n+    public void stderrShouldContainMultiLinePattern(String[] needles, boolean verbose) {\n+        String [] stderrLines = stdoutAsLines().toArray(new String[0]);\n+        searchLinesForMultiLinePattern(stderrLines, needles, verbose);\n+    }\n+\n+    public void stderrShouldContainMultiLinePattern(String... needles) {\n+        stderrShouldContainMultiLinePattern(needles, true);\n+    }\n+\n+    public void shouldContainMultiLinePattern(String[] needles, boolean verbose) {\n+        String [] lines = asLines().toArray(new String[0]);\n+        searchLinesForMultiLinePattern(lines, needles, verbose);\n+    }\n+\n+    public void shouldContainMultiLinePattern(String... needles) {\n+        shouldContainMultiLinePattern(needles, true);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputAnalyzer.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -525,0 +525,2 @@\n+  public native void cleanMetaspaces();\n+\n@@ -788,0 +790,4 @@\n+  public native void pinObject(Object o);\n+\n+  public native void unpinObject(Object o);\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,1 +84,5 @@\n-    int result = pthread_create(&thread, NULL, procedure, &helper);\n+    pthread_attr_t attr;\n+    pthread_attr_init(&attr);\n+    size_t stack_size = 0x100000;\n+    pthread_attr_setstacksize(&attr, stack_size);\n+    int result = pthread_create(&thread, &attr, procedure, &helper);\n@@ -88,0 +92,1 @@\n+    pthread_attr_destroy(&attr);\n","filename":"test\/lib\/native\/testlib_threads.h","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmark measuring aligned System.arraycopy.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class ArrayCopyAlignedLarge {\n+\n+    @Param({\"100000\", \"1000000\", \"2000000\", \"5000000\", \"10000000\"})\n+    int length;\n+\n+    int fromPos, toPos;\n+    byte[] fromByteArr, toByteArr;\n+\n+    @Setup\n+    public void setup() {\n+        \/\/ Both positions aligned\n+        fromPos = 0;\n+        toPos = 0;\n+\n+        fromByteArr = new byte[length];\n+        toByteArr = new byte[length];\n+    }\n+\n+    @Benchmark\n+    public void testByte() {\n+        System.arraycopy(fromByteArr, fromPos, toByteArr, toPos, length);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ArrayCopyAlignedLarge.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -66,5 +66,5 @@\n-        Arena arena = Arena.ofConfined();\n-        MemorySegment segment = arena.allocate(size);\n-        MemorySegment.copy(arr, start, segment, C_CHAR, 0, size);\n-        arena.close();\n-        return segment;\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(size);\n+            MemorySegment.copy(arr, start, segment, C_CHAR, 0, size);\n+            return segment;\n+        }\n@@ -75,4 +75,3 @@\n-        Arena arena = Arena.ofConfined();\n-        MemorySegment segment = arena.allocateFrom(C_CHAR, MemorySegment.ofArray(arr), C_CHAR, start, size);\n-        arena.close();\n-        return segment;\n+        try (Arena arena = Arena.ofConfined()) {\n+            return arena.allocateFrom(C_CHAR, MemorySegment.ofArray(arr), C_CHAR, start, size);\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocFromSliceTest.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -71,4 +71,3 @@\n-        Arena arena = Arena.ofConfined();\n-        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n-        arena.close();\n-        return segment;\n+        try (Arena arena = Arena.ofConfined()) {\n+            return arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        }\n@@ -79,4 +78,3 @@\n-        MallocArena arena = new MallocArena();\n-        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n-        arena.close();\n-        return segment;\n+        try (MallocArena arena = new MallocArena()) {\n+            return arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        }\n@@ -87,4 +85,3 @@\n-        UnsafeArena arena = new UnsafeArena();\n-        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n-        arena.close();\n-        return segment;\n+        try (UnsafeArena arena = new UnsafeArena()) {\n+            return arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        }\n@@ -95,4 +92,3 @@\n-        Arena arena = pool.acquire();\n-        MemorySegment segment = arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n-        arena.close();\n-        return segment;\n+        try (Arena arena = pool.acquire()) {\n+            return arena.allocateFrom(ValueLayout.JAVA_BYTE, arr);\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocFromTest.java","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -68,4 +68,3 @@\n-        Arena arena = Arena.ofConfined();\n-        MemorySegment segment = arena.allocate(size);\n-        arena.close();\n-        return segment;\n+        try (Arena arena = Arena.ofConfined()) {\n+            return arena.allocate(size);\n+        }\n@@ -76,4 +75,3 @@\n-        CallocArena arena = new CallocArena();\n-        MemorySegment segment = arena.allocate(size);\n-        arena.close();\n-        return segment.address();\n+        try (CallocArena arena = new CallocArena()) {\n+            return arena.allocate(size).address();\n+        }\n@@ -84,4 +82,3 @@\n-        UnsafeArena arena = new UnsafeArena();\n-        MemorySegment segment = arena.allocate(size);\n-        arena.close();\n-        return segment.address();\n+        try (UnsafeArena arena = new UnsafeArena()) {\n+            return arena.allocate(size).address();\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/AllocTest.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class ResourceScopeCloseMin {\n+\n+    Runnable dummy = () -> {};\n+\n+    static class ConfinedScope {\n+        final Thread owner;\n+        boolean closed;\n+        final List<Runnable> resources = new ArrayList<>();\n+\n+        private void checkState() {\n+            if (closed) {\n+                throw new AssertionError(\"Closed\");\n+            } else if (owner != Thread.currentThread()) {\n+                throw new AssertionError(\"Wrong thread\");\n+            }\n+        }\n+\n+        ConfinedScope() {\n+            this.owner = Thread.currentThread();\n+        }\n+\n+        void addCloseAction(Runnable runnable) {\n+            checkState();\n+            resources.add(runnable);\n+        }\n+\n+        public void close() {\n+            checkState();\n+            closed = true;\n+            for (Runnable r : resources) {\n+                r.run();\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void confined_close() {\n+        ConfinedScope scope = new ConfinedScope();\n+        try { \/\/ simulate TWR\n+            scope.addCloseAction(dummy);\n+            scope.close();\n+        } catch (RuntimeException ex) {\n+            scope.close();\n+            throw ex;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void confined_close_notry() {\n+        ConfinedScope scope = new ConfinedScope();\n+        scope.addCloseAction(dummy);\n+        scope.close();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ResourceScopeCloseMin.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -93,1 +93,1 @@\n-    public int panama_strlen() throws Throwable {\n+    public int panama_strlen_alloc() throws Throwable {\n@@ -107,4 +107,3 @@\n-        Arena arena = pool.acquire();\n-        int l = (int) STRLEN.invokeExact(arena.allocateFrom(str));\n-        arena.close();\n-        return l;\n+        try (Arena arena = pool.acquire()) {\n+            return (int) STRLEN.invokeExact(arena.allocateFrom(str));\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/StrLenTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -85,4 +85,3 @@\n-        Arena arena = Arena.ofConfined();\n-        MemorySegment segment = arena.allocateFrom(str);\n-        arena.close();\n-        return segment;\n+        try (Arena arena = Arena.ofConfined()) {\n+            return arena.allocateFrom(str);\n+        }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ToCStringTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}