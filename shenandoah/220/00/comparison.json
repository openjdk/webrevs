{"files":[{"patch":"@@ -216,3 +216,6 @@\n-    log_info(gc, ergo)(\"Adaptive CSet Selection. Max Evacuation: \" SIZE_FORMAT \"%s, Actual Free: \" SIZE_FORMAT \"%s.\",\n-                         byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset),\n-                         byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free));\n+    log_info(gc, ergo)(\"Adaptive CSet Selection. Target Free: \" SIZE_FORMAT \"%s, Actual Free: \"\n+                     SIZE_FORMAT \"%s, Max Evacuation: \" SIZE_FORMAT \"%s, Min Garbage: \" SIZE_FORMAT \"%s\",\n+                     byte_size_in_proper_unit(free_target), proper_unit_for_byte_size(free_target),\n+                     byte_size_in_proper_unit(actual_free), proper_unit_for_byte_size(actual_free),\n+                     byte_size_in_proper_unit(max_cset),    proper_unit_for_byte_size(max_cset),\n+                     byte_size_in_proper_unit(min_garbage), proper_unit_for_byte_size(min_garbage));\n@@ -225,5 +228,9 @@\n-      size_t new_cset = cur_cset + r->get_live_data_bytes();\n-      size_t region_garbage = r->garbage();\n-      size_t new_garbage = cur_garbage + region_garbage;\n-      bool add_regardless = (region_garbage > ignore_threshold) && (new_garbage < min_garbage);\n-      if ((new_cset <= max_cset) && (add_regardless || (region_garbage > garbage_threshold))) {\n+\n+      size_t new_cset    = cur_cset + r->get_live_data_bytes();\n+      size_t new_garbage = cur_garbage + r->garbage();\n+\n+      if (new_cset > max_cset) {\n+        break;\n+      }\n+\n+      if ((new_garbage < min_garbage) || (r->garbage() > garbage_threshold)) {\n@@ -364,1 +371,1 @@\n-  if (allocation_headroom < min_threshold) {\n+  if (available < min_threshold) {\n@@ -376,1 +383,1 @@\n-    if (allocation_headroom < init_threshold) {\n+    if (available < init_threshold) {\n@@ -426,18 +433,0 @@\n-  size_t last_live_memory = get_last_live_memory();\n-  size_t penultimate_live_memory = get_penultimate_live_memory();\n-  double original_cycle_time = avg_cycle_time;\n-  if ((penultimate_live_memory < last_live_memory) && (penultimate_live_memory != 0)) {\n-    \/\/ If the live-memory size is growing, our estimates of cycle time are based on lighter workload, so adjust.\n-    \/\/ TODO: Be more precise about how to scale when live memory is growing.  Existing code is a very rough approximation\n-    \/\/ tuned with very limited workload observations.\n-    avg_cycle_time = (avg_cycle_time * 2 * last_live_memory) \/ penultimate_live_memory;\n-  } else {\n-    int degen_cycles = degenerated_cycles_in_a_row();\n-    if (degen_cycles > 0) {\n-      \/\/ If we've degenerated recently, we might be waiting too long between triggers so adjust trigger forward.\n-      \/\/ TODO: Be more precise about how to scale when we've experienced recent degenerated GC.  Existing code is a very\n-      \/\/ rough approximation tuned with very limited workload observations.\n-      avg_cycle_time += degen_cycles * avg_cycle_time;\n-    }\n-  }\n-\n@@ -449,4 +438,0 @@\n-    if (avg_cycle_time > original_cycle_time) {\n-      log_debug(gc)(\"%s: average GC time adjusted from: %.2f ms to %.2f ms because upward trend in live memory retention\",\n-                    _generation->name(), original_cycle_time, avg_cycle_time);\n-    }\n@@ -588,4 +573,0 @@\n-double ShenandoahAllocationRate::instantaneous_rate(size_t allocated) const {\n-  return instantaneous_rate(os::elapsedTime(), allocated);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":17,"deletions":36,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-  double instantaneous_rate(size_t allocated) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-  _live_memory_last_cycle(0),\n-  _live_memory_penultimate_cycle(0),\n@@ -129,1 +127,1 @@\n-    if (!in_generation(region)) {\n+    if (is_generational && !in_generation(region)) {\n@@ -184,2 +182,0 @@\n-  save_last_live_memory(live_memory);\n-\n@@ -220,2 +216,2 @@\n-                     \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%), \"\n-                     \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%)\",\n+                     \"Immediate: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%) R: \" SIZE_FORMAT \", \"\n+                     \"CSet: \" SIZE_FORMAT \"%s (\" SIZE_FORMAT \"%%) R: \" SIZE_FORMAT,\n@@ -230,0 +226,1 @@\n+                     immediate_regions,\n@@ -233,1 +230,2 @@\n-                     cset_percent);\n+                     cset_percent,\n+                     collection_set->count());\n@@ -385,13 +383,0 @@\n-\n-void ShenandoahHeuristics::save_last_live_memory(size_t live_memory) {\n-  _live_memory_penultimate_cycle = _live_memory_last_cycle;\n-  _live_memory_last_cycle = live_memory;\n-}\n-\n-size_t ShenandoahHeuristics::get_last_live_memory() {\n-  return _live_memory_last_cycle;\n-}\n-\n-size_t ShenandoahHeuristics::get_penultimate_live_memory() {\n-  return _live_memory_penultimate_cycle;\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -104,3 +104,0 @@\n-  size_t _live_memory_last_cycle;\n-  size_t _live_memory_penultimate_cycle;\n-\n@@ -176,4 +173,0 @@\n-\n-  void save_last_live_memory(size_t live_memory);\n-  size_t get_last_live_memory();\n-  size_t get_penultimate_live_memory();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  _live(0),\n@@ -108,0 +109,1 @@\n+  _live += r->get_live_data_bytes();\n@@ -125,0 +127,1 @@\n+  _live = 0;\n@@ -180,1 +183,5 @@\n-  out->print_cr(\"Collection Set : \" SIZE_FORMAT \"\", count());\n+  out->print_cr(\"Collection Set: Regions: \"\n+                SIZE_FORMAT \", Garbage: \" SIZE_FORMAT \"%s, Live: \" SIZE_FORMAT \"%s, Used: \" SIZE_FORMAT \"%s\", count(),\n+                byte_size_in_proper_unit(garbage()), proper_unit_for_byte_size(garbage()),\n+                byte_size_in_proper_unit(live()), proper_unit_for_byte_size(live()),\n+                byte_size_in_proper_unit(used()), proper_unit_for_byte_size(used()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  size_t                _live;\n@@ -122,1 +123,1 @@\n-\n+  size_t live()          const { return _live; }\n@@ -124,0 +125,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -750,0 +750,7 @@\n+      LogTarget(Info, gc, ergo) lt;\n+      if (lt.is_enabled()) {\n+        ResourceMark rm;\n+        LogStream ls(lt);\n+        heap->collection_set()->print_on(&ls);\n+      }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+  log_debug(gc, free)(\"Could not allocate collector region with affiliation: %s for request \" PTR_FORMAT, affiliation_name(affiliation), p2i(&req));\n@@ -128,7 +129,8 @@\n-  switch (req.affiliation()) {\n-    case ShenandoahRegionAffiliation::OLD_GENERATION:\n-      \/\/ Note: unsigned result from adjusted_unaffiliated_regions() will never be less than zero, but it may equal zero.\n-      if (_heap->old_generation()->adjusted_unaffiliated_regions() <= 0) {\n-        allow_new_region = false;\n-      }\n-      break;\n+  if (_heap->mode()->is_generational()) {\n+    switch (req.affiliation()) {\n+      case ShenandoahRegionAffiliation::OLD_GENERATION:\n+        \/\/ Note: unsigned result from adjusted_unaffiliated_regions() will never be less than zero, but it may equal zero.\n+        if (_heap->old_generation()->adjusted_unaffiliated_regions() <= 0) {\n+          allow_new_region = false;\n+        }\n+        break;\n@@ -136,6 +138,6 @@\n-    case ShenandoahRegionAffiliation::YOUNG_GENERATION:\n-      \/\/ Note: unsigned result from adjusted_unaffiliated_regions() will never be less than zero, but it may equal zero.\n-      if (_heap->young_generation()->adjusted_unaffiliated_regions() <= 0) {\n-        allow_new_region = false;\n-      }\n-      break;\n+      case ShenandoahRegionAffiliation::YOUNG_GENERATION:\n+        \/\/ Note: unsigned result from adjusted_unaffiliated_regions() will never be less than zero, but it may equal zero.\n+        if (_heap->young_generation()->adjusted_unaffiliated_regions() <= 0) {\n+          allow_new_region = false;\n+        }\n+        break;\n@@ -143,4 +145,5 @@\n-    case ShenandoahRegionAffiliation::FREE:\n-    default:\n-      ShouldNotReachHere();\n-      break;\n+      case ShenandoahRegionAffiliation::FREE:\n+      default:\n+        ShouldNotReachHere();\n+        break;\n+    }\n@@ -174,6 +177,12 @@\n-      \/\/ First try to fit into a region that is already in use in the same generation.\n-      HeapWord* result;\n-      if (req.affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION) {\n-        \/\/ TODO: this is a work around to address a deficiency in FreeSet representation.  A better solution fixes\n-        \/\/ the FreeSet implementation to deal more efficiently with old-gen regions as being in the \"collector free set\"\n-        result = allocate_with_old_affiliation(req, in_new_region);\n+      if (!_heap->mode()->is_generational()) {\n+        \/\/ size_t is unsigned, need to dodge underflow when _leftmost = 0\n+        \/\/ Fast-path: try to allocate in the collector view first\n+        for (size_t c = _collector_rightmost + 1; c > _collector_leftmost; c--) {\n+          size_t idx = c - 1;\n+          if (is_collector_free(idx)) {\n+            HeapWord* result = try_allocate_in(_heap->get_region(idx), req, in_new_region);\n+            if (result != nullptr) {\n+              return result;\n+            }\n+          }\n+        }\n@@ -181,8 +190,9 @@\n-        result = allocate_with_affiliation(req.affiliation(), req, in_new_region);\n-      }\n-      if (result != nullptr) {\n-        return result;\n-      }\n-      if (allow_new_region) {\n-        \/\/ Then try a free region that is dedicated to GC allocations.\n-        result = allocate_with_affiliation(FREE, req, in_new_region);\n+        \/\/ First try to fit into a region that is already in use in the same generation.\n+        HeapWord* result;\n+        if (req.affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION) {\n+          \/\/ TODO: this is a work around to address a deficiency in FreeSet representation.  A better solution fixes\n+          \/\/ the FreeSet implementation to deal more efficiently with old-gen regions as being in the \"collector free set\"\n+          result = allocate_with_old_affiliation(req, in_new_region);\n+        } else {\n+          result = allocate_with_affiliation(req.affiliation(), req, in_new_region);\n+        }\n@@ -192,0 +202,7 @@\n+        if (allow_new_region) {\n+          \/\/ Then try a free region that is dedicated to GC allocations.\n+          result = allocate_with_affiliation(FREE, req, in_new_region);\n+          if (result != nullptr) {\n+            return result;\n+          }\n+        }\n@@ -209,0 +226,1 @@\n+                log_debug(gc, free)(\"Flipped region \" SIZE_FORMAT \" to gc for request: \" PTR_FORMAT, idx, p2i(&req));\n@@ -251,6 +269,0 @@\n-\n-    \/\/ Leave top_bitmap alone.  The first time a heap region is put into service, top_bitmap should equal end.\n-    \/\/ Thereafter, it should represent the upper bound on parts of the bitmap that need to be cleared.\n-    log_debug(gc)(\"NOT clearing bitmap for region \" SIZE_FORMAT \", top_bitmap: \"\n-                  PTR_FORMAT \" at transition from FREE to %s\",\n-                  r->index(), p2i(ctx->top_bitmap(r)), affiliation_name(req.affiliation()));\n@@ -258,0 +270,1 @@\n+    assert(!_heap->mode()->is_generational(), \"Should not have conflicting affiliation in non-generational mode.\");\n@@ -265,0 +278,5 @@\n+  if (in_new_region) {\n+    log_debug(gc, free)(\"Using new region (\" SIZE_FORMAT \") for %s (\" PTR_FORMAT \").\",\n+                       r->index(), ShenandoahAllocRequest::alloc_type_to_string(req.type()), p2i(&req));\n+  }\n+\n@@ -268,0 +286,1 @@\n+      assert(_heap->mode()->is_generational(), \"PLABs are only for generational mode\");\n@@ -332,1 +351,1 @@\n-        log_trace(gc, ergo)(\"Failed to shrink TLAB or GCLAB request (\" SIZE_FORMAT \") in region \" SIZE_FORMAT \" to \" SIZE_FORMAT\n+        log_trace(gc, free)(\"Failed to shrink TLAB or GCLAB request (\" SIZE_FORMAT \") in region \" SIZE_FORMAT \" to \" SIZE_FORMAT\n@@ -337,0 +356,1 @@\n+    assert(_heap->mode()->is_generational(), \"PLABs are only for generational mode\");\n@@ -376,0 +396,1 @@\n+  ShenandoahGeneration* generation = _heap->generation_for(req.affiliation());\n@@ -379,2 +400,2 @@\n-      \/\/ Mutator allocations always pull from young gen.\n-      _heap->young_generation()->increase_used(size * HeapWordSize);\n+      assert(req.is_young(), \"Mutator allocations always come from young generation.\");\n+      generation->increase_used(size * HeapWordSize);\n@@ -393,5 +414,2 @@\n-\n-      if (r->affiliation() == ShenandoahRegionAffiliation::YOUNG_GENERATION) {\n-        _heap->young_generation()->increase_used(size * HeapWordSize);\n-      } else {\n-        assert(r->affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION, \"GC Alloc was not YOUNG so must be OLD\");\n+      generation->increase_used(size * HeapWordSize);\n+      if (r->affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION) {\n@@ -399,1 +417,0 @@\n-        _heap->old_generation()->increase_used(size * HeapWordSize);\n@@ -404,0 +421,1 @@\n+\n@@ -418,1 +436,1 @@\n-        _heap->generation_for(req.affiliation())->increase_allocated(waste);\n+        generation->increase_allocated(waste);\n@@ -474,1 +492,1 @@\n-  size_t avail_young_regions = _heap->young_generation()->adjusted_unaffiliated_regions();\n+  ShenandoahGeneration* generation = _heap->generation_for(req.affiliation());\n@@ -476,3 +494,10 @@\n-  \/\/ No regions left to satisfy allocation, bye.\n-  if (num > mutator_count() || (num > avail_young_regions)) {\n-    return nullptr;\n+  \/\/ Check if there are enough regions left to satisfy allocation.\n+  if (_heap->mode()->is_generational()) {\n+    size_t avail_young_regions = generation->adjusted_unaffiliated_regions();\n+    if (num > mutator_count() || (num > avail_young_regions)) {\n+      return nullptr;\n+    }\n+  } else {\n+    if (num > mutator_count()) {\n+      return nullptr;\n+    }\n@@ -545,3 +570,3 @@\n-    log_debug(gc)(\"NOT clearing bitmap for Humongous region [\" PTR_FORMAT \", \" PTR_FORMAT \"], top_bitmap: \"\n-                  PTR_FORMAT \" at transition from FREE to %s\",\n-                  p2i(r->bottom()), p2i(r->end()), p2i(ctx->top_bitmap(r)), affiliation_name(req.affiliation()));\n+    log_debug(gc, free)(\"NOT clearing bitmap for Humongous region [\" PTR_FORMAT \", \" PTR_FORMAT \"], top_bitmap: \"\n+                        PTR_FORMAT \" at transition from FREE to %s\",\n+                        p2i(r->bottom()), p2i(r->end()), p2i(ctx->top_bitmap(r)), affiliation_name(req.affiliation()));\n@@ -555,5 +580,1 @@\n-  if (req.affiliation() == ShenandoahRegionAffiliation::YOUNG_GENERATION) {\n-    _heap->young_generation()->increase_used(words_size * HeapWordSize);\n-  } else if (req.affiliation() == ShenandoahRegionAffiliation::OLD_GENERATION) {\n-    _heap->old_generation()->increase_used(words_size * HeapWordSize);\n-  }\n+  generation->increase_used(words_size * HeapWordSize);\n@@ -565,1 +586,1 @@\n-    _heap->generation_for(req.affiliation())->increase_allocated(waste * HeapWordSize);\n+    generation->increase_allocated(waste * HeapWordSize);\n@@ -573,0 +594,1 @@\n+\n@@ -604,0 +626,1 @@\n+\n@@ -657,1 +680,1 @@\n-  log_debug(gc)(\"Rebuilding FreeSet\");\n+  log_debug(gc, free)(\"Rebuilding FreeSet\");\n@@ -672,1 +695,3 @@\n-      log_debug(gc)(\"  Setting Region \" SIZE_FORMAT \" _mutator_free_bitmap bit to true\", idx);\n+      log_debug(gc, free)(\"  Adding Region \" SIZE_FORMAT \" (Free: \" SIZE_FORMAT \"%s, Used: \" SIZE_FORMAT \"%s) to mutator free set\",\n+          idx, byte_size_in_proper_unit(region->free()), proper_unit_for_byte_size(region->free()),\n+               byte_size_in_proper_unit(region->used()), proper_unit_for_byte_size(region->used()));\n@@ -709,1 +734,3 @@\n-      log_debug(gc)(\"  Shifting region \" SIZE_FORMAT \" from mutator_free to collector_free\", idx);\n+      log_debug(gc, free)(\"  Shifting Region \" SIZE_FORMAT \" (Free: \" SIZE_FORMAT \"%s, Used: \" SIZE_FORMAT \"%s) to collector free set\",\n+                          idx, byte_size_in_proper_unit(region->free()), proper_unit_for_byte_size(region->free()),\n+                               byte_size_in_proper_unit(region->used()), proper_unit_for_byte_size(region->used()));\n@@ -717,1 +744,1 @@\n-  LogTarget(Info, gc, ergo) lt;\n+  LogTarget(Info, gc, free) lt;\n@@ -783,0 +810,2 @@\n+      ls.print(\"Used: \" SIZE_FORMAT \"%s, Mutator Free: \" SIZE_FORMAT \" \",\n+               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used), mutator_count());\n@@ -788,0 +817,1 @@\n+      size_t total_used = 0;\n@@ -795,0 +825,1 @@\n+          total_used += r->used();\n@@ -798,1 +829,1 @@\n-      ls.print_cr(\"Reserve: \" SIZE_FORMAT \"%s, Max: \" SIZE_FORMAT \"%s\",\n+      ls.print_cr(\"Reserve: \" SIZE_FORMAT \"%s, Max: \" SIZE_FORMAT \"%s, Used: \" SIZE_FORMAT \"%s\",\n@@ -800,1 +831,2 @@\n-                  byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max));\n+                  byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max),\n+                  byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":98,"deletions":66,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -882,0 +882,1 @@\n+    log_debug(gc, free)(\"Allocate new gclab: \" SIZE_FORMAT \", \" SIZE_FORMAT, new_size, PLAB::min_size() * ShenandoahMaxEvacLABRatio);\n@@ -884,0 +885,1 @@\n+\n@@ -895,0 +897,1 @@\n+    log_debug(gc, free)(\"New gclab size (\" SIZE_FORMAT \") is too small for \" SIZE_FORMAT, new_size, size);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -438,1 +438,1 @@\n-    st->print(\"|G \" SIZE_FORMAT_W(5) \"%1s\", byte_size_in_proper_unit(get_plab_allocs()),   proper_unit_for_byte_size(get_plab_allocs()));\n+    st->print(\"|P \" SIZE_FORMAT_W(5) \"%1s\", byte_size_in_proper_unit(get_plab_allocs()),   proper_unit_for_byte_size(get_plab_allocs()));\n@@ -669,5 +669,1 @@\n-  if (affiliation() == YOUNG_GENERATION) {\n-    heap->young_generation()->decrease_used(used());\n-  } else if (affiliation() == OLD_GENERATION) {\n-    heap->old_generation()->decrease_used(used());\n-  }\n+  heap->generation_for(affiliation())->decrease_used(used());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-  LogTarget(Debug, gc, region) lt;\n+  LogTarget(Trace, gc, region) lt;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -314,1 +314,1 @@\n-  product(uintx, ShenandoahMaxEvacLABRatio, 16, EXPERIMENTAL,               \\\n+  product(uintx, ShenandoahMaxEvacLABRatio, 0, EXPERIMENTAL,                \\\n@@ -330,1 +330,1 @@\n-          \"filling their local evcauation buffers with evacuated \"          \\\n+          \"filling their local evacuation buffers with evacuated \"          \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}