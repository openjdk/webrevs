{"files":[{"patch":"@@ -1169,1 +1169,1 @@\n-      ShenandoahGenerationalFullGC::balance_generations_before_rebuilding_free_set(heap);\n+      ShenandoahGenerationalFullGC::balance_generations_after_gc(heap);\n@@ -1190,1 +1190,1 @@\n-      heap->adjust_generation_sizes_for_next_cycle(0, 0, 0);\n+      heap->compute_old_generation_balance(0, 0);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-void ShenandoahGenerationalFullGC::balance_generations_before_rebuilding_free_set(ShenandoahHeap* heap) {\n+void ShenandoahGenerationalFullGC::balance_generations_after_gc(ShenandoahHeap* heap) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,12 @@\n-  static void balance_generations_before_rebuilding_free_set(ShenandoahHeap* heap);\n+  \/\/ Full GC may have promoted regions and may have temporarily violated constraints on the usage and\n+  \/\/ capacity of the old generation. This method will balance the accounting of regions between the\n+  \/\/ young and old generations. This is somewhat vestigial, but the outcome of this method is used\n+  \/\/ when rebuilding the free sets.\n+  static void balance_generations_after_gc(ShenandoahHeap* heap);\n+\n+  \/\/ Rebuilding the free set may have resulted in regions being pulled in to the old generation\n+  \/\/ evacuation reserve. For this reason, we must update the usage and capacity of the generations\n+  \/\/ again. In the distant past, the free set did not know anything about generations, so we had\n+  \/\/ a layer built above it to represent how much young\/old memory was available. This layer is\n+  \/\/ redundant and adds complexity. We would like to one day remove it. Until then, we must keep it\n+  \/\/ synchronized with the free set's view of things.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1245,1 +1245,1 @@\n-\/\/ xfer_limit, and any excess is transferred to the young generation.\n+\/\/ xfer_limit, and any surplus is transferred to the young generation.\n@@ -1247,2 +1247,1 @@\n-void ShenandoahHeap::adjust_generation_sizes_for_next_cycle(\n-  size_t xfer_limit, size_t young_cset_regions, size_t old_cset_regions) {\n+void ShenandoahHeap::compute_old_generation_balance(size_t old_xfer_limit, size_t old_cset_regions) {\n@@ -1274,1 +1273,1 @@\n-  const size_t bound_on_old_reserve = old_available + xfer_limit + young_reserve;\n+  const size_t bound_on_old_reserve = old_available + old_xfer_limit + young_reserve;\n@@ -1337,1 +1336,1 @@\n-    const size_t max_old_region_xfer = xfer_limit \/ region_size_bytes;\n+    const size_t max_old_region_xfer = old_xfer_limit \/ region_size_bytes;\n@@ -3182,1 +3181,1 @@\n-    adjust_generation_sizes_for_next_cycle(allocation_runway, young_cset_regions, old_cset_regions);\n+    compute_old_generation_balance(allocation_runway, old_cset_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -859,1 +859,1 @@\n-  void adjust_generation_sizes_for_next_cycle(size_t old_xfer_limit, size_t young_cset_regions, size_t old_cset_regions);\n+  void compute_old_generation_balance(size_t old_xfer_limit, size_t old_cset_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-  heap->adjust_generation_sizes_for_next_cycle(allocation_runway, 0, 0);\n+  heap->compute_old_generation_balance(allocation_runway, 0);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}