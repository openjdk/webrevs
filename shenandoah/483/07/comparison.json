{"files":[{"patch":"@@ -44,1 +44,1 @@\n-        value=\"$(grep -h ${{ inputs.var }}= make\/conf\/github-actions.conf | cut -d '=' -f 2-)\"\n+        value=\"$(grep -h '^${{ inputs.var }}'= make\/conf\/github-actions.conf | cut -d '=' -f 2-)\"\n","filename":".github\/actions\/config\/action.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+name: 'Build (alpine-linux)'\n+\n+on:\n+  workflow_call:\n+    inputs:\n+      platform:\n+        required: true\n+        type: string\n+      extra-conf-options:\n+        required: false\n+        type: string\n+      make-target:\n+        required: false\n+        type: string\n+        default: 'product-bundles test-bundles'\n+      debug-levels:\n+        required: false\n+        type: string\n+        default: '[ \"debug\", \"release\" ]'\n+      apk-extra-packages:\n+        required: false\n+        type: string\n+      configure-arguments:\n+        required: false\n+        type: string\n+      make-arguments:\n+        required: false\n+        type: string\n+\n+jobs:\n+  build-linux:\n+    name: build\n+    runs-on: ubuntu-22.04\n+    container:\n+      image: alpine:3.20\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        debug-level: ${{ fromJSON(inputs.debug-levels) }}\n+        include:\n+          - debug-level: debug\n+            flags: --with-debug-level=fastdebug\n+            suffix: -debug+\n+\n+    steps:\n+      - name: 'Checkout the JDK source'\n+        uses: actions\/checkout@v4\n+\n+      - name: 'Install toolchain and dependencies'\n+        run: |\n+          apk update\n+          apk add alpine-sdk alsa-lib-dev autoconf bash cups-dev cups-libs fontconfig-dev freetype-dev grep libx11-dev libxext-dev libxrandr-dev libxrender-dev libxt-dev libxtst-dev linux-headers wget zip ${{ inputs.apk-extra-packages }}\n+\n+      - name: 'Get the BootJDK'\n+        id: bootjdk\n+        uses: .\/.github\/actions\/get-bootjdk\n+        with:\n+          platform: alpine-linux-x64\n+\n+      - name: 'Configure'\n+        run: >\n+          bash configure\n+          --with-conf-name=${{ inputs.platform }}\n+          ${{ matrix.flags }}\n+          --with-version-opt=${GITHUB_ACTOR}-${GITHUB_SHA}\n+          --with-boot-jdk=${{ steps.bootjdk.outputs.path }}\n+          --with-zlib=system\n+          --with-jmod-compress=zip-1\n+          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n+          echo \"Dumping config.log:\" &&\n+          cat config.log &&\n+          exit 1)\n+\n+      - name: 'Build'\n+        id: build\n+        uses: .\/.github\/actions\/do-build\n+        with:\n+          make-target: '${{ inputs.make-target }} ${{ inputs.make-arguments }}'\n+          platform: ${{ inputs.platform }}\n+          debug-suffix: '${{ matrix.suffix }}'\n+\n+      - name: 'Upload bundles'\n+        uses: .\/.github\/actions\/upload-bundles\n+        with:\n+          platform: ${{ inputs.platform }}\n+          debug-suffix: '${{ matrix.suffix }}'\n","filename":".github\/workflows\/build-alpine-linux.yml","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -39,1 +39,1 @@\n-        default: 'linux-x64, linux-x86, linux-x64-variants, linux-cross-compile, macos-x64, macos-aarch64, windows-x64, windows-aarch64, docs'\n+        default: 'linux-x64, linux-x86-hs, linux-x64-variants, linux-cross-compile, alpine-linux-x64, macos-x64, macos-aarch64, windows-x64, windows-aarch64, docs'\n@@ -60,0 +60,3 @@\n+    env:\n+      # List of platforms to exclude by default\n+      EXCLUDED_PLATFORMS: 'alpine-linux-x64'\n@@ -62,1 +65,1 @@\n-      linux-x86: ${{ steps.include.outputs.linux-x86 }}\n+      linux-x86-hs: ${{ steps.include.outputs.linux-x86-hs }}\n@@ -65,0 +68,1 @@\n+      alpine-linux-x64: ${{ steps.include.outputs.alpine-linux-x64 }}\n@@ -81,0 +85,4 @@\n+\n+          # Convert EXCLUDED_PLATFORMS from a comma-separated string to an array\n+          IFS=',' read -r -a excluded_array <<< \"$EXCLUDED_PLATFORMS\"\n+\n@@ -97,1 +105,7 @@\n-              # For an empty input, assume all platforms should run\n+              # For an empty input, assume all platforms should run, except those in the EXCLUDED_PLATFORMS list\n+              for excluded in \"${excluded_array[@]}\"; do\n+                if [[ \"$1\" == \"$excluded\" ]]; then\n+                  echo 'false'\n+                  return\n+                fi\n+              done\n@@ -108,0 +122,8 @@\n+\n+              # If not explicitly included, check against the EXCLUDED_PLATFORMS list\n+              for excluded in \"${excluded_array[@]}\"; do\n+                if [[ \"$1\" == \"$excluded\" ]]; then\n+                  echo 'false'\n+                  return\n+                fi\n+              done\n@@ -114,1 +136,1 @@\n-          echo \"linux-x86=$(check_platform linux-x86 linux x86)\" >> $GITHUB_OUTPUT\n+          echo \"linux-x86-hs=$(check_platform linux-x86-hs linux x86)\" >> $GITHUB_OUTPUT\n@@ -117,0 +139,1 @@\n+          echo \"alpine-linux-x64=$(check_platform alpine-linux-x64 alpine-linux x64)\" >> $GITHUB_OUTPUT\n@@ -138,2 +161,2 @@\n-  build-linux-x86:\n-    name: linux-x86\n+  build-linux-x86-hs:\n+    name: linux-x86-hs\n@@ -144,0 +167,1 @@\n+      make-target: 'hotspot'\n@@ -153,1 +177,1 @@\n-    if: needs.select.outputs.linux-x86 == 'true'\n+    if: needs.select.outputs.linux-x86-hs == 'true'\n@@ -223,0 +247,10 @@\n+  build-alpine-linux-x64:\n+    name: alpine-linux-x64\n+    needs: select\n+    uses: .\/.github\/workflows\/build-alpine-linux.yml\n+    with:\n+      platform: alpine-linux-x64\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n+    if: needs.select.outputs.alpine-linux-x64 == 'true'\n+\n@@ -303,10 +337,0 @@\n-  test-linux-x86:\n-    name: linux-x86\n-    needs:\n-      - build-linux-x86\n-    uses: .\/.github\/workflows\/test.yml\n-    with:\n-      platform: linux-x86\n-      bootjdk-platform: linux-x64\n-      runs-on: ubuntu-22.04\n-\n@@ -350,1 +374,1 @@\n-      - build-linux-x86\n+      - build-linux-x86-hs\n@@ -356,0 +380,1 @@\n+      - build-alpine-linux-x64\n@@ -361,1 +386,0 @@\n-      - test-linux-x86\n","filename":".github\/workflows\/main.yml","additions":43,"deletions":19,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -281,0 +281,12 @@\n+$(eval $(call SetupTarget, hotspot-xcode-project, \\\n+    MAKEFILE := ide\/xcode\/hotspot\/CreateXcodeProject, \\\n+    TARGET := build, \\\n+    DEPS := hotspot compile-commands-hotspot jdk-image, \\\n+))\n+\n+$(eval $(call SetupTarget, open-hotspot-xcode-project, \\\n+    MAKEFILE := ide\/xcode\/hotspot\/CreateXcodeProject, \\\n+    TARGET := open, \\\n+    DEPS := hotspot-xcode-project, \\\n+))\n+\n","filename":"make\/Main.gmk","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+          $(CHMOD) u+w '$(call DecodeSpace, $@)'; \\\n@@ -191,0 +192,5 @@\n+define copy-and-chmod-executable\n+\t$(install-file)\n+\t$(CHMOD) a+rx $@\n+endef\n+\n","filename":"make\/common\/FileUtils.gmk","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -285,2 +285,20 @@\n-  ifneq ($$($1_CLASSPATH), )\n-    $1_FLAGS += -cp $$(call PathList, $$($1_CLASSPATH))\n+  $1_AUGMENTED_CLASSPATH := $$($1_CLASSPATH)\n+  $1_API_TARGET := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_pubapi\n+  $1_API_INTERNAL := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_internalapi\n+\n+  ifeq ($$($1_CREATE_API_DIGEST), true)\n+    $1_API_DIGEST_FLAGS := \\\n+        -Xplugin:\"depend $$($1_API_TARGET)\" \\\n+        \"-XDinternalAPIPath=$$($1_API_INTERNAL)\" \\\n+        \"-XDLOG_LEVEL=$(LOG_LEVEL)\" \\\n+        #\n+\n+    $1_EXTRA_DEPS := $$(BUILDTOOLS_OUTPUTDIR)\/depend\/_the.COMPILE_DEPEND_batch\n+    # including the compilation output on the classpath, so that incremental\n+    # compilations in unnamed module can refer to other classes from the same\n+    # source root, which are not being recompiled in this compilation:\n+    $1_AUGMENTED_CLASSPATH += $$(BUILDTOOLS_OUTPUTDIR)\/depend $$($1_BIN)\n+  endif\n+\n+  ifneq ($$($1_AUGMENTED_CLASSPATH), )\n+    $1_FLAGS += -cp $$(call PathList, $$($1_AUGMENTED_CLASSPATH))\n@@ -414,3 +432,0 @@\n-    $1_API_TARGET := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_pubapi\n-    $1_API_INTERNAL := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_internalapi\n-\n@@ -445,11 +460,0 @@\n-    ifeq ($$($1_CREATE_API_DIGEST), true)\n-      $1_API_DIGEST_FLAGS := \\\n-          -classpath $$(BUILDTOOLS_OUTPUTDIR)\/depend \\\n-          -Xplugin:\"depend $$($1_API_TARGET)\" \\\n-          \"-XDinternalAPIPath=$$($1_API_INTERNAL)\" \\\n-          \"-XDLOG_LEVEL=$(LOG_LEVEL)\" \\\n-          #\n-\n-      $1_EXTRA_DEPS := $$(BUILDTOOLS_OUTPUTDIR)\/depend\/_the.COMPILE_DEPEND_batch\n-    endif\n-\n","filename":"make\/common\/JavaCompilation.gmk","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-    $1 := $$($1_ALL_OBJS_JSON)\n+    $1 := $$($1_ALL_OBJS_JSON) $$($1_LDFLAGS_FILE)\n","filename":"make\/common\/NativeCompilation.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,0 +201,12 @@\n+\n+  # This is for IDE integration purposes only, and is not normally generated\n+  $1_LDFLAGS_FILE := $$(MAKESUPPORT_OUTPUTDIR)\/compile-commands\/$$($1_NAME)-ldflags.txt\n+\n+  $1_ALL_LD_ARGS := $$($1_LDFLAGS) $$($1_EXTRA_LDFLAGS) $$($1_SYSROOT_LDFLAGS) \\\n+      $$($1_LIBS) $$($1_EXTRA_LIBS)\n+\n+  $$($1_LDFLAGS_FILE): $$($1_VARDEPS_FILE)\n+\t$$(call LogInfo, Creating compile commands linker flags output for $$($1_BASENAME))\n+\t$$(call MakeDir, $$(dir $$@))\n+\t$$(ECHO) $$($1_ALL_LD_ARGS) > $$@\n+\n","filename":"make\/common\/native\/Link.gmk","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+ALPINE_LINUX_X64_BOOT_JDK_EXT=tar.gz\n+ALPINE_LINUX_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin22-binaries\/releases\/download\/jdk-22.0.2%2B9\/OpenJDK22U-jdk_x64_alpine-linux_hotspot_22.0.2_9.tar.gz\n+ALPINE_LINUX_X64_BOOT_JDK_SHA256=49f73414824b1a7c268a611225fa4d7ce5e25600201e0f1cd59f94d1040b5264\n+\n","filename":"make\/conf\/github-actions.conf","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-    java.datatransfer \\\n@@ -100,1 +99,0 @@\n-    java.logging \\\n@@ -102,3 +100,0 @@\n-    java.management.rmi \\\n-    java.naming \\\n-    java.net.http \\\n@@ -107,2 +102,0 @@\n-    java.scripting \\\n-    java.se \\\n@@ -110,1 +103,0 @@\n-    java.security.sasl \\\n@@ -112,5 +104,0 @@\n-    java.sql \\\n-    java.sql.rowset \\\n-    java.transaction.xa \\\n-    java.xml \\\n-    java.xml.crypto \\\n@@ -118,1 +105,1 @@\n-    jdk.charsets \\\n+    jdk.attach \\\n@@ -120,3 +107,2 @@\n-    jdk.dynalink \\\n-    jdk.httpserver \\\n-    jdk.incubator.vector \\\n+    jdk.crypto.mscapi \\\n+    jdk.hotspot.agent \\\n@@ -125,0 +111,1 @@\n+    jdk.jdi \\\n@@ -126,2 +113,1 @@\n-    jdk.jsobject \\\n-    jdk.localedata \\\n+    jdk.jpackage \\\n@@ -130,3 +116,0 @@\n-    jdk.management.jfr \\\n-    jdk.naming.dns \\\n-    jdk.naming.rmi \\\n@@ -134,1 +117,0 @@\n-    jdk.nio.mapmode \\\n@@ -137,4 +119,0 @@\n-    jdk.security.jgss \\\n-    jdk.unsupported \\\n-    jdk.xml.dom \\\n-    jdk.zipfs \\\n","filename":"make\/conf\/module-loader-map.conf","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-  TOOLS_OUTPUTDIR := $(HOTSPOT_OUTPUTDIR)\/support\/ide_classes\n+  TOOLS_OUTPUTDIR := $(MAKESUPPORT_OUTPUTDIR)\/ide\/visualstudio\n","filename":"make\/ide\/visualstudio\/hotspot\/CreateVSProject.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+#\n+# Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# This must be the first rule\n+default: all\n+\n+include $(SPEC)\n+include MakeBase.gmk\n+include CopyFiles.gmk\n+include Execute.gmk\n+include JavaCompilation.gmk\n+\n+ifeq ($(call isTargetOs, macosx), true)\n+  ##############################################################################\n+  # Build the XcodeProjectMaker java tool.\n+\n+  PROJECT_MAKER_DIR := $(TOPDIR)\/make\/ide\/xcode\/hotspot\n+  TOOLS_OUTPUTDIR := $(MAKESUPPORT_OUTPUTDIR)\/ide\/xcode\n+  IDE_OUTPUTDIR := $(OUTPUTDIR)\/xcode\n+  PROJECT_FILE_NAME := hotspot.xcodeproj\n+\n+  COMPILE_COMMAND_FILE := $(OUTPUTDIR)\/compile_commands.json\n+  LINKER_FLAGS_FILE := $(MAKESUPPORT_OUTPUTDIR)\/compile-commands\/jvm-ldflags.txt\n+\n+  $(eval $(call SetupJavaCompilation, BUILD_PROJECT_CREATOR, \\\n+      TARGET_RELEASE := $(TARGET_RELEASE_BOOTJDK), \\\n+      SRC := $(PROJECT_MAKER_DIR)\/src\/classes, \\\n+      BIN := $(TOOLS_OUTPUTDIR), \\\n+      DISABLED_WARNINGS := rawtypes unchecked serial, \\\n+  ))\n+\n+  TARGETS += $(BUILD_PROJECT_CREATOR)\n+\n+  # Run the XcodeProjectMaker tool\n+  PROJECT_CREATOR_TOOL := $(JAVA_SMALL) -cp $(TOOLS_OUTPUTDIR) XcodeProjectMaker\n+\n+  ifneq ($(findstring $(LOG_LEVEL), debug trace), )\n+    XCODE_PROJ_DEBUG_OPTION := -d\n+  endif\n+\n+  XCODE_PROJ_VARDEPS := $(WORKSPACE_ROOT) $(IDE_OUTPUTDIR) \\\n+      $(PROJECT_MAKER_DIR)\/data $(COMPILE_COMMAND_FILE) $(LINKER_FLAGS_FILE)\n+  XCODE_PROJ_VARDEPS_FILE := $(call DependOnVariable, XCODE_PROJ_VARDEPS, \\\n+    $(TOOLS_OUTPUTDIR)\/xcodeproj.vardeps)\n+\n+  $(eval $(call SetupExecute, build_xcode_project, \\\n+      WARN := Generating Xcode project file, \\\n+      DEPS := $(BUILD_PROJECT_CREATOR) $(COMPILE_COMMAND_FILE) \\\n+          $(LINKER_FLAGS_FILE) $(XCODE_PROJ_VARDEPS_FILE), \\\n+      OUTPUT_DIR := $(TOOLS_OUTPUTDIR), \\\n+      COMMAND := $(PROJECT_CREATOR_TOOL) $(WORKSPACE_ROOT) $(IDE_OUTPUTDIR) \\\n+          $(PROJECT_MAKER_DIR)\/data $(COMPILE_COMMAND_FILE) \\\n+          $(LINKER_FLAGS_FILE) $(XCODE_PROJ_DEBUG_OPTION), \\\n+  ))\n+\n+  TARGETS += $(build_xcode_project)\n+\n+  $(eval $(call SetupCopyFiles, copy_xcode_project, \\\n+      DEST := $(IDE_OUTPUTDIR), \\\n+      FILES := $(PROJECT_MAKER_DIR)\/data\/script_before.sh $(PROJECT_MAKER_DIR)\/data\/script_after.sh , \\\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n+\n+  TARGETS += $(copy_xcode_project)\n+\n+  $(eval $(call SetupExecute, open_xcode_project, \\\n+      INFO := Opening Xcode project file, \\\n+      DEPS := $(build_xcodeproject_TARGET) FORCE, \\\n+      OUTPUT_DIR := $(TOOLS_OUTPUTDIR), \\\n+      COMMAND := open $(IDE_OUTPUTDIR)\/$(PROJECT_FILE_NAME), \\\n+  ))\n+\n+  TARGETS += $(open_xcode_project)\n+\n+  # Always call open without considering dependencies being up to date\n+  FORCE:\n+\n+  build: $(build_xcode_project) $(copy_xcode_project)\n+\n+  open: $(open_xcode_project)\n+\n+  all: $(TARGETS)\n+else\n+  build:\n+  open:\n+  all:\n+\t$(info Xcode projects are only supported on macOS)\n+endif\n+\n+.PHONY: default all build open\n","filename":"make\/ide\/xcode\/hotspot\/CreateXcodeProject.gmk","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Bucket\n+   type = \"4\"\n+   version = \"2.0\">\n+   <Breakpoints>\n+      <BreakpointProxy\n+         BreakpointExtensionID = \"Xcode.Breakpoint.SymbolicBreakpoint\">\n+         <BreakpointContent\n+            shouldBeEnabled = \"Yes\"\n+            ignoreCount = \"0\"\n+            continueAfterRunningActions = \"Yes\"\n+            symbolName = \"load_jimage_library\"\n+            moduleName = \"libjvm.dylib\">\n+            <Actions>\n+               <BreakpointActionProxy\n+                  ActionExtensionID = \"Xcode.BreakpointAction.DebuggerCommand\">\n+                  <ActionContent\n+                     consoleCommand = \"process handle -n true -p true -s false SIGSEGV SIGBUS SIGUSR2\">\n+                  <\/ActionContent>\n+               <\/BreakpointActionProxy>\n+            <\/Actions>\n+            <Locations>\n+               <Location\n+                  shouldBeEnabled = \"Yes\"\n+                  ignoreCount = \"0\"\n+                  continueAfterRunningActions = \"No\"\n+                  symbolName = \"ClassLoader::load_jimage_library()\"\n+                  moduleName = \"libjvm.dylib\"\n+                  usesParentBreakpointCondition = \"Yes\"\n+                  timestampString = \"0\"\n+                  startingColumnNumber = \"0\"\n+                  endingColumnNumber = \"0\"\n+                  startingLineNumber = \"0\"\n+                  endingLineNumber = \"0\"\n+                  offsetFromSymbolStart = \"0\">\n+               <\/Location>\n+            <\/Locations>\n+         <\/BreakpointContent>\n+      <\/BreakpointProxy>\n+   <\/Breakpoints>\n+<\/Bucket>\n","filename":"make\/ide\/xcode\/hotspot\/data\/Breakpoints_v2.xcbkptlist.template","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Scheme\n+   LastUpgradeVersion = \"0900\"\n+   version = \"1.3\">\n+   <BuildAction\n+      parallelizeBuildables = \"YES\"\n+      buildImplicitDependencies = \"YES\">\n+      <BuildActionEntries>\n+         <BuildActionEntry\n+            buildForTesting = \"YES\"\n+            buildForRunning = \"YES\"\n+            buildForProfiling = \"NO\"\n+            buildForArchiving = \"NO\"\n+            buildForAnalyzing = \"YES\">\n+            <BuildableReference\n+               BuildableIdentifier = \"primary\"\n+               BlueprintIdentifier = \"D60000000000000000000000\"\n+               BuildableName = \"libjvm.dylib\"\n+               BlueprintName = \"jvm\"\n+               ReferencedContainer = \"container:hotspot.xcodeproj\">\n+            <\/BuildableReference>\n+         <\/BuildActionEntry>\n+      <\/BuildActionEntries>\n+   <\/BuildAction>\n+   <TestAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\">\n+      <Testables>\n+      <\/Testables>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/TestAction>\n+   <LaunchAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      launchStyle = \"0\"\n+      useCustomWorkingDirectory = \"NO\"\n+      ignoresPersistentStateOnLaunch = \"NO\"\n+      debugDocumentVersioning = \"YES\"\n+      debugServiceExtension = \"internal\"\n+      allowLocationSimulation = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <CommandLineArguments>\n+         <CommandLineArgument\n+            argument = \"-version\"\n+            isEnabled = \"YES\">\n+         <\/CommandLineArgument>\n+      <\/CommandLineArguments>\n+      <EnvironmentVariables>\n+         <EnvironmentVariable\n+            key = \"DYLD_PRINT_ENV\"\n+            value = \"1\"\n+            isEnabled = \"YES\">\n+         <\/EnvironmentVariable>\n+      <\/EnvironmentVariables>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/LaunchAction>\n+   <ProfileAction\n+      buildConfiguration = \"Release\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\"\n+      savedToolIdentifier = \"\"\n+      useCustomWorkingDirectory = \"NO\"\n+      debugDocumentVersioning = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+   <\/ProfileAction>\n+   <AnalyzeAction\n+      buildConfiguration = \"Release\">\n+   <\/AnalyzeAction>\n+   <ArchiveAction\n+      buildConfiguration = \"Release\"\n+      revealArchiveInOrganizer = \"YES\">\n+   <\/ArchiveAction>\n+<\/Scheme>\n","filename":"make\/ide\/xcode\/hotspot\/data\/jvm.xcscheme.template","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,207 @@\n+\/\/ !$*UTF8*$!\n+{\n+\tarchiveVersion = 1;\n+\tclasses = {\n+\t};\n+\tobjectVersion = 48;\n+\tobjects = {\n+\n+\/* Begin PBXBuildFile section *\/\n+TEMPLATE_PBXBUILDFILE\n+\/* End PBXBuildFile section *\/\n+\n+\/* Begin PBXFileReference section *\/\n+\t\tD60000000000000000000003 \/* script_before.sh *\/ = {isa = PBXFileReference; lastKnownFileType = text.script.sh; path = script_before.sh; sourceTree = \"<group>\"; };\n+\t\tD60000000000000000000002 \/* script_after.sh *\/ = {isa = PBXFileReference; lastKnownFileType = text.script.sh; path = script_after.sh; sourceTree = \"<group>\"; };\n+\t\tD60000000000000000000006 \/* libjvm.dylib *\/ = {isa = PBXFileReference; explicitFileType = \"compiled.mach-o.dylib\"; includeInIndex = 0; path = libjvm.dylib; sourceTree = BUILT_PRODUCTS_DIR; };\n+TEMPLATE_PBXFILEREFERENCE\n+\/* End PBXFileReference section *\/\n+\n+\/* Begin PBXGroup section *\/\n+\t\tD60000000000000000000004 \/* scripts *\/ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tD60000000000000000000003 \/* script_before.sh *\/,\n+\t\t\t\tD60000000000000000000002 \/* script_after.sh *\/,\n+\t\t\t);\n+\t\t\tname = scripts;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\tD60000000000000000000005 \/* Products *\/ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tD60000000000000000000006 \/* libjvm.dylib *\/,\n+\t\t\t);\n+\t\t\tname = Products;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\tD60000000000000000000001 = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tD60000000000000000000004 \/* scripts *\/,\n+TEMPLATE_GROUP_GENSRC \/* gensrc *\/,\n+TEMPLATE_GROUP_SRC \/* src *\/,\n+TEMPLATE_GROUP_TEST \/* test *\/,\n+\t\t\t\tD60000000000000000000005 \/* Products *\/,\n+\t\t\t);\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+TEMPLATE_GROUPS\n+\/* End PBXGroup section *\/\n+\n+\/* Begin PBXNativeTarget section *\/\n+\t\tD60000000000000000000000 \/* jvm *\/ = {\n+\t\t\tisa = PBXNativeTarget;\n+\t\t\tbuildConfigurationList = D6000000000000000000000F \/* Build configuration list for PBXNativeTarget \"jvm\" *\/;\n+\t\t\tbuildPhases = (\n+\t\t\t\tD60000000000000000000007 \/* Run script_before *\/,\n+\t\t\t\tD60000000000000000000008 \/* Sources *\/,\n+\t\t\t\tD6000000000000000000000A \/* Run script_after *\/,\n+\t\t\t);\n+\t\t\tbuildRules = (\n+\t\t\t);\n+\t\t\tdependencies = (\n+\t\t\t);\n+\t\t\tname = jvm;\n+\t\t\tproductName = jvm;\n+\t\t\tproductReference = D60000000000000000000006 \/* libjvm.dylib *\/;\n+\t\t\tproductType = \"com.apple.product-type.library.dynamic\";\n+\t\t};\n+\/* End PBXNativeTarget section *\/\n+\n+\/* Begin PBXProject section *\/\n+\t\tD60000000000000000000010 \/* Project object *\/ = {\n+\t\t\tisa = PBXProject;\n+\t\t\tattributes = {\n+\t\t\t\tLastUpgradeCheck = 0900;\n+\t\t\t\tORGANIZATIONNAME = Oracle;\n+\t\t\t\tTargetAttributes = {\n+\t\t\t\t\tD60000000000000000000000 = {\n+\t\t\t\t\t\tCreatedOnToolsVersion = 9.0;\n+\t\t\t\t\t\tProvisioningStyle = Automatic;\n+\t\t\t\t\t};\n+\t\t\t\t};\n+\t\t\t};\n+\t\t\tbuildConfigurationList = D6000000000000000000000E \/* Build configuration list for PBXProject \"jvm\" *\/;\n+\t\t\tcompatibilityVersion = \"Xcode 8.0\";\n+\t\t\tdevelopmentRegion = en;\n+\t\t\thasScannedForEncodings = 0;\n+\t\t\tknownRegions = (\n+\t\t\t\ten,\n+\t\t\t);\n+\t\t\tmainGroup = D60000000000000000000001;\n+\t\t\tproductRefGroup = D60000000000000000000005 \/* Products *\/;\n+\t\t\tprojectDirPath = \"\";\n+\t\t\tprojectRoot = \"\";\n+\t\t\ttargets = (\n+\t\t\t\tD60000000000000000000000 \/* jvm *\/,\n+\t\t\t);\n+\t\t};\n+\/* End PBXProject section *\/\n+\n+\/* Begin PBXShellScriptBuildPhase section *\/\n+\t\tD60000000000000000000007 \/* Run script_before *\/ = {\n+\t\t\tisa = PBXShellScriptBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\tinputPaths = (\n+\t\t\t);\n+\t\t\tname = \"Run script_before\";\n+\t\t\toutputPaths = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t\tshellPath = \/bin\/sh;\n+\t\t\tshellScript = \"cd $PROJECT_DIR;\\ntime .\/script_before.sh;\\n\";\n+\t\t};\n+\t\tD6000000000000000000000A \/* Run script_after *\/ = {\n+\t\t\tisa = PBXShellScriptBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\tinputPaths = (\n+\t\t\t);\n+\t\t\tname = \"Run script_after\";\n+\t\t\toutputPaths = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t\tshellPath = \/bin\/sh;\n+\t\t\tshellScript = \"cd $PROJECT_DIR;\\ntime .\/script_after.sh;\\n\";\n+\t\t};\n+\/* End PBXShellScriptBuildPhase section *\/\n+\n+\/* Begin PBXSourcesBuildPhase section *\/\n+\t\tD60000000000000000000008 \/* Sources *\/ = {\n+\t\t\tisa = PBXSourcesBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+TEMPLATE_PBXSOURCESSBUILDPHASE\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t};\n+\/* End PBXSourcesBuildPhase section *\/\n+\n+\/* Begin XCBuildConfiguration section *\/\n+\t\tD6000000000000000000000B \/* Release *\/ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tALWAYS_SEARCH_USER_PATHS = YES;\n+\t\t\t\tCLANG_CXX_LANGUAGE_STANDARD = \"gnu++14\";\n+\t\t\t\tCODE_SIGN_IDENTITY = \"-\";\n+\t\t\t\tCONFIGURATION_BUILD_DIR = build\/jdk\/lib\/server;\n+\t\t\t\tCONFIGURATION_TEMP_DIR = build;\n+\t\t\t\tCOPY_PHASE_STRIP = NO;\n+\t\t\t\tDEBUG_INFORMATION_FORMAT = \"dwarf-with-dsym\";\n+\t\t\t\tMTL_ENABLE_DEBUG_INFO = NO;\n+\t\t\t\tOBJROOT = build;\n+\t\t\t\tONLY_ACTIVE_ARCH = YES;\n+\t\t\t\tSDKROOT = macosx;\n+\t\t\t};\n+\t\t\tname = Release;\n+\t\t};\n+\t\tD6000000000000000000000D \/* Release *\/ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tCONFIGURATION_BUILD_DIR = \"$(BUILD_DIR)\";\n+\t\t\t\tEXECUTABLE_PREFIX = lib;\n+\t\t\t\tFRAMEWORK_SEARCH_PATHS = (\n+TEMPLATE_FRAMEWORK_SEARCH_PATHS\n+\t\t\t\t);\n+\t\t\t\tOTHER_CFLAGS = (\n+TEMPLATE_OTHER_CFLAGS\n+\t\t\t\t);\n+\t\t\t\tOTHER_LDFLAGS = (\n+TEMPLATE_OTHER_LDFLAGS\n+\t\t\t\t);\n+\t\t\t\tPRODUCT_NAME = \"$(TARGET_NAME)\";\n+\t\t\t\tSKIP_INSTALL = YES;\n+\t\t\t\tSYMROOT = build\/jdk\/lib\/server;\n+\t\t\t\tUSER_HEADER_SEARCH_PATHS = (\n+TEMPLATE_USER_HEADER_SEARCH_PATHS\n+\t\t\t\t);\n+\t\t\t};\n+\t\t\tname = Release;\n+\t\t};\n+\/* End XCBuildConfiguration section *\/\n+\n+\/* Begin XCConfigurationList section *\/\n+\t\tD6000000000000000000000E \/* Build configuration list for PBXProject \"jvm\" *\/ = {\n+\t\t\tisa = XCConfigurationList;\n+\t\t\tbuildConfigurations = (\n+\t\t\t\tD6000000000000000000000B \/* Release *\/,\n+\t\t\t);\n+\t\t\tdefaultConfigurationIsVisible = 0;\n+\t\t\tdefaultConfigurationName = Release;\n+\t\t};\n+\t\tD6000000000000000000000F \/* Build configuration list for PBXNativeTarget \"jvm\" *\/ = {\n+\t\t\tisa = XCConfigurationList;\n+\t\t\tbuildConfigurations = (\n+\t\t\t\tD6000000000000000000000D \/* Release *\/,\n+\t\t\t);\n+\t\t\tdefaultConfigurationIsVisible = 0;\n+\t\t\tdefaultConfigurationName = Release;\n+\t\t};\n+\/* End XCConfigurationList section *\/\n+\t};\n+\trootObject = D60000000000000000000010 \/* Project object *\/;\n+}\n","filename":"make\/ide\/xcode\/hotspot\/data\/project.pbxproj.template","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Scheme\n+   LastUpgradeVersion = \"0900\"\n+   version = \"1.3\">\n+   <BuildAction\n+      parallelizeBuildables = \"YES\"\n+      buildImplicitDependencies = \"YES\">\n+      <BuildActionEntries>\n+         <BuildActionEntry\n+            buildForTesting = \"YES\"\n+            buildForRunning = \" NO\"\n+            buildForProfiling = \"NO\"\n+            buildForArchiving = \"NO\"\n+            buildForAnalyzing = \"NO\">\n+            <BuildableReference\n+               BuildableIdentifier = \"primary\"\n+               BlueprintIdentifier = \"D60000000000000000000000\"\n+               BuildableName = \"libjvm.dylib\"\n+               BlueprintName = \"jvm\"\n+               ReferencedContainer = \"container:hotspot.xcodeproj\">\n+            <\/BuildableReference>\n+         <\/BuildActionEntry>\n+      <\/BuildActionEntries>\n+   <\/BuildAction>\n+   <TestAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\">\n+      <Testables>\n+      <\/Testables>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/TestAction>\n+   <LaunchAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      launchStyle = \"0\"\n+      useCustomWorkingDirectory = \"NO\"\n+      ignoresPersistentStateOnLaunch = \"NO\"\n+      debugDocumentVersioning = \"YES\"\n+      debugServiceExtension = \"internal\"\n+      allowLocationSimulation = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <CommandLineArguments>\n+         <CommandLineArgument\n+            argument = \"-jar TEMPLATE_JDK_PATH\/build\/jdk\/demo\/jfc\/J2Ddemo\/J2Ddemo.jar\"\n+            isEnabled = \"YES\">\n+         <\/CommandLineArgument>\n+      <\/CommandLineArguments>\n+      <EnvironmentVariables>\n+         <EnvironmentVariable\n+            key = \"DYLD_PRINT_ENV\"\n+            value = \"1\"\n+            isEnabled = \"YES\">\n+         <\/EnvironmentVariable>\n+      <\/EnvironmentVariables>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/LaunchAction>\n+   <ProfileAction\n+      buildConfiguration = \"Release\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\"\n+      savedToolIdentifier = \"\"\n+      useCustomWorkingDirectory = \"NO\"\n+      debugDocumentVersioning = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+   <\/ProfileAction>\n+   <AnalyzeAction\n+      buildConfiguration = \"Release\">\n+   <\/AnalyzeAction>\n+   <ArchiveAction\n+      buildConfiguration = \"Release\"\n+      revealArchiveInOrganizer = \"YES\">\n+   <\/ArchiveAction>\n+<\/Scheme>\n","filename":"make\/ide\/xcode\/hotspot\/data\/runJ2Demo.xcscheme.template","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+echo \"running script_after.sh\"\n+\n+readonly JDK_LIB_PATH=\"build\/jdk\/lib\/server\/libjvm.dylib\";\n+\n+if [ ! -f ${JDK_LIB_PATH} ] ; then\n+{\n+    echo \">>>>>>>   Cannot find ${JDK_LIB_PATH}, the build failed!?\";\n+    exit 1;\n+}\n+fi\n","filename":"make\/ide\/xcode\/hotspot\/data\/script_after.sh","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+echo \"running script_before.sh\"\n+\n+readonly JDK_BUILD_PATH=\"..\";\n+readonly JAVAC_LOCATE_PATTERN=\"images\/jdk\/bin\/javac\";\n+readonly HOTSPOT_TOUCH_FILE=\"..\/..\/..\/src\/hotspot\/os\/posix\/jvm_posix.cpp\";\n+\n+echo \">>>>>>> Making a copy of JDK ...\";\n+\n+javac_file_array=( $(find ${JDK_BUILD_PATH} | grep ${JAVAC_LOCATE_PATTERN}) );\n+javac_file=${javac_file_array[0]};\n+if [ -z ${javac_file} ] ; then\n+{\n+  echo \">>>>>>>   ERROR: could not locate ${JAVAC_LOCATE_PATTERN} (did you remember to do \\\"make images\\\"?)\";\n+  exit 1;\n+}\n+fi\n+\n+jdk_build_path=$(dirname $(dirname ${javac_file}));\n+if [ ! -f \"build\/${JAVAC_LOCATE_PATTERN}\" ] ; then\n+{\n+  echo \">>>>>>>   Copying jdk over...\";\n+  rsync -a \"${jdk_build_path}\" \"build\/\";\n+}\n+fi\n+\n+# the following files will be supplied by the Xcode build\n+rm -rf \"build\/jdk\/lib\/server\/libjvm.dylib\";\n+rm -rf \"build\/jdk\/lib\/server\/libjvm.dylib.dSYM\";\n+\n+echo \">>>>>>> DONE\";\n+\n+echo \">>>>>>> Touching ${HOTSPOT_TOUCH_FILE} to force HotspotVM rebuilt\";\n+if [ ! -f ${HOTSPOT_TOUCH_FILE} ] ; then\n+{\n+    echo \">>>>>>>   Cannot find ${HOTSPOT_TOUCH_FILE}\";\n+    exit 1;\n+}\n+fi\n+touch ${HOTSPOT_TOUCH_FILE};\n+\n+echo \">>>>>>> DONE\";\n+\n+echo \">>>>>>> Xcode should be building the HotspotVM now...\";\n","filename":"make\/ide\/xcode\/hotspot\/data\/script_before.sh","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,291 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+public class DiskFile extends LinkedHashMap<Path, DiskFile> implements Comparable<DiskFile> {\n+    \/\/ xcode id ex: D50000000000000000000000\n+    private static long xcodeIdCount = 0xF0000001;\n+    private final Path path;\n+    private final boolean directory;\n+    private final String xcodeId;\n+    private final String xcodeId2;\n+    private Iterable<String> compilerFlags;\n+\n+    public DiskFile(String path, boolean directory) {\n+        this(stringToPath(path), directory);\n+    }\n+\n+    private DiskFile(Path path, boolean directory) {\n+        this.path = path;\n+        this.directory = directory;\n+        this.compilerFlags = null;\n+        this.xcodeId = getNextXcodeId();\n+        this.xcodeId2 = getNextXcodeId();\n+    }\n+\n+    private static Path stringToPath(String string) {\n+        if (string != null) {\n+            return new File(string).toPath();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static Path clipPath(Path path, String clip) {\n+        return clipPath(path.toString(), clip);\n+    }\n+\n+    private static Path clipPath(String path, String clip) {\n+        String subpath = path;\n+        if (path.contains(clip)) {\n+            subpath = clip;\n+        }\n+        int index = path.indexOf(subpath);\n+        return stringToPath(path.substring(index));\n+    }\n+\n+    private String getNextXcodeId() {\n+        String id = \"D5FFFFFF\" + Long.toHexString(xcodeIdCount).toUpperCase(Locale.ROOT);\n+        xcodeIdCount++;\n+\n+        return id;\n+    }\n+\n+    private String getPath() {\n+        return this.path.toString();\n+    }\n+\n+    public boolean isDirectory() {\n+        return this.directory;\n+    }\n+\n+    public void markAsCompiled(List<String> compilerFlags) {\n+        this.compilerFlags = compilerFlags;\n+    }\n+\n+    private boolean isCompiled() {\n+        return (this.compilerFlags != null);\n+    }\n+\n+    public String getXcodeId() {\n+        return this.xcodeId;\n+    }\n+\n+    public String generatePbxSourcesBuildPhase() {\n+        String string = \"\";\n+        if (isCompiled()) {\n+            String fileName = getFileName();\n+            string += String.format(\"        %s \/* %s in Sources *\/,\\n\", this.xcodeId2, fileName);\n+        } else if (isDirectory()) {\n+            for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+                DiskFile file = entry.getValue();\n+                string += file.generatePbxSourcesBuildPhase();\n+            }\n+        }\n+        return string;\n+    }\n+\n+    \/\/ D5FFFFFFFFFFFFFFF0006506 \/* vm_version.cpp in Sources *\/ = {isa = PBXBuildFile; fileRef = D5FFFFFFFFFFFFFFF0006505 \/* vm_version.cpp *\/; settings = {COMPILER_FLAGS = HEREHERE; }; };\n+    public String generatePbxBuildFile() {\n+        String string = \"\";\n+        if (isCompiled()) {\n+            String flagsString = \"\";\n+            for (String flag : this.compilerFlags) {\n+                flagsString += flag.replace(\"\\\"\", \"\\\\\\\\\\\"\") + \" \";\n+            }\n+            String fileName = getFileName();\n+            string += String.format(\"    %s \/* %s in Sources *\/ = {isa = PBXBuildFile; fileRef = %s \/* %s *\/; settings = {COMPILER_FLAGS = \\\"%s\\\"; }; };\\n\", this.xcodeId2, fileName, this.xcodeId, fileName, flagsString);\n+        } else if (isDirectory()) {\n+            for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+                DiskFile file = entry.getValue();\n+                string += file.generatePbxBuildFile();\n+            }\n+        }\n+        return string;\n+    }\n+\n+    public String generatePbxFileReference(String relativePathToRoot) {\n+        String string = \"\";\n+        if (!isDirectory()) {\n+            String fileName = getFileName();\n+            String suffix = getFileNameSuffix();\n+            string += String.format(\"    %s \/* %s *\/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = %s%s; name = %s; path = \\\"%s%s\\\"; sourceTree = \\\"<group>\\\"; };\\n\", this.xcodeId, fileName, fileName, suffix, fileName, relativePathToRoot, getPath());\n+        } else if (isDirectory()) {\n+            for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+                DiskFile file = entry.getValue();\n+                string += file.generatePbxFileReference(relativePathToRoot);\n+            }\n+        }\n+        return string;\n+    }\n+\n+    public String generatePbxGroup() {\n+        String string = String.format(\"    %s \/* %s *\/ = {\\n      isa = PBXGroup;\\n      children = (\\n\", this.xcodeId, getFileName());\n+\n+        Set<DiskFile> sortedSet = new TreeSet<>(values());\n+\n+        for (DiskFile file : sortedSet) {\n+            string += String.format(\"        %s \/* %s *\/,\\n\", file.getXcodeId(), file.getFileName());\n+        }\n+        string += String.format(\"      );\\n      name = %s;\\n      sourceTree = \\\"<group>\\\";\\n    };\\n\", getFileName());\n+\n+        for (DiskFile file : sortedSet) {\n+            if (file.isDirectory()) {\n+                string += file.generatePbxGroup();\n+            }\n+        }\n+\n+        return string;\n+    }\n+\n+    private ArrayList<DiskFile> getFiles(ArrayList<DiskFile> array) {\n+        for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+            DiskFile file = entry.getValue();\n+            if (file.isDirectory()) {\n+                array.add(file);\n+                array = file.getFiles(array);\n+            } else {\n+                array.add(file);\n+            }\n+        }\n+        return array;\n+    }\n+\n+    public ArrayList<DiskFile> getFiles() {\n+        return getFiles(new ArrayList<>());\n+    }\n+\n+    public String getFilePath() {\n+        return this.path.toString();\n+    }\n+\n+    private String getFileName() {\n+        Path fileName = this.path.getFileName();\n+        if (fileName != null) {\n+            return fileName.toString();\n+        } else {\n+            return this.path.toString();\n+        }\n+    }\n+\n+    private String getFileNameNoSuffix() {\n+        String string;\n+        Path fileName = this.path.getFileName();\n+        if (fileName != null) {\n+            string = fileName.toString();\n+            int index = string.indexOf('.');\n+            if (index >= 0) {\n+                string = string.substring(0, index);\n+            }\n+        } else {\n+            string = this.path.toString();\n+        }\n+        return string;\n+    }\n+\n+    private String getFileNameSuffix() {\n+        String fileName = getFileName();\n+        int index = fileName.indexOf('.');\n+        if (index >= 0) {\n+            return fileName.substring(index);\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    public DiskFile getChild(String fileName) {\n+        DiskFile child = null;\n+        for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+            DiskFile file = entry.getValue();\n+            if (file.getFileName().equals(fileName)) {\n+                child = entry.getValue();\n+                break;\n+            } else if (file.isDirectory()) {\n+                child = file.getChild(fileName);\n+                if (child != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        return child;\n+    }\n+\n+    private DiskFile getParent(Path path) {\n+        Path pathParent = path.getParent();\n+        DiskFile parent = get(pathParent);\n+        if (parent == null) {\n+            if (this.path.equals(pathParent)) {\n+                parent = this;\n+            } else {\n+                parent = getParent(pathParent).get(pathParent);\n+            }\n+            parent.putIfAbsent(path, new DiskFile(path, true));\n+        }\n+        return parent;\n+    }\n+\n+    public void addFile(Path path, String clip) {\n+        path = clipPath(path, clip);\n+        DiskFile parent = getParent(path);\n+        parent.put(path, new DiskFile(path, false));\n+    }\n+\n+    public void addDirectory(Path path, String clip) {\n+        path = clipPath(path, clip);\n+        DiskFile parent = getParent(path);\n+        parent.putIfAbsent(path, new DiskFile(path, true));\n+    }\n+\n+    @Override\n+    public int compareTo(DiskFile file) {\n+        \/\/ \".hpp\", then \".inline.hpp\", then \".cpp\"\n+        int equal = getFileNameNoSuffix().compareTo(file.getFileNameNoSuffix());\n+        if (equal == 0) {\n+            String suffix1 = getFileNameSuffix();\n+            String suffix2 = file.getFileNameSuffix();\n+            if (!suffix1.equals(\".inline.hpp\") && !suffix2.equals(\".inline.hpp\")) {\n+                \/\/ .hpp before .cpp\n+                equal = -(getFileNameSuffix().compareTo(file.getFileNameSuffix()));\n+            } else if (suffix1.equals(\".inline.hpp\") && suffix2.equals(\".hpp\")) {\n+                return 1;\n+            } else if (suffix1.equals(\".inline.hpp\") && suffix2.equals(\".cpp\")) {\n+                return -1;\n+            } else if (suffix1.equals(\".hpp\") && suffix2.equals(\".inline.hpp\")) {\n+                return -1;\n+            } else if (suffix1.equals(\".cpp\") && suffix2.equals(\".inline.hpp\")) {\n+                return 1;\n+            }\n+        }\n+        return equal;\n+    }\n+}\n","filename":"make\/ide\/xcode\/hotspot\/src\/classes\/DiskFile.java","additions":291,"deletions":0,"binary":false,"changes":291,"status":"added"},{"patch":"@@ -0,0 +1,754 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystemLoopException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+public final class XcodeProjectMaker {\n+    private static final String JDK_SCRIPT_TOKEN_1 = \"configure\";\n+    private static final String JDK_SCRIPT_TOKEN_2 = \".jcheck\";\n+    private static final String COMPILER_LINE_HEADER = \"-I\";\n+    private static final String COMPILER_IFRAMEWORK = \"-iframework\";\n+    private static final String COMPILER_FFRAMEWORK = \"-F\";\n+    private static final String SRC_HOTSPOT_PATH = \"\/src\/hotspot\";\n+    private static final String TEST_HOTSPOT_PATH = \"\/test\/hotspot\/gtest\";\n+    private static final String ALIAS_JAVA_OLD = \"java_old.sh\";\n+    private static final String ALIAS_JAVA_NEW = \"java_new.sh\";\n+    private static final String JDK_BIN_JAVA = \"\/jdk\/bin\/java\";\n+    private static final String FILE_TOKEN = \"\\\"file\\\": \";\n+    private static final String COMMAND_TOKEN = \"\\\"command\\\": \";\n+    private static final String QUOTE_START_TOKEN = \"'\\\\\\\"\";\n+    private static final String QUOTE_END_TOKEN = \"\\\\\\\"'\";\n+    private static final String VERSION = \"2.0.0\";\n+    private static final String EXCLUDE_PARSE_TOKEN_1 = \"gtest\";\n+    private static final String TEMPLATE_FRAMEWORK_SEARCH_PATHS = \"TEMPLATE_FRAMEWORK_SEARCH_PATHS\";\n+    private static final String TEMPLATE_OTHER_CFLAGS = \"TEMPLATE_OTHER_CFLAGS\";\n+    private static final String TEMPLATE_OTHER_LDFLAGS = \"TEMPLATE_OTHER_LDFLAGS\";\n+    private static final String TEMPLATE_USER_HEADER_SEARCH_PATHS = \"TEMPLATE_USER_HEADER_SEARCH_PATHS\";\n+    private static final String TEMPLATE_GROUP_GENSRC = \"TEMPLATE_GROUP_GENSRC\";\n+    private static final String TEMPLATE_GROUP_SRC = \"TEMPLATE_GROUP_SRC\";\n+    private static final String TEMPLATE_GROUP_TEST = \"TEMPLATE_GROUP_TEST\";\n+    private static final String TEMPLATE_GROUPS = \"TEMPLATE_GROUPS\";\n+    private static final String TEMPLATE_PBXBUILDFILE = \"TEMPLATE_PBXBUILDFILE\";\n+    private static final String TEMPLATE_PBXFILEREFERENCE = \"TEMPLATE_PBXFILEREFERENCE\";\n+    private static final String TEMPLATE_PBXSOURCESSBUILDPHASE = \"TEMPLATE_PBXSOURCESSBUILDPHASE\";\n+    private static final String TEMPLATE_JDK_PATH = \"TEMPLATE_JDK_PATH\";\n+    private static final String HOTSPOT_PBXPROJ = \"hotspot.xcodeproj\";\n+    private static final String PBXPROJ = \"project.pbxproj\";\n+    private static final String XCSAHAREDDATA = \"xcshareddata\";\n+    private static final String XCSCHEMES = \"xcschemes\";\n+    private static final String JVM_XCSCHEME = \"jvm.xcscheme\";\n+    private static final String J2D_XCSCHEME = \"runJ2Demo.xcscheme\";\n+    private static final String XCDEBUGGER = \"xcdebugger\";\n+    private static final String XCBKPTLIST = \"Breakpoints_v2.xcbkptlist\";\n+    private static final String TEMPLATE_PBXPROJ = PBXPROJ + \".template\";\n+    private static final String TEMPLATE_JVM_XCSCHEME = JVM_XCSCHEME + \".template\";\n+    private static final String TEMPLATE_J2D_XCSCHEME = J2D_XCSCHEME + \".template\";\n+    private static final String TEMPLATE_XCBKPTLIST = XCBKPTLIST + \".template\";\n+    private static final String[] EXCLUDE_FILES_PREFIX = {\".\"};\n+    private static final String[] EXCLUDE_FILES_POSTFIX = {\".log\", \".cmdline\"};\n+    private static final String[] COMPILER_FLAGS_INCLUDE = {\"-m\", \"-f\", \"-D\", \"-W\"};\n+    private static final String[] COMPILER_FLAGS_IS = {\"-g\", \"-Os\", \"-0\"};\n+    private static final String[] COMPILER_FLAGS_EXCLUDE = {\"-DTHIS_FILE\", \"-DGTEST_OS_MAC\", \"-mmacosx-version-min\", \"-Werror\"}; \/\/ \"-Werror\" causes Xcode to stop compiling\n+    private static final int EXIT4 = -4;\n+    private static final int EXIT5 = -5;\n+    private static final int EXIT6 = -6;\n+    private static final int EXIT7 = -7;\n+\n+    private final HashMap<String, ArrayList<String>> compiledFiles = new HashMap<>();\n+    private final TreeSet<String> compilerFlags = new TreeSet<>();\n+    private List<String> linkerFlags = List.of();\n+    private final TreeSet<String> headerPaths = new TreeSet<>();\n+    private final boolean debugLog;\n+    private String projectMakerDataPath = null;\n+    private String generatedHotspotPath = null;\n+    private String iframework = null;\n+    private String fframework = null;\n+    private DiskFile rootGensrc = new DiskFile(\"\/\", true);\n+    private DiskFile rootSrc = new DiskFile(\"\/\", true);\n+    private DiskFile rootTest = new DiskFile(\"\/\", true);\n+\n+    public XcodeProjectMaker(boolean debugLog) {\n+        this.debugLog = debugLog;\n+    }\n+\n+    public static void main(String[] args) {\n+        String workspaceRoot = args[0];\n+        String outputDir = args[1];\n+        String pathToProjectMakerData = args[2];\n+        String pathToCompileCommands = args[3];\n+        String pathToLinkerOptionsFile = args[4];\n+        String linkerOptionsString = readFile(pathToLinkerOptionsFile);\n+        boolean debugLog = args.length > 5 && args[5].equals(\"-d\");\n+\n+        File xcodeFolder = new File(outputDir);\n+        xcodeFolder.mkdirs();\n+        String workspaceRootPathFromOutputDir = findRelativePathToWorkspaceRoot(outputDir);\n+\n+        if (debugLog) {\n+            System.out.println();\n+            System.out.println(\"Version \" + VERSION);\n+            System.out.println();\n+            System.out.println(\"       Path to workspace root is \\\"\" + workspaceRoot + \"\\\"\");\n+            System.out.println(\"Path to compile commands file is \\\"\" + pathToCompileCommands + \"\\\"\");\n+            System.out.println(\" Xcode project will be placed in \\\"\" + outputDir + \"\\\"\");\n+            System.out.println();\n+        }\n+\n+        XcodeProjectMaker maker = new XcodeProjectMaker(debugLog);\n+        maker.parseHotspotCompileCommands(pathToCompileCommands);\n+        maker.linkerFlags = List.of(linkerOptionsString.split(\" \"));\n+        maker.projectMakerDataPath = pathToProjectMakerData;\n+\n+        maker.printLogDetails();\n+\n+        maker.prepareFiles(workspaceRoot);\n+        maker.makeXcodeProj(outputDir, workspaceRootPathFromOutputDir);\n+\n+        String pathToBuild = getFileParent(outputDir);\n+        maker.makeAliases(outputDir, pathToBuild);\n+\n+        System.out.println();\n+        System.out.println(\"The Xcode project for hotspot was succesfully created\");\n+        System.out.println(\"It can be found in '\" + outputDir + \"\/\" + HOTSPOT_PBXPROJ + \"'\");\n+        System.out.println();\n+    }\n+\n+    \/\/ find a path to what looks like jdk\n+    private static String findRelativePathToWorkspaceRoot(String root) {\n+        String pathToWorkspaceRoot = null;\n+        String path = root;\n+        boolean found1 = false;\n+        boolean found2 = false;\n+\n+        while (!found1 && !found2) {\n+            File folder = new File(path);\n+            File[] files = folder.listFiles();\n+            for (File file : files) {\n+                String fileName = file.toPath().getFileName().toString();\n+                if (fileName.equals(JDK_SCRIPT_TOKEN_1)) {\n+                    found1 = true;\n+                }\n+                if (fileName.equals(JDK_SCRIPT_TOKEN_2)) {\n+                    found2 = true;\n+                }\n+                if (found1 && found2) {\n+                    break;\n+                }\n+            }\n+\n+            if (!found1 && !found2) {\n+                path = Paths.get(path).getParent().toString();\n+                if (pathToWorkspaceRoot == null) {\n+                    pathToWorkspaceRoot = \"..\";\n+                } else {\n+                    pathToWorkspaceRoot += \"\/..\";\n+                }\n+            }\n+        }\n+        return pathToWorkspaceRoot;\n+    }\n+\n+    private static String readFile(File file) {\n+        return readFile(file.toPath());\n+    }\n+\n+    private static String readFile(String path) {\n+        return readFile(Paths.get(path));\n+    }\n+\n+    private static String readFile(Path path) {\n+        try {\n+            return Files.readString(path);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+\n+    private static void writeFile(File file, String string) {\n+        writeFile(file.toPath(), string);\n+    }\n+\n+    private static void writeFile(Path path, String string) {\n+        try {\n+            Files.writeString(path, string);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            System.exit(EXIT4);\n+        }\n+    }\n+\n+    private static boolean excludeFile(Path path) {\n+        return excludeFile(path.toString());\n+    }\n+\n+    private static boolean excludeFile(String string) {\n+        return excludeFile(string, null);\n+    }\n+\n+    private static boolean excludeFile(String string, String exclude) {\n+        if (exclude != null) {\n+            if (contains(string, exclude)) {\n+                return true;\n+            }\n+        }\n+        for (String excludeFilesPrefix : EXCLUDE_FILES_PREFIX) {\n+            if (string.startsWith(excludeFilesPrefix)) {\n+                return true;\n+            }\n+        }\n+        for (String excludeFilesPostfix : EXCLUDE_FILES_POSTFIX) {\n+            if (string.endsWith(excludeFilesPostfix)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean isExcludeCompilerFlag(String string) {\n+        boolean flag = false;\n+        for (String exclude : COMPILER_FLAGS_EXCLUDE) {\n+            if (string.contains(exclude)) {\n+                flag = true;\n+                break;\n+            }\n+        }\n+        return flag;\n+    }\n+\n+    private static boolean isCompilerFlag(String string) {\n+        boolean flag = false;\n+        for (String include : COMPILER_FLAGS_INCLUDE) {\n+            if (string.startsWith(include)) {\n+                flag = true;\n+                break;\n+            }\n+        }\n+        for (String is : COMPILER_FLAGS_IS) {\n+            if (string.equals(is)) {\n+                flag = true;\n+                break;\n+            }\n+        }\n+        if (isExcludeCompilerFlag(string)) {\n+            flag = false;\n+        }\n+        return flag;\n+    }\n+\n+    private static String strip(String string) {\n+        return string.substring(2, string.length() - 1);\n+    }\n+\n+    private static String strip(String string, String token) {\n+        int start = string.indexOf(token);\n+        int end = start + token.length();\n+        return strip(string.substring(end));\n+    }\n+\n+    private static boolean contains(String string, String token) {\n+        return ((string.length() >= token.length()) && (string.contains(token)));\n+    }\n+\n+    private static String getFileParent(String path) {\n+        return Paths.get(path).getParent().toString();\n+    }\n+\n+    private static String extractPath(String string, String from, String to) {\n+        String result = null;\n+        String[] tokens = string.split(\"\/\");\n+        int i = 0;\n+        for (; i < tokens.length; i++) {\n+            if (tokens[i].equals(from)) {\n+                result = \"\";\n+                break;\n+            }\n+        }\n+        for (; i < tokens.length; i++) {\n+            result += \"\/\" + tokens[i];\n+            if (tokens[i].equals(to)) {\n+                break;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private void extractCommonCompilerFlags() {\n+        \/\/ heuristic, find average count of number of flags used by each compiled file\n+        int countFiles = 0;\n+        int countFlags = 0;\n+\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            countFiles++;\n+            List<String> flags = entry.getValue();\n+            countFlags += flags.size();\n+        }\n+\n+        \/\/ when finding common flags, only consider files with this many flags\n+        int flagCutoff = (countFlags \/ countFiles) \/ 2;\n+\n+        \/\/ collect all flags\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            List<String> flags = entry.getValue();\n+            if (flags.size() > flagCutoff) {\n+                this.compilerFlags.addAll(flags);\n+            }\n+        }\n+\n+        \/\/ find flags to remove\n+        Set<String> removeFlags = new TreeSet<>();\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            List<String> flags = entry.getValue();\n+            if (flags.size() > flagCutoff) {\n+                for (String common : this.compilerFlags) {\n+                    if (!flags.contains(common)) {\n+                        removeFlags.add(common);\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ leave only common flags\n+        for (String flag : removeFlags) {\n+            this.compilerFlags.remove(flag);\n+        }\n+\n+        \/\/ remove common flags from each compiler file, leaving only the unique ones\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            List<String> flags = entry.getValue();\n+            if (flags.size() > flagCutoff) {\n+                for (String common : this.compilerFlags) {\n+                    flags.remove(common);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void extractCompilerFlags(String line) {\n+        boolean verboseCompilerTokens = false;\n+        String file = null;\n+        ArrayList<String> flags = null;\n+\n+        String[] commands = line.split(\",\");\n+        for (String command : commands) {\n+            if (contains(command, FILE_TOKEN)) {\n+                file = strip(command, FILE_TOKEN);\n+                \/\/verbose_compiler_tokens = Contains(file, \"vm_version.cpp\");\n+            } else if (contains(command, COMMAND_TOKEN)) {\n+                String tokens = strip(command, COMMAND_TOKEN);\n+                String[] arguments = tokens.split(\" \");\n+                if (arguments.length >= 3) {\n+                    flags = new ArrayList<>();\n+                    for (int a = 2; a < arguments.length; a++) {\n+                        String argument = arguments[a];\n+                        if (isCompilerFlag(argument)) {\n+                            \/\/ catch argument like -DVMTYPE=\\\"Minimal\\\"\n+                            if (contains(argument, \"\\\\\\\\\\\\\\\"\") && argument.endsWith(\"\\\\\\\\\\\\\\\"\")) {\n+                                \/\/ TODO: more robust fix needed here\n+                                argument = argument.replace(\"\\\\\", \"\");\n+                                argument = argument.replaceFirst(\"\\\"\", \"~.~\"); \/\/ temp token ~.~\n+                                argument = argument.replace(\"\\\"\", \"\\\\\\\"'\");\n+                                argument = argument.replace(\"~.~\", \"'\\\\\\\"\");\n+                            }\n+\n+                            \/\/ argument like -DHOTSPOT_VM_DISTRO='\\\"Java HotSpot(TM)\\\"'\n+                            \/\/ gets split up, so reconstruct as single string\n+                            if (contains(argument, QUOTE_START_TOKEN) && !argument.endsWith(QUOTE_END_TOKEN)) {\n+                                String fullArgument = argument;\n+                                do {\n+                                    ++a;\n+                                    argument = arguments[a];\n+                                    fullArgument = fullArgument + \" \" + argument;\n+                                } while (!argument.endsWith(QUOTE_END_TOKEN));\n+                                argument = fullArgument;\n+                            }\n+                            flags.add(argument);\n+                            if (verboseCompilerTokens) {\n+                                System.out.println(\"    FOUND COMPILER FLAG: \" + argument);\n+                            }\n+                        } else if (argument.startsWith(COMPILER_LINE_HEADER)) {\n+                            this.headerPaths.add(argument.substring(2));\n+                        } else if (argument.equals(COMPILER_IFRAMEWORK)) {\n+                            if (iframework == null) {\n+                                ++a;\n+                                this.iframework = arguments[a]; \/\/ gets the value, so skip it for the next loop\n+                            }\n+                        } else if (argument.equals(COMPILER_FFRAMEWORK)) {\n+                            if (fframework == null) {\n+                                ++a;\n+                                this.fframework = arguments[a]; \/\/ gets the value, so skip it for the next loop\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((file != null) && (flags != null)) {\n+            this.compiledFiles.put(file, flags);\n+        } else {\n+            System.err.println(\" WARNING: extractCompilerFlags returns file:\" + file + \", flags:\" + flags);\n+        }\n+\n+        if (verboseCompilerTokens) {\n+            System.exit(0);\n+        }\n+    }\n+\n+    public void parseHotspotCompileCommands(String path) {\n+        String content = readFile(path);\n+        String[] parts = content.split(\"\\\\{\"); \/\/ }\n+\n+        int found = 0;\n+        for (String line : parts) {\n+            if (!contains(line, EXCLUDE_PARSE_TOKEN_1) && !line.startsWith(\"[\")) {\n+                extractCompilerFlags(line);\n+                found++;\n+            }\n+        }\n+        if (debugLog) {\n+            System.out.println(\"Found total of \" + found + \" files that make up the libjvm.dylib\");\n+        }\n+        extractCommonCompilerFlags();\n+\n+        \/\/ figure out \"gensrc\" folder\n+        \/\/ from: \"\/Users\/gerard\/Desktop\/jdk_test\/jdk10\/build\/macosx-x86_64-normal-server-fastdebug\/hotspot\/variant-server\/gensrc\/adfiles\/ad_x86_clone.cpp\"\n+        \/\/ to:   \"\/build\/macosx-x86_64-normal-server-fastdebug\/hotspot\/variant-server\/gensrc\"\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            String file = entry.getKey();\n+            if (file.contains(\"gensrc\")) {\n+                this.generatedHotspotPath = extractPath(file, \"build\", \"gensrc\");\n+                \/\/generatedHotspotPath = \"\/build\/macosx-x64\/hotspot\/variant-server\/gensrc\";\n+                \/\/generatedHotspotPath = \"\/build\/macosx-x86_64-normal-server-fastdebug\/hotspot\/variant-server\/gensrc\";\n+            }\n+        }\n+    }\n+\n+    \/\/ https:\/\/docs.oracle.com\/javase\/tutorial\/displayCode.html?code=https:\/\/docs.oracle.com\/javase\/tutorial\/essential\/io\/examples\/Copy.java\n+    private DiskFile getHotspotFiles(DiskFile root, String workspaceRoot, String hotspotPath) {\n+        File file = new File(workspaceRoot + \"\/\" + hotspotPath);\n+        if (!file.exists()) {\n+            return null;\n+        }\n+\n+        try {\n+            final Path rootDir = Paths.get(workspaceRoot + hotspotPath);\n+            Files.walkFileTree(rootDir, new HotspotFileVisitor(root, hotspotPath));\n+        } catch (IOException ex) {\n+            System.err.println(\"ex: \" + ex);\n+        }\n+\n+        return root;\n+    }\n+\n+    public void prepareFiles(String workspaceRoot) {\n+        this.rootGensrc = getHotspotFiles(this.rootGensrc, workspaceRoot, this.generatedHotspotPath);\n+        this.rootSrc = getHotspotFiles(this.rootSrc, workspaceRoot, SRC_HOTSPOT_PATH);\n+        this.rootTest = getHotspotFiles(this.rootTest, workspaceRoot, TEST_HOTSPOT_PATH);\n+\n+        \/\/ make a copy of files from the log\n+        Set<String> logFiles = new TreeSet<>(this.compiledFiles.keySet());\n+\n+        int totalMarkedFiles = 0;\n+        DiskFile[] roots = { this.rootGensrc, this.rootSrc };\n+        for (DiskFile root : roots) {\n+            List<DiskFile> diskFiles = root.getFiles();\n+            for (DiskFile diskFile : diskFiles) {\n+                if (!diskFile.isDirectory()) {\n+                    String logFileProcessed = null;\n+                    String diskFilePath = diskFile.getFilePath();\n+                    for (String logFilePath : logFiles) {\n+                        if (contains(logFilePath, diskFilePath)) {\n+                            totalMarkedFiles++;\n+\n+                            logFileProcessed = logFilePath;\n+\n+                            \/\/ mark the file as needing compilation\n+                            diskFile.markAsCompiled(this.compiledFiles.get(logFilePath));\n+\n+                            \/\/ break early if found\n+                            break;\n+                        }\n+                    }\n+                    if (logFileProcessed != null) {\n+                        \/\/ remove the file, so we don't have to search through it again\n+                        logFiles.remove(logFileProcessed);\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (this.compiledFiles.size() != totalMarkedFiles) {\n+            System.err.println(\"\\nError: was expecting to compile \" + this.compiledFiles.size() + \" files, but marked \" + totalMarkedFiles);\n+            for (String file : logFiles) {\n+                System.err.println(\"file: \" + file);\n+            }\n+            System.exit(EXIT5);\n+        }\n+\n+        if (!logFiles.isEmpty()) {\n+            System.err.println(\"\\nError: unprocessed files left over:\");\n+            for (String logFile : logFiles) {\n+                System.err.println(\"  \" + logFile);\n+            }\n+            System.exit(EXIT6);\n+        }\n+    }\n+\n+    public void printLogDetails() {\n+        if (!debugLog) return;\n+\n+        System.out.println(\"\\nFound \" + this.compilerFlags.size() + \" common compiler flags:\");\n+        for (String flag : this.compilerFlags) {\n+            System.out.println(\" \" + flag);\n+        }\n+\n+        System.out.println(\"\\nList of compiled files (each one uses common compiler flags plus extra ones as specified):\");\n+        int count = 1;\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            String file = entry.getKey();\n+            System.out.format(\"%4d: %s\\n\", (count), file);\n+            count++;\n+            List<String> flags = entry.getValue();\n+            for (String flag : flags) {\n+                System.out.println(\"        \" + flag);\n+            }\n+        }\n+\n+        System.out.println(\"\\nFound \" + this.linkerFlags.size() + \" linker flags:\");\n+        for (String flag : this.linkerFlags) {\n+            System.out.println(\" \" + flag);\n+        }\n+\n+        System.out.println(\"\\nFound \" + this.headerPaths.size() + \" header paths:\");\n+        for (String header : this.headerPaths) {\n+            System.out.println(\" \" + header);\n+        }\n+\n+        System.out.println(\"\\nFrameworks:\");\n+        System.out.println(\" -iframework \" + iframework);\n+        System.out.println(\" -f \" + fframework);\n+    }\n+\n+    private String makeProjectPbxproj(String workspaceRootPathFromOutputDir, String string) {\n+        String cFlags = \"\";\n+        for (String flag : this.compilerFlags) {\n+            cFlags += \"          \\\"\" + flag.replace(\"\\\"\", \"\\\\\\\\\\\"\") + \"\\\",\\n\";\n+        }\n+        cFlags = cFlags.substring(0, cFlags.length() - 2);\n+        string = string.replaceFirst(TEMPLATE_OTHER_CFLAGS, cFlags);\n+\n+        String ldFlags = \"\";\n+        for (String flag : this.linkerFlags) {\n+            ldFlags += \"          \\\"\" + flag + \"\\\",\\n\";\n+        }\n+        ldFlags = ldFlags.substring(0, ldFlags.length() - 2);\n+        string = string.replaceFirst(TEMPLATE_OTHER_LDFLAGS, ldFlags);\n+\n+        String headerPaths = \"\";\n+        for (String header : this.headerPaths) {\n+            headerPaths += \"          \\\"\" + header + \"\\\",\\n\";\n+        }\n+        headerPaths = headerPaths.substring(0, headerPaths.length() - 2);\n+        string = string.replaceFirst(TEMPLATE_USER_HEADER_SEARCH_PATHS, headerPaths);\n+\n+        String frameworkPaths = \"\";\n+        if (fframework != null) {\n+            frameworkPaths += \"          \\\"\" + fframework + \"\\\"\\n\";\n+        }\n+        string = string.replaceFirst(TEMPLATE_FRAMEWORK_SEARCH_PATHS, frameworkPaths);\n+\n+        DiskFile gensrcFile = this.rootGensrc.getChild(\"gensrc\");\n+        string = string.replaceFirst(TEMPLATE_GROUP_GENSRC, \"        \" + gensrcFile.getXcodeId());\n+\n+        DiskFile srcFile = this.rootSrc.getChild(\"src\");\n+        string = string.replaceFirst(TEMPLATE_GROUP_SRC, \"        \" + srcFile.getXcodeId());\n+\n+        DiskFile testFile = this.rootTest.getChild(\"test\");\n+        string = string.replaceFirst(TEMPLATE_GROUP_TEST, \"        \" + testFile.getXcodeId());\n+\n+        String gensrcGroups = gensrcFile.generatePbxGroup();\n+        String srcGroups = srcFile.generatePbxGroup();\n+        String testGroups = testFile.generatePbxGroup();\n+        string = string.replaceFirst(TEMPLATE_GROUPS, gensrcGroups + srcGroups + testGroups);\n+\n+        String gensrcFiles = gensrcFile.generatePbxFileReference(workspaceRootPathFromOutputDir);\n+        String srcFiles = srcFile.generatePbxFileReference(workspaceRootPathFromOutputDir);\n+        String testFiles = testFile.generatePbxFileReference(workspaceRootPathFromOutputDir);\n+        string = string.replaceFirst(TEMPLATE_PBXFILEREFERENCE, gensrcFiles + srcFiles + testFiles);\n+\n+        String gensrcCompiled = gensrcFile.generatePbxBuildFile();\n+        String compiled = srcFile.generatePbxBuildFile();\n+        string = string.replaceFirst(TEMPLATE_PBXBUILDFILE, gensrcCompiled + compiled);\n+\n+        String gensrcBuilt = gensrcFile.generatePbxSourcesBuildPhase();\n+        String built = srcFile.generatePbxSourcesBuildPhase();\n+        string = string.replaceFirst(TEMPLATE_PBXSOURCESSBUILDPHASE, gensrcBuilt + built);\n+\n+        return string;\n+    }\n+\n+    private String makeTemplateXcscheme(String outputDir, String string) {\n+        string = string.replaceAll(TEMPLATE_JDK_PATH, outputDir);\n+\n+        return string;\n+    }\n+\n+    public void makeXcodeProj(String outputDir, String workspaceRootPathFromOutputDir) {\n+    \/*\n+     jvm.xcodeproj                     <-- folder\n+       project.pbxproj                 <-- file\n+       xcshareddata                    <-- folder\n+         xcschemes                     <-- folder\n+           jvm.xcscheme                <-- file\n+         xcdebugger                    <-- folder\n+           Breakpoints_v2.xcbkptlist   <-- file\n+     *\/\n+        File xcodeDir = new File(outputDir);\n+        File jvmXcodeprojDir = new File(xcodeDir, HOTSPOT_PBXPROJ);\n+        File projectPbxprojFile = new File(jvmXcodeprojDir, PBXPROJ);\n+        File xcshareddataDir = new File(jvmXcodeprojDir, XCSAHAREDDATA);\n+        File xcschemesDir = new File(xcshareddataDir, XCSCHEMES);\n+        File jvmXcschemeFile = new File(xcschemesDir, JVM_XCSCHEME);\n+        File j2DemoXcschemeFile = new File(xcschemesDir, J2D_XCSCHEME);\n+        File xcdebuggerDir = new File(xcshareddataDir, XCDEBUGGER);\n+        File jBreakpointsV2XcbkptlistFile = new File(xcdebuggerDir, XCBKPTLIST);\n+\n+        if (xcodeDir.exists()) {\n+            xcodeDir.delete();\n+        }\n+\n+        jvmXcodeprojDir.mkdirs();\n+        xcshareddataDir.mkdirs();\n+        xcschemesDir.mkdirs();\n+        xcdebuggerDir.mkdirs();\n+\n+        File dataDir = new File(projectMakerDataPath);\n+        File templateProjectPbxprojFile = new File(dataDir, TEMPLATE_PBXPROJ);\n+        File templateJvmXcschemeFile = new File(dataDir, TEMPLATE_JVM_XCSCHEME);\n+        File templateJ2DemoXcschemeFile = new File(dataDir, TEMPLATE_J2D_XCSCHEME);\n+        File templateJBreakpointsV2XcbkptlistFile = new File(dataDir, TEMPLATE_XCBKPTLIST);\n+\n+        String projectPbxprojString = readFile(templateProjectPbxprojFile);\n+        String jvmXcschemeString = readFile(templateJvmXcschemeFile);\n+        String j2DemoXcschemeString = readFile(templateJ2DemoXcschemeFile);\n+        String jBreakpointsV2XcbkptlistString = readFile(templateJBreakpointsV2XcbkptlistFile);\n+\n+        writeFile(projectPbxprojFile, makeProjectPbxproj(workspaceRootPathFromOutputDir, projectPbxprojString));\n+        writeFile(jvmXcschemeFile, makeTemplateXcscheme(outputDir, jvmXcschemeString));\n+        writeFile(j2DemoXcschemeFile, makeTemplateXcscheme(outputDir, j2DemoXcschemeString));\n+        writeFile(jBreakpointsV2XcbkptlistFile, jBreakpointsV2XcbkptlistString);\n+    }\n+\n+    public void makeAliases(String outputDir, String pathToBuild) {\n+        File xcodeDir = new File(outputDir);\n+        File jdkOldSh = new File(xcodeDir, ALIAS_JAVA_OLD);\n+        File jdkNewSh = new File(xcodeDir, ALIAS_JAVA_NEW);\n+\n+        writeFile(jdkOldSh, \"#!\/bin\/bash\\n\" + pathToBuild + JDK_BIN_JAVA + \" $@\");\n+        writeFile(jdkNewSh, \"#!\/bin\/bash\\n\" + outputDir + \"\/build\" + JDK_BIN_JAVA + \" $@\");\n+\n+        try {\n+            Set<PosixFilePermission> permissions = new HashSet<>();\n+            permissions.add(PosixFilePermission.OWNER_READ);\n+            permissions.add(PosixFilePermission.OWNER_WRITE);\n+            permissions.add(PosixFilePermission.OWNER_EXECUTE);\n+            permissions.add(PosixFilePermission.GROUP_READ);\n+            permissions.add(PosixFilePermission.OTHERS_READ);\n+            Files.setPosixFilePermissions(jdkOldSh.toPath(), permissions);\n+            Files.setPosixFilePermissions(jdkNewSh.toPath(), permissions);\n+        } catch (IOException ex) {\n+            System.err.println(\"Warning: unable to change file permissions\");\n+            System.err.println(ex);\n+        }\n+    }\n+\n+    private static class HotspotFileVisitor implements FileVisitor<Path> {\n+        private final DiskFile root;\n+        private final String hotspotPath;\n+\n+        public HotspotFileVisitor(DiskFile root, String hotspotPath) {\n+            this.root = root;\n+            this.hotspotPath = hotspotPath;\n+        }\n+\n+        @Override\n+        public FileVisitResult preVisitDirectory(Path path, BasicFileAttributes attrs) {\n+            if (excludeFile(path)) {\n+                return FileVisitResult.SKIP_SUBTREE;\n+            } else {\n+                \/\/ consider folders based on their names\n+                Path file = path.getFileName();\n+                if (!excludeFile(file)) {\n+                    root.addDirectory(path, hotspotPath);\n+                    return FileVisitResult.CONTINUE;\n+                } else {\n+                    \/\/ skip folders with names beginning with \".\", etc\n+                    return FileVisitResult.SKIP_SUBTREE;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n+            Path file = path.getFileName();\n+            if (!excludeFile(file)) {\n+                \/\/System.err.println(path.toString());\n+                root.addFile(path, hotspotPath);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        @Override\n+        public FileVisitResult postVisitDirectory(Path path, IOException exc) {\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFileFailed(Path path, IOException exc) {\n+            if (exc instanceof FileSystemLoopException) {\n+                System.err.println(\"cycle detected: \" + path);\n+            } else {\n+                System.err.format(\"Unable to process: %s: %s\\n\", path, exc);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+    }\n+}\n","filename":"make\/ide\/xcode\/hotspot\/src\/classes\/XcodeProjectMaker.java","additions":754,"deletions":0,"binary":false,"changes":754,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,5 +54,0 @@\n-  define copy-and-chmod\n-\t$(install-file)\n-\t$(CHMOD) a+rx $@\n-  endef\n-\n@@ -61,1 +56,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_MSVCR, \\\n+  $(eval $(call SetupCopyFiles, COPY_MSVCR, \\\n@@ -64,1 +59,2 @@\n-      MACRO := copy-and-chmod))\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n@@ -66,1 +62,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_VCRUNTIME_1, \\\n+  $(eval $(call SetupCopyFiles, COPY_VCRUNTIME_1, \\\n@@ -69,1 +65,2 @@\n-      MACRO := copy-and-chmod))\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n@@ -71,1 +68,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_MSVCP, \\\n+  $(eval $(call SetupCopyFiles, COPY_MSVCP, \\\n@@ -74,1 +71,2 @@\n-      MACRO := copy-and-chmod))\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n@@ -83,1 +81,1 @@\n-        MACRO := copy-and-chmod, \\\n+        MACRO := copy-and-chmod-executable, \\\n","filename":"make\/modules\/java.base\/Copy.gmk","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+    CREATE_API_DIGEST := true, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    DISABLED_WARNINGS := try deprecation rawtypes unchecked serial cast removal preview dangling-doc-comments, \\\n+    DISABLED_WARNINGS := try deprecation rawtypes unchecked serial cast removal preview restricted dangling-doc-comments, \\\n","filename":"make\/test\/BuildTestLib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/images\/About.jpg","binary":true,"status":"modified"},{"patch":"@@ -2723,1 +2723,1 @@\n-      \/* Fix up any out-of-range offsets. *\/\n+      \/\/ Fix up any out-of-range offsets.\n@@ -2764,1 +2764,5 @@\n-      (masm->*insn)(reg, T, Address(base, disp));\n+      \/\/ Fix up any out-of-range offsets.\n+      assert_different_registers(rscratch1, base);\n+      Address addr = Address(base, disp);\n+      addr = __ legitimize_address(addr, (1 << T), rscratch1);\n+      (masm->*insn)(reg, T, addr);\n@@ -2819,1 +2823,1 @@\n-  enc_class aarch64_enc_ldrsbw(iRegI dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrsbw(iRegI dst, memory mem) %{\n@@ -2827,1 +2831,1 @@\n-  enc_class aarch64_enc_ldrsb(iRegI dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrsb(iRegI dst, memory mem) %{\n@@ -2835,1 +2839,1 @@\n-  enc_class aarch64_enc_ldrb(iRegI dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrb(iRegI dst, memory mem) %{\n@@ -2843,1 +2847,1 @@\n-  enc_class aarch64_enc_ldrb(iRegL dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrb(iRegL dst, memory mem) %{\n@@ -2851,1 +2855,1 @@\n-  enc_class aarch64_enc_ldrshw(iRegI dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrshw(iRegI dst, memory mem) %{\n@@ -2859,1 +2863,1 @@\n-  enc_class aarch64_enc_ldrsh(iRegI dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrsh(iRegI dst, memory mem) %{\n@@ -2867,1 +2871,1 @@\n-  enc_class aarch64_enc_ldrh(iRegI dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrh(iRegI dst, memory mem) %{\n@@ -2875,1 +2879,1 @@\n-  enc_class aarch64_enc_ldrh(iRegL dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrh(iRegL dst, memory mem) %{\n@@ -2883,1 +2887,1 @@\n-  enc_class aarch64_enc_ldrw(iRegI dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrw(iRegI dst, memory mem) %{\n@@ -2891,1 +2895,1 @@\n-  enc_class aarch64_enc_ldrw(iRegL dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrw(iRegL dst, memory mem) %{\n@@ -2899,1 +2903,1 @@\n-  enc_class aarch64_enc_ldrsw(iRegL dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrsw(iRegL dst, memory mem) %{\n@@ -2907,1 +2911,1 @@\n-  enc_class aarch64_enc_ldr(iRegL dst, memory8 mem) %{\n+  enc_class aarch64_enc_ldr(iRegL dst, memory mem) %{\n@@ -2915,1 +2919,1 @@\n-  enc_class aarch64_enc_ldrs(vRegF dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrs(vRegF dst, memory mem) %{\n@@ -2923,1 +2927,1 @@\n-  enc_class aarch64_enc_ldrd(vRegD dst, memory8 mem) %{\n+  enc_class aarch64_enc_ldrd(vRegD dst, memory mem) %{\n@@ -2931,1 +2935,1 @@\n-  enc_class aarch64_enc_strb(iRegI src, memory1 mem) %{\n+  enc_class aarch64_enc_strb(iRegI src, memory mem) %{\n@@ -2939,1 +2943,1 @@\n-  enc_class aarch64_enc_strb0(memory1 mem) %{\n+  enc_class aarch64_enc_strb0(memory mem) %{\n@@ -2946,1 +2950,1 @@\n-  enc_class aarch64_enc_strh(iRegI src, memory2 mem) %{\n+  enc_class aarch64_enc_strh(iRegI src, memory mem) %{\n@@ -2954,1 +2958,1 @@\n-  enc_class aarch64_enc_strh0(memory2 mem) %{\n+  enc_class aarch64_enc_strh0(memory mem) %{\n@@ -2961,1 +2965,1 @@\n-  enc_class aarch64_enc_strw(iRegI src, memory4 mem) %{\n+  enc_class aarch64_enc_strw(iRegI src, memory mem) %{\n@@ -2969,1 +2973,1 @@\n-  enc_class aarch64_enc_strw0(memory4 mem) %{\n+  enc_class aarch64_enc_strw0(memory mem) %{\n@@ -2976,1 +2980,1 @@\n-  enc_class aarch64_enc_str(iRegL src, memory8 mem) %{\n+  enc_class aarch64_enc_str(iRegL src, memory mem) %{\n@@ -2991,1 +2995,1 @@\n-  enc_class aarch64_enc_str0(memory8 mem) %{\n+  enc_class aarch64_enc_str0(memory mem) %{\n@@ -2998,1 +3002,1 @@\n-  enc_class aarch64_enc_strs(vRegF src, memory4 mem) %{\n+  enc_class aarch64_enc_strs(vRegF src, memory mem) %{\n@@ -3006,1 +3010,1 @@\n-  enc_class aarch64_enc_strd(vRegD src, memory8 mem) %{\n+  enc_class aarch64_enc_strd(vRegD src, memory mem) %{\n@@ -3014,1 +3018,1 @@\n-  enc_class aarch64_enc_strb0_ordered(memory4 mem) %{\n+  enc_class aarch64_enc_strb0_ordered(memory mem) %{\n@@ -3216,1 +3220,1 @@\n-  enc_class aarch64_enc_ldaxr(iRegL dst, memory8 mem) %{\n+  enc_class aarch64_enc_ldaxr(iRegL dst, memory mem) %{\n@@ -3244,1 +3248,1 @@\n-  enc_class aarch64_enc_stlxr(iRegLNoSp src, memory8 mem) %{\n+  enc_class aarch64_enc_stlxr(iRegLNoSp src, memory mem) %{\n@@ -4172,1 +4176,1 @@\n-\/\/ Offset for scaled or unscaled immediate loads and stores\n+\/\/ Offset for immediate loads and stores\n@@ -4175,51 +4179,1 @@\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 0));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset1()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 0));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset2()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 1));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset4()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 2));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset8()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 3));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset16()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 4));\n+  predicate(n->get_int() >= -256 && n->get_int() <= 65520);\n@@ -4243,50 +4197,0 @@\n-operand immLoffset1()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 0));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset2()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 1));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset4()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 2));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset8()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 3));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset16()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 4));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -5205,15 +5109,1 @@\n-operand indOffI1(iRegP reg, immIOffset1 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffI2(iRegP reg, immIOffset2 off)\n+operand indOffI(iRegP reg, immIOffset off)\n@@ -5233,99 +5123,1 @@\n-operand indOffI4(iRegP reg, immIOffset4 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffI8(iRegP reg, immIOffset8 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffI16(iRegP reg, immIOffset16 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL1(iRegP reg, immLoffset1 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL2(iRegP reg, immLoffset2 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL4(iRegP reg, immLoffset4 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL8(iRegP reg, immLoffset8 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL16(iRegP reg, immLoffset16 off)\n+operand indOffL(iRegP reg, immLOffset off)\n@@ -5707,4 +5499,1 @@\n-opclass vmem2(indirect, indIndex, indOffI2, indOffL2);\n-opclass vmem4(indirect, indIndex, indOffI4, indOffL4);\n-opclass vmem8(indirect, indIndex, indOffI8, indOffL8);\n-opclass vmem16(indirect, indIndex, indOffI16, indOffL16);\n+opclass vmem(indirect, indIndex, indOffI, indOffL, indOffIN, indOffLN);\n@@ -5722,17 +5511,3 @@\n-opclass memory1(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI1, indOffL1,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n-\n-opclass memory2(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI2, indOffL2,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n-\n-opclass memory4(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI4, indOffL4,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n-\n-opclass memory8(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI8, indOffL8,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n-\n-\/\/ All of the memory operands. For the pipeline description.\n-opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex,\n-               indOffI1, indOffL1, indOffI2, indOffL2, indOffI4, indOffL4, indOffI8, indOffL8,\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n-\n+opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI, indOffL,\n+               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN,\n+               indOffLN, indirectX2P, indOffX2P);\n@@ -6440,1 +6215,1 @@\n-instruct loadB(iRegINoSp dst, memory1 mem)\n+instruct loadB(iRegINoSp dst, memory mem)\n@@ -6454,1 +6229,1 @@\n-instruct loadB2L(iRegLNoSp dst, memory1 mem)\n+instruct loadB2L(iRegLNoSp dst, memory mem)\n@@ -6468,1 +6243,1 @@\n-instruct loadUB(iRegINoSp dst, memory1 mem)\n+instruct loadUB(iRegINoSp dst, memory mem)\n@@ -6482,1 +6257,1 @@\n-instruct loadUB2L(iRegLNoSp dst, memory1 mem)\n+instruct loadUB2L(iRegLNoSp dst, memory mem)\n@@ -6496,1 +6271,1 @@\n-instruct loadS(iRegINoSp dst, memory2 mem)\n+instruct loadS(iRegINoSp dst, memory mem)\n@@ -6510,1 +6285,1 @@\n-instruct loadS2L(iRegLNoSp dst, memory2 mem)\n+instruct loadS2L(iRegLNoSp dst, memory mem)\n@@ -6524,1 +6299,1 @@\n-instruct loadUS(iRegINoSp dst, memory2 mem)\n+instruct loadUS(iRegINoSp dst, memory mem)\n@@ -6538,1 +6313,1 @@\n-instruct loadUS2L(iRegLNoSp dst, memory2 mem)\n+instruct loadUS2L(iRegLNoSp dst, memory mem)\n@@ -6552,1 +6327,1 @@\n-instruct loadI(iRegINoSp dst, memory4 mem)\n+instruct loadI(iRegINoSp dst, memory mem)\n@@ -6566,1 +6341,1 @@\n-instruct loadI2L(iRegLNoSp dst, memory4 mem)\n+instruct loadI2L(iRegLNoSp dst, memory mem)\n@@ -6580,1 +6355,1 @@\n-instruct loadUI2L(iRegLNoSp dst, memory4 mem, immL_32bits mask)\n+instruct loadUI2L(iRegLNoSp dst, memory mem, immL_32bits mask)\n@@ -6594,1 +6369,1 @@\n-instruct loadL(iRegLNoSp dst, memory8 mem)\n+instruct loadL(iRegLNoSp dst, memory mem)\n@@ -6608,1 +6383,1 @@\n-instruct loadRange(iRegINoSp dst, memory4 mem)\n+instruct loadRange(iRegINoSp dst, memory mem)\n@@ -6621,1 +6396,1 @@\n-instruct loadP(iRegPNoSp dst, memory8 mem)\n+instruct loadP(iRegPNoSp dst, memory mem)\n@@ -6635,1 +6410,1 @@\n-instruct loadN(iRegNNoSp dst, memory4 mem)\n+instruct loadN(iRegNNoSp dst, memory mem)\n@@ -6649,1 +6424,1 @@\n-instruct loadKlass(iRegPNoSp dst, memory8 mem)\n+instruct loadKlass(iRegPNoSp dst, memory mem)\n@@ -6663,1 +6438,1 @@\n-instruct loadNKlass(iRegNNoSp dst, memory4 mem)\n+instruct loadNKlass(iRegNNoSp dst, memory mem)\n@@ -6677,1 +6452,1 @@\n-instruct loadF(vRegF dst, memory4 mem)\n+instruct loadF(vRegF dst, memory mem)\n@@ -6691,1 +6466,1 @@\n-instruct loadD(vRegD dst, memory8 mem)\n+instruct loadD(vRegD dst, memory mem)\n@@ -6895,1 +6670,1 @@\n-instruct storeimmCM0(immI0 zero, memory1 mem)\n+instruct storeimmCM0(immI0 zero, memory mem)\n@@ -6910,1 +6685,1 @@\n-instruct storeimmCM0_ordered(immI0 zero, memory1 mem)\n+instruct storeimmCM0_ordered(immI0 zero, memory mem)\n@@ -6925,1 +6700,1 @@\n-instruct storeB(iRegIorL2I src, memory1 mem)\n+instruct storeB(iRegIorL2I src, memory mem)\n@@ -6939,1 +6714,1 @@\n-instruct storeimmB0(immI0 zero, memory1 mem)\n+instruct storeimmB0(immI0 zero, memory mem)\n@@ -6953,1 +6728,1 @@\n-instruct storeC(iRegIorL2I src, memory2 mem)\n+instruct storeC(iRegIorL2I src, memory mem)\n@@ -6966,1 +6741,1 @@\n-instruct storeimmC0(immI0 zero, memory2 mem)\n+instruct storeimmC0(immI0 zero, memory mem)\n@@ -6981,1 +6756,1 @@\n-instruct storeI(iRegIorL2I src, memory4 mem)\n+instruct storeI(iRegIorL2I src, memory mem)\n@@ -6994,1 +6769,1 @@\n-instruct storeimmI0(immI0 zero, memory4 mem)\n+instruct storeimmI0(immI0 zero, memory mem)\n@@ -7008,1 +6783,1 @@\n-instruct storeL(iRegL src, memory8 mem)\n+instruct storeL(iRegL src, memory mem)\n@@ -7022,1 +6797,1 @@\n-instruct storeimmL0(immL0 zero, memory8 mem)\n+instruct storeimmL0(immL0 zero, memory mem)\n@@ -7036,1 +6811,1 @@\n-instruct storeP(iRegP src, memory8 mem)\n+instruct storeP(iRegP src, memory mem)\n@@ -7050,1 +6825,1 @@\n-instruct storeimmP0(immP0 zero, memory8 mem)\n+instruct storeimmP0(immP0 zero, memory mem)\n@@ -7064,1 +6839,1 @@\n-instruct storeN(iRegN src, memory4 mem)\n+instruct storeN(iRegN src, memory mem)\n@@ -7077,1 +6852,1 @@\n-instruct storeImmN0(immN0 zero, memory4 mem)\n+instruct storeImmN0(immN0 zero, memory mem)\n@@ -7091,1 +6866,1 @@\n-instruct storeF(vRegF src, memory4 mem)\n+instruct storeF(vRegF src, memory mem)\n@@ -7108,1 +6883,1 @@\n-instruct storeD(vRegD src, memory8 mem)\n+instruct storeD(vRegD src, memory mem)\n@@ -7122,1 +6897,1 @@\n-instruct storeNKlass(iRegN src, memory4 mem)\n+instruct storeNKlass(iRegN src, memory mem)\n@@ -7141,1 +6916,1 @@\n-instruct prefetchalloc( memory8 mem ) %{\n+instruct prefetchalloc( memory mem ) %{\n@@ -7710,1 +7485,1 @@\n-instruct popCountI_mem(iRegINoSp dst, memory4 mem, vRegF tmp) %{\n+instruct popCountI_mem(iRegINoSp dst, memory mem, vRegF tmp) %{\n@@ -7751,1 +7526,1 @@\n-instruct popCountL_mem(iRegINoSp dst, memory8 mem, vRegD tmp) %{\n+instruct popCountL_mem(iRegINoSp dst, memory mem, vRegD tmp) %{\n@@ -16021,1 +15796,1 @@\n-    __ fast_lock_lightweight($object$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n+    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -16037,1 +15812,1 @@\n-    __ fast_unlock_lightweight($object$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n+    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -16900,1 +16675,1 @@\n-instruct compressBitsI_memcon(iRegINoSp dst, memory4 mem, immI mask,\n+instruct compressBitsI_memcon(iRegINoSp dst, memory mem, immI mask,\n@@ -16937,1 +16712,1 @@\n-instruct compressBitsL_memcon(iRegLNoSp dst, memory8 mem, immL mask,\n+instruct compressBitsL_memcon(iRegLNoSp dst, memory mem, immL mask,\n@@ -16974,1 +16749,1 @@\n-instruct expandBitsI_memcon(iRegINoSp dst, memory4 mem, immI mask,\n+instruct expandBitsI_memcon(iRegINoSp dst, memory mem, immI mask,\n@@ -17012,1 +16787,1 @@\n-instruct expandBitsL_memcon(iRegINoSp dst, memory8 mem, immL mask,\n+instruct expandBitsL_memcon(iRegINoSp dst, memory mem, immL mask,\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":86,"deletions":311,"binary":false,"changes":397,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-instruct loadV2(vReg dst, vmem2 mem) %{\n+instruct loadV2(vReg dst, vmem mem) %{\n@@ -357,1 +357,1 @@\n-instruct storeV2(vReg src, vmem2 mem) %{\n+instruct storeV2(vReg src, vmem mem) %{\n@@ -366,1 +366,1 @@\n-instruct loadV4(vReg dst, vmem4 mem) %{\n+instruct loadV4(vReg dst, vmem mem) %{\n@@ -375,1 +375,1 @@\n-instruct storeV4(vReg src, vmem4 mem) %{\n+instruct storeV4(vReg src, vmem mem) %{\n@@ -384,1 +384,1 @@\n-instruct loadV8(vReg dst, vmem8 mem) %{\n+instruct loadV8(vReg dst, vmem mem) %{\n@@ -393,1 +393,1 @@\n-instruct storeV8(vReg src, vmem8 mem) %{\n+instruct storeV8(vReg src, vmem mem) %{\n@@ -402,1 +402,1 @@\n-instruct loadV16(vReg dst, vmem16 mem) %{\n+instruct loadV16(vReg dst, vmem mem) %{\n@@ -411,1 +411,1 @@\n-instruct storeV16(vReg src, vmem16 mem) %{\n+instruct storeV16(vReg src, vmem mem) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-instruct $1V$2(vReg $3, vmem$2 mem) %{\n+instruct $1V$2(vReg $3, vmem mem) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  enc_class aarch64_enc_$2($1 dst, memory$5 mem) %{dnl\n+  enc_class aarch64_enc_$2($1 dst, memory mem) %{dnl\n@@ -56,1 +56,1 @@\n-  enc_class aarch64_enc_$2($1 src, memory$5 mem) %{dnl\n+  enc_class aarch64_enc_$2($1 src, memory mem) %{dnl\n@@ -61,1 +61,1 @@\n-  enc_class aarch64_enc_$2`'0(memory$4 mem) %{\n+  enc_class aarch64_enc_$2`'0(memory mem) %{\n@@ -85,1 +85,1 @@\n-  enc_class aarch64_enc_strb0_ordered(memory4 mem) %{\n+  enc_class aarch64_enc_strb0_ordered(memory mem) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/ad_encode.m4","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    lightweight_lock(obj, hdr, temp, rscratch2, slow_case);\n+    lightweight_lock(disp_hdr, obj, hdr, temp, rscratch2, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register t1,\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register t1,\n@@ -230,1 +230,1 @@\n-  assert_different_registers(obj, t1, t2, t3);\n+  assert_different_registers(obj, box, t1, t2, t3);\n@@ -239,0 +239,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    str(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }\n+\n@@ -247,0 +252,1 @@\n+  const Register t3_t = t3;\n@@ -254,1 +260,0 @@\n-    const Register t3_t = t3;\n@@ -292,3 +297,38 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register t1_tagged_monitor = t1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register t1_monitor = t1;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(t1_monitor == t1_mark, \"should be the same here\");\n+    } else {\n+      Label monitor_found;\n+\n+      \/\/ Load cache address\n+      lea(t3_t, Address(rthread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        ldr(t1, Address(t3_t));\n+        cmp(obj, t1);\n+        br(Assembler::EQ, monitor_found);\n+        increment(t3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      Label loop;\n+\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      ldr(t1, Address(t3_t));\n+      cmp(obj, t1);\n+      br(Assembler::EQ, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      increment(t3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      cbnz(t1, loop);\n+      \/\/ Cache Miss, NE set from cmp above, cbnz does not set flags\n+      b(slow_path);\n+\n+      bind(monitor_found);\n+      ldr(t1_monitor, Address(t3_t, OMCache::oop_to_monitor_difference()));\n+    }\n+\n@@ -297,0 +337,5 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address owner_address(t1_monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+    const Address recursions_address(t1_monitor, ObjectMonitor::recursions_offset() - monitor_tag);\n+\n+    Label monitor_locked;\n@@ -299,1 +344,1 @@\n-    lea(t2_owner_addr, Address(t1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n+    lea(t2_owner_addr, owner_address);\n@@ -304,1 +349,1 @@\n-    br(Assembler::EQ, locked);\n+    br(Assembler::EQ, monitor_locked);\n@@ -311,1 +356,6 @@\n-    increment(Address(t1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1);\n+    increment(recursions_address, 1);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      str(t1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+    }\n@@ -334,2 +384,2 @@\n-void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register t1, Register t2,\n-                                                Register t3) {\n+void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register box, Register t1,\n+                                                Register t2, Register t3) {\n@@ -337,1 +387,1 @@\n-  assert_different_registers(obj, t1, t2, t3);\n+  assert_different_registers(obj, box, t1, t2, t3);\n@@ -340,1 +390,1 @@\n-  Label inflated, inflated_load_monitor;\n+  Label inflated, inflated_load_mark;\n@@ -352,0 +402,2 @@\n+    Label push_and_slow_path;\n+\n@@ -358,1 +410,1 @@\n-    br(Assembler::NE, inflated_load_monitor);\n+    br(Assembler::NE, inflated_load_mark);\n@@ -375,1 +427,4 @@\n-    tbnz(t1_mark, exact_log2(markWord::monitor_value), inflated);\n+    \/\/ Because we got here by popping (meaning we pushed in locked)\n+    \/\/ there will be no monitor in the box. So we need to push back the obj\n+    \/\/ so that the runtime can fix any potential anonymous owner.\n+    tbnz(t1_mark, exact_log2(markWord::monitor_value), UseObjectMonitorTable ? push_and_slow_path : inflated);\n@@ -384,0 +439,1 @@\n+    bind(push_and_slow_path);\n@@ -394,1 +450,1 @@\n-    bind(inflated_load_monitor);\n+    bind(inflated_load_mark);\n@@ -415,3 +471,4 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register t1_monitor = t1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register t1_monitor = t1;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(t1_monitor == t1_mark, \"should be the same here\");\n@@ -419,2 +476,8 @@\n-    \/\/ Untag the monitor.\n-    sub(t1_monitor, t1_mark, monitor_tag);\n+      \/\/ Untag the monitor.\n+      add(t1_monitor, t1_mark, -(int)markWord::monitor_value);\n+    } else {\n+      ldr(t1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ null check with Flags == NE, no valid pointer below alignof(ObjectMonitor*)\n+      cmp(t1_monitor, checked_cast<uint8_t>(alignof(ObjectMonitor*)));\n+      br(Assembler::LO, slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":84,"deletions":21,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-  void fast_lock_lightweight(Register object, Register t1, Register t2, Register t3);\n-  void fast_unlock_lightweight(Register object, Register t1, Register t2, Register t3);\n+  void fast_lock_lightweight(Register object, Register box, Register t1, Register t2, Register t3);\n+  void fast_unlock_lightweight(Register object, Register box, Register t1, Register t2, Register t3);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-instruct xLoadP(iRegPNoSp dst, memory8 mem, rFlagsReg cr)\n+instruct xLoadP(iRegPNoSp dst, memory mem, rFlagsReg cr)\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/x\/x_aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-instruct zLoadP(iRegPNoSp dst, memory8 mem, rFlagsReg cr)\n+instruct zLoadP(iRegPNoSp dst, memory mem, rFlagsReg cr)\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -699,1 +699,1 @@\n-      lightweight_lock(obj_reg, tmp, tmp2, tmp3, slow_case);\n+      lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n@@ -755,9 +755,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-              obj_reg);\n-    } else {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-              lock_reg);\n-    }\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+            lock_reg);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -747,1 +747,1 @@\n-    lea(rscratch1, RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+    lea(rscratch1, RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n@@ -6753,1 +6753,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register t1, Register t2, Register t3, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register t1, Register t2, Register t3, Label& slow) {\n@@ -6755,1 +6755,1 @@\n-  assert_different_registers(obj, t1, t2, t3, rscratch1);\n+  assert_different_registers(basic_lock, obj, t1, t2, t3, rscratch1);\n@@ -6766,0 +6766,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    str(zr, Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1642,1 +1642,1 @@\n-  void lightweight_lock(Register obj, Register t1, Register t2, Register t3, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register t1, Register t2, Register t3, Label& slow);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_AbstractMethodError_entry()));\n@@ -454,1 +454,1 @@\n-      __ far_jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));\n+      __ far_jump(RuntimeAddress(SharedRuntime::throw_IncompatibleClassChangeError_entry()));\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif\n+\n@@ -1814,1 +1820,1 @@\n-      __ lightweight_lock(obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n+      __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -2767,0 +2773,190 @@\n+\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Since we need to preserve callee-saved values (currently\n+\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+\/\/ map and therefore have to make these stubs into RuntimeStubs\n+\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+\/\/ be preserved between the fault point and the exception handler\n+\/\/ then it must assume responsibility for that in\n+\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  \/\/ n.b. aarch64 asserts that frame::arg_reg_save_area_bytes == 0\n+  enum layout {\n+    rfp_off = 0,\n+    rfp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 512;\n+  int locs_size  = 64;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+\n+  __ enter(); \/\/ Save FP and LR before call\n+\n+  assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n+\n+  \/\/ lr and fp are already in place\n+  __ sub(sp, rfp, ((uint64_t)framesize-4) << LogBytesPerInt); \/\/ prolog\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n+\n+  __ mov(c_rarg0, rthread);\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ mov(rscratch1, runtime_entry);\n+  __ blr(rscratch1);\n+\n+  \/\/ Generate oop map\n+  OopMap* map = new OopMap(framesize, 0);\n+\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+  \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+  __ reinitialize_ptrue();\n+\n+  __ leave();\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));\n+  __ cbnz(rscratch1, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/\/ ASSERT\n+  __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+static void jfr_prologue(address the_pc, MacroAssembler* masm, Register thread) {\n+  __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n+  __ mov(c_rarg0, thread);\n+}\n+\n+\/\/ The handle is dereferenced through a load barrier.\n+static void jfr_epilogue(MacroAssembler* masm) {\n+  __ reset_last_Java_frame(true);\n+}\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+  jfr_epilogue(masm);\n+  __ resolve_global_jobject(r0, rscratch1, rscratch2);\n+  __ leave();\n+  __ ret(lr);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+\n+  CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  jfr_epilogue(masm);\n+\n+  __ leave();\n+  __ ret(lr);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":197,"deletions":1,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -7048,1 +7048,1 @@\n-    __ lea(rscratch1, RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+    __ lea(rscratch1, RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -7308,92 +7308,0 @@\n-#if INCLUDE_JFR\n-\n-  static void jfr_prologue(address the_pc, MacroAssembler* _masm, Register thread) {\n-    __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n-    __ mov(c_rarg0, thread);\n-  }\n-\n-  \/\/ The handle is dereferenced through a load barrier.\n-  static void jfr_epilogue(MacroAssembler* _masm) {\n-    __ reset_last_Java_frame(true);\n-  }\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      rbp_off,\n-      rbpH_off,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-    jfr_epilogue(_masm);\n-    __ resolve_global_jobject(r0, rscratch1, rscratch2);\n-    __ leave();\n-    __ ret(lr);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      rbp_off,\n-      rbpH_off,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-    jfr_epilogue(_masm);\n-\n-    __ leave();\n-    __ ret(lr);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -7415,16 +7323,0 @@\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Since we need to preserve callee-saved values (currently\n-  \/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-  \/\/ map and therefore have to make these stubs into RuntimeStubs\n-  \/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-  \/\/ be preserved between the fault point and the exception handler\n-  \/\/ then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n@@ -7434,90 +7326,0 @@\n-  address generate_throw_exception(const char* name,\n-                                   address runtime_entry,\n-                                   Register arg1 = noreg,\n-                                   Register arg2 = noreg) {\n-    \/\/ Information about frame layout at time of blocking runtime call.\n-    \/\/ Note that we only have to preserve callee-saved registers since\n-    \/\/ the compilers are responsible for supplying a continuation point\n-    \/\/ if they expect all registers to be preserved.\n-    \/\/ n.b. aarch64 asserts that frame::arg_reg_save_area_bytes == 0\n-    enum layout {\n-      rfp_off = 0,\n-      rfp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 512;\n-    int locs_size  = 64;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-\n-    __ enter(); \/\/ Save FP and LR before call\n-\n-    assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n-\n-    \/\/ lr and fp are already in place\n-    __ sub(sp, rfp, ((uint64_t)framesize-4) << LogBytesPerInt); \/\/ prolog\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    address the_pc = __ pc();\n-    __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n-\n-    \/\/ Call runtime\n-    if (arg1 != noreg) {\n-      assert(arg2 != c_rarg1, \"clobbered\");\n-      __ mov(c_rarg1, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mov(c_rarg2, arg2);\n-    }\n-    __ mov(c_rarg0, rthread);\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ mov(rscratch1, runtime_entry);\n-    __ blr(rscratch1);\n-\n-    \/\/ Generate oop map\n-    OopMap* map = new OopMap(framesize, 0);\n-\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    __ reset_last_Java_frame(true);\n-\n-    \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n-    \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n-    __ reinitialize_ptrue();\n-\n-    __ leave();\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));\n-    __ cbnz(rscratch1, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/\/ ASSERT\n-    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-    \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name,\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub->entry_point();\n-  }\n-\n@@ -8366,10 +8168,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_StackOverflowError));\n-    StubRoutines::_throw_delayed_StackOverflowError_entry =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_delayed_StackOverflowError));\n-\n@@ -8411,10 +8203,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n-  }\n-\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -8422,1 +8204,0 @@\n-#endif \/\/ INCLUDE_JFR\n@@ -8429,17 +8210,0 @@\n-    StubRoutines::_throw_AbstractMethodError_entry =\n-      generate_throw_exception(\"AbstractMethodError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_AbstractMethodError));\n-\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry =\n-      generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_IncompatibleClassChangeError));\n-\n-    StubRoutines::_throw_NullPointerException_at_call_entry =\n-      generate_throw_exception(\"NullPointerException at call throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_NullPointerException_at_call));\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":237,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -755,2 +755,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -988,9 +988,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Pass oop, not lock, in fast lock case. call_VM wants R1 though.\n-      push(R1);\n-      mov(R1, Robj);\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj), R1);\n-      pop(R1);\n-    } else {\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), Rlock);\n-    }\n+    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), Rlock);\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -143,1 +144,1 @@\n-  __ jump(StubRoutines::throw_AbstractMethodError_entry(), relocInfo::runtime_call_type, Rtemp);\n+  __ jump(SharedRuntime::throw_AbstractMethodError_entry(), relocInfo::runtime_call_type, Rtemp);\n@@ -464,1 +465,1 @@\n-      __ jump(StubRoutines::throw_IncompatibleClassChangeError_entry(), relocInfo::runtime_call_type, Rtemp);\n+      __ jump(SharedRuntime::throw_IncompatibleClassChangeError_entry(), relocInfo::runtime_call_type, Rtemp);\n","filename":"src\/hotspot\/cpu\/arm\/methodHandles_arm.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1731,0 +1731,140 @@\n+\n+\/\/------------------------------------------------------------------------------------------------------------------------\n+\/\/ Continuation point for throwing of implicit exceptions that are not handled in\n+\/\/ the current activation. Fabricates an exception oop and initiates normal\n+\/\/ exception dispatching in this frame.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  int insts_size = 128;\n+  int locs_size  = 32;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps;\n+  int frame_size;\n+  int frame_complete;\n+\n+  oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  frame_size = 2;\n+  __ mov(Rexception_pc, LR);\n+  __ raw_push(FP, LR);\n+\n+  frame_complete = __ pc() - start;\n+\n+  \/\/ Any extra arguments are already supposed to be R1 and R2\n+  __ mov(R0, Rthread);\n+\n+  int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp);\n+  assert(((__ pc()) - start) == __ offset(), \"warning: start differs from code_begin\");\n+  __ call(runtime_entry);\n+  if (pc_offset == -1) {\n+    pc_offset = __ offset();\n+  }\n+\n+  \/\/ Generate oop map\n+  OopMap* map =  new OopMap(frame_size*VMRegImpl::slots_per_word, 0);\n+  oop_maps->add_gc_map(pc_offset, map);\n+  __ reset_last_Java_frame(Rtemp); \/\/ Rtemp free since scratched by far call\n+\n+  __ raw_pop(FP, LR);\n+  __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);\n+\n+  RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                                    frame_size, oop_maps, false);\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    r1_off,\n+    r2_off,\n+    return_off,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ raw_push(R1, R2, LR);\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(SP, FP, true, Rtemp);\n+  __ mov(c_rarg0, Rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), c_rarg0);\n+  __ reset_last_Java_frame(Rtemp);\n+\n+  \/\/ R0 is jobject handle result, unpack and process it through a barrier.\n+  __ resolve_global_jobject(R0, Rtemp, R1);\n+\n+  __ raw_pop(R1, R2, LR);\n+  __ ret();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    r1_off,\n+    r2_off,\n+    return_off,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_return_lease\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ raw_push(R1, R2, LR);\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(SP, FP, true, Rtemp);\n+  __ mov(c_rarg0, Rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), c_rarg0);\n+  __ reset_last_Java_frame(Rtemp);\n+\n+  __ raw_pop(R1, R2, LR);\n+  __ ret();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":140,"deletions":0,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2964,46 +2964,0 @@\n-  \/\/------------------------------------------------------------------------------------------------------------------------\n-  \/\/ Continuation point for throwing of implicit exceptions that are not handled in\n-  \/\/ the current activation. Fabricates an exception oop and initiates normal\n-  \/\/ exception dispatching in this frame.\n-  address generate_throw_exception(const char* name, address runtime_entry) {\n-    int insts_size = 128;\n-    int locs_size  = 32;\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps;\n-    int frame_size;\n-    int frame_complete;\n-\n-    oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-\n-    frame_size = 2;\n-    __ mov(Rexception_pc, LR);\n-    __ raw_push(FP, LR);\n-\n-    frame_complete = __ pc() - start;\n-\n-    \/\/ Any extra arguments are already supposed to be R1 and R2\n-    __ mov(R0, Rthread);\n-\n-    int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp);\n-    assert(((__ pc()) - start) == __ offset(), \"warning: start differs from code_begin\");\n-    __ call(runtime_entry);\n-    if (pc_offset == -1) {\n-      pc_offset = __ offset();\n-    }\n-\n-    \/\/ Generate oop map\n-    OopMap* map =  new OopMap(frame_size*VMRegImpl::slots_per_word, 0);\n-    oop_maps->add_gc_map(pc_offset, map);\n-    __ reset_last_Java_frame(Rtemp); \/\/ Rtemp free since scratched by far call\n-\n-    __ raw_pop(FP, LR);\n-    __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);\n-\n-    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n-                                                      frame_size, oop_maps, false);\n-    return stub->entry_point();\n-  }\n-\n@@ -3028,89 +2982,0 @@\n-#if INCLUDE_JFR\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      r1_off,\n-      r2_off,\n-      return_off,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-    __ raw_push(R1, R2, LR);\n-    address the_pc = __ pc();\n-\n-    int frame_complete = the_pc - start;\n-\n-    __ set_last_Java_frame(SP, FP, true, Rtemp);\n-    __ mov(c_rarg0, Rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), c_rarg0);\n-    __ reset_last_Java_frame(Rtemp);\n-\n-    \/\/ R0 is jobject handle result, unpack and process it through a barrier.\n-    __ resolve_global_jobject(R0, Rtemp, R1);\n-\n-    __ raw_pop(R1, R2, LR);\n-    __ ret();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(frame_complete, map);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps,\n-                                    false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      r1_off,\n-      r2_off,\n-      return_off,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    CodeBuffer code(\"jfr_return_lease\", 512, 64);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-    __ raw_push(R1, R2, LR);\n-    address the_pc = __ pc();\n-\n-    int frame_complete = the_pc - start;\n-\n-    __ set_last_Java_frame(SP, FP, true, Rtemp);\n-    __ mov(c_rarg0, Rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), c_rarg0);\n-    __ reset_last_Java_frame(Rtemp);\n-\n-    __ raw_pop(R1, R2, LR);\n-    __ ret();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(frame_complete, map);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps,\n-                                    false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -3135,2 +3000,0 @@\n-    StubRoutines::_throw_StackOverflowError_entry  = generate_throw_exception(\"StackOverflowError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));\n-\n@@ -3158,2 +3021,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n@@ -3162,9 +3023,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-  }\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -3174,6 +3026,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in non-core builds\n-    \/\/ and need to be relocatable, so they each fabricate a RuntimeStub internally.\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));\n-\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":0,"deletions":154,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -563,1 +563,1 @@\n-  __ b(StubRoutines::throw_StackOverflowError_entry(), ls);\n+  __ b(SharedRuntime::throw_StackOverflowError_entry(), ls);\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -295,1 +295,1 @@\n-void Assembler::add(Register d, RegisterOrConstant roc, Register s1) {\n+void Assembler::add(Register d, Register s, RegisterOrConstant roc) {\n@@ -299,1 +299,3 @@\n-    addi(d, s1, (int)c);\n+    addi(d, s, (int)c);\n+  } else {\n+    add(d, s, roc.as_register());\n@@ -301,1 +303,0 @@\n-  else add(d, roc.as_register(), s1);\n@@ -304,1 +305,1 @@\n-void Assembler::subf(Register d, RegisterOrConstant roc, Register s1) {\n+void Assembler::sub(Register d, Register s, RegisterOrConstant roc) {\n@@ -308,1 +309,13 @@\n-    addi(d, s1, (int)-c);\n+    addi(d, s, (int)-c);\n+  } else {\n+    sub(d, s, roc.as_register());\n+  }\n+}\n+\n+void Assembler::xorr(Register d, Register s, RegisterOrConstant roc) {\n+  if (roc.is_constant()) {\n+    intptr_t c = roc.as_constant();\n+    assert(is_uimm(c, 16), \"too big\");\n+    xori(d, s, (int)c);\n+  } else {\n+    xorr(d, s, roc.as_register());\n@@ -310,1 +323,0 @@\n-  else subf(d, roc.as_register(), s1);\n@@ -313,1 +325,1 @@\n-void Assembler::cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1) {\n+void Assembler::cmpw(ConditionRegister d, Register s, RegisterOrConstant roc) {\n@@ -317,1 +329,13 @@\n-    cmpdi(d, s1, (int)c);\n+    cmpwi(d, s, (int)c);\n+  } else {\n+    cmpw(d, s, roc.as_register());\n+  }\n+}\n+\n+void Assembler::cmpd(ConditionRegister d, Register s, RegisterOrConstant roc) {\n+  if (roc.is_constant()) {\n+    intptr_t c = roc.as_constant();\n+    assert(is_simm(c, 16), \"too big\");\n+    cmpdi(d, s, (int)c);\n+  } else {\n+    cmpd(d, s, roc.as_register());\n@@ -319,1 +343,0 @@\n-  else cmpd(d, roc.as_register(), s1);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.cpp","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2515,3 +2515,7 @@\n-  void add( Register d, RegisterOrConstant roc, Register s1);\n-  void subf(Register d, RegisterOrConstant roc, Register s1);\n-  void cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1);\n+  void add( Register d, Register s, RegisterOrConstant roc);\n+  void add( Register d, RegisterOrConstant roc, Register s) { add(d, s, roc); }\n+  void sub( Register d, Register s, RegisterOrConstant roc);\n+  void xorr(Register d, Register s, RegisterOrConstant roc);\n+  void xorr(Register d, RegisterOrConstant roc, Register s) { xorr(d, s, roc); }\n+  void cmpw(ConditionRegister d, Register s, RegisterOrConstant roc);\n+  void cmpd(ConditionRegister d, Register s, RegisterOrConstant roc);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2623,1 +2623,1 @@\n-                noreg, \/*check without ldarx first*\/true);\n+                noreg, nullptr, \/*check without ldarx first*\/true);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -706,1 +706,1 @@\n-                false, success_flag, true);\n+                false, success_flag, nullptr, true);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -338,1 +338,1 @@\n-      __ add(ref_base, ind_or_offs, ref_base);\n+      __ add(ref_base, ref_base, ind_or_offs);\n@@ -346,1 +346,1 @@\n-      __ subf(ref_base, ind_or_offs, ref_base);\n+      __ sub(ref_base, ref_base, ind_or_offs);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1046,5 +1046,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj), object);\n-    } else {\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-    }\n+    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1504,1 +1504,1 @@\n-  load_const_optimized(R0, StubRoutines::throw_delayed_StackOverflowError_entry());\n+  load_const_optimized(R0, SharedRuntime::throw_delayed_StackOverflowError_entry());\n@@ -1623,1 +1623,1 @@\n-                                       Register compare_value, Register exchange_value,\n+                                       RegisterOrConstant compare_value, Register exchange_value,\n@@ -1637,1 +1637,1 @@\n-    assert_different_registers(tmp1, tmp2, dest_current_value, compare_value, exchange_value, addr_base);\n+    assert_different_registers(tmp1, tmp2, dest_current_value, compare_value.register_or_noreg(), exchange_value, addr_base);\n@@ -1698,1 +1698,1 @@\n-                                     Register compare_value, Register exchange_value,\n+                                     RegisterOrConstant compare_value, Register exchange_value,\n@@ -1700,2 +1700,2 @@\n-                                     int semantics, bool cmpxchgx_hint,\n-                                     Register int_flag_success, bool contention_hint, bool weak, int size) {\n+                                     int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                                     Label* failed_ext, bool contention_hint, bool weak, int size) {\n@@ -1703,1 +1703,2 @@\n-  Label failed;\n+  Label failed_int;\n+  Label& failed = (failed_ext != nullptr) ? *failed_ext : failed_int;\n@@ -1709,1 +1710,1 @@\n-  bool preset_result_reg = (int_flag_success != dest_current_value && int_flag_success != compare_value &&\n+  bool preset_result_reg = (int_flag_success != dest_current_value && int_flag_success != compare_value.register_or_noreg() &&\n@@ -1713,0 +1714,1 @@\n+  assert(int_flag_success == noreg || failed_ext == nullptr, \"cannot have both\");\n@@ -1763,1 +1765,1 @@\n-  bind(failed);\n+  bind(failed_int);\n@@ -1790,4 +1792,5 @@\n-void MacroAssembler::cmpxchgd(ConditionRegister flag,\n-                              Register dest_current_value, RegisterOrConstant compare_value, Register exchange_value,\n-                              Register addr_base, int semantics, bool cmpxchgx_hint,\n-                              Register int_flag_success, Label* failed_ext, bool contention_hint, bool weak) {\n+void MacroAssembler::cmpxchgd(ConditionRegister flag, Register dest_current_value,\n+                              RegisterOrConstant compare_value, Register exchange_value,\n+                              Register addr_base,\n+                              int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                              Label* failed_ext, bool contention_hint, bool weak) {\n@@ -1813,1 +1816,1 @@\n-    cmpd(flag, compare_value, dest_current_value);\n+    cmpd(flag, dest_current_value, compare_value);\n@@ -1826,1 +1829,1 @@\n-  cmpd(flag, compare_value, dest_current_value);\n+  cmpd(flag, dest_current_value, compare_value);\n@@ -2173,1 +2176,0 @@\n-\/\/ Return true: we succeeded in generating this code\n@@ -2295,3 +2297,2 @@\n-  assert(Klass::SECONDARY_SUPERS_BITMAP_FULL == ~uintx(0), \"\");\n-  cmpdi(CCR0, r_bitmap, -1);\n-  beq(CCR0, L_huge);\n+  cmpwi(CCR0, r_array_length, (int32_t)Klass::SECONDARY_SUPERS_TABLE_SIZE - 2);\n+  bgt(CCR0, L_huge);\n@@ -2807,26 +2808,33 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tagged_monitor = mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-    const Register owner_addr = tmp2;\n-\n-    \/\/ Compute owner address.\n-    addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n-\n-    \/\/ CAS owner (null => current thread).\n-    cmpxchgd(\/*flag=*\/flag,\n-            \/*current_value=*\/t,\n-            \/*compare_value=*\/(intptr_t)0,\n-            \/*exchange_value=*\/R16_thread,\n-            \/*where=*\/owner_addr,\n-            MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-            MacroAssembler::cmpxchgx_hint_acquire_lock());\n-    beq(flag, locked);\n-\n-    \/\/ Check if recursive.\n-    cmpd(flag, t, R16_thread);\n-    bne(flag, slow_path);\n-\n-    \/\/ Recursive.\n-    ld(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n-    addi(tmp1, tmp1, 1);\n-    std(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register tagged_monitor = mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+      const Register owner_addr = tmp2;\n+\n+      \/\/ Compute owner address.\n+      addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n+\n+      \/\/ CAS owner (null => current thread).\n+      cmpxchgd(\/*flag=*\/flag,\n+              \/*current_value=*\/t,\n+              \/*compare_value=*\/(intptr_t)0,\n+              \/*exchange_value=*\/R16_thread,\n+              \/*where=*\/owner_addr,\n+              MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n+              MacroAssembler::cmpxchgx_hint_acquire_lock());\n+      beq(flag, locked);\n+\n+      \/\/ Check if recursive.\n+      cmpd(flag, t, R16_thread);\n+      bne(flag, slow_path);\n+\n+      \/\/ Recursive.\n+      ld(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+      addi(tmp1, tmp1, 1);\n+      std(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      crxor(flag, Assembler::equal, flag, Assembler::equal);\n+      b(slow_path);\n+    }\n@@ -2900,1 +2908,5 @@\n-    bne(CCR0, inflated);\n+    if (!UseObjectMonitorTable) {\n+      bne(CCR0, inflated);\n+    } else {\n+      bne(CCR0, push_and_slow);\n+    }\n@@ -2946,43 +2958,50 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register monitor = mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-\n-    \/\/ Untag the monitor.\n-    subi(monitor, mark, monitor_tag);\n-\n-    const Register recursions = tmp2;\n-    Label not_recursive;\n-\n-    \/\/ Check if recursive.\n-    ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-    addic_(recursions, recursions, -1);\n-    blt(CCR0, not_recursive);\n-\n-    \/\/ Recursive unlock.\n-    std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-    crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n-    b(unlocked);\n-\n-    bind(not_recursive);\n-\n-    Label release_;\n-    const Register t2 = tmp2;\n-\n-    \/\/ Check if the entry lists are empty.\n-    ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n-    ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n-    orr(t, t, t2);\n-    cmpdi(flag, t, 0);\n-    beq(flag, release_);\n-\n-    \/\/ The owner may be anonymous and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n-    b(slow_path);\n-\n-    bind(release_);\n-    \/\/ Set owner to null.\n-    release();\n-    \/\/ t contains 0\n-    std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register monitor = mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+\n+      \/\/ Untag the monitor.\n+      subi(monitor, mark, monitor_tag);\n+\n+      const Register recursions = tmp2;\n+      Label not_recursive;\n+\n+      \/\/ Check if recursive.\n+      ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+      addic_(recursions, recursions, -1);\n+      blt(CCR0, not_recursive);\n+\n+      \/\/ Recursive unlock.\n+      std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+      crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n+      b(unlocked);\n+\n+      bind(not_recursive);\n+\n+      Label release_;\n+      const Register t2 = tmp2;\n+\n+      \/\/ Check if the entry lists are empty.\n+      ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n+      ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n+      orr(t, t, t2);\n+      cmpdi(flag, t, 0);\n+      beq(flag, release_);\n+\n+      \/\/ The owner may be anonymous and we removed the last obj entry in\n+      \/\/ the lock-stack. This loses the information about the owner.\n+      \/\/ Write the thread to the owner field so the runtime knows the owner.\n+      std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+      b(slow_path);\n+\n+      bind(release_);\n+      \/\/ Set owner to null.\n+      release();\n+      \/\/ t contains 0\n+      std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      crxor(flag, Assembler::equal, flag, Assembler::equal);\n+      b(slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":108,"deletions":89,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -485,1 +485,1 @@\n-                         Register compare_value, Register exchange_value,\n+                         RegisterOrConstant compare_value, Register exchange_value,\n@@ -488,4 +488,5 @@\n-  void cmpxchg_generic(ConditionRegister flag,\n-                       Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                       Register tmp1, Register tmp2,\n-                       int semantics, bool cmpxchgx_hint, Register int_flag_success, bool contention_hint, bool weak, int size);\n+  void cmpxchg_generic(ConditionRegister flag, Register dest_current_value,\n+                       RegisterOrConstant compare_value, Register exchange_value,\n+                       Register addr_base, Register tmp1, Register tmp2,\n+                       int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                       Label* failed_ext, bool contention_hint, bool weak, int size);\n@@ -531,4 +532,5 @@\n-  void cmpxchgb(ConditionRegister flag,\n-                Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                Register tmp1, Register tmp2, int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, bool contention_hint = false, bool weak = false) {\n+  void cmpxchgb(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base, Register tmp1, Register tmp2,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n@@ -536,1 +538,1 @@\n-                    semantics, cmpxchgx_hint, int_flag_success, contention_hint, weak, 1);\n+                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 1);\n@@ -540,4 +542,5 @@\n-  void cmpxchgh(ConditionRegister flag,\n-                Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                Register tmp1, Register tmp2, int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, bool contention_hint = false, bool weak = false) {\n+  void cmpxchgh(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base, Register tmp1, Register tmp2,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n@@ -545,1 +548,1 @@\n-                    semantics, cmpxchgx_hint, int_flag_success, contention_hint, weak, 2);\n+                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 2);\n@@ -547,4 +550,5 @@\n-  void cmpxchgw(ConditionRegister flag,\n-                Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, bool contention_hint = false, bool weak = false) {\n+  void cmpxchgw(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n@@ -552,1 +556,1 @@\n-                    semantics, cmpxchgx_hint, int_flag_success, contention_hint, weak, 4);\n+                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 4);\n@@ -554,4 +558,5 @@\n-  void cmpxchgd(ConditionRegister flag,\n-                Register dest_current_value, RegisterOrConstant compare_value, Register exchange_value,\n-                Register addr_base, int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, Label* failed = nullptr, bool contention_hint = false, bool weak = false);\n+  void cmpxchgd(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":29,"deletions":24,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -161,2 +161,2 @@\n-  assert(StubRoutines::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n-  __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());\n+  assert(SharedRuntime::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n+  __ load_const_optimized(target, SharedRuntime::throw_AbstractMethodError_entry());\n@@ -492,1 +492,1 @@\n-      __ load_const_optimized(temp1, StubRoutines::throw_IncompatibleClassChangeError_entry());\n+      __ load_const_optimized(temp1, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n","filename":"src\/hotspot\/cpu\/ppc\/methodHandles_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7393,1 +7393,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7412,1 +7412,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7431,1 +7431,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7450,1 +7450,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7468,1 +7468,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7486,1 +7486,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7544,1 +7544,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7558,1 +7558,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7572,1 +7572,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7586,1 +7586,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7600,1 +7600,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7614,1 +7614,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7628,1 +7628,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7642,1 +7642,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7656,1 +7656,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7672,1 +7672,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7686,1 +7686,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7702,1 +7702,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7779,1 +7779,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7793,1 +7793,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7807,1 +7807,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7827,1 +7827,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7847,1 +7847,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7861,1 +7861,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7875,1 +7875,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7895,1 +7895,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7915,1 +7915,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7929,1 +7929,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7949,1 +7949,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7963,1 +7963,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -3407,0 +3408,94 @@\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Only callee-saved registers are preserved (through the\n+\/\/ normal register window \/ RegisterMap handling).  If the compiler\n+\/\/ needs all registers to be preserved between the fault point and\n+\/\/ the exception handler then it must assume responsibility for that\n+\/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\/\/\n+\/\/ Note that we generate only this stub into a RuntimeStub, because\n+\/\/ it needs to be properly traversed and ignored during GC, so we\n+\/\/ change the meaning of the \"__\" macro within this method.\n+\/\/\n+\/\/ Note: the routine set_pc_not_at_call_for_caller in\n+\/\/ SharedRuntime.cpp requires that this code be generated into a\n+\/\/ RuntimeStub.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, 1024 DEBUG_ONLY(+ 512), 0);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  int frame_size_in_bytes = frame::native_abi_reg_args_size;\n+  OopMap* map = new OopMap(frame_size_in_bytes \/ sizeof(jint), 0);\n+\n+  address start = __ pc();\n+\n+  __ save_LR(R11_scratch1);\n+\n+  \/\/ Push a frame.\n+  __ push_frame_reg_args(0, R11_scratch1);\n+\n+  address frame_complete_pc = __ pc();\n+\n+  \/\/ Note that we always have a runtime stub frame on the top of\n+  \/\/ stack by this point. Remember the offset of the instruction\n+  \/\/ whose address will be moved to R11_scratch1.\n+  address gc_map_pc = __ get_PC_trash_LR(R11_scratch1);\n+\n+  __ set_last_Java_frame(\/*sp*\/R1_SP, \/*pc*\/R11_scratch1);\n+\n+  __ mr(R3_ARG1, R16_thread);\n+#if defined(ABI_ELFv2)\n+  __ call_c(runtime_entry, relocInfo::none);\n+#else\n+  __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, runtime_entry), relocInfo::none);\n+#endif\n+\n+  \/\/ Set an oopmap for the call site.\n+  oop_maps->add_gc_map((int)(gc_map_pc - start), map);\n+\n+  __ reset_last_Java_frame();\n+\n+#ifdef ASSERT\n+  \/\/ Make sure that this code is only executed if there is a pending\n+  \/\/ exception.\n+  {\n+    Label L;\n+    __ ld(R0,\n+          in_bytes(Thread::pending_exception_offset()),\n+          R16_thread);\n+    __ cmpdi(CCR0, R0, 0);\n+    __ bne(CCR0, L);\n+    __ stop(\"SharedRuntime::throw_exception: no pending exception\");\n+    __ bind(L);\n+  }\n+#endif\n+\n+  \/\/ Pop frame.\n+  __ pop_frame();\n+\n+  __ restore_LR(R11_scratch1);\n+\n+  __ load_const(R11_scratch1, StubRoutines::forward_exception_entry());\n+  __ mtctr(R11_scratch1);\n+  __ bctr();\n+\n+  \/\/ Create runtime stub with OopMap.\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name, &code,\n+                                  \/*frame_complete=*\/ (int)(frame_complete_pc - start),\n+                                  frame_size_in_bytes\/wordSize,\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n@@ -3650,0 +3745,78 @@\n+\n+#if INCLUDE_JFR\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  Register tmp1 = R10_ARG8;\n+  Register tmp2 = R9_ARG7;\n+\n+  int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n+  address start = __ pc();\n+  __ mflr(tmp1);\n+  __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n+  __ push_frame_reg_args(0, tmp1);\n+  int frame_complete = __ pc() - start;\n+  __ set_last_Java_frame(R1_SP, noreg);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), R16_thread);\n+  address calls_return_pc = __ last_calls_return_pc();\n+  __ reset_last_Java_frame();\n+  \/\/ The handle is dereferenced through a load barrier.\n+  __ resolve_global_jobject(R3_RET, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n+  __ pop_frame();\n+  __ ld(tmp1, _abi0(lr), R1_SP);\n+  __ mtlr(tmp1);\n+  __ blr();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 0);\n+  oop_maps->add_gc_map(calls_return_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  CodeBuffer code(\"jfr_return_lease\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  Register tmp1 = R10_ARG8;\n+  Register tmp2 = R9_ARG7;\n+\n+  int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n+  address start = __ pc();\n+  __ mflr(tmp1);\n+  __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n+  __ push_frame_reg_args(0, tmp1);\n+  int frame_complete = __ pc() - start;\n+  __ set_last_Java_frame(R1_SP, noreg);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), R16_thread);\n+  address calls_return_pc = __ last_calls_return_pc();\n+  __ reset_last_Java_frame();\n+  __ pop_frame();\n+  __ ld(tmp1, _abi0(lr), R1_SP);\n+  __ mtlr(tmp1);\n+  __ blr();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 0);\n+  oop_maps->add_gc_map(calls_return_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":173,"deletions":0,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -520,103 +520,0 @@\n-#define __ masm->\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Only callee-saved registers are preserved (through the\n-  \/\/ normal register window \/ RegisterMap handling).  If the compiler\n-  \/\/ needs all registers to be preserved between the fault point and\n-  \/\/ the exception handler then it must assume responsibility for that\n-  \/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-  \/\/\n-  \/\/ Note that we generate only this stub into a RuntimeStub, because\n-  \/\/ it needs to be properly traversed and ignored during GC, so we\n-  \/\/ change the meaning of the \"__\" macro within this method.\n-  \/\/\n-  \/\/ Note: the routine set_pc_not_at_call_for_caller in\n-  \/\/ SharedRuntime.cpp requires that this code be generated into a\n-  \/\/ RuntimeStub.\n-  address generate_throw_exception(const char* name, address runtime_entry, bool restore_saved_exception_pc,\n-                                   Register arg1 = noreg, Register arg2 = noreg) {\n-    CodeBuffer code(name, 1024 DEBUG_ONLY(+ 512), 0);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    int frame_size_in_bytes = frame::native_abi_reg_args_size;\n-    OopMap* map = new OopMap(frame_size_in_bytes \/ sizeof(jint), 0);\n-\n-    address start = __ pc();\n-\n-    __ save_LR(R11_scratch1);\n-\n-    \/\/ Push a frame.\n-    __ push_frame_reg_args(0, R11_scratch1);\n-\n-    address frame_complete_pc = __ pc();\n-\n-    if (restore_saved_exception_pc) {\n-      __ unimplemented(\"StubGenerator::throw_exception with restore_saved_exception_pc\");\n-    }\n-\n-    \/\/ Note that we always have a runtime stub frame on the top of\n-    \/\/ stack by this point. Remember the offset of the instruction\n-    \/\/ whose address will be moved to R11_scratch1.\n-    address gc_map_pc = __ get_PC_trash_LR(R11_scratch1);\n-\n-    __ set_last_Java_frame(\/*sp*\/R1_SP, \/*pc*\/R11_scratch1);\n-\n-    __ mr(R3_ARG1, R16_thread);\n-    if (arg1 != noreg) {\n-      __ mr(R4_ARG2, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mr(R5_ARG3, arg2);\n-    }\n-#if defined(ABI_ELFv2)\n-    __ call_c(runtime_entry, relocInfo::none);\n-#else\n-    __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, runtime_entry), relocInfo::none);\n-#endif\n-\n-    \/\/ Set an oopmap for the call site.\n-    oop_maps->add_gc_map((int)(gc_map_pc - start), map);\n-\n-    __ reset_last_Java_frame();\n-\n-#ifdef ASSERT\n-    \/\/ Make sure that this code is only executed if there is a pending\n-    \/\/ exception.\n-    {\n-      Label L;\n-      __ ld(R0,\n-                in_bytes(Thread::pending_exception_offset()),\n-                R16_thread);\n-      __ cmpdi(CCR0, R0, 0);\n-      __ bne(CCR0, L);\n-      __ stop(\"StubRoutines::throw_exception: no pending exception\");\n-      __ bind(L);\n-    }\n-#endif\n-\n-    \/\/ Pop frame.\n-    __ pop_frame();\n-\n-    __ restore_LR(R11_scratch1);\n-\n-    __ load_const(R11_scratch1, StubRoutines::forward_exception_entry());\n-    __ mtctr(R11_scratch1);\n-    __ bctr();\n-\n-    \/\/ Create runtime stub with OopMap.\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name, &code,\n-                                    \/*frame_complete=*\/ (int)(frame_complete_pc - start),\n-                                    frame_size_in_bytes\/wordSize,\n-                                    oop_maps,\n-                                    false);\n-    return stub->entry_point();\n-  }\n-#undef __\n@@ -4619,1 +4516,1 @@\n-    __ load_const_optimized(tmp1, (StubRoutines::throw_StackOverflowError_entry()), R0);\n+    __ load_const_optimized(tmp1, (SharedRuntime::throw_StackOverflowError_entry()), R0);\n@@ -4678,78 +4575,0 @@\n-#if INCLUDE_JFR\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  RuntimeStub* generate_jfr_write_checkpoint() {\n-    CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n-    MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-    Register tmp1 = R10_ARG8;\n-    Register tmp2 = R9_ARG7;\n-\n-    int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n-    address start = __ pc();\n-    __ mflr(tmp1);\n-    __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n-    __ push_frame_reg_args(0, tmp1);\n-    int frame_complete = __ pc() - start;\n-    __ set_last_Java_frame(R1_SP, noreg);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), R16_thread);\n-    address calls_return_pc = __ last_calls_return_pc();\n-    __ reset_last_Java_frame();\n-    \/\/ The handle is dereferenced through a load barrier.\n-    __ resolve_global_jobject(R3_RET, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n-    __ pop_frame();\n-    __ ld(tmp1, _abi0(lr), R1_SP);\n-    __ mtlr(tmp1);\n-    __ blr();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 0);\n-    oop_maps->add_gc_map(calls_return_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  RuntimeStub* generate_jfr_return_lease() {\n-    CodeBuffer code(\"jfr_return_lease\", 512, 64);\n-    MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-    Register tmp1 = R10_ARG8;\n-    Register tmp2 = R9_ARG7;\n-\n-    int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n-    address start = __ pc();\n-    __ mflr(tmp1);\n-    __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n-    __ push_frame_reg_args(0, tmp1);\n-    int frame_complete = __ pc() - start;\n-    __ set_last_Java_frame(R1_SP, noreg);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), R16_thread);\n-    address calls_return_pc = __ last_calls_return_pc();\n-    __ reset_last_Java_frame();\n-    __ pop_frame();\n-    __ ld(tmp1, _abi0(lr), R1_SP);\n-    __ mtlr(tmp1);\n-    __ blr();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 0);\n-    oop_maps->add_gc_map(calls_return_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -4789,8 +4608,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry   =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError), false);\n-    StubRoutines::_throw_delayed_StackOverflowError_entry =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError), false);\n-\n@@ -4815,10 +4626,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n-  }\n-\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -4826,1 +4627,0 @@\n-#endif \/\/ INCLUDE_JFR\n@@ -4831,7 +4631,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in\n-    \/\/ non-core builds\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError),  false);\n-    \/\/ Handle IncompatibleClassChangeError in itable stubs.\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError),  false);\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call), false);\n-\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":1,"deletions":208,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -786,2 +786,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"generated in wrong order\");\n-  __ load_const_optimized(Rscratch1, (StubRoutines::throw_StackOverflowError_entry()), R0);\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"generated in wrong order\");\n+  __ load_const_optimized(Rscratch1, (SharedRuntime::throw_StackOverflowError_entry()), R0);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-    __ cmpd(CCR0, R19_method, 0);\n+    __ cmpdi(CCR0, R19_method, 0);\n","filename":"src\/hotspot\/cpu\/ppc\/vtableStubs_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1838,0 +1838,1 @@\n+  INSN(vlseg4e8_v, 0b0000111, 0b000, 0b00000, 0b00, 0b0, g4);\n@@ -1840,0 +1841,1 @@\n+  INSN(vsseg3e8_v, 0b0100111, 0b000, 0b00000, 0b00, 0b0, g3);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    lightweight_lock(obj, hdr, temp, t1, slow_case);\n+    lightweight_lock(disp_hdr, obj, hdr, temp, t1, slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,1 +256,2 @@\n-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register tmp1, Register tmp2, Register tmp3) {\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box,\n+                                              Register tmp1, Register tmp2, Register tmp3) {\n@@ -261,1 +262,1 @@\n-  assert_different_registers(obj, tmp1, tmp2, tmp3, flag, t0);\n+  assert_different_registers(obj, box, tmp1, tmp2, tmp3, flag, t0);\n@@ -272,0 +273,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    sd(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }\n+\n@@ -280,0 +286,1 @@\n+  const Register tmp3_t = tmp3;\n@@ -287,1 +294,0 @@\n-    const Register tmp3_t = tmp3;\n@@ -326,3 +332,35 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tmp1_tagged_monitor = tmp1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register tmp1_monitor = tmp1;\n+    if (!UseObjectMonitorTable) {\n+      assert(tmp1_monitor == tmp1_mark, \"should be the same here\");\n+    } else {\n+      Label monitor_found;\n+\n+      \/\/ Load cache address\n+      la(tmp3_t, Address(xthread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        ld(tmp1, Address(tmp3_t));\n+        beq(obj, tmp1, monitor_found);\n+        add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      Label loop;\n+\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      ld(tmp1, Address(tmp3_t));\n+      beq(obj, tmp1, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      bnez(tmp1, loop);\n+      \/\/ Cache Miss. Take the slowpath.\n+      j(slow_path);\n+\n+      bind(monitor_found);\n+      ld(tmp1_monitor, Address(tmp3_t, OMCache::oop_to_monitor_difference()));\n+    }\n+\n@@ -332,0 +370,6 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address owner_address(tmp1_monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+    const Address recursions_address(tmp1_monitor, ObjectMonitor::recursions_offset() - monitor_tag);\n+\n+    Label monitor_locked;\n+\n@@ -333,1 +377,1 @@\n-    la(tmp2_owner_addr, Address(tmp1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n+    la(tmp2_owner_addr, owner_address);\n@@ -338,1 +382,1 @@\n-    beqz(tmp3_owner, locked);\n+    beqz(tmp3_owner, monitor_locked);\n@@ -344,1 +388,6 @@\n-    increment(Address(tmp1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1, tmp2, tmp3);\n+    increment(recursions_address, 1, tmp2, tmp3);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      sd(tmp1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+    }\n@@ -368,2 +417,2 @@\n-void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register tmp1, Register tmp2,\n-                                                Register tmp3) {\n+void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register box,\n+                                                Register tmp1, Register tmp2, Register tmp3) {\n@@ -374,1 +423,1 @@\n-  assert_different_registers(obj, tmp1, tmp2, tmp3, flag, t0);\n+  assert_different_registers(obj, box, tmp1, tmp2, tmp3, flag, t0);\n@@ -379,1 +428,1 @@\n-  Label inflated, inflated_load_monitor;\n+  Label inflated, inflated_load_mark;\n@@ -390,0 +439,1 @@\n+    Label push_and_slow_path;\n@@ -397,1 +447,1 @@\n-    bne(obj, tmp3_t, inflated_load_monitor);\n+    bne(obj, tmp3_t, inflated_load_mark);\n@@ -414,0 +464,3 @@\n+    \/\/ Because we got here by popping (meaning we pushed in locked)\n+    \/\/ there will be no monitor in the box. So we need to push back the obj\n+    \/\/ so that the runtime can fix any potential anonymous owner.\n@@ -415,1 +468,1 @@\n-    bnez(tmp3_t, inflated);\n+    bnez(tmp3_t, UseObjectMonitorTable ? push_and_slow_path : inflated);\n@@ -424,0 +477,1 @@\n+    bind(push_and_slow_path);\n@@ -434,1 +488,1 @@\n-    bind(inflated_load_monitor);\n+    bind(inflated_load_mark);\n@@ -456,6 +510,12 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tmp1_monitor = tmp1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-\n-    \/\/ Untag the monitor.\n-    sub(tmp1_monitor, tmp1_mark, monitor_tag);\n+    const Register tmp1_monitor = tmp1;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(tmp1_monitor == tmp1_mark, \"should be the same here\");\n+      \/\/ Untag the monitor.\n+      add(tmp1_monitor, tmp1_mark, -(int)markWord::monitor_value);\n+    } else {\n+      ld(tmp1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ No valid pointer below alignof(ObjectMonitor*). Take the slow path.\n+      mv(tmp3_t, alignof(ObjectMonitor*));\n+      bltu(tmp1_monitor, tmp3_t, slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":82,"deletions":22,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-  void fast_lock_lightweight(Register object, Register tmp1, Register tmp2, Register tmp3);\n-  void fast_unlock_lightweight(Register object, Register tmp1, Register tmp2, Register tmp3);\n+  void fast_lock_lightweight(Register object, Register box, Register tmp1, Register tmp2, Register tmp3);\n+  void fast_unlock_lightweight(Register object, Register box, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-        \/\/ If we patch code we need both a code patching and a loadload\n+        \/\/ If we patch code we need both a cmodx fence and a loadload\n@@ -276,0 +276,1 @@\n+\n@@ -277,4 +278,11 @@\n-        \/\/ Embed an artificial data dependency to order the guard load\n-        \/\/ before the epoch load.\n-        __ srli(ra, t0, 32);\n-        __ orr(t1, t1, ra);\n+        if (!UseZtso) {\n+          \/\/ Embed a synthetic data dependency between the load of the guard and\n+          \/\/ the load of the epoch. This guarantees that these loads occur in\n+          \/\/ order, while allowing other independent instructions to be reordered.\n+          \/\/ Note: This may be slower than using a membar(load|load) (fence r,r).\n+          \/\/ Because processors will not start the second load until the first comes back.\n+          \/\/ This means you cant overlap the two loads,\n+          \/\/ which is stronger than needed for ordering (stronger than TSO).\n+          __ srli(ra, t0, 32);\n+          __ orr(t1, t1, ra);\n+        }\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -759,1 +759,1 @@\n-      lightweight_lock(obj_reg, tmp, tmp2, tmp3, slow_case);\n+      lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n@@ -795,9 +795,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-              obj_reg);\n-    } else {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-              lock_reg);\n-    }\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+            lock_reg);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4147,1 +4147,1 @@\n-  la(t0, RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+  la(t0, RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n@@ -5795,1 +5795,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow) {\n@@ -5797,1 +5797,1 @@\n-  assert_different_registers(obj, tmp1, tmp2, tmp3, t0);\n+  assert_different_registers(basic_lock, obj, tmp1, tmp2, tmp3, t0);\n@@ -5808,0 +5808,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    sd(zr, Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1605,1 +1605,1 @@\n-  void lightweight_lock(Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_AbstractMethodError_entry()));\n@@ -444,1 +444,1 @@\n-      __ far_jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));\n+      __ far_jump(RuntimeAddress(SharedRuntime::throw_IncompatibleClassChangeError_entry()));\n","filename":"src\/hotspot\/cpu\/riscv\/methodHandles_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -10556,1 +10556,1 @@\n-instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP_R10 box, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -10560,1 +10560,1 @@\n-  effect(TEMP tmp1, TEMP tmp2, USE_KILL box);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n@@ -10563,1 +10563,1 @@\n-  format %{ \"fastlock $object,$box\\t! kills $box,$tmp1,$tmp2 #@cmpFastLockLightweight\" %}\n+  format %{ \"fastlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3 #@cmpFastLockLightweight\" %}\n@@ -10566,1 +10566,1 @@\n-    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -10572,1 +10572,1 @@\n-instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP_R10 box, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -10576,1 +10576,1 @@\n-  effect(TEMP tmp1, TEMP tmp2, USE_KILL box);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n@@ -10579,1 +10579,1 @@\n-  format %{ \"fastunlock $object,$box\\t! kills $box,$tmp1,$tmp2, #@cmpFastUnlockLightweight\" %}\n+  format %{ \"fastunlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3 #@cmpFastUnlockLightweight\" %}\n@@ -10582,1 +10582,1 @@\n-    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -68,0 +69,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif\n+\n@@ -1698,1 +1705,1 @@\n-      __ lightweight_lock(obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n+      __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -2631,0 +2638,188 @@\n+\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Since we need to preserve callee-saved values (currently\n+\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+\/\/ map and therefore have to make these stubs into RuntimeStubs\n+\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+\/\/ be preserved between the fault point and the exception handler\n+\/\/ then it must assume responsibility for that in\n+\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  \/\/ n.b. riscv asserts that frame::arg_reg_save_area_bytes == 0\n+  assert_cond(runtime_entry != nullptr);\n+  enum layout {\n+    fp_off = 0,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  const int insts_size = 1024;\n+  const int locs_size  = 64;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  assert_cond(oop_maps != nullptr && masm != nullptr);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+\n+  __ enter(); \/\/ Save FP and RA before call\n+\n+  assert(is_even(framesize \/ 2), \"sp not 16-byte aligned\");\n+\n+  \/\/ ra and fp are already in place\n+  __ addi(sp, fp, 0 - ((unsigned)framesize << LogBytesPerInt)); \/\/ prolog\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, fp, the_pc, t0);\n+\n+  \/\/ Call runtime\n+  __ mv(c_rarg0, xthread);\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ rt_call(runtime_entry);\n+\n+  \/\/ Generate oop map\n+  OopMap* map = new OopMap(framesize, 0);\n+  assert_cond(map != nullptr);\n+\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave();\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n+  __ bnez(t0, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/\/ ASSERT\n+  __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  assert(stub != nullptr, \"create runtime stub fail!\");\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+static void jfr_prologue(address the_pc, MacroAssembler* masm, Register thread) {\n+  __ set_last_Java_frame(sp, fp, the_pc, t0);\n+  __ mv(c_rarg0, thread);\n+}\n+\n+static void jfr_epilogue(MacroAssembler* masm) {\n+  __ reset_last_Java_frame(true);\n+}\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    fp_off,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, xthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+\n+  jfr_epilogue(masm);\n+  __ resolve_global_jobject(x10, t0, t1);\n+  __ leave();\n+  __ ret();\n+\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    fp_off,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, xthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+\n+  jfr_epilogue(masm);\n+  __ leave();\n+  __ ret();\n+\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":196,"deletions":1,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -3777,1 +3777,1 @@\n-    __ la(t0, RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+    __ la(t0, RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -5325,0 +5325,273 @@\n+  \/**\n+   * vector registers:\n+   * input VectorRegister's:  intputV1-V4, for m2 they could be v2, v4, v6, for m1 they could be v2, v4, v6, v8\n+   * index VectorRegister's:  idxV1-V3, for m2 they could be v8, v10, v12, v14, for m1 they could be v10, v12, v14, v16\n+   * output VectorRegister's: outputV1-V4, for m2 they could be v16, v18, v20, v22, for m1 they could be v18, v20, v22\n+   *\n+   * NOTE: each field will occupy a single vector register group\n+   *\/\n+  void base64_vector_decode_round(Register src, Register dst, Register codec,\n+                    Register size, Register stepSrc, Register stepDst, Register failedIdx, Register minusOne,\n+                    VectorRegister inputV1, VectorRegister inputV2, VectorRegister inputV3, VectorRegister inputV4,\n+                    VectorRegister idxV1, VectorRegister idxV2, VectorRegister idxV3, VectorRegister idxV4,\n+                    VectorRegister outputV1, VectorRegister outputV2, VectorRegister outputV3,\n+                    Assembler::LMUL lmul) {\n+    \/\/ set vector register type\/len\n+    __ vsetvli(x0, size, Assembler::e8, lmul, Assembler::ma, Assembler::ta);\n+\n+    \/\/ segmented load src into v registers: mem(src) => vr(4)\n+    __ vlseg4e8_v(inputV1, src);\n+\n+    \/\/ src = src + register_group_len_bytes * 4\n+    __ add(src, src, stepSrc);\n+\n+    \/\/ decoding\n+    \/\/   1. indexed load: vr(4) => vr(4)\n+    __ vluxei8_v(idxV1, codec, inputV1);\n+    __ vluxei8_v(idxV2, codec, inputV2);\n+    __ vluxei8_v(idxV3, codec, inputV3);\n+    __ vluxei8_v(idxV4, codec, inputV4);\n+\n+    \/\/   2. check wrong data\n+    __ vor_vv(outputV1, idxV1, idxV2);\n+    __ vor_vv(outputV2, idxV3, idxV4);\n+    __ vor_vv(outputV1, outputV1, outputV2);\n+    __ vmseq_vi(v0, outputV1, -1);\n+    __ vfirst_m(failedIdx, v0);\n+    Label NoFailure;\n+    __ beq(failedIdx, minusOne, NoFailure);\n+    __ vsetvli(x0, failedIdx, Assembler::e8, lmul, Assembler::mu, Assembler::tu);\n+    __ slli(stepDst, failedIdx, 1);\n+    __ add(stepDst, failedIdx, stepDst);\n+    __ BIND(NoFailure);\n+\n+    \/\/   3. compute the decoded data: vr(4) => vr(3)\n+    __ vsll_vi(idxV1, idxV1, 2);\n+    __ vsrl_vi(outputV1, idxV2, 4);\n+    __ vor_vv(outputV1, outputV1, idxV1);\n+\n+    __ vsll_vi(idxV2, idxV2, 4);\n+    __ vsrl_vi(outputV2, idxV3, 2);\n+    __ vor_vv(outputV2, outputV2, idxV2);\n+\n+    __ vsll_vi(idxV3, idxV3, 6);\n+    __ vor_vv(outputV3, idxV4, idxV3);\n+\n+    \/\/ segmented store encoded data in v registers back to dst: vr(3) => mem(dst)\n+    __ vsseg3e8_v(outputV1, dst);\n+\n+    \/\/ dst = dst + register_group_len_bytes * 3\n+    __ add(dst, dst, stepDst);\n+  }\n+\n+  \/**\n+   * int j.u.Base64.Decoder.decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL, boolean isMIME)\n+   *\n+   *  Input arguments:\n+   *  c_rarg0   - src, source array\n+   *  c_rarg1   - sp, src start offset\n+   *  c_rarg2   - sl, src end offset\n+   *  c_rarg3   - dst, dest array\n+   *  c_rarg4   - dp, dst start offset\n+   *  c_rarg5   - isURL, Base64 or URL character set\n+   *  c_rarg6   - isMIME, Decoding MIME block\n+   *\/\n+  address generate_base64_decodeBlock() {\n+\n+    static const uint8_t fromBase64[256] = {\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u, 255u,  63u,\n+        52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+        15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u, 255u,\n+        255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+        41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    static const uint8_t fromBase64URL[256] = {\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u,\n+        52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+        15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,  63u,\n+        255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+        41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"decodeBlock\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    Register src    = c_rarg0;\n+    Register soff   = c_rarg1;\n+    Register send   = c_rarg2;\n+    Register dst    = c_rarg3;\n+    Register doff   = c_rarg4;\n+    Register isURL  = c_rarg5;\n+    Register isMIME = c_rarg6;\n+\n+    Register codec     = c_rarg7;\n+    Register dstBackup = x31;\n+    Register length    = x28;     \/\/ t3, total length of src data in bytes\n+\n+    Label ProcessData, Exit;\n+    Label ProcessScalar, ScalarLoop;\n+\n+    \/\/ passed in length (send - soff) is guaranteed to be > 4,\n+    \/\/ and in this intrinsic we only process data of length in multiple of 4,\n+    \/\/ it's not guaranteed to be multiple of 4 by java level, so do it explicitly\n+    __ sub(length, send, soff);\n+    __ andi(length, length, -4);\n+    \/\/ real src\/dst to process data\n+    __ add(src, src, soff);\n+    __ add(dst, dst, doff);\n+    \/\/ backup of dst, used to calculate the return value at exit\n+    __ mv(dstBackup, dst);\n+\n+    \/\/ load the codec base address\n+    __ la(codec, ExternalAddress((address) fromBase64));\n+    __ beqz(isURL, ProcessData);\n+    __ la(codec, ExternalAddress((address) fromBase64URL));\n+    __ BIND(ProcessData);\n+\n+    \/\/ vector version\n+    if (UseRVV) {\n+      \/\/ for MIME case, it has a default length limit of 76 which could be\n+      \/\/ different(smaller) from (send - soff), so in MIME case, we go through\n+      \/\/ the scalar code path directly.\n+      __ bnez(isMIME, ScalarLoop);\n+\n+      Label ProcessM1, ProcessM2;\n+\n+      Register failedIdx = soff;\n+      Register stepSrcM1 = send;\n+      Register stepSrcM2 = doff;\n+      Register stepDst   = isURL;\n+      Register size      = x29;   \/\/ t4\n+      Register minusOne  = x30;   \/\/ t5\n+\n+      __ mv(minusOne, -1);\n+      __ mv(size, MaxVectorSize * 2);\n+      __ mv(stepSrcM1, MaxVectorSize * 4);\n+      __ slli(stepSrcM2, stepSrcM1, 1);\n+      __ mv(stepDst, MaxVectorSize * 2 * 3);\n+\n+      __ blt(length, stepSrcM2, ProcessM1);\n+\n+\n+      \/\/ Assembler::m2\n+      __ BIND(ProcessM2);\n+      base64_vector_decode_round(src, dst, codec,\n+                    size, stepSrcM2, stepDst, failedIdx, minusOne,\n+                    v2, v4, v6, v8,      \/\/ inputs\n+                    v10, v12, v14, v16,  \/\/ indexes\n+                    v18, v20, v22,       \/\/ outputs\n+                    Assembler::m2);\n+      __ sub(length, length, stepSrcM2);\n+\n+      \/\/ error check\n+      __ bne(failedIdx, minusOne, Exit);\n+\n+      __ bge(length, stepSrcM2, ProcessM2);\n+\n+\n+      \/\/ Assembler::m1\n+      __ BIND(ProcessM1);\n+      __ blt(length, stepSrcM1, ProcessScalar);\n+\n+      __ srli(size, size, 1);\n+      __ srli(stepDst, stepDst, 1);\n+      base64_vector_decode_round(src, dst, codec,\n+                    size, stepSrcM1, stepDst, failedIdx, minusOne,\n+                    v1, v2, v3, v4,      \/\/ inputs\n+                    v5, v6, v7, v8,      \/\/ indexes\n+                    v9, v10, v11,        \/\/ outputs\n+                    Assembler::m1);\n+      __ sub(length, length, stepSrcM1);\n+\n+      \/\/ error check\n+      __ bne(failedIdx, minusOne, Exit);\n+\n+      __ BIND(ProcessScalar);\n+      __ beqz(length, Exit);\n+    }\n+\n+    \/\/ scalar version\n+    {\n+      Register byte0 = soff, byte1 = send, byte2 = doff, byte3 = isURL;\n+      Register combined32Bits = x29; \/\/ t5\n+\n+      \/\/ encoded:   [byte0[5:0] : byte1[5:0] : byte2[5:0]] : byte3[5:0]] =>\n+      \/\/ plain:     [byte0[5:0]+byte1[5:4] : byte1[3:0]+byte2[5:2] : byte2[1:0]+byte3[5:0]]\n+      __ BIND(ScalarLoop);\n+\n+      \/\/ load 4 bytes encoded src data\n+      __ lbu(byte0, Address(src, 0));\n+      __ lbu(byte1, Address(src, 1));\n+      __ lbu(byte2, Address(src, 2));\n+      __ lbu(byte3, Address(src, 3));\n+      __ addi(src, src, 4);\n+\n+      \/\/ get codec index and decode (ie. load from codec by index)\n+      __ add(byte0, codec, byte0);\n+      __ add(byte1, codec, byte1);\n+      __ lb(byte0, Address(byte0, 0));\n+      __ lb(byte1, Address(byte1, 0));\n+      __ add(byte2, codec, byte2);\n+      __ add(byte3, codec, byte3);\n+      __ lb(byte2, Address(byte2, 0));\n+      __ lb(byte3, Address(byte3, 0));\n+      __ slliw(byte0, byte0, 18);\n+      __ slliw(byte1, byte1, 12);\n+      __ orr(byte0, byte0, byte1);\n+      __ orr(byte0, byte0, byte3);\n+      __ slliw(byte2, byte2, 6);\n+      \/\/ For performance consideration, `combined32Bits` is constructed for 2 purposes at the same time,\n+      \/\/  1. error check below\n+      \/\/  2. decode below\n+      __ orr(combined32Bits, byte0, byte2);\n+\n+      \/\/ error check\n+      __ bltz(combined32Bits, Exit);\n+\n+      \/\/ store 3 bytes decoded data\n+      __ sraiw(byte0, combined32Bits, 16);\n+      __ sraiw(byte1, combined32Bits, 8);\n+      __ sb(byte0, Address(dst, 0));\n+      __ sb(byte1, Address(dst, 1));\n+      __ sb(combined32Bits, Address(dst, 2));\n+\n+      __ sub(length, length, 4);\n+      __ addi(dst, dst, 3);\n+      \/\/ loop back\n+      __ bnez(length, ScalarLoop);\n+    }\n+\n+    __ BIND(Exit);\n+    __ sub(c_rarg0, dst, dstBackup);\n+\n+    __ leave();\n+    __ ret();\n+\n+    return (address) start;\n+  }\n+\n@@ -5837,91 +6110,0 @@\n-#if INCLUDE_JFR\n-\n-  static void jfr_prologue(address the_pc, MacroAssembler* _masm, Register thread) {\n-    __ set_last_Java_frame(sp, fp, the_pc, t0);\n-    __ mv(c_rarg0, thread);\n-  }\n-\n-  static void jfr_epilogue(MacroAssembler* _masm) {\n-    __ reset_last_Java_frame(true);\n-  }\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      fp_off,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, xthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-\n-    jfr_epilogue(_masm);\n-    __ resolve_global_jobject(x10, t0, t1);\n-    __ leave();\n-    __ ret();\n-\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      fp_off,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, xthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-\n-    jfr_epilogue(_masm);\n-    __ leave();\n-    __ ret();\n-\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -5942,108 +6124,0 @@\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Since we need to preserve callee-saved values (currently\n-  \/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-  \/\/ map and therefore have to make these stubs into RuntimeStubs\n-  \/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-  \/\/ be preserved between the fault point and the exception handler\n-  \/\/ then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n-#undef __\n-#define __ masm->\n-\n-  address generate_throw_exception(const char* name,\n-                                   address runtime_entry,\n-                                   Register arg1 = noreg,\n-                                   Register arg2 = noreg) {\n-    \/\/ Information about frame layout at time of blocking runtime call.\n-    \/\/ Note that we only have to preserve callee-saved registers since\n-    \/\/ the compilers are responsible for supplying a continuation point\n-    \/\/ if they expect all registers to be preserved.\n-    \/\/ n.b. riscv asserts that frame::arg_reg_save_area_bytes == 0\n-    assert_cond(runtime_entry != nullptr);\n-    enum layout {\n-      fp_off = 0,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    const int insts_size = 1024;\n-    const int locs_size  = 64;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    assert_cond(oop_maps != nullptr && masm != nullptr);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-\n-    __ enter(); \/\/ Save FP and RA before call\n-\n-    assert(is_even(framesize \/ 2), \"sp not 16-byte aligned\");\n-\n-    \/\/ ra and fp are already in place\n-    __ addi(sp, fp, 0 - ((unsigned)framesize << LogBytesPerInt)); \/\/ prolog\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    address the_pc = __ pc();\n-    __ set_last_Java_frame(sp, fp, the_pc, t0);\n-\n-    \/\/ Call runtime\n-    if (arg1 != noreg) {\n-      assert(arg2 != c_rarg1, \"clobbered\");\n-      __ mv(c_rarg1, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mv(c_rarg2, arg2);\n-    }\n-    __ mv(c_rarg0, xthread);\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ rt_call(runtime_entry);\n-\n-    \/\/ Generate oop map\n-    OopMap* map = new OopMap(framesize, 0);\n-    assert_cond(map != nullptr);\n-\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    __ reset_last_Java_frame(true);\n-\n-    __ leave();\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n-    __ bnez(t0, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/\/ ASSERT\n-    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-    \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name,\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    assert(stub != nullptr, \"create runtime stub fail!\");\n-    return stub->entry_point();\n-  }\n-\n@@ -6074,10 +6148,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_StackOverflowError));\n-    StubRoutines::_throw_delayed_StackOverflowError_entry =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_delayed_StackOverflowError));\n-\n@@ -6096,10 +6160,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n-  }\n-\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -6107,1 +6161,0 @@\n-#endif \/\/ INCLUDE_JFR\n@@ -6115,17 +6168,0 @@\n-    StubRoutines::_throw_AbstractMethodError_entry =\n-      generate_throw_exception(\"AbstractMethodError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_AbstractMethodError));\n-\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry =\n-      generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_IncompatibleClassChangeError));\n-\n-    StubRoutines::_throw_NullPointerException_at_call_entry =\n-      generate_throw_exception(\"NullPointerException at call throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_NullPointerException_at_call));\n@@ -6220,0 +6256,1 @@\n+      StubRoutines::_base64_decodeBlock = generate_base64_decodeBlock();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":275,"deletions":238,"binary":false,"changes":513,"status":"modified"},{"patch":"@@ -661,2 +661,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1075,10 +1075,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    \/\/ for lightweight locking we need to use monitorenter_obj, see interpreterRuntime.cpp\n-    call_VM(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-            object);\n-  } else {\n-    call_VM(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            monitor);\n-  }\n+  call_VM(noreg,\n+          CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+          monitor);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2754,1 +2754,1 @@\n-  load_const_optimized(Z_R1, StubRoutines::throw_delayed_StackOverflowError_entry());\n+  load_const_optimized(Z_R1, SharedRuntime::throw_delayed_StackOverflowError_entry());\n@@ -3323,2 +3323,2 @@\n-  z_cghi(r_bitmap, Klass::SECONDARY_SUPERS_BITMAP_FULL);\n-  z_bre(L_huge);\n+  z_chi(r_array_length, Klass::SECONDARY_SUPERS_BITMAP_FULL - 2);\n+  z_brh(L_huge);\n@@ -6221,20 +6221,27 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tagged_monitor = mark;\n-    const Register zero           = tmp2;\n-\n-    \/\/ Try to CAS m->owner from null to current thread.\n-    \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n-    \/\/ Otherwise, register zero is filled with the current owner.\n-    z_lghi(zero, 0);\n-    z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), tagged_monitor);\n-    z_bre(locked);\n-\n-    \/\/ Check if recursive.\n-    z_cgr(Z_thread, zero); \/\/ zero contains the owner from z_csg instruction\n-    z_brne(slow_path);\n-\n-    \/\/ Recursive\n-    z_agsi(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n-    z_cgr(zero, zero);\n-    \/\/ z_bru(locked);\n-    \/\/ Uncomment above line in the future, for now jump address is right next to us.\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register tagged_monitor = mark;\n+      const Register zero           = tmp2;\n+\n+      \/\/ Try to CAS m->owner from null to current thread.\n+      \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n+      \/\/ Otherwise, register zero is filled with the current owner.\n+      z_lghi(zero, 0);\n+      z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), tagged_monitor);\n+      z_bre(locked);\n+\n+      \/\/ Check if recursive.\n+      z_cgr(Z_thread, zero); \/\/ zero contains the owner from z_csg instruction\n+      z_brne(slow_path);\n+\n+      \/\/ Recursive\n+      z_agsi(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n+      z_cgr(zero, zero);\n+      \/\/ z_bru(locked);\n+      \/\/ Uncomment above line in the future, for now jump address is right next to us.\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      z_ltgr(obj, obj);\n+      z_bru(slow_path);\n+    }\n@@ -6282,0 +6289,1 @@\n+    NearLabel push_and_slow_path;\n@@ -6311,1 +6319,5 @@\n-    z_brnaz(inflated);\n+    if (!UseObjectMonitorTable) {\n+      z_brnaz(inflated);\n+    } else {\n+      z_brnaz(push_and_slow_path);\n+    }\n@@ -6330,0 +6342,1 @@\n+    bind(push_and_slow_path);\n@@ -6367,2 +6380,3 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register monitor = mark;\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register monitor = mark;\n@@ -6370,2 +6384,2 @@\n-    NearLabel not_recursive;\n-    const Register recursions = tmp2;\n+      NearLabel not_recursive;\n+      const Register recursions = tmp2;\n@@ -6373,3 +6387,3 @@\n-    \/\/ Check if recursive.\n-    load_and_test_long(recursions, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-    z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+      \/\/ Check if recursive.\n+      load_and_test_long(recursions, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+      z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n@@ -6377,4 +6391,4 @@\n-    \/\/ Recursive unlock\n-    z_agsi(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n-    z_cgr(monitor, monitor); \/\/ set the CC to EQUAL\n-    z_bru(unlocked);\n+      \/\/ Recursive unlock\n+      z_agsi(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n+      z_cgr(monitor, monitor); \/\/ set the CC to EQUAL\n+      z_bru(unlocked);\n@@ -6382,1 +6396,1 @@\n-    bind(not_recursive);\n+      bind(not_recursive);\n@@ -6384,6 +6398,6 @@\n-    NearLabel not_ok;\n-    \/\/ Check if the entry lists are empty.\n-    load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-    z_brne(not_ok);\n-    load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-    z_brne(not_ok);\n+      NearLabel not_ok;\n+      \/\/ Check if the entry lists are empty.\n+      load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+      z_brne(not_ok);\n+      load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n+      z_brne(not_ok);\n@@ -6391,2 +6405,2 @@\n-    z_release();\n-    z_stg(tmp2 \/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+      z_release();\n+      z_stg(tmp2 \/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n@@ -6394,1 +6408,1 @@\n-    z_bru(unlocked); \/\/ CC = EQ here\n+      z_bru(unlocked); \/\/ CC = EQ here\n@@ -6396,1 +6410,1 @@\n-    bind(not_ok);\n+      bind(not_ok);\n@@ -6398,5 +6412,11 @@\n-    \/\/ The owner may be anonymous, and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    z_stg(Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n-    z_bru(slow_path); \/\/ CC = NE here\n+      \/\/ The owner may be anonymous, and we removed the last obj entry in\n+      \/\/ the lock-stack. This loses the information about the owner.\n+      \/\/ Write the thread to the owner field so the runtime knows the owner.\n+      z_stg(Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+      z_bru(slow_path); \/\/ CC = NE here\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      z_ltgr(obj, obj);\n+      z_bru(slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":71,"deletions":51,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -183,2 +183,2 @@\n-  assert(StubRoutines::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n-  __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());\n+  assert(SharedRuntime::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n+  __ load_const_optimized(target, SharedRuntime::throw_AbstractMethodError_entry());\n@@ -546,1 +546,1 @@\n-      __ load_const_optimized(Z_R1, StubRoutines::throw_IncompatibleClassChangeError_entry());\n+      __ load_const_optimized(Z_R1, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n","filename":"src\/hotspot\/cpu\/s390\/methodHandles_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3013,0 +3013,79 @@\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Only callee-saved registers are preserved (through the\n+\/\/ normal RegisterMap handling). If the compiler\n+\/\/ needs all registers to be preserved between the fault point and\n+\/\/ the exception handler then it must assume responsibility for that\n+\/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\n+\/\/ Note that we generate only this stub into a RuntimeStub, because\n+\/\/ it needs to be properly traversed and ignored during GC, so we\n+\/\/ change the meaning of the \"__\" macro within this method.\n+\n+\/\/ Note: the routine set_pc_not_at_call_for_caller in\n+\/\/ SharedRuntime.cpp requires that this code be generated into a\n+\/\/ RuntimeStub.\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+\n+  int insts_size = 256;\n+  int locs_size  = 0;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer      code(name, insts_size, locs_size);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  int framesize_in_bytes;\n+  address start = __ pc();\n+\n+  __ save_return_pc();\n+  framesize_in_bytes = __ push_frame_abi160(0);\n+\n+  address frame_complete_pc = __ pc();\n+\n+  \/\/ Note that we always have a runtime stub frame on the top of stack at this point.\n+  __ get_PC(Z_R1);\n+  __ set_last_Java_frame(\/*sp*\/Z_SP, \/*pc*\/Z_R1);\n+\n+  \/\/ Do the call.\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ call_VM_leaf(runtime_entry, Z_thread);\n+\n+  __ reset_last_Java_frame();\n+\n+#ifdef ASSERT\n+  \/\/ Make sure that this code is only executed if there is a pending exception.\n+  { Label L;\n+    __ z_lg(Z_R0,\n+            in_bytes(Thread::pending_exception_offset()),\n+            Z_thread);\n+    __ z_ltgr(Z_R0, Z_R0);\n+    __ z_brne(L);\n+    __ stop(\"SharedRuntime::throw_exception: no pending exception\");\n+    __ bind(L);\n+  }\n+#endif\n+\n+  __ pop_frame();\n+  __ restore_return_pc();\n+\n+  __ load_const_optimized(Z_R1, StubRoutines::forward_exception_entry());\n+  __ z_br(Z_R1);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name, &code,\n+                                  frame_complete_pc - start,\n+                                  framesize_in_bytes\/wordSize,\n+                                  nullptr \/*oop_maps*\/, false);\n+\n+  return stub;\n+}\n+\n@@ -3266,0 +3345,15 @@\n+\n+#if INCLUDE_JFR\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  if (!Continuations::enabled()) return nullptr;\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  if (!Continuations::enabled()) return nullptr;\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -575,83 +575,0 @@\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Only callee-saved registers are preserved (through the\n-  \/\/ normal RegisterMap handling). If the compiler\n-  \/\/ needs all registers to be preserved between the fault point and\n-  \/\/ the exception handler then it must assume responsibility for that\n-  \/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n-  \/\/ Note that we generate only this stub into a RuntimeStub, because\n-  \/\/ it needs to be properly traversed and ignored during GC, so we\n-  \/\/ change the meaning of the \"__\" macro within this method.\n-\n-  \/\/ Note: the routine set_pc_not_at_call_for_caller in\n-  \/\/ SharedRuntime.cpp requires that this code be generated into a\n-  \/\/ RuntimeStub.\n-#undef __\n-#define __ masm->\n-\n-  address generate_throw_exception(const char* name, address runtime_entry,\n-                                   bool restore_saved_exception_pc,\n-                                   Register arg1 = noreg, Register arg2 = noreg) {\n-    assert_different_registers(arg1, Z_R0_scratch);  \/\/ would be destroyed by push_frame()\n-    assert_different_registers(arg2, Z_R0_scratch);  \/\/ would be destroyed by push_frame()\n-\n-    int insts_size = 256;\n-    int locs_size  = 0;\n-    CodeBuffer      code(name, insts_size, locs_size);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    int framesize_in_bytes;\n-    address start = __ pc();\n-\n-    __ save_return_pc();\n-    framesize_in_bytes = __ push_frame_abi160(0);\n-\n-    address frame_complete_pc = __ pc();\n-    if (restore_saved_exception_pc) {\n-      __ unimplemented(\"StubGenerator::throw_exception\", 74);\n-    }\n-\n-    \/\/ Note that we always have a runtime stub frame on the top of stack at this point.\n-    __ get_PC(Z_R1);\n-    __ set_last_Java_frame(\/*sp*\/Z_SP, \/*pc*\/Z_R1);\n-\n-    \/\/ Do the call.\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ call_VM_leaf(runtime_entry, Z_thread, arg1, arg2);\n-\n-    __ reset_last_Java_frame();\n-\n-#ifdef ASSERT\n-    \/\/ Make sure that this code is only executed if there is a pending exception.\n-    { Label L;\n-      __ z_lg(Z_R0,\n-                in_bytes(Thread::pending_exception_offset()),\n-                Z_thread);\n-      __ z_ltgr(Z_R0, Z_R0);\n-      __ z_brne(L);\n-      __ stop(\"StubRoutines::throw_exception: no pending exception\");\n-      __ bind(L);\n-    }\n-#endif\n-\n-    __ pop_frame();\n-    __ restore_return_pc();\n-\n-    __ load_const_optimized(Z_R1, StubRoutines::forward_exception_entry());\n-    __ z_br(Z_R1);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name, &code,\n-                                    frame_complete_pc - start,\n-                                    framesize_in_bytes\/wordSize,\n-                                    nullptr \/*oop_maps*\/, false);\n-\n-    return stub->entry_point();\n-  }\n-\n@@ -3124,15 +3041,0 @@\n-  #if INCLUDE_JFR\n-  RuntimeStub* generate_jfr_write_checkpoint() {\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n-  }\n-\n-  RuntimeStub* generate_jfr_return_lease() {\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n-  }\n-\n-  #endif \/\/ INCLUDE_JFR\n-\n@@ -3167,8 +3069,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry          =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError), false);\n-    StubRoutines::_throw_delayed_StackOverflowError_entry  =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError), false);\n-\n@@ -3199,2 +3093,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n@@ -3203,9 +3095,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-  }\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -3217,5 +3100,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in non-core builds.\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError),  false);\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError),  false);\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call), false);\n-\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":0,"deletions":122,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -853,3 +853,3 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  AddressLiteral stub(StubRoutines::throw_StackOverflowError_entry());\n-  __ load_absolute_address(tmp1, StubRoutines::throw_StackOverflowError_entry());\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  AddressLiteral stub(SharedRuntime::throw_StackOverflowError_entry());\n+  __ load_absolute_address(tmp1, SharedRuntime::throw_StackOverflowError_entry());\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+    lightweight_lock(disp_hdr, obj, hdr, thread, tmp, slow_case);\n@@ -70,2 +71,4 @@\n-    const Register thread = disp_hdr;\n-    get_thread(thread);\n+    \/\/ Implicit null check.\n+    movptr(hdr, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+    jmp(slow_case);\n@@ -73,1 +76,0 @@\n-    lightweight_lock(obj, hdr, thread, tmp, slow_case);\n@@ -142,4 +144,2 @@\n-    \/\/ This relies on the implementation of lightweight_unlock being able to handle\n-    \/\/ that the reg_rax and thread Register parameters may alias each other.\n-    get_thread(disp_hdr);\n-    lightweight_unlock(obj, disp_hdr, disp_hdr, hdr, slow_case);\n+    \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+    jmp(slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+    __ bind(_slow_path);\n@@ -115,0 +116,4 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address succ_address(monitor, ObjectMonitor::succ_offset() - monitor_tag);\n+    const Address owner_address(monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+\n@@ -116,1 +121,1 @@\n-    __ cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n+    __ cmpptr(succ_address, NULL_WORD);\n@@ -120,1 +125,1 @@\n-    __ movptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n+    __ movptr(owner_address, NULL_WORD);\n@@ -127,1 +132,1 @@\n-    __ cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n+    __ cmpptr(succ_address, NULL_WORD);\n@@ -136,1 +141,1 @@\n-    __ lock(); __ cmpxchgptr(_thread, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+    __ lock(); __ cmpxchgptr(_thread, owner_address);\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -593,0 +593,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    movptr(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), 0);\n+  }\n+\n@@ -606,1 +611,1 @@\n-    const Register top = box;\n+    const Register top = UseObjectMonitorTable ? rax_reg : box;\n@@ -633,0 +638,4 @@\n+    if (UseObjectMonitorTable) {\n+      \/\/ Need to reload top, clobbered by CAS.\n+      movl(top, Address(thread, JavaThread::lock_stack_top_offset()));\n+    }\n@@ -643,1 +652,44 @@\n-    const Register tagged_monitor = mark;\n+    const Register monitor = t;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(mark == monitor, \"should be the same here\");\n+    } else {\n+      \/\/ Uses ObjectMonitorTable.  Look for the monitor in the om_cache.\n+      \/\/ Fetch ObjectMonitor* from the cache or take the slow-path.\n+      Label monitor_found;\n+\n+      \/\/ Load cache address\n+      lea(t, Address(thread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        cmpptr(obj, Address(t));\n+        jccb(Assembler::equal, monitor_found);\n+        increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      Label loop;\n+\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      cmpptr(obj, Address(t));\n+      jccb(Assembler::equal, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      cmpptr(Address(t), 1);\n+      jcc(Assembler::below, slow_path); \/\/ 0 check, but with ZF=0 when *t == 0\n+      increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+      jmpb(loop);\n+\n+      \/\/ Cache hit.\n+      bind(monitor_found);\n+      movptr(monitor, Address(t, OMCache::oop_to_monitor_difference()));\n+    }\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address recursions_address(monitor, ObjectMonitor::recursions_offset() - monitor_tag);\n+    const Address owner_address(monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+\n+    Label monitor_locked;\n+    \/\/ Lock the monitor.\n@@ -647,2 +699,2 @@\n-    lock(); cmpxchgptr(thread, Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-    jccb(Assembler::equal, locked);\n+    lock(); cmpxchgptr(thread, owner_address);\n+    jccb(Assembler::equal, monitor_locked);\n@@ -655,1 +707,7 @@\n-    increment(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+    increment(recursions_address);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      \/\/ Cache the monitor for unlock\n+      movptr(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), monitor);\n+    }\n@@ -697,1 +755,3 @@\n-  const Register top = reg_rax;\n+  const Register monitor = t;\n+  const Register top = UseObjectMonitorTable ? t : reg_rax;\n+  const Register box = reg_rax;\n@@ -709,0 +769,1 @@\n+  Label& slow_path = stub == nullptr ? dummy : stub->slow_path();\n@@ -715,2 +776,4 @@\n-    \/\/ Prefetch mark.\n-    movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    if (!UseObjectMonitorTable) {\n+      \/\/ Prefetch mark.\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n@@ -733,0 +796,5 @@\n+    if (UseObjectMonitorTable) {\n+      \/\/ Load mark.\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n+\n@@ -754,0 +822,3 @@\n+    if (UseObjectMonitorTable) {\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n@@ -761,13 +832,14 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register monitor = mark;\n-\n-#ifndef _LP64\n-    \/\/ Check if recursive.\n-    xorptr(reg_rax, reg_rax);\n-    orptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-    jcc(Assembler::notZero, check_successor);\n-\n-    \/\/ Check if the entry lists are empty.\n-    movptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-    orptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-    jcc(Assembler::notZero, check_successor);\n+    if (!UseObjectMonitorTable) {\n+      assert(mark == monitor, \"should be the same here\");\n+    } else {\n+      \/\/ Uses ObjectMonitorTable.  Look for the monitor in our BasicLock on the stack.\n+      movptr(monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ null check with ZF == 0, no valid pointer below alignof(ObjectMonitor*)\n+      cmpptr(monitor, alignof(ObjectMonitor*));\n+      jcc(Assembler::below, slow_path);\n+    }\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address recursions_address{monitor, ObjectMonitor::recursions_offset() - monitor_tag};\n+    const Address cxq_address{monitor, ObjectMonitor::cxq_offset() - monitor_tag};\n+    const Address EntryList_address{monitor, ObjectMonitor::EntryList_offset() - monitor_tag};\n+    const Address owner_address{monitor, ObjectMonitor::owner_offset() - monitor_tag};\n@@ -775,3 +847,0 @@\n-    \/\/ Release lock.\n-    movptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n-#else \/\/ _LP64\n@@ -781,1 +850,1 @@\n-    cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 0);\n+    cmpptr(recursions_address, 0);\n@@ -785,2 +854,2 @@\n-    movptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-    orptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+    movptr(reg_rax, cxq_address);\n+    orptr(reg_rax, EntryList_address);\n@@ -790,1 +859,1 @@\n-    movptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n+    movptr(owner_address, NULL_WORD);\n@@ -795,1 +864,1 @@\n-    decrement(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+    decrement(recursions_address);\n@@ -797,1 +866,0 @@\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":98,"deletions":30,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -1186,0 +1186,1 @@\n+      lightweight_lock(lock_reg, obj_reg, swap_reg, thread, tmp_reg, slow_case);\n@@ -1187,2 +1188,2 @@\n-      const Register thread = lock_reg;\n-      get_thread(thread);\n+      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+      jmp(slow_case);\n@@ -1190,1 +1191,0 @@\n-      lightweight_lock(obj_reg, swap_reg, thread, tmp_reg, slow_case);\n@@ -1252,9 +1252,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-              obj_reg);\n-    } else {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-              lock_reg);\n-    }\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+            lock_reg);\n@@ -1309,4 +1303,2 @@\n-      \/\/ This relies on the implementation of lightweight_unlock being able to handle\n-      \/\/ that the reg_rax and thread Register parameters may alias each other.\n-      get_thread(swap_reg);\n-      lightweight_unlock(obj_reg, swap_reg, swap_reg, header_reg, slow_case);\n+      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+      jmp(slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1306,1 +1306,1 @@\n-  jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+  jump(RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n@@ -10278,1 +10278,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register reg_rax, Register thread, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register reg_rax, Register thread, Register tmp, Label& slow) {\n@@ -10280,1 +10280,1 @@\n-  assert_different_registers(obj, reg_rax, thread, tmp);\n+  assert_different_registers(basic_lock, obj, reg_rax, thread, tmp);\n@@ -10289,0 +10289,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    movptr(Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))), 0);\n+  }\n+\n@@ -10327,3 +10332,0 @@\n-\/\/\n-\/\/ x86_32 Note: reg_rax and thread may alias each other due to limited register\n-\/\/              availiability.\n@@ -10332,2 +10334,1 @@\n-  assert_different_registers(obj, reg_rax, tmp);\n-  LP64_ONLY(assert_different_registers(obj, reg_rax, thread, tmp);)\n+  assert_different_registers(obj, reg_rax, thread, tmp);\n@@ -10373,4 +10374,0 @@\n-  if (thread == reg_rax) {\n-    \/\/ On x86_32 we may lose the thread.\n-    get_thread(thread);\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2151,1 +2151,1 @@\n-  void lightweight_lock(Register obj, Register reg_rax, Register thread, Register tmp, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register reg_rax, Register thread, Register tmp, Label& slow);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-  __ jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));\n+  __ jump(RuntimeAddress(SharedRuntime::throw_AbstractMethodError_entry()));\n@@ -513,1 +513,1 @@\n-      __ jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));\n+      __ jump(RuntimeAddress(SharedRuntime::throw_IncompatibleClassChangeError_entry()));\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,3 +65,5 @@\n-    \/\/ check if monitor\n-    __ testptr(result, markWord::monitor_value);\n-    __ jcc(Assembler::notZero, slowCase);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ check if monitor\n+      __ testptr(result, markWord::monitor_value);\n+      __ jcc(Assembler::notZero, slowCase);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -59,0 +60,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif \/\/ PRODUCT\n+\n@@ -1689,1 +1696,2 @@\n-      __ lightweight_lock(obj_reg, swap_reg, thread, lock_reg, slow_path_lock);\n+      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+      __ jmp(slow_path_lock);\n@@ -2633,0 +2641,204 @@\n+\n+  \/\/------------------------------------------------------------------------------------------------------------------------\n+  \/\/ Continuation point for throwing of implicit exceptions that are not handled in\n+  \/\/ the current activation. Fabricates an exception oop and initiates normal\n+  \/\/ exception dispatching in this frame.\n+  \/\/\n+  \/\/ Previously the compiler (c2) allowed for callee save registers on Java calls.\n+  \/\/ This is no longer true after adapter frames were removed but could possibly\n+  \/\/ be brought back in the future if the interpreter code was reworked and it\n+  \/\/ was deemed worthwhile. The comment below was left to describe what must\n+  \/\/ happen here if callee saves were resurrected. As it stands now this stub\n+  \/\/ could actually be a vanilla BufferBlob and have now oopMap at all.\n+  \/\/ Since it doesn't make much difference we've chosen to leave it the\n+  \/\/ way it was in the callee save days and keep the comment.\n+\n+  \/\/ If we need to preserve callee-saved values we need a callee-saved oop map and\n+  \/\/ therefore have to make these stubs into RuntimeStubs rather than BufferBlobs.\n+  \/\/ If the compiler needs all registers to be preserved between the fault\n+  \/\/ point and the exception handler then it must assume responsibility for that in\n+  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+  \/\/ continuation_for_implicit_division_by_zero_exception. All other implicit\n+  \/\/ exceptions (e.g., NullPointerException or AbstractMethodError on entry) are\n+  \/\/ either at call sites or otherwise assume that stack unwinding will be initiated,\n+  \/\/ so caller saved registers were assumed volatile in the compiler.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  enum layout {\n+    thread_off,    \/\/ last_java_sp\n+    arg1_off,\n+    arg2_off,\n+    rbp_off,       \/\/ callee saved register\n+    ret_pc,\n+    framesize\n+  };\n+\n+  int insts_size = 256;\n+  int locs_size  = 32;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+  Register java_thread = rbx;\n+  __ get_thread(java_thread);\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ pc and rbp, already pushed\n+  __ subptr(rsp, (framesize-2) * wordSize); \/\/ prolog\n+\n+  \/\/ Frame is now completed as far as size and linkage.\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ push java thread (becomes first argument of C function)\n+  __ movptr(Address(rsp, thread_off * wordSize), java_thread);\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  __ set_last_Java_frame(java_thread, rsp, rbp, nullptr, noreg);\n+\n+  \/\/ Call runtime\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ call(RuntimeAddress(runtime_entry));\n+  \/\/ Generate oop map\n+  OopMap* map =  new OopMap(framesize, 0);\n+  oop_maps->add_gc_map(__ pc() - start, map);\n+\n+  \/\/ restore the thread (cannot use the pushed argument since arguments\n+  \/\/ may be overwritten by C code generated by an optimizing compiler);\n+  \/\/ however can use the register value directly if it is callee saved.\n+  __ get_thread(java_thread);\n+\n+  __ reset_last_Java_frame(java_thread, true);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n+  __ jcc(Assembler::notEqual, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/* ASSERT *\/\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+\n+  RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete, framesize, oop_maps, false);\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+static void jfr_prologue(address the_pc, MacroAssembler* masm) {\n+  Register java_thread = rdi;\n+  __ get_thread(java_thread);\n+  __ set_last_Java_frame(java_thread, rsp, rbp, the_pc, noreg);\n+  __ movptr(Address(rsp, 0), java_thread);\n+}\n+\n+\/\/ The handle is dereferenced through a load barrier.\n+static void jfr_epilogue(MacroAssembler* masm) {\n+  Register java_thread = rdi;\n+  __ get_thread(java_thread);\n+  __ reset_last_Java_frame(java_thread, true);\n+}\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    FPUState_off         = 0,\n+    rbp_off              = FPUStateSizeInWords,\n+    rdi_off,\n+    rsi_off,\n+    rcx_off,\n+    rbx_off,\n+    saved_argument_off,\n+    saved_argument_off2, \/\/ 2nd half of double\n+    framesize\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+  jfr_epilogue(masm);\n+  __ resolve_global_jobject(rax, rdi, rdx);\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    FPUState_off = 0,\n+    rbp_off = FPUStateSizeInWords,\n+    rdi_off,\n+    rsi_off,\n+    rcx_off,\n+    rbx_off,\n+    saved_argument_off,\n+    saved_argument_off2, \/\/ 2nd half of double\n+    framesize\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  jfr_epilogue(masm);\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":213,"deletions":1,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -73,0 +74,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif \/\/ PRODUCT\n+\n@@ -2269,1 +2276,1 @@\n-      __ lightweight_lock(obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n+      __ lightweight_lock(lock_reg, obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n@@ -3213,0 +3220,95 @@\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Since we need to preserve callee-saved values (currently\n+\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+\/\/ map and therefore have to make these stubs into RuntimeStubs\n+\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+\/\/ be preserved between the fault point and the exception handler\n+\/\/ then it must assume responsibility for that in\n+\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  enum layout {\n+    rbp_off = frame::arg_reg_save_area_bytes\/BytesPerInt,\n+    rbp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 512;\n+  int locs_size  = 64;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n+\n+  \/\/ return address and rbp are already in place\n+  __ subptr(rsp, (framesize-4) << LogBytesPerInt); \/\/ prolog\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n+  __ andptr(rsp, -(StackAlignmentInBytes));    \/\/ Align stack\n+\n+  \/\/ Call runtime\n+  __ movptr(c_rarg0, r15_thread);\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ call(RuntimeAddress(runtime_entry));\n+\n+  \/\/ Generate oop map\n+  OopMap* map = new OopMap(framesize, 0);\n+\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n+  __ jcc(Assembler::notEqual, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/\/ ASSERT\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+\n+  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n@@ -3478,0 +3580,91 @@\n+#if INCLUDE_JFR\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_write_checkpoint\", 1024, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  address start = __ pc();\n+\n+  __ enter();\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n+  __ movptr(c_rarg0, r15_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+  __ reset_last_Java_frame(true);\n+\n+  \/\/ rax is jobject handle result, unpack and process it through a barrier.\n+  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_return_lease\", 1024, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  address start = __ pc();\n+\n+  __ enter();\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch2);\n+  __ movptr(c_rarg0, r15_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":194,"deletions":1,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -3846,14 +3846,0 @@\n- public:\n-  \/\/ Information about frame layout at time of blocking runtime call.\n-  \/\/ Note that we only have to preserve callee-saved registers since\n-  \/\/ the compilers are responsible for supplying a continuation point\n-  \/\/ if they expect all registers to be preserved.\n-  enum layout {\n-    thread_off,    \/\/ last_java_sp\n-    arg1_off,\n-    arg2_off,\n-    rbp_off,       \/\/ callee saved register\n-    ret_pc,\n-    framesize\n-  };\n-\n@@ -3862,99 +3848,0 @@\n-#undef  __\n-#define __ masm->\n-\n-  \/\/------------------------------------------------------------------------------------------------------------------------\n-  \/\/ Continuation point for throwing of implicit exceptions that are not handled in\n-  \/\/ the current activation. Fabricates an exception oop and initiates normal\n-  \/\/ exception dispatching in this frame.\n-  \/\/\n-  \/\/ Previously the compiler (c2) allowed for callee save registers on Java calls.\n-  \/\/ This is no longer true after adapter frames were removed but could possibly\n-  \/\/ be brought back in the future if the interpreter code was reworked and it\n-  \/\/ was deemed worthwhile. The comment below was left to describe what must\n-  \/\/ happen here if callee saves were resurrected. As it stands now this stub\n-  \/\/ could actually be a vanilla BufferBlob and have now oopMap at all.\n-  \/\/ Since it doesn't make much difference we've chosen to leave it the\n-  \/\/ way it was in the callee save days and keep the comment.\n-\n-  \/\/ If we need to preserve callee-saved values we need a callee-saved oop map and\n-  \/\/ therefore have to make these stubs into RuntimeStubs rather than BufferBlobs.\n-  \/\/ If the compiler needs all registers to be preserved between the fault\n-  \/\/ point and the exception handler then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other implicit\n-  \/\/ exceptions (e.g., NullPointerException or AbstractMethodError on entry) are\n-  \/\/ either at call sites or otherwise assume that stack unwinding will be initiated,\n-  \/\/ so caller saved registers were assumed volatile in the compiler.\n-  address generate_throw_exception(const char* name, address runtime_entry,\n-                                   Register arg1 = noreg, Register arg2 = noreg) {\n-\n-    int insts_size = 256;\n-    int locs_size  = 32;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-    Register java_thread = rbx;\n-    __ get_thread(java_thread);\n-\n-    __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-    \/\/ pc and rbp, already pushed\n-    __ subptr(rsp, (framesize-2) * wordSize); \/\/ prolog\n-\n-    \/\/ Frame is now completed as far as size and linkage.\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ push java thread (becomes first argument of C function)\n-    __ movptr(Address(rsp, thread_off * wordSize), java_thread);\n-    if (arg1 != noreg) {\n-      __ movptr(Address(rsp, arg1_off * wordSize), arg1);\n-    }\n-    if (arg2 != noreg) {\n-      assert(arg1 != noreg, \"missing reg arg\");\n-      __ movptr(Address(rsp, arg2_off * wordSize), arg2);\n-    }\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    __ set_last_Java_frame(java_thread, rsp, rbp, nullptr, noreg);\n-\n-    \/\/ Call runtime\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ call(RuntimeAddress(runtime_entry));\n-    \/\/ Generate oop map\n-    OopMap* map =  new OopMap(framesize, 0);\n-    oop_maps->add_gc_map(__ pc() - start, map);\n-\n-    \/\/ restore the thread (cannot use the pushed argument since arguments\n-    \/\/ may be overwritten by C code generated by an optimizing compiler);\n-    \/\/ however can use the register value directly if it is callee saved.\n-    __ get_thread(java_thread);\n-\n-    __ reset_last_Java_frame(java_thread, true);\n-\n-    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n-    __ jcc(Assembler::notEqual, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/* ASSERT *\/\n-    __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-\n-    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete, framesize, oop_maps, false);\n-    return stub->entry_point();\n-  }\n-\n-\n@@ -4000,103 +3887,0 @@\n-#if INCLUDE_JFR\n-\n-  static void jfr_prologue(address the_pc, MacroAssembler* masm) {\n-    Register java_thread = rdi;\n-    __ get_thread(java_thread);\n-    __ set_last_Java_frame(java_thread, rsp, rbp, the_pc, noreg);\n-    __ movptr(Address(rsp, 0), java_thread);\n-  }\n-\n-  \/\/ The handle is dereferenced through a load barrier.\n-  static void jfr_epilogue(MacroAssembler* masm) {\n-    Register java_thread = rdi;\n-    __ get_thread(java_thread);\n-    __ reset_last_Java_frame(java_thread, true);\n-  }\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      FPUState_off         = 0,\n-      rbp_off              = FPUStateSizeInWords,\n-      rdi_off,\n-      rsi_off,\n-      rcx_off,\n-      rbx_off,\n-      saved_argument_off,\n-      saved_argument_off2, \/\/ 2nd half of double\n-      framesize\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-    jfr_epilogue(_masm);\n-    __ resolve_global_jobject(rax, rdi, rdx);\n-    __ leave();\n-    __ ret(0);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      FPUState_off = 0,\n-      rbp_off = FPUStateSizeInWords,\n-      rdi_off,\n-      rsi_off,\n-      rcx_off,\n-      rbx_off,\n-      saved_argument_off,\n-      saved_argument_off2, \/\/ 2nd half of double\n-      framesize\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-    jfr_epilogue(_masm);\n-    __ leave();\n-    __ ret(0);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -4133,6 +3917,0 @@\n-    \/\/ Build this early so it's available for the interpreter\n-    StubRoutines::_throw_StackOverflowError_entry          = generate_throw_exception(\"StackOverflowError throw_exception\",\n-                                                                                      CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));\n-    StubRoutines::_throw_delayed_StackOverflowError_entry  = generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                                                                                      CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError));\n-\n@@ -4191,2 +3969,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n@@ -4195,9 +3971,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-  }\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -4207,6 +3974,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in non-core builds\n-    \/\/ and need to be relocatable, so they each fabricate a RuntimeStub internally.\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":0,"deletions":239,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -48,3 +48,0 @@\n-#if INCLUDE_JFR\n-#include \"jfr\/support\/jfrIntrinsics.hpp\"\n-#endif\n@@ -3705,1 +3702,1 @@\n-  __ jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  __ jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -3781,192 +3778,0 @@\n-#if INCLUDE_JFR\n-\n-\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-\/\/ It returns a jobject handle to the event writer.\n-\/\/ The handle is dereferenced and the return value is the event writer oop.\n-RuntimeStub* StubGenerator::generate_jfr_write_checkpoint() {\n-  enum layout {\n-    rbp_off,\n-    rbpH_off,\n-    return_off,\n-    return_off2,\n-    framesize \/\/ inclusive of return address\n-  };\n-\n-  CodeBuffer code(\"jfr_write_checkpoint\", 1024, 64);\n-  MacroAssembler* _masm = new MacroAssembler(&code);\n-  address start = __ pc();\n-\n-  __ enter();\n-  address the_pc = __ pc();\n-\n-  int frame_complete = the_pc - start;\n-\n-  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n-  __ movptr(c_rarg0, r15_thread);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-  __ reset_last_Java_frame(true);\n-\n-  \/\/ rax is jobject handle result, unpack and process it through a barrier.\n-  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n-\n-  __ leave();\n-  __ ret(0);\n-\n-  OopMapSet* oop_maps = new OopMapSet();\n-  OopMap* map = new OopMap(framesize, 1);\n-  oop_maps->add_gc_map(frame_complete, map);\n-\n-  RuntimeStub* stub =\n-    RuntimeStub::new_runtime_stub(code.name(),\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps,\n-                                  false);\n-  return stub;\n-}\n-\n-\/\/ For c2: call to return a leased buffer.\n-RuntimeStub* StubGenerator::generate_jfr_return_lease() {\n-  enum layout {\n-    rbp_off,\n-    rbpH_off,\n-    return_off,\n-    return_off2,\n-    framesize \/\/ inclusive of return address\n-  };\n-\n-  CodeBuffer code(\"jfr_return_lease\", 1024, 64);\n-  MacroAssembler* _masm = new MacroAssembler(&code);\n-  address start = __ pc();\n-\n-  __ enter();\n-  address the_pc = __ pc();\n-\n-  int frame_complete = the_pc - start;\n-\n-  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch2);\n-  __ movptr(c_rarg0, r15_thread);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-  __ reset_last_Java_frame(true);\n-\n-  __ leave();\n-  __ ret(0);\n-\n-  OopMapSet* oop_maps = new OopMapSet();\n-  OopMap* map = new OopMap(framesize, 1);\n-  oop_maps->add_gc_map(frame_complete, map);\n-\n-  RuntimeStub* stub =\n-    RuntimeStub::new_runtime_stub(code.name(),\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps,\n-                                  false);\n-  return stub;\n-}\n-\n-#endif \/\/ INCLUDE_JFR\n-\n-\/\/ Continuation point for throwing of implicit exceptions that are\n-\/\/ not handled in the current activation. Fabricates an exception\n-\/\/ oop and initiates normal exception dispatching in this\n-\/\/ frame. Since we need to preserve callee-saved values (currently\n-\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-\/\/ map and therefore have to make these stubs into RuntimeStubs\n-\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-\/\/ be preserved between the fault point and the exception handler\n-\/\/ then it must assume responsibility for that in\n-\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-\/\/ continuation_for_implicit_division_by_zero_exception. All other\n-\/\/ implicit exceptions (e.g., NullPointerException or\n-\/\/ AbstractMethodError on entry) are either at call sites or\n-\/\/ otherwise assume that stack unwinding will be initiated, so\n-\/\/ caller saved registers were assumed volatile in the compiler.\n-address StubGenerator::generate_throw_exception(const char* name,\n-                                                address runtime_entry,\n-                                                Register arg1,\n-                                                Register arg2) {\n-  \/\/ Information about frame layout at time of blocking runtime call.\n-  \/\/ Note that we only have to preserve callee-saved registers since\n-  \/\/ the compilers are responsible for supplying a continuation point\n-  \/\/ if they expect all registers to be preserved.\n-  enum layout {\n-    rbp_off = frame::arg_reg_save_area_bytes\/BytesPerInt,\n-    rbp_off2,\n-    return_off,\n-    return_off2,\n-    framesize \/\/ inclusive of return address\n-  };\n-\n-  int insts_size = 512;\n-  int locs_size  = 64;\n-\n-  CodeBuffer code(name, insts_size, locs_size);\n-  OopMapSet* oop_maps  = new OopMapSet();\n-  MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-  address start = __ pc();\n-\n-  \/\/ This is an inlined and slightly modified version of call_VM\n-  \/\/ which has the ability to fetch the return PC out of\n-  \/\/ thread-local storage and also sets up last_Java_sp slightly\n-  \/\/ differently than the real call_VM\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n-\n-  \/\/ return address and rbp are already in place\n-  __ subptr(rsp, (framesize-4) << LogBytesPerInt); \/\/ prolog\n-\n-  int frame_complete = __ pc() - start;\n-\n-  \/\/ Set up last_Java_sp and last_Java_fp\n-  address the_pc = __ pc();\n-  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n-  __ andptr(rsp, -(StackAlignmentInBytes));    \/\/ Align stack\n-\n-  \/\/ Call runtime\n-  if (arg1 != noreg) {\n-    assert(arg2 != c_rarg1, \"clobbered\");\n-    __ movptr(c_rarg1, arg1);\n-  }\n-  if (arg2 != noreg) {\n-    __ movptr(c_rarg2, arg2);\n-  }\n-  __ movptr(c_rarg0, r15_thread);\n-  BLOCK_COMMENT(\"call runtime_entry\");\n-  __ call(RuntimeAddress(runtime_entry));\n-\n-  \/\/ Generate oop map\n-  OopMap* map = new OopMap(framesize, 0);\n-\n-  oop_maps->add_gc_map(the_pc - start, map);\n-\n-  __ reset_last_Java_frame(true);\n-\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  \/\/ check for pending exceptions\n-#ifdef ASSERT\n-  Label L;\n-  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n-  __ jcc(Assembler::notEqual, L);\n-  __ should_not_reach_here();\n-  __ bind(L);\n-#endif \/\/ ASSERT\n-  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-\n-  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-  RuntimeStub* stub =\n-    RuntimeStub::new_runtime_stub(name,\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps, false);\n-  return stub->entry_point();\n-}\n-\n@@ -4090,11 +3895,0 @@\n-  \/\/ Build this early so it's available for the interpreter.\n-  StubRoutines::_throw_StackOverflowError_entry =\n-    generate_throw_exception(\"StackOverflowError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_StackOverflowError));\n-  StubRoutines::_throw_delayed_StackOverflowError_entry =\n-    generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_delayed_StackOverflowError));\n@@ -4134,2 +3928,0 @@\n-\n-  JFR_ONLY(generate_jfr_stubs();)\n@@ -4138,9 +3930,0 @@\n-#if INCLUDE_JFR\n-void StubGenerator::generate_jfr_stubs() {\n-  StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-  StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-  StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-  StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-}\n-#endif\n-\n@@ -4150,21 +3933,0 @@\n-  \/\/ These entry points require SharedInfo::stack0 to be set up in\n-  \/\/ non-core builds and need to be relocatable, so they each\n-  \/\/ fabricate a RuntimeStub internally.\n-  StubRoutines::_throw_AbstractMethodError_entry =\n-    generate_throw_exception(\"AbstractMethodError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_AbstractMethodError));\n-\n-  StubRoutines::_throw_IncompatibleClassChangeError_entry =\n-    generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_IncompatibleClassChangeError));\n-\n-  StubRoutines::_throw_NullPointerException_at_call_entry =\n-    generate_throw_exception(\"NullPointerException at call throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_NullPointerException_at_call));\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":239,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -589,10 +589,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs();\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  RuntimeStub* generate_jfr_write_checkpoint();\n-  \/\/ For c2: call to runtime to return a buffer lease.\n-  RuntimeStub* generate_jfr_return_lease();\n-#endif \/\/ INCLUDE_JFR\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -548,2 +548,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  __ jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  __ jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-static RuntimeStub* generate_empty_runtime_stub(const char* name) {\n+static RuntimeStub* generate_empty_runtime_stub() {\n@@ -104,1 +104,0 @@\n-\n@@ -114,1 +113,5 @@\n-  return generate_empty_runtime_stub(\"resolve_blob\");\n+  return generate_empty_runtime_stub();\n+}\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  return generate_empty_runtime_stub();\n@@ -130,0 +133,12 @@\n+\n+#if INCLUDE_JFR\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  return nullptr;\n+}\n+\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  return nullptr;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -206,16 +206,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in\n-    \/\/ non-core builds and need to be relocatable, so they each\n-    \/\/ fabricate a RuntimeStub internally.\n-    StubRoutines::_throw_AbstractMethodError_entry =\n-      ShouldNotCallThisStub();\n-\n-    StubRoutines::_throw_NullPointerException_at_call_entry =\n-      ShouldNotCallThisStub();\n-\n-    StubRoutines::_throw_StackOverflowError_entry =\n-      ShouldNotCallThisStub();\n-\n-    \/\/ support for verify_oop (must happen after universe_init)\n-    StubRoutines::_verify_oop_subroutine_entry =\n-      ShouldNotCallThisStub();\n-\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -47,0 +48,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -334,13 +336,15 @@\n-    markWord disp = lockee->mark().set_unlocked();\n-    monitor->lock()->set_displaced_header(disp);\n-    bool call_vm = (LockingMode == LM_MONITOR);\n-    bool inc_monitor_count = true;\n-    if (call_vm || lockee->cas_set_mark(markWord::from_pointer(monitor), disp) != disp) {\n-      \/\/ Is it simple recursive case?\n-      if (!call_vm && thread->is_lock_owned((address) disp.clear_lock_bits().to_pointer())) {\n-        monitor->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-      } else {\n-        inc_monitor_count = false;\n-        CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));\n-        if (HAS_PENDING_EXCEPTION)\n-          goto unwind_and_return;\n+    bool success = false;\n+    if (LockingMode == LM_LEGACY) {\n+      markWord disp = lockee->mark().set_unlocked();\n+      monitor->lock()->set_displaced_header(disp);\n+      success = true;\n+      if (lockee->cas_set_mark(markWord::from_pointer(monitor), disp) != disp) {\n+        \/\/ Is it simple recursive case?\n+        if (thread->is_lock_owned((address) disp.clear_lock_bits().to_pointer())) {\n+          monitor->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+        } else {\n+          success = false;\n+        }\n+      }\n+      if (success) {\n+        THREAD->inc_held_monitor_count();\n@@ -349,2 +353,4 @@\n-    if (inc_monitor_count) {\n-      THREAD->inc_held_monitor_count();\n+    if (!success) {\n+      CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));\n+          if (HAS_PENDING_EXCEPTION)\n+            goto unwind_and_return;\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-  \/*  NB: The default value of UseLinuxPosixThreadCPUClocks may be   *\/ \\\n-  \/* overridden in Arguments::parse_each_vm_init_arg.                *\/ \\\n@@ -44,1 +42,1 @@\n-          \"enable fast Linux Posix clocks where available\")             \\\n+          \"(Deprecated) enable fast Linux Posix clocks where available\") \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-    _snprintf(msg, sizeof(msg), \"%d\\n\", result);\n+    os::snprintf(msg, sizeof(msg), \"%d\\n\", result);\n","filename":"src\/hotspot\/os\/windows\/attachListener_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1779,3 +1779,3 @@\n-    ::_snprintf(ebuf, ebuflen - 1,\n-                \"Can't load %s-bit .dll on a %s-bit platform\",\n-                lib_arch_str, running_arch_str);\n+    os::snprintf(ebuf, ebuflen - 1,\n+                 \"Can't load %s-bit .dll on a %s-bit platform\",\n+                 lib_arch_str, running_arch_str);\n@@ -1784,3 +1784,3 @@\n-    ::_snprintf(ebuf, ebuflen - 1,\n-                \"Can't load this .dll (machine code=0x%x) on a %s-bit platform\",\n-                lib_arch, running_arch_str);\n+    os::snprintf(ebuf, ebuflen - 1,\n+                 \"Can't load this .dll (machine code=0x%x) on a %s-bit platform\",\n+                 lib_arch, running_arch_str);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,1 @@\n-  _snprintf(dirname, nbytes, \"%s\\\\%s_%s\", tmpdir, perfdir, user);\n+  os::snprintf(dirname, nbytes, \"%s\\\\%s_%s\", tmpdir, perfdir, user);\n@@ -458,1 +458,1 @@\n-  _snprintf(name, nbytes, \"%s_%s_%u\", PERFDATA_NAME, user, vmid);\n+  os::snprintf(name, nbytes, \"%s_%s_%u\", PERFDATA_NAME, user, vmid);\n@@ -474,1 +474,1 @@\n-  _snprintf(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n+  os::snprintf(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n","filename":"src\/hotspot\/os\/windows\/perfMemory_windows.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1566,1 +1566,1 @@\n-       (scope()->wrote_final() ||\n+       (scope()->wrote_final() || scope()->wrote_stable() ||\n@@ -1744,4 +1744,0 @@\n-  if (field->is_final() && (code == Bytecodes::_putfield)) {\n-    scope()->set_wrote_final();\n-  }\n-\n@@ -1753,0 +1749,6 @@\n+    if (field->is_final()) {\n+      scope()->set_wrote_final();\n+    }\n+    if (field->is_stable()) {\n+      scope()->set_wrote_stable();\n+    }\n@@ -2117,1 +2119,1 @@\n-    assert(!target->can_be_statically_bound() || target == cha_monomorphic_target, \"\");\n+    assert(!target->can_be_statically_bound() || target->equals(cha_monomorphic_target), \"\");\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  _wrote_stable       = false;\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+  bool          _wrote_stable;                   \/\/ has written @Stable field\n@@ -190,0 +191,2 @@\n+  void          set_wrote_stable()               { _wrote_stable = true; }\n+  bool          wrote_stable() const             { return _wrote_stable; }\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -760,2 +760,2 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT || obj == lock->obj(), \"must match\");\n-  SharedRuntime::monitor_enter_helper(obj, LockingMode == LM_LIGHTWEIGHT ? nullptr : lock->lock(), current);\n+  assert(obj == lock->obj(), \"must match\");\n+  SharedRuntime::monitor_enter_helper(obj, lock->lock(), current);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,0 +115,6 @@\n+  \/\/ The minimum region size of all collectors that are supported by CDS in\n+  \/\/ ArchiveHeapLoader::can_map() mode. Currently only G1 is supported. G1's region size\n+  \/\/ depends on -Xmx, but can never be smaller than 1 * M.\n+  \/\/ (TODO: Perhaps change to 256K to be compatible with Shenandoah)\n+  static constexpr int MIN_GC_REGION_ALIGNMENT = 1 * M;\n+\n@@ -122,6 +128,0 @@\n-  \/\/ The minimum region size of all collectors that are supported by CDS in\n-  \/\/ ArchiveHeapLoader::can_map() mode. Currently only G1 is supported. G1's region size\n-  \/\/ depends on -Xmx, but can never be smaller than 1 * M.\n-  \/\/ (TODO: Perhaps change to 256K to be compatible with Shenandoah)\n-  static constexpr int MIN_GC_REGION_ALIGNMENT = 1 * M;\n-\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2028,1 +2028,1 @@\n-        log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC or UseParallelGC are required.\");\n+        log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC, UseParallelGC, or UseShenandoahGC are required.\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -784,0 +784,16 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciMethod::equals\n+\/\/\n+\/\/ Returns true if the methods are the same, taking redefined methods\n+\/\/ into account.\n+bool ciMethod::equals(const ciMethod* m) const {\n+  if (this == m) return true;\n+  VM_ENTRY_MARK;\n+  Method* m1 = this->get_Method();\n+  Method* m2 = m->get_Method();\n+  if (m1->is_old()) m1 = m1->get_new_method();\n+  if (m2->is_old()) m2 = m2->get_new_method();\n+  return m1 == m2;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -369,0 +369,2 @@\n+  bool equals(const ciMethod* m) const;\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,1 +264,2 @@\n-  if ((int)strlen(name) > Symbol::max_length()) {\n+  size_t name_len = strlen(name);\n+  if (name_len > static_cast<size_t>(Symbol::max_length())) {\n@@ -266,5 +267,18 @@\n-    \/\/ into the constant pool.\n-    Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n-                       \"Class name exceeds maximum length of %d: %s\",\n-                       Symbol::max_length(),\n-                       name);\n+    \/\/ into the constant pool. If necessary report an abridged name\n+    \/\/ in the exception message.\n+    if (name_len > static_cast<size_t>(MaxStringPrintSize)) {\n+      Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n+                         \"Class name exceeds maximum length of %d: %.*s ... (%zu characters omitted) ... %.*s\",\n+                         Symbol::max_length(),\n+                         MaxStringPrintSize \/ 2,\n+                         name,\n+                         name_len - 2 * (MaxStringPrintSize \/ 2), \/\/ allows for odd value\n+                         MaxStringPrintSize \/ 2,\n+                         name + name_len - MaxStringPrintSize \/ 2);\n+    }\n+    else {\n+      Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n+                         \"Class name exceeds maximum length of %d: %s\",\n+                         Symbol::max_length(),\n+                         name);\n+    }\n@@ -274,1 +288,2 @@\n-  assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false),\n+  assert(UTF8::is_legal_utf8((const unsigned char*)name,\n+                             static_cast<int>(name_len), false),\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  do_klass(IllegalCallerException_klass,                java_lang_IllegalCallerException                      ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -245,0 +245,2 @@\n+    case vmIntrinsics::_Continuation_pin:\n+    case vmIntrinsics::_Continuation_unpin:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -603,0 +603,2 @@\n+  do_intrinsic(_Continuation_pin,          jdk_internal_vm_Continuation, pin_name, void_method_signature, F_SN)         \\\n+  do_intrinsic(_Continuation_unpin,        jdk_internal_vm_Continuation, unpin_name, void_method_signature, F_SN)       \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,0 +206,1 @@\n+  template(java_lang_IllegalCallerException,          \"java\/lang\/IllegalCallerException\")         \\\n@@ -409,0 +410,2 @@\n+  template(pin_name,                                  \"pin\")                                      \\\n+  template(unpin_name,                                \"unpin\")                                    \\\n@@ -589,1 +592,1 @@\n-  template(classloader_string_long_signature,         \"(Ljava\/lang\/ClassLoader;Ljava\/lang\/String;)J\")             \\\n+  template(classloader_class_string_string_long_signature,         \"(Ljava\/lang\/ClassLoader;Ljava\/lang\/Class;Ljava\/lang\/String;Ljava\/lang\/String;)J\")             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -247,0 +247,4 @@\n+  \/\/ The claim size for group cardsets should be smaller to facilitate\n+  \/\/ better work distribution. The group cardsets should be larger than\n+  \/\/ the per region cardsets.\n+  const static uint GroupBucketClaimSize = 4;\n@@ -350,1 +354,9 @@\n-    _table_scanner.set(&_table, BucketClaimSize);\n+    reset_table_scanner(BucketClaimSize);\n+  }\n+\n+  void reset_table_scanner_for_groups() {\n+    reset_table_scanner(GroupBucketClaimSize);\n+  }\n+\n+  void reset_table_scanner(uint claim_size) {\n+    _table_scanner.set(&_table, claim_size);\n@@ -1045,0 +1057,4 @@\n+\n+void G1CardSet::reset_table_scanner_for_groups() {\n+  _table->reset_table_scanner_for_groups();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -383,0 +383,2 @@\n+  void reset_table_scanner_for_groups();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1162,0 +1162,2 @@\n+  _young_regions_cardset_mm(card_set_config(), card_set_freelist_pool()),\n+  _young_regions_cardset(card_set_config(), &_young_regions_cardset_mm),\n@@ -2696,0 +2698,1 @@\n+  hr->install_group_cardset(young_regions_cardset());\n@@ -2905,0 +2908,2 @@\n+      \/\/ Install the group cardset.\n+      new_alloc_region->install_group_cardset(young_regions_cardset());\n@@ -3046,0 +3051,4 @@\n+\n+void G1CollectedHeap::prepare_group_cardsets_for_scan () {\n+  _young_regions_cardset.reset_table_scanner_for_groups();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -782,0 +782,4 @@\n+  \/\/ Group cardsets\n+  G1CardSetMemoryManager _young_regions_cardset_mm;\n+  G1CardSet _young_regions_cardset;\n+\n@@ -783,0 +787,8 @@\n+  G1CardSetConfiguration* card_set_config() { return &_card_set_config; }\n+\n+  G1CardSet* young_regions_cardset() { return &_young_regions_cardset; };\n+\n+  G1CardSetMemoryManager* young_regions_card_set_mm() { return &_young_regions_cardset_mm; }\n+\n+  void prepare_group_cardsets_for_scan();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards);\n+  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards, _g1h->young_regions_cardset()->occupied());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2983,0 +2983,1 @@\n+  _young_cardset_bytes_per_region(0),\n@@ -2993,0 +2994,7 @@\n+  uint num_young_regions = g1h->young_regions_count();\n+  size_t young_cardset_bytes = g1h->young_regions_cardset()->mem_size();\n+\n+  if (num_young_regions > 0) {\n+    _young_cardset_bytes_per_region = young_cardset_bytes \/ num_young_regions;\n+  }\n+\n@@ -3044,0 +3052,4 @@\n+  if (r->is_young()) {\n+    remset_bytes = _young_cardset_bytes_per_region;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -961,0 +961,2 @@\n+  size_t _young_cardset_bytes_per_region;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-  size_t _sampled_card_rs_length;\n@@ -262,1 +261,1 @@\n-    _sampled_card_rs_length(0), _sampled_code_root_rs_length(0) {}\n+    _sampled_code_root_rs_length(0) {}\n@@ -266,1 +265,0 @@\n-    _sampled_card_rs_length += rem_set->occupied();\n@@ -271,1 +269,0 @@\n-  size_t sampled_card_rs_length() const { return _sampled_card_rs_length; }\n@@ -289,0 +286,2 @@\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    G1CollectionSet* cset = g1h->collection_set();\n@@ -290,1 +289,0 @@\n-    G1CollectionSet* cset = G1CollectedHeap::heap()->collection_set();\n@@ -292,1 +290,5 @@\n-    _policy->revise_young_list_target_length(cl.sampled_card_rs_length(), cl.sampled_code_root_rs_length());\n+\n+    size_t card_rs_length = g1h->young_regions_cardset()->occupied();\n+\n+    size_t sampled_code_root_rs_length = cl.sampled_code_root_rs_length();\n+    _policy->revise_young_list_target_length(card_rs_length, sampled_code_root_rs_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+    hr->uninstall_group_cardset();\n@@ -250,0 +251,2 @@\n+  _heap->young_regions_cardset()->clear();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+  uninstall_group_cardset();\n@@ -218,0 +219,3 @@\n+  if (is_young()) {\n+    uninstall_group_cardset();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+class G1CardSet;\n@@ -511,0 +512,3 @@\n+  void install_group_cardset(G1CardSet* group_cardset);\n+  void uninstall_group_cardset();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -514,0 +514,8 @@\n+inline void G1HeapRegion::install_group_cardset(G1CardSet* group_cardset) {\n+  _rem_set->install_group_cardset(group_cardset);\n+}\n+\n+inline void G1HeapRegion::uninstall_group_cardset() {\n+  _rem_set->uninstall_group_cardset();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,0 +58,7 @@\n+void G1HeapRegionRemSet::uninstall_group_cardset() {\n+  if (_saved_card_set != nullptr) {\n+    _card_set = _saved_card_set;\n+    _saved_card_set = nullptr;\n+  }\n+}\n+\n@@ -62,1 +69,2 @@\n-  _card_set(config, &_card_set_mm),\n+  _card_set(new G1CardSet(config, &_card_set_mm)),\n+  _saved_card_set(nullptr),\n@@ -71,0 +79,1 @@\n+  assert(_saved_card_set == nullptr, \"pre-condition\");\n@@ -75,1 +84,1 @@\n-  _card_set.clear();\n+  _card_set->clear();\n@@ -86,1 +95,1 @@\n-  _card_set.reset_table_scanner();\n+  _card_set->reset_table_scanner();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,1 +50,2 @@\n-  G1CardSet _card_set;\n+  G1CardSet* _card_set;\n+  G1CardSet* _saved_card_set;\n@@ -61,0 +62,1 @@\n+  ~G1HeapRegionRemSet() { delete _card_set; }\n@@ -63,1 +65,15 @@\n-    return _card_set.is_empty();\n+    return _card_set->is_empty();\n+  }\n+\n+  void install_group_cardset(G1CardSet* group_cardset) {\n+    assert(group_cardset != nullptr, \"pre-condition\");\n+    assert(_saved_card_set == nullptr, \"pre-condition\");\n+\n+    _saved_card_set = _card_set;\n+    _card_set = group_cardset;\n+  }\n+\n+  void uninstall_group_cardset();\n+\n+  bool has_group_cardset() {\n+    return _saved_card_set != nullptr;\n@@ -71,1 +87,1 @@\n-    return (code_roots_list_length() == 0) && _card_set.occupancy_less_or_equal_to(occ);\n+    return (code_roots_list_length() == 0) && _card_set->occupancy_less_or_equal_to(occ);\n@@ -80,0 +96,3 @@\n+  template <class CardOrRangeVisitor>\n+  inline static void iterate_for_merge(G1CardSet* card_set, CardOrRangeVisitor& cl);\n+\n@@ -81,1 +100,1 @@\n-    return _card_set.occupied();\n+    return _card_set->occupied();\n@@ -84,0 +103,2 @@\n+  G1CardSet* card_set() { return _card_set; }\n+\n@@ -128,1 +149,1 @@\n-    return _card_set.mem_size()\n+    return _card_set->mem_size()\n@@ -134,1 +155,1 @@\n-    return _card_set.unused_mem_size();\n+    return _card_set->unused_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.hpp","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -111,5 +111,1 @@\n-  G1HeapRegionRemSetMergeCardClosure<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(&_card_set,\n-                                                                                       cl,\n-                                                                                       _card_set.config()->log2_card_regions_per_heap_region(),\n-                                                                                       _card_set.config()->log2_cards_per_card_region());\n-  _card_set.iterate_containers(&cl2, true \/* at_safepoint *\/);\n+  iterate_for_merge(_card_set, cl);\n@@ -118,0 +114,8 @@\n+template <class CardOrRangeVisitor>\n+void G1HeapRegionRemSet::iterate_for_merge(G1CardSet* card_set, CardOrRangeVisitor& cl) {\n+  G1HeapRegionRemSetMergeCardClosure<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(card_set,\n+                                                                                       cl,\n+                                                                                       card_set->config()->log2_card_regions_per_heap_region(),\n+                                                                                       card_set->config()->log2_cards_per_card_region());\n+  card_set->iterate_containers(&cl2, true \/* at_safepoint *\/);\n+}\n@@ -133,1 +137,1 @@\n-   return;\n+    return;\n@@ -136,1 +140,1 @@\n-  _card_set.add_card(to_card(from));\n+  _card_set->add_card(to_card(from));\n@@ -140,1 +144,1 @@\n-  return _card_set.contains_card(to_card(from));\n+  return _card_set->contains_card(to_card(from));\n@@ -144,1 +148,1 @@\n-  _card_set.print_info(st, to_card(from));\n+  _card_set->print_info(st, to_card(from));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.inline.hpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1092,0 +1092,5 @@\n+  return predict_base_time_ms(pending_cards, card_rs_length);\n+}\n+\n+double G1Policy::predict_base_time_ms(size_t pending_cards, size_t card_rs_length) const {\n+  bool for_young_only_phase = collector_state()->in_young_only_phase();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,0 +141,2 @@\n+  double predict_base_time_ms(size_t pending_cards, size_t card_rs_length) const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1382,0 +1382,4 @@\n+        if (_initial_evacuation) {\n+          G1HeapRegionRemSet::iterate_for_merge(g1h->young_regions_cardset(), merge);\n+        }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+    size_t occupied_cards = hrrs->occupied();\n@@ -225,0 +226,8 @@\n+\n+    if (r->is_young()) {\n+      uint num_young  =  G1CollectedHeap::heap()->young_regions_count();\n+      occupied_cards \/= num_young;\n+      rs_unused_mem_sz \/= num_young;\n+      rs_mem_sz \/= num_young;\n+    }\n+\n@@ -229,1 +238,1 @@\n-    size_t occupied_cards = hrrs->occupied();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -298,4 +298,3 @@\n-      \/\/ Sample card set sizes for young gen and humongous before GC: this makes\n-      \/\/ the policy to give back memory to the OS keep the most recent amount of\n-      \/\/ memory for these regions.\n-      if (hr->is_young() || hr->is_starts_humongous()) {\n+      \/\/ Sample card set sizes for humongous before GC: this makes the policy to give\n+      \/\/ back memory to the OS keep the most recent amount of memory for these regions.\n+      if (hr->is_starts_humongous()) {\n@@ -510,0 +509,3 @@\n+\n+    _g1h->prepare_group_cardsets_for_scan();\n+\n@@ -517,1 +519,4 @@\n-    _g1h->set_young_gen_card_set_stats(g1_prep_task.all_card_set_stats());\n+    G1MonotonicArenaMemoryStats sampled_card_set_stats = g1_prep_task.all_card_set_stats();\n+    sampled_card_set_stats.add(_g1h->young_regions_card_set_mm()->memory_stats());\n+    _g1h->set_young_gen_card_set_stats(sampled_card_set_stats);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -676,0 +676,4 @@\n+\n+    \/\/ Add the cards from the group cardsets.\n+    _card_rs_length += g1h->young_regions_cardset()->occupied();\n+\n@@ -825,1 +829,0 @@\n-    stats()->account_card_rs_length(r);\n@@ -828,0 +831,2 @@\n+      \/\/ We only use card_rs_length statistics to estimate young regions length.\n+      stats()->account_card_rs_length(r);\n@@ -914,0 +919,2 @@\n+\n+    _g1h->young_regions_cardset()->clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -849,1 +849,9 @@\n-  Generation::print_on(st);\n+  st->print(\" %-10s\", name());\n+\n+  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n+            capacity()\/K, used()\/K);\n+  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+               p2i(_virtual_space.low_boundary()),\n+               p2i(_virtual_space.high()),\n+               p2i(_virtual_space.high_boundary()));\n+\n@@ -858,5 +866,0 @@\n-\n-const char* DefNewGeneration::name() const {\n-  return \"def new generation\";\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -237,2 +237,1 @@\n-  virtual const char* name() const;\n-  virtual const char* short_name() const { return \"DefNew\"; }\n+  const char* name() const { return \"DefNew\"; }\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,12 +61,0 @@\n-\n-void Generation::print() const { print_on(tty); }\n-\n-void Generation::print_on(outputStream* st)  const {\n-  st->print(\" %-20s\", name());\n-  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n-             capacity()\/K, used()\/K);\n-  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-              p2i(_virtual_space.low_boundary()),\n-              p2i(_virtual_space.high()),\n-              p2i(_virtual_space.high_boundary()));\n-}\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -106,7 +106,0 @@\n-  \/\/ Printing\n-  virtual const char* name() const = 0;\n-  virtual const char* short_name() const = 0;\n-\n-  virtual void print() const;\n-  virtual void print_on(outputStream* st) const;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -885,6 +885,6 @@\n-  if (_young_gen != nullptr) {\n-    _young_gen->print_on(st);\n-  }\n-  if (_old_gen != nullptr) {\n-    _old_gen->print_on(st);\n-  }\n+  assert(_young_gen != nullptr, \"precondition\");\n+  assert(_old_gen   != nullptr, \"precondition\");\n+\n+  _young_gen->print_on(st);\n+  _old_gen->print_on(st);\n+\n@@ -911,1 +911,1 @@\n-                     HEAP_CHANGE_FORMAT_ARGS(def_new_gen->short_name(),\n+                     HEAP_CHANGE_FORMAT_ARGS(def_new_gen->name(),\n@@ -927,1 +927,1 @@\n-                     HEAP_CHANGE_FORMAT_ARGS(old_gen()->short_name(),\n+                     HEAP_CHANGE_FORMAT_ARGS(old_gen()->name(),\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -443,1 +443,9 @@\n-  Generation::print_on(st);\n+  st->print(\" %-10s\", name());\n+\n+  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n+            capacity()\/K, used()\/K);\n+  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+               p2i(_virtual_space.low_boundary()),\n+               p2i(_virtual_space.high()),\n+               p2i(_virtual_space.high_boundary()));\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -124,2 +124,1 @@\n-  const char* name() const { return \"tenured generation\"; }\n-  const char* short_name() const { return \"Tenured\"; }\n+  const char* name() const { return \"Tenured\"; }\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -41,0 +42,21 @@\n+\/\/ GCLockerTimingDebugLogger tracks specific timing information for GC lock waits.\n+class GCLockerTimingDebugLogger : public StackObj {\n+  const char* _log_message;\n+  Ticks _start;\n+\n+public:\n+  GCLockerTimingDebugLogger(const char* log_message) : _log_message(log_message) {\n+    assert(_log_message != nullptr, \"GC locker debug message must be set.\");\n+    _start = Ticks::now();\n+  }\n+\n+  ~GCLockerTimingDebugLogger() {\n+    Log(gc, jni) log;\n+    if (log.is_debug()) {\n+      ResourceMark rm; \/\/ JavaThread::name() allocates to convert to UTF8\n+      const Tickspan elapsed_time = Ticks::now() - _start;\n+      log.debug(\"%s Resumed after \" UINT64_FORMAT \"ms. Thread \\\"%s\\\".\", _log_message, elapsed_time.milliseconds(), Thread::current()->name());\n+    }\n+  }\n+};\n+\n@@ -113,5 +135,5 @@\n-  }\n-\n-  \/\/ Wait for _needs_gc  to be cleared\n-  while (needs_gc()) {\n-    ml.wait();\n+    GCLockerTimingDebugLogger logger(\"Thread stalled by JNI critical section.\");\n+    \/\/ Wait for _needs_gc to be cleared\n+    while (needs_gc()) {\n+      ml.wait();\n+    }\n@@ -130,10 +152,14 @@\n-  while (needs_gc()) {\n-    \/\/ There's at least one thread that has not left the critical region (CR)\n-    \/\/ completely. When that last thread (no new threads can enter CR due to the\n-    \/\/ blocking) exits CR, it calls `jni_unlock`, which sets `_needs_gc`\n-    \/\/ to false and wakes up all blocked threads.\n-    \/\/ We would like to assert #threads in CR to be > 0, `_jni_lock_count > 0`\n-    \/\/ in the code, but it's too strong; it's possible that the last thread\n-    \/\/ has called `jni_unlock`, but not yet finished the call, e.g. initiating\n-    \/\/ a GCCause::_gc_locker GC.\n-    ml.wait();\n+  if (needs_gc()) {\n+    log_debug_jni(\"Blocking thread as there is a pending GC request\");\n+    GCLockerTimingDebugLogger logger(\"Thread blocked to enter critical region.\");\n+    while (needs_gc()) {\n+      \/\/ There's at least one thread that has not left the critical region (CR)\n+      \/\/ completely. When that last thread (no new threads can enter CR due to the\n+      \/\/ blocking) exits CR, it calls `jni_unlock`, which sets `_needs_gc`\n+      \/\/ to false and wakes up all blocked threads.\n+      \/\/ We would like to assert #threads in CR to be > 0, `_jni_lock_count > 0`\n+      \/\/ in the code, but it's too strong; it's possible that the last thread\n+      \/\/ has called `jni_unlock`, but not yet finished the call, e.g. initiating\n+      \/\/ a GCCause::_gc_locker GC.\n+      ml.wait();\n+    }\n@@ -151,0 +177,1 @@\n+  log_debug_jni(\"Thread exiting critical region.\");\n@@ -164,1 +191,1 @@\n-      log_debug_jni(\"Performing GC after exiting critical section.\");\n+      log_debug_jni(\"Last thread exiting. Performing GC after exiting critical section.\");\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":43,"deletions":16,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  if (!heap->is_in(loc)) return;\n+  if (!heap->is_in_reserved(loc)) return;\n@@ -83,1 +83,1 @@\n-  if (heap->is_in(loc)) {\n+  if (heap->is_in_reserved(loc)) {\n@@ -102,1 +102,1 @@\n-  if (heap->is_in(loc)) {\n+  if (heap->is_in_reserved(loc)) {\n@@ -119,1 +119,1 @@\n-  bool loc_in_heap = (loc != nullptr && heap->is_in(loc));\n+  bool loc_in_heap = (loc != nullptr && heap->is_in_reserved(loc));\n@@ -172,1 +172,1 @@\n-void ShenandoahAsserts::assert_in_heap(void* interior_loc, oop obj, const char *file, int line) {\n+void ShenandoahAsserts::assert_in_heap_bounds(void* interior_loc, oop obj, const char *file, int line) {\n@@ -175,3 +175,3 @@\n-  if (!heap->is_in(obj)) {\n-    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap failed\",\n-                  \"oop must point to a heap address\",\n+  if (!heap->is_in_reserved(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_bounds failed\",\n+                  \"oop must be in heap bounds\",\n@@ -182,1 +182,1 @@\n-void ShenandoahAsserts::assert_in_heap_or_null(void* interior_loc, oop obj, const char *file, int line) {\n+void ShenandoahAsserts::assert_in_heap_bounds_or_null(void* interior_loc, oop obj, const char *file, int line) {\n@@ -185,3 +185,3 @@\n-  if (obj != nullptr && !heap->is_in(obj)) {\n-    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_or_null failed\",\n-                  \"oop must point to a heap address\",\n+  if (obj != nullptr && !heap->is_in_reserved(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_bounds_or_null failed\",\n+                  \"oop must be in heap bounds\",\n@@ -197,1 +197,1 @@\n-  if (!heap->is_in(obj)) {\n+  if (!heap->is_in_reserved(obj)) {\n@@ -199,1 +199,1 @@\n-                  \"oop must point to a heap address\",\n+                  \"oop must be in heap bounds\",\n@@ -216,0 +216,6 @@\n+  if (!heap->is_in(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                  \"Object should be in active region area\",\n+                  file, line);\n+  }\n+\n@@ -229,1 +235,1 @@\n-    if (!heap->is_in(fwd)) {\n+    if (!heap->is_in_reserved(fwd)) {\n@@ -231,1 +237,1 @@\n-                    \"Forwardee must point to a heap address\",\n+                    \"Forwardee must be in heap bounds\",\n@@ -242,0 +248,6 @@\n+    if (!heap->is_in(fwd)) {\n+      print_failure(_safe_oop, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                    \"Forwardee should be in active region area\",\n+                    file, line);\n+    }\n+\n@@ -244,1 +256,1 @@\n-                    \"Non-trivial forwardee should in another region\",\n+                    \"Non-trivial forwardee should be in another region\",\n@@ -260,1 +272,1 @@\n-  if (java_lang_Class::is_instance(obj)) {\n+  if (Universe::is_fully_initialized() && (obj_klass == vmClasses::Class_klass())) {\n@@ -289,1 +301,3 @@\n-  if (alloc_size > ShenandoahHeapRegion::humongous_threshold_words()) {\n+  HeapWord* obj_end = cast_from_oop<HeapWord*>(obj) + alloc_size;\n+\n+  if (ShenandoahHeapRegion::requires_humongous(alloc_size)) {\n@@ -291,2 +305,2 @@\n-    size_t num_regions = ShenandoahHeapRegion::required_regions(alloc_size * HeapWordSize);\n-    for (size_t i = idx; i < idx + num_regions; i++) {\n+    size_t end_idx = heap->heap_region_index_containing(obj_end - 1);\n+    for (size_t i = idx; i < end_idx; i++) {\n@@ -305,0 +319,6 @@\n+  } else {\n+    if (obj_end > r->top()) {\n+      print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_correct_region failed\",\n+                    \"Object end should be within the active area of the region\",\n+                    file, line);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":41,"deletions":21,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-  static void assert_in_heap(void* interior_loc, oop obj, const char* file, int line);\n-  static void assert_in_heap_or_null(void* interior_loc, oop obj, const char* file, int line);\n+  static void assert_in_heap_bounds(void* interior_loc, oop obj, const char* file, int line);\n+  static void assert_in_heap_bounds_or_null(void* interior_loc, oop obj, const char* file, int line);\n@@ -81,4 +81,4 @@\n-#define shenandoah_assert_in_heap(interior_loc, obj) \\\n-                    ShenandoahAsserts::assert_in_heap(interior_loc, obj, __FILE__, __LINE__)\n-#define shenandoah_assert_in_heap_or_null(interior_loc, obj) \\\n-                    ShenandoahAsserts::assert_in_heap_or_null(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_in_heap_bounds(interior_loc, obj) \\\n+                    ShenandoahAsserts::assert_in_heap_bounds(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_in_heap_bounds_or_null(interior_loc, obj) \\\n+                    ShenandoahAsserts::assert_in_heap_bounds_or_null(interior_loc, obj, __FILE__, __LINE__)\n@@ -186,2 +186,2 @@\n-#define shenandoah_assert_in_heap(interior_loc, obj)\n-#define shenandoah_assert_in_heap_or_null(interior_loc, obj)\n+#define shenandoah_assert_in_heap_bounds(interior_loc, obj)\n+#define shenandoah_assert_in_heap_bounds_or_null(interior_loc, obj)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  shenandoah_assert_in_heap_or_null(nullptr, p);\n+  shenandoah_assert_in_heap_bounds_or_null(nullptr, p);\n@@ -50,1 +50,1 @@\n-  assert(p == nullptr || _heap->is_in(p), \"Must be in the heap\");\n+  assert(p == nullptr || _heap->is_in_reserved(p), \"Must be in the heap\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -736,6 +736,0 @@\n-      \/\/ Verify before arming for concurrent processing.\n-      \/\/ Otherwise, verification can trigger stack processing.\n-      if (ShenandoahVerify) {\n-        heap->verifier()->verify_during_evacuation();\n-      }\n-\n@@ -866,4 +860,1 @@\n-        \/\/ Here we are asserting that an unmarked from-space object is 'correct'. There seems to be a legitimate\n-        \/\/ use-case for accessing from-space objects during concurrent class unloading. In all modes of Shenandoah,\n-        \/\/ concurrent class unloading only happens during a global collection.\n-        shenandoah_assert_correct(p, obj);\n+        \/\/ Note: The obj is dead here. Do not touch it, just clear.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  bool is_humongous = req.size() > ShenandoahHeapRegion::humongous_threshold_words();\n+  bool is_humongous = ShenandoahHeapRegion::requires_humongous(req.size());\n@@ -83,1 +83,1 @@\n-  bool is_humongous = (words > ShenandoahHeapRegion::region_size_words());\n+  bool is_humongous = ShenandoahHeapRegion::requires_humongous(words);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -363,5 +363,0 @@\n-\n-    if(ShenandoahVerify) {\n-      heap->verifier()->verify_during_evacuation();\n-    }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  shenandoah_assert_in_heap(nullptr, obj);\n+  shenandoah_assert_in_heap_bounds(nullptr, obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1987,1 +1987,1 @@\n-  if (req.size() > ShenandoahHeapRegion::humongous_threshold_words()) {\n+  if (ShenandoahHeapRegion::requires_humongous(req.size())) {\n@@ -1997,2 +1997,1 @@\n-        assert(false, \"Trying to allocate TLAB larger than the humongous threshold: \" SIZE_FORMAT \" > \" SIZE_FORMAT,\n-               req.size(), ShenandoahHeapRegion::humongous_threshold_words());\n+        assert(false, \"Trying to allocate TLAB in humongous region: \" SIZE_FORMAT, req.size());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-  \/\/ Precondition: req.size() <= ShenandoahHeapRegion::humongous_threshold_words().\n+  \/\/ Precondition: !ShenandoahHeapRegion::requires_humongous(req.size())\n@@ -320,1 +320,1 @@\n-  \/\/ Precondition: req.size() > ShenandoahHeapRegion::humongous_threshold_words().\n+  \/\/ Precondition: ShenandoahHeapRegion::requires_humongous(req.size())\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+#include \"cds\/archiveHeapWriter.hpp\"\n@@ -708,1 +709,1 @@\n-    if (wasted_bytes > 0 && req.actual_size() > ShenandoahHeapRegion::humongous_threshold_words()) {\n+    if (wasted_bytes > 0 && ShenandoahHeapRegion::requires_humongous(req.actual_size())) {\n@@ -782,0 +783,15 @@\n+bool ShenandoahHeap::is_in(const void* p) const {\n+  if (is_in_reserved(p)) {\n+    if (is_full_gc_move_in_progress()) {\n+      \/\/ Full GC move is running, we do not have a consistent region\n+      \/\/ information yet. But we know the pointer is in heap.\n+      return true;\n+    }\n+    \/\/ Now check if we point to a live section in active region.\n+    ShenandoahHeapRegion* r = heap_region_containing(p);\n+    return (r->is_active() && p < r->top());\n+  } else {\n+    return false;\n+  }\n+}\n+\n@@ -2671,0 +2687,77 @@\n+HeapWord* ShenandoahHeap::allocate_loaded_archive_space(size_t size) {\n+#if INCLUDE_CDS_JAVA_HEAP\n+  \/\/ CDS wants a continuous memory range to load a bunch of objects.\n+  \/\/ This effectively bypasses normal allocation paths, and requires\n+  \/\/ a bit of massaging to unbreak GC invariants.\n+\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);\n+\n+  \/\/ Easy case: a single regular region, no further adjustments needed.\n+  if (!ShenandoahHeapRegion::requires_humongous(size)) {\n+    return allocate_memory(req);\n+  }\n+\n+  \/\/ Hard case: the requested size would cause a humongous allocation.\n+  \/\/ We need to make sure it looks like regular allocation to the rest of GC.\n+\n+  \/\/ CDS code would guarantee no objects straddle multiple regions, as long as\n+  \/\/ regions are as large as MIN_GC_REGION_ALIGNMENT. It is impractical at this\n+  \/\/ point to deal with case when Shenandoah runs with smaller regions.\n+  \/\/ TODO: This check can be dropped once MIN_GC_REGION_ALIGNMENT agrees more with Shenandoah.\n+  if (ShenandoahHeapRegion::region_size_bytes() < ArchiveHeapWriter::MIN_GC_REGION_ALIGNMENT) {\n+    return nullptr;\n+  }\n+\n+  HeapWord* mem = allocate_memory(req);\n+  size_t start_idx = heap_region_index_containing(mem);\n+  size_t num_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);\n+\n+  \/\/ Flip humongous -> regular.\n+  {\n+    ShenandoahHeapLocker locker(lock(), false);\n+    for (size_t c = start_idx; c < start_idx + num_regions; c++) {\n+      get_region(c)->make_regular_bypass();\n+    }\n+  }\n+\n+  return mem;\n+#else\n+  assert(false, \"Archive heap loader should not be available, should not be here\");\n+  return nullptr;\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+}\n+\n+void ShenandoahHeap::complete_loaded_archive_space(MemRegion archive_space) {\n+  \/\/ Nothing to do here, except checking that heap looks fine.\n+#ifdef ASSERT\n+  HeapWord* start = archive_space.start();\n+  HeapWord* end = archive_space.end();\n+\n+  \/\/ No unclaimed space between the objects.\n+  \/\/ Objects are properly allocated in correct regions.\n+  HeapWord* cur = start;\n+  while (cur < end) {\n+    oop oop = cast_to_oop(cur);\n+    shenandoah_assert_in_correct_region(nullptr, oop);\n+    cur += oop->size();\n+  }\n+\n+  \/\/ No unclaimed tail at the end of archive space.\n+  assert(cur == end,\n+         \"Archive space should be fully used: \" PTR_FORMAT \" \" PTR_FORMAT,\n+         p2i(cur), p2i(end));\n+\n+  \/\/ Region bounds are good.\n+  ShenandoahHeapRegion* begin_reg = heap_region_containing(start);\n+  ShenandoahHeapRegion* end_reg = heap_region_containing(end);\n+  assert(begin_reg->is_regular(), \"Must be\");\n+  assert(end_reg->is_regular(), \"Must be\");\n+  assert(begin_reg->bottom() == start,\n+         \"Must agree: archive-space-start: \" PTR_FORMAT \", begin-region-bottom: \" PTR_FORMAT,\n+         p2i(start), p2i(begin_reg->bottom()));\n+  assert(end_reg->top() == end,\n+         \"Must agree: archive-space-end: \" PTR_FORMAT \", end-region-top: \" PTR_FORMAT,\n+         p2i(end), p2i(end_reg->top()));\n+#endif\n+}\n+\n@@ -2692,0 +2785,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":95,"deletions":1,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -601,1 +601,3 @@\n-  inline bool is_in(const void* p) const override;\n+  \/\/ Check the pointer is in active part of Java heap.\n+  \/\/ Use is_in_reserved to check if object is within heap bounds.\n+  bool is_in(const void* p) const override;\n@@ -657,0 +659,6 @@\n+\/\/ ---------- CDS archive support\n+\n+  bool can_load_archived_objects() const override { return UseCompressedOops && !ShenandoahCardBarrier; }\n+  HeapWord* allocate_loaded_archive_space(size_t size) override;\n+  void complete_loaded_archive_space(MemRegion archive_space) override;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -348,6 +348,0 @@\n-bool ShenandoahHeap::is_in(const void* p) const {\n-  HeapWord* heap_base = (HeapWord*) base();\n-  HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();\n-  return p >= heap_base && p < last_region_end;\n-}\n-\n@@ -357,1 +351,1 @@\n-    assert(is_in(obj), \"Otherwise shouldn't return true below\");\n+    assert(is_in_reserved(obj), \"Otherwise shouldn't return true below\");\n@@ -369,1 +363,1 @@\n-  assert(is_in(obj), \"only check if is in active generation for objects (\" PTR_FORMAT \") in heap\", p2i(obj));\n+  assert(is_in_reserved(obj), \"only check if is in active generation for objects (\" PTR_FORMAT \") in heap\", p2i(obj));\n@@ -395,1 +389,1 @@\n-  return is_in(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::YOUNG_GENERATION);\n+  return is_in_reserved(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::YOUNG_GENERATION);\n@@ -399,1 +393,1 @@\n-  return is_in(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::OLD_GENERATION);\n+  return is_in_reserved(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::OLD_GENERATION);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-\n@@ -63,2 +62,0 @@\n-size_t ShenandoahHeapRegion::HumongousThresholdBytes = 0;\n-size_t ShenandoahHeapRegion::HumongousThresholdWords = 0;\n@@ -147,2 +144,4 @@\n-  assert (ShenandoahHeap::heap()->is_full_gc_in_progress() || ShenandoahHeap::heap()->is_degenerated_gc_in_progress(),\n-          \"only for full or degen GC\");\n+  assert (!Universe::is_fully_initialized() ||\n+          ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+          ShenandoahHeap::heap()->is_degenerated_gc_in_progress(),\n+          \"Only for STW GC or when Universe is initializing (CDS)\");\n@@ -750,9 +749,0 @@\n-  guarantee(HumongousThresholdWords == 0, \"we should only set it once\");\n-  HumongousThresholdWords = RegionSizeWords * ShenandoahHumongousThreshold \/ 100;\n-  HumongousThresholdWords = align_down(HumongousThresholdWords, MinObjAlignment);\n-  assert (HumongousThresholdWords <= RegionSizeWords, \"sanity\");\n-\n-  guarantee(HumongousThresholdBytes == 0, \"we should only set it once\");\n-  HumongousThresholdBytes = HumongousThresholdWords * HeapWordSize;\n-  assert (HumongousThresholdBytes <= RegionSizeBytes, \"sanity\");\n-\n@@ -760,2 +750,1 @@\n-  MaxTLABSizeWords = MIN2(RegionSizeWords, HumongousThresholdWords);\n-  MaxTLABSizeWords = align_down(MaxTLABSizeWords, MinObjAlignment);\n+  MaxTLABSizeWords = align_down(RegionSizeWords, MinObjAlignment);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -231,2 +231,0 @@\n-  static size_t HumongousThresholdBytes;\n-  static size_t HumongousThresholdWords;\n@@ -282,0 +280,4 @@\n+  inline static bool requires_humongous(size_t words) {\n+    return words > ShenandoahHeapRegion::RegionSizeWords;\n+  }\n+\n@@ -334,8 +336,0 @@\n-  inline static size_t humongous_threshold_bytes() {\n-    return ShenandoahHeapRegion::HumongousThresholdBytes;\n-  }\n-\n-  inline static size_t humongous_threshold_words() {\n-    return ShenandoahHeapRegion::HumongousThresholdWords;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  log_info(gc, init)(\"Humongous Object Threshold: \" EXACTFMT, EXACTFMTARGS(ShenandoahHeapRegion::humongous_threshold_bytes()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahInitLogger.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  assert(ShenandoahHeap::heap()->is_in(addr),\n+  assert(ShenandoahHeap::heap()->is_in_reserved(addr),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,4 +64,5 @@\n-  \/\/ TODO: Do these really need to be const?\n-  inline bool is_marked(const oop) const;\n-  inline bool is_marked_strong(const oop obj) const;\n-  inline bool is_marked_weak(const oop obj) const;\n+  inline bool is_marked(oop obj) const;\n+  inline bool is_marked(HeapWord* raw_obj) const;\n+  inline bool is_marked_strong(oop obj) const;\n+  inline bool is_marked_strong(HeapWord* raw_obj) const;\n+  inline bool is_marked_weak(oop obj) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -42,1 +42,5 @@\n-  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked(cast_from_oop<HeapWord *>(obj));\n+  return is_marked(cast_from_oop<HeapWord*>(obj));\n+}\n+\n+inline bool ShenandoahMarkingContext::is_marked(HeapWord* raw_obj) const {\n+  return allocated_after_mark_start(raw_obj) || _mark_bit_map.is_marked(raw_obj);\n@@ -46,1 +50,5 @@\n-  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked_strong(cast_from_oop<HeapWord*>(obj));\n+  return is_marked_strong(cast_from_oop<HeapWord*>(obj));\n+}\n+\n+inline bool ShenandoahMarkingContext::is_marked_strong(HeapWord* raw_obj) const {\n+  return allocated_after_mark_start(raw_obj) || _mark_bit_map.is_marked_strong(raw_obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -112,0 +112,11 @@\n+inline oop reference_coop_decode_raw(narrowOop v) {\n+  return CompressedOops::is_null(v) ? nullptr : CompressedOops::decode_raw(v);\n+}\n+\n+inline oop reference_coop_decode_raw(oop v) {\n+  return v;\n+}\n+\n+\/\/ Raw referent, it can be dead. You cannot treat it as oop without additional safety\n+\/\/ checks, this is why it is HeapWord*. The decoding uses a special-case inlined\n+\/\/ CompressedOops::decode method that bypasses normal oop-ness checks.\n@@ -113,3 +124,3 @@\n-static oop reference_referent(oop reference) {\n-  T heap_oop = Atomic::load(reference_referent_addr<T>(reference));\n-  return CompressedOops::decode(heap_oop);\n+static HeapWord* reference_referent_raw(oop reference) {\n+  T raw_oop = Atomic::load(reference_referent_addr<T>(reference));\n+  return cast_from_oop<HeapWord*>(reference_coop_decode_raw(raw_oop));\n@@ -313,2 +324,2 @@\n-  const oop referent = reference_referent<T>(reference);\n-  if (referent == nullptr) {\n+  HeapWord* raw_referent = reference_referent_raw<T>(reference);\n+  if (raw_referent == nullptr) {\n@@ -324,1 +335,1 @@\n-    return ShenandoahHeap::heap()->complete_marking_context()->is_marked(referent);\n+    return ShenandoahHeap::heap()->complete_marking_context()->is_marked(raw_referent);\n@@ -326,1 +337,1 @@\n-    return ShenandoahHeap::heap()->complete_marking_context()->is_marked_strong(referent);\n+    return ShenandoahHeap::heap()->complete_marking_context()->is_marked_strong(raw_referent);\n@@ -338,1 +349,1 @@\n-    assert(ShenandoahHeap::heap()->marking_context()->is_marked(reference_referent<T>(reference)), \"only make inactive final refs with alive referents\");\n+    assert(ShenandoahHeap::heap()->marking_context()->is_marked(reference_referent_raw<T>(reference)), \"only make inactive final refs with alive referents\");\n@@ -425,0 +436,7 @@\n+  HeapWord* raw_referent = reference_referent_raw<T>(reference);\n+\n+#ifdef ASSERT\n+  assert(raw_referent == nullptr || ShenandoahHeap::heap()->marking_context()->is_marked(raw_referent),\n+         \"only drop references with alive referents\");\n+#endif\n+\n@@ -426,2 +444,0 @@\n-  oop referent = reference_referent<T>(reference);\n-  assert(referent == nullptr || heap->marking_context()->is_marked(referent), \"only drop references with alive referents\");\n@@ -436,1 +452,1 @@\n-  if (heap->mode()->is_generational() && heap->is_in_old(reference) && heap->is_in_young(referent)) {\n+  if (heap->mode()->is_generational() && heap->is_in_old(reference) && heap->is_in_young(raw_referent)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":27,"deletions":11,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -59,7 +59,0 @@\n-class ShenandoahIgnoreReferenceDiscoverer : public ReferenceDiscoverer {\n-public:\n-  virtual bool discover_reference(oop obj, ReferenceType type) {\n-    return true;\n-  }\n-};\n-\n@@ -76,0 +69,1 @@\n+  ReferenceIterationMode _ref_mode;\n@@ -93,1 +87,7 @@\n-      set_ref_discoverer_internal(new ShenandoahIgnoreReferenceDiscoverer());\n+      \/\/ Unknown status for Reference.referent field. Do not touch it, it might be dead.\n+      \/\/ Normally, barriers would prevent us from seeing the dead referents, but verifier\n+      \/\/ runs with barriers disabled.\n+      _ref_mode = DO_FIELDS_EXCEPT_REFERENT;\n+    } else {\n+      \/\/ Otherwise do all fields.\n+      _ref_mode = DO_FIELDS;\n@@ -103,0 +103,4 @@\n+  ReferenceIterationMode reference_iteration_mode() override {\n+    return _ref_mode;\n+  }\n+\n@@ -147,2 +151,2 @@\n-    check(ShenandoahAsserts::_safe_unknown, obj, _heap->is_in(obj),\n-              \"oop must be in heap\");\n+    check(ShenandoahAsserts::_safe_unknown, obj, _heap->is_in_reserved(obj),\n+              \"oop must be in heap bounds\");\n@@ -207,2 +211,2 @@\n-      check(ShenandoahAsserts::_safe_oop, obj, _heap->is_in(fwd),\n-             \"Forwardee must be in heap\");\n+      check(ShenandoahAsserts::_safe_oop, obj, _heap->is_in_reserved(fwd),\n+             \"Forwardee must be in heap bounds\");\n@@ -225,0 +229,3 @@\n+      check(ShenandoahAsserts::_safe_oop, obj, fwd_reg->is_active(),\n+            \"Forwardee should be in active region\");\n+\n@@ -245,1 +252,1 @@\n-    if (java_lang_Class::is_instance(obj)) {\n+    if (obj_klass == vmClasses::Class_klass()) {\n@@ -822,8 +829,0 @@\n-      case _verify_gcstate_evacuation:\n-        enabled = true;\n-        expected = ShenandoahHeap::EVACUATION;\n-        if (!_heap->is_stw_gc_in_progress()) {\n-          \/\/ Only concurrent GC sets this.\n-          expected |= ShenandoahHeap::WEAK_ROOTS;\n-        }\n-        break;\n@@ -1114,28 +1113,0 @@\n-void ShenandoahVerifier::verify_during_evacuation() {\n-  verify_at_safepoint(\n-          \"During Evacuation\",\n-          _verify_remembered_disable, \/\/ do not verify remembered set\n-          _verify_forwarded_allow,    \/\/ some forwarded references are allowed\n-          _verify_marked_disable,     \/\/ walk only roots\n-          _verify_cset_disable,       \/\/ some cset references are not forwarded yet\n-          _verify_liveness_disable,   \/\/ liveness data might be already stale after pre-evacs\n-          _verify_regions_disable,    \/\/ trash regions not yet recycled\n-          _verify_size_disable,       \/\/ we don't know how much of promote-in-place work has been completed\n-          _verify_gcstate_evacuation  \/\/ evacuation is in progress\n-  );\n-}\n-\n-void ShenandoahVerifier::verify_after_evacuation() {\n-  verify_at_safepoint(\n-          \"After Evacuation\",\n-          _verify_remembered_disable,  \/\/ do not verify remembered set\n-          _verify_forwarded_allow,     \/\/ objects are still forwarded\n-          _verify_marked_complete,     \/\/ bitmaps might be stale, but alloc-after-mark should be well\n-          _verify_cset_forwarded,      \/\/ all cset refs are fully forwarded\n-          _verify_liveness_disable,    \/\/ no reliable liveness data anymore\n-          _verify_regions_notrash,     \/\/ trash regions have been recycled already\n-          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n-          _verify_gcstate_forwarded    \/\/ evacuation produced some forwarded objects\n-  );\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":20,"deletions":49,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -173,3 +173,0 @@\n-    \/\/ Evacuation is in progress, some objects are forwarded\n-    _verify_gcstate_evacuation,\n-\n@@ -218,2 +215,0 @@\n-  void verify_during_evacuation();\n-  void verify_after_evacuation();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -133,7 +133,0 @@\n-  product(intx, ShenandoahHumongousThreshold, 100, EXPERIMENTAL,            \\\n-          \"Humongous objects are allocated in separate regions. \"           \\\n-          \"This setting defines how large the object should be to be \"      \\\n-          \"deemed humongous. Value is in  percents of heap region size. \"   \\\n-          \"This also caps the maximum TLAB size.\")                          \\\n-          range(1, 100)                                                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -233,2 +233,2 @@\n-static bool should_clear_soft_references(GCCause::Cause cause) {\n-  \/\/ Clear soft references if implied by the GC cause\n+static bool should_clear_all_soft_references(GCCause::Cause cause) {\n+  \/\/ Clear all soft references if implied by the GC cause\n@@ -262,1 +262,1 @@\n-  \/\/ Clear soft references if threads are stalled waiting for an old collection\n+  \/\/ Clear all soft references if threads are stalled waiting for an old collection\n@@ -267,1 +267,1 @@\n-  \/\/ Don't clear\n+  \/\/ Don't clear all soft references\n@@ -305,5 +305,9 @@\n-  \/\/ It is important that when soft references are cleared, we also pre-clean the young\n-  \/\/ generation, as we might otherwise throw premature OOM. Therefore, all causes that\n-  \/\/ trigger soft ref cleaning must also trigger pre-cleaning of young gen. If allocations\n-  \/\/ stalled when checking for soft ref cleaning, then since we hold the driver locker all\n-  \/\/ the way until we check for young gen pre-cleaning, we can be certain that we should\n+  \/\/ We clear all soft references as a last-ditch effort to collect memory\n+  \/\/ before throwing an OOM. Therefore it is important that when the GC policy\n+  \/\/ is to clear all soft references, that we also pre-clean the young\n+  \/\/ generation, as we might otherwise throw premature OOM.\n+  \/\/\n+  \/\/ Therefore, all causes that trigger all soft ref clearing must also trigger\n+  \/\/ pre-cleaning of young gen. If allocations stalled when checking for all\n+  \/\/ soft ref clearing, then since we hold the driver locker all the way until\n+  \/\/ we check for young gen pre-cleaning, we can be certain that we should\n@@ -311,1 +315,1 @@\n-  assert(!should_clear_soft_references(cause), \"Clearing soft references without pre-cleaning young gen\");\n+  assert(!should_clear_all_soft_references(cause), \"Clearing all soft references without pre-cleaning young gen\");\n@@ -398,0 +402,4 @@\n+\n+    \/\/ Set up soft reference policy\n+    const bool clear_all = should_clear_all_soft_references(request.cause());\n+    ZGeneration::old()->set_soft_reference_policy(clear_all);\n@@ -447,2 +455,3 @@\n-static void handle_alloc_stalling_for_old(bool cleared_soft_refs) {\n-  ZHeap::heap()->handle_alloc_stalling_for_old(cleared_soft_refs);\n+static void handle_alloc_stalling_for_old() {\n+  const bool cleared_all = ZGeneration::old()->uses_clear_all_soft_reference_policy();\n+  ZHeap::heap()->handle_alloc_stalling_for_old(cleared_all);\n@@ -451,2 +460,2 @@\n-void ZDriverMajor::handle_alloc_stalls(bool cleared_soft_refs) const {\n-  handle_alloc_stalling_for_old(cleared_soft_refs);\n+void ZDriverMajor::handle_alloc_stalls() const {\n+  handle_alloc_stalling_for_old();\n@@ -467,4 +476,0 @@\n-    \/\/ Set up soft reference policy\n-    const bool clear_soft_refs = should_clear_soft_references(request.cause());\n-    ZGeneration::old()->set_soft_reference_policy(clear_soft_refs);\n-\n@@ -480,1 +485,1 @@\n-    handle_alloc_stalls(clear_soft_refs);\n+    handle_alloc_stalls();\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":24,"deletions":19,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-  void handle_alloc_stalls(bool cleared_soft_refs) const;\n+  void handle_alloc_stalls() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1289,0 +1289,4 @@\n+bool ZGenerationOld::uses_clear_all_soft_reference_policy() const {\n+  return _reference_processor.uses_clear_all_soft_reference_policy();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -312,0 +312,1 @@\n+  bool uses_clear_all_soft_reference_policy() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-inline void ZHeap::handle_alloc_stalling_for_old(bool cleared_soft_refs) {\n-  _page_allocator.handle_alloc_stalling_for_old(cleared_soft_refs);\n+inline void ZHeap::handle_alloc_stalling_for_old(bool cleared_all_soft_refs) {\n+  _page_allocator.handle_alloc_stalling_for_old(cleared_all_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -988,1 +988,1 @@\n-void ZPageAllocator::handle_alloc_stalling_for_old(bool cleared_soft_refs) {\n+void ZPageAllocator::handle_alloc_stalling_for_old(bool cleared_all_soft_refs) {\n@@ -990,1 +990,1 @@\n-  if (cleared_soft_refs) {\n+  if (cleared_all_soft_refs) {\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-    _clear_all_soft_refs(false),\n+    _uses_clear_all_soft_reference_policy(false),\n@@ -124,1 +124,1 @@\n-void ZReferenceProcessor::set_soft_reference_policy(bool clear) {\n+void ZReferenceProcessor::set_soft_reference_policy(bool clear_all_soft_references) {\n@@ -128,1 +128,1 @@\n-  _clear_all_soft_refs = clear;\n+  _uses_clear_all_soft_reference_policy = clear_all_soft_references;\n@@ -130,1 +130,1 @@\n-  if (clear) {\n+  if (clear_all_soft_references) {\n@@ -139,0 +139,4 @@\n+bool ZReferenceProcessor::uses_clear_all_soft_reference_policy() const {\n+  return _uses_clear_all_soft_reference_policy;\n+}\n+\n@@ -443,1 +447,1 @@\n-  if (_clear_all_soft_refs) {\n+  if (_uses_clear_all_soft_reference_policy) {\n","filename":"src\/hotspot\/share\/gc\/z\/zReferenceProcessor.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  bool                 _clear_all_soft_refs;\n+  bool                 _uses_clear_all_soft_reference_policy;\n@@ -72,1 +72,3 @@\n-  void set_soft_reference_policy(bool clear);\n+  void set_soft_reference_policy(bool clear_all_soft_references);\n+  bool uses_clear_all_soft_reference_policy() const;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zReferenceProcessor.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -728,1 +728,0 @@\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Should call monitorenter_obj() when using the new lightweight locking\");\n@@ -743,17 +742,0 @@\n-\/\/ NOTE: We provide a separate implementation for the new lightweight locking to workaround a limitation\n-\/\/ of registers in x86_32. This entry point accepts an oop instead of a BasicObjectLock*.\n-\/\/ The problem is that we would need to preserve the register that holds the BasicObjectLock,\n-\/\/ but we are using that register to hold the thread. We don't have enough registers to\n-\/\/ also keep the BasicObjectLock, but we don't really need it anyway, we only need\n-\/\/ the object. See also InterpreterMacroAssembler::lock_object().\n-\/\/ As soon as legacy stack-locking goes away we could remove the other monitorenter() entry\n-\/\/ point, and only use oop-accepting entries (same for monitorexit() below).\n-JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter_obj(JavaThread* current, oopDesc* obj))\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"Should call monitorenter() when not using the new lightweight locking\");\n-  Handle h_obj(current, cast_to_oop(obj));\n-  assert(Universe::heap()->is_in_or_null(h_obj()),\n-         \"must be null or an object\");\n-  ObjectSynchronizer::enter(h_obj, nullptr, current);\n-  return;\n-JRT_END\n-\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -57,0 +58,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -64,0 +66,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -627,12 +630,16 @@\n-        \/\/ Traditional lightweight locking.\n-        markWord displaced = rcvr->mark().set_unlocked();\n-        mon->lock()->set_displaced_header(displaced);\n-        bool call_vm = (LockingMode == LM_MONITOR);\n-        bool inc_monitor_count = true;\n-        if (call_vm || rcvr->cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {\n-          \/\/ Is it simple recursive case?\n-          if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-            mon->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-          } else {\n-            inc_monitor_count = false;\n-            CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);\n+        bool success = false;\n+        if (LockingMode == LM_LEGACY) {\n+           \/\/ Traditional fast locking.\n+          markWord displaced = rcvr->mark().set_unlocked();\n+          mon->lock()->set_displaced_header(displaced);\n+          success = true;\n+          if (rcvr->cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {\n+            \/\/ Is it simple recursive case?\n+            if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+              mon->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+            } else {\n+              success = false;\n+            }\n+          }\n+          if (success) {\n+            THREAD->inc_held_monitor_count();\n@@ -641,2 +648,2 @@\n-        if (inc_monitor_count) {\n-          THREAD->inc_held_monitor_count();\n+        if (!success) {\n+            CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);\n@@ -644,0 +651,1 @@\n+\n@@ -726,12 +734,16 @@\n-      \/\/ traditional lightweight locking\n-      markWord displaced = lockee->mark().set_unlocked();\n-      entry->lock()->set_displaced_header(displaced);\n-      bool call_vm = (LockingMode == LM_MONITOR);\n-      bool inc_monitor_count = true;\n-      if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n-        \/\/ Is it simple recursive case?\n-        if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-          entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-        } else {\n-          inc_monitor_count = false;\n-          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n+      bool success = false;\n+      if (LockingMode == LM_LEGACY) {\n+        \/\/ Traditional fast locking.\n+        markWord displaced = lockee->mark().set_unlocked();\n+        entry->lock()->set_displaced_header(displaced);\n+        success = true;\n+        if (lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n+          \/\/ Is it simple recursive case?\n+          if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+            entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+          } else {\n+            success = false;\n+          }\n+        }\n+        if (success) {\n+          THREAD->inc_held_monitor_count();\n@@ -740,2 +752,2 @@\n-      if (inc_monitor_count) {\n-        THREAD->inc_held_monitor_count();\n+      if (!success) {\n+        CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n@@ -743,0 +755,1 @@\n+\n@@ -1656,12 +1669,16 @@\n-          \/\/ traditional lightweight locking\n-          markWord displaced = lockee->mark().set_unlocked();\n-          entry->lock()->set_displaced_header(displaced);\n-          bool call_vm = (LockingMode == LM_MONITOR);\n-          bool inc_monitor_count = true;\n-          if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n-            \/\/ Is it simple recursive case?\n-            if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-              entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-            } else {\n-              inc_monitor_count = false;\n-              CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n+          bool success = false;\n+          if (LockingMode == LM_LEGACY) {\n+            \/\/ Traditional fast locking.\n+            markWord displaced = lockee->mark().set_unlocked();\n+            entry->lock()->set_displaced_header(displaced);\n+            success = true;\n+            if (lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n+              \/\/ Is it simple recursive case?\n+              if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+                entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+              } else {\n+                success = false;\n+              }\n+            }\n+            if (success) {\n+              THREAD->inc_held_monitor_count();\n@@ -1670,2 +1687,2 @@\n-          if (inc_monitor_count) {\n-            THREAD->inc_held_monitor_count();\n+          if (!success) {\n+            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n@@ -1673,0 +1690,1 @@\n+\n@@ -1690,2 +1708,0 @@\n-            markWord header = lock->displaced_header();\n-            most_recent->set_obj(nullptr);\n@@ -1693,10 +1709,16 @@\n-            \/\/ If it isn't recursive we either must swap old header or call the runtime\n-            bool dec_monitor_count = true;\n-            bool call_vm = (LockingMode == LM_MONITOR);\n-            if (header.to_pointer() != nullptr || call_vm) {\n-              markWord old_header = markWord::encode(lock);\n-              if (call_vm || lockee->cas_set_mark(header, old_header) != old_header) {\n-                \/\/ restore object for the slow case\n-                most_recent->set_obj(lockee);\n-                dec_monitor_count = false;\n-                InterpreterRuntime::monitorexit(most_recent);\n+            bool success = false;\n+            if (LockingMode == LM_LEGACY) {\n+              \/\/ If it isn't recursive we either must swap old header or call the runtime\n+              most_recent->set_obj(nullptr);\n+              success = true;\n+              markWord header = lock->displaced_header();\n+              if (header.to_pointer() != nullptr) {\n+                markWord old_header = markWord::encode(lock);\n+                if (lockee->cas_set_mark(header, old_header) != old_header) {\n+                  \/\/ restore object for the slow case\n+                  most_recent->set_obj(lockee);\n+                  success = false;\n+                }\n+              }\n+              if (success) {\n+                THREAD->dec_held_monitor_count();\n@@ -1705,2 +1727,2 @@\n-            if (dec_monitor_count) {\n-              THREAD->dec_held_monitor_count();\n+            if (!success) {\n+              InterpreterRuntime::monitorexit(most_recent);\n@@ -3128,12 +3150,18 @@\n-          markWord header = lock->displaced_header();\n-          end->set_obj(nullptr);\n-\n-          \/\/ If it isn't recursive we either must swap old header or call the runtime\n-          bool dec_monitor_count = true;\n-          if (header.to_pointer() != nullptr) {\n-            markWord old_header = markWord::encode(lock);\n-            if (lockee->cas_set_mark(header, old_header) != old_header) {\n-              \/\/ restore object for the slow case\n-              end->set_obj(lockee);\n-              dec_monitor_count = false;\n-              InterpreterRuntime::monitorexit(end);\n+\n+          bool success = false;\n+          if (LockingMode == LM_LEGACY) {\n+            markWord header = lock->displaced_header();\n+            end->set_obj(nullptr);\n+\n+            \/\/ If it isn't recursive we either must swap old header or call the runtime\n+            success = true;\n+            if (header.to_pointer() != nullptr) {\n+              markWord old_header = markWord::encode(lock);\n+              if (lockee->cas_set_mark(header, old_header) != old_header) {\n+                \/\/ restore object for the slow case\n+                end->set_obj(lockee);\n+                success = false;\n+              }\n+            }\n+            if (success) {\n+              THREAD->dec_held_monitor_count();\n@@ -3142,2 +3170,2 @@\n-          if (dec_monitor_count) {\n-            THREAD->dec_held_monitor_count();\n+          if (!success) {\n+            InterpreterRuntime::monitorexit(end);\n@@ -3191,1 +3219,1 @@\n-          } else if (LockingMode == LM_MONITOR) {\n+          } else if (LockingMode != LM_LEGACY) {\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":99,"deletions":71,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-jboolean JNICALL jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size);\n+void JNICALL jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,0 +194,4 @@\n+  if (!initialize(THREAD)) {\n+    log_error(jfr, system)(\"JfrUpcall could not be initialized.\");\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -396,2 +396,1 @@\n-template <typename Instance, void(Instance::*func)()>\n-class JfrVMOperation : public VM_Operation {\n+class JfrSafepointClearVMOperation : public VM_Operation {\n@@ -399,1 +398,10 @@\n-  Instance& _instance;\n+  JfrRecorderService& _instance;\n+ public:\n+  JfrSafepointClearVMOperation(JfrRecorderService& instance) : _instance(instance) {}\n+  void doit() { _instance.safepoint_clear(); }\n+  VMOp_Type type() const { return VMOp_JFRSafepointClear; }\n+};\n+\n+class JfrSafepointWriteVMOperation : public VM_Operation {\n+ private:\n+  JfrRecorderService& _instance;\n@@ -401,3 +409,3 @@\n-  JfrVMOperation(Instance& instance) : _instance(instance) {}\n-  void doit() { (_instance.*func)(); }\n-  VMOp_Type type() const { return VMOp_JFRCheckpoint; }\n+  JfrSafepointWriteVMOperation(JfrRecorderService& instance) : _instance(instance) {}\n+  void doit() { _instance.safepoint_write(); }\n+  VMOp_Type type() const { return VMOp_JFRSafepointWrite; }\n@@ -473,1 +481,1 @@\n-  JfrVMOperation<JfrRecorderService, &JfrRecorderService::safepoint_clear> safepoint_task(*this);\n+  JfrSafepointClearVMOperation op(*this);\n@@ -475,1 +483,1 @@\n-  VMThread::execute(&safepoint_task);\n+  VMThread::execute(&op);\n@@ -580,1 +588,1 @@\n-  JfrVMOperation<JfrRecorderService, &JfrRecorderService::safepoint_write> safepoint_task(*this);\n+  JfrSafepointWriteVMOperation op(*this);\n@@ -583,1 +591,1 @@\n-  VMThread::execute(&safepoint_task);\n+  VMThread::execute(&op);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+  friend class JfrSafepointClearVMOperation;\n+  friend class JfrSafepointWriteVMOperation;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -29,2 +29,1 @@\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/klass.hpp\"\n@@ -203,1 +202,1 @@\n-  return mark((uintptr_t)sym->identity_hash(), sym, leakp);\n+  return mark(sym->identity_hash(), sym, leakp);\n@@ -239,35 +238,8 @@\n-* hidden classes symbol is the external name +\n-* the address of its InstanceKlass slash appended:\n-*   java.lang.invoke.LambdaForm$BMH\/22626602\n-*\n-* caller needs ResourceMark\n-*\/\n-\n-uintptr_t JfrSymbolTable::hidden_klass_name_hash(const InstanceKlass* ik) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != nullptr, \"invariant\");\n-  return (uintptr_t)mirror->identity_hash();\n-}\n-\n-static const char* create_hidden_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  assert(hash != 0, \"invariant\");\n-  char* hidden_symbol = nullptr;\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != nullptr, \"invariant\");\n-  char hash_buf[40];\n-  os::snprintf_checked(hash_buf, sizeof(hash_buf), \"\/\" UINTX_FORMAT, hash);\n-  const size_t hash_len = strlen(hash_buf);\n-  const size_t result_len = ik->name()->utf8_length();\n-  hidden_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);\n-  ik->name()->as_klass_external_name(hidden_symbol, (int)result_len + 1);\n-  assert(strlen(hidden_symbol) == result_len, \"invariant\");\n-  strcpy(hidden_symbol + result_len, hash_buf);\n-  assert(strlen(hidden_symbol) == result_len + hash_len, \"invariant\");\n-  return hidden_symbol;\n-}\n-\n-bool JfrSymbolTable::is_hidden_klass(const Klass* k) {\n+ * The hidden class symbol is the external name with the\n+ * address of its Klass slash appended.\n+ *\n+ * \"java.lang.invoke.LambdaForm$DMH\/0x0000000037144c00\"\n+ *\n+ * Caller needs ResourceMark.\n+ *\/\n+traceid JfrSymbolTable::mark_hidden_klass_name(const Klass* k, bool leakp) {\n@@ -275,9 +247,3 @@\n-  return k->is_instance_klass() && ((const InstanceKlass*)k)->is_hidden();\n-}\n-\n-traceid JfrSymbolTable::mark_hidden_klass_name(const InstanceKlass* ik, bool leakp) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const uintptr_t hash = hidden_klass_name_hash(ik);\n-  const char* const hidden_symbol = create_hidden_klass_symbol(ik, hash);\n-  return mark(hash, hidden_symbol, leakp);\n+  assert(k->is_hidden(), \"invariant\");\n+  const uintptr_t hash = k->name()->identity_hash();\n+  return mark(hash, k->external_name(), leakp);\n@@ -289,3 +255,2 @@\n-  if (is_hidden_klass(k)) {\n-    assert(k->is_instance_klass(), \"invariant\");\n-    symbol_id = mark_hidden_klass_name((const InstanceKlass*)k, leakp);\n+  if (k->is_hidden()) {\n+    symbol_id = mark_hidden_klass_name(k, leakp);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.cpp","additions":17,"deletions":52,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,1 @@\n+  traceid mark_hidden_klass_name(const Klass* k, bool leakp);\n@@ -109,4 +110,0 @@\n-  traceid mark_hidden_klass_name(const InstanceKlass* k, bool leakp);\n-  bool is_hidden_klass(const Klass* k);\n-  uintptr_t hidden_klass_name_hash(const InstanceKlass* ik);\n-\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -52,0 +53,1 @@\n+static int pin_offset = invalid_offset;\n@@ -101,0 +103,7 @@\n+\n+  const char pin_name[] = \"pinVirtualThread\";\n+  Symbol* const pin_sym = SymbolTable::new_symbol(valid_name);\n+  assert(pin_sym != nullptr, \"invariant\");\n+  assert(invalid_offset == pin_offset, \"invariant\");\n+  JfrJavaSupport::compute_field_offset(pin_offset, klass, pin_sym, vmSymbols::bool_signature());\n+  assert(pin_offset != invalid_offset, \"invariant\");\n@@ -222,0 +231,5 @@\n+static inline bool pin_virtual(const JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  return JfrThreadLocal::is_vthread(jt) && VMContinuations;\n+}\n+\n@@ -228,1 +242,1 @@\n-  static const char signature[] = \"(JJJZZ)V\";\n+  static const char signature[] = \"(JJJZZZ)V\";\n@@ -237,0 +251,1 @@\n+  args.push_int(pin_virtual(THREAD) ? (jint)JNI_TRUE : (jint)JNI_FALSE);\n@@ -252,0 +267,1 @@\n+      writer->long_field_put(thread_id_offset, current_tid);\n@@ -254,1 +270,3 @@\n-      writer->long_field_put(thread_id_offset, current_tid);\n+      if (!excluded) {\n+        writer->bool_field_put(pin_offset, pin_virtual(jt));\n+      }\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -713,2 +713,4 @@\n-    if (!THREAD->has_last_Java_frame()) {\n-        JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"Cannot call getJObjectValue without Java frame anchor\"));\n+    \/\/ Ensure that current JNI handle scope is not the top-most JNIHandleBlock as handles\n+    \/\/ in that scope are only released when the thread exits.\n+    if (!THREAD->has_last_Java_frame() && THREAD->active_handles()->pop_frame_link() == nullptr) {\n+        JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"Cannot call getJObjectValue without Java frame anchor or a pushed JNI handle block\"));\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+    static address SharedRuntime_throw_delayed_StackOverflowError_entry;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+address CompilerToVM::Data::SharedRuntime_throw_delayed_StackOverflowError_entry;\n@@ -161,0 +162,1 @@\n+  SharedRuntime_throw_delayed_StackOverflowError_entry = SharedRuntime::throw_delayed_StackOverflowError_entry();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -71,0 +72,2 @@\n+  static_field(CompilerToVM::Data,             SharedRuntime_throw_delayed_StackOverflowError_entry,                                 \\\n+                                                                                       address)                                      \\\n@@ -154,1 +157,1 @@\n-  volatile_nonstatic_field(BasicLock,          _displaced_header,                      markWord)                                     \\\n+  volatile_nonstatic_field(BasicLock,          _metadata,                              uintptr_t)                                    \\\n@@ -244,0 +247,2 @@\n+  nonstatic_field(JavaThread,                  _om_cache,                                     OMCache)                               \\\n+  nonstatic_field(JavaThread,                  _cont_entry,                                   ContinuationEntry*)                    \\\n@@ -248,0 +253,1 @@\n+  nonstatic_field(ContinuationEntry,           _pin_count,                                    uint32_t)                              \\\n@@ -330,2 +336,0 @@\n-  static_field(StubRoutines,                _throw_delayed_StackOverflowError_entry,          address)                               \\\n-                                                                                                                                     \\\n@@ -534,0 +538,2 @@\n+  declare_constant_with_value(\"OMCache::oop_to_oop_difference\", OMCache::oop_to_oop_difference()) \\\n+  declare_constant_with_value(\"OMCache::oop_to_monitor_difference\", OMCache::oop_to_monitor_difference()) \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+  LOG_TAG(monitortable) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size, bool is_class) {\n+void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size) {\n@@ -135,1 +135,2 @@\n-  if (Metaspace::using_class_space() && is_class) {\n+  const bool is_class = Metaspace::using_class_space() && Metaspace::is_in_class_space(ptr);\n+  if (is_class) {\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-  void deallocate(MetaWord* ptr, size_t word_size, bool is_class);\n+  void deallocate(MetaWord* ptr, size_t word_size);\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-      loader_data->metaspace_non_null()->deallocate((MetaWord*)data, size, false);\n+      loader_data->metaspace_non_null()->deallocate((MetaWord*)data, size);\n@@ -71,1 +71,0 @@\n-      bool is_klass = md->is_klass();\n@@ -79,1 +78,1 @@\n-      loader_data->metaspace_non_null()->deallocate((MetaWord*)md, size, is_klass);\n+      loader_data->metaspace_non_null()->deallocate((MetaWord*)md, size);\n","filename":"src\/hotspot\/share\/memory\/metadataFactory.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -541,0 +541,2 @@\n+const void* Metaspace::_class_space_start = nullptr;\n+const void* Metaspace::_class_space_end = nullptr;\n@@ -573,0 +575,2 @@\n+  _class_space_start = rs.base();\n+  _class_space_end = rs.end();\n@@ -896,9 +900,11 @@\n-  Log(gc, metaspace, freelist, oom) log;\n-  if (log.is_info()) {\n-    log.info(\"Metaspace (%s) allocation failed for size \" SIZE_FORMAT,\n-             is_class_space_allocation(mdtype) ? \"class\" : \"data\", word_size);\n-    ResourceMark rm;\n-    if (log.is_debug()) {\n-      if (loader_data->metaspace_or_null() != nullptr) {\n-        LogStream ls(log.debug());\n-        loader_data->print_value_on(&ls);\n+  {\n+    LogMessage(gc, metaspace, freelist, oom) log;\n+    if (log.is_info()) {\n+      log.info(\"Metaspace (%s) allocation failed for size \" SIZE_FORMAT,\n+               is_class_space_allocation(mdtype) ? \"class\" : \"data\", word_size);\n+      ResourceMark rm;\n+      if (log.is_debug()) {\n+        if (loader_data->metaspace_or_null() != nullptr) {\n+          NonInterleavingLogStream ls(LogLevelType::Debug, log);\n+          loader_data->print_value_on(&ls);\n+        }\n@@ -906,0 +912,3 @@\n+      NonInterleavingLogStream ls(LogLevelType::Info, log);\n+      \/\/ In case of an OOM, log out a short but still useful report.\n+      MetaspaceUtils::print_basic_report(&ls, 0);\n@@ -907,3 +916,0 @@\n-    LogStream ls(log.info());\n-    \/\/ In case of an OOM, log out a short but still useful report.\n-    MetaspaceUtils::print_basic_report(&ls, 0);\n@@ -980,6 +986,0 @@\n-bool Metaspace::contains(const void* ptr) {\n-  if (MetaspaceShared::is_in_shared_metaspace(ptr)) {\n-    return true;\n-  }\n-  return contains_non_shared(ptr);\n-}\n@@ -987,4 +987,5 @@\n-bool Metaspace::contains_non_shared(const void* ptr) {\n-  if (using_class_space() && VirtualSpaceList::vslist_class()->contains((MetaWord*)ptr)) {\n-     return true;\n-  }\n+\/\/ Returns true if pointer points into one of the metaspace regions, or\n+\/\/ into the class space.\n+bool Metaspace::is_in_shared_metaspace(const void* ptr) {\n+  return MetaspaceShared::is_in_shared_metaspace(ptr);\n+}\n@@ -992,0 +993,2 @@\n+\/\/ Returns true if pointer points into one of the non-class-space metaspace regions.\n+bool Metaspace::is_in_nonclass_metaspace(const void* ptr) {\n@@ -994,0 +997,1 @@\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":26,"deletions":22,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,4 @@\n+  \/\/ For quick pointer testing: extent of class space; nullptr if no class space.\n+  static const void* _class_space_start;\n+  static const void* _class_space_end;\n+\n@@ -116,2 +120,26 @@\n-  static bool contains(const void* ptr);\n-  static bool contains_non_shared(const void* ptr);\n+  \/\/ Returns true if the pointer points into class space, non-class metaspace, or the\n+  \/\/ metadata portion of the CDS archive.\n+  static bool contains(const void* ptr) {\n+    return is_in_shared_metaspace(ptr) || \/\/ in cds\n+           is_in_class_space(ptr) ||      \/\/ in class space\n+           is_in_nonclass_metaspace(ptr); \/\/ in one of the non-class regions?\n+  }\n+\n+  \/\/ Returns true if the pointer points into class space or into non-class metaspace\n+  static bool contains_non_shared(const void* ptr) {\n+    return is_in_class_space(ptr) ||      \/\/ in class space\n+           is_in_nonclass_metaspace(ptr); \/\/ in one of the non-class regions?\n+  }\n+\n+  \/\/ Returns true if pointer points into the CDS klass region.\n+  static bool is_in_shared_metaspace(const void* ptr);\n+\n+  \/\/ Returns true if pointer points into one of the non-class-space metaspace regions.\n+  static bool is_in_nonclass_metaspace(const void* ptr);\n+\n+  \/\/ Returns true if pointer points into class space, false if it doesn't or if\n+  \/\/ there is no class space. Class space is a contiguous region, which is why\n+  \/\/ two address comparisons are enough.\n+  static inline bool is_in_class_space(const void* ptr) {\n+    return ptr < _class_space_end && ptr >= _class_space_start;\n+  }\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -439,3 +439,0 @@\n-        assert(!fellThrough, \"should not happen\");\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n-        break;\n@@ -444,1 +441,4 @@\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n+        \/\/ If this is the last bytecode, there is no successor to mark\n+        if (bci + Bytecodes::length_for(bytecode) < method()->code_size()) {\n+          bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n+        }\n@@ -505,1 +505,4 @@\n-            reachable_basicblock(this, bci + Bytecodes::length_for(bytecode), &change);\n+            \/\/ If this is the last bytecode, there is no successor to mark\n+            if (bci + Bytecodes::length_for(bytecode) < method()->code_size()) {\n+              reachable_basicblock(this, bci + Bytecodes::length_for(bytecode), &change);\n+            }\n@@ -589,3 +592,0 @@\n-\n-\n-\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -228,4 +228,0 @@\n-  \/\/ _is_marked_dependent can be set concurrently, thus cannot be part of the\n-  \/\/ _misc_flags.\n-  bool            _is_marked_dependent;     \/\/ used for marking during flushing and deoptimization\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-    f.print_value_on(_st, nullptr);\n+    f.print_value_on(_st);\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -70,1 +71,1 @@\n-    if (print_monitor_info) {\n+    if (print_monitor_info && !UseObjectMonitorTable) {\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-\/\/    [ptr             | 10]  monitor            inflated lock (header is swapped out)\n+\/\/    [ptr             | 10]  monitor            inflated lock (header is swapped out, UseObjectMonitorTable == false)\n+\/\/    [header          | 10]  monitor            inflated lock (UseObjectMonitorTable == true)\n@@ -200,0 +201,1 @@\n+    assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use markWord for monitors\");\n@@ -205,2 +207,5 @@\n-    return LockingMode == LM_LIGHTWEIGHT  ? lockbits == monitor_value   \/\/ monitor?\n-                                          : (lockbits & unlocked_value) == 0; \/\/ monitor | stack-locked?\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      return !UseObjectMonitorTable && lockbits == monitor_value;\n+    }\n+    \/\/ monitor (0b10) | stack-locked (0b00)?\n+    return (lockbits & unlocked_value) == 0;\n@@ -226,0 +231,1 @@\n+    assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use markWord for monitors\");\n@@ -230,0 +236,4 @@\n+  markWord set_has_monitor() const {\n+    return markWord((value() & ~lock_mask_in_place) | monitor_value);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  Label _slow_path;\n@@ -114,0 +115,1 @@\n+  Label& slow_path() { return _slow_path; }\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -734,0 +734,2 @@\n+  case vmIntrinsics::_Continuation_pin:\n+  case vmIntrinsics::_Continuation_unpin:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -485,0 +485,3 @@\n+  case vmIntrinsics::_Continuation_pin:          return inline_native_Continuation_pinning(false);\n+  case vmIntrinsics::_Continuation_unpin:        return inline_native_Continuation_pinning(true);\n+\n@@ -3170,1 +3173,1 @@\n-                                              StubRoutines::jfr_return_lease(),\n+                                              SharedRuntime::jfr_return_lease(),\n@@ -3233,0 +3236,1 @@\n+ * bool pinVirtualThread;\n@@ -3237,0 +3241,1 @@\n+ *   pinVirtualThread = VMContinuations;\n@@ -3248,0 +3253,1 @@\n+ *   pinVirtualThread = false;\n@@ -3253,1 +3259,1 @@\n- *   setField(event_writer, \"threadID\", tid);\n+ *   setField(event_writer, \"pinVirtualThread\", pinVirtualThread);\n@@ -3255,0 +3261,1 @@\n+ *   setField(event_writer, \"threadID\", tid);\n@@ -3325,0 +3332,4 @@\n+  \/\/ Continuation support determines if a virtual thread should be pinned.\n+  Node* global_addr = makecon(TypeRawPtr::make((address)&VMContinuations));\n+  Node* continuation_support = make_load(control(), global_addr, TypeInt::BOOL, T_BOOLEAN, MemNode::unordered);\n+\n@@ -3369,1 +3380,1 @@\n-                                                  StubRoutines::jfr_write_checkpoint(),\n+                                                  SharedRuntime::jfr_write_checkpoint(),\n@@ -3415,0 +3426,2 @@\n+  PhiNode* pinVirtualThread = new PhiNode(vthread_compare_rgn, TypeInt::BOOL);\n+  record_for_igvn(pinVirtualThread);\n@@ -3427,0 +3440,2 @@\n+  pinVirtualThread->init_req(_true_path, _gvn.transform(continuation_support));\n+  pinVirtualThread->init_req(_false_path, _gvn.intcon(0));\n@@ -3450,0 +3465,3 @@\n+  \/\/ Get the field offset to, conditionally, store an updated pinVirtualThread value later.\n+  Node* const event_writer_pin_field = field_address_from_object(event_writer, \"pinVirtualThread\", \"Z\", false);\n+  const TypePtr* event_writer_pin_field_type = _gvn.type(event_writer_pin_field)->isa_ptr();\n@@ -3470,0 +3488,3 @@\n+  \/\/ Store the pin state to the event writer.\n+  store_to_memory(tid_is_not_equal, event_writer_pin_field, _gvn.transform(pinVirtualThread), T_BOOLEAN, event_writer_pin_field_type, MemNode::unordered);\n+\n@@ -3718,0 +3739,87 @@\n+\/\/------------------------inline_native_Continuation_pin and unpin-----------\n+\n+\/\/ Shared implementation routine for both pin and unpin.\n+bool LibraryCallKit::inline_native_Continuation_pinning(bool unpin) {\n+  enum { _true_path = 1, _false_path = 2, PATH_LIMIT };\n+\n+  \/\/ Save input memory.\n+  Node* input_memory_state = reset_memory();\n+  set_all_memory(input_memory_state);\n+\n+  \/\/ TLS\n+  Node* tls_ptr = _gvn.transform(new ThreadLocalNode());\n+  Node* last_continuation_offset = basic_plus_adr(top(), tls_ptr, in_bytes(JavaThread::cont_entry_offset()));\n+  Node* last_continuation = make_load(control(), last_continuation_offset, last_continuation_offset->get_ptr_type(), T_ADDRESS, MemNode::unordered);\n+\n+  \/\/ Null check the last continuation object.\n+  Node* continuation_cmp_null = _gvn.transform(new CmpPNode(last_continuation, null()));\n+  Node* test_continuation_not_equal_null = _gvn.transform(new BoolNode(continuation_cmp_null, BoolTest::ne));\n+  IfNode* iff_continuation_not_equal_null = create_and_map_if(control(), test_continuation_not_equal_null, PROB_MAX, COUNT_UNKNOWN);\n+\n+  \/\/ False path, last continuation is null.\n+  Node* continuation_is_null = _gvn.transform(new IfFalseNode(iff_continuation_not_equal_null));\n+\n+  \/\/ True path, last continuation is not null.\n+  Node* continuation_is_not_null = _gvn.transform(new IfTrueNode(iff_continuation_not_equal_null));\n+\n+  set_control(continuation_is_not_null);\n+\n+  \/\/ Load the pin count from the last continuation.\n+  Node* pin_count_offset = basic_plus_adr(top(), last_continuation, in_bytes(ContinuationEntry::pin_count_offset()));\n+  Node* pin_count = make_load(control(), pin_count_offset, TypeInt::INT, T_INT, MemNode::unordered);\n+\n+  \/\/ The loaded pin count is compared against a context specific rhs for over\/underflow detection.\n+  Node* pin_count_rhs;\n+  if (unpin) {\n+    pin_count_rhs = _gvn.intcon(0);\n+  } else {\n+    pin_count_rhs = _gvn.intcon(UINT32_MAX);\n+  }\n+  Node* pin_count_cmp = _gvn.transform(new CmpUNode(_gvn.transform(pin_count), pin_count_rhs));\n+  Node* test_pin_count_over_underflow = _gvn.transform(new BoolNode(pin_count_cmp, BoolTest::eq));\n+  IfNode* iff_pin_count_over_underflow = create_and_map_if(control(), test_pin_count_over_underflow, PROB_MIN, COUNT_UNKNOWN);\n+\n+  \/\/ False branch, no pin count over\/underflow. Increment or decrement pin count and store back.\n+  Node* valid_pin_count = _gvn.transform(new IfFalseNode(iff_pin_count_over_underflow));\n+  set_control(valid_pin_count);\n+\n+  Node* next_pin_count;\n+  if (unpin) {\n+    next_pin_count = _gvn.transform(new SubINode(pin_count, _gvn.intcon(1)));\n+  } else {\n+    next_pin_count = _gvn.transform(new AddINode(pin_count, _gvn.intcon(1)));\n+  }\n+\n+  Node* updated_pin_count_memory = store_to_memory(control(), pin_count_offset, next_pin_count, T_INT, Compile::AliasIdxRaw, MemNode::unordered);\n+\n+  \/\/ True branch, pin count over\/underflow.\n+  Node* pin_count_over_underflow = _gvn.transform(new IfTrueNode(iff_pin_count_over_underflow));\n+  {\n+    \/\/ Trap (but not deoptimize (Action_none)) and continue in the interpreter\n+    \/\/ which will throw IllegalStateException for pin count over\/underflow.\n+    PreserveJVMState pjvms(this);\n+    set_control(pin_count_over_underflow);\n+    set_all_memory(input_memory_state);\n+    uncommon_trap_exact(Deoptimization::Reason_intrinsic,\n+                        Deoptimization::Action_none);\n+    assert(stopped(), \"invariant\");\n+  }\n+\n+  \/\/ Result of top level CFG and Memory.\n+  RegionNode* result_rgn = new RegionNode(PATH_LIMIT);\n+  record_for_igvn(result_rgn);\n+  PhiNode* result_mem = new PhiNode(result_rgn, Type::MEMORY, TypePtr::BOTTOM);\n+  record_for_igvn(result_mem);\n+\n+  result_rgn->init_req(_true_path, _gvn.transform(valid_pin_count));\n+  result_rgn->init_req(_false_path, _gvn.transform(continuation_is_null));\n+  result_mem->init_req(_true_path, _gvn.transform(updated_pin_count_memory));\n+  result_mem->init_req(_false_path, _gvn.transform(input_memory_state));\n+\n+  \/\/ Set output state.\n+  set_control(_gvn.transform(result_rgn));\n+  set_all_memory(_gvn.transform(result_mem));\n+\n+  return true;\n+}\n+\n@@ -4607,7 +4715,8 @@\n-  \/\/ Test the header to see if it is safe to read w.r.t. locking.\n-  Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n-  Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n-    Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n-    Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n+  if (!UseObjectMonitorTable) {\n+    \/\/ Test the header to see if it is safe to read w.r.t. locking.\n+    Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n+    Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n+      Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n+      Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n@@ -4615,5 +4724,5 @@\n-    generate_slow_guard(test_monitor, slow_region);\n-  } else {\n-    Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n-    Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n-    Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n+      generate_slow_guard(test_monitor, slow_region);\n+    } else {\n+      Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n+      Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n+      Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n@@ -4621,1 +4730,2 @@\n-    generate_slow_guard(test_not_unlocked, slow_region);\n+      generate_slow_guard(test_not_unlocked, slow_region);\n+    }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":126,"deletions":16,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -244,0 +244,1 @@\n+  bool inline_native_Continuation_pinning(bool unpin);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1581,1 +1581,1 @@\n-  static bool is_divisor_counted_loop_phi(const Node* divisor, const Node* loop);\n+  static bool is_divisor_loop_phi(const Node* divisor, const Node* loop);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-  return is_divisor_counted_loop_phi(divisor, region) &&\n+  return is_divisor_loop_phi(divisor, region) &&\n@@ -302,2 +302,2 @@\n-bool PhaseIdealLoop::is_divisor_counted_loop_phi(const Node* divisor, const Node* loop) {\n-  return loop->is_BaseCountedLoop() && divisor->is_Phi() && divisor->in(0) == loop;\n+bool PhaseIdealLoop::is_divisor_loop_phi(const Node* divisor, const Node* loop) {\n+  return loop->is_Loop() && divisor->is_Phi() && divisor->in(0) == loop;\n@@ -1072,1 +1072,1 @@\n-            assert(get_loop(lca)->_nest < n_loop->_nest || lca->in(0)->is_NeverBranch(), \"must not be moved into inner loop\");\n+            assert(get_loop(lca)->_nest < n_loop->_nest || get_loop(lca)->_head->as_Loop()->is_in_infinite_subgraph(), \"must not be moved into inner loop\");\n@@ -1275,3 +1275,1 @@\n-    if (loop->is_member(get_loop(dom)) ||\n-        \/\/ NeverBranch nodes are not assigned to the loop when constructed\n-        (dom->is_NeverBranch() && loop->is_member(get_loop(dom->in(0))))) {\n+    if (loop->is_member(get_loop(dom))) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -430,3 +431,9 @@\n-bool MemNode::all_controls_dominate(Node* dom, Node* sub) {\n-  if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top())\n-    return false; \/\/ Conservative answer for dead code\n+\/\/ Returns 'DomResult::Dominate' if all control inputs of 'dom'\n+\/\/ dominate 'sub', 'DomResult::NotDominate' if not,\n+\/\/ and 'DomResult::EncounteredDeadCode' if we can't decide due to\n+\/\/ dead code, but at the end of IGVN, we know the definite result\n+\/\/ once the dead code is cleaned up.\n+Node::DomResult MemNode::maybe_all_controls_dominate(Node* dom, Node* sub) {\n+  if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top()) {\n+    return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+  }\n@@ -436,2 +443,3 @@\n-  if (dom == nullptr || dom->is_top())\n-    return false; \/\/ Conservative answer for dead code\n+  if (dom == nullptr || dom->is_top()) {\n+    return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+  }\n@@ -442,1 +450,1 @@\n-    return false;\n+    return DomResult::NotDominate;\n@@ -445,2 +453,3 @@\n-  if (dom->is_Con() || dom->is_Start() || dom->is_Root() || dom == sub)\n-    return true;\n+  if (dom->is_Con() || dom->is_Start() || dom->is_Root() || dom == sub) {\n+    return DomResult::Dominate;\n+  }\n@@ -460,2 +469,3 @@\n-  if (sub == nullptr || sub->is_top())\n-    return false; \/\/ Conservative answer for dead code\n+  if (sub == nullptr || sub->is_top()) {\n+    return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+  }\n@@ -465,2 +475,3 @@\n-  if (sub == dom)\n-    return true;\n+  if (sub == dom) {\n+    return DomResult::Dominate;\n+  }\n@@ -468,2 +479,3 @@\n-  if (sub->is_Start() || sub->is_Root())\n-    return false;\n+  if (sub->is_Start() || sub->is_Root()) {\n+    return DomResult::NotDominate;\n+  }\n@@ -483,2 +495,3 @@\n-      if (n == orig_sub)\n-        return false; \/\/ One of dom's inputs dominated by sub.\n+      if (n == orig_sub) {\n+        return DomResult::NotDominate; \/\/ One of dom's inputs dominated by sub.\n+      }\n@@ -488,2 +501,3 @@\n-        if (n == nullptr || n->is_top())\n-          return false; \/\/ Conservative answer for dead code\n+        if (n == nullptr || n->is_top()) {\n+          return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+        }\n@@ -495,1 +509,2 @@\n-        if (n->dominates(sub, nlist))\n+        DomResult dom_result = n->dominates(sub, nlist);\n+        if (dom_result == DomResult::Dominate) {\n@@ -497,2 +512,3 @@\n-        else\n-          return false;\n+        } else {\n+          return dom_result;\n+        }\n@@ -503,2 +519,3 @@\n-          if (m->is_top())\n-            return false; \/\/ Conservative answer for dead code\n+          if (m->is_top()) {\n+            return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+          }\n@@ -511,1 +528,1 @@\n-          if (m == nullptr || m->is_top())\n+          if (m == nullptr || m->is_top()) {\n@@ -513,0 +530,1 @@\n+          }\n@@ -517,1 +535,1 @@\n-    return only_dominating_controls;\n+    return only_dominating_controls ? DomResult::Dominate : DomResult::NotDominate;\n@@ -729,1 +747,1 @@\n-      if (st_alloc == nullptr)\n+      if (st_alloc == nullptr) {\n@@ -731,0 +749,1 @@\n+      }\n@@ -733,1 +752,1 @@\n-      if (alloc == st_alloc)\n+      if (alloc == st_alloc) {\n@@ -735,1 +754,1 @@\n-      else if (alloc != nullptr)\n+      } else if (alloc != nullptr) {\n@@ -737,1 +756,1 @@\n-      else if (all_controls_dominate(this, st_alloc))\n+      } else if (all_controls_dominate(this, st_alloc)) {\n@@ -739,0 +758,1 @@\n+      }\n@@ -1569,1 +1589,1 @@\n-    if (!MemNode::all_controls_dominate(mem, base->in(0)))\n+    if (!MemNode::all_controls_dominate(mem, base->in(0))) {\n@@ -1571,0 +1591,1 @@\n+    }\n@@ -1661,0 +1682,1 @@\n+  DomResult dom_result = DomResult::Dominate;\n@@ -1665,2 +1687,2 @@\n-    if (!MemNode::all_controls_dominate(address, region))\n-      return nullptr;\n+    \/\/ We will check `dom_result` later.\n+    dom_result = MemNode::maybe_all_controls_dominate(address, region);\n@@ -1671,2 +1693,2 @@\n-    if (!MemNode::all_controls_dominate(mem, region))\n-      return nullptr;\n+    \/\/ We will check `dom_result` later.\n+    dom_result = MemNode::maybe_all_controls_dominate(mem, region);\n@@ -1675,1 +1697,2 @@\n-    if (MemNode::all_controls_dominate(mem, base->in(0))) {\n+    dom_result = MemNode::maybe_all_controls_dominate(mem, base->in(0));\n+    if (dom_result == DomResult::Dominate) {\n@@ -1677,2 +1700,0 @@\n-    } else if (MemNode::all_controls_dominate(address, mem->in(0))) {\n-      region = mem->in(0);\n@@ -1680,1 +1701,5 @@\n-      return nullptr; \/\/ complex graph\n+      dom_result = MemNode::maybe_all_controls_dominate(address, mem->in(0));\n+      if (dom_result == DomResult::Dominate) {\n+        region = mem->in(0);\n+      }\n+      \/\/ Otherwise we encountered a complex graph.\n@@ -1687,0 +1712,11 @@\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+  if (dom_result != DomResult::Dominate) {\n+    if (dom_result == DomResult::EncounteredDeadCode) {\n+      \/\/ There is some dead code which eventually will be removed in IGVN.\n+      \/\/ Once this is the case, we get an unambiguous dominance result.\n+      \/\/ Push the node to the worklist again until the dead code is removed.\n+      igvn->_worklist.push(this);\n+    }\n+    return nullptr;\n+  }\n+\n@@ -1689,1 +1725,0 @@\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n@@ -4574,1 +4609,1 @@\n-      if (!MemNode::all_controls_dominate(n, this))\n+      if (!MemNode::all_controls_dominate(n, this)) {\n@@ -4576,0 +4611,1 @@\n+      }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":76,"deletions":40,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -108,2 +109,6 @@\n-  \/\/ This one should probably be a phase-specific function:\n-  static bool all_controls_dominate(Node* dom, Node* sub);\n+  \/\/ The following two should probably be phase-specific functions:\n+  static DomResult maybe_all_controls_dominate(Node* dom, Node* sub);\n+  static bool all_controls_dominate(Node* dom, Node* sub) {\n+    DomResult dom_result = maybe_all_controls_dominate(dom, sub);\n+    return dom_result == DomResult::Dominate;\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -1252,1 +1253,1 @@\n-bool Node::dominates(Node* sub, Node_List &nlist) {\n+Node::DomResult Node::dominates(Node* sub, Node_List &nlist) {\n@@ -1272,1 +1273,4 @@\n-    if (sub->is_top())  break; \/\/ Conservative answer for dead code.\n+    if (sub->is_top()) {\n+      \/\/ Conservative answer for dead code.\n+      return DomResult::EncounteredDeadCode;\n+    }\n@@ -1277,1 +1281,1 @@\n-        return true;\n+        return DomResult::Dominate;\n@@ -1291,1 +1295,1 @@\n-      return met_dom;\n+      return met_dom ? DomResult::Dominate : DomResult::NotDominate;\n@@ -1322,1 +1326,1 @@\n-            return false;\n+            return DomResult::NotDominate;\n@@ -1365,2 +1369,1 @@\n-  \/\/ Conservative answer for dead code.\n-  return false;\n+  return DomResult::NotDominate;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -1110,0 +1111,6 @@\n+  \/\/ Results of the dominance analysis.\n+  enum class DomResult {\n+    NotDominate,         \/\/ 'this' node does not dominate 'sub'.\n+    Dominate,            \/\/ 'this' node dominates or is equal to 'sub'.\n+    EncounteredDeadCode  \/\/ Result is undefined due to encountering dead code.\n+  };\n@@ -1111,1 +1118,1 @@\n-  bool dominates(Node* sub, Node_List &nlist);\n+  DomResult dominates(Node* sub, Node_List &nlist);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-  Node*         _alloc_with_final;   \/\/ An allocation node with final field\n+  Node*         _alloc_with_final_or_stable; \/\/ An allocation node with final or @Stable field\n@@ -406,4 +406,4 @@\n-  Node*    alloc_with_final() const   { return _alloc_with_final; }\n-  void set_alloc_with_final(Node* n)  {\n-    assert((_alloc_with_final == nullptr) || (_alloc_with_final == n), \"different init objects?\");\n-    _alloc_with_final = n;\n+  Node*    alloc_with_final_or_stable() const   { return _alloc_with_final_or_stable; }\n+  void set_alloc_with_final_or_stable(Node* n)  {\n+    assert((_alloc_with_final_or_stable == nullptr) || (_alloc_with_final_or_stable == n), \"different init objects?\");\n+    _alloc_with_final_or_stable = n;\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -415,1 +415,1 @@\n-  _alloc_with_final = nullptr;\n+  _alloc_with_final_or_stable = nullptr;\n@@ -991,2 +991,2 @@\n-  \/\/ 1. The constructor wrote a final. The effects of all initializations\n-  \/\/    must be committed to memory before any code after the constructor\n+  \/\/ 1. The constructor wrote a final or a @Stable field. All these\n+  \/\/    initializations must be ordered before any code after the constructor\n@@ -1017,1 +1017,1 @@\n-       (wrote_final() ||\n+       (wrote_final() || wrote_stable() ||\n@@ -1020,0 +1020,1 @@\n+    Node* recorded_alloc = alloc_with_final_or_stable();\n@@ -1021,1 +1022,1 @@\n-                          alloc_with_final());\n+                          recorded_alloc);\n@@ -1026,2 +1027,2 @@\n-    if (DoEscapeAnalysis && alloc_with_final()) {\n-      AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_with_final());\n+    if (DoEscapeAnalysis && (recorded_alloc != nullptr)) {\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(recorded_alloc);\n@@ -1032,13 +1033,1 @@\n-      tty->print_cr(\" writes finals and needs a memory barrier\");\n-    }\n-  }\n-\n-  \/\/ Any method can write a @Stable field; insert memory barriers\n-  \/\/ after those also. Can't bind predecessor allocation node (if any)\n-  \/\/ with barrier because allocation doesn't always dominate\n-  \/\/ MemBarRelease.\n-  if (wrote_stable()) {\n-    _exits.insert_mem_bar(Op_MemBarRelease);\n-    if (PrintOpto && (Verbose || WizardMode)) {\n-      method()->print_name();\n-      tty->print_cr(\" writes @Stable and needs a memory barrier\");\n+      tty->print_cr(\" writes finals\/@Stable and needs a memory barrier\");\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -239,1 +239,4 @@\n-    \/\/ Note the presence of writes to final non-static fields, so that we\n+    \/\/ If the field is @Stable, we can be in any method, but we only care about\n+    \/\/ constructors at this point.\n+    \/\/\n+    \/\/ Note the presence of writes to final\/@Stable non-static fields, so that we\n@@ -242,3 +245,7 @@\n-    \/\/ Any method can write a @Stable field; insert memory barriers after those also.\n-    if (field->is_final()) {\n-      set_wrote_final(true);\n+    if (field->is_final() || field->is_stable()) {\n+      if (field->is_final()) {\n+        set_wrote_final(true);\n+      }\n+      if (field->is_stable()) {\n+        set_wrote_stable(true);\n+      }\n@@ -248,2 +255,1 @@\n-        \/\/ Can't bind stable with its allocation, only record allocation for final field.\n-        set_alloc_with_final(obj);\n+        set_alloc_with_final_or_stable(obj);\n@@ -252,3 +258,0 @@\n-    if (field->is_stable()) {\n-      set_wrote_stable(true);\n-    }\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1626,17 +1626,0 @@\n-  \/\/ Change ((x & m) u<= m) or ((m & x) u<= m) to always true\n-  \/\/ Same with ((x & m) u< m+1) and ((m & x) u< m+1)\n-  if (cop == Op_CmpU &&\n-      cmp1_op == Op_AndI) {\n-    Node* bound = nullptr;\n-    if (_test._test == BoolTest::le) {\n-      bound = cmp2;\n-    } else if (_test._test == BoolTest::lt &&\n-               cmp2->Opcode() == Op_AddI &&\n-               cmp2->in(2)->find_int_con(0) == 1) {\n-      bound = cmp2->in(1);\n-    }\n-    if (cmp1->in(2) == bound || cmp1->in(1) == bound) {\n-      return ConINode::make(1);\n-    }\n-  }\n-\n@@ -1644,1 +1627,1 @@\n-  \/\/ This is the off-by-one variant of the above\n+  \/\/ This is the off-by-one variant of ((x & m) u<= m)\n@@ -1830,0 +1813,25 @@\n+\/\/ Change ((x & m) u<= m) or ((m & x) u<= m) to always true\n+\/\/ Same with ((x & m) u< m+1) and ((m & x) u< m+1)\n+const Type* BoolNode::Value_cmpu_and_mask(PhaseValues* phase) const {\n+  Node* cmp = in(1);\n+  if (cmp != nullptr && cmp->Opcode() == Op_CmpU) {\n+    Node* cmp1 = cmp->in(1);\n+    Node* cmp2 = cmp->in(2);\n+\n+    if (cmp1->Opcode() == Op_AndI) {\n+      Node* bound = nullptr;\n+      if (_test._test == BoolTest::le) {\n+        bound = cmp2;\n+      } else if (_test._test == BoolTest::lt && cmp2->Opcode() == Op_AddI && cmp2->in(2)->find_int_con(0) == 1) {\n+        bound = cmp2->in(1);\n+      }\n+\n+      if (cmp1->in(2) == bound || cmp1->in(1) == bound) {\n+        return TypeInt::ONE;\n+      }\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n@@ -1833,0 +1841,5 @@\n+  const Type* t = Value_cmpu_and_mask(phase);\n+  if (t != nullptr) {\n+    return t;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":32,"deletions":19,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -350,0 +350,1 @@\n+  const Type* Value_cmpu_and_mask(PhaseValues* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1159,1 +1159,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1212,1 +1212,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1263,1 +1263,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1356,1 +1356,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1409,1 +1409,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1461,1 +1461,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1557,1 +1557,1 @@\n-  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \\\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1612,2 +1612,2 @@\n-  k->initialize(CHECK_0); \\\n-  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \\\n+  k->initialize(CHECK_(ResultType{})); \\\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1666,1 +1666,1 @@\n-  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \\\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_(ResultType{})); \\\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3406,1 +3406,1 @@\n-      THROW_HANDLE_0(h_exception);\n+      THROW_HANDLE_NULL(h_exception);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -1468,1 +1469,0 @@\n-  ObjectMonitor *mon = nullptr;\n@@ -1498,3 +1498,5 @@\n-  if (mark.has_monitor()) {\n-    mon = mark.monitor();\n-    assert(mon != nullptr, \"must have monitor\");\n+  ObjectMonitor* mon = mark.has_monitor()\n+      ? ObjectSynchronizer::read_monitor(current_thread, hobj(), mark)\n+      : nullptr;\n+\n+  if (mon != nullptr) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -276,1 +276,9 @@\n-  Handle name_arg = java_lang_String::create_from_str(jni_name, CHECK_NULL);\n+  Handle jni_class(THREAD, method->method_holder()->java_mirror());\n+  Handle jni_name_arg = java_lang_String::create_from_str(jni_name, CHECK_NULL);\n+  Handle java_name_arg = java_lang_String::create_from_str(method->name()->as_C_string(), CHECK_NULL);\n+\n+  JavaCallArguments args;\n+  args.push_oop(loader);\n+  args.push_oop(jni_class);\n+  args.push_oop(jni_name_arg);\n+  args.push_oop(java_name_arg);\n@@ -282,4 +290,2 @@\n-                         vmSymbols::classloader_string_long_signature(),\n-                         \/\/ Arguments\n-                         loader,\n-                         name_arg,\n+                         vmSymbols::classloader_class_string_string_long_signature(),\n+                         &args,\n@@ -412,0 +418,8 @@\n+  if (THREAD->has_pending_exception()) {\n+    oop exception = THREAD->pending_exception();\n+    if (exception->is_a(vmClasses::IllegalCallerException_klass())) {\n+      \/\/ we already have a pending exception from the restricted method check, just return\n+      return nullptr;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2586,1 +2586,1 @@\n-      current_frame->print_value_on(&st, nullptr);\n+      current_frame->print_value_on(&st);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -308,0 +308,2 @@\n+#define ILLEGAL_NATIVE_ACCESS \"illegal.native.access\"\n+#define ILLEGAL_NATIVE_ACCESS_LEN 21\n@@ -329,0 +331,1 @@\n+        matches_property_suffix(property_suffix, ILLEGAL_NATIVE_ACCESS, ILLEGAL_NATIVE_ACCESS_LEN) ||\n@@ -506,0 +509,3 @@\n+#ifdef LINUX\n+  { \"UseLinuxPosixThreadCPUClocks\", JDK_Version::jdk(24), JDK_Version::jdk(25), JDK_Version::jdk(26) },\n+#endif\n@@ -1819,0 +1825,4 @@\n+  if (UseObjectMonitorTable) {\n+    FLAG_SET_CMDLINE(UseObjectMonitorTable, false);\n+    warning(\"UseObjectMonitorTable not supported on this platform\");\n+  }\n@@ -1821,0 +1831,6 @@\n+  if (UseObjectMonitorTable && LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ ObjectMonitorTable requires lightweight locking.\n+    FLAG_SET_CMDLINE(UseObjectMonitorTable, false);\n+    warning(\"UseObjectMonitorTable requires LM_LIGHTWEIGHT\");\n+  }\n+\n@@ -2236,0 +2252,4 @@\n+    } else if (match_option(option, \"--illegal-native-access=\", &tail)) {\n+      if (!create_module_property(\"jdk.module.illegal.native.access\", tail, InternalProperty)) {\n+        return JNI_ENOMEM;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-#include \"runtime\/basicLock.hpp\"\n+#include \"runtime\/basicLock.inline.hpp\"\n+#include \"runtime\/objectMonitor.hpp\"\n@@ -32,5 +33,12 @@\n-  markWord mark_word = displaced_header();\n-  if (mark_word.value() != 0) {\n-    \/\/ Print monitor info if there's an owning oop and it refers to this BasicLock.\n-    bool print_monitor_info = (owner != nullptr) && (owner->mark() == markWord::from_pointer((void*)this));\n-    mark_word.print_on(st, print_monitor_info);\n+  if (UseObjectMonitorTable) {\n+    ObjectMonitor* mon = object_monitor_cache();\n+    if (mon != nullptr) {\n+      mon->print_on(st);\n+    }\n+  } else if (LockingMode == LM_LEGACY) {\n+    markWord mark_word = displaced_header();\n+    if (mark_word.value() != 0) {\n+      \/\/ Print monitor info if there's an owning oop and it refers to this BasicLock.\n+      bool print_monitor_info = (owner != nullptr) && (owner->mark() == markWord::from_pointer((void*)this));\n+      mark_word.print_on(st, print_monitor_info);\n+    }\n@@ -85,0 +93,5 @@\n+  } else if (UseObjectMonitorTable) {\n+    \/\/ Preserve the ObjectMonitor*, the cache is cleared when a box is reused\n+    \/\/ and only read while the lock is held, so no stale ObjectMonitor* is\n+    \/\/ encountered.\n+    dest->set_object_monitor_cache(object_monitor_cache());\n@@ -88,1 +101,1 @@\n-    dest->set_displaced_header(markWord(badDispHeaderDeopt));\n+    dest->set_bad_metadata_deopt();\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -37,0 +38,3 @@\n+  \/\/ * For LM_MONITOR\n+  \/\/ Unused.\n+  \/\/ * For LM_LEGACY\n@@ -39,1 +43,9 @@\n-  volatile markWord _displaced_header;\n+  \/\/ * For LM_LIGHTWEIGHT\n+  \/\/ Used as a cache of the ObjectMonitor* used when locking. Must either\n+  \/\/ be nullptr or the ObjectMonitor* used when locking.\n+  volatile uintptr_t _metadata;\n+\n+  uintptr_t get_metadata() const { return Atomic::load(&_metadata); }\n+  void set_metadata(uintptr_t value) { Atomic::store(&_metadata, value); }\n+  static int metadata_offset_in_bytes() { return (int)offset_of(BasicLock, _metadata); }\n+\n@@ -41,3 +53,2 @@\n-  markWord displaced_header() const {\n-    return Atomic::load(&_displaced_header);\n-  }\n+  \/\/ LM_MONITOR\n+  void set_bad_metadata_deopt() { set_metadata(badDispHeaderDeopt); }\n@@ -45,3 +56,10 @@\n-  void set_displaced_header(markWord header) {\n-    Atomic::store(&_displaced_header, header);\n-  }\n+  \/\/ LM_LEGACY\n+  inline markWord displaced_header() const;\n+  inline void set_displaced_header(markWord header);\n+  static int displaced_header_offset_in_bytes() { return metadata_offset_in_bytes(); }\n+\n+  \/\/ LM_LIGHTWEIGHT\n+  inline ObjectMonitor* object_monitor_cache() const;\n+  inline void clear_object_monitor_cache();\n+  inline void set_object_monitor_cache(ObjectMonitor* mon);\n+  static int object_monitor_cache_offset_in_bytes() { return metadata_offset_in_bytes(); }\n@@ -53,2 +71,0 @@\n-\n-  static int displaced_header_offset_in_bytes() { return (int)offset_of(BasicLock, _displaced_header); }\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_BASICLOCK_INLINE_HPP\n+#define SHARE_RUNTIME_BASICLOCK_INLINE_HPP\n+\n+#include \"runtime\/basicLock.hpp\"\n+\n+inline markWord BasicLock::displaced_header() const {\n+  assert(LockingMode == LM_LEGACY, \"must be\");\n+  return markWord(get_metadata());\n+}\n+\n+inline void BasicLock::set_displaced_header(markWord header) {\n+  assert(LockingMode == LM_LEGACY, \"must be\");\n+  Atomic::store(&_metadata, header.value());\n+}\n+\n+inline ObjectMonitor* BasicLock::object_monitor_cache() const {\n+  assert(UseObjectMonitorTable, \"must be\");\n+#if defined(X86) || defined(AARCH64) || defined(RISCV64)\n+  return reinterpret_cast<ObjectMonitor*>(get_metadata());\n+#else\n+  \/\/ Other platforms do not make use of the cache yet,\n+  \/\/ and are not as careful with maintaining the invariant\n+  \/\/ that the metadata either is nullptr or ObjectMonitor*.\n+  return nullptr;\n+#endif\n+}\n+\n+inline void BasicLock::clear_object_monitor_cache() {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  set_metadata(0);\n+}\n+\n+inline void BasicLock::set_object_monitor_cache(ObjectMonitor* mon) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  set_metadata(reinterpret_cast<uintptr_t>(mon));\n+}\n+\n+#endif \/\/ SHARE_RUNTIME_BASICLOCK_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+  friend class JVMCIVMStructs;\n@@ -81,1 +82,1 @@\n-  uint _pin_count;\n+  uint32_t _pin_count;\n@@ -111,1 +112,1 @@\n-    if (_pin_count == UINT_MAX) return false;\n+    if (_pin_count == UINT32_MAX) return false;\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -880,1 +880,1 @@\n-    f.print_value_on(&ls, nullptr);\n+    f.print_value_on(&ls);\n@@ -889,1 +889,1 @@\n-    DEBUG_ONLY(hf.print_value_on(&ls, nullptr);)\n+    DEBUG_ONLY(hf.print_value_on(&ls);)\n@@ -2030,1 +2030,1 @@\n-    heap_frame.print_value_on(&ls, nullptr);\n+    heap_frame.print_value_on(&ls);\n@@ -2127,1 +2127,1 @@\n-    hf.print_value_on(&ls, nullptr);\n+    hf.print_value_on(&ls);\n@@ -2397,1 +2397,1 @@\n-    _cont.last_frame().print_value_on(&ls, nullptr);\n+    _cont.last_frame().print_value_on(&ls);\n@@ -2409,1 +2409,1 @@\n-    f.print_value_on(&ls, nullptr);\n+    f.print_value_on(&ls);\n@@ -2470,1 +2470,1 @@\n-    frame(sp).print_value_on(&ls, nullptr);\n+    frame(sp).print_value_on(&ls);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -78,0 +79,2 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/lockStack.inline.hpp\"\n@@ -87,1 +90,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -1637,1 +1640,11 @@\n-              mon_info->lock()->set_displaced_header(markWord::unused_mark());\n+              if (LockingMode == LM_LEGACY) {\n+                mon_info->lock()->set_displaced_header(markWord::unused_mark());\n+              } else if (UseObjectMonitorTable) {\n+                mon_info->lock()->clear_object_monitor_cache();\n+              }\n+#ifdef ASSERT\n+              else {\n+                assert(LockingMode == LM_MONITOR || !UseObjectMonitorTable, \"must be\");\n+                mon_info->lock()->set_bad_metadata_deopt();\n+              }\n+#endif\n@@ -1643,0 +1656,1 @@\n+        BasicLock* lock = mon_info->lock();\n@@ -1645,3 +1659,7 @@\n-          \/\/ Inflate the locks instead. Enter then inflate to avoid races with\n-          \/\/ deflation.\n-          ObjectSynchronizer::enter_for(obj, nullptr, deoptee_thread);\n+          \/\/ Entering may create an invalid lock stack. Inflate the lock if it\n+          \/\/ was fast_locked to restore the valid lock stack.\n+          ObjectSynchronizer::enter_for(obj, lock, deoptee_thread);\n+          if (deoptee_thread->lock_stack().contains(obj())) {\n+            LightweightSynchronizer::inflate_fast_locked_object(obj(), ObjectSynchronizer::InflateCause::inflate_cause_vm_internal,\n+                                                                deoptee_thread, thread);\n+          }\n@@ -1649,2 +1667,3 @@\n-          ObjectMonitor* mon = ObjectSynchronizer::inflate_for(deoptee_thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n-          assert(mon->owner() == deoptee_thread, \"must be\");\n+          assert(obj->mark().has_monitor(), \"must be\");\n+          assert(!deoptee_thread->lock_stack().contains(obj()), \"must be\");\n+          assert(ObjectSynchronizer::read_monitor(thread, obj(), obj->mark())->owner() == deoptee_thread, \"must be\");\n@@ -1652,1 +1671,0 @@\n-          BasicLock* lock = mon_info->lock();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -514,1 +514,1 @@\n-void frame::print_value_on(outputStream* st, JavaThread *thread) const {\n+void frame::print_value_on(outputStream* st) const {\n@@ -553,1 +553,1 @@\n-  print_value_on(st,nullptr);\n+  print_value_on(st);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -436,2 +436,2 @@\n-  void print_value() const { print_value_on(tty,nullptr); }\n-  void print_value_on(outputStream* st, JavaThread *thread) const;\n+  void print_value() const { print_value_on(tty); }\n+  void print_value_on(outputStream* st) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1959,0 +1959,11 @@\n+  product(bool, UseObjectMonitorTable, false, DIAGNOSTIC,                   \\\n+          \"With Lightweight Locking mode, use a table to record inflated \"  \\\n+          \"monitors rather than the first word of the object.\")             \\\n+                                                                            \\\n+  product(int, LightweightFastLockingSpins, 13, DIAGNOSTIC,                 \\\n+          \"Specifies the number of times lightweight fast locking will \"    \\\n+          \"attempt to CAS the markWord before inflating. Between each \"     \\\n+          \"CAS it will spin for exponentially more time, resulting in \"     \\\n+          \"a total number of spins on the order of O(2^value)\")             \\\n+          range(1, 30)                                                      \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+  \/\/ stub routines in initial blob are referenced by later generated code\n@@ -130,0 +131,2 @@\n+  \/\/ stack overflow exception blob is referenced by the interpreter\n+  SharedRuntime::generate_initial_stubs();\n@@ -147,0 +150,3 @@\n+#if INCLUDE_JFR\n+  SharedRuntime::generate_jfr_stubs();\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,8 +360,0 @@\n-  \/\/ Since the call stub sets up like the interpreter we call the from_interpreted_entry\n-  \/\/ so we can go compiled via a i2c. Otherwise initial entry method will always\n-  \/\/ run interpreted.\n-  address entry_point = method->from_interpreted_entry();\n-  if (JvmtiExport::can_post_interpreter_events() && thread->is_interp_only_mode()) {\n-    entry_point = method->interpreter_entry();\n-  }\n-\n@@ -401,0 +393,12 @@\n+\n+      address entry_point;\n+      {\n+        \/\/ The enter_interp_only_mode use handshake to set interp_only mode\n+        \/\/ so no safepoint should be allowed between is_interp_only_mode() and call\n+        NoSafepointVerifier nsv;\n+        if (JvmtiExport::can_post_interpreter_events() && thread->is_interp_only_mode()) {\n+          entry_point = method->interpreter_entry();\n+        } else {\n+          \/\/ Since the call stub sets up like the interpreter we call the from_interpreted_entry\n+          \/\/ so we can go compiled via a i2c.\n+          entry_point = method->from_interpreted_entry();\n@@ -402,10 +406,13 @@\n-      \/\/ Gets the alternative target (if any) that should be called\n-      Handle alternative_target = args->alternative_target();\n-      if (!alternative_target.is_null()) {\n-        \/\/ Must extract verified entry point from HotSpotNmethod after VM to Java\n-        \/\/ transition in JavaCallWrapper constructor so that it is safe with\n-        \/\/ respect to nmethod sweeping.\n-        address verified_entry_point = (address) HotSpotJVMCI::InstalledCode::entryPoint(nullptr, alternative_target());\n-        if (verified_entry_point != nullptr) {\n-          thread->set_jvmci_alternate_call_target(verified_entry_point);\n-          entry_point = method->adapter()->get_i2c_entry();\n+          \/\/ Gets the alternative target (if any) that should be called\n+          Handle alternative_target = args->alternative_target();\n+          if (!alternative_target.is_null()) {\n+            \/\/ Must extract verified entry point from HotSpotNmethod after VM to Java\n+            \/\/ transition in JavaCallWrapper constructor so that it is safe with\n+            \/\/ respect to nmethod sweeping.\n+            address verified_entry_point = (address) HotSpotJVMCI::InstalledCode::entryPoint(nullptr, alternative_target());\n+            if (verified_entry_point != nullptr) {\n+              thread->set_jvmci_alternate_call_target(verified_entry_point);\n+              entry_point = method->adapter()->get_i2c_entry();\n+            }\n+          }\n+#endif\n@@ -414,1 +421,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -507,1 +507,2 @@\n-  _lock_stack(this) {\n+  _lock_stack(this),\n+  _om_cache(this) {\n@@ -806,0 +807,2 @@\n+  om_clear_monitor_cache();\n+\n@@ -1906,1 +1909,1 @@\n-    fst.current()->print_value_on(tty, this);\n+    fst.current()->print_value_on(tty);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+class ObjectMonitor;\n@@ -1168,0 +1169,1 @@\n+  OMCache _om_cache;\n@@ -1179,0 +1181,7 @@\n+  static ByteSize om_cache_offset()        { return byte_offset_of(JavaThread, _om_cache); }\n+  static ByteSize om_cache_oops_offset()   { return om_cache_offset() + OMCache::entries_offset(); }\n+\n+  void om_set_monitor_cache(ObjectMonitor* monitor);\n+  void om_clear_monitor_cache();\n+  ObjectMonitor* om_get_from_monitor_cache(oop obj);\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/lockStack.inline.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -242,0 +244,21 @@\n+inline void JavaThread::om_set_monitor_cache(ObjectMonitor* monitor) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  assert(monitor != nullptr, \"use om_clear_monitor_cache to clear\");\n+  assert(this == current() || monitor->owner_raw() == this, \"only add owned monitors for other threads\");\n+  assert(this == current() || is_obj_deopt_suspend(), \"thread must not run concurrently\");\n+\n+  _om_cache.set_monitor(monitor);\n+}\n+\n+inline void JavaThread::om_clear_monitor_cache() {\n+  if (UseObjectMonitorTable) {\n+    _om_cache.clear();\n+  }\n+}\n+\n+inline ObjectMonitor* JavaThread::om_get_from_monitor_cache(oop obj) {\n+  assert(obj != nullptr, \"do not look for null objects\");\n+  assert(this == current(), \"only get own thread locals\");\n+  return _om_cache.get_monitor(obj);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,1223 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"jfrfiles\/jfrEventClasses.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"nmt\/memflags.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/basicLock.inline.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/lockStack.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/objectMonitor.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/perfData.inline.hpp\"\n+#include \"runtime\/safepointMechanism.inline.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n+#include \"runtime\/timerTrace.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n+#include \"utilities\/concurrentHashTable.inline.hpp\"\n+#include \"utilities\/concurrentHashTableTasks.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ ConcurrentHashTable storing links from objects to ObjectMonitors\n+class ObjectMonitorTable : AllStatic {\n+  struct Config {\n+    using Value = ObjectMonitor*;\n+    static uintx get_hash(Value const& value, bool* is_dead) {\n+      return (uintx)value->hash();\n+    }\n+    static void* allocate_node(void* context, size_t size, Value const& value) {\n+      ObjectMonitorTable::inc_items_count();\n+      return AllocateHeap(size, MEMFLAGS::mtObjectMonitor);\n+    };\n+    static void free_node(void* context, void* memory, Value const& value) {\n+      ObjectMonitorTable::dec_items_count();\n+      FreeHeap(memory);\n+    }\n+  };\n+  using ConcurrentTable = ConcurrentHashTable<Config, MEMFLAGS::mtObjectMonitor>;\n+\n+  static ConcurrentTable* _table;\n+  static volatile size_t _items_count;\n+  static size_t _table_size;\n+  static volatile bool _resize;\n+\n+  class Lookup : public StackObj {\n+    oop _obj;\n+\n+   public:\n+    explicit Lookup(oop obj) : _obj(obj) {}\n+\n+    uintx get_hash() const {\n+      uintx hash = _obj->mark().hash();\n+      assert(hash != 0, \"should have a hash\");\n+      return hash;\n+    }\n+\n+    bool equals(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return (*value)->object_refers_to(_obj);\n+    }\n+\n+    bool is_dead(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return false;\n+    }\n+  };\n+\n+  class LookupMonitor : public StackObj {\n+    ObjectMonitor* _monitor;\n+\n+   public:\n+    explicit LookupMonitor(ObjectMonitor* monitor) : _monitor(monitor) {}\n+\n+    uintx get_hash() const {\n+      return _monitor->hash();\n+    }\n+\n+    bool equals(ObjectMonitor** value) {\n+      return (*value) == _monitor;\n+    }\n+\n+    bool is_dead(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return (*value)->object_is_dead();\n+    }\n+  };\n+\n+  static void inc_items_count() {\n+    Atomic::inc(&_items_count);\n+  }\n+\n+  static void dec_items_count() {\n+    Atomic::dec(&_items_count);\n+  }\n+\n+  static double get_load_factor() {\n+    return (double)_items_count \/ (double)_table_size;\n+  }\n+\n+  static size_t table_size(Thread* current = Thread::current()) {\n+    return ((size_t)1) << _table->get_size_log2(current);\n+  }\n+\n+  static size_t max_log_size() {\n+    \/\/ TODO[OMTable]: Evaluate the max size.\n+    \/\/ TODO[OMTable]: Need to fix init order to use Universe::heap()->max_capacity();\n+    \/\/                Using MaxHeapSize directly this early may be wrong, and there\n+    \/\/                are definitely rounding errors (alignment).\n+    const size_t max_capacity = MaxHeapSize;\n+    const size_t min_object_size = CollectedHeap::min_dummy_object_size() * HeapWordSize;\n+    const size_t max_objects = max_capacity \/ MAX2(MinObjAlignmentInBytes, checked_cast<int>(min_object_size));\n+    const size_t log_max_objects = log2i_graceful(max_objects);\n+\n+    return MAX2(MIN2<size_t>(SIZE_BIG_LOG2, log_max_objects), min_log_size());\n+  }\n+\n+  static size_t min_log_size() {\n+    \/\/ ~= log(AvgMonitorsPerThreadEstimate default)\n+    return 10;\n+  }\n+\n+  template<typename V>\n+  static size_t clamp_log_size(V log_size) {\n+    return MAX2(MIN2(log_size, checked_cast<V>(max_log_size())), checked_cast<V>(min_log_size()));\n+  }\n+\n+  static size_t initial_log_size() {\n+    const size_t estimate = log2i(MAX2(os::processor_count(), 1)) + log2i(MAX2(AvgMonitorsPerThreadEstimate, size_t(1)));\n+    return clamp_log_size(estimate);\n+  }\n+\n+  static size_t grow_hint () {\n+    return ConcurrentTable::DEFAULT_GROW_HINT;\n+  }\n+\n+ public:\n+  static void create() {\n+    _table = new ConcurrentTable(initial_log_size(), max_log_size(), grow_hint());\n+    _items_count = 0;\n+    _table_size = table_size();\n+    _resize = false;\n+  }\n+\n+  static void verify_monitor_get_result(oop obj, ObjectMonitor* monitor) {\n+#ifdef ASSERT\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      bool has_monitor = obj->mark().has_monitor();\n+      assert(has_monitor == (monitor != nullptr),\n+          \"Inconsistency between markWord and ObjectMonitorTable has_monitor: %s monitor: \" PTR_FORMAT,\n+          BOOL_TO_STR(has_monitor), p2i(monitor));\n+    }\n+#endif\n+  }\n+\n+  static ObjectMonitor* monitor_get(Thread* current, oop obj) {\n+    ObjectMonitor* result = nullptr;\n+    Lookup lookup_f(obj);\n+    auto found_f = [&](ObjectMonitor** found) {\n+      assert((*found)->object_peek() == obj, \"must be\");\n+      result = *found;\n+    };\n+    _table->get(current, lookup_f, found_f);\n+    verify_monitor_get_result(obj, result);\n+    return result;\n+  }\n+\n+  static void try_notify_grow() {\n+    if (!_table->is_max_size_reached() && !Atomic::load(&_resize)) {\n+      Atomic::store(&_resize, true);\n+      if (Service_lock->try_lock()) {\n+        Service_lock->notify();\n+        Service_lock->unlock();\n+      }\n+    }\n+  }\n+\n+  static bool should_shrink() {\n+    \/\/ Not implemented;\n+    return false;\n+  }\n+\n+  static constexpr double GROW_LOAD_FACTOR = 0.75;\n+\n+  static bool should_grow() {\n+    return get_load_factor() > GROW_LOAD_FACTOR && !_table->is_max_size_reached();\n+  }\n+\n+  static bool should_resize() {\n+    return should_grow() || should_shrink() || Atomic::load(&_resize);\n+  }\n+\n+  template<typename Task, typename... Args>\n+  static bool run_task(JavaThread* current, Task& task, const char* task_name, Args&... args) {\n+    if (task.prepare(current)) {\n+      log_trace(monitortable)(\"Started to %s\", task_name);\n+      TraceTime timer(task_name, TRACETIME_LOG(Debug, monitortable, perf));\n+      while (task.do_task(current, args...)) {\n+        task.pause(current);\n+        {\n+          ThreadBlockInVM tbivm(current);\n+        }\n+        task.cont(current);\n+      }\n+      task.done(current);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  static bool grow(JavaThread* current) {\n+    ConcurrentTable::GrowTask grow_task(_table);\n+    if (run_task(current, grow_task, \"Grow\")) {\n+      _table_size = table_size(current);\n+      log_info(monitortable)(\"Grown to size: %zu\", _table_size);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  static bool clean(JavaThread* current) {\n+    ConcurrentTable::BulkDeleteTask clean_task(_table);\n+    auto is_dead = [&](ObjectMonitor** monitor) {\n+      return (*monitor)->object_is_dead();\n+    };\n+    auto do_nothing = [&](ObjectMonitor** monitor) {};\n+    NativeHeapTrimmer::SuspendMark sm(\"ObjectMonitorTable\");\n+    return run_task(current, clean_task, \"Clean\", is_dead, do_nothing);\n+  }\n+\n+  static bool resize(JavaThread* current) {\n+    LogTarget(Info, monitortable) lt;\n+    bool success = false;\n+\n+    if (should_grow()) {\n+      lt.print(\"Start growing with load factor %f\", get_load_factor());\n+      success = grow(current);\n+    } else {\n+      if (!_table->is_max_size_reached() && Atomic::load(&_resize)) {\n+        lt.print(\"WARNING: Getting resize hints with load factor %f\", get_load_factor());\n+      }\n+      lt.print(\"Start cleaning with load factor %f\", get_load_factor());\n+      success = clean(current);\n+    }\n+\n+    Atomic::store(&_resize, false);\n+\n+    return success;\n+  }\n+\n+  static ObjectMonitor* monitor_put_get(Thread* current, ObjectMonitor* monitor, oop obj) {\n+    \/\/ Enter the monitor into the concurrent hashtable.\n+    ObjectMonitor* result = monitor;\n+    Lookup lookup_f(obj);\n+    auto found_f = [&](ObjectMonitor** found) {\n+      assert((*found)->object_peek() == obj, \"must be\");\n+      result = *found;\n+    };\n+    bool grow;\n+    _table->insert_get(current, lookup_f, monitor, found_f, &grow);\n+    verify_monitor_get_result(obj, result);\n+    if (grow) {\n+      try_notify_grow();\n+    }\n+    return result;\n+  }\n+\n+  static bool remove_monitor_entry(Thread* current, ObjectMonitor* monitor) {\n+    LookupMonitor lookup_f(monitor);\n+    return _table->remove(current, lookup_f);\n+  }\n+\n+  static bool contains_monitor(Thread* current, ObjectMonitor* monitor) {\n+    LookupMonitor lookup_f(monitor);\n+    bool result = false;\n+    auto found_f = [&](ObjectMonitor** found) {\n+      result = true;\n+    };\n+    _table->get(current, lookup_f, found_f);\n+    return result;\n+  }\n+\n+  static void print_on(outputStream* st) {\n+    auto printer = [&] (ObjectMonitor** entry) {\n+       ObjectMonitor* om = *entry;\n+       oop obj = om->object_peek();\n+       st->print(\"monitor=\" PTR_FORMAT \", \", p2i(om));\n+       st->print(\"object=\" PTR_FORMAT, p2i(obj));\n+       assert(obj->mark().hash() == om->hash(), \"hash must match\");\n+       st->cr();\n+       return true;\n+    };\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      _table->do_safepoint_scan(printer);\n+    } else {\n+      _table->do_scan(Thread::current(), printer);\n+    }\n+  }\n+};\n+\n+ObjectMonitorTable::ConcurrentTable* ObjectMonitorTable::_table = nullptr;\n+volatile size_t ObjectMonitorTable::_items_count = 0;\n+size_t ObjectMonitorTable::_table_size = 0;\n+volatile bool ObjectMonitorTable::_resize = false;\n+\n+ObjectMonitor* LightweightSynchronizer::get_or_insert_monitor_from_table(oop object, JavaThread* current, bool* inserted) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+\n+  ObjectMonitor* monitor = get_monitor_from_table(current, object);\n+  if (monitor != nullptr) {\n+    *inserted = false;\n+    return monitor;\n+  }\n+\n+  ObjectMonitor* alloced_monitor = new ObjectMonitor(object);\n+  alloced_monitor->set_owner_anonymous();\n+\n+  \/\/ Try insert monitor\n+  monitor = add_monitor(current, alloced_monitor, object);\n+\n+  *inserted = alloced_monitor == monitor;\n+  if (!*inserted) {\n+    delete alloced_monitor;\n+  }\n+\n+  return monitor;\n+}\n+\n+static void log_inflate(Thread* current, oop object, ObjectSynchronizer::InflateCause cause) {\n+  if (log_is_enabled(Trace, monitorinflation)) {\n+    ResourceMark rm(current);\n+    log_trace(monitorinflation)(\"inflate: object=\" INTPTR_FORMAT \", mark=\"\n+                                INTPTR_FORMAT \", type='%s' cause=%s\", p2i(object),\n+                                object->mark().value(), object->klass()->external_name(),\n+                                ObjectSynchronizer::inflate_cause_name(cause));\n+  }\n+}\n+\n+static void post_monitor_inflate_event(EventJavaMonitorInflate* event,\n+                                       const oop obj,\n+                                       ObjectSynchronizer::InflateCause cause) {\n+  assert(event != nullptr, \"invariant\");\n+  event->set_monitorClass(obj->klass());\n+  event->set_address((uintptr_t)(void*)obj);\n+  event->set_cause((u1)cause);\n+  event->commit();\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::get_or_insert_monitor(oop object, JavaThread* current, ObjectSynchronizer::InflateCause cause) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+\n+  EventJavaMonitorInflate event;\n+\n+  bool inserted;\n+  ObjectMonitor* monitor = get_or_insert_monitor_from_table(object, current, &inserted);\n+\n+  if (inserted) {\n+    \/\/ Hopefully the performance counters are allocated on distinct\n+    \/\/ cache lines to avoid false sharing on MP systems ...\n+    OM_PERFDATA_OP(Inflations, inc());\n+    log_inflate(current, object, cause);\n+    if (event.should_commit()) {\n+      post_monitor_inflate_event(&event, object, cause);\n+    }\n+\n+    \/\/ The monitor has an anonymous owner so it is safe from async deflation.\n+    ObjectSynchronizer::_in_use_list.add(monitor);\n+  }\n+\n+  return monitor;\n+}\n+\n+\/\/ Add the hashcode to the monitor to match the object and put it in the hashtable.\n+ObjectMonitor* LightweightSynchronizer::add_monitor(JavaThread* current, ObjectMonitor* monitor, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  assert(obj == monitor->object(), \"must be\");\n+\n+  intptr_t hash = obj->mark().hash();\n+  assert(hash != 0, \"must be set when claiming the object monitor\");\n+  monitor->set_hash(hash);\n+\n+  return ObjectMonitorTable::monitor_put_get(current, monitor, obj);\n+}\n+\n+bool LightweightSynchronizer::remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  assert(monitor->object_peek() == obj, \"must be, cleared objects are removed by is_dead\");\n+\n+  return ObjectMonitorTable::remove_monitor_entry(current, monitor);\n+}\n+\n+void LightweightSynchronizer::deflate_mark_word(oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+\n+  markWord mark = obj->mark_acquire();\n+  assert(!mark.has_no_hash(), \"obj with inflated monitor must have had a hash\");\n+\n+  while (mark.has_monitor()) {\n+    const markWord new_mark = mark.clear_lock_bits().set_unlocked();\n+    mark = obj->cas_set_mark(new_mark, mark);\n+  }\n+}\n+\n+void LightweightSynchronizer::initialize() {\n+  if (!UseObjectMonitorTable) {\n+    return;\n+  }\n+  ObjectMonitorTable::create();\n+}\n+\n+bool LightweightSynchronizer::needs_resize() {\n+  if (!UseObjectMonitorTable) {\n+    return false;\n+  }\n+  return ObjectMonitorTable::should_resize();\n+}\n+\n+bool LightweightSynchronizer::resize_table(JavaThread* current) {\n+  if (!UseObjectMonitorTable) {\n+    return true;\n+  }\n+  return ObjectMonitorTable::resize(current);\n+}\n+\n+class LightweightSynchronizer::LockStackInflateContendedLocks : private OopClosure {\n+ private:\n+  oop _contended_oops[LockStack::CAPACITY];\n+  int _length;\n+\n+  void do_oop(oop* o) final {\n+    oop obj = *o;\n+    if (obj->mark_acquire().has_monitor()) {\n+      if (_length > 0 && _contended_oops[_length - 1] == obj) {\n+        \/\/ Recursive\n+        return;\n+      }\n+      _contended_oops[_length++] = obj;\n+    }\n+  }\n+\n+  void do_oop(narrowOop* o) final {\n+    ShouldNotReachHere();\n+  }\n+\n+ public:\n+  LockStackInflateContendedLocks() :\n+    _contended_oops(),\n+    _length(0) {};\n+\n+  void inflate(JavaThread* current) {\n+    assert(current == JavaThread::current(), \"must be\");\n+    current->lock_stack().oops_do(this);\n+    for (int i = 0; i < _length; i++) {\n+      LightweightSynchronizer::\n+        inflate_fast_locked_object(_contended_oops[i], ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n+    }\n+  }\n+};\n+\n+void LightweightSynchronizer::ensure_lock_stack_space(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+  LockStack& lock_stack = current->lock_stack();\n+\n+  \/\/ Make room on lock_stack\n+  if (lock_stack.is_full()) {\n+    \/\/ Inflate contended objects\n+    LockStackInflateContendedLocks().inflate(current);\n+    if (lock_stack.is_full()) {\n+      \/\/ Inflate the oldest object\n+      inflate_fast_locked_object(lock_stack.bottom(), ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n+    }\n+  }\n+}\n+\n+class LightweightSynchronizer::CacheSetter : StackObj {\n+  JavaThread* const _thread;\n+  BasicLock* const _lock;\n+  ObjectMonitor* _monitor;\n+\n+  NONCOPYABLE(CacheSetter);\n+\n+ public:\n+  CacheSetter(JavaThread* thread, BasicLock* lock) :\n+    _thread(thread),\n+    _lock(lock),\n+    _monitor(nullptr) {}\n+\n+  ~CacheSetter() {\n+    \/\/ Only use the cache if using the table.\n+    if (UseObjectMonitorTable) {\n+      if (_monitor != nullptr) {\n+        _thread->om_set_monitor_cache(_monitor);\n+        _lock->set_object_monitor_cache(_monitor);\n+      } else {\n+        _lock->clear_object_monitor_cache();\n+      }\n+    }\n+  }\n+\n+  void set_monitor(ObjectMonitor* monitor) {\n+    assert(_monitor == nullptr, \"only set once\");\n+    _monitor = monitor;\n+  }\n+\n+};\n+\n+class LightweightSynchronizer::VerifyThreadState {\n+  bool _no_safepoint;\n+\n+ public:\n+  VerifyThreadState(JavaThread* locking_thread, JavaThread* current) : _no_safepoint(locking_thread != current) {\n+    assert(current == Thread::current(), \"must be\");\n+    assert(locking_thread == current || locking_thread->is_obj_deopt_suspend(), \"locking_thread may not run concurrently\");\n+    if (_no_safepoint) {\n+      DEBUG_ONLY(JavaThread::current()->inc_no_safepoint_count();)\n+    }\n+  }\n+  ~VerifyThreadState() {\n+    if (_no_safepoint){\n+      DEBUG_ONLY(JavaThread::current()->dec_no_safepoint_count();)\n+    }\n+  }\n+};\n+\n+inline bool LightweightSynchronizer::fast_lock_try_enter(oop obj, LockStack& lock_stack, JavaThread* current) {\n+  markWord mark = obj->mark();\n+  while (mark.is_unlocked()) {\n+    ensure_lock_stack_space(current);\n+    assert(!lock_stack.is_full(), \"must have made room on the lock stack\");\n+    assert(!lock_stack.contains(obj), \"thread must not already hold the lock\");\n+    \/\/ Try to swing into 'fast-locked' state.\n+    markWord locked_mark = mark.set_fast_locked();\n+    markWord old_mark = mark;\n+    mark = obj->cas_set_mark(locked_mark, old_mark);\n+    if (old_mark == mark) {\n+      \/\/ Successfully fast-locked, push object to lock-stack and return.\n+      lock_stack.push(obj);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool LightweightSynchronizer::fast_lock_spin_enter(oop obj, LockStack& lock_stack, JavaThread* current, bool observed_deflation) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  \/\/ Will spin with exponential backoff with an accumulative O(2^spin_limit) spins.\n+  const int log_spin_limit = os::is_MP() ? LightweightFastLockingSpins : 1;\n+  const int log_min_safepoint_check_interval = 10;\n+\n+  markWord mark = obj->mark();\n+  const auto should_spin = [&]() {\n+    if (!mark.has_monitor()) {\n+      \/\/ Spin while not inflated.\n+      return true;\n+    } else if (observed_deflation) {\n+      \/\/ Spin while monitor is being deflated.\n+      ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n+      return monitor == nullptr || monitor->is_being_async_deflated();\n+    }\n+    \/\/ Else stop spinning.\n+    return false;\n+  };\n+  \/\/ Always attempt to lock once even when safepoint synchronizing.\n+  bool should_process = false;\n+  for (int i = 0; should_spin() && !should_process && i < log_spin_limit; i++) {\n+    \/\/ Spin with exponential backoff.\n+    const int total_spin_count = 1 << i;\n+    const int inner_spin_count = MIN2(1 << log_min_safepoint_check_interval, total_spin_count);\n+    const int outer_spin_count = total_spin_count \/ inner_spin_count;\n+    for (int outer = 0; outer < outer_spin_count; outer++) {\n+      should_process = SafepointMechanism::should_process(current);\n+      if (should_process) {\n+        \/\/ Stop spinning for safepoint.\n+        break;\n+      }\n+      for (int inner = 1; inner < inner_spin_count; inner++) {\n+        SpinPause();\n+      }\n+    }\n+\n+    if (fast_lock_try_enter(obj, lock_stack, current)) return true;\n+  }\n+  return false;\n+}\n+\n+void LightweightSynchronizer::enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  JavaThread* current = JavaThread::current();\n+  VerifyThreadState vts(locking_thread, current);\n+\n+  if (obj->klass()->is_value_based()) {\n+    ObjectSynchronizer::handle_sync_on_value_based_class(obj, locking_thread);\n+  }\n+\n+  locking_thread->inc_held_monitor_count();\n+\n+  CacheSetter cache_setter(locking_thread, lock);\n+\n+  LockStack& lock_stack = locking_thread->lock_stack();\n+\n+  ObjectMonitor* monitor = nullptr;\n+  if (lock_stack.contains(obj())) {\n+    monitor = inflate_fast_locked_object(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n+    bool entered = monitor->enter_for(locking_thread);\n+    assert(entered, \"recursive ObjectMonitor::enter_for must succeed\");\n+  } else {\n+    \/\/ It is assumed that enter_for must enter on an object without contention.\n+    monitor = inflate_and_enter(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n+  }\n+\n+  assert(monitor != nullptr, \"LightweightSynchronizer::enter_for must succeed\");\n+  cache_setter.set_monitor(monitor);\n+}\n+\n+void LightweightSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  if (obj->klass()->is_value_based()) {\n+    ObjectSynchronizer::handle_sync_on_value_based_class(obj, current);\n+  }\n+\n+  current->inc_held_monitor_count();\n+\n+  CacheSetter cache_setter(current, lock);\n+\n+  \/\/ Used when deflation is observed. Progress here requires progress\n+  \/\/ from the deflator. After observing that the deflator is not\n+  \/\/ making progress (after two yields), switch to sleeping.\n+  SpinYield spin_yield(0, 2);\n+  bool observed_deflation = false;\n+\n+  LockStack& lock_stack = current->lock_stack();\n+\n+  if (!lock_stack.is_full() && lock_stack.try_recursive_enter(obj())) {\n+    \/\/ Recursively fast locked\n+    return;\n+  }\n+\n+  if (lock_stack.contains(obj())) {\n+    ObjectMonitor* monitor = inflate_fast_locked_object(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, current, current);\n+    bool entered = monitor->enter(current);\n+    assert(entered, \"recursive ObjectMonitor::enter must succeed\");\n+    cache_setter.set_monitor(monitor);\n+    return;\n+  }\n+\n+  while (true) {\n+    \/\/ Fast-locking does not use the 'lock' argument.\n+    \/\/ Fast-lock spinning to avoid inflating for short critical sections.\n+    \/\/ The goal is to only inflate when the extra cost of using ObjectMonitors\n+    \/\/ is worth it.\n+    \/\/ If deflation has been observed we also spin while deflation is ongoing.\n+    if (fast_lock_try_enter(obj(), lock_stack, current)) {\n+      return;\n+    } else if (UseObjectMonitorTable && fast_lock_spin_enter(obj(), lock_stack, current, observed_deflation)) {\n+      return;\n+    }\n+\n+    if (observed_deflation) {\n+      spin_yield.wait();\n+    }\n+\n+    ObjectMonitor* monitor = inflate_and_enter(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, current, current);\n+    if (monitor != nullptr) {\n+      cache_setter.set_monitor(monitor);\n+      return;\n+    }\n+\n+    \/\/ If inflate_and_enter returns nullptr it is because a deflated monitor\n+    \/\/ was encountered. Fallback to fast locking. The deflater is responsible\n+    \/\/ for clearing out the monitor and transitioning the markWord back to\n+    \/\/ fast locking.\n+    observed_deflation = true;\n+  }\n+}\n+\n+void LightweightSynchronizer::exit(oop object, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(current == Thread::current(), \"must be\");\n+\n+  markWord mark = object->mark();\n+  assert(!mark.is_unlocked(), \"must be\");\n+\n+  LockStack& lock_stack = current->lock_stack();\n+  if (mark.is_fast_locked()) {\n+    if (lock_stack.try_recursive_exit(object)) {\n+      \/\/ This is a recursive exit which succeeded\n+      return;\n+    }\n+    if (lock_stack.is_recursive(object)) {\n+      \/\/ Must inflate recursive locks if try_recursive_exit fails\n+      \/\/ This happens for un-structured unlocks, could potentially\n+      \/\/ fix try_recursive_exit to handle these.\n+      inflate_fast_locked_object(object, ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n+    }\n+  }\n+\n+  while (mark.is_fast_locked()) {\n+    markWord unlocked_mark = mark.set_unlocked();\n+    markWord old_mark = mark;\n+    mark = object->cas_set_mark(unlocked_mark, old_mark);\n+    if (old_mark == mark) {\n+      \/\/ CAS successful, remove from lock_stack\n+      size_t recursion = lock_stack.remove(object) - 1;\n+      assert(recursion == 0, \"Should not have unlocked here\");\n+      return;\n+    }\n+  }\n+\n+  assert(mark.has_monitor(), \"must be\");\n+  \/\/ The monitor exists\n+  ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, object, mark);\n+  if (monitor->is_owner_anonymous()) {\n+    assert(current->lock_stack().contains(object), \"current must have object on its lock stack\");\n+    monitor->set_owner_from_anonymous(current);\n+    monitor->set_recursions(current->lock_stack().remove(object) - 1);\n+  }\n+\n+  monitor->exit(current);\n+}\n+\n+\/\/ LightweightSynchronizer::inflate_locked_or_imse is used to to get an inflated\n+\/\/ ObjectMonitor* with LM_LIGHTWEIGHT. It is used from contexts which require\n+\/\/ an inflated ObjectMonitor* for a monitor, and expects to throw a\n+\/\/ java.lang.IllegalMonitorStateException if it is not held by the current\n+\/\/ thread. Such as notify\/wait and jni_exit. LM_LIGHTWEIGHT keeps it invariant\n+\/\/ that it only inflates if it is already locked by the current thread or the\n+\/\/ current thread is in the process of entering. To maintain this invariant we\n+\/\/ need to throw a java.lang.IllegalMonitorStateException before inflating if\n+\/\/ the current thread is not the owner.\n+\/\/ LightweightSynchronizer::inflate_locked_or_imse facilitates this.\n+ObjectMonitor* LightweightSynchronizer::inflate_locked_or_imse(oop obj, ObjectSynchronizer::InflateCause cause, TRAPS) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  JavaThread* current = THREAD;\n+\n+  for (;;) {\n+    markWord mark = obj->mark_acquire();\n+    if (mark.is_unlocked()) {\n+      \/\/ No lock, IMSE.\n+      THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n+                 \"current thread is not owner\", nullptr);\n+    }\n+\n+    if (mark.is_fast_locked()) {\n+      if (!current->lock_stack().contains(obj)) {\n+        \/\/ Fast locked by other thread, IMSE.\n+        THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n+                   \"current thread is not owner\", nullptr);\n+      } else {\n+        \/\/ Current thread owns the lock, must inflate\n+        return inflate_fast_locked_object(obj, cause, current, current);\n+      }\n+    }\n+\n+    assert(mark.has_monitor(), \"must be\");\n+    ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n+    if (monitor != nullptr) {\n+      if (monitor->is_owner_anonymous()) {\n+        LockStack& lock_stack = current->lock_stack();\n+        if (lock_stack.contains(obj)) {\n+          \/\/ Current thread owns the lock but someone else inflated it.\n+          \/\/ Fix owner and pop lock stack.\n+          monitor->set_owner_from_anonymous(current);\n+          monitor->set_recursions(lock_stack.remove(obj) - 1);\n+        } else {\n+          \/\/ Fast locked (and inflated) by other thread, or deflation in progress, IMSE.\n+          THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n+                     \"current thread is not owner\", nullptr);\n+        }\n+      }\n+      return monitor;\n+    }\n+  }\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* inflating_thread, Thread* current) {\n+\n+  \/\/ The JavaThread* inflating_thread parameter is only used by LM_LIGHTWEIGHT and requires\n+  \/\/ that the inflating_thread == Thread::current() or is suspended throughout the call by\n+  \/\/ some other mechanism.\n+  \/\/ Even with LM_LIGHTWEIGHT the thread might be nullptr when called from a non\n+  \/\/ JavaThread. (As may still be the case from FastHashCode). However it is only\n+  \/\/ important for the correctness of the LM_LIGHTWEIGHT algorithm that the thread\n+  \/\/ is set when called from ObjectSynchronizer::enter from the owning thread,\n+  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n+  EventJavaMonitorInflate event;\n+\n+  for (;;) {\n+    const markWord mark = object->mark_acquire();\n+\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  inflated     - Just return if using stack-locking.\n+    \/\/                   If using fast-locking and the ObjectMonitor owner\n+    \/\/                   is anonymous and the inflating_thread owns the\n+    \/\/                   object lock, then we make the inflating_thread\n+    \/\/                   the ObjectMonitor owner and remove the lock from\n+    \/\/                   the inflating_thread's lock stack.\n+    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  unlocked     - Aggressively inflate the object.\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      ObjectMonitor* inf = mark.monitor();\n+      markWord dmw = inf->header();\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+      if (inf->is_owner_anonymous() &&\n+          inflating_thread != nullptr && inflating_thread->lock_stack().contains(object)) {\n+        inf->set_owner_from_anonymous(inflating_thread);\n+        size_t removed = inflating_thread->lock_stack().remove(object);\n+        inf->set_recursions(removed - 1);\n+      }\n+      return inf;\n+    }\n+\n+    \/\/ CASE: fast-locked\n+    \/\/ Could be fast-locked either by the inflating_thread or by some other thread.\n+    \/\/\n+    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_\n+    \/\/ attempting to set the object's mark to the new ObjectMonitor. If\n+    \/\/ the inflating_thread owns the monitor, then we set the ObjectMonitor's\n+    \/\/ owner to the inflating_thread. Otherwise, we set the ObjectMonitor's owner\n+    \/\/ to anonymous. If we lose the race to set the object's mark to the\n+    \/\/ new ObjectMonitor, then we just delete it and loop around again.\n+    \/\/\n+    if (mark.is_fast_locked()) {\n+      ObjectMonitor* monitor = new ObjectMonitor(object);\n+      monitor->set_header(mark.set_unlocked());\n+      bool own = inflating_thread != nullptr && inflating_thread->lock_stack().contains(object);\n+      if (own) {\n+        \/\/ Owned by inflating_thread.\n+        monitor->set_owner_from(nullptr, inflating_thread);\n+      } else {\n+        \/\/ Owned by somebody else.\n+        monitor->set_owner_anonymous();\n+      }\n+      markWord monitor_mark = markWord::encode(monitor);\n+      markWord old_mark = object->cas_set_mark(monitor_mark, mark);\n+      if (old_mark == mark) {\n+        \/\/ Success! Return inflated monitor.\n+        if (own) {\n+          size_t removed = inflating_thread->lock_stack().remove(object);\n+          monitor->set_recursions(removed - 1);\n+        }\n+        \/\/ Once the ObjectMonitor is configured and object is associated\n+        \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+        ObjectSynchronizer::_in_use_list.add(monitor);\n+\n+        \/\/ Hopefully the performance counters are allocated on distinct\n+        \/\/ cache lines to avoid false sharing on MP systems ...\n+        OM_PERFDATA_OP(Inflations, inc());\n+        log_inflate(current, object, cause);\n+        if (event.should_commit()) {\n+          post_monitor_inflate_event(&event, object, cause);\n+        }\n+        return monitor;\n+      } else {\n+        delete monitor;\n+        continue;  \/\/ Interference -- just retry\n+      }\n+    }\n+\n+    \/\/ CASE: unlocked\n+    \/\/ TODO-FIXME: for entry we currently inflate and then try to CAS _owner.\n+    \/\/ If we know we're inflating for entry it's better to inflate by swinging a\n+    \/\/ pre-locked ObjectMonitor pointer into the object header.   A successful\n+    \/\/ CAS inflates the object *and* confers ownership to the inflating thread.\n+    \/\/ In the current implementation we use a 2-step mechanism where we CAS()\n+    \/\/ to inflate and then CAS() again to try to swing _owner from null to current.\n+    \/\/ An inflateTry() method that we could call from enter() would be useful.\n+\n+    assert(mark.is_unlocked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    ObjectMonitor* m = new ObjectMonitor(object);\n+    \/\/ prepare m for installation - set monitor to initial state\n+    m->set_header(mark);\n+\n+    if (object->cas_set_mark(markWord::encode(m), mark) != mark) {\n+      delete m;\n+      m = nullptr;\n+      continue;\n+      \/\/ interference - the markword changed - just retry.\n+      \/\/ The state-transitions are one-way, so there's no chance of\n+      \/\/ live-lock -- \"Inflated\" is an absorbing state.\n+    }\n+\n+    \/\/ Once the ObjectMonitor is configured and object is associated\n+    \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+    ObjectSynchronizer::_in_use_list.add(m);\n+\n+    \/\/ Hopefully the performance counters are allocated on distinct\n+    \/\/ cache lines to avoid false sharing on MP systems ...\n+    OM_PERFDATA_OP(Inflations, inc());\n+    log_inflate(current, object, cause);\n+    if (event.should_commit()) {\n+      post_monitor_inflate_event(&event, object, cause);\n+    }\n+    return m;\n+  }\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::inflate_fast_locked_object(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used for lightweight\");\n+  VerifyThreadState vts(locking_thread, current);\n+  assert(locking_thread->lock_stack().contains(object), \"locking_thread must have object on its lock stack\");\n+\n+  ObjectMonitor* monitor;\n+\n+  if (!UseObjectMonitorTable) {\n+    return inflate_into_object_header(object, cause, locking_thread, current);\n+  }\n+\n+  \/\/ Inflating requires a hash code\n+  ObjectSynchronizer::FastHashCode(current, object);\n+\n+  markWord mark = object->mark_acquire();\n+  assert(!mark.is_unlocked(), \"Cannot be unlocked\");\n+\n+  for (;;) {\n+    \/\/ Fetch the monitor from the table\n+    monitor = get_or_insert_monitor(object, current, cause);\n+\n+    \/\/ ObjectMonitors are always inserted as anonymously owned, this thread is\n+    \/\/ the current holder of the monitor. So unless the entry is stale and\n+    \/\/ contains a deflating monitor it must be anonymously owned.\n+    if (monitor->is_owner_anonymous()) {\n+      \/\/ The monitor must be anonymously owned if it was added\n+      assert(monitor == get_monitor_from_table(current, object), \"The monitor must be found\");\n+      \/\/ New fresh monitor\n+      break;\n+    }\n+\n+    \/\/ If the monitor was not anonymously owned then we got a deflating monitor\n+    \/\/ from the table. We need to let the deflator make progress and remove this\n+    \/\/ entry before we are allowed to add a new one.\n+    os::naked_yield();\n+    assert(monitor->is_being_async_deflated(), \"Should be the reason\");\n+  }\n+\n+  \/\/ Set the mark word; loop to handle concurrent updates to other parts of the mark word\n+  while (mark.is_fast_locked()) {\n+    mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n+  }\n+\n+  \/\/ Indicate that the monitor now has a known owner\n+  monitor->set_owner_from_anonymous(locking_thread);\n+\n+  \/\/ Remove the entry from the thread's lock stack\n+  monitor->set_recursions(locking_thread->lock_stack().remove(object) - 1);\n+\n+  if (locking_thread == current) {\n+    \/\/ Only change the thread local state of the current thread.\n+    locking_thread->om_set_monitor_cache(monitor);\n+  }\n+\n+  return monitor;\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::inflate_and_enter(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used for lightweight\");\n+  VerifyThreadState vts(locking_thread, current);\n+\n+  \/\/ Note: In some paths (deoptimization) the 'current' thread inflates and\n+  \/\/ enters the lock on behalf of the 'locking_thread' thread.\n+\n+  ObjectMonitor* monitor = nullptr;\n+\n+  if (!UseObjectMonitorTable) {\n+    \/\/ Do the old inflate and enter.\n+    monitor = inflate_into_object_header(object, cause, locking_thread, current);\n+\n+    bool entered;\n+    if (locking_thread == current) {\n+      entered = monitor->enter(locking_thread);\n+    } else {\n+      entered = monitor->enter_for(locking_thread);\n+    }\n+\n+    \/\/ enter returns false for deflation found.\n+    return entered ? monitor : nullptr;\n+  }\n+\n+  NoSafepointVerifier nsv;\n+\n+  \/\/ Lightweight monitors require that hash codes are installed first\n+  ObjectSynchronizer::FastHashCode(locking_thread, object);\n+\n+  \/\/ Try to get the monitor from the thread-local cache.\n+  \/\/ There's no need to use the cache if we are locking\n+  \/\/ on behalf of another thread.\n+  if (current == locking_thread) {\n+    monitor = current->om_get_from_monitor_cache(object);\n+  }\n+\n+  \/\/ Get or create the monitor\n+  if (monitor == nullptr) {\n+    monitor = get_or_insert_monitor(object, current, cause);\n+  }\n+\n+  if (monitor->try_enter(locking_thread)) {\n+    return monitor;\n+  }\n+\n+  \/\/ Holds is_being_async_deflated() stable throughout this function.\n+  ObjectMonitorContentionMark contention_mark(monitor);\n+\n+  \/\/\/ First handle the case where the monitor from the table is deflated\n+  if (monitor->is_being_async_deflated()) {\n+    \/\/ The MonitorDeflation thread is deflating the monitor. The locking thread\n+    \/\/ must spin until further progress has been made.\n+\n+    const markWord mark = object->mark_acquire();\n+\n+    if (mark.has_monitor()) {\n+      \/\/ Waiting on the deflation thread to remove the deflated monitor from the table.\n+      os::naked_yield();\n+\n+    } else if (mark.is_fast_locked()) {\n+      \/\/ Some other thread managed to fast-lock the lock, or this is a\n+      \/\/ recursive lock from the same thread; yield for the deflation\n+      \/\/ thread to remove the deflated monitor from the table.\n+      os::naked_yield();\n+\n+    } else {\n+      assert(mark.is_unlocked(), \"Implied\");\n+      \/\/ Retry immediately\n+    }\n+\n+    \/\/ Retry\n+    return nullptr;\n+  }\n+\n+  for (;;) {\n+    const markWord mark = object->mark_acquire();\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  inflated     - If the ObjectMonitor owner is anonymous\n+    \/\/                   and the locking_thread owns the object\n+    \/\/                   lock, then we make the locking_thread\n+    \/\/                   the ObjectMonitor owner and remove the\n+    \/\/                   lock from the locking_thread's lock stack.\n+    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  neutral      - Inflate the object. Successful CAS is locked\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      LockStack& lock_stack = locking_thread->lock_stack();\n+      if (monitor->is_owner_anonymous() && lock_stack.contains(object)) {\n+        \/\/ The lock is fast-locked by the locking thread,\n+        \/\/ convert it to a held monitor with a known owner.\n+        monitor->set_owner_from_anonymous(locking_thread);\n+        monitor->set_recursions(lock_stack.remove(object) - 1);\n+      }\n+\n+      break; \/\/ Success\n+    }\n+\n+    \/\/ CASE: fast-locked\n+    \/\/ Could be fast-locked either by locking_thread or by some other thread.\n+    \/\/\n+    if (mark.is_fast_locked()) {\n+      markWord old_mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n+      if (old_mark != mark) {\n+        \/\/ CAS failed\n+        continue;\n+      }\n+\n+      \/\/ Success! Return inflated monitor.\n+      LockStack& lock_stack = locking_thread->lock_stack();\n+      if (lock_stack.contains(object)) {\n+        \/\/ The lock is fast-locked by the locking thread,\n+        \/\/ convert it to a held monitor with a known owner.\n+        monitor->set_owner_from_anonymous(locking_thread);\n+        monitor->set_recursions(lock_stack.remove(object) - 1);\n+      }\n+\n+      break; \/\/ Success\n+    }\n+\n+    \/\/ CASE: neutral (unlocked)\n+\n+    \/\/ Catch if the object's header is not neutral (not locked and\n+    \/\/ not marked is what we care about here).\n+    assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    markWord old_mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n+    if (old_mark != mark) {\n+      \/\/ CAS failed\n+      continue;\n+    }\n+\n+    \/\/ Transitioned from unlocked to monitor means locking_thread owns the lock.\n+    monitor->set_owner_from_anonymous(locking_thread);\n+\n+    return monitor;\n+  }\n+\n+  if (current == locking_thread) {\n+    \/\/ One round of spinning\n+    if (monitor->spin_enter(locking_thread)) {\n+      return monitor;\n+    }\n+\n+    \/\/ Monitor is contended, take the time before entering to fix the lock stack.\n+    LockStackInflateContendedLocks().inflate(current);\n+  }\n+\n+  \/\/ enter can block for safepoints; clear the unhandled object oop\n+  PauseNoSafepointVerifier pnsv(&nsv);\n+  object = nullptr;\n+\n+  if (current == locking_thread) {\n+    monitor->enter_with_contention_mark(locking_thread, contention_mark);\n+  } else {\n+    monitor->enter_for_with_contention_mark(locking_thread, contention_mark);\n+  }\n+\n+  return monitor;\n+}\n+\n+void LightweightSynchronizer::deflate_monitor(Thread* current, oop obj, ObjectMonitor* monitor) {\n+  if (obj != nullptr) {\n+    deflate_mark_word(obj);\n+  }\n+  bool removed = remove_monitor(current, monitor, obj);\n+  if (obj != nullptr) {\n+    assert(removed, \"Should have removed the entry if obj was alive\");\n+  }\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::get_monitor_from_table(Thread* current, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  return ObjectMonitorTable::monitor_get(current, obj);\n+}\n+\n+bool LightweightSynchronizer::contains_monitor(Thread* current, ObjectMonitor* monitor) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  return ObjectMonitorTable::contains_monitor(current, monitor);\n+}\n+\n+bool LightweightSynchronizer::quick_enter(oop obj, BasicLock* lock, JavaThread* current) {\n+  assert(current->thread_state() == _thread_in_Java, \"must be\");\n+  assert(obj != nullptr, \"must be\");\n+  NoSafepointVerifier nsv;\n+\n+  \/\/ If quick_enter succeeds with entering, the cache should be in a valid initialized state.\n+  CacheSetter cache_setter(current, lock);\n+\n+  LockStack& lock_stack = current->lock_stack();\n+  if (lock_stack.is_full()) {\n+    \/\/ Always go into runtime if the lock stack is full.\n+    return false;\n+  }\n+\n+  const markWord mark = obj->mark();\n+\n+#ifndef _LP64\n+  \/\/ Only for 32bit which has limited support for fast locking outside the runtime.\n+  if (lock_stack.try_recursive_enter(obj)) {\n+    \/\/ Recursive lock successful.\n+    current->inc_held_monitor_count();\n+    return true;\n+  }\n+\n+  if (mark.is_unlocked()) {\n+    markWord locked_mark = mark.set_fast_locked();\n+    if (obj->cas_set_mark(locked_mark, mark) == mark) {\n+      \/\/ Successfully fast-locked, push object to lock-stack and return.\n+      lock_stack.push(obj);\n+      current->inc_held_monitor_count();\n+      return true;\n+    }\n+  }\n+#endif\n+\n+  if (mark.has_monitor()) {\n+    ObjectMonitor* const monitor = UseObjectMonitorTable ? current->om_get_from_monitor_cache(obj) :\n+                                                           ObjectSynchronizer::read_monitor(mark);\n+\n+    if (monitor == nullptr) {\n+      \/\/ Take the slow-path on a cache miss.\n+      return false;\n+    }\n+\n+    if (monitor->try_enter(current)) {\n+      \/\/ ObjectMonitor enter successful.\n+      cache_setter.set_monitor(monitor);\n+      current->inc_held_monitor_count();\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Slow-path.\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":1223,"deletions":0,"binary":false,"changes":1223,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_LIGHTWEIGHTSYNCHRONIZER_HPP\n+#define SHARE_RUNTIME_LIGHTWEIGHTSYNCHRONIZER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/objectMonitor.hpp\"\n+#include \"runtime\/synchronizer.hpp\"\n+\n+class ObjectMonitorTable;\n+\n+class LightweightSynchronizer : AllStatic {\n+ private:\n+  static ObjectMonitor* get_or_insert_monitor_from_table(oop object, JavaThread* current, bool* inserted);\n+  static ObjectMonitor* get_or_insert_monitor(oop object, JavaThread* current, ObjectSynchronizer::InflateCause cause);\n+\n+  static ObjectMonitor* add_monitor(JavaThread* current, ObjectMonitor* monitor, oop obj);\n+  static bool remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj);\n+\n+  static void deflate_mark_word(oop object);\n+\n+  static void ensure_lock_stack_space(JavaThread* current);\n+\n+  class CacheSetter;\n+  class LockStackInflateContendedLocks;\n+  class VerifyThreadState;\n+\n+ public:\n+  static void initialize();\n+\n+  static bool needs_resize();\n+  static bool resize_table(JavaThread* current);\n+\n+ private:\n+  static inline bool fast_lock_try_enter(oop obj, LockStack& lock_stack, JavaThread* current);\n+  static bool fast_lock_spin_enter(oop obj, LockStack& lock_stack, JavaThread* current, bool observed_deflation);\n+\n+ public:\n+  static void enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread);\n+  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n+  static void exit(oop object, JavaThread* current);\n+\n+  static ObjectMonitor* inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* inflating_thread, Thread* current);\n+  static ObjectMonitor* inflate_locked_or_imse(oop object, ObjectSynchronizer::InflateCause cause, TRAPS);\n+  static ObjectMonitor* inflate_fast_locked_object(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current);\n+  static ObjectMonitor* inflate_and_enter(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current);\n+\n+  static void deflate_monitor(Thread* current, oop obj, ObjectMonitor* monitor);\n+\n+  static ObjectMonitor* get_monitor_from_table(Thread* current, oop obj);\n+\n+  static bool contains_monitor(Thread* current, ObjectMonitor* monitor);\n+\n+  static bool quick_enter(oop obj, BasicLock* Lock, JavaThread* current);\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_LIGHTWEIGHTSYNCHRONIZER_HPP\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -37,0 +38,1 @@\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -43,0 +45,1 @@\n+#include \"utilities\/sizes.hpp\"\n@@ -117,0 +120,8 @@\n+\n+OMCache::OMCache(JavaThread* jt) : _entries() {\n+  STATIC_ASSERT(std::is_standard_layout<OMCache>::value);\n+  STATIC_ASSERT(std::is_standard_layout<OMCache::OMCacheEntry>::value);\n+  STATIC_ASSERT(offsetof(OMCache, _null_sentinel) == offsetof(OMCache, _entries) +\n+                offsetof(OMCache::OMCacheEntry, _oop) +\n+                OMCache::CAPACITY * in_bytes(oop_to_oop_difference()));\n+}\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class ObjectMonitor;\n@@ -39,0 +40,1 @@\n+class Thread;\n@@ -44,1 +46,1 @@\n-public:\n+ public:\n@@ -46,1 +48,1 @@\n-private:\n+ private:\n@@ -76,1 +78,1 @@\n-public:\n+ public:\n@@ -126,0 +128,25 @@\n+class OMCache {\n+  friend class VMStructs;\n+ public:\n+  static constexpr int CAPACITY = 8;\n+\n+ private:\n+  struct OMCacheEntry {\n+    oop _oop = nullptr;\n+    ObjectMonitor* _monitor = nullptr;\n+  } _entries[CAPACITY];\n+  const oop _null_sentinel = nullptr;\n+\n+ public:\n+  static ByteSize entries_offset() { return byte_offset_of(OMCache, _entries); }\n+  static constexpr ByteSize oop_to_oop_difference() { return in_ByteSize(sizeof(OMCacheEntry)); }\n+  static constexpr ByteSize oop_to_monitor_difference() { return in_ByteSize(sizeof(oop)); }\n+\n+  explicit OMCache(JavaThread* jt);\n+\n+  inline ObjectMonitor* get_monitor(oop o);\n+  inline void set_monitor(ObjectMonitor* monitor);\n+  inline void clear();\n+\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -225,0 +227,50 @@\n+inline void OMCache::set_monitor(ObjectMonitor *monitor) {\n+  const int end = OMCache::CAPACITY - 1;\n+\n+  oop obj = monitor->object_peek();\n+  assert(obj != nullptr, \"must be alive\");\n+  assert(monitor == LightweightSynchronizer::get_monitor_from_table(JavaThread::current(), obj), \"must exist in table\");\n+\n+  OMCacheEntry to_insert = {obj, monitor};\n+\n+  for (int i = 0; i < end; ++i) {\n+    if (_entries[i]._oop == obj ||\n+        _entries[i]._monitor == nullptr ||\n+        _entries[i]._monitor->is_being_async_deflated()) {\n+      \/\/ Use stale slot.\n+      _entries[i] = to_insert;\n+      return;\n+    }\n+    \/\/ Swap with the most recent value.\n+    ::swap(to_insert, _entries[i]);\n+  }\n+  _entries[end] = to_insert;\n+}\n+\n+inline ObjectMonitor* OMCache::get_monitor(oop o) {\n+  for (int i = 0; i < CAPACITY; ++i) {\n+    if (_entries[i]._oop == o) {\n+      assert(_entries[i]._monitor != nullptr, \"monitor must exist\");\n+      if (_entries[i]._monitor->is_being_async_deflated()) {\n+        \/\/ Bad monitor\n+        \/\/ Shift down rest\n+        for (; i < CAPACITY - 1; ++i) {\n+          _entries[i] = _entries[i + 1];\n+        }\n+        \/\/ Clear end\n+        _entries[i] = {};\n+        return nullptr;\n+      }\n+      return _entries[i]._monitor;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+inline void OMCache::clear() {\n+  for (size_t i = 0; i < CAPACITY; ++i) {\n+    \/\/ Clear\n+    _entries[i] = {};\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -56,0 +57,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -249,1 +251,1 @@\n-  _header(markWord::zero()),\n+  _metadata(0),\n@@ -275,4 +277,0 @@\n-oop ObjectMonitor::object_peek() const {\n-  return _object.peek();\n-}\n-\n@@ -300,0 +298,6 @@\n+#define assert_mark_word_consistency()                                         \\\n+  assert(UseObjectMonitorTable || object()->mark() == markWord::encode(this),  \\\n+         \"object mark must match encoded this: mark=\" INTPTR_FORMAT            \\\n+         \", encoded this=\" INTPTR_FORMAT, object()->mark().value(),            \\\n+         markWord::encode(this).value());\n+\n@@ -303,1 +307,17 @@\n-bool ObjectMonitor::enter_for(JavaThread* locking_thread) {\n+bool ObjectMonitor::enter_is_async_deflating() {\n+  if (is_being_async_deflated()) {\n+    if (!UseObjectMonitorTable) {\n+      const oop l_object = object();\n+      if (l_object != nullptr) {\n+        \/\/ Attempt to restore the header\/dmw to the object's header so that\n+        \/\/ we only retry once if the deflater thread happens to be slow.\n+        install_displaced_markword_in_object(l_object);\n+      }\n+    }\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+void ObjectMonitor::enter_for_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark) {\n@@ -308,0 +328,2 @@\n+  assert(contention_mark._monitor == this, \"must be\");\n+  assert(!is_being_async_deflated(), \"must be\");\n@@ -309,2 +331,2 @@\n-  \/\/ Block out deflation as soon as possible.\n-  add_to_contentions(1);\n+\n+  void* prev_owner = try_set_owner_from(nullptr, locking_thread);\n@@ -313,2 +335,0 @@\n-  if (!is_being_async_deflated()) {\n-    void* prev_owner = try_set_owner_from(nullptr, locking_thread);\n@@ -316,25 +336,12 @@\n-    if (prev_owner == nullptr) {\n-      assert(_recursions == 0, \"invariant\");\n-      success = true;\n-    } else if (prev_owner == locking_thread) {\n-      _recursions++;\n-      success = true;\n-    } else if (prev_owner == DEFLATER_MARKER) {\n-      \/\/ Racing with deflation.\n-      prev_owner = try_set_owner_from(DEFLATER_MARKER, locking_thread);\n-      if (prev_owner == DEFLATER_MARKER) {\n-        \/\/ Cancelled deflation. Increment contentions as part of the deflation protocol.\n-        add_to_contentions(1);\n-        success = true;\n-      } else if (prev_owner == nullptr) {\n-        \/\/ At this point we cannot race with deflation as we have both incremented\n-        \/\/ contentions, seen contention > 0 and seen a DEFLATER_MARKER.\n-        \/\/ success will only be false if this races with something other than\n-        \/\/ deflation.\n-        prev_owner = try_set_owner_from(nullptr, locking_thread);\n-        success = prev_owner == nullptr;\n-      }\n-    } else if (LockingMode == LM_LEGACY && locking_thread->is_lock_owned((address)prev_owner)) {\n-      assert(_recursions == 0, \"must be\");\n-      _recursions = 1;\n-      set_owner_from_BasicLock(prev_owner, locking_thread);\n+  if (prev_owner == nullptr) {\n+    assert(_recursions == 0, \"invariant\");\n+    success = true;\n+  } else if (prev_owner == locking_thread) {\n+    _recursions++;\n+    success = true;\n+  } else if (prev_owner == DEFLATER_MARKER) {\n+    \/\/ Racing with deflation.\n+    prev_owner = try_set_owner_from(DEFLATER_MARKER, locking_thread);\n+    if (prev_owner == DEFLATER_MARKER) {\n+      \/\/ Cancelled deflation. Increment contentions as part of the deflation protocol.\n+      add_to_contentions(1);\n@@ -342,0 +349,7 @@\n+    } else if (prev_owner == nullptr) {\n+      \/\/ At this point we cannot race with deflation as we have both incremented\n+      \/\/ contentions, seen contention > 0 and seen a DEFLATER_MARKER.\n+      \/\/ success will only be false if this races with something other than\n+      \/\/ deflation.\n+      prev_owner = try_set_owner_from(nullptr, locking_thread);\n+      success = prev_owner == nullptr;\n@@ -343,13 +357,5 @@\n-    assert(success, \"Failed to enter_for: locking_thread=\" INTPTR_FORMAT\n-           \", this=\" INTPTR_FORMAT \"{owner=\" INTPTR_FORMAT \"}, observed owner: \" INTPTR_FORMAT,\n-           p2i(locking_thread), p2i(this), p2i(owner_raw()), p2i(prev_owner));\n-  } else {\n-    \/\/ Async deflation is in progress and our contentions increment\n-    \/\/ above lost the race to async deflation. Undo the work and\n-    \/\/ force the caller to retry.\n-    const oop l_object = object();\n-    if (l_object != nullptr) {\n-      \/\/ Attempt to restore the header\/dmw to the object's header so that\n-      \/\/ we only retry once if the deflater thread happens to be slow.\n-      install_displaced_markword_in_object(l_object);\n-    }\n+  } else if (LockingMode == LM_LEGACY && locking_thread->is_lock_owned((address)prev_owner)) {\n+    assert(_recursions == 0, \"must be\");\n+    _recursions = 1;\n+    set_owner_from_BasicLock(prev_owner, locking_thread);\n+    success = true;\n@@ -357,0 +363,6 @@\n+  assert(success, \"Failed to enter_for: locking_thread=\" INTPTR_FORMAT\n+          \", this=\" INTPTR_FORMAT \"{owner=\" INTPTR_FORMAT \"}, observed owner: \" INTPTR_FORMAT,\n+          p2i(locking_thread), p2i(this), p2i(owner_raw()), p2i(prev_owner));\n+}\n+\n+bool ObjectMonitor::enter_for(JavaThread* locking_thread) {\n@@ -358,1 +370,2 @@\n-  add_to_contentions(-1);\n+  \/\/ Block out deflation as soon as possible.\n+  ObjectMonitorContentionMark contention_mark(this);\n@@ -360,1 +373,4 @@\n-  assert(!success || owner_raw() == locking_thread, \"must be\");\n+  \/\/ Check for deflation.\n+  if (enter_is_async_deflating()) {\n+    return false;\n+  }\n@@ -362,1 +378,3 @@\n-  return success;\n+  enter_for_with_contention_mark(locking_thread, contention_mark);\n+  assert(owner_raw() == locking_thread, \"must be\");\n+  return true;\n@@ -365,7 +383,4 @@\n-bool ObjectMonitor::enter(JavaThread* current) {\n-  assert(current == JavaThread::current(), \"must be\");\n-  \/\/ The following code is ordered to check the most common cases first\n-  \/\/ and to reduce RTS->RTO cache line upgrades on SPARC and IA32 processors.\n-\n-  void* cur = try_set_owner_from(nullptr, current);\n-  if (cur == nullptr) {\n+bool ObjectMonitor::try_enter(JavaThread* current) {\n+  \/\/ TryLock avoids the CAS\n+  TryLockResult r = TryLock(current);\n+  if (r == TryLockResult::Success) {\n@@ -376,2 +391,1 @@\n-  if (cur == current) {\n-    \/\/ TODO-FIXME: check for integer overflow!  BUGID 6557169.\n+  if (r == TryLockResult::HasOwner && owner() == current) {\n@@ -382,1 +396,2 @@\n-  if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+  void* cur = owner_raw();\n+  if (LockingMode == LM_LEGACY && current->is_lock_owned((address)cur)) {\n@@ -389,0 +404,16 @@\n+  return false;\n+}\n+\n+bool ObjectMonitor::spin_enter(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  \/\/ Check for recursion.\n+  if (try_enter(current)) {\n+    return true;\n+  }\n+\n+  \/\/ Check for deflation.\n+  if (enter_is_async_deflating()) {\n+    return false;\n+  }\n+\n@@ -391,3 +422,1 @@\n-  \/\/ Try one round of spinning *before* enqueueing current\n-  \/\/ and before going through the awkward and expensive state\n-  \/\/ transitions.  The following spin is strictly optional ...\n+  \/\/ Do one round of spinning.\n@@ -399,4 +428,11 @@\n-    assert(object()->mark() == markWord::encode(this),\n-           \"object mark must match encoded this: mark=\" INTPTR_FORMAT\n-           \", encoded this=\" INTPTR_FORMAT, object()->mark().value(),\n-           markWord::encode(this).value());\n+    assert_mark_word_consistency();\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool ObjectMonitor::enter(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  if (spin_enter(current)) {\n@@ -411,13 +447,5 @@\n-  \/\/ Keep track of contention for JVM\/TI and M&M queries.\n-  add_to_contentions(1);\n-  if (is_being_async_deflated()) {\n-    \/\/ Async deflation is in progress and our contentions increment\n-    \/\/ above lost the race to async deflation. Undo the work and\n-    \/\/ force the caller to retry.\n-    const oop l_object = object();\n-    if (l_object != nullptr) {\n-      \/\/ Attempt to restore the header\/dmw to the object's header so that\n-      \/\/ we only retry once if the deflater thread happens to be slow.\n-      install_displaced_markword_in_object(l_object);\n-    }\n-    add_to_contentions(-1);\n+  \/\/ Keep is_being_async_deflated stable across the rest of enter\n+  ObjectMonitorContentionMark contention_mark(this);\n+\n+  \/\/ Check for deflation.\n+  if (enter_is_async_deflating()) {\n@@ -427,0 +455,11 @@\n+  \/\/ At this point this ObjectMonitor cannot be deflated, finish contended enter\n+  enter_with_contention_mark(current, contention_mark);\n+  return true;\n+}\n+\n+void ObjectMonitor::enter_with_contention_mark(JavaThread *current, ObjectMonitorContentionMark &cm) {\n+  assert(current == JavaThread::current(), \"must be\");\n+  assert(owner_raw() != current, \"must be\");\n+  assert(cm._monitor == this, \"must be\");\n+  assert(!is_being_async_deflated(), \"must be\");\n+\n@@ -483,1 +522,0 @@\n-  add_to_contentions(-1);\n@@ -490,1 +528,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_consistency();\n@@ -519,1 +557,0 @@\n-  return true;\n@@ -552,1 +589,1 @@\n-bool ObjectMonitor::deflate_monitor() {\n+bool ObjectMonitor::deflate_monitor(Thread* current) {\n@@ -623,0 +660,1 @@\n+  }\n@@ -624,0 +662,3 @@\n+  if (UseObjectMonitorTable) {\n+    LightweightSynchronizer::deflate_monitor(current, obj, this);\n+  } else if (obj != nullptr) {\n@@ -639,0 +680,1 @@\n+  assert(!UseObjectMonitorTable, \"ObjectMonitorTable has no dmw\");\n@@ -975,0 +1017,1 @@\n+  assert(current->thread_state() != _thread_blocked, \"invariant\");\n@@ -978,3 +1021,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n-\n-  assert(current->thread_state() != _thread_blocked, \"invariant\");\n+  assert_mark_word_consistency();\n@@ -1045,1 +1086,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_consistency();\n@@ -1671,1 +1712,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_consistency();\n@@ -2188,1 +2229,1 @@\n-\/\/   _header = 0x0000000000000001\n+\/\/   _metadata = 0x0000000000000001\n@@ -2217,1 +2258,1 @@\n-  st->print_cr(\"  _header = \" INTPTR_FORMAT, header().value());\n+  st->print_cr(\"  _metadata = \" INTPTR_FORMAT, _metadata);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":133,"deletions":92,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class ObjectMonitorContentionMark;\n@@ -72,1 +73,1 @@\n-\/\/ - The _header field must be at offset 0 because the displaced header\n+\/\/ - The _metadata field must be at offset 0 because the displaced header\n@@ -78,1 +79,1 @@\n-\/\/ - The _header and _owner fields should be separated by enough space\n+\/\/ - The _metadata and _owner fields should be separated by enough space\n@@ -82,1 +83,1 @@\n-\/\/     _header\n+\/\/     _metadata\n@@ -86,0 +87,1 @@\n+\/\/     <optional padding>\n@@ -109,10 +111,9 @@\n-\/\/   - Separating _owner from the <remaining_fields> by enough space to\n-\/\/     avoid false sharing might be profitable. Given\n-\/\/     http:\/\/blogs.oracle.com\/dave\/entry\/cas_and_cache_trivia_invalidate\n-\/\/     we know that the CAS in monitorenter will invalidate the line\n-\/\/     underlying _owner. We want to avoid an L1 data cache miss on that\n-\/\/     same line for monitorexit. Putting these <remaining_fields>:\n-\/\/     _recursions, _EntryList, _cxq, and _succ, all of which may be\n-\/\/     fetched in the inflated unlock path, on a different cache line\n-\/\/     would make them immune to CAS-based invalidation from the _owner\n-\/\/     field.\n+\/\/ - Separating _owner from the <remaining_fields> by enough space to\n+\/\/   avoid false sharing might be profitable. Given that the CAS in\n+\/\/   monitorenter will invalidate the line underlying _owner. We want\n+\/\/   to avoid an L1 data cache miss on that same line for monitorexit.\n+\/\/   Putting these <remaining_fields>:\n+\/\/   _recursions, _EntryList, _cxq, and _succ, all of which may be\n+\/\/   fetched in the inflated unlock path, on a different cache line\n+\/\/   would make them immune to CAS-based invalidation from the _owner\n+\/\/   field.\n@@ -120,3 +121,3 @@\n-\/\/   - The _recursions field should be of type int, or int32_t but not\n-\/\/     intptr_t. There's no reason to use a 64-bit type for this field\n-\/\/     in a 64-bit JVM.\n+\/\/ - The _recursions field should be of type int, or int32_t but not\n+\/\/   intptr_t. There's no reason to use a 64-bit type for this field\n+\/\/   in a 64-bit JVM.\n@@ -134,3 +135,7 @@\n-  \/\/ The sync code expects the header field to be at offset zero (0).\n-  \/\/ Enforced by the assert() in header_addr().\n-  volatile markWord _header;        \/\/ displaced object header word - mark\n+  \/\/ The sync code expects the metadata field to be at offset zero (0).\n+  \/\/ Enforced by the assert() in metadata_addr().\n+  \/\/ * LM_LIGHTWEIGHT with UseObjectMonitorTable:\n+  \/\/ Contains the _object's hashCode.\n+  \/\/ * LM_LEGACY, LM_MONITOR, LM_LIGHTWEIGHT without UseObjectMonitorTable:\n+  \/\/ Contains the displaced object header word - mark\n+  volatile uintptr_t _metadata;     \/\/ metadata\n@@ -138,2 +143,2 @@\n-  \/\/ Separate _header and _owner on different cache lines since both can\n-  \/\/ have busy multi-threaded access. _header and _object are set at initial\n+  \/\/ Separate _metadata and _owner on different cache lines since both can\n+  \/\/ have busy multi-threaded access. _metadata and _object are set at initial\n@@ -141,2 +146,2 @@\n-  \/\/ its cache line with _header.\n-  DEFINE_PAD_MINUS_SIZE(0, OM_CACHE_LINE_SIZE, sizeof(volatile markWord) +\n+  \/\/ its cache line with _metadata.\n+  DEFINE_PAD_MINUS_SIZE(0, OM_CACHE_LINE_SIZE, sizeof(_metadata) +\n@@ -152,2 +157,3 @@\n-  #define DEFLATER_MARKER reinterpret_cast<void*>(2)\n-public:\n+  static const uintptr_t DEFLATER_MARKER_VALUE = 2;\n+  #define DEFLATER_MARKER reinterpret_cast<void*>(DEFLATER_MARKER_VALUE)\n+ public:\n@@ -157,1 +163,1 @@\n-private:\n+ private:\n@@ -184,1 +190,1 @@\n- protected:\n+\n@@ -187,1 +193,0 @@\n- private:\n@@ -216,0 +221,1 @@\n+  static ByteSize metadata_offset()    { return byte_offset_of(ObjectMonitor, _metadata); }\n@@ -236,3 +242,9 @@\n-  markWord           header() const;\n-  volatile markWord* header_addr();\n-  void               set_header(markWord hdr);\n+  uintptr_t           metadata() const;\n+  void                set_metadata(uintptr_t value);\n+  volatile uintptr_t* metadata_addr();\n+\n+  markWord            header() const;\n+  void                set_header(markWord hdr);\n+\n+  intptr_t            hash() const;\n+  void                set_hash(intptr_t hash);\n@@ -309,0 +321,2 @@\n+  bool      object_is_dead() const;\n+  bool      object_refers_to(oop obj) const;\n@@ -331,0 +345,2 @@\n+\n+  bool      enter_is_async_deflating();\n@@ -332,0 +348,1 @@\n+  void      enter_for_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark);\n@@ -334,0 +351,3 @@\n+  bool      try_enter(JavaThread* current);\n+  bool      spin_enter(JavaThread* current);\n+  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark);\n@@ -367,1 +387,2 @@\n-  bool      deflate_monitor();\n+  bool      deflate_monitor(Thread* current);\n+ private:\n@@ -371,0 +392,14 @@\n+\/\/ RAII object to ensure that ObjectMonitor::is_being_async_deflated() is\n+\/\/ stable within the context of this mark.\n+class ObjectMonitorContentionMark : StackObj {\n+  DEBUG_ONLY(friend class ObjectMonitor;)\n+\n+  ObjectMonitor* _monitor;\n+\n+  NONCOPYABLE(ObjectMonitorContentionMark);\n+\n+ public:\n+  explicit ObjectMonitorContentionMark(ObjectMonitor* monitor);\n+  ~ObjectMonitorContentionMark();\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":67,"deletions":32,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/markWord.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -35,0 +37,2 @@\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -52,2 +56,6 @@\n-inline markWord ObjectMonitor::header() const {\n-  return Atomic::load(&_header);\n+inline uintptr_t ObjectMonitor::metadata() const {\n+  return Atomic::load(&_metadata);\n+}\n+\n+inline void ObjectMonitor::set_metadata(uintptr_t value) {\n+  Atomic::store(&_metadata, value);\n@@ -56,2 +64,9 @@\n-inline volatile markWord* ObjectMonitor::header_addr() {\n-  return &_header;\n+inline volatile uintptr_t* ObjectMonitor::metadata_addr() {\n+  STATIC_ASSERT(std::is_standard_layout<ObjectMonitor>::value);\n+  STATIC_ASSERT(offsetof(ObjectMonitor, _metadata) == 0);\n+  return &_metadata;\n+}\n+\n+inline markWord ObjectMonitor::header() const {\n+  assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use header\");\n+  return markWord(metadata());\n@@ -61,1 +76,12 @@\n-  Atomic::store(&_header, hdr);\n+  assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use header\");\n+  set_metadata(hdr.value());\n+}\n+\n+inline intptr_t ObjectMonitor::hash() const {\n+  assert(UseObjectMonitorTable, \"Only used by lightweight locking with OM table\");\n+  return metadata();\n+}\n+\n+inline void ObjectMonitor::set_hash(intptr_t hash) {\n+  assert(UseObjectMonitorTable, \"Only used by lightweight locking with OM table\");\n+  set_metadata(hash);\n@@ -183,0 +209,27 @@\n+inline ObjectMonitorContentionMark::ObjectMonitorContentionMark(ObjectMonitor* monitor)\n+  : _monitor(monitor) {\n+  _monitor->add_to_contentions(1);\n+}\n+\n+inline ObjectMonitorContentionMark::~ObjectMonitorContentionMark() {\n+  _monitor->add_to_contentions(-1);\n+}\n+\n+inline oop ObjectMonitor::object_peek() const {\n+  if (_object.is_null()) {\n+    return nullptr;\n+  }\n+  return _object.peek();\n+}\n+\n+inline bool ObjectMonitor::object_is_dead() const {\n+  return object_peek() == nullptr;\n+}\n+\n+inline bool ObjectMonitor::object_refers_to(oop obj) const {\n+  if (_object.is_null()) {\n+    return false;\n+  }\n+  return _object.peek() == obj;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":58,"deletions":5,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1007,3 +1007,3 @@\n-          THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),\n-                      vmSymbols::throwable_void_signature(),\n-                      &args);\n+          THROW_ARG_NULL(vmSymbols::java_lang_reflect_InvocationTargetException(),\n+                         vmSymbols::throwable_void_signature(),\n+                         &args);\n@@ -1031,3 +1031,3 @@\n-            THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),\n-              vmSymbols::throwable_void_signature(),\n-              &args);\n+            THROW_ARG_NULL(vmSymbols::java_lang_reflect_InvocationTargetException(),\n+                           vmSymbols::throwable_void_signature(),\n+                           &args);\n@@ -1120,3 +1120,3 @@\n-    THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),\n-                vmSymbols::throwable_void_signature(),\n-                &args);\n+    THROW_ARG_NULL(vmSymbols::java_lang_reflect_InvocationTargetException(),\n+                   vmSymbols::throwable_void_signature(),\n+                   &args);\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -734,0 +734,5 @@\n+\n+  \/\/ The oops in the monitor cache are cleared to prevent stale cache entries\n+  \/\/ from keeping dead objects alive. Because these oops are always cleared\n+  \/\/ before safepoint operations they are not visited in JavaThread::oops_do.\n+  _thread->om_clear_monitor_cache();\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"memory\/universe.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -38,0 +38,3 @@\n+#include \"prims\/jvmtiImpl.hpp\"\n+#include \"prims\/jvmtiTagMap.hpp\"\n+#include \"prims\/resolvedMethodTable.hpp\"\n@@ -43,1 +46,1 @@\n-#include \"runtime\/serviceThread.hpp\"\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -46,3 +49,1 @@\n-#include \"prims\/jvmtiImpl.hpp\"\n-#include \"prims\/jvmtiTagMap.hpp\"\n-#include \"prims\/resolvedMethodTable.hpp\"\n+#include \"runtime\/serviceThread.hpp\"\n@@ -97,0 +98,1 @@\n+    bool object_monitor_table_work = false;\n@@ -124,1 +126,2 @@\n-              (oopmap_cache_work = OopMapCache::has_cleanup_work())\n+              (oopmap_cache_work = OopMapCache::has_cleanup_work()) |\n+              (object_monitor_table_work = LightweightSynchronizer::needs_resize())\n@@ -186,0 +189,4 @@\n+\n+    if (object_monitor_table_work) {\n+      LightweightSynchronizer::resize_table(jt);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -72,1 +73,2 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n+#include \"runtime\/timerTrace.hpp\"\n@@ -79,0 +81,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -89,1 +92,3 @@\n-\/\/ Shared stub locations\n+\/\/ Shared runtime stub routines reside in their own unique blob with a\n+\/\/ single entry point\n+\n@@ -96,1 +101,0 @@\n-address             SharedRuntime::_resolve_static_call_entry;\n@@ -103,0 +107,11 @@\n+RuntimeStub*        SharedRuntime::_throw_AbstractMethodError_blob;\n+RuntimeStub*        SharedRuntime::_throw_IncompatibleClassChangeError_blob;\n+RuntimeStub*        SharedRuntime::_throw_NullPointerException_at_call_blob;\n+RuntimeStub*        SharedRuntime::_throw_StackOverflowError_blob;\n+RuntimeStub*        SharedRuntime::_throw_delayed_StackOverflowError_blob;\n+\n+#if INCLUDE_JFR\n+RuntimeStub*        SharedRuntime::_jfr_write_checkpoint_blob = nullptr;\n+RuntimeStub*        SharedRuntime::_jfr_return_lease_blob = nullptr;\n+#endif\n+\n@@ -106,0 +121,7 @@\n+void SharedRuntime::generate_initial_stubs() {\n+  \/\/ Build this early so it's available for the interpreter.\n+  _throw_StackOverflowError_blob =\n+    generate_throw_exception(\"StackOverflowError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));\n+}\n+\n@@ -113,1 +135,16 @@\n-  _resolve_static_call_entry           = _resolve_static_call_blob->entry_point();\n+\n+  _throw_delayed_StackOverflowError_blob =\n+    generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError));\n+\n+  _throw_AbstractMethodError_blob =\n+    generate_throw_exception(\"AbstractMethodError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));\n+\n+  _throw_IncompatibleClassChangeError_blob =\n+    generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));\n+\n+  _throw_NullPointerException_at_call_blob =\n+    generate_throw_exception(\"NullPointerException at call throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));\n@@ -130,0 +167,13 @@\n+#if INCLUDE_JFR\n+\/\/------------------------------generate jfr runtime stubs ------\n+void SharedRuntime::generate_jfr_stubs() {\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_jfr_stubs\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  _jfr_write_checkpoint_blob = generate_jfr_write_checkpoint();\n+  _jfr_return_lease_blob = generate_jfr_return_lease();\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -868,1 +918,1 @@\n-        return StubRoutines::throw_StackOverflowError_entry();\n+        return SharedRuntime::throw_StackOverflowError_entry();\n@@ -894,1 +944,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -915,1 +965,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -926,1 +976,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -932,1 +982,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -1468,1 +1518,1 @@\n-  address res = StubRoutines::throw_AbstractMethodError_entry();\n+  address res = SharedRuntime::throw_AbstractMethodError_entry();\n@@ -1886,1 +1936,1 @@\n-    if (ObjectSynchronizer::quick_enter(obj, current, lock)) {\n+    if (ObjectSynchronizer::quick_enter(obj, lock, current)) {\n@@ -2388,1 +2438,1 @@\n-                                                                StubRoutines::throw_AbstractMethodError_entry(),\n+                                                                SharedRuntime::throw_AbstractMethodError_entry(),\n@@ -2948,0 +2998,2 @@\n+      } else if (UseObjectMonitorTable) {\n+        buf[i] = (intptr_t)lock->object_monitor_cache();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":64,"deletions":12,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-  static address             _resolve_static_call_entry;\n@@ -67,0 +66,11 @@\n+  static RuntimeStub*        _throw_AbstractMethodError_blob;\n+  static RuntimeStub*        _throw_IncompatibleClassChangeError_blob;\n+  static RuntimeStub*        _throw_NullPointerException_at_call_blob;\n+  static RuntimeStub*        _throw_StackOverflowError_blob;\n+  static RuntimeStub*        _throw_delayed_StackOverflowError_blob;\n+\n+#if INCLUDE_JFR\n+  static RuntimeStub*        _jfr_write_checkpoint_blob;\n+  static RuntimeStub*        _jfr_return_lease_blob;\n+#endif\n+\n@@ -76,1 +86,1 @@\n-\n+  static RuntimeStub*   generate_throw_exception(const char* name, address runtime_entry);\n@@ -78,0 +88,1 @@\n+  static void generate_initial_stubs(void);\n@@ -79,0 +90,9 @@\n+#if INCLUDE_JFR\n+  static void generate_jfr_stubs(void);\n+  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+  \/\/ It returns a jobject handle to the event writer.\n+  \/\/ The handle is dereferenced and the return value is the event writer oop.\n+  static RuntimeStub* generate_jfr_write_checkpoint();\n+  \/\/ For c2: call to runtime to return a buffer lease.\n+  static RuntimeStub* generate_jfr_return_lease();\n+#endif\n@@ -244,0 +264,12 @@\n+  \/\/ Implicit exceptions\n+  static address throw_AbstractMethodError_entry()          { return _throw_AbstractMethodError_blob->entry_point(); }\n+  static address throw_IncompatibleClassChangeError_entry() { return _throw_IncompatibleClassChangeError_blob->entry_point(); }\n+  static address throw_NullPointerException_at_call_entry() { return _throw_NullPointerException_at_call_blob->entry_point(); }\n+  static address throw_StackOverflowError_entry()           { return _throw_StackOverflowError_blob->entry_point(); }\n+  static address throw_delayed_StackOverflowError_entry()   { return _throw_delayed_StackOverflowError_blob->entry_point(); }\n+\n+#if INCLUDE_JFR\n+  static address jfr_write_checkpoint() { return _jfr_write_checkpoint_blob->entry_point(); }\n+  static address jfr_return_lease()     { return _jfr_return_lease_blob->entry_point(); }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -64,5 +64,0 @@\n-address StubRoutines::_throw_AbstractMethodError_entry          = nullptr;\n-address StubRoutines::_throw_IncompatibleClassChangeError_entry = nullptr;\n-address StubRoutines::_throw_NullPointerException_at_call_entry = nullptr;\n-address StubRoutines::_throw_StackOverflowError_entry           = nullptr;\n-address StubRoutines::_throw_delayed_StackOverflowError_entry   = nullptr;\n@@ -194,5 +189,0 @@\n-JFR_ONLY(RuntimeStub* StubRoutines::_jfr_write_checkpoint_stub = nullptr;)\n-JFR_ONLY(address StubRoutines::_jfr_write_checkpoint = nullptr;)\n-JFR_ONLY(RuntimeStub* StubRoutines::_jfr_return_lease_stub = nullptr;)\n-JFR_ONLY(address StubRoutines::_jfr_return_lease = nullptr;)\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,28 @@\n-\/\/ points are defined in the platform-specific inner class.\n+\/\/ points are defined in the platform-specific inner class. Most\n+\/\/ routines have a single (main) entry point. However, a few routines\n+\/\/ do provide alternative entry points.\n+\/\/\n+\/\/ Stub routines whose entries are advertised via class StubRoutines\n+\/\/ are generated in batches at well-defined stages during JVM init:\n+\/\/ initial stubs, continuation stubs, compiler stubs, final stubs.\n+\/\/ Each batch is embedded in a single, associated blob (an instance of\n+\/\/ BufferBlob) i.e. the blob to entry relationship is 1-m.\n+\/\/\n+\/\/ Note that this constrasts with the much smaller number of stub\n+\/\/ routines generated via classes SharedRuntime, c1_Runtime1 and\n+\/\/ OptoRuntime. The latter routines are also generated at well-defined\n+\/\/ points during JVM init. However, each stub routine has its own\n+\/\/ unique blob (various subclasses of RuntimeBlob) i.e. the blob to\n+\/\/ entry relationship is 1-1. The difference arises because\n+\/\/ SharedRuntime routines may need to be relocatable or advertise\n+\/\/ properties such as a frame size via their blob.\n+\/\/\n+\/\/ Staging of stub routine generation is needed in order to manage\n+\/\/ init dependencies between 1) stubs and other stubs or 2) stubs and\n+\/\/ other runtime components. For example, some exception throw stubs\n+\/\/ need to be generated before compiler stubs (such as the\n+\/\/ deoptimization stub) so that the latter can invoke the thrwo rotine\n+\/\/ in bail-out code. Likewise, stubs that access objects (such as the\n+\/\/ object array copy stub) need to be created after initialization of\n+\/\/ some GC constants and generation of the GC barrier stubs they might\n+\/\/ need to invoke.\n@@ -52,2 +79,1 @@\n-\/\/    stubRoutines_<os_family>.cpp       stubGenerator_<arch>.cpp\n-\/\/    stubRoutines_<os_arch>.cpp\n+\/\/                                       stubGenerator_<arch>.cpp\n@@ -78,0 +104,2 @@\n+\/\/ 5. ensure the entry is generated in the right blob to satisfy initialization\n+\/\/    dependencies between it and other stubs or runtime components.\n@@ -140,5 +168,0 @@\n-  static address _throw_AbstractMethodError_entry;\n-  static address _throw_IncompatibleClassChangeError_entry;\n-  static address _throw_NullPointerException_at_call_entry;\n-  static address _throw_StackOverflowError_entry;\n-  static address _throw_delayed_StackOverflowError_entry;\n@@ -272,5 +295,0 @@\n-  JFR_ONLY(static RuntimeStub* _jfr_write_checkpoint_stub;)\n-  JFR_ONLY(static address _jfr_write_checkpoint;)\n-  JFR_ONLY(static RuntimeStub* _jfr_return_lease_stub;)\n-  JFR_ONLY(static address _jfr_return_lease;)\n-\n@@ -332,6 +350,0 @@\n-  \/\/ Implicit exceptions\n-  static address throw_AbstractMethodError_entry()         { return _throw_AbstractMethodError_entry; }\n-  static address throw_IncompatibleClassChangeError_entry(){ return _throw_IncompatibleClassChangeError_entry; }\n-  static address throw_NullPointerException_at_call_entry(){ return _throw_NullPointerException_at_call_entry; }\n-  static address throw_StackOverflowError_entry()          { return _throw_StackOverflowError_entry; }\n-  static address throw_delayed_StackOverflowError_entry()  { return _throw_delayed_StackOverflowError_entry; }\n@@ -490,3 +502,0 @@\n-  JFR_ONLY(static address jfr_write_checkpoint() { return _jfr_write_checkpoint; })\n-  JFR_ONLY(static address jfr_return_lease() { return _jfr_return_lease; })\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":31,"deletions":22,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -44,0 +45,1 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -55,1 +57,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -279,0 +281,4 @@\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LightweightSynchronizer::initialize();\n+  }\n@@ -352,1 +358,5 @@\n-    ObjectMonitor* const mon = mark.monitor();\n+    ObjectMonitor* const mon = read_monitor(current, obj, mark);\n+    if (LockingMode == LM_LIGHTWEIGHT && mon == nullptr) {\n+      \/\/ Racing with inflation\/deflation go slow path\n+      return false;\n+    }\n@@ -379,0 +389,7 @@\n+static bool useHeavyMonitors() {\n+#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64) || defined(S390)\n+  return LockingMode == LM_MONITOR;\n+#else\n+  return false;\n+#endif\n+}\n@@ -386,2 +403,1 @@\n-bool ObjectSynchronizer::quick_enter(oop obj, JavaThread* current,\n-                                     BasicLock * lock) {\n+bool ObjectSynchronizer::quick_enter_legacy(oop obj, BasicLock* lock, JavaThread* current) {\n@@ -389,2 +405,0 @@\n-  NoSafepointVerifier nsv;\n-  if (obj == nullptr) return false;       \/\/ Need to throw NPE\n@@ -392,2 +406,2 @@\n-  if (obj->klass()->is_value_based()) {\n-    return false;\n+  if (useHeavyMonitors()) {\n+    return false;  \/\/ Slow path\n@@ -397,10 +411,1 @@\n-    LockStack& lock_stack = current->lock_stack();\n-    if (lock_stack.is_full()) {\n-      \/\/ Always go into runtime if the lock stack is full.\n-      return false;\n-    }\n-    if (lock_stack.try_recursive_enter(obj)) {\n-      \/\/ Recursive lock successful.\n-      current->inc_held_monitor_count();\n-      return true;\n-    }\n+    return LightweightSynchronizer::quick_enter(obj, lock, current);\n@@ -409,0 +414,2 @@\n+  assert(LockingMode == LM_LEGACY, \"legacy mode below\");\n+\n@@ -412,1 +419,2 @@\n-    ObjectMonitor* const m = mark.monitor();\n+\n+    ObjectMonitor* const m = read_monitor(mark);\n@@ -432,12 +440,10 @@\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ This Java Monitor is inflated so obj's header will never be\n-      \/\/ displaced to this thread's BasicLock. Make the displaced header\n-      \/\/ non-null so this BasicLock is not seen as recursive nor as\n-      \/\/ being locked. We do this unconditionally so that this thread's\n-      \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n-      \/\/ performance reasons, stack walkers generally first check for\n-      \/\/ stack-locking in the object's header, the second check is for\n-      \/\/ recursive stack-locking in the displaced header in the BasicLock,\n-      \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n-      lock->set_displaced_header(markWord::unused_mark());\n-    }\n+    \/\/ This Java Monitor is inflated so obj's header will never be\n+    \/\/ displaced to this thread's BasicLock. Make the displaced header\n+    \/\/ non-null so this BasicLock is not seen as recursive nor as\n+    \/\/ being locked. We do this unconditionally so that this thread's\n+    \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n+    \/\/ performance reasons, stack walkers generally first check for\n+    \/\/ stack-locking in the object's header, the second check is for\n+    \/\/ recursive stack-locking in the displaced header in the BasicLock,\n+    \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n+    lock->set_displaced_header(markWord::unused_mark());\n@@ -511,8 +517,0 @@\n-static bool useHeavyMonitors() {\n-#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64) || defined(S390)\n-  return LockingMode == LM_MONITOR;\n-#else\n-  return false;\n-#endif\n-}\n-\n@@ -527,0 +525,5 @@\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    return LightweightSynchronizer::enter_for(obj, lock, locking_thread);\n+  }\n+\n@@ -543,2 +546,1 @@\n-void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n-  assert(current == Thread::current(), \"must be\");\n+void ObjectSynchronizer::enter_legacy(Handle obj, BasicLock* lock, JavaThread* current) {\n@@ -564,0 +566,1 @@\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"Use LightweightSynchronizer\");\n@@ -572,55 +575,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast-locking does not use the 'lock' argument.\n-      LockStack& lock_stack = locking_thread->lock_stack();\n-      if (lock_stack.is_full()) {\n-        \/\/ We unconditionally make room on the lock stack by inflating\n-        \/\/ the least recently locked object on the lock stack.\n-\n-        \/\/ About the choice to inflate least recently locked object.\n-        \/\/ First we must chose to inflate a lock, either some lock on\n-        \/\/ the lock-stack or the lock that is currently being entered\n-        \/\/ (which may or may not be on the lock-stack).\n-        \/\/ Second the best lock to inflate is a lock which is entered\n-        \/\/ in a control flow where there are only a very few locks being\n-        \/\/ used, as the costly part of inflated locking is inflation,\n-        \/\/ not locking. But this property is entirely program dependent.\n-        \/\/ Third inflating the lock currently being entered on when it\n-        \/\/ is not present on the lock-stack will result in a still full\n-        \/\/ lock-stack. This creates a scenario where every deeper nested\n-        \/\/ monitorenter must call into the runtime.\n-        \/\/ The rational here is as follows:\n-        \/\/ Because we cannot (currently) figure out the second, and want\n-        \/\/ to avoid the third, we inflate a lock on the lock-stack.\n-        \/\/ The least recently locked lock is chosen as it is the lock\n-        \/\/ with the longest critical section.\n-\n-        log_info(monitorinflation)(\"LockStack capacity exceeded, inflating.\");\n-        ObjectMonitor* monitor = inflate_for(locking_thread, lock_stack.bottom(), inflate_cause_vm_internal);\n-        assert(monitor->owner() == locking_thread, \"must be owner=\" PTR_FORMAT \" locking_thread=\" PTR_FORMAT \" mark=\" PTR_FORMAT,\n-               p2i(monitor->owner()), p2i(locking_thread), monitor->object()->mark_acquire().value());\n-        assert(!lock_stack.is_full(), \"must have made room here\");\n-      }\n-\n-      markWord mark = obj()->mark_acquire();\n-      while (mark.is_unlocked()) {\n-        \/\/ Retry until a lock state change has been observed. cas_set_mark() may collide with non lock bits modifications.\n-        \/\/ Try to swing into 'fast-locked' state.\n-        assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n-        const markWord locked_mark = mark.set_fast_locked();\n-        const markWord old_mark = obj()->cas_set_mark(locked_mark, mark);\n-        if (old_mark == mark) {\n-          \/\/ Successfully fast-locked, push object to lock-stack and return.\n-          lock_stack.push(obj());\n-          return true;\n-        }\n-        mark = old_mark;\n-      }\n-\n-      if (mark.is_fast_locked() && lock_stack.try_recursive_enter(obj())) {\n-        \/\/ Recursive lock successful.\n-        return true;\n-      }\n-\n-      \/\/ Failed to fast lock.\n-      return false;\n-    } else if (LockingMode == LM_LEGACY) {\n+    if (LockingMode == LM_LEGACY) {\n@@ -659,2 +608,2 @@\n-void ObjectSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n-  current->dec_held_monitor_count();\n+void ObjectSynchronizer::exit_legacy(oop object, BasicLock* lock, JavaThread* current) {\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"Use LightweightSynchronizer\");\n@@ -664,26 +613,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast-locking does not use the 'lock' argument.\n-      LockStack& lock_stack = current->lock_stack();\n-      if (mark.is_fast_locked() && lock_stack.try_recursive_exit(object)) {\n-        \/\/ Recursively unlocked.\n-        return;\n-      }\n-\n-      if (mark.is_fast_locked() && lock_stack.is_recursive(object)) {\n-        \/\/ This lock is recursive but is not at the top of the lock stack so we're\n-        \/\/ doing an unbalanced exit. We have to fall thru to inflation below and\n-        \/\/ let ObjectMonitor::exit() do the unlock.\n-      } else {\n-        while (mark.is_fast_locked()) {\n-          \/\/ Retry until a lock state change has been observed. cas_set_mark() may collide with non lock bits modifications.\n-          const markWord unlocked_mark = mark.set_unlocked();\n-          const markWord old_mark = object->cas_set_mark(unlocked_mark, mark);\n-          if (old_mark == mark) {\n-            size_t recursions = lock_stack.remove(object) - 1;\n-            assert(recursions == 0, \"must not be recursive here\");\n-            return;\n-          }\n-          mark = old_mark;\n-        }\n-      }\n-    } else if (LockingMode == LM_LEGACY) {\n+    if (LockingMode == LM_LEGACY) {\n@@ -711,1 +635,1 @@\n-            ObjectMonitor* m = mark.monitor();\n+            ObjectMonitor* m = read_monitor(mark);\n@@ -755,2 +679,10 @@\n-    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_jni_enter);\n-    if (monitor->enter(current)) {\n+    ObjectMonitor* monitor;\n+    bool entered;\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      entered = LightweightSynchronizer::inflate_and_enter(obj(), inflate_cause_jni_enter, current, current) != nullptr;\n+    } else {\n+      monitor = inflate(current, obj(), inflate_cause_jni_enter);\n+      entered = monitor->enter(current);\n+    }\n+\n+    if (entered) {\n@@ -768,3 +700,8 @@\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n-  ObjectMonitor* monitor = inflate(current, obj, inflate_cause_jni_exit);\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj, inflate_cause_jni_exit, CHECK);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+    \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n+    monitor = inflate(current, obj, inflate_cause_jni_exit);\n+  }\n@@ -803,0 +740,1 @@\n+\n@@ -808,4 +746,10 @@\n-  \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n-  \/\/ field is incremented before ownership is dropped and decremented\n-  \/\/ after ownership is regained.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_wait);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK_0);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n+    \/\/ field is incremented before ownership is dropped and decremented\n+    \/\/ after ownership is regained.\n+    monitor = inflate(current, obj(), inflate_cause_wait);\n+  }\n@@ -828,3 +772,8 @@\n-  ObjectSynchronizer::inflate(THREAD,\n-                              obj(),\n-                              inflate_cause_wait)->wait(millis, false, THREAD);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK);\n+  } else {\n+    monitor = inflate(THREAD, obj(), inflate_cause_wait);\n+  }\n+  monitor->wait(millis, false, THREAD);\n@@ -849,3 +798,9 @@\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped by the calling thread.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_notify);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+    \/\/ dropped by the calling thread.\n+    monitor = inflate(current, obj(), inflate_cause_notify);\n+  }\n@@ -871,3 +826,9 @@\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped by the calling thread.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_notify);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+    \/\/ dropped by the calling thread.\n+    monitor = inflate(current, obj(), inflate_cause_notify);\n+  }\n@@ -971,1 +932,1 @@\n-static inline intptr_t get_next_hash(Thread* current, oop obj) {\n+static intptr_t get_next_hash(Thread* current, oop obj) {\n@@ -1011,0 +972,21 @@\n+static intptr_t install_hash_code(Thread* current, oop obj) {\n+  assert(UseObjectMonitorTable && LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+\n+  markWord mark = obj->mark_acquire();\n+  for (;;) {\n+    intptr_t hash = mark.hash();\n+    if (hash != 0) {\n+      return hash;\n+    }\n+\n+    hash = get_next_hash(current, obj);\n+    const markWord old_mark = mark;\n+    const markWord new_mark = old_mark.copy_set_hash(hash);\n+\n+    mark = obj->cas_set_mark(new_mark, old_mark);\n+    if (old_mark == mark) {\n+      return hash;\n+    }\n+  }\n+}\n+\n@@ -1012,0 +994,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Since the monitor isn't in the object header, the hash can simply be\n+    \/\/ installed in the object header.\n+    return install_hash_code(current, obj);\n+  }\n@@ -1105,1 +1092,1 @@\n-      uintptr_t v = Atomic::cmpxchg((volatile uintptr_t*)monitor->header_addr(), mark.value(), temp.value());\n+      uintptr_t v = Atomic::cmpxchg(monitor->metadata_addr(), mark.value(), temp.value());\n@@ -1117,1 +1104,1 @@\n-      if (monitor->is_being_async_deflated()) {\n+      if (monitor->is_being_async_deflated() && !UseObjectMonitorTable) {\n@@ -1148,1 +1135,15 @@\n-  if (mark.has_monitor()) {\n+  while (LockingMode == LM_LIGHTWEIGHT && mark.has_monitor()) {\n+    ObjectMonitor* monitor = read_monitor(current, obj, mark);\n+    if (monitor != nullptr) {\n+      return monitor->is_entered(current) != 0;\n+    }\n+    \/\/ Racing with inflation\/deflation, retry\n+    mark = obj->mark_acquire();\n+\n+    if (mark.is_fast_locked()) {\n+      \/\/ Some other thread fast_locked, current could not have held the lock\n+      return false;\n+    }\n+  }\n+\n+  if (LockingMode != LM_LIGHTWEIGHT && mark.has_monitor()) {\n@@ -1152,1 +1153,1 @@\n-    ObjectMonitor* monitor = mark.monitor();\n+    ObjectMonitor* monitor = read_monitor(mark);\n@@ -1176,1 +1177,15 @@\n-  if (mark.has_monitor()) {\n+  while (LockingMode == LM_LIGHTWEIGHT && mark.has_monitor()) {\n+    ObjectMonitor* monitor = read_monitor(Thread::current(), obj, mark);\n+    if (monitor != nullptr) {\n+      return Threads::owning_thread_from_monitor(t_list, monitor);\n+    }\n+    \/\/ Racing with inflation\/deflation, retry\n+    mark = obj->mark_acquire();\n+\n+    if (mark.is_fast_locked()) {\n+      \/\/ Some other thread fast_locked\n+      return Threads::owning_thread_from_object(t_list, h_obj());\n+    }\n+  }\n+\n+  if (LockingMode != LM_LIGHTWEIGHT && mark.has_monitor()) {\n@@ -1180,1 +1195,1 @@\n-    ObjectMonitor* monitor = mark.monitor();\n+    ObjectMonitor* monitor = read_monitor(mark);\n@@ -1392,0 +1407,1 @@\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"only inflate through enter\");\n@@ -1394,1 +1410,1 @@\n-    ObjectMonitor* monitor = mark.monitor();\n+    ObjectMonitor* monitor = read_monitor(mark);\n@@ -1404,4 +1420,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT && current->is_Java_thread()) {\n-    return inflate_impl(JavaThread::cast(current), obj, cause);\n-  }\n-  return inflate_impl(nullptr, obj, cause);\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"only inflate through enter\");\n+  return inflate_impl(obj, cause);\n@@ -1412,12 +1426,6 @@\n-  return inflate_impl(thread, obj, cause);\n-}\n-\n-ObjectMonitor* ObjectSynchronizer::inflate_impl(JavaThread* inflating_thread, oop object, const InflateCause cause) {\n-  \/\/ The JavaThread* inflating_thread parameter is only used by LM_LIGHTWEIGHT and requires\n-  \/\/ that the inflating_thread == Thread::current() or is suspended throughout the call by\n-  \/\/ some other mechanism.\n-  \/\/ Even with LM_LIGHTWEIGHT the thread might be nullptr when called from a non\n-  \/\/ JavaThread. (As may still be the case from FastHashCode). However it is only\n-  \/\/ important for the correctness of the LM_LIGHTWEIGHT algorithm that the thread\n-  \/\/ is set when called from ObjectSynchronizer::enter from the owning thread,\n-  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"LM_LIGHTWEIGHT cannot use inflate_for\");\n+  return inflate_impl(obj, cause);\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::inflate_impl(oop object, const InflateCause cause) {\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"LM_LIGHTWEIGHT cannot use inflate_impl\");\n@@ -1430,7 +1438,1 @@\n-    \/\/ *  inflated     - Just return if using stack-locking.\n-    \/\/                   If using fast-locking and the ObjectMonitor owner\n-    \/\/                   is anonymous and the inflating_thread owns the\n-    \/\/                   object lock, then we make the inflating_thread\n-    \/\/                   the ObjectMonitor owner and remove the lock from\n-    \/\/                   the inflating_thread's lock stack.\n-    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  inflated     - Just return it.\n@@ -1447,6 +1449,0 @@\n-      if (LockingMode == LM_LIGHTWEIGHT && inf->is_owner_anonymous() &&\n-          inflating_thread != nullptr && inflating_thread->lock_stack().contains(object)) {\n-        inf->set_owner_from_anonymous(inflating_thread);\n-        size_t removed = inflating_thread->lock_stack().remove(object);\n-        inf->set_recursions(removed - 1);\n-      }\n@@ -1456,65 +1452,9 @@\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ New lightweight locking does not use INFLATING.\n-      \/\/ CASE: inflation in progress - inflating over a stack-lock.\n-      \/\/ Some other thread is converting from stack-locked to inflated.\n-      \/\/ Only that thread can complete inflation -- other threads must wait.\n-      \/\/ The INFLATING value is transient.\n-      \/\/ Currently, we spin\/yield\/park and poll the markword, waiting for inflation to finish.\n-      \/\/ We could always eliminate polling by parking the thread on some auxiliary list.\n-      if (mark == markWord::INFLATING()) {\n-        read_stable_mark(object);\n-        continue;\n-      }\n-    }\n-\n-    \/\/ CASE: fast-locked\n-    \/\/ Could be fast-locked either by the inflating_thread or by some other thread.\n-    \/\/\n-    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_\n-    \/\/ attempting to set the object's mark to the new ObjectMonitor. If\n-    \/\/ the inflating_thread owns the monitor, then we set the ObjectMonitor's\n-    \/\/ owner to the inflating_thread. Otherwise, we set the ObjectMonitor's owner\n-    \/\/ to anonymous. If we lose the race to set the object's mark to the\n-    \/\/ new ObjectMonitor, then we just delete it and loop around again.\n-    \/\/\n-    LogStreamHandle(Trace, monitorinflation) lsh;\n-    if (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked()) {\n-      ObjectMonitor* monitor = new ObjectMonitor(object);\n-      monitor->set_header(mark.set_unlocked());\n-      bool own = inflating_thread != nullptr && inflating_thread->lock_stack().contains(object);\n-      if (own) {\n-        \/\/ Owned by inflating_thread.\n-        monitor->set_owner_from(nullptr, inflating_thread);\n-      } else {\n-        \/\/ Owned by somebody else.\n-        monitor->set_owner_anonymous();\n-      }\n-      markWord monitor_mark = markWord::encode(monitor);\n-      markWord old_mark = object->cas_set_mark(monitor_mark, mark);\n-      if (old_mark == mark) {\n-        \/\/ Success! Return inflated monitor.\n-        if (own) {\n-          size_t removed = inflating_thread->lock_stack().remove(object);\n-          monitor->set_recursions(removed - 1);\n-        }\n-        \/\/ Once the ObjectMonitor is configured and object is associated\n-        \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n-        _in_use_list.add(monitor);\n-\n-        \/\/ Hopefully the performance counters are allocated on distinct\n-        \/\/ cache lines to avoid false sharing on MP systems ...\n-        OM_PERFDATA_OP(Inflations, inc());\n-        if (log_is_enabled(Trace, monitorinflation)) {\n-          ResourceMark rm;\n-          lsh.print_cr(\"inflate(has_locker): object=\" INTPTR_FORMAT \", mark=\"\n-                       INTPTR_FORMAT \", type='%s'\", p2i(object),\n-                       object->mark().value(), object->klass()->external_name());\n-        }\n-        if (event.should_commit()) {\n-          post_monitor_inflate_event(&event, object, cause);\n-        }\n-        return monitor;\n-      } else {\n-        delete monitor;\n-        continue;  \/\/ Interference -- just retry\n-      }\n+    \/\/ CASE: inflation in progress - inflating over a stack-lock.\n+    \/\/ Some other thread is converting from stack-locked to inflated.\n+    \/\/ Only that thread can complete inflation -- other threads must wait.\n+    \/\/ The INFLATING value is transient.\n+    \/\/ Currently, we spin\/yield\/park and poll the markword, waiting for inflation to finish.\n+    \/\/ We could always eliminate polling by parking the thread on some auxiliary list.\n+    if (mark == markWord::INFLATING()) {\n+      read_stable_mark(object);\n+      continue;\n@@ -1534,0 +1474,1 @@\n+    LogStreamHandle(Trace, monitorinflation) lsh;\n@@ -1535,1 +1476,0 @@\n-      assert(LockingMode != LM_LIGHTWEIGHT, \"cannot happen with new lightweight locking\");\n@@ -1667,0 +1607,1 @@\n+  Thread* current = Thread::current();\n@@ -1673,1 +1614,1 @@\n-    if (mid->deflate_monitor()) {\n+    if (mid->deflate_monitor(current)) {\n@@ -1691,0 +1632,5 @@\n+    if (thread->is_Java_thread()) {\n+      \/\/ Clear OM cache\n+      JavaThread* jt = JavaThread::cast(thread);\n+      jt->om_clear_monitor_cache();\n+    }\n@@ -1837,0 +1783,8 @@\n+#ifdef ASSERT\n+    if (UseObjectMonitorTable) {\n+      for (ObjectMonitor* monitor : delete_list) {\n+        assert(!LightweightSynchronizer::contains_monitor(current, monitor), \"Should have been removed\");\n+      }\n+    }\n+#endif\n+\n@@ -2045,1 +1999,2 @@\n-  if (n->header().value() == 0) {\n+\n+  if (n->metadata() == 0) {\n@@ -2047,1 +2002,1 @@\n-                  \"have non-null _header field.\", p2i(n));\n+                  \"have non-null _metadata (header\/hash) field.\", p2i(n));\n@@ -2050,0 +2005,1 @@\n+\n@@ -2051,17 +2007,21 @@\n-  if (obj != nullptr) {\n-    const markWord mark = obj->mark();\n-    if (!mark.has_monitor()) {\n-      out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n-                    \"object does not think it has a monitor: obj=\"\n-                    INTPTR_FORMAT \", mark=\" INTPTR_FORMAT, p2i(n),\n-                    p2i(obj), mark.value());\n-      *error_cnt_p = *error_cnt_p + 1;\n-    }\n-    ObjectMonitor* const obj_mon = mark.monitor();\n-    if (n != obj_mon) {\n-      out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n-                    \"object does not refer to the same monitor: obj=\"\n-                    INTPTR_FORMAT \", mark=\" INTPTR_FORMAT \", obj_mon=\"\n-                    INTPTR_FORMAT, p2i(n), p2i(obj), mark.value(), p2i(obj_mon));\n-      *error_cnt_p = *error_cnt_p + 1;\n-    }\n+  if (obj == nullptr) {\n+    return;\n+  }\n+\n+  const markWord mark = obj->mark();\n+  if (!mark.has_monitor()) {\n+    out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n+                  \"object does not think it has a monitor: obj=\"\n+                  INTPTR_FORMAT \", mark=\" INTPTR_FORMAT, p2i(n),\n+                  p2i(obj), mark.value());\n+    *error_cnt_p = *error_cnt_p + 1;\n+    return;\n+  }\n+\n+  ObjectMonitor* const obj_mon = read_monitor(Thread::current(), obj, mark);\n+  if (n != obj_mon) {\n+    out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n+                  \"object does not refer to the same monitor: obj=\"\n+                  INTPTR_FORMAT \", mark=\" INTPTR_FORMAT \", obj_mon=\"\n+                  INTPTR_FORMAT, p2i(n), p2i(obj), mark.value(), p2i(obj_mon));\n+    *error_cnt_p = *error_cnt_p + 1;\n@@ -2090,1 +2050,1 @@\n-        const markWord mark = monitor->header();\n+        const intptr_t hash = UseObjectMonitorTable ? monitor->hash() : monitor->header().hash();\n@@ -2093,1 +2053,1 @@\n-                   monitor->is_busy(), mark.hash() != 0, monitor->owner() != nullptr,\n+                   monitor->is_busy(), hash != 0, monitor->owner() != nullptr,\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":228,"deletions":268,"binary":false,"changes":496,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -96,2 +97,3 @@\n-  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n-  static void exit(oop obj, BasicLock* lock, JavaThread* current);\n+  static inline void enter(Handle obj, BasicLock* lock, JavaThread* current);\n+  static inline void exit(oop obj, BasicLock* lock, JavaThread* current);\n+\n@@ -109,0 +111,3 @@\n+  static bool quick_enter_legacy(oop obj, BasicLock* Lock, JavaThread* current);\n+  static void enter_legacy(Handle obj, BasicLock* Lock, JavaThread* current);\n+  static void exit_legacy(oop obj, BasicLock* lock, JavaThread* current);\n@@ -121,1 +126,1 @@\n-  static bool quick_enter(oop obj, JavaThread* current, BasicLock* Lock);\n+  static inline bool quick_enter(oop obj, BasicLock* Lock, JavaThread* current);\n@@ -135,1 +140,1 @@\n-  static ObjectMonitor* inflate_impl(JavaThread* thread, oop obj, const InflateCause cause);\n+  static ObjectMonitor* inflate_impl(oop obj, const InflateCause cause);\n@@ -142,0 +147,3 @@\n+  inline static ObjectMonitor* read_monitor(markWord mark);\n+  inline static ObjectMonitor* read_monitor(Thread* current, oop obj, markWord mark);\n+\n@@ -203,0 +211,1 @@\n+  friend class LightweightSynchronizer;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_SYNCHRONIZER_INLINE_HPP\n+#define SHARE_RUNTIME_SYNCHRONIZER_INLINE_HPP\n+\n+#include \"runtime\/synchronizer.hpp\"\n+\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+\n+inline ObjectMonitor* ObjectSynchronizer::read_monitor(markWord mark) {\n+  return mark.monitor();\n+}\n+\n+inline ObjectMonitor* ObjectSynchronizer::read_monitor(Thread* current, oop obj, markWord mark) {\n+  if (!UseObjectMonitorTable) {\n+    return read_monitor(mark);\n+  } else {\n+    return LightweightSynchronizer::get_monitor_from_table(current, obj);\n+  }\n+}\n+\n+inline void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n+  assert(current == Thread::current(), \"must be\");\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LightweightSynchronizer::enter(obj, lock, current);\n+  } else {\n+    enter_legacy(obj, lock, current);\n+  }\n+}\n+\n+inline bool ObjectSynchronizer::quick_enter(oop obj, BasicLock* lock, JavaThread* current) {\n+  assert(current->thread_state() == _thread_in_Java, \"invariant\");\n+  NoSafepointVerifier nsv;\n+  if (obj == nullptr) return false;       \/\/ Need to throw NPE\n+\n+  if (obj->klass()->is_value_based()) {\n+    return false;\n+  }\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    return LightweightSynchronizer::quick_enter(obj, lock, current);\n+  } else {\n+    return quick_enter_legacy(obj, lock, current);\n+  }\n+}\n+\n+inline void ObjectSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n+  current->dec_held_monitor_count();\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LightweightSynchronizer::exit(object, current);\n+  } else {\n+    exit_legacy(object, lock, current);\n+  }\n+}\n+\n+#endif \/\/ SHARE_RUNTIME_SYNCHRONIZER_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -53,1 +53,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -250,3 +250,6 @@\n-          if (mark.has_monitor() &&\n-              ( \/\/ we have marked ourself as pending on this monitor\n-                mark.monitor() == thread()->current_pending_monitor() ||\n+          if (mark.has_monitor()) {\n+            ObjectMonitor* mon = ObjectSynchronizer::read_monitor(current, monitor->owner(), mark);\n+            if (\/\/ if the monitor is null we must be in the process of locking\n+                mon == nullptr ||\n+                \/\/ we have marked ourself as pending on this monitor\n+                mon == thread()->current_pending_monitor() ||\n@@ -254,3 +257,3 @@\n-                !mark.monitor()->is_entered(thread())\n-              )) {\n-            lock_state = \"waiting to lock\";\n+                !mon->is_entered(thread())) {\n+              lock_state = \"waiting to lock\";\n+            }\n@@ -622,1 +625,1 @@\n-  if (WizardMode) _fr.print_value_on(output, nullptr);\n+  if (WizardMode) _fr.print_value_on(output);\n@@ -737,1 +740,1 @@\n-  _fr.print_value_on(output, nullptr);\n+  _fr.print_value_on(output);\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -90,1 +90,2 @@\n-  template(JFRCheckpoint)                         \\\n+  template(JFRSafepointClear)                     \\\n+  template(JFRSafepointWrite)                     \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -249,1 +249,0 @@\n-  nonstatic_field(InstanceKlass,               _is_marked_dependent,                          bool)                                  \\\n@@ -781,1 +780,1 @@\n-  volatile_nonstatic_field(ObjectMonitor,      _header,                                       markWord)                              \\\n+  volatile_nonstatic_field(ObjectMonitor,      _metadata,                                     uintptr_t)                             \\\n@@ -785,1 +784,1 @@\n-  volatile_nonstatic_field(BasicLock,          _displaced_header,                             markWord)                              \\\n+  volatile_nonstatic_field(BasicLock,          _metadata,                                     uintptr_t)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,0 +131,16 @@\n+bool ClassLoadingService::get_verbose() {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n+    \/\/ set_verbose looks for a non-exact match for class+load,\n+    \/\/ so look for all tag sets that match class+load*\n+    if (ts->contains(LogTag::_class) &&\n+        ts->contains(LogTag::_load)) {\n+      LogLevelType l = ts->level_for(LogConfiguration::StdoutLog);\n+      if (l != LogLevel::Info && l != LogLevel::Debug && l != LogLevel::Trace) {\n+        return false;\n+      }\n+    }\n+  }\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/classLoadingService.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+  static bool get_verbose() NOT_MANAGEMENT_RETURN_(false);\n@@ -66,1 +67,0 @@\n-  static bool get_verbose() { return log_is_enabled(Info, class, load); }\n","filename":"src\/hotspot\/share\/services\/classLoadingService.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -205,0 +205,15 @@\n+bool MemoryService::get_verbose() {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n+    \/\/ set_verbose only sets gc and not gc*, so check for an exact match\n+    const bool is_gc_exact_match = ts->contains(LogTag::_gc) && ts->ntags() == 1;\n+    if (is_gc_exact_match) {\n+      LogLevelType l = ts->level_for(LogConfiguration::StdoutLog);\n+      if (l == LogLevel::Info || l == LogLevel::Debug || l == LogLevel::Trace) {\n+        return true;\n+      }\n+    }\n+  }\n+\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/memoryService.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,0 @@\n-  static bool get_verbose() { return log_is_enabled(Info, gc); }\n@@ -111,0 +110,1 @@\n+  static bool get_verbose();\n","filename":"src\/hotspot\/share\/services\/memoryService.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -154,1 +154,3 @@\n-void ExceptionsEventLog::log(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {\n+void ExceptionsEventLog::log(Thread* thread, Handle h_exception,\n+                             const char* message, const char* file, int line,\n+                             int message_length_limit) {\n@@ -166,1 +168,5 @@\n-  st.print(\"%s%s> (\" PTR_FORMAT \") \\n\"\n+  if (message != nullptr) {\n+    int len = message_length_limit > 0 ? message_length_limit : (int)strlen(message);\n+    st.print(\": %.*s\", len, message);\n+  }\n+  st.print(\"> (\" PTR_FORMAT \") \\n\"\n@@ -168,1 +174,0 @@\n-           message ? \": \" : \"\", message ? message : \"\",\n","filename":"src\/hotspot\/share\/utilities\/events.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -210,1 +210,3 @@\n-  void log(Thread* thread, Handle h_exception, const char* message, const char* file, int line);\n+  \/\/ Message length limit of zero means no limit.\n+  void log(Thread* thread, Handle h_exception, const char* message,\n+           const char* file, int line, int message_length_limit = 0);\n@@ -278,1 +280,1 @@\n-  static void log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line);\n+  static void log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line, int message_length_limit = 0);\n@@ -348,1 +350,3 @@\n-inline void Events::log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {\n+inline void Events::log_exception(Thread* thread, Handle h_exception,\n+                                  const char* message, const char* file,\n+                                  int line, int message_length_limit) {\n@@ -350,1 +354,1 @@\n-    _exceptions->log(thread, h_exception, message, file, line);\n+    _exceptions->log(thread, h_exception, message, file, line, message_length_limit);\n","filename":"src\/hotspot\/share\/utilities\/events.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-  Events::log_exception(thread, h_exception, message, file, line);\n+  Events::log_exception(thread, h_exception, message, file, line, MAX_LEN);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -314,0 +314,3 @@\n+#define THROW_HANDLE_NULL(e)                THROW_HANDLE_(e, nullptr)\n+#define THROW_ARG_NULL(name, signature, arg) THROW_ARG_(name, signature, arg, nullptr)\n+\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2445,1 +2445,1 @@\n-    \/*\n+    \/**\n@@ -2447,0 +2447,17 @@\n+     * @param loader the class loader used to look up the native library symbol\n+     * @param clazz the class in which the native method is declared\n+     * @param entryName the native method's mangled name (this is the name used for the native lookup)\n+     * @param javaName the native method's declared name\n+     *\/\n+    static long findNative(ClassLoader loader, Class<?> clazz, String entryName, String javaName) {\n+        long addr = findNativeInternal(loader, entryName);\n+        if (addr != 0 && loader != null) {\n+            Reflection.ensureNativeAccess(clazz, clazz, javaName, true);\n+        }\n+        return addr;\n+    }\n+\n+    \/*\n+     * This is also called by SymbolLookup::loaderLookup. In that case, we need\n+     * to avoid a restricted check, as that check has already been performed when\n+     * obtaining the lookup.\n@@ -2448,1 +2465,1 @@\n-    static long findNative(ClassLoader loader, String entryName) {\n+    static long findNativeInternal(ClassLoader loader, String entryName) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import jdk.internal.misc.VM;\n@@ -66,0 +67,1 @@\n+import jdk.internal.module.ModuleBootstrap.IllegalNativeAccess;\n@@ -303,1 +305,1 @@\n-    void ensureNativeAccess(Class<?> owner, String methodName, Class<?> currentClass) {\n+    void ensureNativeAccess(Class<?> owner, String methodName, Class<?> currentClass, boolean jni) {\n@@ -306,3 +308,10 @@\n-        if (!EnableNativeAccess.isNativeAccessEnabled(target)) {\n-            if (ModuleBootstrap.hasEnableNativeAccessFlag()) {\n-                throw new IllegalCallerException(\"Illegal native access from: \" + this);\n+        ModuleBootstrap.IllegalNativeAccess illegalNativeAccess = ModuleBootstrap.illegalNativeAccess();\n+        if (illegalNativeAccess != ModuleBootstrap.IllegalNativeAccess.ALLOW &&\n+                !EnableNativeAccess.isNativeAccessEnabled(target)) {\n+            String mod = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n+            if (currentClass != null) {\n+                \/\/ try to extract location of the current class (e.g. jar or folder)\n+                URL url = System.codeSource(currentClass);\n+                if (url != null) {\n+                    mod += \" (\" + url + \")\";\n+                }\n@@ -310,1 +319,3 @@\n-            if (EnableNativeAccess.trySetEnableNativeAccess(target)) {\n+            if (illegalNativeAccess == ModuleBootstrap.IllegalNativeAccess.DENY) {\n+                throw new IllegalCallerException(\"Illegal native access from \" + mod);\n+            } else if (EnableNativeAccess.trySetEnableNativeAccess(target)) {\n@@ -314,1 +325,0 @@\n-                String mod = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n@@ -317,6 +327,15 @@\n-                System.err.printf(\"\"\"\n-                        WARNING: A restricted method in %s has been called\n-                        WARNING: %s has been called by %s in %s\n-                        WARNING: Use --enable-native-access=%s to avoid a warning for callers in this module\n-                        WARNING: Restricted methods will be blocked in a future release unless native access is enabled\n-                        %n\"\"\", cls, mtd, caller, mod, modflag);\n+                if (jni) {\n+                    VM.initialErr().printf(\"\"\"\n+                            WARNING: A native method in %s has been bound\n+                            WARNING: %s is declared in %s\n+                            WARNING: Use --enable-native-access=%s to avoid a warning for native methods declared in this module\n+                            WARNING: Restricted methods will be blocked in a future release unless native access is enabled\n+                            %n\"\"\", cls, mtd, mod, modflag);\n+                } else {\n+                    VM.initialErr().printf(\"\"\"\n+                            WARNING: A restricted method in %s has been called\n+                            WARNING: %s has been called by %s in %s\n+                            WARNING: Use --enable-native-access=%s to avoid a warning for callers in this module\n+                            WARNING: Restricted methods will be blocked in a future release unless native access is enabled\n+                            %n\"\"\", cls, mtd, caller, mod, modflag);\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":31,"deletions":12,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-                \"enableNativeAccess\");\n+                \"enableNativeAccess\", false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ModuleLayer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import jdk.internal.javac.Restricted;\n@@ -831,0 +832,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -837,0 +840,1 @@\n+    @Restricted\n@@ -838,1 +842,3 @@\n-        load0(Reflection.getCallerClass(), filename);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, Runtime.class, \"load\", false);\n+        load0(caller, filename);\n@@ -897,0 +903,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -902,0 +910,1 @@\n+    @Restricted\n@@ -903,1 +912,3 @@\n-        loadLibrary0(Reflection.getCallerClass(), libname);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, Runtime.class, \"loadLibrary\", false);\n+        loadLibrary0(caller, libname);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Runtime.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -31,0 +32,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -42,0 +44,92 @@\n+    static abstract class StringConcatBase {\n+        @Stable\n+        final String[] constants;\n+        final int      length;\n+        final byte     coder;\n+\n+        StringConcatBase(String[] constants) {\n+            int  length = 0;\n+            byte coder  = String.LATIN1;\n+            for (String c : constants) {\n+                length += c.length();\n+                coder  |= c.coder();\n+            }\n+            this.constants = constants;\n+            this.length    = length;\n+            this.coder     = coder;\n+        }\n+    }\n+\n+    static final class Concat1 extends StringConcatBase {\n+        Concat1(String[] constants) {\n+            super(constants);\n+        }\n+\n+        @ForceInline\n+        String concat0(String value) {\n+            int length = stringSize(this.length, value);\n+            byte coder = (byte) (this.coder | value.coder());\n+            byte[] buf = newArray(length << coder);\n+            String prefix = constants[0];\n+            prefix.getBytes(buf, 0, coder);\n+            value.getBytes(buf, prefix.length(), coder);\n+            constants[1].getBytes(buf, prefix.length() + value.length(), coder);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(boolean value) {\n+            int length = stringSize(this.length, value);\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(char value) {\n+            int length = stringSize(this.length, value);\n+            byte coder = (byte) (this.coder | stringCoder(value));\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(int value) {\n+            int length = stringSize(this.length, value);\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(long value) {\n+            int length = stringSize(this.length, value);\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(Object value) {\n+            return concat0(stringOf(value));\n+        }\n+\n+        @ForceInline\n+        String concat(float value) {\n+            return concat0(Float.toString(value));\n+        }\n+\n+        @ForceInline\n+        String concat(double value) {\n+            return concat0(Double.toString(value));\n+        }\n+    }\n@@ -378,0 +472,58 @@\n+    static String stringOf(float value) {\n+        return Float.toString(value);\n+    }\n+\n+    static String stringOf(double value) {\n+        return Double.toString(value);\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, char value) {\n+        return checkOverflow(length + 1);\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, boolean value) {\n+        return checkOverflow(length + (value ? 4 : 5));\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, int value) {\n+        return checkOverflow(length + DecimalDigits.stringSize(value));\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, long value) {\n+        return checkOverflow(length + DecimalDigits.stringSize(value));\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, String value) {\n+        return checkOverflow(length + value.length());\n+    }\n+\n@@ -443,0 +595,191 @@\n+    \/**\n+     * Allocates an uninitialized byte array based on the length and coder\n+     * information, then prepends the given suffix string at the end of the\n+     * byte array before returning it. The calling code must adjust the\n+     * indexCoder so that it's taken the coder of the suffix into account, but\n+     * subtracted the length of the suffix.\n+     *\n+     * @param suffix\n+     * @param indexCoder\n+     * @return the newly allocated byte array\n+     *\/\n+    @ForceInline\n+    static byte[] newArrayWithSuffix(String suffix, int index, byte coder) {\n+        byte[] buf = newArray((index + suffix.length()) << coder);\n+        if (coder == String.LATIN1) {\n+            suffix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            suffix.getBytes(buf, index, String.UTF16);\n+        }\n+        return buf;\n+    }\n+\n+    \/**\n+     * Return the coder for the character.\n+     * @param value character\n+     * @return      coder\n+     *\/\n+    static byte stringCoder(char value) {\n+        return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      boolean value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, boolean value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            if (value) {\n+                index -= 4;\n+                buf[index] = 't';\n+                buf[index + 1] = 'r';\n+                buf[index + 2] = 'u';\n+                buf[index + 3] = 'e';\n+            } else {\n+                index -= 5;\n+                buf[index] = 'f';\n+                buf[index + 1] = 'a';\n+                buf[index + 2] = 'l';\n+                buf[index + 3] = 's';\n+                buf[index + 4] = 'e';\n+            }\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            if (value) {\n+                index -= 4;\n+                StringUTF16.putChar(buf, index, 't');\n+                StringUTF16.putChar(buf, index + 1, 'r');\n+                StringUTF16.putChar(buf, index + 2, 'u');\n+                StringUTF16.putChar(buf, index + 3, 'e');\n+            } else {\n+                index -= 5;\n+                StringUTF16.putChar(buf, index, 'f');\n+                StringUTF16.putChar(buf, index + 1, 'a');\n+                StringUTF16.putChar(buf, index + 2, 'l');\n+                StringUTF16.putChar(buf, index + 3, 's');\n+                StringUTF16.putChar(buf, index + 4, 'e');\n+            }\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      char value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, char value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            buf[--index] = (byte) (value & 0xFF);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            StringUTF16.putChar(buf, --index, value);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      int value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, int value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            index = StringLatin1.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            index = StringUTF16.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      long value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, long value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            index = StringLatin1.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            index = StringUTF16.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      boolean value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, String value, String prefix) {\n+        index -= value.length();\n+        if (coder == String.LATIN1) {\n+            value.getBytes(buf, index, String.LATIN1);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            value.getBytes(buf, index, String.UTF16);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Check for overflow, throw exception on overflow.\n+     *\n+     * @param value\n+     * @return the given parameter value, if valid\n+     *\/\n+    @ForceInline\n+    static int checkOverflow(int value) {\n+        if (value >= 0) {\n+            return value;\n+        }\n+        throw new OutOfMemoryError(\"Overflow: String length out of range\");\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":343,"deletions":0,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.javac.Restricted;\n@@ -358,1 +359,1 @@\n-    private static URL codeSource(Class<?> clazz) {\n+    static URL codeSource(Class<?> clazz) {\n@@ -2020,0 +2021,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -2026,0 +2029,1 @@\n+    @Restricted\n@@ -2027,1 +2031,3 @@\n-        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, System.class, \"load\", false);\n+        Runtime.getRuntime().load0(caller, filename);\n@@ -2058,0 +2064,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -2064,0 +2072,1 @@\n+    @Restricted\n@@ -2065,1 +2074,3 @@\n-        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, System.class, \"loadLibrary\", false);\n+        Runtime.getRuntime().loadLibrary0(caller, libname);\n@@ -2542,2 +2553,2 @@\n-            public void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass) {\n-                m.ensureNativeAccess(owner, methodName, currentClass);\n+            public void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass, boolean jni) {\n+                m.ensureNativeAccess(owner, methodName, currentClass, jni);\n@@ -2626,0 +2637,4 @@\n+            public Object stringConcat1(String[] constants) {\n+                return new StringConcatHelper.Concat1(constants);\n+            }\n+\n@@ -2644,1 +2659,1 @@\n-                return ClassLoader.findNative(loader, entry);\n+                return ClassLoader.findNativeInternal(loader, entry);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -40,1 +40,16 @@\n- * Models an annotation on a declaration.\n+ * Models an {@code annotation} structure (JVMS {@jvms 4.7.16}) or part of a {@code\n+ * type_annotation} structure (JVMS {@jvms 4.7.20}). This model indicates the\n+ * interface of the annotation and a set of element-value pairs.\n+ * <p>\n+ * This model can reconstruct an annotation, given the location of the modeled structure\n+ * in the class file and the definition of the annotation interface.\n+ * <p>\n+ * Two {@code Annotation} objects should be compared using the {@link\n+ * Object#equals(Object) equals} method.\n+ *\n+ * @apiNote\n+ * For Java programs, the location of the modeled structure indicates the source code\n+ * element or type (JLS {@jls 9.7.4}) on which the reconstructed annotation appears,\n+ * and the annotation interface definition determines whether the reconstructed annotation has\n+ * elements with default values (JLS {@jls 9.6.2}), and whether the reconstructed annotation\n+ * is a container annotation for multiple annotations (JLS {@jls 9.7.5}).\n@@ -44,0 +59,1 @@\n+ * @see TypeAnnotation\n@@ -49,1 +65,0 @@\n- * @sealedGraph\n@@ -54,1 +69,1 @@\n-        permits TypeAnnotation, AnnotationImpl {\n+        permits AnnotationImpl {\n@@ -57,1 +72,2 @@\n-     * {@return the class of the annotation}\n+     * {@return the constant pool entry holding the {@linkplain Class#descriptorString\n+     * descriptor string} of the annotation interface}\n@@ -62,1 +78,1 @@\n-     * {@return the class of the annotation, as a symbolic descriptor}\n+     * {@return the annotation interface, as a symbolic descriptor}\n@@ -69,1 +85,1 @@\n-     * {@return the elements of the annotation}\n+     * {@return the element-value pairs of the annotation}\n@@ -75,2 +91,3 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the constant pool entry holding the descriptor string\n+     *                        of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n@@ -85,2 +102,3 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the constant pool entry holding the descriptor string\n+     *                        of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n@@ -95,2 +113,2 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the descriptor of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n@@ -105,2 +123,2 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the descriptor of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Annotation.java","additions":32,"deletions":14,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -35,1 +35,7 @@\n- * Models a key-value pair of an annotation.\n+ * Models an element-value pair in the {@code element_value_pairs}\n+ * table in the {@code annotation} structure defined in JVMS\n+ * {@jvms 4.7.16} or the {@code type_annotation} structure defined\n+ * in JVMS {@jvms 4.7.20}.\n+ * <p>\n+ * Two {@code AnnotationElement} objects should be compared using the\n+ * {@link Object#equals(Object) equals} method.\n@@ -48,0 +54,6 @@\n+     *\n+     * @apiNote\n+     * In Java source code, by convention, the name of the sole element in a\n+     * single-element annotation interface is {@code value}. (JLS {@jls 9.6.1})\n+     * This is the case for single-element annotations (JLS {@jls 9.7.3}) and\n+     * container annotations for multiple annotations (JLS {@jls 9.6.3}).\n@@ -57,1 +69,1 @@\n-     * {@return an annotation key-value pair}\n+     * {@return an element-value pair}\n@@ -67,1 +79,1 @@\n-     * {@return an annotation key-value pair}\n+     * {@return an element-value pair}\n@@ -77,1 +89,1 @@\n-     * {@return an annotation key-value pair for a class-valued annotation}\n+     * {@return an element-value pair for a class-valued element}\n@@ -80,0 +92,1 @@\n+     * @see AnnotationValue#ofClass(ClassDesc) AnnotationValue::ofClass\n@@ -87,1 +100,1 @@\n-     * {@return an annotation key-value pair for a string-valued annotation}\n+     * {@return an element-value pair for a string-valued element}\n@@ -90,0 +103,1 @@\n+     * @see AnnotationValue#ofString(String) AnnotationValue::ofString\n@@ -97,1 +111,1 @@\n-     * {@return an annotation key-value pair for a long-valued annotation}\n+     * {@return an element-value pair for a long-valued element}\n@@ -100,0 +114,1 @@\n+     * @see AnnotationValue#ofLong(long) AnnotationValue::ofLong\n@@ -107,1 +122,1 @@\n-     * {@return an annotation key-value pair for an int-valued annotation}\n+     * {@return an element-value pair for an int-valued element}\n@@ -110,0 +125,1 @@\n+     * @see AnnotationValue#ofInt(int) AnnotationValue::ofInt\n@@ -117,1 +133,1 @@\n-     * {@return an annotation key-value pair for a char-valued annotation}\n+     * {@return an element-value pair for a char-valued element}\n@@ -120,0 +136,1 @@\n+     * @see AnnotationValue#ofChar(char) AnnotationValue::ofChar\n@@ -127,1 +144,1 @@\n-     * {@return an annotation key-value pair for a short-valued annotation}\n+     * {@return an element-value pair for a short-valued element}\n@@ -130,0 +147,1 @@\n+     * @see AnnotationValue#ofShort(short) AnnotationValue::ofShort\n@@ -137,1 +155,1 @@\n-     * {@return an annotation key-value pair for a byte-valued annotation}\n+     * {@return an element-value pair for a byte-valued element}\n@@ -140,0 +158,1 @@\n+     * @see AnnotationValue#ofByte(byte) AnnotationValue::ofByte\n@@ -142,1 +161,1 @@\n-                                      byte value) {\n+                                    byte value) {\n@@ -147,1 +166,1 @@\n-     * {@return an annotation key-value pair for a boolean-valued annotation}\n+     * {@return an element-value pair for a boolean-valued element}\n@@ -150,0 +169,1 @@\n+     * @see AnnotationValue#ofBoolean(boolean) AnnotationValue::ofBoolean\n@@ -152,1 +172,1 @@\n-                                      boolean value) {\n+                                       boolean value) {\n@@ -157,1 +177,1 @@\n-     * {@return an annotation key-value pair for a double-valued annotation}\n+     * {@return an element-value pair for a double-valued element}\n@@ -160,0 +180,1 @@\n+     * @see AnnotationValue#ofDouble(double) AnnotationValue::ofDouble\n@@ -167,1 +188,1 @@\n-     * {@return an annotation key-value pair for a float-valued annotation}\n+     * {@return an element-value pair for a float-valued element}\n@@ -170,0 +191,1 @@\n+     * @see AnnotationValue#ofFloat(float) AnnotationValue::ofFloat\n@@ -177,1 +199,1 @@\n-     * {@return an annotation key-value pair for an annotation-valued annotation}\n+     * {@return an element-value pair for an annotation-valued element}\n@@ -180,0 +202,1 @@\n+     * @see AnnotationValue#ofAnnotation AnnotationValue::ofAnnotation\n@@ -187,1 +210,1 @@\n-     * {@return an annotation key-value pair for an array-valued annotation}\n+     * {@return an element-value pair for an array-valued element}\n@@ -190,0 +213,1 @@\n+     * @see AnnotationValue#ofArray(AnnotationValue...) AnnotationValue::ofArray\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationElement.java","additions":41,"deletions":17,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -44,1 +44,5 @@\n- * Models the value of a key-value pair of an annotation.\n+ * Models an {@code element_value} structure, or a value of an element-value\n+ * pair of an annotation, as defined in JVMS {@jvms 4.7.16.1}.\n+ * <p>\n+ * Two {@code AnnotationValue} objects should be compared using the {@link\n+ * Object#equals(Object) equals} method.\n@@ -56,2 +60,2 @@\n-     * Models an annotation-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_ANNOTATION}.\n+     * Models an annotation value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_ANNOTATION}.\n@@ -69,2 +73,2 @@\n-     * Models an array-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_ARRAY}.\n+     * Models an array value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_ARRAY}.\n@@ -82,1 +86,3 @@\n-         * which must not be an array type. ({@jls 9.6.1})\n+         * which must not be an array type. (JLS {@jls 9.6.1}) If such elements are\n+         * annotations, they have the same annotation interface; if such elements\n+         * are enum, they belong to the same enum class.\n@@ -88,1 +94,1 @@\n-     * Models a constant-valued element.\n+     * Models a constant value of an element-value pair.\n@@ -94,4 +100,1 @@\n-    sealed interface OfConstant\n-            extends AnnotationValue\n-            permits OfString, OfDouble, OfFloat, OfLong, OfInt, OfShort, OfChar, OfByte,\n-                    OfBoolean, AnnotationImpl.OfConstantImpl {\n+    sealed interface OfConstant extends AnnotationValue {\n@@ -126,2 +129,2 @@\n-     * Models a string-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_STRING}.\n+     * Models a string value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_STRING}.\n@@ -154,2 +157,2 @@\n-     * Models a double-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_DOUBLE}.\n+     * Models a double value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_DOUBLE}.\n@@ -182,2 +185,2 @@\n-     * Models a float-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_FLOAT}.\n+     * Models a float value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_FLOAT}.\n@@ -210,2 +213,2 @@\n-     * Models a long-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_LONG}.\n+     * Models a long value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_LONG}.\n@@ -238,2 +241,2 @@\n-     * Models an int-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_INT}.\n+     * Models an int value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_INT}.\n@@ -266,2 +269,2 @@\n-     * Models a short-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_SHORT}.\n+     * Models a short value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_SHORT}.\n@@ -297,2 +300,2 @@\n-     * Models a char-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_CHAR}.\n+     * Models a char value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_CHAR}.\n@@ -328,2 +331,2 @@\n-     * Models a byte-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_BYTE}.\n+     * Models a byte value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_BYTE}.\n@@ -359,2 +362,2 @@\n-     * Models a boolean-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_BOOLEAN}.\n+     * Models a boolean value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_BOOLEAN}.\n@@ -390,2 +393,2 @@\n-     * Models a class-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_CLASS}.\n+     * Models a class value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_CLASS}.\n@@ -408,2 +411,2 @@\n-     * Models an enum-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_ENUM}.\n+     * Models an enum value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_ENUM}.\n@@ -429,1 +432,2 @@\n-     * {@return the tag character for this type as per {@jvms 4.7.16.1}}\n+     * {@return the tag character for this value as per JVMS {@jvms 4.7.16.1}}\n+     * The tag characters have a one-to-one mapping to the types of annotation element values.\n@@ -434,1 +438,1 @@\n-     * {@return an annotation element for a enum-valued element}\n+     * {@return an enum value for an element-value pair}\n@@ -444,1 +448,1 @@\n-     * {@return an annotation element for a enum-valued element}\n+     * {@return an enum value for an element-value pair}\n@@ -454,1 +458,1 @@\n-     * {@return an annotation element for a class-valued element}\n+     * {@return a class value for an element-value pair}\n@@ -462,1 +466,1 @@\n-     * {@return an annotation element for a class-valued element}\n+     * {@return a class value for an element-value pair}\n@@ -470,1 +474,1 @@\n-     * {@return an annotation element for a string-valued element}\n+     * {@return a string value for an element-value pair}\n@@ -478,1 +482,1 @@\n-     * {@return an annotation element for a string-valued element}\n+     * {@return a string value for an element-value pair}\n@@ -486,1 +490,1 @@\n-     * {@return an annotation element for a double-valued element}\n+     * {@return a double value for an element-value pair}\n@@ -494,1 +498,1 @@\n-     * {@return an annotation element for a double-valued element}\n+     * {@return a double value for an element-value pair}\n@@ -502,1 +506,1 @@\n-     * {@return an annotation element for a float-valued element}\n+     * {@return a float value for an element-value pair}\n@@ -510,1 +514,1 @@\n-     * {@return an annotation element for a float-valued element}\n+     * {@return a float value for an element-value pair}\n@@ -518,1 +522,1 @@\n-     * {@return an annotation element for a long-valued element}\n+     * {@return a long value for an element-value pair}\n@@ -526,1 +530,1 @@\n-     * {@return an annotation element for a long-valued element}\n+     * {@return a long value for an element-value pair}\n@@ -534,1 +538,1 @@\n-     * {@return an annotation element for an int-valued element}\n+     * {@return an int value for an element-value pair}\n@@ -542,1 +546,1 @@\n-     * {@return an annotation element for an int-valued element}\n+     * {@return an int value for an element-value pair}\n@@ -550,1 +554,1 @@\n-     * {@return an annotation element for a short-valued element}\n+     * {@return a short value for an element-value pair}\n@@ -558,1 +562,1 @@\n-     * {@return an annotation element for a short-valued element}\n+     * {@return a short value for an element-value pair}\n@@ -566,1 +570,1 @@\n-     * {@return an annotation element for a char-valued element}\n+     * {@return a char value for an element-value pair}\n@@ -574,1 +578,1 @@\n-     * {@return an annotation element for a char-valued element}\n+     * {@return a char value for an element-value pair}\n@@ -582,1 +586,1 @@\n-     * {@return an annotation element for a byte-valued element}\n+     * {@return a byte value for an element-value pair}\n@@ -590,1 +594,1 @@\n-     * {@return an annotation element for a byte-valued element}\n+     * {@return a byte value for an element-value pair}\n@@ -598,1 +602,1 @@\n-     * {@return an annotation element for a boolean-valued element}\n+     * {@return a boolean value for an element-value pair}\n@@ -606,1 +610,1 @@\n-     * {@return an annotation element for a boolean-valued element}\n+     * {@return a boolean value for an element-value pair}\n@@ -615,1 +619,1 @@\n-     * {@return an annotation element for an annotation-valued element}\n+     * {@return an annotation value for an element-value pair}\n@@ -623,1 +627,6 @@\n-     * {@return an annotation element for an array-valued element}\n+     * {@return an array value for an element-value pair}\n+     *\n+     * @apiNote\n+     * See {@link AnnotationValue.OfArray#values() values()} for conventions\n+     * on array values derived from Java source code.\n+     *\n@@ -631,1 +640,6 @@\n-     * {@return an annotation element for an array-valued element}\n+     * {@return an array value for an element-value pair}\n+     *\n+     * @apiNote\n+     * See {@link AnnotationValue.OfArray#values() values()} for conventions\n+     * on array values derived from Java source code.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationValue.java","additions":73,"deletions":59,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n- * Models a classfile attribute {@jvms 4.7}.  Many, though not all, subtypes of\n+ * Models a classfile attribute (JVMS {@jvms 4.7}).  Many, though not all, subtypes of\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-public interface AttributeMapper<A> {\n+public interface AttributeMapper<A extends Attribute<A>> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AttributeMapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-        return withField(name, descriptor, fb -> fb.withFlags(flags));\n+        return withField(name, descriptor, Util.buildingFlags(flags));\n@@ -197,1 +197,1 @@\n-        return withField(name, descriptor, fb -> fb.withFlags(flags));\n+        return withField(name, descriptor, Util.buildingFlags(flags));\n@@ -244,1 +244,1 @@\n-        return withMethod(name, descriptor, methodFlags, mb -> mb.withCode(handler));\n+        return withMethod(name, descriptor, methodFlags, Util.buildingCode(handler));\n@@ -279,4 +279,1 @@\n-        return withMethodBody(constantPool().utf8Entry(name),\n-                              constantPool().utf8Entry(descriptor),\n-                              methodFlags,\n-                              handler);\n+        return withMethod(name, descriptor, methodFlags, Util.buildingCode(handler));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassBuilder.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * Models the generic signature of a class file, as defined by {@jvms 4.7.9}.\n+ * Models the generic signature of a class file, as defined by JVMS {@jvms 4.7.9}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassSignature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * Models the generic signature of a method, as defined by {@jvms 4.7.9}.\n+ * Models the generic signature of a method, as defined by JVMS {@jvms 4.7.9}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodSignature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * Describes the opcodes of the JVM instruction set, as described in {@jvms 6.5}.\n+ * Describes the opcodes of the JVM instruction set, as described in JVMS {@jvms 6.5}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Opcode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * Models generic Java type signatures, as defined in {@jvms 4.7.9.1}.\n+ * Models generic Java type signatures, as defined in JVMS {@jvms 4.7.9.1}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Signature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.lang.constant.ClassDesc;\n@@ -33,1 +32,0 @@\n-import java.lang.classfile.constantpool.Utf8Entry;\n@@ -59,1 +57,0 @@\n-import jdk.internal.classfile.impl.TemporaryConstantPool;\n@@ -63,1 +60,11 @@\n- * Models an annotation on a type use, as defined in {@jvms 4.7.19} and {@jvms 4.7.20}.\n+ * Models a {@code type_annotation} structure (JVMS {@jvms 4.7.20}). This model\n+ * indicates the annotated type within a declaration or expression and the part\n+ * of the indicated type that is annotated, in addition to what is {@linkplain\n+ * #annotation() available} in an {@code Annotation}.\n+ * <p>\n+ * This model can reconstruct an annotation on a type or a part of a type, given\n+ * the location of the {@code type_annotation} structure in the class file and\n+ * the definition of the annotation interface.\n+ * <p>\n+ * Two {@code TypeAnnotation} objects should be compared using the {@link\n+ * Object#equals(Object) equals} method.\n@@ -65,0 +72,1 @@\n+ * @see Annotation\n@@ -72,1 +80,0 @@\n-        extends Annotation\n@@ -76,1 +83,1 @@\n-     * The kind of target on which the annotation appears, as defined in {@jvms 4.7.20.1}.\n+     * The kind of target on which the annotation appears, as defined in JVMS {@jvms 4.7.20.1}.\n@@ -173,1 +180,1 @@\n-     * is annotated}\n+     * is annotated} This models the {@code target_type} and {@code target_info} items.\n@@ -183,19 +190,4 @@\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClassUtf8Entry the annotation class\n-     * @param annotationElements the annotation elements\n-     *\/\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             Utf8Entry annotationClassUtf8Entry,\n-                             List<AnnotationElement> annotationElements) {\n-        return new UnboundAttribute.UnboundTypeAnnotation(targetInfo, targetPath,\n-                annotationClassUtf8Entry, annotationElements);\n-    }\n-\n-    \/**\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClass the annotation class\n-     * @param annotationElements the annotation elements\n+     * {@return the annotation applied to the part indicated by {@link #targetPath()}}\n+     * This models the interface of the annotation and the set of element-value pairs,\n+     * the subset of the {@code type_annotation} structure that is identical to the\n+     * {@code annotation} structure.\n@@ -203,19 +195,1 @@\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             ClassDesc annotationClass,\n-                             AnnotationElement... annotationElements) {\n-        return of(targetInfo, targetPath, annotationClass, List.of(annotationElements));\n-    }\n-\n-    \/**\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClass the annotation class\n-     * @param annotationElements the annotation elements\n-     *\/\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             ClassDesc annotationClass,\n-                             List<AnnotationElement> annotationElements) {\n-        return of(targetInfo, targetPath,\n-                TemporaryConstantPool.INSTANCE.utf8Entry(annotationClass.descriptorString()), annotationElements);\n-    }\n+    Annotation annotation();\n@@ -224,1 +198,1 @@\n-     * {@return a type annotation}\n+     * {@return a {@code type_annotation} structure}\n@@ -227,2 +201,1 @@\n-     * @param annotationClassUtf8Entry the annotation class\n-     * @param annotationElements the annotation elements\n+     * @param annotation the annotation\n@@ -231,3 +204,2 @@\n-                             Utf8Entry annotationClassUtf8Entry,\n-                             AnnotationElement... annotationElements) {\n-        return of(targetInfo, targetPath, annotationClassUtf8Entry, List.of(annotationElements));\n+                             Annotation annotation) {\n+        return new UnboundAttribute.UnboundTypeAnnotation(targetInfo, targetPath, annotation);\n@@ -776,1 +748,1 @@\n-     * as defined in {@jvms 4.7.20.2}\n+     * as defined in JVMS {@jvms 4.7.20.2}\n@@ -785,1 +757,1 @@\n-         * Type path kind, as defined in {@jvms 4.7.20.2}\n+         * Type path kind, as defined in JVMS {@jvms 4.7.20.2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeAnnotation.java","additions":26,"deletions":54,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code AnnotationDefault} attribute {@jvms 4.7.22}, which can\n+ * Models the {@code AnnotationDefault} attribute (JVMS {@jvms 4.7.22}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/AnnotationDefaultAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code BootstrapMethods} attribute {@jvms 4.7.23}, which serves as\n+ * Models the {@code BootstrapMethods} attribute (JVMS {@jvms 4.7.23}), which serves as\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/BootstrapMethodsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * Models the {@code Code} attribute {@jvms 4.7.3}, appears on non-native,\n+ * Models the {@code Code} attribute (JVMS {@jvms 4.7.3}), appears on non-native,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/CodeAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code ConstantValue} attribute {@jvms 4.7.2}, which can appear on\n+ * Models the {@code ConstantValue} attribute (JVMS {@jvms 4.7.2}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ConstantValueAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code Deprecated} attribute {@jvms 4.7.15}, which can appear on\n+ * Models the {@code Deprecated} attribute (JVMS {@jvms 4.7.15}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/DeprecatedAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * Models the {@code EnclosingMethod} attribute {@jvms 4.7.7}, which can appear\n+ * Models the {@code EnclosingMethod} attribute (JVMS {@jvms 4.7.7}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/EnclosingMethodAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * Models the {@code Exceptions} attribute {@jvms 4.7.5}, which can appear on\n+ * Models the {@code Exceptions} attribute (JVMS {@jvms 4.7.5}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ExceptionsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code InnerClasses} attribute {@jvms 4.7.6}, which can\n+ * Models the {@code InnerClasses} attribute (JVMS {@jvms 4.7.6}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/InnerClassesAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * Models the {@code LineNumberTable} attribute {@jvms 4.7.12}, which can appear\n+ * Models the {@code LineNumberTable} attribute (JVMS {@jvms 4.7.12}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LineNumberTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * Models the {@code LocalVariableTable} attribute {@jvms 4.7.13}, which can appear\n+ * Models the {@code LocalVariableTable} attribute (JVMS {@jvms 4.7.13}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LocalVariableTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code LocalVariableTypeTable} attribute {@jvms 4.7.14}, which can appear\n+ * Models the {@code LocalVariableTypeTable} attribute (JVMS {@jvms 4.7.14}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LocalVariableTypeTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code MethodParameters} attribute {@jvms 4.7.24}, which can\n+ * Models the {@code MethodParameters} attribute (JVMS {@jvms 4.7.24}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/MethodParametersAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * Models the {@code Module} attribute {@jvms 4.7.25}, which can\n+ * Models the {@code Module} attribute (JVMS {@jvms 4.7.25}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code ModuleMainClass} attribute {@jvms 4.7.27}, which can\n+ * Models the {@code ModuleMainClass} attribute (JVMS {@jvms 4.7.27}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleMainClassAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * Models the {@code ModulePackages} attribute {@jvms 4.7.26}, which can\n+ * Models the {@code ModulePackages} attribute (JVMS {@jvms 4.7.26}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModulePackagesAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code NestHost} attribute {@jvms 4.7.28}, which can\n+ * Models the {@code NestHost} attribute (JVMS {@jvms 4.7.28}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/NestHostAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * Models the {@code NestMembers} attribute {@jvms 4.7.29}, which can\n+ * Models the {@code NestMembers} attribute (JVMS {@jvms 4.7.29}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/NestMembersAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * Models the {@code PermittedSubclasses} attribute {@jvms 4.7.31}, which can\n+ * Models the {@code PermittedSubclasses} attribute (JVMS {@jvms 4.7.31}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/PermittedSubclassesAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code Record} attribute {@jvms 4.7.30}, which can\n+ * Models the {@code Record} attribute (JVMS {@jvms 4.7.30}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RecordAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code RuntimeInvisibleAnnotations} attribute {@jvms 4.7.17}, which\n+ * Models the {@code RuntimeInvisibleAnnotations} attribute (JVMS {@jvms 4.7.17}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * {@jvms 4.7.19}, which can appear on methods. Delivered as a {@link\n+ * (JVMS {@jvms 4.7.19}), which can appear on methods. Delivered as a {@link\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleParameterAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * Models the {@code RuntimeInvisibleTypeAnnotations} attribute {@jvms 4.7.21}, which\n+ * Models the {@code RuntimeInvisibleTypeAnnotations} attribute (JVMS {@jvms 4.7.21}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleTypeAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code RuntimeVisibleAnnotations} attribute {@jvms 4.7.16}, which\n+ * Models the {@code RuntimeVisibleAnnotations} attribute (JVMS {@jvms 4.7.16}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * Models the {@code RuntimeVisibleParameterAnnotations} attribute {@jvms 4.7.18}, which\n+ * Models the {@code RuntimeVisibleParameterAnnotations} attribute (JVMS {@jvms 4.7.18}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleParameterAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * Models the {@code RuntimeVisibleTypeAnnotations} attribute {@jvms 4.7.20}, which\n+ * Models the {@code RuntimeVisibleTypeAnnotations} attribute (JVMS {@jvms 4.7.20}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleTypeAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * Models the {@code Signature} attribute {@jvms 4.7.9}, which\n+ * Models the {@code Signature} attribute (JVMS {@jvms 4.7.9}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SignatureAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code SourceFile} attribute {@jvms 4.7.10}, which\n+ * Models the {@code SourceFile} attribute (JVMS {@jvms 4.7.10}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SourceFileAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * Models stack map frame of {@code StackMapTable} attribute {@jvms 4.7.4}.\n+ * Models stack map frame of {@code StackMapTable} attribute (JVMS {@jvms 4.7.4}).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapFrameInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code StackMapTable} attribute {@jvms 4.7.4}, which can appear\n+ * Models the {@code StackMapTable} attribute (JVMS {@jvms 4.7.4}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code Synthetic} attribute {@jvms 4.7.8}, which can appear on\n+ * Models the {@code Synthetic} attribute (JVMS {@jvms 4.7.8}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SyntheticAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n-     * @param refKind the reference kind of the method handle {@jvms 4.4.8}\n+     * @param refKind the reference kind of the method handle (JVMS {@jvms 4.4.8})\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-     * {@return the reference kind of this method handle {@jvms 4.4.8}}\n+     * {@return the reference kind of this method handle (JVMS {@jvms 4.4.8})}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/MethodHandleEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-     * {@return the {@code count} value of an {@code invokeinterface} instruction, as defined in {@jvms 6.5}\n+     * {@return the {@code count} value of an {@code invokeinterface} instruction, as defined in JVMS {@jvms 6.5}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/InvokeInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n- * java.lang.Object)} method for mapping back to the classfile format.  It also\n+ * java.lang.classfile.Attribute)} method for mapping back to the classfile format.  It also\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import static jdk.internal.constant.ConstantUtils.forPrimitiveType;\n@@ -167,1 +168,1 @@\n-               ? Wrapper.forPrimitiveType(descriptor.charAt(0)).basicClassDescriptor()\n+               ? forPrimitiveType(descriptor, 0)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-    public static final ClassDesc CD_int = new PrimitiveClassDescImpl(\"I\");\n+    public static final ClassDesc CD_int = PrimitiveClassDescImpl.CD_int;\n@@ -246,1 +246,1 @@\n-    public static final ClassDesc CD_long = new PrimitiveClassDescImpl(\"J\");\n+    public static final ClassDesc CD_long = PrimitiveClassDescImpl.CD_long;\n@@ -249,1 +249,1 @@\n-    public static final ClassDesc CD_float = new PrimitiveClassDescImpl(\"F\");\n+    public static final ClassDesc CD_float = PrimitiveClassDescImpl.CD_float;\n@@ -252,1 +252,1 @@\n-    public static final ClassDesc CD_double = new PrimitiveClassDescImpl(\"D\");\n+    public static final ClassDesc CD_double = PrimitiveClassDescImpl.CD_double;\n@@ -255,1 +255,1 @@\n-    public static final ClassDesc CD_short = new PrimitiveClassDescImpl(\"S\");\n+    public static final ClassDesc CD_short = PrimitiveClassDescImpl.CD_short;\n@@ -258,1 +258,1 @@\n-    public static final ClassDesc CD_byte = new PrimitiveClassDescImpl(\"B\");\n+    public static final ClassDesc CD_byte = PrimitiveClassDescImpl.CD_byte;\n@@ -261,1 +261,1 @@\n-    public static final ClassDesc CD_char = new PrimitiveClassDescImpl(\"C\");\n+    public static final ClassDesc CD_char = PrimitiveClassDescImpl.CD_char;\n@@ -264,1 +264,1 @@\n-    public static final ClassDesc CD_boolean = new PrimitiveClassDescImpl(\"Z\");\n+    public static final ClassDesc CD_boolean = PrimitiveClassDescImpl.CD_boolean;\n@@ -267,1 +267,1 @@\n-    public static final ClassDesc CD_void = new PrimitiveClassDescImpl(\"V\");\n+    public static final ClassDesc CD_void = PrimitiveClassDescImpl.CD_void;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -616,1 +616,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -687,1 +687,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -736,1 +736,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -577,1 +577,3 @@\n-     * Otherwise, the returned method handle throws {@link IndexOutOfBoundsException}.\n+     * Otherwise, the returned method handle throws {@link IndexOutOfBoundsException}. Moreover,\n+     * the value of {@code b} must be such that the computation for {@code offset} does not overflow,\n+     * or the returned method handle throws {@link ArithmeticException}.\n@@ -667,3 +669,4 @@\n-     * {@code P} and {@code P'} are derived, where P contains all the path elements from\n-     * 0 to {@code k - 1} and {@code P'} contains all the path elements from {@code k + 1}\n-     * to {@code m} (if any). Then, the returned var handle is computed as follows:\n+     * {@code P} and {@code Q} are derived, where P contains all the path elements from\n+     * 0 to {@code k - 1} and {@code Q} contains all the path elements from {@code k + 1}\n+     * to {@code m} ({@code Q} could be an empty layout path if {@code k == m}).\n+     * Then, the returned var handle is computed as follows:\n@@ -674,1 +677,1 @@\n-     * VarHandle targetHandle = target.varHandle(P);\n+     * VarHandle targetHandle = target.varHandle(Q);\n@@ -947,1 +950,1 @@\n-         *    <li>if {@code F < 0}, then {@code B = ceilDiv(-(S + 1), -F)}<\/li>\n+         *    <li>if {@code F < 0}, then {@code B = ceilDiv(S + 1, -F)}<\/li>\n@@ -975,2 +978,2 @@\n-         * {@return a path element that dereferences an address layout as its\n-         * {@linkplain AddressLayout#targetLayout() target layout} (where set)}\n+         * {@return a path element that selects the {@linkplain AddressLayout#targetLayout() target layout} of\n+         * an address layout (where set)}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n- *       ptr = z.reinterpret(16, arena, null);                       \/\/ size = 4, scope = arena.scope()\n+ *       ptr = z.reinterpret(16, arena, null);                       \/\/ size = 16, scope = arena.scope()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -295,1 +295,1 @@\n-                SymbolLookup.class, \"libraryLookup\");\n+                SymbolLookup.class, \"libraryLookup\", false);\n@@ -322,1 +322,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -329,1 +329,1 @@\n-                SymbolLookup.class, \"libraryLookup\");\n+                SymbolLookup.class, \"libraryLookup\", false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -168,4 +168,5 @@\n- * the special value {@code ALL-UNNAMED} can be used). If this option is specified,\n- * access to restricted methods are only granted to the modules listed by that option.\n- * If this option is not specified, access to restricted methods is enabled for all\n- * modules, but access to restricted methods will result in runtime warnings.\n+ * the special value {@code ALL-UNNAMED} can be used). Access to restricted methods\n+ * from modules not listed by that option is deemed <em>illegal<\/em>. Clients can\n+ * control how access to restricted methods is handled, using the command line\n+ * option {@code --illegal-native-access}. If this option is not specified,\n+ * illegal access to restricted methods will result in runtime warnings.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.lang.invoke.InnerClassLambdaMetafactory.MethodBody;\n@@ -71,2 +70,0 @@\n-    private static final Consumer<FieldBuilder> STATIC_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_STATIC);\n-    private static final Consumer<FieldBuilder> FINAL_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_FINAL);\n@@ -628,1 +625,1 @@\n-                       .withField(sdFieldName, CD_SPECIES_DATA, STATIC_FIELD_FLAGS);\n+                       .withField(sdFieldName, CD_SPECIES_DATA, ACC_STATIC);\n@@ -712,1 +709,1 @@\n-                        clb.withField(field.name, field.desc, FINAL_FIELD_FLAGS);\n+                        clb.withField(field.name, field.desc, ACC_FINAL);\n@@ -716,2 +713,2 @@\n-                    clb.withMethod(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n-                            new MethodBody(new Consumer<CodeBuilder>() {\n+                    clb.withMethodBody(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n+                            new Consumer<>() {\n@@ -723,1 +720,1 @@\n-                            }));\n+                            });\n@@ -730,2 +727,2 @@\n-                    clb.withMethod(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE,\n-                            new MethodBody(new Consumer<CodeBuilder>() {\n+                    clb.withMethodBody(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE,\n+                            new Consumer<>() {\n@@ -756,1 +753,1 @@\n-                            }));\n+                            });\n@@ -760,2 +757,2 @@\n-                    clb.withMethod(\"make\", methodDesc(ftryType), ACC_STATIC,\n-                            new MethodBody(new Consumer<CodeBuilder>() {\n+                    clb.withMethodBody(\"make\", methodDesc(ftryType), ACC_STATIC,\n+                            new Consumer<>() {\n@@ -776,1 +773,1 @@\n-                            }));\n+                            });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.constant.ConstantUtils;\n@@ -115,1 +116,1 @@\n-        return Wrapper.forPrimitiveType(name.charAt(0)).primitiveType();\n+        return ConstantUtils.forPrimitiveType(name, 0).resolveConstantDesc(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ConstantBootstraps.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,14 +75,0 @@\n-    \/\/ Static builders to avoid lambdas\n-    record FieldFlags(int flags) implements Consumer<FieldBuilder> {\n-        @Override\n-        public void accept(FieldBuilder fb) {\n-            fb.withFlags(flags);\n-        }\n-    };\n-    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n-        @Override\n-        public void accept(MethodBuilder mb) {\n-            mb.withCode(code);\n-        }\n-    };\n-\n@@ -327,1 +313,1 @@\n-                    clb.withField(argNames[i], argDescs[i], new FieldFlags(ACC_PRIVATE | ACC_FINAL));\n+                    clb.withField(argNames[i], argDescs[i], ACC_PRIVATE | ACC_FINAL);\n@@ -337,1 +323,1 @@\n-                clb.withMethod(interfaceMethodName,\n+                clb.withMethodBody(interfaceMethodName,\n@@ -345,1 +331,1 @@\n-                        clb.withMethod(interfaceMethodName,\n+                        clb.withMethodBody(interfaceMethodName,\n@@ -379,1 +365,1 @@\n-        clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, new FieldFlags(ACC_PRIVATE | ACC_STATIC | ACC_FINAL));\n+        clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n@@ -382,1 +368,1 @@\n-        clb.withMethod(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new Consumer<>() {\n@@ -392,1 +378,1 @@\n-        }));\n+        });\n@@ -400,2 +386,2 @@\n-        clb.withMethod(INIT_NAME, constructorTypeDesc, ACC_PRIVATE,\n-                new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(INIT_NAME, constructorTypeDesc, ACC_PRIVATE,\n+                new Consumer<>() {\n@@ -415,1 +401,1 @@\n-                }));\n+                });\n@@ -442,2 +428,2 @@\n-        clb.withMethod(SerializationSupport.NAME_METHOD_WRITE_REPLACE, SerializationSupport.MTD_Object, ACC_PRIVATE | ACC_FINAL,\n-                new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(SerializationSupport.NAME_METHOD_WRITE_REPLACE, SerializationSupport.MTD_Object, ACC_PRIVATE | ACC_FINAL,\n+                new Consumer<>() {\n@@ -471,1 +457,1 @@\n-                }));\n+                });\n@@ -507,2 +493,2 @@\n-    Consumer<MethodBuilder> forwardingMethod(MethodType methodType) {\n-        return new MethodBody(new Consumer<CodeBuilder>() {\n+    Consumer<CodeBuilder> forwardingMethod(MethodType methodType) {\n+        return new Consumer<>() {\n@@ -545,1 +531,1 @@\n-        });\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":15,"deletions":29,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,15 +86,0 @@\n-    \/\/ Static builders to avoid lambdas\n-    private static final Consumer<FieldBuilder> STATIC_FINAL_FIELD = new Consumer<FieldBuilder>() {\n-        @Override\n-        public void accept(FieldBuilder fb) {\n-            fb.withFlags(ACC_STATIC | ACC_FINAL);\n-        }\n-    };\n-\n-    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n-        @Override\n-        public void accept(MethodBuilder mb) {\n-            mb.withCode(code);\n-        }\n-    };\n-\n@@ -331,1 +316,1 @@\n-            clb.withField(p.name, p.desc, STATIC_FINAL_FIELD);\n+            clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n@@ -334,1 +319,1 @@\n-        clb.withMethod(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new Consumer<>() {\n@@ -359,1 +344,1 @@\n-        }));\n+        });\n@@ -1674,1 +1659,1 @@\n-            clb.withMethod(\"dummy\", MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+            clb.withMethodBody(\"dummy\", MTD_void, ACC_STATIC, new Consumer<>() {\n@@ -1681,1 +1666,1 @@\n-            }));\n+            });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -31,0 +32,2 @@\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -33,0 +36,2 @@\n+import jdk.internal.util.ReferenceKey;\n+import jdk.internal.util.ReferencedKeyMap;\n@@ -36,0 +41,1 @@\n+import java.lang.classfile.Annotation;\n@@ -39,0 +45,1 @@\n+import java.lang.classfile.MethodBuilder;\n@@ -40,0 +47,1 @@\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -41,1 +49,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -44,1 +51,4 @@\n-import java.lang.reflect.AccessFlag;\n+import java.lang.ref.SoftReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n@@ -47,0 +57,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -48,0 +59,1 @@\n+import java.util.function.Supplier;\n@@ -49,1 +61,2 @@\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -110,1 +123,0 @@\n-\n@@ -112,0 +124,1 @@\n+    private static final int FORCE_INLINE_THRESHOLD;\n@@ -115,1 +128,4 @@\n-        HIGH_ARITY_THRESHOLD = highArity != null ? Integer.parseInt(highArity) : 20;\n+        HIGH_ARITY_THRESHOLD = highArity != null ? Integer.parseInt(highArity) : 0;\n+\n+        String inlineThreshold = VM.getSavedProperty(\"java.lang.invoke.StringConcat.inlineThreshold\");\n+        FORCE_INLINE_THRESHOLD = inlineThreshold != null ? Integer.parseInt(inlineThreshold) : 16;\n@@ -374,7 +390,7 @@\n-            if (concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n-                return new ConstantCallSite(\n-                        generateMHInlineCopy(concatType, constantStrings)\n-                                .viewAsType(concatType, true));\n-            } else {\n-                return new ConstantCallSite(\n-                        SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings));\n+            MethodHandle mh = makeSimpleConcat(concatType, constantStrings);\n+            if (mh == null && concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n+                mh = generateMHInlineCopy(concatType, constantStrings);\n+            }\n+\n+            if (mh == null) {\n+                mh = InlineHiddenClassStrategy.generate(lookup, concatType, constantStrings);\n@@ -382,0 +398,3 @@\n+            mh = mh.viewAsType(concatType, true);\n+\n+            return new ConstantCallSite(mh);\n@@ -430,1 +449,1 @@\n-                consts[oCount++] = acc.length() > 0 ? acc.toString() : null;\n+                consts[oCount++] = acc.length() > 0 ? acc.toString() : \"\";\n@@ -446,1 +465,1 @@\n-        consts[oCount] = acc.length() > 0 ? acc.toString() : null;\n+        consts[oCount] = acc.length() > 0 ? acc.toString() : \"\";\n@@ -469,8 +488,1 @@\n-    \/**\n-     * <p>This strategy replicates what StringBuilders are doing: it builds the\n-     * byte[] array on its own and passes that byte[] array to String\n-     * constructor. This strategy requires access to some private APIs in JDK,\n-     * most notably, the private String constructor that accepts byte[] arrays\n-     * without copying.\n-     *\/\n-    private static MethodHandle generateMHInlineCopy(MethodType mt, String[] constants) {\n+    private static MethodHandle makeSimpleConcat(MethodType mt, String[] constants) {\n@@ -487,2 +499,2 @@\n-            if (prefix == null) {\n-                if (suffix == null) {\n+            if (prefix.isEmpty()) {\n+                if (suffix.isEmpty()) {\n@@ -493,1 +505,1 @@\n-            } else if (suffix == null && !mt.hasPrimitives()) {\n+            } else if (suffix.isEmpty() && !mt.hasPrimitives()) {\n@@ -497,3 +509,2 @@\n-        }\n-        if (paramCount == 2 && !mt.hasPrimitives() && suffix == null\n-                && constants[0] == null && constants[1] == null) {\n+        } else if (paramCount == 2 && !mt.hasPrimitives() && suffix.isEmpty()\n+                && constants[0].isEmpty() && constants[1].isEmpty()) {\n@@ -503,0 +514,16 @@\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * <p>This strategy replicates what StringBuilders are doing: it builds the\n+     * byte[] array on its own and passes that byte[] array to String\n+     * constructor. This strategy requires access to some private APIs in JDK,\n+     * most notably, the private String constructor that accepts byte[] arrays\n+     * without copying.\n+     *\/\n+    private static MethodHandle generateMHInlineCopy(MethodType mt, String[] constants) {\n+        int paramCount = mt.parameterCount();\n+        String suffix = constants[paramCount];\n+\n+\n@@ -1046,1 +1073,1 @@\n-     * Bytecode StringBuilder strategy.\n+     * Implement efficient hidden class strategy for String concatenation\n@@ -1048,2 +1075,5 @@\n-     * <p>This strategy emits StringBuilder chains as similar as possible\n-     * to what javac would. No exact sizing of parameters or estimates.\n+     * <p>This strategy replicates based on the bytecode what StringBuilders are doing: it builds the\n+     * byte[] array on its own and passes that byte[] array to String\n+     * constructor. This strategy requires access to some private APIs in JDK,\n+     * most notably, the private String constructor that accepts byte[] arrays\n+     * without copying.\n@@ -1051,3 +1081,4 @@\n-    private static final class SimpleStringBuilderStrategy {\n-        static final String METHOD_NAME = \"concat\";\n-        static final ClassDesc STRING_BUILDER = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringBuilder;\");\n+    private static final class InlineHiddenClassStrategy {\n+        static final String CLASS_NAME   = \"java.lang.String$$StringConcat\";\n+        static final String METHOD_NAME  = \"concat\";\n+\n@@ -1056,10 +1087,86 @@\n-        static final MethodTypeDesc APPEND_BOOLEAN_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_boolean);\n-        static final MethodTypeDesc APPEND_CHAR_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_char);\n-        static final MethodTypeDesc APPEND_DOUBLE_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_double);\n-        static final MethodTypeDesc APPEND_FLOAT_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_float);\n-        static final MethodTypeDesc APPEND_INT_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_int);\n-        static final MethodTypeDesc APPEND_LONG_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_long);\n-        static final MethodTypeDesc APPEND_OBJECT_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_Object);\n-        static final MethodTypeDesc APPEND_STRING_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_String);\n-        static final MethodTypeDesc INT_CONSTRUCTOR_TYPE = MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_int);\n-        static final MethodTypeDesc TO_STRING_TYPE = MethodTypeDesc.of(ConstantDescs.CD_String);\n+        static final MethodHandles.Lookup STR_LOOKUP = new MethodHandles.Lookup(String.class);\n+\n+        static final ClassDesc CD_CONCAT             = ConstantUtils.binaryNameToDesc(CLASS_NAME);\n+        static final ClassDesc CD_StringConcatHelper = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper;\");\n+        static final ClassDesc CD_StringConcatBase   = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper$StringConcatBase;\");\n+        static final ClassDesc CD_Array_byte         = ReferenceClassDescImpl.ofValidated(\"[B\");\n+        static final ClassDesc CD_Array_String       = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/String;\");\n+\n+        static final MethodTypeDesc MTD_byte_char       = MethodTypeDescImpl.ofValidated(CD_byte, CD_char);\n+        static final MethodTypeDesc MTD_byte            = MethodTypeDescImpl.ofValidated(CD_byte);\n+        static final MethodTypeDesc MTD_int             = MethodTypeDescImpl.ofValidated(CD_int);\n+        static final MethodTypeDesc MTD_int_int_boolean = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_boolean);\n+        static final MethodTypeDesc MTD_int_int_char    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_char);\n+        static final MethodTypeDesc MTD_int_int_int     = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_int);\n+        static final MethodTypeDesc MTD_int_int_long    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_long);\n+        static final MethodTypeDesc MTD_int_int_String  = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_String);\n+        static final MethodTypeDesc MTD_String_float    = MethodTypeDescImpl.ofValidated(CD_String, CD_float);\n+        static final MethodTypeDesc MTD_String_double   = MethodTypeDescImpl.ofValidated(CD_String, CD_double);\n+        static final MethodTypeDesc MTD_String_Object   = MethodTypeDescImpl.ofValidated(CD_String, CD_Object);\n+\n+        static final MethodTypeDesc MTD_INIT             = MethodTypeDescImpl.ofValidated(CD_void, CD_Array_String);\n+        static final MethodTypeDesc MTD_NEW_ARRAY_SUFFIX = MethodTypeDescImpl.ofValidated(CD_Array_byte, CD_String, CD_int, CD_byte);\n+        static final MethodTypeDesc MTD_STRING_INIT      = MethodTypeDescImpl.ofValidated(CD_void, CD_Array_byte, CD_byte);\n+\n+        static final MethodTypeDesc PREPEND_int     = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_int, CD_String);\n+        static final MethodTypeDesc PREPEND_long    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_long, CD_String);\n+        static final MethodTypeDesc PREPEND_boolean = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_boolean, CD_String);\n+        static final MethodTypeDesc PREPEND_char    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_char, CD_String);\n+        static final MethodTypeDesc PREPEND_String  = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_String, CD_String);\n+\n+        static final RuntimeVisibleAnnotationsAttribute FORCE_INLINE = RuntimeVisibleAnnotationsAttribute.of(Annotation.of(ClassDesc.ofDescriptor(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\")));\n+\n+        static final MethodType CONSTRUCTOR_METHOD_TYPE        = MethodType.methodType(void.class, String[].class);\n+        static final Consumer<CodeBuilder> CONSTRUCTOR_BUILDER = new Consumer<CodeBuilder>() {\n+            @Override\n+            public void accept(CodeBuilder cb) {\n+                \/*\n+                 * super(constants);\n+                 *\/\n+                int thisSlot      = cb.receiverSlot(),\n+                    constantsSlot = cb.parameterSlot(0);\n+                cb.aload(thisSlot)\n+                  .aload(constantsSlot)\n+                  .invokespecial(CD_StringConcatBase, INIT_NAME, MTD_INIT, false)\n+                  .return_();\n+            }\n+        };\n+\n+        static final ReferencedKeyMap<MethodType, SoftReference<MethodHandlePair>> CACHE =\n+                ReferencedKeyMap.create(true, true,\n+                        new Supplier<>() {\n+                            @Override\n+                            public Map<ReferenceKey<MethodType>, SoftReference<MethodHandlePair>> get() {\n+                                return new ConcurrentHashMap<>(64);\n+                            }\n+                        });\n+\n+        private InlineHiddenClassStrategy() {\n+            \/\/ no instantiation\n+        }\n+\n+        private record MethodHandlePair(MethodHandle constructor, MethodHandle concatenator) { };\n+\n+        \/**\n+         * The parameter types are normalized into 7 types: int,long,boolean,char,float,double,Object\n+         *\/\n+        private static MethodType erasedArgs(MethodType args) {\n+            int parameterCount = args.parameterCount();\n+            var paramTypes = new Class<?>[parameterCount];\n+            boolean changed = false;\n+            for (int i = 0; i < parameterCount; i++) {\n+                Class<?> cl = args.parameterType(i);\n+                \/\/ Use int as the logical type for subword integral types\n+                \/\/ (byte and short). char and boolean require special\n+                \/\/ handling so don't change the logical type of those\n+                if (cl == byte.class || cl == short.class) {\n+                    cl = int.class;\n+                    changed = true;\n+                } else if (cl != Object.class && !cl.isPrimitive()) {\n+                    cl = Object.class;\n+                    changed = true;\n+                }\n+                paramTypes[i] = cl;\n+            }\n+            return changed ? MethodType.methodType(args.returnType(), paramTypes, true) : args;\n+        }\n@@ -1068,2 +1175,8 @@\n-         * Ensure a capacity in the initial StringBuilder to accommodate all\n-         * constants plus this factor times the number of arguments.\n+         * Construct the MethodType of the prepend method, The parameters only support 5 types:\n+         * int\/long\/char\/boolean\/String. Not int\/long\/char\/boolean type, use String type<p>\n+         *\n+         * The following is an example of the generated target code:\n+         * <blockquote><pre>\n+         *  int prepend(int length, byte coder, byte[] buff,  String[] constants\n+         *      int arg0, long arg1, boolean arg2, char arg3, String arg5)\n+         * <\/pre><\/blockquote>\n@@ -1071,1 +1184,14 @@\n-        static final int ARGUMENT_SIZE_FACTOR = 4;\n+        private static MethodTypeDesc prependArgs(MethodType concatArgs) {\n+            int parameterCount = concatArgs.parameterCount();\n+            var paramTypes = new ClassDesc[parameterCount + 4];\n+            paramTypes[0] = CD_int;          \/\/ length\n+            paramTypes[1] = CD_byte;         \/\/ coder\n+            paramTypes[2] = CD_Array_byte;   \/\/ buff\n+            paramTypes[3] = CD_Array_String; \/\/ constants\n+\n+            for (int i = 0; i < parameterCount; i++) {\n+                var cl = concatArgs.parameterType(i);\n+                paramTypes[i + 4] = needStringOf(cl) ? CD_String : ConstantUtils.classDesc(cl);\n+            }\n+            return MethodTypeDescImpl.ofValidated(CD_int, paramTypes);\n+        }\n@@ -1073,1 +1199,6 @@\n-        static final Set<Lookup.ClassOption> SET_OF_STRONG = Set.of(STRONG);\n+        \/**\n+         * Construct the MethodType of the coder method. The first parameter is the initialized coder.\n+         * Only parameter types which can be UTF16 are added. Returns null if no such parameter exists.\n+         *\/\n+        private static MethodTypeDesc coderArgsIfMaybeUTF16(MethodType concatArgs) {\n+            int parameterCount = concatArgs.parameterCount();\n@@ -1075,2 +1206,35 @@\n-        private SimpleStringBuilderStrategy() {\n-            \/\/ no instantiation\n+            int maybeUTF16Count = 0;\n+            for (int i = 0; i < parameterCount; i++) {\n+                if (maybeUTF16(concatArgs.parameterType(i))) {\n+                    maybeUTF16Count++;\n+                }\n+            }\n+\n+            if (maybeUTF16Count == 0) {\n+                return null;\n+            }\n+\n+            var paramTypes = new ClassDesc[maybeUTF16Count + 1];\n+            paramTypes[0] = CD_int; \/\/ init coder\n+            for (int i = 0, paramIndex = 1; i < parameterCount; i++) {\n+                var cl = concatArgs.parameterType(i);\n+                if (maybeUTF16(cl)) {\n+                    paramTypes[paramIndex++] = cl == char.class ? CD_char : CD_String;\n+                }\n+            }\n+            return MethodTypeDescImpl.ofValidated(CD_int, paramTypes);\n+        }\n+\n+        \/**\n+         * Construct the MethodType of the length method,\n+         * The first parameter is the initialized length\n+         *\/\n+        private static MethodTypeDesc lengthArgs(MethodType concatArgs) {\n+            int parameterCount = concatArgs.parameterCount();\n+            var paramTypes = new ClassDesc[parameterCount + 1];\n+            paramTypes[0] = CD_int; \/\/ init long\n+            for (int i = 0; i < parameterCount; i++) {\n+                var cl = concatArgs.parameterType(i);\n+                paramTypes[i + 1] = needStringOf(cl) ? CD_String : ConstantUtils.classDesc(cl);\n+            }\n+            return MethodTypeDescImpl.ofValidated(CD_int, paramTypes);\n@@ -1080,1 +1244,25 @@\n-            String className = getClassName(lookup.lookupClass());\n+            lookup = STR_LOOKUP;\n+            final MethodType concatArgs = erasedArgs(args);\n+\n+            \/\/ 1 argment use built-in method\n+            if (args.parameterCount() == 1) {\n+                Object concat1 = JLA.stringConcat1(constants);\n+                var handle = lookup.findVirtual(concat1.getClass(), METHOD_NAME, concatArgs);\n+                return handle.bindTo(concat1);\n+            }\n+\n+            var weakConstructorHandle = CACHE.get(concatArgs);\n+            if (weakConstructorHandle != null) {\n+                MethodHandlePair handlePair = weakConstructorHandle.get();\n+                if (handlePair != null) {\n+                    try {\n+                        var instance = handlePair.constructor.invoke(constants);\n+                        return handlePair.concatenator.bindTo(instance);\n+                    } catch (Throwable e) {\n+                        throw new StringConcatException(\"Exception while utilizing the hidden class\", e);\n+                    }\n+                }\n+            }\n+            MethodTypeDesc lengthArgs  = lengthArgs(concatArgs),\n+                           coderArgs   = coderArgsIfMaybeUTF16(concatArgs),\n+                           prependArgs = prependArgs(concatArgs);\n@@ -1082,1 +1270,1 @@\n-            byte[] classBytes = ClassFile.of().build(ConstantUtils.binaryNameToDesc(className),\n+            byte[] classBytes = ClassFile.of().build(CD_CONCAT,\n@@ -1084,0 +1272,2 @@\n+                        final boolean forceInline = concatArgs.parameterCount() < FORCE_INLINE_THRESHOLD;\n+\n@@ -1086,5 +1276,55 @@\n-                            clb.withFlags(AccessFlag.FINAL, AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n-                                .withMethodBody(METHOD_NAME,\n-                                        ConstantUtils.methodTypeDesc(args),\n-                                        ClassFile.ACC_FINAL | ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC,\n-                                        generateMethod(constants, args));\n+                            clb.withSuperclass(CD_StringConcatBase)\n+                                .withFlags(ACC_FINAL | ACC_SUPER | ACC_SYNTHETIC)\n+                                .withMethodBody(INIT_NAME, MTD_INIT, 0, CONSTRUCTOR_BUILDER)\n+                                .withMethod(\"length\",\n+                                        lengthArgs,\n+                                        ACC_STATIC | ACC_PRIVATE,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generateLengthMethod(lengthArgs));\n+                                            }\n+                                        })\n+                                .withMethod(\"prepend\",\n+                                        prependArgs,\n+                                        ACC_STATIC | ACC_PRIVATE,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generatePrependMethod(prependArgs));\n+                                            }\n+                                        })\n+                                .withMethod(METHOD_NAME,\n+                                        ConstantUtils.methodTypeDesc(concatArgs),\n+                                        ACC_FINAL,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generateConcatMethod(\n+                                                        CD_CONCAT,\n+                                                        concatArgs,\n+                                                        lengthArgs,\n+                                                        coderArgs,\n+                                                        prependArgs));\n+                                            }\n+                                        });\n+\n+                            if (coderArgs != null) {\n+                                clb.withMethod(\"coder\",\n+                                        coderArgs,\n+                                        ACC_STATIC | ACC_PRIVATE,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generateCoderMethod(coderArgs));\n+                                            }\n+                                        });\n+                            }\n@@ -1093,5 +1333,8 @@\n-                Lookup hiddenLookup = lookup.makeHiddenClassDefiner(className, classBytes, SET_OF_STRONG, DUMPER)\n-                                            .defineClassAsLookup(true);\n-                Class<?> innerClass = hiddenLookup.lookupClass();\n-                return hiddenLookup.findStatic(innerClass, METHOD_NAME, args);\n-            } catch (Exception e) {\n+                var hiddenClass = lookup.makeHiddenClassDefiner(CLASS_NAME, classBytes, Set.of(), DUMPER)\n+                                        .defineClass(true, null);\n+                var constructor = lookup.findConstructor(hiddenClass, CONSTRUCTOR_METHOD_TYPE);\n+                var concat      = lookup.findVirtual(hiddenClass, METHOD_NAME, concatArgs);\n+                CACHE.put(concatArgs, new SoftReference<>(new MethodHandlePair(constructor, concat)));\n+                var instance = hiddenClass.cast(constructor.invoke(constants));\n+                return concat.bindTo(instance);\n+            } catch (Throwable e) {\n@@ -1102,1 +1345,71 @@\n-        private static Consumer<CodeBuilder> generateMethod(String[] constants, MethodType args) {\n+        \/**\n+         * Generate InlineCopy-based code. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         *  import static java.lang.StringConcatHelper.newArrayWithSuffix;\n+         *  import static java.lang.StringConcatHelper.prepend;\n+         *  import static java.lang.StringConcatHelper.stringCoder;\n+         *  import static java.lang.StringConcatHelper.stringSize;\n+         *\n+         *  class StringConcat extends java.lang.StringConcatHelper.StringConcatBase {\n+         *      \/\/ super class defines\n+         *      \/\/ String[] constants;\n+         *      \/\/ int length;\n+         *      \/\/ byte coder;\n+         *\n+         *      StringConcat(String[] constants) {\n+         *          super(constants);\n+         *      }\n+         *\n+         *      String concat(int arg0, long arg1, boolean arg2, char arg3, String arg4,\n+         *          float arg5, double arg6, Object arg7\n+         *      ) {\n+         *          \/\/ Types other than byte\/short\/int\/long\/boolean\/String require a local variable to store\n+         *          String str4 = stringOf(arg4);\n+         *          String str5 = stringOf(arg5);\n+         *          String str6 = stringOf(arg6);\n+         *          String str7 = stringOf(arg7);\n+         *\n+         *          int coder  = coder(this.coder, arg0, arg1, arg2, arg3, str4, str5, str6, str7);\n+         *          int length = length(this.length, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n+         *          String[] constants = this.constants;\n+         *          byte[] buf = newArrayWithSuffix(constants[paramCount], length. coder);\n+         *\n+         *          prepend(length, coder, buf, constants, arg0, arg1, arg2, arg3, str4, str5, str6, str7);\n+         *\n+         *          return new String(buf, coder);\n+         *      }\n+         *\n+         *      static int length(int length, int arg0, long arg1, boolean arg2, char arg3,\n+         *                       String arg4, String arg5, String arg6, String arg7) {\n+         *          return stringSize(stringSize(stringSize(stringSize(stringSize(stringSize(stringSize(stringSize(\n+         *                      length, arg0), arg1), arg2), arg3), arg4), arg5), arg6), arg7);\n+         *      }\n+         *\n+         *      static int cocder(int coder, char arg3, String str4, String str5, String str6, String str7) {\n+         *          return coder | stringCoder(arg3) | str4.coder() | str5.coder() | str6.coder() | str7.coder();\n+         *      }\n+         *\n+         *      static int prepend(int length, int coder, byte[] buf, String[] constants,\n+         *                     int arg0, long arg1, boolean arg2, char arg3,\n+         *                     String str4, String str5, String str6, String str7) {\n+         *          \/\/ StringConcatHelper.prepend\n+         *          return prepend(prepend(prepend(prepend(\n+         *                  prepend(apppend(prepend(prepend(length,\n+         *                       buf, str7, constant[7]), buf, str6, constant[6]),\n+         *                       buf, str5, constant[5]), buf, str4, constant[4]),\n+         *                       buf, arg3, constant[3]), buf, arg2, constant[2]),\n+         *                       buf, arg1, constant[1]), buf, arg0, constant[0]);\n+         *      }\n+         *  }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        private static Consumer<CodeBuilder> generateConcatMethod(\n+                ClassDesc      concatClass,\n+                MethodType     concatArgs,\n+                MethodTypeDesc lengthArgs,\n+                MethodTypeDesc coderArgs,\n+                MethodTypeDesc prependArgs\n+        ) {\n@@ -1106,7 +1419,35 @@\n-                    cb.new_(STRING_BUILDER);\n-                    cb.dup();\n-\n-                    int len = 0;\n-                    for (String constant : constants) {\n-                        if (constant != null) {\n-                            len += constant.length();\n+                    \/\/ Compute parameter variable slots\n+                    int paramCount    = concatArgs.parameterCount(),\n+                        thisSlot      = cb.receiverSlot(),\n+                        lengthSlot    = cb.allocateLocal(TypeKind.IntType),\n+                        coderSlot     = cb.allocateLocal(TypeKind.ByteType),\n+                        bufSlot       = cb.allocateLocal(TypeKind.ReferenceType),\n+                        constantsSlot = cb.allocateLocal(TypeKind.ReferenceType),\n+                        suffixSlot    = cb.allocateLocal(TypeKind.ReferenceType);\n+\n+                    \/*\n+                     * Types other than int\/long\/char\/boolean require local variables to store the result of stringOf.\n+                     *\n+                     * stringSlots stores the slots of parameters relative to local variables\n+                     *\n+                     * str0 = stringOf(arg0);\n+                     * str1 = stringOf(arg1);\n+                     * ...\n+                     * strN = toString(argN);\n+                     *\/\n+                    int[] stringSlots = new int[paramCount];\n+                    for (int i = 0; i < paramCount; i++) {\n+                        var cl = concatArgs.parameterType(i);\n+                        if (needStringOf(cl)) {\n+                            MethodTypeDesc methodTypeDesc;\n+                            if (cl == float.class) {\n+                                methodTypeDesc = MTD_String_float;\n+                            } else if (cl == double.class) {\n+                                methodTypeDesc = MTD_String_double;\n+                            } else {\n+                                methodTypeDesc = MTD_String_Object;\n+                            }\n+                            stringSlots[i] = cb.allocateLocal(TypeKind.ReferenceType);\n+                            cb.loadLocal(TypeKind.from(cl), cb.parameterSlot(i))\n+                              .invokestatic(CD_StringConcatHelper, \"stringOf\", methodTypeDesc)\n+                              .astore(stringSlots[i]);\n@@ -1115,11 +1456,15 @@\n-                    len += args.parameterCount() * ARGUMENT_SIZE_FACTOR;\n-                    cb.loadConstant(len);\n-                    cb.invokespecial(STRING_BUILDER, \"<init>\", INT_CONSTRUCTOR_TYPE);\n-\n-                    \/\/ At this point, we have a blank StringBuilder on stack, fill it in with .append calls.\n-                    {\n-                        int off = 0;\n-                        for (int c = 0; c < args.parameterCount(); c++) {\n-                            if (constants[c] != null) {\n-                                cb.ldc(constants[c]);\n-                                cb.invokevirtual(STRING_BUILDER, \"append\", APPEND_STRING_TYPE);\n+\n+                    \/*\n+                     * coder = coder(this.coder, arg0, arg1, ... argN);\n+                     *\/\n+                    cb.aload(thisSlot)\n+                      .getfield(concatClass, \"coder\", CD_byte);\n+                    if (coderArgs != null) {\n+                        for (int i = 0; i < paramCount; i++) {\n+                            var cl = concatArgs.parameterType(i);\n+                            if (maybeUTF16(cl)) {\n+                                if (cl == char.class) {\n+                                    cb.loadLocal(TypeKind.CharType, cb.parameterSlot(i));\n+                                } else {\n+                                    cb.aload(stringSlots[i]);\n+                                }\n@@ -1127,6 +1472,0 @@\n-                            Class<?> cl = args.parameterType(c);\n-                            TypeKind kind = TypeKind.from(cl);\n-                            cb.loadLocal(kind, off);\n-                            off += kind.slotSize();\n-                            MethodTypeDesc desc = getSBAppendDesc(cl);\n-                            cb.invokevirtual(STRING_BUILDER, \"append\", desc);\n@@ -1134,3 +1473,62 @@\n-                        if (constants[constants.length - 1] != null) {\n-                            cb.ldc(constants[constants.length - 1]);\n-                            cb.invokevirtual(STRING_BUILDER, \"append\", APPEND_STRING_TYPE);\n+                        cb.invokestatic(concatClass, \"coder\", coderArgs);\n+                    }\n+                    cb.istore(coderSlot);\n+\n+                    \/*\n+                     * length = length(this.length, arg0, arg1, ..., argN);\n+                     *\/\n+                    cb.aload(thisSlot)\n+                      .getfield(concatClass, \"length\", CD_int);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        var cl        = concatArgs.parameterType(i);\n+                        int paramSlot = cb.parameterSlot(i);\n+                        if (needStringOf(cl)) {\n+                            paramSlot = stringSlots[i];\n+                            cl = String.class;\n+                        }\n+                        cb.loadLocal(TypeKind.from(cl), paramSlot);\n+                    }\n+                    cb.invokestatic(concatClass, \"length\", lengthArgs);\n+\n+                    \/*\n+                     * String[] constants = this.constants;\n+                     * suffix  = constants[paramCount];\n+                     * length -= suffix.length();\n+                     *\/\n+                    cb.aload(thisSlot)\n+                      .getfield(concatClass, \"constants\", CD_Array_String)\n+                      .dup()\n+                      .astore(constantsSlot)\n+                      .ldc(paramCount)\n+                      .aaload()\n+                      .dup()\n+                      .astore(suffixSlot)\n+                      .invokevirtual(CD_String, \"length\", MTD_int)\n+                      .isub()\n+                      .istore(lengthSlot);\n+\n+                    \/*\n+                     * Allocate buffer :\n+                     *\n+                     *  buf = newArrayWithSuffix(suffix, length, coder)\n+                     *\/\n+                    cb.aload(suffixSlot)\n+                      .iload(lengthSlot)\n+                      .iload(coderSlot)\n+                      .invokestatic(CD_StringConcatHelper, \"newArrayWithSuffix\", MTD_NEW_ARRAY_SUFFIX)\n+                      .astore(bufSlot);\n+\n+                    \/*\n+                     * prepend(length, coder, buf, constants, ar0, ar1, ..., argN);\n+                     *\/\n+                    cb.iload(lengthSlot)\n+                      .iload(coderSlot)\n+                      .aload(bufSlot)\n+                      .aload(constantsSlot);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        var cl = concatArgs.parameterType(i);\n+                        int paramSlot = cb.parameterSlot(i);\n+                        var kind = TypeKind.from(cl);\n+                        if (needStringOf(cl)) {\n+                            paramSlot = stringSlots[i];\n+                            kind = TypeKind.ReferenceType;\n@@ -1138,0 +1536,1 @@\n+                        cb.loadLocal(kind, paramSlot);\n@@ -1139,0 +1538,12 @@\n+                    cb.invokestatic(concatClass, \"prepend\", prependArgs);\n+\n+                    \/\/ return new String(buf, coder);\n+                    cb.new_(CD_String)\n+                      .dup()\n+                      .aload(bufSlot)\n+                      .iload(coderSlot)\n+                      .invokespecial(CD_String, INIT_NAME, MTD_STRING_INIT)\n+                      .areturn();\n+                }\n+            };\n+        }\n@@ -1140,2 +1551,38 @@\n-                    cb.invokevirtual(STRING_BUILDER, \"toString\", TO_STRING_TYPE);\n-                    cb.areturn();\n+        \/**\n+         * Generate length method. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         * import static java.lang.StringConcatHelper.stringSize;\n+         *\n+         * static int length(int length, int arg0, long arg1, boolean arg2, char arg3,\n+         *                  String arg4, String arg5, String arg6, String arg7) {\n+         *     return stringSize(stringSize(stringSize(length, arg0), arg1), ..., arg7);\n+         * }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        private static Consumer<CodeBuilder> generateLengthMethod(MethodTypeDesc lengthArgs) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    int lengthSlot = cb.parameterSlot(0);\n+                    cb.iload(lengthSlot);\n+                    for (int i = 1; i < lengthArgs.parameterCount(); i++) {\n+                        var cl = lengthArgs.parameterType(i);\n+                        MethodTypeDesc methodTypeDesc;\n+                        if (cl == CD_char) {\n+                            methodTypeDesc = MTD_int_int_char;\n+                        } else if (cl == CD_int) {\n+                            methodTypeDesc = MTD_int_int_int;\n+                        } else if (cl == CD_long) {\n+                            methodTypeDesc = MTD_int_int_long;\n+                        } else if (cl == CD_boolean) {\n+                            methodTypeDesc = MTD_int_int_boolean;\n+                        } else {\n+                            methodTypeDesc = MTD_int_int_String;\n+                        }\n+                        cb.loadLocal(TypeKind.from(cl), cb.parameterSlot(i))\n+                          .invokestatic(CD_StringConcatHelper, \"stringSize\", methodTypeDesc);\n+                    }\n+                    cb.ireturn();\n@@ -1147,3 +1594,11 @@\n-         * The generated class is in the same package as the host class as\n-         * it's the implementation of the string concatenation for the host\n-         * class.\n+         * Generate coder method. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         * import static java.lang.StringConcatHelper.stringCoder;\n+         *\n+         * static int cocder(int coder, char arg3, String str4, String str5, String str6, String str7) {\n+         *     return coder | stringCoder(arg3) | str4.coder() | str5.coder() | str6.coder() | str7.coder();\n+         * }\n+         * <\/pre><\/blockquote>\n@@ -1151,4 +1606,22 @@\n-        private static String getClassName(Class<?> hostClass) {\n-            String name = hostClass.isHidden() ? hostClass.getName().replace('\/', '_')\n-                    : hostClass.getName();\n-            return name + \"$$StringConcat\";\n+        private static Consumer<CodeBuilder> generateCoderMethod(MethodTypeDesc coderArgs) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    \/*\n+                     * return coder | stringCoder(argN) | ... | arg1.coder() | arg0.coder();\n+                     *\/\n+                    int coderSlot = cb.parameterSlot(0);\n+                    cb.iload(coderSlot);\n+                    for (int i = 1; i < coderArgs.parameterCount(); i++) {\n+                        var cl = coderArgs.parameterType(i);\n+                        cb.loadLocal(TypeKind.from(cl), cb.parameterSlot(i));\n+                        if (cl == CD_char) {\n+                            cb.invokestatic(CD_StringConcatHelper, \"stringCoder\", MTD_byte_char);\n+                        } else {\n+                            cb.invokevirtual(CD_String, \"coder\", MTD_byte);\n+                        }\n+                        cb.ior();\n+                    }\n+                    cb.ireturn();\n+                }\n+            };\n@@ -1157,16 +1630,68 @@\n-        private static MethodTypeDesc getSBAppendDesc(Class<?> cl) {\n-            if (cl.isPrimitive()) {\n-                if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {\n-                    return APPEND_INT_TYPE;\n-                } else if (cl == Boolean.TYPE) {\n-                    return APPEND_BOOLEAN_TYPE;\n-                } else if (cl == Character.TYPE) {\n-                    return APPEND_CHAR_TYPE;\n-                } else if (cl == Double.TYPE) {\n-                    return APPEND_DOUBLE_TYPE;\n-                } else if (cl == Float.TYPE) {\n-                    return APPEND_FLOAT_TYPE;\n-                } else if (cl == Long.TYPE) {\n-                    return APPEND_LONG_TYPE;\n-                } else {\n-                    throw new IllegalStateException(\"Unhandled primitive StringBuilder.append: \" + cl);\n+        \/**\n+         * Generate prepend method. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         * import static java.lang.StringConcatHelper.prepend;\n+         *\n+         * static int prepend(int length, int coder, byte[] buf, String[] constants,\n+         *                int arg0, long arg1, boolean arg2, char arg3,\n+         *                String str4, String str5, String str6, String str7) {\n+         *\n+         *     return prepend(prepend(prepend(prepend(\n+         *             prepend(prepend(prepend(prepend(length,\n+         *                  buf, str7, constant[7]), buf, str6, constant[6]),\n+         *                  buf, str5, constant[5]), buf, str4, constant[4]),\n+         *                  buf, arg3, constant[3]), buf, arg2, constant[2]),\n+         *                  buf, arg1, constant[1]), buf, arg0, constant[0]);\n+         * }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        private static Consumer<CodeBuilder> generatePrependMethod(MethodTypeDesc prependArgs) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    \/\/ Compute parameter variable slots\n+                    int lengthSlot    = cb.parameterSlot(0),\n+                        coderSlot     = cb.parameterSlot(1),\n+                        bufSlot       = cb.parameterSlot(2),\n+                        constantsSlot = cb.parameterSlot(3);\n+                    \/*\n+                     * \/\/ StringConcatHelper.prepend\n+                     * return prepend(prepend(prepend(prepend(\n+                     *         prepend(apppend(prepend(prepend(length,\n+                     *              buf, str7, constant[7]), buf, str6, constant[6]),\n+                     *              buf, str5, constant[5]), buf, arg4, constant[4]),\n+                     *              buf, arg3, constant[3]), buf, arg2, constant[2]),\n+                     *              buf, arg1, constant[1]), buf, arg0, constant[0]);\n+                     *\/\n+                    cb.iload(lengthSlot);\n+                    for (int i = prependArgs.parameterCount() - 1; i >= 4; i--) {\n+                        var cl   = prependArgs.parameterType(i);\n+                        var kind = TypeKind.from(cl);\n+\n+                        \/\/ There are only 5 types of parameters: int, long, boolean, char, String\n+                        MethodTypeDesc methodTypeDesc;\n+                        if (cl == CD_int) {\n+                            methodTypeDesc = PREPEND_int;\n+                        } else if (cl == CD_long) {\n+                            methodTypeDesc = PREPEND_long;\n+                        } else if (cl == CD_boolean) {\n+                            methodTypeDesc = PREPEND_boolean;\n+                        } else if (cl == CD_char) {\n+                            methodTypeDesc = PREPEND_char;\n+                        } else {\n+                            kind = TypeKind.ReferenceType;\n+                            methodTypeDesc = PREPEND_String;\n+                        }\n+\n+                        cb.iload(coderSlot)\n+                          .aload(bufSlot)\n+                          .loadLocal(kind, cb.parameterSlot(i))\n+                          .aload(constantsSlot)\n+                          .ldc(i - 4)\n+                          .aaload()\n+                          .invokestatic(CD_StringConcatHelper, \"prepend\", methodTypeDesc);\n+                    }\n+                    cb.ireturn();\n@@ -1174,5 +1699,9 @@\n-            } else if (cl == String.class) {\n-                return APPEND_STRING_TYPE;\n-            } else {\n-                return APPEND_OBJECT_TYPE;\n-            }\n+            };\n+        }\n+\n+        static boolean needStringOf(Class<?> cl) {\n+            return cl != int.class && cl != long.class && cl != boolean.class && cl != char.class;\n+        }\n+\n+        static boolean maybeUTF16(Class<?> cl) {\n+            return cl == char.class || !cl.isPrimitive();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":649,"deletions":120,"binary":false,"changes":769,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -31,0 +32,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -48,1 +50,1 @@\n-    static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, long.class);\n+    static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, MemoryLayout.class, long.class, long.class);\n@@ -56,1 +58,1 @@\n-        return accessType.accessModeType(MemorySegment.class, $type$.class, long.class);\n+        return accessType.accessModeType(MemorySegment.class, $type$.class, MemoryLayout.class, long.class, long.class);\n@@ -100,1 +102,1 @@\n-    static AbstractMemorySegmentImpl checkReadOnly(Object obb, boolean ro) {\n+    static AbstractMemorySegmentImpl checkSegment(Object obb, Object encl, long base, boolean ro) {\n@@ -102,1 +104,1 @@\n-        oo.checkReadOnly(ro);\n+        oo.checkEnclosingLayout(base, (MemoryLayout)encl, ro);\n@@ -107,1 +109,1 @@\n-    static long offsetNonPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+    static long offsetNonPlain(AbstractMemorySegmentImpl bb, long base, long offset, long alignmentMask) {\n@@ -111,1 +113,1 @@\n-        return offsetPlain(bb, offset);\n+        return offsetPlain(bb, base, offset);\n@@ -115,3 +117,3 @@\n-    static long offsetPlain(AbstractMemorySegmentImpl bb, long offset) {\n-        long base = bb.unsafeGetOffset();\n-        return base + offset;\n+    static long offsetPlain(AbstractMemorySegmentImpl bb, long base, long offset) {\n+        long segment_base = bb.unsafeGetOffset();\n+        return segment_base + base + offset;\n@@ -121,1 +123,1 @@\n-    static $type$ get(VarHandle ob, Object obb, long base) {\n+    static $type$ get(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -123,1 +125,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -127,1 +129,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -134,1 +136,1 @@\n-                offsetPlain(bb, base));\n+                offsetPlain(bb, base, offset));\n@@ -138,1 +140,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -145,1 +147,1 @@\n-    static void set(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void set(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -147,1 +149,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -151,1 +153,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -158,1 +160,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -163,1 +165,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -171,1 +173,1 @@\n-    static $type$ getVolatile(VarHandle ob, Object obb, long base) {\n+    static $type$ getVolatile(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -173,1 +175,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -177,1 +179,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n@@ -181,1 +183,1 @@\n-    static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setVolatile(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -183,1 +185,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -186,1 +188,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -191,1 +193,1 @@\n-    static $type$ getAcquire(VarHandle ob, Object obb, long base) {\n+    static $type$ getAcquire(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -193,1 +195,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -197,1 +199,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n@@ -201,1 +203,1 @@\n-    static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -203,1 +205,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -206,1 +208,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -211,1 +213,1 @@\n-    static $type$ getOpaque(VarHandle ob, Object obb, long base) {\n+    static $type$ getOpaque(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -213,1 +215,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -217,1 +219,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n@@ -221,1 +223,1 @@\n-    static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setOpaque(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -223,1 +225,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -226,1 +228,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -232,1 +234,1 @@\n-    static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean compareAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -234,1 +236,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -237,1 +239,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -242,1 +244,1 @@\n-    static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchange(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -244,1 +246,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -248,1 +250,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -253,1 +255,1 @@\n-    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -255,1 +257,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -259,1 +261,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -264,1 +266,1 @@\n-    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -266,1 +268,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -270,1 +272,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -275,1 +277,1 @@\n-    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -277,1 +279,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -280,1 +282,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -285,1 +287,1 @@\n-    static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -287,1 +289,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -290,1 +292,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -295,1 +297,1 @@\n-    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -297,1 +299,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -300,1 +302,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -305,1 +307,1 @@\n-    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -307,1 +309,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -310,1 +312,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -315,1 +317,1 @@\n-    static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -317,1 +319,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -321,1 +323,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -326,1 +328,1 @@\n-    static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSetAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -328,1 +330,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -332,1 +334,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -337,1 +339,1 @@\n-    static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSetRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -339,1 +341,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -343,1 +345,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -350,1 +352,1 @@\n-    static $type$ getAndAdd(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAdd(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n@@ -352,1 +354,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -356,1 +358,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -359,1 +361,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n@@ -364,1 +366,1 @@\n-    static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAddAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n@@ -366,1 +368,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -370,1 +372,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -373,1 +375,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n@@ -378,1 +380,1 @@\n-    static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAddRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n@@ -380,1 +382,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -384,1 +386,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -387,1 +389,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n@@ -406,1 +408,1 @@\n-    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -408,1 +410,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -412,1 +414,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -415,1 +417,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -420,1 +422,1 @@\n-    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -422,1 +424,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -426,1 +428,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -429,1 +431,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -434,1 +436,1 @@\n-    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -436,1 +438,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -440,1 +442,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -443,1 +445,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -460,1 +462,1 @@\n-    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -462,1 +464,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -466,1 +468,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -469,1 +471,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -474,1 +476,1 @@\n-    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -476,1 +478,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -480,1 +482,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -483,1 +485,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -488,1 +490,1 @@\n-    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -490,1 +492,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -494,1 +496,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -497,1 +499,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -515,1 +517,1 @@\n-    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -517,1 +519,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -521,1 +523,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -524,1 +526,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -529,1 +531,1 @@\n-    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -531,1 +533,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -535,1 +537,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -538,1 +540,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -543,1 +545,1 @@\n-    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -545,1 +547,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -549,1 +551,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -552,1 +554,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":120,"deletions":118,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -157,3 +157,3 @@\n- * specific. In the JDK the default set of root modules contains every module\n- * that is observable on the upgrade module path or among the system modules,\n- * and that exports at least one package without qualification. <\/p>\n+ * specific. In the JDK the default set of root modules contains every module on\n+ * the upgrade module path or among the system modules that exports at least one\n+ * package, without qualification. <\/p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -168,0 +168,8 @@\n+    \/\/ Creates a new root constructor with a custom accessor for serialization hooks.\n+    Constructor<T> newWithAccessor(ConstructorAccessor accessor) {\n+        var res = new Constructor<>(clazz, parameterTypes, exceptionTypes, modifiers, slot,\n+                signature, annotations, parameterAnnotations);\n+        res.constructorAccessor = accessor;\n+        return res;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -176,15 +176,0 @@\n-    \/**\n-     * Make a copy of a leaf method.\n-     *\/\n-    Method leafCopy() {\n-        if (this.root == null)\n-            throw new IllegalArgumentException(\"Can only leafCopy a non-root Method\");\n-\n-        Method res = new Method(clazz, name, parameterTypes, returnType,\n-                exceptionTypes, modifiers, slot, signature,\n-                annotations, parameterAnnotations, annotationDefault);\n-        res.root = root;\n-        res.methodAccessor = methodAccessor;\n-        return res;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import jdk.internal.reflect.MethodAccessor;\n+import jdk.internal.access.JavaLangReflectAccess;\n@@ -34,53 +34,3 @@\n-\n-class ReflectAccess implements jdk.internal.access.JavaLangReflectAccess {\n-    public <T> Constructor<T> newConstructor(Class<T> declaringClass,\n-                                             Class<?>[] parameterTypes,\n-                                             Class<?>[] checkedExceptions,\n-                                             int modifiers,\n-                                             int slot,\n-                                             String signature,\n-                                             byte[] annotations,\n-                                             byte[] parameterAnnotations)\n-    {\n-        return new Constructor<>(declaringClass,\n-                                  parameterTypes,\n-                                  checkedExceptions,\n-                                  modifiers,\n-                                  slot,\n-                                  signature,\n-                                  annotations,\n-                                  parameterAnnotations);\n-    }\n-\n-    public MethodAccessor getMethodAccessor(Method m) {\n-        return m.getMethodAccessor();\n-    }\n-\n-    public void setMethodAccessor(Method m, MethodAccessor accessor) {\n-        m.setMethodAccessor(accessor);\n-    }\n-\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c) {\n-        return c.getConstructorAccessor();\n-    }\n-\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor)\n-    {\n-        c.setConstructorAccessor(accessor);\n-    }\n-\n-    public int getConstructorSlot(Constructor<?> c) {\n-        return c.getSlot();\n-    }\n-\n-    public String getConstructorSignature(Constructor<?> c) {\n-        return c.getSignature();\n-    }\n-\n-    public byte[] getConstructorAnnotations(Constructor<?> c) {\n-        return c.getRawAnnotations();\n-    }\n-\n-    public byte[] getConstructorParameterAnnotations(Constructor<?> c) {\n-        return c.getRawParameterAnnotations();\n+final class ReflectAccess implements JavaLangReflectAccess {\n+    public <T> Constructor<T> newConstructorWithAccessor(Constructor<T> original, ConstructorAccessor accessor) {\n+        return original.newWithAccessor(accessor);\n@@ -108,3 +58,0 @@\n-    public Method      leafCopyMethod(Method arg) {\n-        return arg.leafCopy();\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":5,"deletions":58,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import java.util.stream.Stream;\n+\n@@ -53,0 +53,1 @@\n+import jdk.internal.constant.MethodTypeDescImpl;\n@@ -84,0 +85,2 @@\n+    private static final ClassDesc CD_BiPredicate = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/function\/BiPredicate;\");\n+    private static final ClassDesc CD_Objects = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n@@ -85,1 +88,11 @@\n-    private static final MethodType TYPES_SWITCH_TYPE = MethodType.methodType(int.class,\n+    private static final MethodTypeDesc CHECK_INDEX_DESCRIPTOR =\n+            MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int, ConstantDescs.CD_int, ConstantDescs.CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH_EXTRA = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int,\n+            CD_BiPredicate,\n+            ConstantDescs.CD_List);\n+    private static final MethodType MT_TYPE_SWITCH_EXTRA = MethodType.methodType(int.class,\n@@ -90,7 +103,3 @@\n-\n-    private static final MethodTypeDesc TYPES_SWITCH_DESCRIPTOR =\n-            MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;ILjava\/util\/function\/BiPredicate;Ljava\/util\/List;)I\");\n-    private static final MethodTypeDesc CHECK_INDEX_DESCRIPTOR =\n-            MethodTypeDesc.ofDescriptor(\"(II)I\");\n-\n-    private static final ClassDesc CD_Objects = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n+    private static final MethodType MT_TYPE_SWITCH = MethodType.methodType(int.class,\n+            Object.class,\n+            int.class);\n@@ -183,1 +192,1 @@\n-\n+        target = target.asType(invocationType);\n@@ -275,1 +284,0 @@\n-        requireNonNull(labels);\n@@ -277,1 +285,1 @@\n-        labels = labels.clone();\n+        labels = labels.clone(); \/\/ implicit null check\n@@ -304,1 +312,0 @@\n-\n@@ -437,0 +444,27 @@\n+    \/**\n+     * Check if the labelConstants can be converted statically to bytecode, or\n+     * whether we'll need to compute and pass in extra information at the call site.\n+     *\/\n+    private static boolean needsExtraInfo(Class<?> selectorType, Object[] labelConstants) {\n+        for (int idx = labelConstants.length - 1; idx >= 0; idx--) {\n+            Object currentLabel = labelConstants[idx];\n+            if (currentLabel instanceof Class<?> classLabel) {\n+                \/\/ No extra info needed for exact matches or primitives\n+                if (unconditionalExactnessCheck(selectorType, classLabel) || classLabel.isPrimitive()) {\n+                    continue;\n+                }\n+                \/\/ Hidden classes - or arrays thereof - can't be nominally\n+                \/\/ represented. Passed in as arguments.\n+                while (classLabel.isArray()) {\n+                    classLabel = classLabel.getComponentType();\n+                }\n+                if (classLabel.isHidden()) {\n+                    return true;\n+                }\n+            } else if (currentLabel instanceof EnumDesc<?>) {\n+                \/\/ EnumDescs labels needs late binding\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n@@ -470,3 +504,4 @@\n-            record Element(Label target, Label next, Object caseLabel) { }\n-            List<Element> cases = new ArrayList<>();\n-            List<SwitchCase> switchCases = new ArrayList<>();\n+            Label[] caseTargets = new Label[labelConstants.length];\n+            Label[] caseNext = new Label[labelConstants.length];\n+            Object[] caseLabels = new Object[labelConstants.length];\n+            SwitchCase[] switchCases = new SwitchCase[labelConstants.length];\n@@ -481,1 +516,1 @@\n-                    next = cases.getLast().next();\n+                    next = caseNext[idx + 1];\n@@ -483,1 +518,1 @@\n-                    next = cases.getLast().target();\n+                    next = caseTargets[idx + 1];\n@@ -486,2 +521,4 @@\n-                cases.add(new Element(target, next, currentLabel));\n-                switchCases.add(SwitchCase.of(idx, target));\n+                caseTargets[idx] = target;\n+                caseNext[idx] = next;\n+                caseLabels[idx] = currentLabel;\n+                switchCases[idx] = SwitchCase.of(idx, target);\n@@ -489,8 +526,6 @@\n-            cases = cases.reversed();\n-            switchCases = switchCases.reversed();\n-            cb.tableswitch(0, labelConstants.length - 1, dflt, switchCases);\n-            for (int idx = 0; idx < cases.size(); idx++) {\n-                Element element = cases.get(idx);\n-                Label next = element.next();\n-                cb.labelBinding(element.target());\n-                if (element.caseLabel() instanceof Class<?> classLabel) {\n+            cb.tableswitch(0, labelConstants.length - 1, dflt, Arrays.asList(switchCases));\n+            for (int idx = 0; idx < labelConstants.length; idx++) {\n+                Label next = caseNext[idx];\n+                Object caseLabel = caseLabels[idx];\n+                cb.labelBinding(caseTargets[idx]);\n+                if (caseLabel instanceof Class<?> classLabel) {\n@@ -580,1 +615,1 @@\n-                } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n+                } else if (caseLabel instanceof EnumDesc<?> enumLabel) {\n@@ -590,1 +625,1 @@\n-                    cb.invokeinterface(referenceClassDesc(BiPredicate.class),\n+                    cb.invokeinterface(CD_BiPredicate,\n@@ -596,1 +631,1 @@\n-                } else if (element.caseLabel() instanceof String stringLabel) {\n+                } else if (caseLabel instanceof String stringLabel) {\n@@ -604,1 +639,1 @@\n-                } else if (element.caseLabel() instanceof Integer integerLabel) {\n+                } else if (caseLabel instanceof Integer integerLabel) {\n@@ -629,5 +664,5 @@\n-                } else if ((element.caseLabel() instanceof Long ||\n-                        element.caseLabel() instanceof Float ||\n-                        element.caseLabel() instanceof Double ||\n-                        element.caseLabel() instanceof Boolean)) {\n-                    if (element.caseLabel() instanceof Boolean c) {\n+                } else if ((caseLabel instanceof Long ||\n+                        caseLabel instanceof Float ||\n+                        caseLabel instanceof Double ||\n+                        caseLabel instanceof Boolean)) {\n+                    if (caseLabel instanceof Boolean c) {\n@@ -636,1 +671,1 @@\n-                        cb.loadConstant((ConstantDesc) element.caseLabel());\n+                        cb.loadConstant((ConstantDesc) caseLabel);\n@@ -638,1 +673,1 @@\n-                    var caseLabelWrapper = Wrapper.forWrapperType(element.caseLabel().getClass());\n+                    var caseLabelWrapper = Wrapper.forWrapperType(caseLabel.getClass());\n@@ -651,1 +686,1 @@\n-                            element.caseLabel().getClass());\n+                            caseLabel.getClass());\n@@ -657,1 +692,1 @@\n-            cb.loadConstant(cases.size());\n+            cb.loadConstant(labelConstants.length);\n@@ -666,2 +701,3 @@\n-        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n-        List<Class<?>> extraClassLabels = new ArrayList<>();\n+        boolean addExtraInfo = needsExtraInfo(selectorType, labelConstants);\n+        List<EnumDesc<?>> enumDescs = addExtraInfo ? new ArrayList<>() : null;\n+        List<Class<?>> extraClassLabels = addExtraInfo ? new ArrayList<>() : null;\n@@ -673,1 +709,1 @@\n-                                       TYPES_SWITCH_DESCRIPTOR,\n+                                       addExtraInfo ? MTD_TYPE_SWITCH_EXTRA : MTD_TYPE_SWITCH,\n@@ -684,7 +720,5 @@\n-                                                        TYPES_SWITCH_TYPE);\n-            typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(new EnumDesc<?>[0])),\n-                                                       List.copyOf(extraClassLabels));\n-            typeSwitch = MethodHandles.explicitCastArguments(typeSwitch,\n-                                                             MethodType.methodType(int.class,\n-                                                                                   selectorType,\n-                                                                                   int.class));\n+                                                        addExtraInfo ? MT_TYPE_SWITCH_EXTRA : MT_TYPE_SWITCH);\n+            if (addExtraInfo) {\n+                typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(new EnumDesc<?>[0])),\n+                        List.copyOf(extraClassLabels));\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":85,"deletions":51,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -398,1 +398,1 @@\n-     *          socket is already bound.\n+     *          socket is already bound or is closed.\n@@ -425,0 +425,5 @@\n+     * <p> If this socket is already connected, then this method will attempt to\n+     * connect to the given address. If this connect fails then the state of\n+     * this socket is unknown - it may or may not be connected to the address\n+     * that it was previously connected to.\n+     *\n@@ -464,1 +469,1 @@\n-     *         may be thrown if connect fails, for example, if the\n+     *         if the port is 0 or connect fails, for example, if the\n@@ -487,0 +492,5 @@\n+     * <p> If this socket is already connected, then this method will attempt to\n+     * connect to the given address. If this connect fails then the state of\n+     * this socket is unknown - it may or may not be connected to the address\n+     * that it was previously connected to.\n+     *\n@@ -646,1 +656,1 @@\n-     * @throws     IOException  if an I\/O error occurs.\n+     * @throws     IOException  if an I\/O error occurs, or the socket is closed.\n@@ -705,1 +715,1 @@\n-     * @throws     IOException  if an I\/O error occurs.\n+     * @throws     IOException  if an I\/O error occurs, or the socket is closed.\n@@ -773,1 +783,2 @@\n-     * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -787,1 +798,2 @@\n-     * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -823,2 +835,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -844,2 +856,2 @@\n-     * @throws    SocketException if there is an error in\n-     * the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -881,2 +893,2 @@\n-     * @throws    SocketException if there is an error in\n-     * the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -902,1 +914,2 @@\n-     * @throws    SocketException if there is an error in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -962,2 +975,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -986,3 +999,2 @@\n-     * @throws  SocketException\n-     *          if there is an error in the underlying protocol, such as an UDP\n-     *          error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -1006,2 +1018,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -1052,2 +1064,2 @@\n-     * @throws SocketException if there is an error setting the\n-     * traffic class or type-of-service\n+     * @throws SocketException if there is an error setting the traffic class or type-of-service,\n+     *         or the socket is closed.\n@@ -1077,2 +1089,2 @@\n-     * @throws SocketException if there is an error obtaining the\n-     * traffic class or type-of-service value.\n+     * @throws SocketException if there is an error obtaining the traffic class\n+     *         or type-of-service value, or the socket is closed.\n@@ -1095,0 +1107,3 @@\n+     *\n+     * <p> Once closed, several of the methods defined by this class will throw\n+     * an exception if invoked on the closed socket.\n@@ -1302,1 +1317,1 @@\n-     *         multicasting\n+     *         multicasting, or the socket is closed\n@@ -1346,1 +1361,1 @@\n-     *         is not a multicast address.\n+     *         is not a multicast address, or the socket is closed.\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocket.java","additions":42,"deletions":27,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-     *             while setting the default time-to-live value\n+     *             while setting the default time-to-live value, or the socket is closed.\n@@ -253,1 +253,1 @@\n-     *          default time-to-live value\n+     *          default time-to-live value, or the socket is closed.\n@@ -268,1 +268,1 @@\n-     * while getting the default time-to-live value\n+     *            while getting the default time-to-live value, or the socket is closed.\n@@ -288,1 +288,1 @@\n-     * getting the default time-to-live value\n+     *            getting the default time-to-live value, or the socket is closed.\n@@ -314,1 +314,1 @@\n-     *             or the platform does not support multicasting\n+     *             or the platform does not support multicasting, or the socket is closed.\n@@ -342,1 +342,1 @@\n-     *             or when the address is not a multicast address.\n+     *             or when the address is not a multicast address, or the socket is closed.\n@@ -396,1 +396,1 @@\n-     *             the underlying protocol, such as a TCP error.\n+     *             the underlying protocol, such as a TCP error, or the socket is closed.\n@@ -416,1 +416,1 @@\n-     *             underlying protocol, such as a TCP error.\n+     *             underlying protocol, such as a TCP error, or the socket is closed.\n@@ -437,1 +437,1 @@\n-     * the underlying protocol, such as a TCP error.\n+     *            the underlying protocol, such as a TCP error, or the socket is closed.\n@@ -457,1 +457,1 @@\n-     *         the underlying protocol, such as a TCP error.\n+     *         the underlying protocol, such as a TCP error, or the socket is closed.\n@@ -479,1 +479,2 @@\n-     * @throws     SocketException if an error occurs while setting the value\n+     * @throws     SocketException if an error occurs while setting the value, or\n+     *             the socket is closed.\n@@ -496,1 +497,2 @@\n-     * @throws     SocketException if an error occurs while getting the value\n+     * @throws     SocketException if an error occurs while getting the value, or\n+     *             the socket is closed.\n@@ -537,2 +539,1 @@\n-     * @throws     IOException is raised if an error occurs i.e\n-     *             error while setting ttl.\n+     * @throws     IOException  if an I\/O error occurs, or the socket is closed.\n","filename":"src\/java.base\/share\/classes\/java\/net\/MulticastSocket.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -655,1 +655,0 @@\n-                val = getNumberValue(number, divisor);\n@@ -657,0 +656,3 @@\n+            roundedNumber = roundedNumber \/ divisor;\n+            decimalFormat.setDigitList(roundedNumber, isNegative, getMaximumFractionDigits());\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -663,2 +665,0 @@\n-                    roundedNumber = roundedNumber \/ divisor;\n-                    decimalFormat.setDigitList(roundedNumber, isNegative, getMaximumFractionDigits());\n@@ -737,1 +737,0 @@\n-                val = getNumberValue(number, divisor);\n@@ -739,0 +738,12 @@\n+            var noFraction = number % divisor == 0;\n+            if (noFraction) {\n+                number = number \/ divisor;\n+                decimalFormat.setDigitList(number, isNegative, 0);\n+            } else {\n+                \/\/ To avoid truncation of fractional part store\n+                \/\/ the value in double and follow double path instead of\n+                \/\/ long path\n+                double dNumber = (double) number \/ divisor;\n+                decimalFormat.setDigitList(dNumber, isNegative, getMaximumFractionDigits());\n+            }\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -744,18 +755,4 @@\n-                    if ((number % divisor == 0)) {\n-                        number = number \/ divisor;\n-                        decimalFormat.setDigitList(number, isNegative, 0);\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, true, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    } else {\n-                        \/\/ To avoid truncation of fractional part store\n-                        \/\/ the value in double and follow double path instead of\n-                        \/\/ long path\n-                        double dNumber = (double) number \/ divisor;\n-                        decimalFormat.setDigitList(dNumber, isNegative, getMaximumFractionDigits());\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, false, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    }\n+                    decimalFormat.subformatNumber(result, delegate,\n+                            isNegative, noFraction, getMaximumIntegerDigits(),\n+                            getMinimumIntegerDigits(), getMaximumFractionDigits(),\n+                            getMinimumFractionDigits());\n@@ -836,1 +833,0 @@\n-                val = getNumberValue(number.doubleValue(), divisor.doubleValue());\n@@ -838,0 +834,3 @@\n+            number = number.divide(new BigDecimal(divisor.toString()), getRoundingMode());\n+            decimalFormat.setDigitList(number, isNegative, getMaximumFractionDigits());\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -843,2 +842,0 @@\n-                    number = number.divide(new BigDecimal(divisor.toString()), getRoundingMode());\n-                    decimalFormat.setDigitList(number, isNegative, getMaximumFractionDigits());\n@@ -907,1 +904,0 @@\n-                val = getNumberValue(number.doubleValue(), divisor.doubleValue());\n@@ -909,0 +905,14 @@\n+            var noFraction = number.mod(new BigInteger(divisor.toString()))\n+                    .compareTo(BigInteger.ZERO) == 0;\n+            if (noFraction) {\n+                number = number.divide(new BigInteger(divisor.toString()));\n+                decimalFormat.setDigitList(number, isNegative, 0);\n+            } else {\n+                \/\/ To avoid truncation of fractional part store the value in\n+                \/\/ BigDecimal and follow BigDecimal path instead of\n+                \/\/ BigInteger path\n+                BigDecimal nDecimal = new BigDecimal(number)\n+                        .divide(new BigDecimal(divisor.toString()), getRoundingMode());\n+                decimalFormat.setDigitList(nDecimal, isNegative, getMaximumFractionDigits());\n+            }\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -914,21 +924,4 @@\n-                    if (number.mod(new BigInteger(divisor.toString()))\n-                            .compareTo(BigInteger.ZERO) == 0) {\n-                        number = number.divide(new BigInteger(divisor.toString()));\n-\n-                        decimalFormat.setDigitList(number, isNegative, 0);\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, true, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    } else {\n-                        \/\/ To avoid truncation of fractional part store the value in\n-                        \/\/ BigDecimal and follow BigDecimal path instead of\n-                        \/\/ BigInteger path\n-                        BigDecimal nDecimal = new BigDecimal(number)\n-                                .divide(new BigDecimal(divisor.toString()), getRoundingMode());\n-                        decimalFormat.setDigitList(nDecimal, isNegative, getMaximumFractionDigits());\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, false, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    }\n+                    decimalFormat.subformatNumber(result, delegate,\n+                        isNegative, noFraction, getMaximumIntegerDigits(),\n+                        getMinimumIntegerDigits(), getMaximumFractionDigits(),\n+                        getMinimumFractionDigits());\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":40,"deletions":47,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -1802,0 +1802,8 @@\n+    \/**\n+     * {@return the {@code DigitList} used by this {@code DecimalFormat} instance}\n+     * Declared as package-private, intended for {@code CompactNumberFormat}.\n+     *\/\n+    DigitList getDigitList() {\n+        return digitList;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,3 +223,3 @@\n-    private final byte BITARRAYMASK = (byte)0x1;\n-    private final int  BYTEPOWER = 3;\n-    private final int  BYTEMASK = (1 << BYTEPOWER) - 1;\n+    private static final byte BITARRAYMASK = (byte)0x1;\n+    private static final int BYTEPOWER = 3;\n+    private static final int BYTEMASK = (1 << BYTEPOWER) - 1;\n","filename":"src\/java.base\/share\/classes\/java\/text\/MergeCollation.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1969,0 +1969,8 @@\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Prints the toString result to the given buf, avoiding extra string allocations.\n+     *\/\n+    void formatTo(StringBuilder buf) {\n@@ -1972,1 +1980,0 @@\n-        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDateTime.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1926,1 +1926,4 @@\n-        return dateTime.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var buf = new StringBuilder(29 + offsetStr.length());\n+        dateTime.formatTo(buf);\n+        return buf.append(offsetStr).toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetDateTime.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1401,1 +1401,4 @@\n-        return time.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var buf = new StringBuilder(18 + offsetStr.length());\n+        time.formatTo(buf);\n+        return buf.append(offsetStr).toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetTime.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2217,1 +2217,3 @@\n-        String str = dateTime.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var zoneStr = (String) null;\n+        int length = 29 + offsetStr.length();\n@@ -2219,1 +2221,2 @@\n-            str += '[' + zone.toString() + ']';\n+            zoneStr = zone.toString();\n+            length += zoneStr.length() + 2;\n@@ -2221,1 +2224,7 @@\n-        return str;\n+        var buf = new StringBuilder(length);\n+        dateTime.formatTo(buf);\n+        buf.append(offsetStr);\n+        if (zoneStr != null) {\n+            buf.append('[').append(zoneStr).append(']');\n+        }\n+        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3024,9 +3024,1 @@\n-    private static class FixedString implements FormatString {\n-        private final String s;\n-        private final int start;\n-        private final int end;\n-        FixedString(String s, int start, int end) {\n-            this.s = s;\n-            this.start = start;\n-            this.end = end;\n-        }\n+    private record FixedString(String s, int start, int end) implements FormatString {\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -991,1 +991,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(baseloc, LOCALE_CREATOR);\n+            return LocaleCache.cache(baseloc);\n@@ -994,1 +994,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n+            return LocaleCache.cache(key);\n@@ -998,2 +998,9 @@\n-    private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n-            = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+    private static final class LocaleCache implements Function<Object, Locale> {\n+        private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n+                = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+\n+        private static final Function<Object, Locale> LOCALE_CREATOR = new LocaleCache();\n+\n+        public static Locale cache(Object key) {\n+            return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n+        }\n@@ -1001,1 +1008,0 @@\n-    private static final Function<Object, Locale> LOCALE_CREATOR = new Function<>() {\n@@ -1010,1 +1016,1 @@\n-    };\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2808,1 +2808,1 @@\n-     * before the given timeout.\n+     * before the given timeout elapsed.\n@@ -2828,1 +2828,1 @@\n-     * otherwise completed before the given timeout.\n+     * otherwise completed before the given timeout elapsed.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,7 +142,1 @@\n-     * contention. We approach this by defining the Nodes that we need\n-     * anyway as ThreadLocals, and include in them per-thread index\n-     * and related bookkeeping state. (We can safely reuse per-thread\n-     * nodes rather than creating them fresh each time because slots\n-     * alternate between pointing to a node vs null, so cannot\n-     * encounter ABA problems. However, we do need some care in\n-     * resetting them between uses.)\n+     * contention.\n@@ -150,13 +144,22 @@\n-     * Implementing an effective arena requires allocating a bunch of\n-     * space, so we only do so upon detecting contention (except on\n-     * uniprocessors, where they wouldn't help, so aren't used).\n-     * Otherwise, exchanges use the single-slot slotExchange method.\n-     * On contention, not only must the slots be in different\n-     * locations, but the locations must not encounter memory\n-     * contention due to being on the same cache line (or more\n-     * generally, the same coherence unit).  Because, as of this\n-     * writing, there is no way to determine cacheline size, we define\n-     * a value that is enough for common platforms.  Additionally,\n-     * extra care elsewhere is taken to avoid other false\/unintended\n-     * sharing and to enhance locality, including adding padding (via\n-     * @Contended) to Nodes, embedding \"bound\" as an Exchanger field.\n+     * We approach this by defining the Nodes holding references to\n+     * transfered items as ThreadLocals, and include in them\n+     * per-thread index and related bookkeeping state. We can safely\n+     * reuse per-thread nodes rather than creating them fresh each\n+     * time because slots alternate between pointing to a node vs\n+     * null, so cannot encounter ABA problems. However, we must ensure\n+     * that object transfer fields are reset between uses. Given this,\n+     * Participant nodes can be defined as static ThreadLocals. As\n+     * seen for example in class Striped64, using indices established\n+     * in one instance across others usually improves overall\n+     * performance.  Nodes also include a participant-local random\n+     * number generator.\n+     *\n+     * Spreading out contention requires that the memory locations\n+     * used by the arena slots don't share a cache line -- otherwise,\n+     * the arena would have almost no benefit. We arrange this by\n+     * adding another level of indirection: The arena elements point\n+     * to \"Slots\", each of which is padded using @Contended. We only\n+     * create a single Slot on intialization, adding more when\n+     * needed. The per-thread Participant Nodes may also be subject to\n+     * false-sharing contention, but tend to be more scattered in\n+     * memory, so are unpadded, with some occasional performance impact.\n@@ -166,13 +169,6 @@\n-     * while trying to exchange. By nature of the above algorithm, the\n-     * only kinds of collision that reliably indicate contention are\n-     * when two attempted releases collide -- one of two attempted\n-     * offers can legitimately fail to CAS without indicating\n-     * contention by more than one other thread. (Note: it is possible\n-     * but not worthwhile to more precisely detect contention by\n-     * reading slot values after CAS failures.)  When a thread has\n-     * collided at each slot within the current arena bound, it tries\n-     * to expand the arena size by one. We track collisions within\n-     * bounds by using a version (sequence) number on the \"bound\"\n-     * field, and conservatively reset collision counts when a\n-     * participant notices that bound has been updated (in either\n-     * direction).\n+     * while trying to exchange. And shrink it via \"spinouts\" in which\n+     * threads give up waiting at a slot.  By nature of the above\n+     * algorithm, the only kinds of collision that reliably indicate\n+     * contention are when two attempted releases collide -- one of\n+     * two attempted offers can legitimately fail to CAS without\n+     * indicating contention by more than one other thread.\n@@ -180,25 +176,15 @@\n-     * The effective arena size is reduced (when there is more than\n-     * one slot) by giving up on waiting after a while and trying to\n-     * decrement the arena size on expiration. The value of \"a while\"\n-     * is an empirical matter.  We implement by piggybacking on the\n-     * use of spin->yield->block that is essential for reasonable\n-     * waiting performance anyway -- in a busy exchanger, offers are\n-     * usually almost immediately released, in which case context\n-     * switching on multiprocessors is extremely slow\/wasteful.  Arena\n-     * waits just omit the blocking part, and instead cancel. The spin\n-     * count is empirically chosen to be a value that avoids blocking\n-     * 99% of the time under maximum sustained exchange rates on a\n-     * range of test machines. Spins and yields entail some limited\n-     * randomness (using a cheap xorshift) to avoid regular patterns\n-     * that can induce unproductive grow\/shrink cycles. (Using a\n-     * pseudorandom also helps regularize spin cycle duration by\n-     * making branches unpredictable.)  Also, during an offer, a\n-     * waiter can \"know\" that it will be released when its slot has\n-     * changed, but cannot yet proceed until match is set.  In the\n-     * mean time it cannot cancel the offer, so instead spins\/yields.\n-     * Note: It is possible to avoid this secondary check by changing\n-     * the linearization point to be a CAS of the match field (as done\n-     * in one case in the Scott & Scherer DISC paper), which also\n-     * increases asynchrony a bit, at the expense of poorer collision\n-     * detection and inability to always reuse per-thread nodes. So\n-     * the current scheme is typically a better tradeoff.\n+     * Arena size (the value of field \"bound\") is controlled by random\n+     * sampling. On each miss (collision or spinout), a thread chooses\n+     * a new random index within the arena.  Upon the third collision\n+     * with the same current bound, it tries to grow the arena. And\n+     * upon the second spinout, it tries to shrink. The asymmetry in\n+     * part reflects relative costs, and reduces flailing. Because\n+     * they cannot be changed without also changing the sampling\n+     * strategy, these rules are directly incorporated into uses of\n+     * the xchg \"misses\" variable.  The bound field is tagged with\n+     * sequence numbers to reduce stale decisions. Uniform random\n+     * indices are generated using XorShift with enough bits so that\n+     * bias (See Knuth TAoCP vol 2) is negligible for moduli used here\n+     * (at most 256) without requiring rejection tests. Using\n+     * nonuniform randoms with greater weight to higher indices is\n+     * also possible but does not seem worthwhile in practice.\n@@ -206,11 +192,15 @@\n-     * On collisions, indices traverse the arena cyclically in reverse\n-     * order, restarting at the maximum index (which will tend to be\n-     * sparsest) when bounds change. (On expirations, indices instead\n-     * are halved until reaching 0.) It is possible (and has been\n-     * tried) to use randomized, prime-value-stepped, or double-hash\n-     * style traversal instead of simple cyclic traversal to reduce\n-     * bunching.  But empirically, whatever benefits these may have\n-     * don't overcome their added overhead: We are managing operations\n-     * that occur very quickly unless there is sustained contention,\n-     * so simpler\/faster control policies work better than more\n-     * accurate but slower ones.\n+     * These mechanics rely on a reasonable choice of constant SPINS.\n+     * The time cost of SPINS * Thread.onSpinWait() should be at least\n+     * the expected cost of a park\/unpark context switch, and larger\n+     * than that of two failed CASes, but still small enough to avoid\n+     * excessive delays during arena shrinkage.  We also deal with the\n+     * possibility that when an offering thread waits for a release,\n+     * spin-waiting would be useless because the releasing thread is\n+     * descheduled. On multiprocessors, we cannot know this in\n+     * general. But when Virtual Threads are used, method\n+     * ForkJoinWorkerThread.hasKnownQueuedWork serves as a guide to\n+     * whether to spin or immediately block, allowing a context switch\n+     * that may enable a releaser.  Note also that when many threads\n+     * are being run on few cores, enountering enough collisions to\n+     * trigger arena growth is rare, and soon followed by shrinkage,\n+     * so this doesn't require special handling.\n@@ -218,5 +208,5 @@\n-     * Because we use expiration for arena size control, we cannot\n-     * throw TimeoutExceptions in the timed version of the public\n-     * exchange method until the arena size has shrunken to zero (or\n-     * the arena isn't enabled). This may delay response to timeout\n-     * but is still within spec.\n+     * The basic exchange mechanics rely on checks that Node item\n+     * fields are not null, which doesn't work when offered items are\n+     * null. We trap this case by translating nulls to the\n+     * (un-Exchangeable) value of the static Participant\n+     * reference.\n@@ -224,10 +214,8 @@\n-     * Essentially all of the implementation is in methods\n-     * slotExchange and arenaExchange. These have similar overall\n-     * structure, but differ in too many details to combine. The\n-     * slotExchange method uses the single Exchanger field \"slot\"\n-     * rather than arena array elements. However, it still needs\n-     * minimal collision detection to trigger arena construction.\n-     * (The messiest part is making sure interrupt status and\n-     * InterruptedExceptions come out right during transitions when\n-     * both methods may be called. This is done by using null return\n-     * as a sentinel to recheck interrupt status.)\n+     * Essentially all of the implementation is in method xchg.  As is\n+     * too common in this sort of code, most of the logic relies on\n+     * reads of fields that are maintained as local variables so can't\n+     * be nicely factored. It is structured as a main loop with a\n+     * leading volatile read (of field bound), that causes others to\n+     * be freshly read even though declared in plain mode.  We don't\n+     * use compareAndExchange that would otherwise save some re-reads\n+     * because of the need to recheck indices and bounds on failures.\n@@ -235,18 +223,15 @@\n-     * As is too common in this sort of code, methods are monolithic\n-     * because most of the logic relies on reads of fields that are\n-     * maintained as local variables so can't be nicely factored --\n-     * mainly, here, bulky spin->yield->block\/cancel code.  Note that\n-     * field Node.item is not declared as volatile even though it is\n-     * read by releasing threads, because they only do so after CAS\n-     * operations that must precede access, and all uses by the owning\n-     * thread are otherwise acceptably ordered by other operations.\n-     * (Because the actual points of atomicity are slot CASes, it\n-     * would also be legal for the write to Node.match in a release to\n-     * be weaker than a full volatile write. However, this is not done\n-     * because it could allow further postponement of the write,\n-     * delaying progress.)\n-     *\/\n-\n-    \/**\n-     * The index distance (as a shift value) between any two used slots\n-     * in the arena, spacing them out to avoid false sharing.\n+     * Support for optional timeouts in a single method adds further\n+     * complexity. Note that for the sake of arena bounds control,\n+     * time bounds must be ignored during spinouts, which may delay\n+     * TimeoutExceptions (but no more so than would excessive context\n+     * switching that could occur otherwise).  Responses to\n+     * interruption are handled similarly, postponing commitment to\n+     * throw InterruptedException until successfully cancelled.\n+     *\n+     * Design differences from previous releases include:\n+     * * Accommodation of VirtualThreads.\n+     * * Use of Slots vs spaced indices for the arena and static\n+     *   ThreadLocals, avoiding separate arena vs non-arena modes.\n+     * * Use of random sampling for grow\/shrink decisions, with typically\n+     *   faster and more stable adaptation (as was mentioned as a\n+     *   possible improvement in previous version).\n@@ -254,1 +239,0 @@\n-    private static final int ASHIFT = 5;\n@@ -258,3 +242,3 @@\n-     * arena size is MMASK + 1. Must be a power of two minus one, less\n-     * than (1<<(31-ASHIFT)). The cap of 255 (0xff) more than suffices\n-     * for the expected scaling limits of the main algorithms.\n+     * arena size is MMASK + 1. Must be a power of two minus one. The\n+     * cap of 255 (0xff) more than suffices for the expected scaling\n+     * limits of the main algorithms.\n@@ -270,3 +254,0 @@\n-    \/** The number of CPUs, for sizing and spin control *\/\n-    private static final int NCPU = Runtime.getRuntime().availableProcessors();\n-\n@@ -274,10 +255,2 @@\n-     * The maximum slot index of the arena: The number of slots that\n-     * can in principle hold all threads without contention, or at\n-     * most the maximum indexable value.\n-     *\/\n-    static final int FULL = (NCPU >= (MMASK << 1)) ? MMASK : NCPU >>> 1;\n-\n-    \/**\n-     * The bound for spins while waiting for a match. The actual\n-     * number of iterations will on average be about twice this value\n-     * due to randomization. Note: Spinning is disabled when NCPU==1.\n+     * The bound for spins while waiting for a match before either\n+     * blocking or possibly shrinking arena.\n@@ -288,10 +261,1 @@\n-     * Value representing null arguments\/returns from public\n-     * methods. Needed because the API originally didn't disallow null\n-     * arguments, which it should have.\n-     *\/\n-    private static final Object NULL_ITEM = new Object();\n-\n-    \/**\n-     * Sentinel value returned by internal exchange methods upon\n-     * timeout, to avoid need for separate timed versions of these\n-     * methods.\n+     * Padded arena cells to avoid false-sharing memory contention\n@@ -299,1 +263,4 @@\n-    private static final Object TIMED_OUT = new Object();\n+    @jdk.internal.vm.annotation.Contended\n+    static final class Slot {\n+        Node entry;\n+    }\n@@ -303,1 +270,1 @@\n-     * bookkeeping. Padded via @Contended to reduce memory contention.\n+     * bookkeeping.\n@@ -305,1 +272,2 @@\n-    @jdk.internal.vm.annotation.Contended static final class Node {\n+    static final class Node {\n+        long seed;              \/\/ Random seed\n@@ -307,3 +275,0 @@\n-        int bound;              \/\/ Last recorded value of Exchanger.bound\n-        int collides;           \/\/ Number of CAS failures at current bound\n-        int hash;               \/\/ Pseudo-random for spins\n@@ -313,0 +278,4 @@\n+        Node() {\n+            index = -1;         \/\/ initialize on first use\n+            seed = Thread.currentThread().threadId();\n+        }\n@@ -321,1 +290,4 @@\n-     * Per-thread state.\n+     * The participant thread-locals. Because it is impossible to\n+     * exchange, we also use this reference for dealing with null user\n+     * arguments that are translated in and out of this value\n+     * surrounding use.\n@@ -323,1 +295,1 @@\n-    private final Participant participant;\n+    private static final Participant participant = new Participant();\n@@ -326,2 +298,2 @@\n-     * Elimination array; null until enabled (within slotExchange).\n-     * Element accesses use emulation of volatile gets and CAS.\n+     * Elimination array; element accesses use emulation of volatile\n+     * gets and CAS.\n@@ -329,1 +301,1 @@\n-    private volatile Node[] arena;\n+    private final Slot[] arena;\n@@ -332,1 +304,2 @@\n-     * Slot used until contention detected.\n+     * Number of cores, for sizing and spin control. Computed only\n+     * upon construction.\n@@ -334,1 +307,1 @@\n-    private volatile Node slot;\n+    private final int ncpu;\n@@ -337,4 +310,1 @@\n-     * The index of the largest valid arena position, OR'ed with SEQ\n-     * number in high bits, incremented on each update.  The initial\n-     * update from 0 to SEQ is used to ensure that the arena array is\n-     * constructed only once.\n+     * The index of the largest valid arena position.\n@@ -345,1 +315,1 @@\n-     * Exchange function when arenas enabled. See above for explanation.\n+     * Exchange function. See above for explanation.\n@@ -347,5 +317,5 @@\n-     * @param item the (non-null) item to exchange\n-     * @param timed true if the wait is timed\n-     * @param ns if timed, the maximum wait time, else 0L\n-     * @return the other thread's item; or null if interrupted; or\n-     * TIMED_OUT if timed and timed out\n+     * @param x the item to exchange\n+     * @param deadline if zero, untimed, else timeout deadline\n+     * @return the other thread's item\n+     * @throws InterruptedException if interrupted while waiting\n+     * @throws TimeoutException if deadline nonzero and timed out\n@@ -353,2 +323,3 @@\n-    private final Object arenaExchange(Object item, boolean timed, long ns) {\n-        Node[] a = arena;\n+    private final V xchg(V x, long deadline)\n+        throws InterruptedException, TimeoutException {\n+        Slot[] a = arena;\n@@ -356,14 +327,39 @@\n-        Node p = participant.get();\n-        for (int i = p.index;;) {                      \/\/ access slot at i\n-            int b, m, c;\n-            int j = (i << ASHIFT) + ((1 << ASHIFT) - 1);\n-            if (j < 0 || j >= alen)\n-                j = alen - 1;\n-            Node q = (Node)AA.getAcquire(a, j);\n-            if (q != null && AA.compareAndSet(a, j, q, null)) {\n-                Object v = q.item;                     \/\/ release\n-                q.match = item;\n-                Thread w = q.parked;\n-                if (w != null)\n-                    LockSupport.unpark(w);\n-                return v;\n+        Participant ps = participant;\n+        Object item = (x == null) ? ps : x;      \/\/ translate nulls\n+        Node p = ps.get();\n+        int i = p.index;                         \/\/ if < 0, move\n+        int misses = 0;                          \/\/ ++ on collide, -- on spinout\n+        Object offered = null;                   \/\/ for cleanup\n+        Object v = null;\n+        outer: for (;;) {\n+            int b, m; Slot s; Node q;\n+            if ((m = (b = bound) & MMASK) == 0)  \/\/ volatile read\n+                i = 0;\n+            if (i < 0 || i > m || i >= alen || (s = a[i]) == null) {\n+                long r = p.seed;                 \/\/ randomly move\n+                r ^= r << 13; r ^= r >>> 7; r ^= r << 17; \/\/ xorShift\n+                i = p.index = (int)((p.seed = r) % (m + 1));\n+            }\n+            else if ((q = s.entry) != null) {    \/\/ try release\n+                if (ENTRY.compareAndSet(s, q, null)) {\n+                    Thread w;\n+                    v = q.item;\n+                    q.match = item;\n+                    if (i == 0 && (w = q.parked) != null)\n+                        LockSupport.unpark(w);\n+                    break;\n+                }\n+                else {                           \/\/ collision\n+                    int nb;\n+                    i = -1;                      \/\/ move index\n+                    if (b != bound)              \/\/ stale\n+                        misses = 0;\n+                    else if (misses <= 2)        \/\/ continue sampling\n+                        ++misses;\n+                    else if ((nb = (b + 1) & MMASK) < alen) {\n+                        misses = 0;              \/\/ try to grow\n+                        if (BOUND.compareAndSet(this, b, b + 1 + SEQ) &&\n+                            a[i = p.index = nb] == null)\n+                            AA.compareAndSet(a, nb, null, new Slot());\n+                    }\n+                }\n@@ -371,12 +367,15 @@\n-            else if (i <= (m = (b = bound) & MMASK) && q == null) {\n-                p.item = item;                         \/\/ offer\n-                if (AA.compareAndSet(a, j, null, p)) {\n-                    long end = (timed && m == 0) ? System.nanoTime() + ns : 0L;\n-                    Thread t = Thread.currentThread(); \/\/ wait\n-                    for (int h = p.hash, spins = SPINS;;) {\n-                        Object v = p.match;\n-                        if (v != null) {\n-                            MATCH.setRelease(p, null);\n-                            p.item = null;             \/\/ clear for next use\n-                            p.hash = h;\n-                            return v;\n+            else {                               \/\/ try offer\n+                if (offered == null)\n+                    offered = p.item = item;\n+                if (ENTRY.compareAndSet(s, null, p)) {\n+                    boolean tryCancel;           \/\/ true if interrupted\n+                    Thread t = Thread.currentThread();\n+                    if (!(tryCancel = t.isInterrupted()) && ncpu > 1 &&\n+                        (i != 0 ||               \/\/ check for busy VTs\n+                         (!ForkJoinWorkerThread.hasKnownQueuedWork()))) {\n+                        for (int j = SPINS; j > 0; --j) {\n+                            if ((v = p.match) != null) {\n+                                MATCH.set(p, null);\n+                                break outer;     \/\/ spin wait\n+                            }\n+                            Thread.onSpinWait();\n@@ -384,7 +383,5 @@\n-                        else if (spins > 0) {\n-                            h ^= h << 1; h ^= h >>> 3; h ^= h << 10; \/\/ xorshift\n-                            if (h == 0)                \/\/ initialize hash\n-                                h = SPINS | (int)t.threadId();\n-                            else if (h < 0 &&          \/\/ approx 50% true\n-                                     (--spins & ((SPINS >>> 1) - 1)) == 0)\n-                                Thread.yield();        \/\/ two yields per wait\n+                    }\n+                    for (long ns = 1L;;) {       \/\/ block or cancel offer\n+                        if ((v = p.match) != null) {\n+                            MATCH.set(p, null);\n+                            break outer;\n@@ -392,8 +389,6 @@\n-                        else if (AA.getAcquire(a, j) != p)\n-                            spins = SPINS;       \/\/ releaser hasn't set match yet\n-                        else if (!t.isInterrupted() && m == 0 &&\n-                                 (!timed ||\n-                                  (ns = end - System.nanoTime()) > 0L)) {\n-                            p.parked = t;              \/\/ minimize window\n-                            if (AA.getAcquire(a, j) == p) {\n-                                if (ns == 0L)\n+                        if (i == 0 && !tryCancel &&\n+                            (deadline == 0L ||\n+                             ((ns = deadline - System.nanoTime()) > 0L))) {\n+                            p.parked = t;        \/\/ emable unpark and recheck\n+                            if (p.match == null) {\n+                                if (deadline == 0L)\n@@ -403,0 +398,1 @@\n+                                tryCancel = t.isInterrupted();\n@@ -406,7 +402,2 @@\n-                        else if (AA.getAcquire(a, j) == p &&\n-                                 AA.compareAndSet(a, j, p, null)) {\n-                            if (m != 0)                \/\/ try to shrink\n-                                BOUND.compareAndSet(this, b, b + SEQ - 1);\n-                            p.item = null;\n-                            p.hash = h;\n-                            i = p.index >>>= 1;        \/\/ descend\n+                        else if (ENTRY.compareAndSet(s, p, null)) { \/\/ cancel\n+                            offered = p.item = null;\n@@ -414,4 +405,13 @@\n-                                return null;\n-                            if (timed && m == 0 && ns <= 0L)\n-                                return TIMED_OUT;\n-                            break;                     \/\/ expired; restart\n+                                throw new InterruptedException();\n+                            if (deadline != 0L && ns <= 0L)\n+                                throw new TimeoutException();\n+                            i = -1;              \/\/ move and restart\n+                            if (bound != b)\n+                                misses = 0;      \/\/ stale\n+                            else if (misses >= 0)\n+                                --misses;        \/\/ continue sampling\n+                            else if ((b & MMASK) != 0) {\n+                                misses = 0;      \/\/ try to shrink\n+                                BOUND.compareAndSet(this, b, b - 1 + SEQ);\n+                            }\n+                            continue outer;\n@@ -421,91 +421,0 @@\n-                else\n-                    p.item = null;                     \/\/ clear offer\n-            }\n-            else {\n-                if (p.bound != b) {                    \/\/ stale; reset\n-                    p.bound = b;\n-                    p.collides = 0;\n-                    i = (i != m || m == 0) ? m : m - 1;\n-                }\n-                else if ((c = p.collides) < m || m == FULL ||\n-                         !BOUND.compareAndSet(this, b, b + SEQ + 1)) {\n-                    p.collides = c + 1;\n-                    i = (i == 0) ? m : i - 1;          \/\/ cyclically traverse\n-                }\n-                else\n-                    i = m + 1;                         \/\/ grow\n-                p.index = i;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Exchange function used until arenas enabled. See above for explanation.\n-     *\n-     * @param item the item to exchange\n-     * @param timed true if the wait is timed\n-     * @param ns if timed, the maximum wait time, else 0L\n-     * @return the other thread's item; or null if either the arena\n-     * was enabled or the thread was interrupted before completion; or\n-     * TIMED_OUT if timed and timed out\n-     *\/\n-    private final Object slotExchange(Object item, boolean timed, long ns) {\n-        Node p = participant.get();\n-        Thread t = Thread.currentThread();\n-        if (t.isInterrupted()) \/\/ preserve interrupt status so caller can recheck\n-            return null;\n-\n-        for (Node q;;) {\n-            if ((q = slot) != null) {\n-                if (SLOT.compareAndSet(this, q, null)) {\n-                    Object v = q.item;\n-                    q.match = item;\n-                    Thread w = q.parked;\n-                    if (w != null)\n-                        LockSupport.unpark(w);\n-                    return v;\n-                }\n-                \/\/ create arena on contention, but continue until slot null\n-                if (NCPU > 1 && bound == 0 &&\n-                    BOUND.compareAndSet(this, 0, SEQ))\n-                    arena = new Node[(FULL + 2) << ASHIFT];\n-            }\n-            else if (arena != null)\n-                return null; \/\/ caller must reroute to arenaExchange\n-            else {\n-                p.item = item;\n-                if (SLOT.compareAndSet(this, null, p))\n-                    break;\n-                p.item = null;\n-            }\n-        }\n-\n-        \/\/ await release\n-        int h = p.hash;\n-        long end = timed ? System.nanoTime() + ns : 0L;\n-        int spins = (NCPU > 1) ? SPINS : 1;\n-        Object v;\n-        while ((v = p.match) == null) {\n-            if (spins > 0) {\n-                h ^= h << 1; h ^= h >>> 3; h ^= h << 10;\n-                if (h == 0)\n-                    h = SPINS | (int)t.threadId();\n-                else if (h < 0 && (--spins & ((SPINS >>> 1) - 1)) == 0)\n-                    Thread.yield();\n-            }\n-            else if (slot != p)\n-                spins = SPINS;\n-            else if (!t.isInterrupted() && arena == null &&\n-                     (!timed || (ns = end - System.nanoTime()) > 0L)) {\n-                p.parked = t;\n-                if (slot == p) {\n-                    if (ns == 0L)\n-                        LockSupport.park(this);\n-                    else\n-                        LockSupport.parkNanos(this, ns);\n-                }\n-                p.parked = null;\n-            }\n-            else if (SLOT.compareAndSet(this, p, null)) {\n-                v = timed && ns <= 0L && !t.isInterrupted() ? TIMED_OUT : null;\n-                break;\n@@ -514,4 +423,4 @@\n-        MATCH.setRelease(p, null);\n-        p.item = null;\n-        p.hash = h;\n-        return v;\n+        if (offered != null)                     \/\/ cleanup\n+            p.item = null;\n+        @SuppressWarnings(\"unchecked\") V ret = (v == participant) ? null : (V)v;\n+        return ret;\n@@ -524,1 +433,3 @@\n-        participant = new Participant();\n+        int h = (ncpu = Runtime.getRuntime().availableProcessors()) >>> 1;\n+        int size = (h == 0) ? 1 : (h > MMASK) ? MMASK + 1 : h;\n+        (arena = new Slot[size])[0] = new Slot();\n@@ -560,1 +471,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -562,9 +472,5 @@\n-        Object v;\n-        Node[] a;\n-        Object item = (x == null) ? NULL_ITEM : x; \/\/ translate null args\n-        if (((a = arena) != null ||\n-             (v = slotExchange(item, false, 0L)) == null) &&\n-            (Thread.interrupted() || \/\/ disambiguates null return\n-             (v = arenaExchange(item, false, 0L)) == null))\n-            throw new InterruptedException();\n-        return (v == NULL_ITEM) ? null : (V)v;\n+        try {\n+            return xchg(x, 0L);\n+        } catch (TimeoutException cannotHappen) {\n+            return null; \/\/ not reached\n+        }\n@@ -615,1 +521,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -618,11 +523,2 @@\n-        Object v;\n-        Object item = (x == null) ? NULL_ITEM : x;\n-        long ns = unit.toNanos(timeout);\n-        if ((arena != null ||\n-             (v = slotExchange(item, true, ns)) == null) &&\n-            (Thread.interrupted() ||\n-             (v = arenaExchange(item, true, ns)) == null))\n-            throw new InterruptedException();\n-        if (v == TIMED_OUT)\n-            throw new TimeoutException();\n-        return (v == NULL_ITEM) ? null : (V)v;\n+        long d = unit.toNanos(timeout) + System.nanoTime();\n+        return xchg(x, (d == 0L) ? 1L : d); \/\/ avoid zero deadline\n@@ -633,1 +529,0 @@\n-    private static final VarHandle SLOT;\n@@ -635,0 +530,1 @@\n+    private static final VarHandle ENTRY;\n@@ -640,1 +536,0 @@\n-            SLOT = l.findVarHandle(Exchanger.class, \"slot\", Node.class);\n@@ -642,1 +537,2 @@\n-            AA = MethodHandles.arrayElementVarHandle(Node[].class);\n+            ENTRY = l.findVarHandle(Slot.class, \"entry\", Node.class);\n+            AA = MethodHandles.arrayElementVarHandle(Slot[].class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Exchanger.java","additions":223,"deletions":327,"binary":false,"changes":550,"status":"modified"},{"patch":"@@ -673,1 +673,1 @@\n-     * released soon therafter. This is checked by setting the\n+     * released soon thereafter. This is checked by setting the\n@@ -858,1 +858,1 @@\n-     * exceptions is preferred to throwing InterruptedExecptions,\n+     * exceptions is preferred to throwing InterruptedExceptions,\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1075,1 +1075,1 @@\n-     * (possibly exceptionally) before the given timeout and\n+     * (possibly exceptionally) before the given timeout elapsed and\n@@ -1100,1 +1100,1 @@\n-     * (possibly exceptionally) before the given timeout.\n+     * (possibly exceptionally) before the given timeout elapsed.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -205,0 +207,24 @@\n+    \/**\n+     * Returns true if the current task is being executed by a\n+     * ForkJoinWorkerThread that is momentarily known to have one or\n+     * more queued tasks that it could execute immediately. This\n+     * method is approximate and useful only as a heuristic indicator\n+     * within a running task.\n+     *\n+     * @return true if the current task is being executed by a worker\n+     * that has queued work\n+     *\/\n+    static boolean hasKnownQueuedWork() {\n+        ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue q, sq;\n+        ForkJoinPool p; ForkJoinPool.WorkQueue[] qs; int i;\n+        Thread c = JLA.currentCarrierThread();\n+        return ((c instanceof ForkJoinWorkerThread) &&\n+                (p = (wt = (ForkJoinWorkerThread)c).pool) != null &&\n+                (q = wt.workQueue) != null &&\n+                (i = q.source) >= 0 && \/\/ check local and current source queues\n+                (((qs = p.queues) != null && qs.length > i &&\n+                  (sq = qs[i]) != null && sq.top - sq.base > 0) ||\n+                 q.top - q.base > 0));\n+    }\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinWorkerThread.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -429,2 +429,2 @@\n-            if (w.isVirtual())             \/\/ don't spin\n-                spin = false;\n+            if (spin && ForkJoinWorkerThread.hasKnownQueuedWork())\n+                spin = false;              \/\/ don't spin\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/LinkedTransferQueue.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -185,0 +185,5 @@\n+    \/**\n+     * Maximum delay is effectively 146 years\n+     *\/\n+    private static final long MAX_NANOS = (Long.MAX_VALUE >>> 1) - 1;\n+\n@@ -528,19 +533,1 @@\n-        return System.nanoTime() +\n-            ((delay < (Long.MAX_VALUE >> 1)) ? delay : overflowFree(delay));\n-    }\n-\n-    \/**\n-     * Constrains the values of all delays in the queue to be within\n-     * Long.MAX_VALUE of each other, to avoid overflow in compareTo.\n-     * This may occur if a task is eligible to be dequeued, but has\n-     * not yet been, while some other task is added with a delay of\n-     * Long.MAX_VALUE.\n-     *\/\n-    private long overflowFree(long delay) {\n-        Delayed head = (Delayed) super.getQueue().peek();\n-        if (head != null) {\n-            long headDelay = head.getDelay(NANOSECONDS);\n-            if (headDelay < 0 && (delay - headDelay < 0))\n-                delay = Long.MAX_VALUE + headDelay;\n-        }\n-        return delay;\n+        return System.nanoTime() + Math.min(delay, MAX_NANOS);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ScheduledThreadPoolExecutor.java","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -197,7 +197,10 @@\n-            static final TerminalOp<?, ?> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.REFERENCE, Optional.empty(),\n-                    Optional::isPresent, FindSink.OfRef::new);\n-\n-            static final TerminalOp<?, ?> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.REFERENCE, Optional.empty(),\n-                    Optional::isPresent, FindSink.OfRef::new);\n+            static final TerminalOp<?, ?> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<Optional<Object>> isPresent = Optional::isPresent;\n+                Supplier<TerminalSink<Object, Optional<Object>>> newSink\n+                        = FindSink.OfRef::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.REFERENCE,\n+                        Optional.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.REFERENCE,\n+                        Optional.empty(), isPresent, newSink);\n+            }\n@@ -220,6 +223,10 @@\n-            static final TerminalOp<Integer, OptionalInt> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.INT_VALUE, OptionalInt.empty(),\n-                    OptionalInt::isPresent, FindSink.OfInt::new);\n-            static final TerminalOp<Integer, OptionalInt> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.INT_VALUE, OptionalInt.empty(),\n-                    OptionalInt::isPresent, FindSink.OfInt::new);\n+            static final TerminalOp<Integer, OptionalInt> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<OptionalInt> isPresent = OptionalInt::isPresent;\n+                Supplier<TerminalSink<Integer, OptionalInt>> newSink\n+                        = FindSink.OfInt::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.INT_VALUE,\n+                        OptionalInt.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.INT_VALUE,\n+                        OptionalInt.empty(), isPresent, newSink);\n+            }\n@@ -242,6 +249,10 @@\n-            static final TerminalOp<Long, OptionalLong> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.LONG_VALUE, OptionalLong.empty(),\n-                    OptionalLong::isPresent, FindSink.OfLong::new);\n-            static final TerminalOp<Long, OptionalLong> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.LONG_VALUE, OptionalLong.empty(),\n-                    OptionalLong::isPresent, FindSink.OfLong::new);\n+            static final TerminalOp<Long, OptionalLong> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<OptionalLong> isPresent = OptionalLong::isPresent;\n+                Supplier<TerminalSink<Long, OptionalLong>> newSink\n+                        = FindSink.OfLong::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.LONG_VALUE,\n+                        OptionalLong.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.LONG_VALUE,\n+                        OptionalLong.empty(), isPresent, newSink);\n+            }\n@@ -264,6 +275,10 @@\n-            static final TerminalOp<Double, OptionalDouble> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.DOUBLE_VALUE, OptionalDouble.empty(),\n-                    OptionalDouble::isPresent, FindSink.OfDouble::new);\n-            static final TerminalOp<Double, OptionalDouble> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.DOUBLE_VALUE, OptionalDouble.empty(),\n-                    OptionalDouble::isPresent, FindSink.OfDouble::new);\n+            static final TerminalOp<Double, OptionalDouble> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<OptionalDouble> isPresent = OptionalDouble::isPresent;\n+                Supplier<TerminalSink<Double, OptionalDouble>> newSink\n+                        = FindSink.OfDouble::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.DOUBLE_VALUE,\n+                        OptionalDouble.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.DOUBLE_VALUE,\n+                        OptionalDouble.empty(), isPresent, newSink);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/FindOps.java","additions":40,"deletions":25,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -284,2 +284,6 @@\n-     * Ensure that the given module has native access. If not, warn or\n-     * throw exception depending on the configuration.\n+     * Ensure that the given module has native access. If not, warn or throw exception depending on the configuration.\n+     * @param m the module in which native access occurred\n+     * @param owner the owner of the restricted method being called (or the JNI method being bound)\n+     * @param methodName the name of the restricted method being called (or the JNI method being bound)\n+     * @param currentClass the class calling the restricted method (for JNI, this is the same as {@code owner})\n+     * @param jni {@code true}, if this event is related to a JNI method being bound\n@@ -287,1 +291,1 @@\n-    void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass);\n+    void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass, boolean jni);\n@@ -449,0 +453,2 @@\n+    Object stringConcat1(String[] constants);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,1 @@\n-    internals of java.lang.reflect. *\/\n-\n+    internals of java.lang.reflect. Use as a last resort! *\/\n@@ -35,25 +34,5 @@\n-    \/** Creates a new java.lang.reflect.Constructor. Access checks as\n-      per java.lang.reflect.AccessibleObject are not overridden. *\/\n-    public <T> Constructor<T> newConstructor(Class<T> declaringClass,\n-                                             Class<?>[] parameterTypes,\n-                                             Class<?>[] checkedExceptions,\n-                                             int modifiers,\n-                                             int slot,\n-                                             String signature,\n-                                             byte[] annotations,\n-                                             byte[] parameterAnnotations);\n-\n-    \/** Gets the MethodAccessor object for a java.lang.reflect.Method *\/\n-    public MethodAccessor getMethodAccessor(Method m);\n-\n-    \/** Sets the MethodAccessor object for a java.lang.reflect.Method *\/\n-    public void setMethodAccessor(Method m, MethodAccessor accessor);\n-\n-    \/** Gets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c);\n-\n-    \/** Sets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor);\n+    \/**\n+     * Creates a new root constructor from the original one, with\n+     * a custom accessor. Used by serialization hooks.\n+     *\/\n+    <T> Constructor<T> newConstructorWithAccessor(Constructor<T> original, ConstructorAccessor accessor);\n@@ -64,12 +43,0 @@\n-    \/** Gets the \"slot\" field from a Constructor (used for serialization) *\/\n-    public int getConstructorSlot(Constructor<?> c);\n-\n-    \/** Gets the \"signature\" field from a Constructor (used for serialization) *\/\n-    public String getConstructorSignature(Constructor<?> c);\n-\n-    \/** Gets the \"annotations\" field from a Constructor (used for serialization) *\/\n-    public byte[] getConstructorAnnotations(Constructor<?> c);\n-\n-    \/** Gets the \"parameterAnnotations\" field from a Constructor (used for serialization) *\/\n-    public byte[] getConstructorParameterAnnotations(Constructor<?> c);\n-\n@@ -82,1 +49,0 @@\n-    \/\/\n@@ -85,1 +51,0 @@\n-    \/\/\n@@ -90,3 +55,0 @@\n-    \/** Makes a copy of this non-root a Method *\/\n-    public Method      leafCopyMethod(Method arg);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":7,"deletions":45,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -56,1 +56,7 @@\n-    for this purpose, namely the loss of compile-time checking. *\/\n+    for this purpose, namely the loss of compile-time checking.\n+ * <p><strong>\n+ * Usage of these APIs often means bad encapsulation designs,\n+ * increased complexity and lack of sustainability.\n+ * Use this only as a last resort!\n+ * <\/strong>\n+ *\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -660,1 +660,1 @@\n-            AnnotationReader.writeAnnotations(buf, attr.annotations());\n+            AnnotationReader.writeTypeAnnotations(buf, attr.annotations());\n@@ -717,1 +717,1 @@\n-            AnnotationReader.writeAnnotations(buf, attr.annotations());\n+            AnnotationReader.writeTypeAnnotations(buf, attr.annotations());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -537,9 +537,0 @@\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (o == this) { return true; }\n-            if (o instanceof AbstractNamedEntry ne) {\n-                return tag == ne.tag() && name().equals(ref1());\n-            }\n-            return false;\n-        }\n@@ -1042,22 +1033,1 @@\n-    abstract static sealed class PrimitiveEntry<T extends ConstantDesc>\n-            extends AbstractPoolEntry {\n-        protected final T val;\n-\n-        public PrimitiveEntry(ConstantPool constantPool, int tag, int index, T val) {\n-            super(constantPool, tag, index, hash1(tag, val.hashCode()));\n-            this.val = val;\n-        }\n-\n-        public T value() {\n-            return val;\n-        }\n-\n-        public ConstantDesc constantValue() {\n-            return value();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"\" + tag() + value();\n-        }\n-    }\n+    public static final class IntegerEntryImpl extends AbstractPoolEntry implements IntegerEntry {\n@@ -1065,2 +1035,1 @@\n-    public static final class IntegerEntryImpl extends PrimitiveEntry<Integer>\n-            implements IntegerEntry {\n+        private final int val;\n@@ -1069,1 +1038,2 @@\n-            super(cpm, ClassFile.TAG_INTEGER, index, i);\n+            super(cpm, ClassFile.TAG_INTEGER, index, hash1(ClassFile.TAG_INTEGER, Integer.hashCode(i)));\n+            val = i;\n@@ -1085,1 +1055,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n@@ -1098,1 +1073,1 @@\n-    public static final class FloatEntryImpl extends PrimitiveEntry<Float>\n+    public static final class FloatEntryImpl extends AbstractPoolEntry\n@@ -1101,0 +1076,2 @@\n+        private final float val;\n+\n@@ -1102,1 +1079,2 @@\n-            super(cpm, ClassFile.TAG_FLOAT, index, f);\n+            super(cpm, ClassFile.TAG_FLOAT, index, hash1(ClassFile.TAG_FLOAT, Float.hashCode(f)));\n+            val = f;\n@@ -1118,1 +1096,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n@@ -1131,1 +1114,3 @@\n-    public static final class LongEntryImpl extends PrimitiveEntry<Long> implements LongEntry {\n+    public static final class LongEntryImpl extends AbstractPoolEntry implements LongEntry {\n+\n+        private final long val;\n@@ -1134,1 +1119,2 @@\n-            super(cpm, ClassFile.TAG_LONG, index, l);\n+            super(cpm, ClassFile.TAG_LONG, index, hash1(ClassFile.TAG_LONG, Long.hashCode(l)));\n+            val = l;\n@@ -1150,1 +1136,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n@@ -1163,1 +1154,3 @@\n-    public static final class DoubleEntryImpl extends PrimitiveEntry<Double> implements DoubleEntry {\n+    public static final class DoubleEntryImpl extends AbstractPoolEntry implements DoubleEntry {\n+\n+        private final double val;\n@@ -1166,1 +1159,2 @@\n-            super(cpm, ClassFile.TAG_DOUBLE, index, d);\n+            super(cpm, ClassFile.TAG_DOUBLE, index, hash1(ClassFile.TAG_DOUBLE, Double.hashCode(d)));\n+            val = d;\n@@ -1182,1 +1176,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":43,"deletions":44,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-        implements Annotation, Util.Writable {\n+        implements Annotation {\n@@ -40,10 +40,0 @@\n-    @Override\n-    public void writeTo(BufWriterImpl buf) {\n-        buf.writeIndex(className());\n-        buf.writeU2(elements().size());\n-        for (var e : elements) {\n-            buf.writeIndex(e.name());\n-            AnnotationReader.writeAnnotationValue(buf, e.value());\n-        }\n-    }\n-\n@@ -55,8 +45,0 @@\n-        if (!evps.isEmpty())\n-            sb.append(\" [\");\n-        for (AnnotationElement evp : evps) {\n-            sb.append(evp.name().stringValue())\n-                    .append(\"=\")\n-                    .append(evp.value().toString())\n-                    .append(\", \");\n-        }\n@@ -64,2 +46,1 @@\n-            sb.delete(sb.length()-1, sb.length());\n-            sb.append(\"]\");\n+            sb.append(' ').append(evps);\n@@ -73,2 +54,1 @@\n-            implements AnnotationElement, Util.Writable {\n-\n+            implements AnnotationElement {\n@@ -76,3 +56,2 @@\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeIndex(name());\n-            AnnotationReader.writeAnnotationValue(buf, value());\n+        public String toString() {\n+            return name + \"=\" + value;\n@@ -82,10 +61,0 @@\n-    public sealed interface OfConstantImpl extends AnnotationValue.OfConstant, Util.Writable {\n-\n-        @Override\n-        default void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeIndex(constant());\n-        }\n-\n-    }\n-\n@@ -93,2 +62,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfString {\n-\n+            implements AnnotationValue.OfString {\n@@ -107,2 +75,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfDouble {\n-\n+            implements AnnotationValue.OfDouble {\n@@ -121,2 +88,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfFloat {\n-\n+            implements AnnotationValue.OfFloat {\n@@ -135,2 +101,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfLong {\n-\n+            implements AnnotationValue.OfLong {\n@@ -149,2 +114,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfInt {\n-\n+            implements AnnotationValue.OfInt {\n@@ -163,2 +127,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfShort {\n-\n+            implements AnnotationValue.OfShort {\n@@ -177,2 +140,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfChar {\n-\n+            implements AnnotationValue.OfChar {\n@@ -191,2 +153,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfByte {\n-\n+            implements AnnotationValue.OfByte {\n@@ -205,2 +166,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfBoolean {\n-\n+            implements AnnotationValue.OfBoolean {\n@@ -219,2 +179,1 @@\n-            implements AnnotationValue.OfArray, Util.Writable {\n-\n+            implements AnnotationValue.OfArray {\n@@ -229,10 +188,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeU2(values.size());\n-            for (var e : values) {\n-                AnnotationReader.writeAnnotationValue(buf, e);\n-            }\n-        }\n-\n@@ -242,1 +191,1 @@\n-            implements AnnotationValue.OfEnum, Util.Writable {\n+            implements AnnotationValue.OfEnum {\n@@ -247,8 +196,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeIndex(className);\n-            buf.writeIndex(constantName);\n-        }\n-\n@@ -258,1 +199,1 @@\n-            implements AnnotationValue.OfAnnotation, Util.Writable {\n+            implements AnnotationValue.OfAnnotation {\n@@ -263,7 +204,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            AnnotationReader.writeAnnotation(buf, annotation);\n-        }\n-\n@@ -273,1 +207,1 @@\n-            implements AnnotationValue.OfClass, Util.Writable {\n+            implements AnnotationValue.OfClass {\n@@ -278,7 +212,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeIndex(className);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationImpl.java","additions":18,"deletions":91,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -244,4 +244,2 @@\n-        Utf8Entry type = classReader.readEntry(p, Utf8Entry.class);\n-        p += 2;\n-        return TypeAnnotation.of(targetInfo, List.of(typePath), type,\n-                                 readAnnotationElementValuePairs(classReader, p));\n+        var anno = readAnnotation(classReader, p);\n+        return TypeAnnotation.of(targetInfo, List.of(typePath), anno);\n@@ -286,3 +284,7 @@\n-        \/\/ handles annotations and type annotations\n-        \/\/ TODO annotation cleanup later\n-        ((Util.Writable) annotation).writeTo(buf);\n+        buf.writeIndex(annotation.className());\n+        var elements = annotation.elements();\n+        buf.writeU2(elements.size());\n+        for (var e : elements) {\n+            buf.writeIndex(e.name());\n+            AnnotationReader.writeAnnotationValue(buf, e.value());\n+        }\n@@ -291,2 +293,1 @@\n-    public static void writeAnnotations(BufWriter buf, List<? extends Annotation> list) {\n-        \/\/ handles annotations and type annotations\n+    public static void writeAnnotations(BufWriter buf, List<Annotation> list) {\n@@ -300,0 +301,60 @@\n+    private static int labelToBci(LabelContext lr, Label label, TypeAnnotation ta) {\n+        \/\/helper method to avoid NPE\n+        if (lr == null) throw new IllegalArgumentException(\"Illegal targetType '%s' in TypeAnnotation outside of Code attribute\".formatted(ta.targetInfo().targetType()));\n+        return lr.labelToBci(label);\n+    }\n+\n+    public static void writeTypeAnnotation(BufWriterImpl buf, TypeAnnotation ta) {\n+        LabelContext lr = buf.labelContext();\n+        \/\/ target_type\n+        buf.writeU1(ta.targetInfo().targetType().targetTypeValue());\n+\n+        \/\/ target_info\n+        switch (ta.targetInfo()) {\n+            case TypeAnnotation.TypeParameterTarget tpt -> buf.writeU1(tpt.typeParameterIndex());\n+            case TypeAnnotation.SupertypeTarget st -> buf.writeU2(st.supertypeIndex());\n+            case TypeAnnotation.TypeParameterBoundTarget tpbt -> {\n+                buf.writeU1(tpbt.typeParameterIndex());\n+                buf.writeU1(tpbt.boundIndex());\n+            }\n+            case TypeAnnotation.EmptyTarget _ -> {\n+                \/\/ nothing to write\n+            }\n+            case TypeAnnotation.FormalParameterTarget fpt -> buf.writeU1(fpt.formalParameterIndex());\n+            case TypeAnnotation.ThrowsTarget tt -> buf.writeU2(tt.throwsTargetIndex());\n+            case TypeAnnotation.LocalVarTarget lvt -> {\n+                buf.writeU2(lvt.table().size());\n+                for (var e : lvt.table()) {\n+                    int startPc = labelToBci(lr, e.startLabel(), ta);\n+                    buf.writeU2(startPc);\n+                    buf.writeU2(labelToBci(lr, e.endLabel(), ta) - startPc);\n+                    buf.writeU2(e.index());\n+                }\n+            }\n+            case TypeAnnotation.CatchTarget ct -> buf.writeU2(ct.exceptionTableIndex());\n+            case TypeAnnotation.OffsetTarget ot -> buf.writeU2(labelToBci(lr, ot.target(), ta));\n+            case TypeAnnotation.TypeArgumentTarget tat -> {\n+                buf.writeU2(labelToBci(lr, tat.target(), ta));\n+                buf.writeU1(tat.typeArgumentIndex());\n+            }\n+        }\n+\n+        \/\/ target_path\n+        buf.writeU1(ta.targetPath().size());\n+        for (TypeAnnotation.TypePathComponent component : ta.targetPath()) {\n+            buf.writeU1(component.typePathKind().tag());\n+            buf.writeU1(component.typeArgumentIndex());\n+        }\n+\n+        \/\/ annotation data\n+        writeAnnotation(buf, ta.annotation());\n+    }\n+\n+    public static void writeTypeAnnotations(BufWriter buf, List<TypeAnnotation> list) {\n+        var internalBuf = (BufWriterImpl) buf;\n+        internalBuf.writeU2(list.size());\n+        for (var e : list) {\n+            writeTypeAnnotation(internalBuf, e);\n+        }\n+    }\n+\n@@ -301,2 +362,21 @@\n-        \/\/ TODO annotation cleanup later\n-        ((Util.Writable) value).writeTo(buf);\n+        var tag = value.tag();\n+        buf.writeU1(tag);\n+        switch (value.tag()) {\n+            case AEV_BOOLEAN, AEV_BYTE, AEV_CHAR, AEV_DOUBLE, AEV_FLOAT, AEV_INT, AEV_LONG, AEV_SHORT, AEV_STRING ->\n+                    buf.writeIndex(((AnnotationValue.OfConstant) value).constant());\n+            case AEV_CLASS -> buf.writeIndex(((AnnotationValue.OfClass) value).className());\n+            case AEV_ENUM -> {\n+                var enumValue = (AnnotationValue.OfEnum) value;\n+                buf.writeIndex(enumValue.className());\n+                buf.writeIndex(enumValue.constantName());\n+            }\n+            case AEV_ANNOTATION -> writeAnnotation(buf, ((AnnotationValue.OfAnnotation) value).annotation());\n+            case AEV_ARRAY -> {\n+                var array = ((AnnotationValue.OfArray) value).values();\n+                buf.writeU2(array.size());\n+                for (var e : array) {\n+                    writeAnnotationValue(buf, e);\n+                }\n+            }\n+            default -> throw new InternalError(\"Unknown value \" + value);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":91,"deletions":11,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -56,0 +56,8 @@\n+    @SuppressWarnings(\"unchecked\")\n+    <A extends Attribute<A>> A get(AttributeMapper<A> am) {\n+        for (Attribute<?> a : attributes)\n+            if (a.attributeMapper() == am)\n+                return (A)a;\n+        return null;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AttributeHolder.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-                filled.add((Attribute<?>) Objects.requireNonNull(mapper.readAttribute(enclosing, reader, p)));\n+                filled.add(Objects.requireNonNull(mapper.readAttribute(enclosing, reader, p)));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -176,6 +176,1 @@\n-            builder.withCode(new Consumer<>() {\n-                @Override\n-                public void accept(CodeBuilder cb) {\n-                    forEach(cb);\n-                }\n-            });\n+            builder.withCode(Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -107,6 +107,1 @@\n-            builder.withField(name, desc, new Consumer<>() {\n-                @Override\n-                public void accept(FieldBuilder fieldBuilder) {\n-                    elements.forEach(fieldBuilder);\n-                }\n-            });\n+            builder.withField(name, desc, Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedFieldBuilder.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -208,6 +208,1 @@\n-            builder.withMethod(methodName(), methodType(), methodFlags(), new Consumer<>() {\n-                @Override\n-                public void accept(MethodBuilder mb) {\n-                    forEach(mb);\n-                }\n-            });\n+            builder.withMethod(methodName(), methodType(), methodFlags(), Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedMethodBuilder.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -278,9 +278,1 @@\n-\n-        var bootstrapDesc = desc.bootstrapMethod();\n-        ClassEntry bsOwner = constantPool.classEntry(bootstrapDesc.owner());\n-        NameAndTypeEntry bsNameAndType = constantPool.nameAndTypeEntry(bootstrapDesc.methodName(),\n-                                                               bootstrapDesc.invocationType());\n-        int bsRefKind = bootstrapDesc.refKind();\n-\n-        MemberRefEntry memberRefEntry = toBootstrapMemberRef(constantPool, bsRefKind, bsOwner, bsNameAndType, bootstrapDesc.isOwnerInterface());\n-        MethodHandleEntry methodHandleEntry = constantPool.methodHandleEntry(bsRefKind, memberRefEntry);\n+        MethodHandleEntry methodHandleEntry = handleDescToHandleInfo(constantPool, desc.bootstrapMethod());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -81,0 +82,9 @@\n+    @Override\n+    public ClassBuilder withMethod(String name, MethodTypeDesc descriptor, int flags, Consumer<? super MethodBuilder> handler) {\n+        var mb = new BufferedMethodBuilder(terminal.constantPool, terminal.context,\n+                constantPool().utf8Entry(name), constantPool().utf8Entry(descriptor), flags, null);\n+        mb.mDesc = descriptor;\n+        consumer.accept(mb.run(handler).toModel());\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedClassBuilder.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,11 +86,22 @@\n-            switch (o) {\n-                case StackMapsOption oo -> smo = oo;\n-                case DebugElementsOption oo -> deo = oo;\n-                case LineNumbersOption oo -> lno = oo;\n-                case AttributesProcessingOption oo -> apo = oo;\n-                case ConstantPoolSharingOption oo -> cpso = oo;\n-                case ShortJumpsOption oo -> sjo = oo;\n-                case DeadCodeOption oo -> dco = oo;\n-                case DeadLabelsOption oo -> dlo = oo;\n-                case ClassHierarchyResolverOption oo -> chro = oo;\n-                case AttributeMapperOption oo -> amo = oo;\n+            if (o instanceof StackMapsOption oo) {\n+                smo = oo;\n+            } else if (o instanceof DebugElementsOption oo) {\n+                deo = oo;\n+            } else if (o instanceof LineNumbersOption oo) {\n+                lno = oo;\n+            } else if (o instanceof AttributesProcessingOption oo) {\n+                apo = oo;\n+            } else if (o instanceof ConstantPoolSharingOption oo) {\n+                cpso = oo;\n+            } else if (o instanceof ShortJumpsOption oo) {\n+                sjo = oo;\n+            } else if (o instanceof DeadCodeOption oo) {\n+                dco = oo;\n+            } else if (o instanceof DeadLabelsOption oo) {\n+                dlo = oo;\n+            } else if (o instanceof ClassHierarchyResolverOption oo) {\n+                chro = oo;\n+            } else if (o instanceof AttributeMapperOption oo) {\n+                amo = oo;\n+            } else { \/\/ null or unknown Option type\n+                throw new IllegalArgumentException(\"Invalid option: \" + o);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileImpl.java","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1041,1 +1041,1 @@\n-                        .with(leaf(\"annotation class\", a.className().stringValue()),\n+                        .with(leaf(\"annotation class\", a.annotation().className().stringValue()),\n@@ -1043,1 +1043,1 @@\n-                        .with(elementValuePairsToTree(a.elements()))));\n+                        .with(elementValuePairsToTree(a.annotation().elements()))));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -404,3 +404,1 @@\n-                a.targetPath(), map(a.classSymbol()),\n-                a.elements().stream().map(el -> AnnotationElement.of(el.name(),\n-                        mapAnnotationValue(el.value()))).toList())).toList();\n+                a.targetPath(), mapAnnotation(a.annotation()))).toList();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -150,6 +150,1 @@\n-                                    new Consumer<CodeBuilder>() {\n-                                        @Override\n-                                        public void accept(CodeBuilder cb) {\n-                                            forEach(cb);\n-                                        }\n-                                    },\n+                                    Util.writingAll(this),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -109,0 +110,7 @@\n+    @Override\n+    public ClassBuilder withMethod(String name, MethodTypeDesc descriptor, int flags, Consumer<? super MethodBuilder> handler) {\n+        var method = new DirectMethodBuilder(constantPool, context, constantPool.utf8Entry(name), constantPool.utf8Entry(descriptor), flags, null);\n+        method.mDesc = descriptor;\n+        return withMethod(method.run(handler));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,6 +102,1 @@\n-            builder.withField(fieldName(), fieldType(), new Consumer<>() {\n-                @Override\n-                public void accept(FieldBuilder fb) {\n-                    FieldImpl.this.forEach(fb);\n-                }\n-            });\n+            builder.withField(fieldName(), fieldType(), Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/FieldImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -139,7 +139,1 @@\n-            builder.withMethod(methodName(), methodType(), methodFlags(),\n-                               new Consumer<>() {\n-                @Override\n-                public void accept(MethodBuilder mb) {\n-                    MethodImpl.this.forEach(mb);\n-                }\n-            });\n+            builder.withMethod(methodName(), methodType(), methodFlags(), Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -269,2 +269,2 @@\n-    private <T extends ConstantDesc> PoolEntry findPrimitiveEntry(int tag, T val) {\n-        int hash = AbstractPoolEntry.hash1(tag, val.hashCode());\n+    private IntegerEntry findIntEntry(int val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_INTEGER, Integer.hashCode(val));\n@@ -274,4 +274,55 @@\n-            if (e.tag() == tag\n-                && e instanceof AbstractPoolEntry.PrimitiveEntry<?> ce\n-                && ce.value().equals(val))\n-                return e;\n+            if (e.tag() == TAG_INTEGER\n+                    && e instanceof AbstractPoolEntry.IntegerEntryImpl ce\n+                    && ce.intValue() == val)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findIntEntry(val);\n+        }\n+        return null;\n+    }\n+\n+    private LongEntry findLongEntry(long val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_LONG, Long.hashCode(val));\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == TAG_LONG\n+                    && e instanceof AbstractPoolEntry.LongEntryImpl ce\n+                    && ce.longValue() == val)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findLongEntry(val);\n+        }\n+        return null;\n+    }\n+\n+    private FloatEntry findFloatEntry(float val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_FLOAT, Float.hashCode(val));\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == TAG_FLOAT\n+                    && e instanceof AbstractPoolEntry.FloatEntryImpl ce\n+                    && ce.floatValue() == val)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findFloatEntry(val);\n+        }\n+        return null;\n+    }\n+\n+    private DoubleEntry findDoubleEntry(double val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_DOUBLE, Double.hashCode(val));\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == TAG_DOUBLE\n+                    && e instanceof AbstractPoolEntry.DoubleEntryImpl ce\n+                    && ce.doubleValue() == val)\n+                return ce;\n@@ -281,1 +332,1 @@\n-            return findPrimitiveEntry(tag, val);\n+            return findDoubleEntry(val);\n@@ -545,1 +596,1 @@\n-        var e = (IntegerEntry) findPrimitiveEntry(TAG_INTEGER, value);\n+        var e = findIntEntry(value);\n@@ -551,1 +602,1 @@\n-        var e = (FloatEntry) findPrimitiveEntry(TAG_FLOAT, value);\n+        var e = findFloatEntry(value);\n@@ -557,1 +608,1 @@\n-        var e = (LongEntry) findPrimitiveEntry(TAG_LONG, value);\n+        var e = findLongEntry(value);\n@@ -563,1 +614,1 @@\n-        var e = (DoubleEntry) findPrimitiveEntry(TAG_DOUBLE, value);\n+        var e = findDoubleEntry(value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":62,"deletions":11,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.Attributes;\n@@ -29,0 +30,2 @@\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n@@ -32,0 +35,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -38,0 +42,1 @@\n+import java.util.stream.Collectors;\n@@ -40,2 +45,0 @@\n-import java.lang.constant.ClassDesc;\n-import java.util.stream.Collectors;\n@@ -50,0 +53,1 @@\n+                dcb.attributes.get(Attributes.stackMapTable()),\n@@ -100,0 +104,1 @@\n+                     StackMapTableAttribute smta,\n@@ -114,1 +119,2 @@\n-        maxStack = stack = rets = 0;\n+        stack = rets = 0;\n+        maxStack = handlers.isEmpty() ? 0 : 1;\n@@ -116,0 +122,11 @@\n+        if (smta != null) {\n+            for (var smfi : smta.entries()) {\n+                int frameStack = smfi.stack().size();\n+                for (var vti : smfi.stack()) {\n+                    if (vti == StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_LONG\n+                     || vti == StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_DOUBLE) frameStack++;\n+                }\n+                if (maxStack < frameStack) maxStack = frameStack;\n+                targets.add(new Target(labelContext.labelToBci(smfi.target()), frameStack));\n+            }\n+        }\n@@ -316,1 +333,1 @@\n-                        addStackSlot(Util.slotSize(mtd.returnType()) - Util.parameterSlots(mtd));\n+                        var delta = Util.slotSize(mtd.returnType()) - Util.parameterSlots(mtd);\n@@ -318,1 +335,1 @@\n-                            addStackSlot(-1);\n+                            delta--;\n@@ -320,0 +337,1 @@\n+                        addStackSlot(delta);\n@@ -322,1 +340,1 @@\n-                        addStackSlot (1 - bcs.getU1(bcs.bci + 3));\n+                        addStackSlot(1 - bcs.getU1(bcs.bci + 3));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -164,2 +164,2 @@\n-        switch (vti) {\n-            case SimpleVerificationTypeInfo svti ->\n+        switch (vti.tag()) {\n+            case VT_TOP, VT_INTEGER, VT_FLOAT, VT_DOUBLE, VT_LONG, VT_NULL, VT_UNINITIALIZED_THIS ->\n@@ -167,4 +167,5 @@\n-            case ObjectVerificationTypeInfo ovti ->\n-                bw.writeIndex(ovti.className());\n-            case UninitializedVerificationTypeInfo uvti ->\n-                bw.writeU2(bw.labelContext().labelToBci(uvti.newTarget()));\n+            case VT_OBJECT ->\n+                bw.writeIndex(((ObjectVerificationTypeInfo)vti).className());\n+            case VT_UNINITIALIZED ->\n+                bw.writeU2(bw.labelContext().labelToBci(((UninitializedVerificationTypeInfo)vti).newTarget()));\n+            default -> throw new IllegalArgumentException(\"Invalid verification type tag: \" + vti.tag());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.classfile.AnnotationElement;\n@@ -39,1 +38,0 @@\n-import java.lang.classfile.Label;\n@@ -761,52 +759,1 @@\n-                                        Utf8Entry className,\n-                                        List<AnnotationElement> elements) implements TypeAnnotation, Util.Writable {\n-\n-        public UnboundTypeAnnotation(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                                     Utf8Entry className, List<AnnotationElement> elements) {\n-            this.targetInfo = targetInfo;\n-            this.targetPath = List.copyOf(targetPath);\n-            this.className = className;\n-            this.elements = List.copyOf(elements);\n-        }\n-\n-        private int labelToBci(LabelContext lr, Label label) {\n-            \/\/helper method to avoid NPE\n-            if (lr == null) throw new IllegalArgumentException(\"Illegal targetType '%s' in TypeAnnotation outside of Code attribute\".formatted(targetInfo.targetType()));\n-            return lr.labelToBci(label);\n-        }\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            LabelContext lr = buf.labelContext();\n-            \/\/ target_type\n-            buf.writeU1(targetInfo.targetType().targetTypeValue());\n-\n-            \/\/ target_info\n-            switch (targetInfo) {\n-                case TypeParameterTarget tpt -> buf.writeU1(tpt.typeParameterIndex());\n-                case SupertypeTarget st -> buf.writeU2(st.supertypeIndex());\n-                case TypeParameterBoundTarget tpbt -> {\n-                    buf.writeU1(tpbt.typeParameterIndex());\n-                    buf.writeU1(tpbt.boundIndex());\n-                }\n-                case EmptyTarget et -> {\n-                    \/\/ nothing to write\n-                }\n-                case FormalParameterTarget fpt -> buf.writeU1(fpt.formalParameterIndex());\n-                case ThrowsTarget tt -> buf.writeU2(tt.throwsTargetIndex());\n-                case LocalVarTarget lvt -> {\n-                    buf.writeU2(lvt.table().size());\n-                    for (var e : lvt.table()) {\n-                        int startPc = labelToBci(lr, e.startLabel());\n-                        buf.writeU2(startPc);\n-                        buf.writeU2(labelToBci(lr, e.endLabel()) - startPc);\n-                        buf.writeU2(e.index());\n-                    }\n-                }\n-                case CatchTarget ct -> buf.writeU2(ct.exceptionTableIndex());\n-                case OffsetTarget ot -> buf.writeU2(labelToBci(lr, ot.target()));\n-                case TypeArgumentTarget tat -> {\n-                    buf.writeU2(labelToBci(lr, tat.target()));\n-                    buf.writeU1(tat.typeArgumentIndex());\n-                }\n-            }\n+                                        Annotation annotation) implements TypeAnnotation {\n@@ -814,16 +761,2 @@\n-            \/\/ target_path\n-            buf.writeU1(targetPath().size());\n-            for (TypePathComponent component : targetPath()) {\n-                buf.writeU1(component.typePathKind().tag());\n-                buf.writeU1(component.typeArgumentIndex());\n-            }\n-\n-            \/\/ type_index\n-            buf.writeIndex(className);\n-\n-            \/\/ element_value_pairs\n-            buf.writeU2(elements.size());\n-            for (AnnotationElement pair : elements()) {\n-                buf.writeIndex(pair.name());\n-                AnnotationReader.writeAnnotationValue(buf, pair.value());\n-            }\n+        public UnboundTypeAnnotation {\n+            targetPath = List.copyOf(targetPath);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":3,"deletions":70,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.classfile.CodeBuilder;\n@@ -28,0 +29,2 @@\n+import java.lang.classfile.FieldBuilder;\n+import java.lang.classfile.MethodBuilder;\n@@ -66,0 +69,30 @@\n+    public static <T> Consumer<Consumer<T>> writingAll(Iterable<T> container) {\n+        record ForEachConsumer<T>(Iterable<T> container) implements Consumer<Consumer<T>> {\n+            @Override\n+            public void accept(Consumer<T> consumer) {\n+                container.forEach(consumer);\n+            }\n+        }\n+        return new ForEachConsumer<>(container);\n+    }\n+\n+    public static Consumer<MethodBuilder> buildingCode(Consumer<? super CodeBuilder> codeHandler) {\n+        record WithCodeMethodHandler(Consumer<? super CodeBuilder> codeHandler) implements Consumer<MethodBuilder> {\n+            @Override\n+            public void accept(MethodBuilder builder) {\n+                builder.withCode(codeHandler);\n+            }\n+        }\n+        return new WithCodeMethodHandler(codeHandler);\n+    }\n+\n+    public static Consumer<FieldBuilder> buildingFlags(int flags) {\n+        record WithFlagFieldHandler(int flags) implements Consumer<FieldBuilder> {\n+            @Override\n+            public void accept(FieldBuilder builder) {\n+                builder.withFlags(flags);\n+            }\n+        }\n+        return new WithFlagFieldHandler(flags);\n+    }\n+\n@@ -194,1 +227,1 @@\n-    private static <T> void writeAttribute(BufWriterImpl writer, Attribute<?> attr) {\n+    private static <T extends Attribute<T>> void writeAttribute(BufWriterImpl writer, Attribute<?> attr) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -396,1 +396,1 @@\n-            l += 2 + an.targetInfo().size() + 2 * an.targetPath().size() + annotationSize(an);\n+            l += 2 + an.targetInfo().size() + 2 * an.targetPath().size() + annotationSize(an.annotation());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import static jdk.internal.constant.PrimitiveClassDescImpl.*;\n+\n@@ -272,33 +274,13 @@\n-    \/**\n-     * Parses a method descriptor string, and return a list of field descriptor\n-     * strings, return type first, then parameter types\n-     *\n-     * @param descriptor the descriptor string\n-     * @return the list of types\n-     * @throws IllegalArgumentException if the descriptor string is not valid\n-     *\/\n-    public static List<ClassDesc> parseMethodDescriptor(String descriptor) {\n-        int cur = 0, end = descriptor.length();\n-        ArrayList<ClassDesc> ptypes = new ArrayList<>();\n-        ptypes.add(null); \/\/ placeholder for return type\n-\n-        if (cur >= end || descriptor.charAt(cur) != '(')\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-\n-        ++cur;  \/\/ skip '('\n-        while (cur < end && descriptor.charAt(cur) != ')') {\n-            int len = skipOverFieldSignature(descriptor, cur, end, false);\n-            if (len == 0)\n-                throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-            ptypes.add(resolveClassDesc(descriptor, cur, len));\n-            cur += len;\n-        }\n-        if (cur >= end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ++cur;  \/\/ skip ')'\n-\n-        int rLen = skipOverFieldSignature(descriptor, cur, end, true);\n-        if (rLen == 0 || cur + rLen != end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ptypes.set(0, resolveClassDesc(descriptor, cur, rLen));\n-        return ptypes;\n+    public static PrimitiveClassDescImpl forPrimitiveType(String descriptor, int offset) {\n+        return switch (descriptor.charAt(offset)) {\n+            case JVM_SIGNATURE_BYTE    -> CD_byte;\n+            case JVM_SIGNATURE_CHAR    -> CD_char;\n+            case JVM_SIGNATURE_FLOAT   -> CD_float;\n+            case JVM_SIGNATURE_DOUBLE  -> CD_double;\n+            case JVM_SIGNATURE_INT     -> CD_int;\n+            case JVM_SIGNATURE_LONG    -> CD_long;\n+            case JVM_SIGNATURE_SHORT   -> CD_short;\n+            case JVM_SIGNATURE_VOID    -> CD_void;\n+            case JVM_SIGNATURE_BOOLEAN -> CD_boolean;\n+            default -> throw badMethodDescriptor(descriptor);\n+        };\n@@ -307,1 +289,1 @@\n-    private static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n+    static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n@@ -309,1 +291,1 @@\n-            return Wrapper.forPrimitiveType(descriptor.charAt(start)).basicClassDescriptor();\n+            return forPrimitiveType(descriptor, start);\n@@ -311,1 +293,2 @@\n-        \/\/ Pre-verified in parseMethodDescriptor; avoid redundant verification\n+\n+        \/\/ Pre-verified in MethodTypeDescImpl#ofDescriptor; avoid redundant verification\n@@ -315,0 +298,4 @@\n+    static IllegalArgumentException badMethodDescriptor(String descriptor) {\n+        return new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+    }\n+\n@@ -319,2 +306,0 @@\n-    private static final char JVM_SIGNATURE_ENDCLASS = ';';\n-    private static final char JVM_SIGNATURE_ENUM = 'E';\n@@ -323,2 +308,0 @@\n-    private static final char JVM_SIGNATURE_FUNC = '(';\n-    private static final char JVM_SIGNATURE_ENDFUNC = ')';\n@@ -337,1 +320,0 @@\n-     * @param voidOK is void acceptable?\n@@ -341,2 +323,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n-    static int skipOverFieldSignature(String descriptor, int start, int end, boolean voidOK) {\n+    static int skipOverFieldSignature(String descriptor, int start, int end) {\n@@ -345,3 +326,10 @@\n-        while (index < end) {\n-            switch (descriptor.charAt(index)) {\n-                case JVM_SIGNATURE_VOID: if (!voidOK) { return 0; }\n+        if (index < end) {\n+            char ch;\n+            while ((ch = descriptor.charAt(index++)) == JVM_SIGNATURE_ARRAY) {\n+                arrayDim++;\n+            }\n+            if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+                throw maxArrayTypeDescDimensions();\n+            }\n+\n+            switch (ch) {\n@@ -356,1 +344,1 @@\n-                    return index - start + 1;\n+                    return index - start;\n@@ -361,2 +349,2 @@\n-                    while (++index < end) {\n-                        switch (descriptor.charAt(index)) {\n+                    while (index < end) {\n+                        switch (descriptor.charAt(index++)) {\n@@ -365,1 +353,1 @@\n-                                return legal ? index - start + 1 : 0;\n+                                return legal ? index - start : 0;\n@@ -380,10 +368,0 @@\n-                    return 0;\n-                case JVM_SIGNATURE_ARRAY:\n-                    arrayDim++;\n-                    if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-                        throw new IllegalArgumentException(String.format(\"Cannot create an array type descriptor with more than %d dimensions\",\n-                                ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n-                    }\n-                    \/\/ The rest of what's there better be a legal descriptor\n-                    index++;\n-                    voidOK = false;\n@@ -392,1 +370,1 @@\n-                    return 0;\n+                    break;\n@@ -397,0 +375,6 @@\n+\n+    private static IllegalArgumentException maxArrayTypeDescDimensions() {\n+        return new IllegalArgumentException(String.format(\n+                        \"Cannot create an array type descriptor with more than %d dimensions\",\n+                        ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":45,"deletions":61,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -35,0 +37,1 @@\n+import java.util.ArrayList;\n@@ -41,0 +44,6 @@\n+import static jdk.internal.constant.ConstantUtils.badMethodDescriptor;\n+import static jdk.internal.constant.ConstantUtils.resolveClassDesc;\n+import static jdk.internal.constant.ConstantUtils.skipOverFieldSignature;\n+import static jdk.internal.constant.ConstantUtils.EMPTY_CLASSDESC;\n+import static jdk.internal.constant.PrimitiveClassDescImpl.CD_void;\n+\n@@ -94,1 +103,1 @@\n-            return new MethodTypeDescImpl(returnType, ConstantUtils.EMPTY_CLASSDESC);\n+            return new MethodTypeDescImpl(returnType, EMPTY_CLASSDESC);\n@@ -108,8 +117,17 @@\n-        \/\/ Implicit null-check of descriptor\n-        List<ClassDesc> ptypes = ConstantUtils.parseMethodDescriptor(descriptor);\n-        int args = ptypes.size() - 1;\n-        ClassDesc[] paramTypes = args > 0\n-                ? ptypes.subList(1, args + 1).toArray(ConstantUtils.EMPTY_CLASSDESC)\n-                : ConstantUtils.EMPTY_CLASSDESC;\n-\n-        MethodTypeDescImpl result = ofValidated(ptypes.get(0), paramTypes);\n+        int length = descriptor.length();\n+        int rightBracket, retTypeLength;\n+        if (descriptor.charAt(0) != '('\n+                || (rightBracket = (descriptor.charAt(1) == ')' ? 1 : descriptor.lastIndexOf(')'))) <= 0\n+                || (retTypeLength = length - rightBracket - 1) == 0\n+                || (retTypeLength != 1 \/\/ if retTypeLength == 1, check correctness in resolveClassDesc\n+                    && retTypeLength != skipOverFieldSignature(descriptor, rightBracket + 1, length))\n+        ) {\n+            throw badMethodDescriptor(descriptor);\n+        }\n+\n+        var returnType = resolveClassDesc(descriptor, rightBracket + 1, retTypeLength);\n+        if (length == 3 && returnType == CD_void) {\n+            return (MethodTypeDescImpl) ConstantDescs.MTD_void;\n+        }\n+        var paramTypes = paramTypes(descriptor, 1, rightBracket);\n+        var result = new MethodTypeDescImpl(returnType, paramTypes);\n@@ -120,0 +138,71 @@\n+    private static ClassDesc[] paramTypes(String descriptor, int start, int end) {\n+        if (start == end) {\n+            return EMPTY_CLASSDESC;\n+        }\n+\n+        \/*\n+         * If the length of the first 8 parameters is < 256, save them in lengths to avoid ArrayList allocation\n+         * Stop storing for the last parameter (we can compute length), or if too many parameters or too long.\n+         *\/\n+        \/\/ little endian storage - lowest byte is encoded length 0\n+        long packedLengths = 0;\n+        int packedCount = 0;\n+        int cur = start;\n+        while (cur < end) {\n+            int len = skipOverFieldSignature(descriptor, cur, end);\n+            if (len == 0) {\n+                throw badMethodDescriptor(descriptor);\n+            }\n+            cur += len;\n+            if (len > 0xFF || packedCount >= Long.SIZE \/ Byte.SIZE || cur == end) {\n+                \/\/ Cannot or do not have to pack this item, but is already scanned and valid\n+                break;\n+            }\n+            packedLengths = packedLengths | (((long) len) << (Byte.SIZE * packedCount++));\n+        }\n+\n+        \/\/ Invariant: packedCount parameters encoded in packedLengths,\n+        \/\/ And another valid parameter pointed by cur\n+\n+        \/\/ Recover encoded elements\n+        ClassDesc[]     paramTypes    = null;\n+        List<ClassDesc> paramTypeList = null;\n+        if (cur == end) {\n+            paramTypes = new ClassDesc[packedCount + 1];\n+        } else {\n+            paramTypeList = new ArrayList<>(32);\n+        }\n+\n+        int last = start;\n+        for (int i = 0; i < packedCount; i++) {\n+            int len = Byte.toUnsignedInt((byte) (packedLengths >> (Byte.SIZE * i)));\n+            var cd = resolveClassDesc(descriptor, last, len);\n+            if (paramTypes != null) {\n+                paramTypes[i] = cd;\n+            } else {\n+                paramTypeList.add(cd);\n+            }\n+            last += len;\n+        }\n+        var lastCd = resolveClassDesc(descriptor, last, cur - last);\n+\n+        if (paramTypes != null) {\n+            paramTypes[packedCount] = lastCd;\n+            return paramTypes;\n+        }\n+        paramTypeList.add(lastCd);\n+        return buildParamTypes(descriptor, cur, end, paramTypeList);\n+    }\n+\n+    \/\/ slow path\n+    private static ClassDesc[] buildParamTypes(String descriptor, int cur, int end, List<ClassDesc> list) {\n+        while (cur < end) {\n+            int len = skipOverFieldSignature(descriptor, cur, end);\n+            if (len == 0)\n+                throw badMethodDescriptor(descriptor);\n+            list.add(resolveClassDesc(descriptor, cur, len));\n+            cur += len;\n+        }\n+\n+        return list.toArray(EMPTY_CLASSDESC);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":98,"deletions":9,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -43,0 +44,27 @@\n+    \/** {@link ClassDesc} representing the primitive type {@code int} *\/\n+    public static final PrimitiveClassDescImpl CD_int = new PrimitiveClassDescImpl(\"I\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code long} *\/\n+    public static final PrimitiveClassDescImpl CD_long = new PrimitiveClassDescImpl(\"J\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code float} *\/\n+    public static final PrimitiveClassDescImpl CD_float = new PrimitiveClassDescImpl(\"F\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code double} *\/\n+    public static final PrimitiveClassDescImpl CD_double = new PrimitiveClassDescImpl(\"D\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code short} *\/\n+    public static final PrimitiveClassDescImpl CD_short = new PrimitiveClassDescImpl(\"S\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code byte} *\/\n+    public static final PrimitiveClassDescImpl CD_byte = new PrimitiveClassDescImpl(\"B\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code char} *\/\n+    public static final PrimitiveClassDescImpl CD_char = new PrimitiveClassDescImpl(\"C\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code boolean} *\/\n+    public static final PrimitiveClassDescImpl CD_boolean = new PrimitiveClassDescImpl(\"Z\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code void} *\/\n+    public static final PrimitiveClassDescImpl CD_void = new PrimitiveClassDescImpl(\"V\");\n+\n@@ -44,0 +72,1 @@\n+    private @Stable Wrapper lazyWrapper; \/\/ initialized only after this\n@@ -55,1 +84,1 @@\n-    public PrimitiveClassDescImpl(String descriptor) {\n+    private PrimitiveClassDescImpl(String descriptor) {\n@@ -57,3 +86,0 @@\n-        if (descriptor.length() != 1\n-            || \"VIJCSBFDZ\".indexOf(descriptor.charAt(0)) < 0)\n-            throw new IllegalArgumentException(String.format(\"not a valid primitive type descriptor: %s\", descriptor));\n@@ -63,0 +89,7 @@\n+    public Wrapper wrapper() {\n+        var wrapper = this.lazyWrapper;\n+        if (wrapper != null)\n+            return wrapper;\n+        return this.lazyWrapper = Wrapper.forBasicType(descriptorString().charAt(0));\n+    }\n+\n@@ -70,1 +103,1 @@\n-        return Wrapper.forBasicType(descriptorString().charAt(0)).primitiveType();\n+        return wrapper().primitiveType();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/PrimitiveClassDescImpl.java","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen, false);\n+        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen);\n@@ -69,1 +69,1 @@\n-        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length(), false)\n+        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length())\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ReferenceClassDescImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-        Reflection.ensureNativeAccess(callerClass, MemorySegment.class, \"reinterpret\");\n+        Reflection.ensureNativeAccess(callerClass, MemorySegment.class, \"reinterpret\", false);\n@@ -376,0 +376,10 @@\n+    @ForceInline\n+    public final void checkEnclosingLayout(long offset, MemoryLayout enclosing, boolean readOnly) {\n+        checkAccess(offset, enclosing.byteSize(), readOnly);\n+        if (!isAlignedForElement(offset, enclosing)) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Target offset %d is incompatible with alignment constraint %d (of %s) for segment %s\"\n+                    , offset, enclosing.byteAlignment(), enclosing, this));\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    private static final MethodHandle MH_ADD;\n+    private static final MethodHandle MH_ADD_EXACT;\n@@ -83,2 +83,2 @@\n-                    MethodType.methodType(MemorySegment.class, MemorySegment.class, MemoryLayout.class));\n-            MH_ADD = lookup.findStatic(Long.class, \"sum\",\n+                    MethodType.methodType(MemorySegment.class, MemorySegment.class));\n+            MH_ADD_EXACT = lookup.findStatic(Math.class, \"addExact\",\n@@ -183,2 +183,1 @@\n-        handle = MethodHandles.filterReturnValue(handle,\n-                MethodHandles.insertArguments(MH_SEGMENT_RESIZE, 1, derefLayout));\n+        handle = MethodHandles.filterReturnValue(handle, MH_SEGMENT_RESIZE);\n@@ -188,2 +187,4 @@\n-    private static MemorySegment resizeSegment(MemorySegment segment, MemoryLayout layout) {\n-        return Utils.longToAddress(segment.address(), layout.byteSize(), layout.byteAlignment());\n+    private static MemorySegment resizeSegment(MemorySegment segment) {\n+        \/\/ Avoid adapting for specific target layout. The check for the root layout\n+        \/\/ size and alignment will be inserted by LayoutPath::dereferenceHandle anyway.\n+        return Utils.longToAddress(segment.address(), Long.MAX_VALUE, 1);\n@@ -208,13 +209,9 @@\n-        VarHandle handle = Utils.makeRawSegmentViewVarHandle(valueLayout);\n-        handle = MethodHandles.collectCoordinates(handle, 1, offsetHandle());\n-\n-        \/\/ we only have to check the alignment of the root layout for the first dereference we do,\n-        \/\/ as each dereference checks the alignment of the target address when constructing its segment\n-        \/\/ (see Utils::longToAddress)\n-        if (derefAdapters.length == 0) {\n-            \/\/ insert align check for the root layout on the initial MS + offset\n-            List<Class<?>> coordinateTypes = handle.coordinateTypes();\n-            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ENCL_LAYOUT, 2, rootLayout());\n-            handle = MethodHandles.collectCoordinates(handle, 0, alignCheck);\n-            int[] reorder = IntStream.concat(IntStream.of(0, 1), IntStream.range(0, coordinateTypes.size())).toArray();\n-            handle = MethodHandles.permuteCoordinates(handle, coordinateTypes, reorder);\n+        VarHandle handle = Utils.makeRawSegmentViewVarHandle(valueLayout);              \/\/ (MS, ML, long, long)\n+        handle = MethodHandles.insertCoordinates(handle, 1, rootLayout());          \/\/ (MS, long, long)\n+        if (strides.length > 0) {\n+            MethodHandle offsetAdapter = offsetHandle();\n+            offsetAdapter = MethodHandles.insertArguments(offsetAdapter, 0, 0L);\n+            handle = MethodHandles.collectCoordinates(handle, 2, offsetAdapter);    \/\/ (MS, long)\n+        } else {\n+            \/\/ simpler adaptation\n+            handle = MethodHandles.insertCoordinates(handle, 2, offset);            \/\/ (MS, long)\n@@ -244,0 +241,2 @@\n+        \/\/ note: the below can overflow, depending on 'base'. When constructing var handles\n+        \/\/ through the layout API, this is never the case, as the injected 'base' is always 0.\n@@ -248,1 +247,1 @@\n-        MethodHandle mh = MethodHandles.insertArguments(MH_ADD, 0, offset);\n+        MethodHandle mh = MH_ADD_EXACT;\n@@ -251,3 +250,7 @@\n-            \/\/ (J, ...) -> J to (J, J, ...) -> J\n-            \/\/ i.e. new coord is prefixed. Last coord will correspond to innermost layout\n-            mh = MethodHandles.collectArguments(mh, 0, collector);\n+            \/\/ (J, J, ...) -> J to (J, J, J, ...) -> J\n+            \/\/ 1. the leading argument is the base offset (externally provided).\n+            \/\/ 2. index arguments are added. The last index correspond to the innermost layout.\n+            \/\/ 3. overflow can only occur at the outermost layer, due to the final addition with the base offset.\n+            \/\/ This is because the layout API ensures (by construction) that all offsets generated from layout paths\n+            \/\/ are always < Long.MAX_VALUE.\n+            mh = MethodHandles.collectArguments(mh, 1, collector);\n@@ -255,2 +258,1 @@\n-\n-        return mh;\n+        return MethodHandles.insertArguments(mh, 1, offset);\n@@ -288,6 +290,1 @@\n-        ((AbstractMemorySegmentImpl)segment).checkAccess(offset, enclosing.byteSize(), true);\n-        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(offset, enclosing)) {\n-            throw new IllegalArgumentException(String.format(\n-                    \"Target offset %d is incompatible with alignment constraint %d (of %s) for segment %s\"\n-                    , offset, enclosing.byteAlignment(), enclosing, segment));\n-        }\n+        ((AbstractMemorySegmentImpl)segment).checkEnclosingLayout(offset, enclosing, true);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":29,"deletions":32,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-    private static final MethodHandle LONG_TO_ADDRESS;\n+    private static final MethodHandle LONG_TO_ADDRESS_TARGET;\n+    private static final MethodHandle LONG_TO_ADDRESS_NO_TARGET;\n@@ -77,2 +78,4 @@\n-            LONG_TO_ADDRESS = lookup.findStatic(Utils.class, \"longToAddress\",\n-                    MethodType.methodType(MemorySegment.class, long.class, long.class, long.class));\n+            LONG_TO_ADDRESS_TARGET = lookup.findStatic(Utils.class, \"longToAddress\",\n+                    MethodType.methodType(MemorySegment.class, long.class, AddressLayout.class));\n+            LONG_TO_ADDRESS_NO_TARGET = lookup.findStatic(Utils.class, \"longToAddress\",\n+                    MethodType.methodType(MemorySegment.class, long.class));\n@@ -132,5 +135,4 @@\n-            handle = MethodHandles.filterValue(handle,\n-                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemorySegment.class)),\n-                    MethodHandles.explicitCastArguments(MethodHandles.insertArguments(LONG_TO_ADDRESS, 1,\n-                                    pointeeByteSize(addressLayout), pointeeByteAlign(addressLayout)),\n-                            MethodType.methodType(MemorySegment.class, baseCarrier)));\n+            MethodHandle longToAddressAdapter = addressLayout.targetLayout().isPresent() ?\n+                    MethodHandles.insertArguments(LONG_TO_ADDRESS_TARGET, 1, addressLayout) :\n+                    LONG_TO_ADDRESS_NO_TARGET;\n+            handle = MethodHandles.filterValue(handle, ADDRESS_TO_LONG, longToAddressAdapter);\n@@ -149,0 +151,10 @@\n+    @ForceInline\n+    public static MemorySegment longToAddress(long addr) {\n+        return longToAddress(addr, 0, 1);\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment longToAddress(long addr, AddressLayout layout) {\n+        return longToAddress(addr, pointeeByteSize(layout), pointeeByteAlign(layout));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\");\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\", false);\n@@ -91,1 +91,1 @@\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\");\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\", false);\n@@ -118,1 +118,1 @@\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"upcallStub\");\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"upcallStub\", false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-            Reflection.ensureNativeAccess(Reflection.getCallerClass(), AddressLayout.class, \"withTargetLayout\");\n+            Reflection.ensureNativeAccess(Reflection.getCallerClass(), AddressLayout.class, \"withTargetLayout\", false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+                    @SuppressWarnings(\"restricted\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/NativeImageBuffer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.io.InterruptedIOException;\n@@ -90,18 +89,0 @@\n-\n-        \/\/ This code has been uglified to protect against interrupts.\n-        \/\/ Even if a thread has been interrupted when loading resources,\n-        \/\/ the IO should not abort, so must carefully retry, failing only\n-        \/\/ if the retry leads to some other IO exception.\n-\n-        boolean isInterrupted = Thread.interrupted();\n-        int len;\n-        for (;;) {\n-            try {\n-                len = getContentLength();\n-                break;\n-            } catch (InterruptedIOException iioe) {\n-                Thread.interrupted();\n-                isInterrupted = true;\n-            }\n-        }\n-\n@@ -109,0 +90,1 @@\n+            int len = getContentLength();\n@@ -124,7 +106,1 @@\n-                int cc = 0;\n-                try {\n-                    cc = in.read(b, pos, bytesToRead);\n-                } catch (InterruptedIOException iioe) {\n-                    Thread.interrupted();\n-                    isInterrupted = true;\n-                }\n+                int cc = in.read(b, pos, bytesToRead);\n@@ -146,2 +122,0 @@\n-            } catch (InterruptedIOException iioe) {\n-                isInterrupted = true;\n@@ -149,4 +123,0 @@\n-\n-            if (isInterrupted) {\n-                Thread.currentThread().interrupt();\n-            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/Resource.java","additions":3,"deletions":33,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,0 @@\n-import java.util.zip.ZipEntry;\n@@ -442,1 +441,2 @@\n-            Loader loader;\n+            Loader loader = null;\n+            final URL[] loaderClassPathURLs;\n@@ -447,4 +447,1 @@\n-                URL[] urls = loader.getClassPath();\n-                if (urls != null) {\n-                    push(urls);\n-                }\n+                loaderClassPathURLs = loader.getClassPath();\n@@ -452,1 +449,8 @@\n-                \/\/ Silently ignore for now...\n+                \/\/ log the error and close the unusable loader (if any)\n+                if (DEBUG) {\n+                    System.err.println(\"Failed to construct a loader or construct its\" +\n+                            \" local classpath for \" + url + \", cause:\" + e);\n+                }\n+                if (loader != null) {\n+                    closeQuietly(loader);\n+                }\n@@ -455,3 +459,3 @@\n-                \/\/ Always silently ignore. The context, if there is one, that\n-                \/\/ this URLClassPath was given during construction will never\n-                \/\/ have permission to access the URL.\n+                \/\/ log the error and close the unusable loader (if any).\n+                \/\/ The context, if there is one, that this URLClassPath was\n+                \/\/ given during construction will never have permission to access the URL.\n@@ -461,0 +465,3 @@\n+                if (loader != null) {\n+                    closeQuietly(loader);\n+                }\n@@ -463,0 +470,3 @@\n+            if (loaderClassPathURLs != null) {\n+                push(loaderClassPathURLs);\n+            }\n@@ -470,0 +480,11 @@\n+    \/\/ closes the given loader and ignores any IOException that may occur during close\n+    private static void closeQuietly(final Loader loader) {\n+        try {\n+            loader.close();\n+        } catch (IOException ioe) {\n+            if (DEBUG) {\n+                System.err.println(\"ignoring exception \" + ioe + \" while closing loader \" + loader);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -790,1 +790,0 @@\n-    private static final boolean HAS_ENABLE_NATIVE_ACCESS_FLAG;\n@@ -793,0 +792,1 @@\n+    private static final IllegalNativeAccess ILLEGAL_NATIVE_ACCESS;\n@@ -794,2 +794,8 @@\n-    public static boolean hasEnableNativeAccessFlag() {\n-        return HAS_ENABLE_NATIVE_ACCESS_FLAG;\n+    public enum IllegalNativeAccess {\n+        ALLOW,\n+        WARN,\n+        DENY\n+    }\n+\n+    public static IllegalNativeAccess illegalNativeAccess() {\n+        return ILLEGAL_NATIVE_ACCESS;\n@@ -799,0 +805,1 @@\n+        ILLEGAL_NATIVE_ACCESS = addIllegalNativeAccess();\n@@ -800,1 +807,0 @@\n-        HAS_ENABLE_NATIVE_ACCESS_FLAG = !USER_NATIVE_ACCESS_MODULES.isEmpty();\n@@ -850,0 +856,21 @@\n+    \/**\n+     * Process the --illegal-native-access option (and its default).\n+     *\/\n+    private static IllegalNativeAccess addIllegalNativeAccess() {\n+        String value = getAndRemoveProperty(\"jdk.module.illegal.native.access\");\n+        \/\/ don't use a switch: bootstrapping issues!\n+        if (value == null) {\n+            return IllegalNativeAccess.WARN; \/\/ default\n+        } else if (value.equals(\"deny\")) {\n+            return IllegalNativeAccess.DENY;\n+        } else if (value.equals(\"allow\")) {\n+            return IllegalNativeAccess.ALLOW;\n+        } else if (value.equals(\"warn\")) {\n+            return IllegalNativeAccess.WARN;\n+        } else {\n+            fail(\"Value specified to --illegal-native-access not recognized:\"\n+                    + \" '\" + value + \"'\");\n+            return null;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-    public static void ensureNativeAccess(Class<?> currentClass, Class<?> owner, String methodName) {\n+    public static void ensureNativeAccess(Class<?> currentClass, Class<?> owner, String methodName, boolean jni) {\n@@ -122,1 +122,4 @@\n-        Holder.JLA.ensureNativeAccess(module, owner, methodName, currentClass);\n+        if (module != null) {\n+            \/\/ not in init phase\n+            Holder.JLA.ensureNativeAccess(module, owner, methodName, currentClass, jni);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,35 +182,0 @@\n-    \/** Creates a new java.lang.reflect.Constructor. Access checks as\n-        per java.lang.reflect.AccessibleObject are not overridden. *\/\n-    public Constructor<?> newConstructor(Class<?> declaringClass,\n-                                         Class<?>[] parameterTypes,\n-                                         Class<?>[] checkedExceptions,\n-                                         int modifiers,\n-                                         int slot,\n-                                         String signature,\n-                                         byte[] annotations,\n-                                         byte[] parameterAnnotations)\n-    {\n-        return langReflectAccess.newConstructor(declaringClass,\n-                                                parameterTypes,\n-                                                checkedExceptions,\n-                                                modifiers,\n-                                                slot,\n-                                                signature,\n-                                                annotations,\n-                                                parameterAnnotations);\n-    }\n-\n-    \/** Gets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c) {\n-        return langReflectAccess.getConstructorAccessor(c);\n-    }\n-\n-    \/** Sets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor)\n-    {\n-        langReflectAccess.setConstructorAccessor(c, accessor);\n-    }\n-\n@@ -228,1 +193,2 @@\n-        return langReflectAccess.leafCopyMethod(arg);\n+        Method root = langReflectAccess.getRoot(arg);\n+        return langReflectAccess.copyMethod(root);\n@@ -231,1 +197,0 @@\n-\n@@ -372,9 +337,0 @@\n-\n-        Constructor<?> ctor = newConstructor(constructorToCall.getDeclaringClass(),\n-                                             constructorToCall.getParameterTypes(),\n-                                             constructorToCall.getExceptionTypes(),\n-                                             constructorToCall.getModifiers(),\n-                                             langReflectAccess.getConstructorSlot(constructorToCall),\n-                                             langReflectAccess.getConstructorSignature(constructorToCall),\n-                                             langReflectAccess.getConstructorAnnotations(constructorToCall),\n-                                             langReflectAccess.getConstructorParameterAnnotations(constructorToCall));\n@@ -389,1 +345,1 @@\n-            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, ctor);\n+            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, constructorToCall);\n@@ -391,1 +347,4 @@\n-        setConstructorAccessor(ctor, acc);\n+        \/\/ Unlike other root constructors, this constructor is not copied for mutation\n+        \/\/ but directly mutated, as it is not cached. To cache this constructor,\n+        \/\/ setAccessible call must be done on a copy and return that copy instead.\n+        Constructor<?> ctor = langReflectAccess.newConstructorWithAccessor(constructorToCall, acc);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":8,"deletions":49,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -83,1 +82,5 @@\n-        String value = GetPropertyAction.privilegedGetProperty(key);\n+        \/*\n+         * GetPropertyAction.privilegedGetProperty cannot be used here, Using VM.getSavedProperty to avoid a bootstrap\n+         * circularity issue in the java\/lang\/String\/concat\/WithSecurityManager.java test\n+         *\/\n+        String value = VM.getSavedProperty(key);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ClassFileDumper.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -430,0 +430,1 @@\n+    @IntrinsicCandidate\n@@ -437,0 +438,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -259,1 +259,2 @@\n-        jdk.internal.vm.ci;\n+        jdk.internal.vm.ci,\n+        jdk.jfr;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -307,15 +307,0 @@\n-    \/** Return the wrapper that corresponds to the provided basic type char.\n-     *  The basic type char must be for one of the eight primitive types, or void.\n-     *  @throws IllegalArgumentException for unexpected types\n-     *\/\n-    public static Wrapper forPrimitiveType(char basicTypeChar) {\n-        Wrapper w = FROM_CHAR[(basicTypeChar + (basicTypeChar >> 1)) & 0xf];\n-        if (w == null || w.basicTypeChar != basicTypeChar) {\n-            throw basicTypeError(basicTypeChar);\n-        }\n-        if (w == OBJECT) {\n-            throw newIllegalArgumentException(\"not primitive: \" + basicTypeChar);\n-        }\n-        return w;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+\\    --illegal-native-access=<value>\\n\\\n+\\                  allow or deny access to code and data outside the Java runtime\\n\\\n+\\                  by code in modules for which native access is not explicitly enabled.\\n\\\n+\\                  <value> is one of \"deny\", \"warn\" or \"allow\". The default value is \"warn\".\\n\\\n+\\                  This option will be removed in a future release.\\n\\\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -686,0 +686,1 @@\n+            long remainingNanos = nanos;\n@@ -691,3 +692,0 @@\n-                    long remainingNanos = (nanos > 0)\n-                            ? nanos - (System.nanoTime() - startNanos)\n-                            : 0;\n@@ -714,1 +712,0 @@\n-                            \/\/ copy bytes to the DatagramPacket, and set length and sender\n@@ -716,0 +713,1 @@\n+                                \/\/ copy bytes to the DatagramPacket, and set length and sender\n@@ -723,0 +721,8 @@\n+                            } else {\n+                                \/\/ need to retry, adjusting timeout if needed\n+                                if (nanos > 0) {\n+                                    remainingNanos = nanos - (System.nanoTime() - startNanos);\n+                                    if (remainingNanos <= 0) {\n+                                        throw new SocketTimeoutException(\"Receive timed out\");\n+                                    }\n+                                }\n@@ -749,0 +755,1 @@\n+        assert nanos >= 0;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1142,1 +1142,3 @@\n-            NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.math.BigInteger;\n@@ -33,0 +32,1 @@\n+import java.util.Arrays;\n@@ -121,5 +121,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -224,5 +219,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -304,1 +294,1 @@\n-        } catch  (GeneralSecurityException gse) {\n+        } catch (GeneralSecurityException gse) {\n@@ -335,2 +325,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -354,2 +343,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -366,2 +354,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -378,6 +365,2 @@\n-            SessionId newId = new SessionId(true,\n-                hc.sslContext.getSecureRandom());\n-\n-            SecretKey resumptionMasterSecret =\n-                hc.handshakeSession.getResumptionMasterSecret();\n-            if (resumptionMasterSecret == null) {\n+            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n+            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n@@ -385,3 +368,2 @@\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"no resumption secret\");\n+                    SSLLogger.fine(\"No session ticket produced: \" +\n+                            \"session timeout is too long\");\n@@ -393,13 +375,11 @@\n-            \/\/ construct the PSK and handshake message\n-            BigInteger nonce = hc.handshakeSession.incrTicketNonceCounter();\n-            byte[] nonceArr = nonce.toByteArray();\n-            SecretKey psk = derivePreSharedKey(\n-                    hc.negotiatedCipherSuite.hashAlg,\n-                    resumptionMasterSecret, nonceArr);\n-\n-            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n-            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"session timeout\");\n+            \/\/ Send NewSessionTickets to the client based\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                int i = 0;\n+                NewSessionTicketMessage nstm;\n+                while (i < SSLConfiguration.serverNewSessionTicketCount) {\n+                    nstm = generateNST(hc, sessionCache);\n+                    if (nstm == null) {\n+                        break;\n+                    }\n+                    nstm.write(hc.handshakeOutput);\n+                    i++;\n@@ -408,1 +388,28 @@\n-                return null;\n+                hc.handshakeOutput.flush();\n+            }\n+            \/*\n+             * With large NST counts, a client that quickly closes after\n+             * TLS Finished completes can cause SocketExceptions such as:\n+             * Windows servers read-side throwing SocketException:\n+             *   \"An established connection was aborted by the software in\n+             *    your host machine\", which relates to error WSAECONNABORTED.\n+             * A SocketException caused by a \"broken pipe\" has been observed on\n+             * other systems.\n+             * These are very unlikely situations when client and server are on\n+             * different machines.\n+             *\n+             * RFC 8446 does not put requirements when an NST needs to be\n+             * sent, but it should be sent very soon after TLS Finished for\n+             * clients that will quickly resume to create more sessions.\n+             * TLS 1.3 is different from TLS 1.2, there is more data the client\n+             * should be aware of\n+             *\/\n+\n+            \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n+            \/\/\n+            \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n+            \/\/ of this post-handshake message will indicate the FINISHED\n+            \/\/ handshake status.  It is not needed to have a follow-on\n+            \/\/ SSLEngine.wrap() any longer.\n+            if (hc.conContext.needHandshakeFinishedStatus) {\n+                hc.conContext.needHandshakeFinishedStatus = false;\n@@ -411,1 +418,16 @@\n-            NewSessionTicketMessage nstm = null;\n+            \/\/ clean the post handshake context\n+            hc.conContext.finishPostHandshake();\n+\n+            \/\/ The message has been delivered.\n+            return null;\n+        }\n+\n+        private NewSessionTicketMessage generateNST(HandshakeContext hc,\n+            SSLSessionContextImpl sessionCache) throws IOException {\n+\n+            NewSessionTicketMessage nstm;\n+            SessionId newId = new SessionId(true,\n+                hc.sslContext.getSecureRandom());\n+\n+            \/\/ construct the PSK and handshake message\n+            byte[] nonce = hc.handshakeSession.incrTicketNonceCounter();\n@@ -414,2 +436,4 @@\n-                    new SSLSessionImpl(hc.handshakeSession, newId);\n-            sessionCopy.setPreSharedKey(psk);\n+                new SSLSessionImpl(hc.handshakeSession, newId);\n+            sessionCopy.setPreSharedKey(derivePreSharedKey(\n+                hc.negotiatedCipherSuite.hashAlg,\n+                hc.handshakeSession.getResumptionMasterSecret(), nonce));\n@@ -422,1 +446,1 @@\n-                        sessionTimeoutSeconds,\n+                        sessionCache.getSessionTimeout(),\n@@ -424,1 +448,1 @@\n-                        nonceArr,\n+                        nonce,\n@@ -431,2 +455,1 @@\n-                        SSLLogger.fine(\n-                            \"Produced NewSessionTicket stateless \" +\n+                        SSLLogger.fine(\"Produced NewSessionTicket stateless \" +\n@@ -436,0 +459,1 @@\n+                return nstm;\n@@ -441,3 +465,4 @@\n-                nstm = new T13NewSessionTicketMessage(hc, sessionTimeoutSeconds,\n-                        hc.sslContext.getSecureRandom(), nonceArr,\n-                        newId.getId());\n+                nstm = new T13NewSessionTicketMessage(hc,\n+                    sessionCache.getSessionTimeout(),\n+                    hc.sslContext.getSecureRandom(), nonce,\n+                    newId.getId());\n@@ -445,3 +470,2 @@\n-                    SSLLogger.fine(\n-                            \"Produced NewSessionTicket post-handshake message\",\n-                            nstm);\n+                    SSLLogger.fine(\"Produced NewSessionTicket \" +\n+                        \"post-handshake message\", nstm);\n@@ -456,0 +480,1 @@\n+                return nstm;\n@@ -458,15 +483,2 @@\n-            \/\/ Output the handshake message.\n-            if (nstm != null) {\n-                \/\/ should never be null\n-                nstm.write(hc.handshakeOutput);\n-                hc.handshakeOutput.flush();\n-\n-                \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n-                \/\/\n-                \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n-                \/\/ of this post-handshake message will indicate the FINISHED\n-                \/\/ handshake status.  It is not needed to have a follow-on\n-                \/\/ SSLEngine.wrap() any longer.\n-                if (hc.conContext.needHandshakeFinishedStatus) {\n-                    hc.conContext.needHandshakeFinishedStatus = false;\n-                }\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"No NewSessionTicket created\");\n@@ -475,4 +487,0 @@\n-            \/\/ clean the post handshake context\n-            hc.conContext.finishPostHandshake();\n-\n-            \/\/ The message has been delivered.\n@@ -500,2 +508,3 @@\n-            \/\/ Is this session resumable?\n-            if (!shc.handshakeSession.isRejoinable()) {\n+            \/\/ Are new tickets allowed?  If so, is this session resumable?\n+            if (SSLConfiguration.serverNewSessionTicketCount == 0 ||\n+                !shc.handshakeSession.isRejoinable()) {\n@@ -581,1 +590,0 @@\n-                sessionCache.remove(hc.handshakeSession.getSessionId());\n@@ -622,1 +630,6 @@\n-            sessionCache.put(sessionCopy);\n+            sessionCache.put(sessionCopy, sessionCopy.isPSK());\n+\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"MultiNST PSK (Server): \" +\n+                    Utilities.toHexString(Arrays.copyOf(nstm.ticket, 16)));\n+            }\n@@ -629,0 +642,1 @@\n+    \/* TLS 1.2 spec does not specify multiple NST behavior.*\/\n@@ -677,2 +691,1 @@\n-                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" +\n-                        nstm.toString());\n+                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" + nstm);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NewSessionTicket.java","additions":93,"deletions":80,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -702,1 +702,1 @@\n-            sessionCache.remove(chc.resumingSession.getSessionId());\n+            sessionCache.remove(chc.resumingSession.getSessionId(), true);\n@@ -707,0 +707,2 @@\n+                SSLLogger.fine(\n+                    \"MultiNST PSK (Client): \" + Utilities.toHexString(Arrays.copyOf(chc.pskIdentity, 16)));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,0 +124,5 @@\n+    \/\/ Number of NewSessionTickets that will be sent by the server.\n+    static final int serverNewSessionTicketCount;\n+    \/\/ Default for NewSessionTickets\n+    static final int SERVER_NST_DEFAULT = 1;\n+\n@@ -185,1 +190,1 @@\n-                \"jdk.tls.client.maxInboundCertificateChainLength\");\n+            \"jdk.tls.client.maxInboundCertificateChainLength\");\n@@ -194,0 +199,27 @@\n+\n+        \/*\n+         * jdk.tls.server.newSessionTicketCount system property\n+         * Sets the number of NewSessionTickets sent to a TLS 1.3 resumption\n+         * client.  The value must be between 0 and 10.  Default is defined by\n+         * SERVER_NST_DEFAULT.\n+         *\/\n+        Integer nstServerCount = GetIntegerAction.privilegedGetProperty(\n+            \"jdk.tls.server.newSessionTicketCount\");\n+        if (nstServerCount == null || nstServerCount < 0 ||\n+            nstServerCount > 10) {\n+            serverNewSessionTicketCount = SERVER_NST_DEFAULT;\n+            if (nstServerCount != null && SSLLogger.isOn &&\n+                SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount defaults to \" +\n+                        SERVER_NST_DEFAULT + \" as the property was not \" +\n+                        \"between 0 and 10\");\n+            }\n+        } else {\n+            serverNewSessionTicketCount = nstServerCount;\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount set to \" +\n+                        serverNewSessionTicketCount);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -419,5 +419,6 @@\n-        if ((conContext.handshakeContext == null) &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            conContext.handshakeContext == null &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineImpl.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+    private static final int DEFAULT_MAX_QUEUE_SIZE = 10;\n@@ -90,2 +91,0 @@\n-        sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n-        sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -93,0 +92,2 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -95,1 +96,1 @@\n-            \/\/ but doesn't necessarily has to be a true random number.\n+            \/\/ but doesn't necessarily have to be a true random number.\n@@ -98,0 +99,3 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryQueue(cacheLimit, timeout,\n+                DEFAULT_MAX_QUEUE_SIZE);\n@@ -280,0 +284,10 @@\n+        put(s, false);\n+    }\n+\n+    \/**\n+     * Put an entry in the cache\n+     * @param s SSLSessionImpl entry to be stored\n+     * @param canQueue True if multiple entries may exist under one\n+     *                 session entry.\n+     *\/\n+    void put(SSLSessionImpl s, boolean canQueue) {\n@@ -285,1 +299,1 @@\n-                getKey(s.getPeerHost(), s.getPeerPort()), s);\n+                getKey(s.getPeerHost(), s.getPeerPort()), s, canQueue);\n@@ -293,0 +307,3 @@\n+        remove(key, false);\n+    }\n+    void remove(SessionId key, boolean isClient) {\n@@ -296,1 +313,3 @@\n-            sessionHostPortCache.remove(\n+            \/\/ A client keeps the cache entry for queued NST resumption.\n+            if (!isClient) {\n+                sessionHostPortCache.remove(\n@@ -298,0 +317,1 @@\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import java.util.Enumeration;\n@@ -135,1 +134,5 @@\n-    private BigInteger ticketNonceCounter = BigInteger.ONE;\n+    private byte ticketNonceCounter = 1;\n+\n+    \/\/ This boolean is true when a new set of NewSessionTickets are needed after\n+    \/\/ the initial ones sent after the handshake.\n+    boolean updateNST = false;\n@@ -495,1 +498,1 @@\n-                buf.get(b, 0 , i);\n+                buf.get(b, 0, i);\n@@ -504,2 +507,7 @@\n-                this.pskIdentity = new byte[buf.get()];\n-                buf.get(pskIdentity);\n+                i = buf.get();\n+                if (i > 0) {\n+                    this.pskIdentity = new byte[buf.get()];\n+                    buf.get(pskIdentity);\n+                } else {\n+                    this.pskIdentity = null;\n+                }\n@@ -718,4 +726,2 @@\n-    BigInteger incrTicketNonceCounter() {\n-        BigInteger result = ticketNonceCounter;\n-        ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);\n-        return result;\n+    byte[] incrTicketNonceCounter() {\n+        return new byte[] {ticketNonceCounter++};\n@@ -725,1 +731,1 @@\n-        return (ticketNonceCounter.compareTo(BigInteger.ZERO) > 0);\n+        return (ticketNonceCounter > 0);\n@@ -784,0 +790,4 @@\n+    public boolean isPSK() {\n+        return (pskIdentity != null && pskIdentity.length > 0);\n+    }\n+\n@@ -1233,1 +1243,0 @@\n-    boolean updateNST;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1324,1 +1324,0 @@\n-                conContext.conSession.updateNST = false;\n@@ -1559,6 +1558,7 @@\n-        if (!conContext.sslConfig.isClientMode &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                conContext.handshakeContext == null &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            !conContext.sslConfig.isClientMode &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            conContext.handshakeContext == null &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n@@ -1568,0 +1568,1 @@\n+            conContext.conSession.updateNST = false;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import javax.net.ssl.SSLSession;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n@@ -29,1 +32,2 @@\n-import java.lang.ref.*;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -93,0 +97,9 @@\n+    \/**\n+     * Add V to the cache with the option to use a QueueCacheEntry if the\n+     * cache is configured for it.  If the cache is not configured for a queue,\n+     * V will silently add the entry directly.\n+     *\/\n+    public void put(K key, V value, boolean canQueue) {\n+        put(key, value);\n+    }\n+\n@@ -140,0 +153,5 @@\n+    public static <K,V> Cache<K,V> newSoftMemoryQueue(int size, int timeout,\n+        int maxQueueSize) {\n+        return new MemoryCache<>(true, size, timeout, maxQueueSize);\n+    }\n+\n@@ -251,3 +269,1 @@\n-    private static final float LOAD_FACTOR = 0.75f;\n-\n-    \/\/ XXXX\n+    \/\/ Debugging\n@@ -258,0 +274,1 @@\n+    final private int maxQueueSize;\n@@ -266,1 +283,1 @@\n-        this(soft, maxSize, 0);\n+        this(soft, maxSize, 0, 0);\n@@ -270,0 +287,4 @@\n+        this(soft, maxSize, lifetime, 0);\n+    }\n+\n+    public MemoryCache(boolean soft, int maxSize, int lifetime, int qSize) {\n@@ -271,0 +292,1 @@\n+        this.maxQueueSize = qSize;\n@@ -272,1 +294,1 @@\n-        if (soft)\n+        if (soft) {\n@@ -274,1 +296,1 @@\n-        else\n+        } else {\n@@ -276,2 +298,4 @@\n-\n-        cacheMap = new LinkedHashMap<>(1, LOAD_FACTOR, true);\n+        }\n+        \/\/ LinkedHashMap is needed for its access order.  0.75f load factor is\n+        \/\/ default.\n+        cacheMap = new LinkedHashMap<>(1, 0.75f, true);\n@@ -341,0 +365,4 @@\n+                \/\/ If this is a queue, check for some expired entries\n+                if (entry instanceof QueueCacheEntry<K,V> qe) {\n+                    qe.getQueue().removeIf(e -> !e.isValid(time));\n+                }\n@@ -370,1 +398,20 @@\n-    public synchronized void put(K key, V value) {\n+    public void put(K key, V value) {\n+        put(key, value, false);\n+    }\n+\n+    \/**\n+     * This puts an entry into the cacheMap.\n+     *\n+     * If canQueue is true, V will be added using a QueueCacheEntry which\n+     * is added to cacheMap.  If false, V is added to the cacheMap directly.\n+     * The caller must keep a consistent canQueue value, mixing them can\n+     * result in a queue being replaced with a single entry.\n+     *\n+     * This method is synchronized to avoid multiple QueueCacheEntry\n+     * overwriting the same key.\n+     *\n+     * @param key key to the cacheMap\n+     * @param value value to be stored\n+     * @param canQueue can the value be put into a QueueCacheEntry\n+     *\/\n+    public synchronized void put(K key, V value, boolean canQueue) {\n@@ -372,2 +419,2 @@\n-        long expirationTime = (lifetime == 0) ? 0 :\n-                                        System.currentTimeMillis() + lifetime;\n+        long expirationTime =\n+            (lifetime == 0) ? 0 : System.currentTimeMillis() + lifetime;\n@@ -378,4 +425,27 @@\n-        CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n-        if (oldEntry != null) {\n-            oldEntry.invalidate();\n-            return;\n+        if (maxQueueSize == 0 || !canQueue) {\n+            CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n+            if (oldEntry != null) {\n+                oldEntry.invalidate();\n+            }\n+        } else {\n+            CacheEntry<K, V> entry = cacheMap.get(key);\n+            switch (entry) {\n+                case QueueCacheEntry<K, V> qe -> {\n+                    qe.putValue(newEntry);\n+                    if (DEBUG) {\n+                        System.out.println(\"QueueCacheEntry= \" + qe);\n+                        final AtomicInteger i = new AtomicInteger(1);\n+                        qe.queue.stream().forEach(e ->\n+                            System.out.println(i.getAndIncrement() + \"= \" + e));\n+                    }\n+                }\n+                case null, default ->\n+                    cacheMap.put(key, new QueueCacheEntry<>(key, newEntry,\n+                        expirationTime, maxQueueSize));\n+            }\n+\n+            if (DEBUG) {\n+                System.out.println(\"Cache entry added: key=\" +\n+                    key.toString() + \", class=\" +\n+                    (entry != null ? entry.getClass().getName() : null));\n+            }\n@@ -404,2 +474,3 @@\n-        long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n-        if (!entry.isValid(time)) {\n+\n+        if (lifetime > 0 && !entry.isValid(System.currentTimeMillis())) {\n+            cacheMap.remove(key);\n@@ -409,1 +480,0 @@\n-            cacheMap.remove(key);\n@@ -412,0 +482,9 @@\n+\n+        \/\/ If the value is a queue, return a queue entry.\n+        if (entry instanceof QueueCacheEntry<K, V> qe) {\n+            V result = qe.getValue(lifetime);\n+            if (qe.isEmpty()) {\n+                removeImpl(key);\n+            }\n+            return result;\n+        }\n@@ -417,0 +496,4 @@\n+        removeImpl(key);\n+    }\n+\n+    private void removeImpl(Object key) {\n@@ -422,1 +505,0 @@\n-\n@@ -553,3 +635,2 @@\n-    private static class SoftCacheEntry<K,V>\n-            extends SoftReference<V>\n-            implements CacheEntry<K,V> {\n+    private static class SoftCacheEntry<K,V> extends SoftReference<V>\n+        implements CacheEntry<K,V> {\n@@ -592,0 +673,7 @@\n+\n+        @Override\n+        public String toString() {\n+            if (get() instanceof SSLSession se)\n+                return HexFormat.of().formatHex(se.getId());\n+            return super.toString();\n+        }\n@@ -594,1 +682,104 @@\n-}\n+    \/**\n+     * This CacheEntry<K,V> type allows multiple V entries to be stored in\n+     * one key in the cacheMap.\n+     *\n+     * This implementation is need for TLS clients that receive multiple\n+     * PSKs or NewSessionTickets for server resumption.\n+     *\/\n+    private static class QueueCacheEntry<K,V> implements CacheEntry<K,V> {\n+\n+        \/\/ Limit the number of queue entries.\n+        private final int MAXQUEUESIZE;\n+\n+        final boolean DEBUG = false;\n+        private K key;\n+        private long expirationTime;\n+        final Queue<CacheEntry<K,V>> queue = new ConcurrentLinkedQueue<>();\n+\n+        QueueCacheEntry(K key, CacheEntry<K,V> entry, long expirationTime,\n+            int maxSize) {\n+            this.key = key;\n+            this.expirationTime = expirationTime;\n+            this.MAXQUEUESIZE = maxSize;\n+            queue.add(entry);\n+        }\n+\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        public V getValue() {\n+            return getValue(0);\n+        }\n+\n+        public V getValue(long lifetime) {\n+            long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n+            do {\n+                var entry = queue.poll();\n+                if (entry == null) {\n+                    return null;\n+                }\n+                if (entry.isValid(time)) {\n+                    return entry.getValue();\n+                }\n+                entry.invalidate();\n+            } while (!queue.isEmpty());\n+\n+            return null;\n+        }\n+\n+        public long getExpirationTime() {\n+            return expirationTime;\n+        }\n+\n+        public void setExpirationTime(long time) {\n+            expirationTime = time;\n+        }\n+\n+        public void putValue(CacheEntry<K,V> entry) {\n+            if (DEBUG) {\n+                System.out.println(\"Added to queue (size=\" + queue.size() +\n+                    \"): \" + entry.getKey().toString() + \",  \" + entry);\n+            }\n+            \/\/ Update the cache entry's expiration time to the latest entry.\n+            \/\/ The getValue() calls will remove expired tickets.\n+            expirationTime = entry.getExpirationTime();\n+            \/\/ Limit the number of queue entries, removing the oldest.\n+            if (queue.size() >= MAXQUEUESIZE) {\n+                queue.remove();\n+            }\n+            queue.add(entry);\n+        }\n+\n+        public boolean isValid(long currentTime) {\n+            boolean valid = (currentTime <= expirationTime) && !queue.isEmpty();\n+            if (!valid) {\n+                invalidate();\n+            }\n+            return valid;\n+        }\n+\n+        public boolean isValid() {\n+            return isValid(System.currentTimeMillis());\n+        }\n+\n+        public void invalidate() {\n+            clear();\n+            key = null;\n+            expirationTime = -1;\n+        }\n+\n+        public void clear() {\n+            queue.forEach(CacheEntry::invalidate);\n+            queue.clear();\n+        }\n+\n+        public boolean isEmpty() {\n+            return queue.isEmpty();\n+        }\n+\n+        public Queue<CacheEntry<K,V>> getQueue() {\n+            return queue;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Cache.java","additions":216,"deletions":25,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.function.UnaryOperator;\n@@ -94,4 +93,0 @@\n-    \/\/ Interned BaseLocale cache\n-    private static final ReferencedKeySet<BaseLocale> CACHE =\n-            ReferencedKeySet.create(true, ReferencedKeySet.concurrentHashMapSupplier());\n-\n@@ -166,13 +161,3 @@\n-        return CACHE.intern(new BaseLocale(language, script, region, variant),\n-                \/\/ Avoid lambdas since this may be on the bootstrap path in many locales\n-                INTERNER);\n-    }\n-\n-    public static final UnaryOperator<BaseLocale> INTERNER = new UnaryOperator<>() {\n-        @Override\n-        public BaseLocale apply(BaseLocale b) {\n-            return new BaseLocale(\n-                    LocaleUtils.toLowerString(b.language).intern(),\n-                    LocaleUtils.toTitleString(b.script).intern(),\n-                    LocaleUtils.toUpperString(b.region).intern(),\n-                    b.variant.intern());\n+        class InterningCache { \/\/ TODO: StableValue\n+            private static final ReferencedKeySet<BaseLocale> CACHE =\n+                    ReferencedKeySet.create(true, ReferencedKeySet.concurrentHashMapSupplier());\n@@ -180,1 +165,6 @@\n-    };\n+        return InterningCache.CACHE.intern(new BaseLocale(\n+                language.intern(), \/\/ guaranteed to be lower-case\n+                LocaleUtils.toTitleString(script).intern(),\n+                region.intern(), \/\/ guaranteed to be upper-case\n+                variant.intern()));\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -555,8 +555,32 @@\n-Methods that provide native access are restricted, and by default their\n-use causes warnings.\n-This option allows code in the specified modules to use restricted\n-methods without warnings.\n-\\f[I]module\\f[R] can be \\f[V]ALL-UNNAMED\\f[R] to indicate code on the\n-class path.\n-When this option is present, any use of restricted methods by code\n-outside the specified modules causes an\n+Native access can occur as a result of calling a method that is either\n+\\f[B]restricted\\f[R] [https:\/\/openjdk.org\/jeps\/454#Safety], or\n+\\f[V]native\\f[R].\n+This option allows code in the specified modules to perform native\n+access.\n+Native access occurring in a module that has not been explicitly enabled\n+is deemed \\f[I]illegal\\f[R].\n+.RS\n+.PP\n+\\f[I]module\\f[R] can be a module name, or \\f[V]ALL-UNNAMED\\f[R] to\n+indicate code on the class path.\n+.RE\n+.TP\n+-\\f[V]--illegal-native-access=\\f[R]\\f[I]parameter\\f[R]\n+This option specifies a mode for how illegal native access is handled:\n+.RS\n+.RS\n+.PP\n+\\f[B]Note:\\f[R] This option will be removed in a future release.\n+.RE\n+.IP \\[bu] 2\n+\\f[V]allow\\f[R]: This mode allows illegal native access in all modules,\n+without any warings.\n+.IP \\[bu] 2\n+\\f[V]warn\\f[R]: This mode is identical to \\f[V]allow\\f[R] except that a\n+warning message is issued for the first illegal native access found in a\n+module.\n+This mode is the default for the current JDK but will change in a future\n+release.\n+.IP \\[bu] 2\n+\\f[V]deny\\f[R]: This mode disables illegal native access.\n+That is, any illegal native access causes an\n@@ -564,0 +588,6 @@\n+This mode will become the default in a future release.\n+.PP\n+To verify that your application is ready for a future version of the\n+JDK, run it with \\f[V]--illegal-native-access=deny\\f[R] along with any\n+necessary \\f[V]--enable-native-access\\f[R] options.\n+.RE\n","filename":"src\/java.base\/share\/man\/java.1","additions":38,"deletions":8,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-    outputConsumedID = (*env)->GetFieldID(env, cls, \"outputConsumed\", \"I\");\n@@ -54,0 +53,1 @@\n+    outputConsumedID = (*env)->GetFieldID(env, cls, \"outputConsumed\", \"I\");\n","filename":"src\/java.base\/share\/native\/libzip\/Inflater.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-    private long st_dev;    \/\/ ID of device\n-    private long st_ino;    \/\/ Inode number\n+    private final long st_dev;    \/\/ ID of device\n+    private final long st_ino;    \/\/ Inode number\n@@ -39,1 +39,4 @@\n-    private FileKey() { }\n+    private FileKey(long st_dev, long st_ino) {\n+        this.st_dev = st_dev;\n+        this.st_ino = st_ino;\n+    }\n@@ -42,3 +45,3 @@\n-        FileKey fk = new FileKey();\n-        fk.init(fd);\n-        return fk;\n+        long finfo[] = new long[2];\n+        init(fd, finfo);\n+        return new FileKey(finfo[0], finfo[1]);\n@@ -62,2 +65,2 @@\n-    private native void init(FileDescriptor fd) throws IOException;\n-    private static native void initIDs();\n+    private static native void init(FileDescriptor fd, long[] finfo)\n+        throws IOException;\n@@ -66,1 +69,1 @@\n-        initIDs();\n+        IOUtil.load();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileKey.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -33,12 +33,0 @@\n-static jfieldID key_st_dev;    \/* id for FileKey.st_dev *\/\n-static jfieldID key_st_ino;    \/* id for FileKey.st_ino *\/\n-\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileKey_initIDs(JNIEnv *env, jclass clazz)\n-{\n-    CHECK_NULL(key_st_dev = (*env)->GetFieldID(env, clazz, \"st_dev\", \"J\"));\n-    CHECK_NULL(key_st_ino = (*env)->GetFieldID(env, clazz, \"st_ino\", \"J\"));\n-}\n-\n-\n@@ -46,1 +34,2 @@\n-Java_sun_nio_ch_FileKey_init(JNIEnv *env, jobject this, jobject fdo)\n+Java_sun_nio_ch_FileKey_init(JNIEnv* env, jclass clazz, jobject fdo,\n+    jlongArray finfo)\n@@ -50,0 +39,1 @@\n+    jlong deviceAndInode[2];\n@@ -51,1 +41,2 @@\n-    RESTARTABLE(fstat(fdval(env, fdo), &fbuf), res);\n+    int fd = fdval(env, fdo);\n+    RESTARTABLE(fstat(fd, &fbuf), res);\n@@ -55,2 +46,3 @@\n-        (*env)->SetLongField(env, this, key_st_dev, (jlong)fbuf.st_dev);\n-        (*env)->SetLongField(env, this, key_st_ino, (jlong)fbuf.st_ino);\n+        deviceAndInode[0] = (jlong)fbuf.st_dev;\n+        deviceAndInode[1] = (jlong)fbuf.st_ino;\n+        (*env)->SetLongArrayRegion(env, finfo, 0, 2, deviceAndInode);\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileKey.c","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -136,3 +136,4 @@\n-#ifndef STATX_ALL\n-#define STATX_ALL (STATX_BTIME | STATX_BASIC_STATS)\n-#endif\n+\/\/\n+\/\/ STATX_ALL is deprecated; use a different name to avoid confusion.\n+\/\/\n+#define LOCAL_STATX_ALL (STATX_BASIC_STATS | STATX_BTIME)\n@@ -257,0 +258,17 @@\n+#if defined(__linux__) && defined(__arm__)\n+\/**\n+ * Lookup functions with time_t parameter. Try to use 64 bit symbol\n+ * if sizeof(time_t) exceeds 32 bit.\n+ *\/\n+static void* lookup_time_t_function(const char* symbol, const char* symbol64) {\n+    void *func_ptr = NULL;\n+    if (sizeof(time_t) > 4) {\n+        func_ptr = dlsym(RTLD_DEFAULT, symbol64);\n+    }\n+    if (func_ptr == NULL) {\n+        return dlsym(RTLD_DEFAULT, symbol);\n+    }\n+    return func_ptr;\n+}\n+#endif\n+\n@@ -354,0 +372,8 @@\n+#if defined(__linux__) && defined(__arm__)\n+    my_futimesat_func = (futimesat_func*) lookup_time_t_function(\"futimesat\",\n+        \"__futimesat64\");\n+    my_lutimes_func = (lutimes_func*) lookup_time_t_function(\"lutimes\",\n+        \"__lutimes64\");\n+    my_futimens_func = (futimens_func*) lookup_time_t_function(\"futimens\",\n+        \"__futimens64\");\n+#else\n@@ -359,0 +385,1 @@\n+#endif\n@@ -596,2 +623,13 @@\n-    (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec, (jlong)buf->stx_btime.tv_sec);\n-    (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec, (jlong)buf->stx_btime.tv_nsec);\n+    if ((buf->stx_mask & STATX_BTIME) != 0) {\n+        \/\/  Birth time was filled in so use it\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec,\n+                             (jlong)buf->stx_btime.tv_sec);\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec,\n+                             (jlong)buf->stx_btime.tv_nsec);\n+    } else {\n+        \/\/  Birth time was not filled in: fall back to last modification time\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec,\n+                             (jlong)buf->stx_mtime.tv_sec);\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec,\n+                             (jlong)buf->stx_mtime.tv_nsec);\n+    }\n@@ -651,1 +689,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n@@ -683,1 +721,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n@@ -714,1 +752,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n@@ -747,1 +785,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":47,"deletions":9,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -36,3 +36,3 @@\n-    private int dwVolumeSerialNumber;\n-    private int nFileIndexHigh;\n-    private int nFileIndexLow;\n+    private final int dwVolumeSerialNumber;\n+    private final int nFileIndexHigh;\n+    private final int nFileIndexLow;\n@@ -40,1 +40,6 @@\n-    private FileKey() { }\n+    private FileKey(int dwVolumeSerialNumber, int nFileIndexHigh,\n+        int nFileIndexLow) {\n+        this.dwVolumeSerialNumber = dwVolumeSerialNumber;\n+        this.nFileIndexHigh = nFileIndexHigh;\n+        this.nFileIndexLow = nFileIndexLow;\n+    }\n@@ -43,3 +48,3 @@\n-        FileKey fk = new FileKey();\n-        fk.init(fd);\n-        return fk;\n+        int finfo[] = new int[3];\n+        init(fd, finfo);\n+        return new FileKey(finfo[0], finfo[1], finfo[2]);\n@@ -63,2 +68,2 @@\n-    private native void init(FileDescriptor fd) throws IOException;\n-    private static native void initIDs();\n+    private static native void init(FileDescriptor fd, int[] finfo)\n+        throws IOException;\n@@ -68,1 +73,0 @@\n-        initIDs();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/FileKey.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -331,1 +331,1 @@\n-        _snprintf(cptr, MAX_PATH, \"\\\"%s\\\" %s\", argv[0], cmdline);\n+        snprintf(cptr, MAX_PATH, \"\\\"%s\\\" %s\", argv[0], cmdline);\n","filename":"src\/java.base\/windows\/native\/libjli\/cmdtoargs.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,14 +33,0 @@\n-static jfieldID key_volumeSN;    \/* id for FileKey.dwVolumeSerialNumber *\/\n-static jfieldID key_indexHigh;   \/* id for FileKey.nFileIndexHigh *\/\n-static jfieldID key_indexLow;    \/* id for FileKey.nFileIndexLow *\/\n-\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileKey_initIDs(JNIEnv *env, jclass clazz)\n-{\n-    CHECK_NULL(key_volumeSN = (*env)->GetFieldID(env, clazz, \"dwVolumeSerialNumber\", \"I\"));\n-    CHECK_NULL(key_indexHigh = (*env)->GetFieldID(env, clazz, \"nFileIndexHigh\", \"I\"));\n-    CHECK_NULL(key_indexLow = (*env)->GetFieldID(env, clazz, \"nFileIndexLow\", \"I\"));\n-}\n-\n-\n@@ -48,1 +34,1 @@\n-Java_sun_nio_ch_FileKey_init(JNIEnv *env, jobject this, jobject fdo)\n+Java_sun_nio_ch_FileKey_init(JNIEnv *env, jclass clazz, jobject fdo, jintArray finfo)\n@@ -50,1 +36,1 @@\n-    HANDLE fileHandle = (HANDLE)(handleval(env, fdo));\n+    HANDLE fileHandle = (HANDLE)handleval(env, fdo);\n@@ -53,0 +39,1 @@\n+    jint info[3];\n@@ -56,3 +43,4 @@\n-        (*env)->SetIntField(env, this, key_volumeSN, fileInfo.dwVolumeSerialNumber);\n-        (*env)->SetIntField(env, this, key_indexHigh, fileInfo.nFileIndexHigh);\n-        (*env)->SetIntField(env, this, key_indexLow, fileInfo.nFileIndexLow);\n+        info[0] = (jint)fileInfo.dwVolumeSerialNumber;\n+        info[1] = (jint)fileInfo.nFileIndexHigh;\n+        info[2] = (jint)fileInfo.nFileIndexLow;\n+        (*env)->SetIntArrayRegion(env, finfo, 0, 3, info);\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileKey.c","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import javax.tools.JavaFileManager;\n@@ -31,1 +30,0 @@\n-import javax.lang.model.element.TypeElement;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Filer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-import java.util.Collections;\n-import java.util.Set;\n-import java.util.HashSet;\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-import java.lang.annotation.AnnotationTypeMismatchException;\n-import java.lang.annotation.IncompleteAnnotationException;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Element.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/VariableElement.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-import javax.lang.model.util.Types;\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/TypeVariable.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import javax.lang.model.element.*;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/TypeVisitor.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractAnnotationValueVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,3 +32,0 @@\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.ElementVisitor;\n-import javax.lang.model.element.RecordComponentElement;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractElementVisitorPreview.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import javax.lang.model.type.*;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitor9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner14.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner7.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.util.List;\n-import java.util.ArrayList;\n@@ -35,2 +33,0 @@\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScannerPreview.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleAnnotationValueVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor7.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,3 +32,0 @@\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.ElementVisitor;\n-import javax.lang.model.element.RecordComponentElement;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitorPreview.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import javax.lang.model.type.TypeVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.type.TypeVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor7.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import javax.lang.model.type.IntersectionType;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/TypeKindVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.lang.annotation.Annotation;\n-import java.lang.annotation.AnnotationTypeMismatchException;\n-import java.lang.annotation.IncompleteAnnotationException;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Types.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,2 +64,0 @@\n-    private static final Object FLAVOR_MAP_KEY = new Object();\n-\n","filename":"src\/java.datatransfer\/share\/classes\/java\/awt\/datatransfer\/SystemFlavorMap.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/eio\/FileManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaFileView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -391,1 +391,3 @@\n-            \"ctrl shift DOWN\", \"selectLastRowExtendSelection\"\n+            \"ctrl shift DOWN\", \"selectLastRowExtendSelection\",\n+            \"ctrl shift RIGHT\", \"selectLastColumnExtendSelection\",\n+            \"ctrl shift LEFT\", \"selectFirstColumnExtendSelection\"\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaKeyBindings.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaLookAndFeel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaMenuBarUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaNativeResources.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,24 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.beans.*;\n-import java.util.*;\n-\n-import javax.swing.*;\n+import java.awt.Adjustable;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseMotionListener;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.BoundedRangeModel;\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.JScrollBar;\n+import javax.swing.LookAndFeel;\n@@ -35,5 +53,13 @@\n-import javax.swing.event.*;\n-import javax.swing.plaf.*;\n-\n-import apple.laf.*;\n-import apple.laf.JRSUIConstants.*;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.ScrollBarUI;\n+\n+import apple.laf.JRSUIStateFactory;\n+import apple.laf.JRSUIConstants.Hit;\n+import apple.laf.JRSUIConstants.NothingToScroll;\n+import apple.laf.JRSUIConstants.Orientation;\n+import apple.laf.JRSUIConstants.ScrollBarHit;\n+import apple.laf.JRSUIConstants.ScrollBarPart;\n+import apple.laf.JRSUIConstants.ShowArrows;\n+import apple.laf.JRSUIConstants.State;\n@@ -41,0 +67,1 @@\n+import apple.laf.JRSUIUtils;\n@@ -530,0 +557,15 @@\n+            Component parent = fScrollBar.getParent();\n+            do {\n+                if (parent instanceof JFrame par) {\n+                    if (!par.isEnabled()) {\n+                        ((Timer)e.getSource()).stop();\n+                        fScrollBar.setValueIsAdjusting(false);\n+                        return;\n+                    }\n+                    break;\n+                } else {\n+                    if (parent != null) {\n+                        parent = parent.getParent();\n+                    }\n+                }\n+            } while (parent != null);\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaScrollBarUI.java","additions":54,"deletions":12,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/ScreenMenu.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/awt\/PlatformGraphicsInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CAccessibility.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/LWCToolkit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGImageReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGImageWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1061,1 +1061,1 @@\n-                     \"ctrl shift RIGHT\", \"selectNextColumnExtendSelection\",\n+                     \"ctrl shift RIGHT\", \"selectLastColumnExtendSelection\",\n@@ -1069,1 +1069,1 @@\n-                      \"ctrl shift LEFT\", \"selectPreviousColumnExtendSelection\",\n+                      \"ctrl shift LEFT\", \"selectFirstColumnExtendSelection\",\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKLookAndFeel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/Platform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/SplashScreen.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1378,1 +1378,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Toolkit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/event\/NativeLibLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/ColorModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import javax.swing.event.*;\n+import javax.swing.event.ChangeListener;\n@@ -43,1 +43,1 @@\n- * must greater than or equal to <code>minimum<\/code>, and <code>maximum<\/code>\n+ * must be greater than or equal to <code>minimum<\/code>, and <code>maximum<\/code>\n@@ -231,1 +231,1 @@\n-     * This method sets all of the model's data with a single method call.\n+     * This method sets all the model's data with a single method call.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/BoundedRangeModel.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -730,0 +730,2 @@\n+            \/\/ The above margin has vastly larger horizontal values when\n+            \/\/ compared to other look and feels that don't rely on these values\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicLookAndFeel.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import javax.swing.JFrame;\n@@ -1611,0 +1612,19 @@\n+            \/\/ If frame is disabled and timer is started in mousePressed\n+            \/\/ and mouseReleased is not called, then timer will not be stopped\n+            \/\/ Stop the timer if frame is disabled\n+            Component parent = scrollbar.getParent();\n+            do {\n+                if (parent instanceof JFrame par) {\n+                    if (!par.isEnabled()) {\n+                        ((Timer)e.getSource()).stop();\n+                        buttonListener.handledEvent = false;\n+                        scrollbar.setValueIsAdjusting(false);\n+                        return;\n+                    }\n+                    break;\n+                } else {\n+                    if (parent != null) {\n+                        parent = parent.getParent();\n+                    }\n+                }\n+            } while (parent != null);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicScrollBarUI.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -397,1 +397,4 @@\n-     * divider is contained in changes. Will create the\n+     * divider is contained in changes.\n+     * If a particular L&amp;F supports this Swing\n+     * \"SplitPane.supportsOneTouchButtons\" property\n+     * it will create the\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSplitPaneDivider.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,7 @@\n-import java.awt.*;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Frame;\n+import java.awt.Insets;\n+import java.awt.Toolkit;\n+import java.awt.Window;\n@@ -31,6 +37,0 @@\n-import javax.swing.plaf.*;\n-import javax.swing.*;\n-import javax.swing.plaf.basic.*;\n-import javax.swing.text.DefaultEditorKit;\n-\n-import java.awt.Color;\n@@ -39,1 +39,0 @@\n-\n@@ -42,1 +41,27 @@\n-import sun.awt.*;\n+import javax.swing.ButtonModel;\n+import javax.swing.DefaultButtonModel;\n+import javax.swing.Icon;\n+import javax.swing.ImageIcon;\n+import javax.swing.JComponent;\n+import javax.swing.JDialog;\n+import javax.swing.JFrame;\n+import javax.swing.JRootPane;\n+import javax.swing.JTextField;\n+import javax.swing.JToggleButton;\n+import javax.swing.LayoutStyle;\n+import javax.swing.LookAndFeel;\n+import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.plaf.BorderUIResource;\n+import javax.swing.plaf.ColorUIResource;\n+import javax.swing.plaf.FontUIResource;\n+import javax.swing.plaf.InsetsUIResource;\n+import javax.swing.plaf.UIResource;\n+import javax.swing.plaf.basic.BasicLookAndFeel;\n+import javax.swing.text.DefaultEditorKit;\n+\n+import sun.awt.AppContext;\n+import sun.awt.OSInfo;\n+import sun.awt.SunToolkit;\n@@ -45,2 +70,0 @@\n-import static javax.swing.UIDefaults.LazyValue;\n-\n@@ -50,0 +73,2 @@\n+import static javax.swing.UIDefaults.LazyValue;\n+\n@@ -785,0 +810,2 @@\n+            \/\/ Button default margin is (2, 14, 2, 14), defined in\n+            \/\/ BasicLookAndFeel via \"Button.margin\" UI property.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalLookAndFeel.java","additions":39,"deletions":12,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/NativeLibLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/ImagingLib.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/JPEGImageDecoder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/NativeLibLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontManagerNativeLibrary.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/Disposer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMS.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,5 +29,0 @@\n-#ifdef _MSC_VER\n-# ifndef snprintf\n-#       define snprintf _snprintf\n-# endif\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/splashscreen_impl.c","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/CUPSPrinter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/PlatformGraphicsInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WToolkit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/windows\/classes\/sun\/print\/PrintServiceLookupProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-    _snprintf(assertMsg, ASSERT_MSG_SIZE, AssertFmt, expr, file, line, lastError, msgBuffer);\n+    snprintf(assertMsg, ASSERT_MSG_SIZE, AssertFmt, expr, file, line, lastError, msgBuffer);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Debug.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/java.instrument\/share\/classes\/sun\/instrument\/InstrumentationImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1023,1 +1023,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/ManagementFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n@@ -456,0 +458,7 @@\n+\n+        long responseTimeoutMillis = 5000;\n+        if (request.timeout().isPresent()) {\n+            final long timeoutMillis = request.timeout().get().toMillis();\n+            responseTimeoutMillis = Math.min(responseTimeoutMillis, timeoutMillis);\n+        }\n+\n@@ -457,0 +466,1 @@\n+                .completeOnTimeout(null, responseTimeoutMillis, TimeUnit.MILLISECONDS)\n@@ -458,24 +468,39 @@\n-            Log.logResponse(r1::toString);\n-            int rcode = r1.statusCode();\n-            if (rcode == 100) {\n-                Log.logTrace(\"Received 100-Continue: sending body\");\n-                if (debug.on()) debug.log(\"Received 100-Continue for %s\", r1);\n-                CompletableFuture<Response> cf =\n-                        exchImpl.sendBodyAsync()\n-                                .thenCompose(exIm -> exIm.getResponseAsync(parentExecutor));\n-                cf = wrapForUpgrade(cf);\n-                cf = wrapForLog(cf);\n-                return cf;\n-            } else {\n-                Log.logTrace(\"Expectation failed: Received {0}\",\n-                        rcode);\n-                if (debug.on()) debug.log(\"Expect-Continue failed (%d) for: %s\", rcode, r1);\n-                if (upgrading && rcode == 101) {\n-                    IOException failed = new IOException(\n-                            \"Unable to handle 101 while waiting for 100\");\n-                    return MinimalFuture.failedFuture(failed);\n-                }\n-                exchImpl.expectContinueFailed(rcode);\n-                return MinimalFuture.completedFuture(r1);\n-            }\n-        });\n+                    \/\/ The response will only be null if there was a timeout\n+                    \/\/ send body regardless\n+                    if (r1 == null) {\n+                        if (debug.on())\n+                            debug.log(\"Setting ExpectTimeoutRaised and sending request body\");\n+                        exchImpl.setExpectTimeoutRaised();\n+                        CompletableFuture<Response> cf =\n+                                exchImpl.sendBodyAsync()\n+                                        .thenCompose(exIm -> exIm.getResponseAsync(parentExecutor));\n+                        cf = wrapForUpgrade(cf);\n+                        cf = wrapForLog(cf);\n+                        return cf;\n+                    }\n+\n+                    Log.logResponse(r1::toString);\n+                    int rcode = r1.statusCode();\n+                    if (rcode == 100) {\n+                        Log.logTrace(\"Received 100-Continue: sending body\");\n+                        if (debug.on())\n+                            debug.log(\"Received 100-Continue for %s\", r1);\n+                        CompletableFuture<Response> cf =\n+                                exchImpl.sendBodyAsync()\n+                                        .thenCompose(exIm -> exIm.getResponseAsync(parentExecutor));\n+                        cf = wrapForUpgrade(cf);\n+                        cf = wrapForLog(cf);\n+                        return cf;\n+                    } else {\n+                        Log.logTrace(\"Expectation failed: Received {0}\", rcode);\n+                        if (debug.on())\n+                            debug.log(\"Expect-Continue failed (%d) for: %s\", rcode, r1);\n+                        if (upgrading && rcode == 101) {\n+                            IOException failed = new IOException(\n+                                    \"Unable to handle 101 while waiting for 100\");\n+                            return MinimalFuture.failedFuture(failed);\n+                        }\n+                        exchImpl.expectContinueFailed(rcode);\n+                        return MinimalFuture.completedFuture(r1);\n+                    }\n+                });\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":50,"deletions":25,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+    private volatile boolean expectTimeoutRaised;\n+\n@@ -74,0 +76,8 @@\n+    final void setExpectTimeoutRaised() {\n+        expectTimeoutRaised = true;\n+    }\n+\n+    final boolean expectTimeoutRaised() {\n+        return expectTimeoutRaised;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1203,2 +1203,7 @@\n-                \/\/ it will be already completed.\n-                cf = response_cfs.remove(0);\n+                \/\/ it will be already completed, unless the expect continue\n+                \/\/ timeout fired\n+                cf = response_cfs.get(0);\n+                if (cf.isDone()) {\n+                    cf = response_cfs.remove(0);\n+                }\n+\n@@ -1207,1 +1212,2 @@\n-                assert cf.isDone() : \"Removing uncompleted response: could cause code to hang!\";\n+                assert cf.isDone() || request.expectContinue && expectTimeoutRaised()\n+                        : \"Removing uncompleted response: could cause code to hang!\";\n@@ -1242,1 +1248,1 @@\n-                if (!cf.isDone()) {\n+                if (!cf.isDone() && !expectTimeoutRaised()) {\n@@ -1250,0 +1256,8 @@\n+                } else if (expectTimeoutRaised()) {\n+                    Log.logTrace(\"Completing response (streamid={0}): {1}\",\n+                            streamid, cf);\n+                    if (debug.on())\n+                        debug.log(\"Completing responseCF(%d) with response headers\", i);\n+                    \/\/ The Request will be removed in getResponseAsync()\n+                    cf.complete(resp);\n+                    return;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.prefs\/macosx\/classes\/java\/util\/prefs\/MacOSXPreferencesFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.prefs\/unix\/classes\/java\/util\/prefs\/FileSystemPreferences.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.prefs\/windows\/classes\/java\/util\/prefs\/WindowsPreferences.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/GC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/wrapper\/SunNativeProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -527,1 +527,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/Credentials.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/SCDynamicStoreConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.smartcardio\/unix\/classes\/sun\/security\/smartcardio\/PlatformPCSC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.smartcardio\/windows\/classes\/sun\/security\/smartcardio\/PlatformPCSC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.accessibility\/windows\/classes\/com\/sun\/java\/accessibility\/internal\/AccessBridge.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1529,2 +1529,2 @@\n-        ::_snprintf(text, sizeof(text), \"%d of %d\", (int)messageNumber,\n-                                                    (int) messageCount);\n+        ::snprintf(text, sizeof(text), \"%d of %d\", (int)messageNumber,\n+                                                   (int) messageCount);\n","filename":"src\/jdk.accessibility\/windows\/native\/jaccessinspector\/jaccessinspector.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/aix\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/macosx\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/AttachProviderImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2341,1 +2341,1 @@\n-        private ErrorType(Type originalType, TypeSymbol tsym,\n+        public ErrorType(Type originalType, TypeSymbol tsym,\n@@ -2396,4 +2396,0 @@\n-        public List<Type> allparams()            { return List.nil(); }\n-        @DefinedBy(Api.LANGUAGE_MODEL)\n-        public List<Type> getTypeArguments()     { return List.nil(); }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5084,0 +5084,8 @@\n+        } else if (clazztype.hasTag(ERROR)) {\n+            ErrorType parameterizedErroneous =\n+                    new ErrorType(clazztype.getOriginalType(),\n+                                  clazztype.tsym,\n+                                  clazztype.getMetadata());\n+\n+            parameterizedErroneous.typarams_field = actuals;\n+            owntype = parameterizedErroneous;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import com.sun.tools.javac.parser.VirtualParser.VirtualScanner;\n@@ -5022,0 +5023,1 @@\n+            boolean unclosedParameterList;\n@@ -5024,0 +5026,1 @@\n+                unclosedParameterList = token.pos == endPosTable.errorEndPos;\n@@ -5029,0 +5032,2 @@\n+            } else {\n+                unclosedParameterList = false;\n@@ -5042,0 +5047,1 @@\n+                    accept(SEMI);\n@@ -5044,0 +5050,1 @@\n+                    accept(SEMI, tk -> Errors.Expected2(LBRACE, SEMI));\n@@ -5045,1 +5052,0 @@\n-                accept(SEMI);\n@@ -5048,2 +5054,5 @@\n-                    skip(false, true, false, false);\n-                    if (token.kind == LBRACE) {\n+                    \/\/ look if there is a probable missing opening brace,\n+                    \/\/ and if yes, parse as a block\n+                    boolean parseAsBlock = openingBraceMissing(unclosedParameterList);\n+\n+                    if (parseAsBlock) {\n@@ -5066,0 +5075,78 @@\n+    \/**\n+     * After seeing a method header, and not seeing an opening left brace,\n+     * attempt to estimate if acting as if the left brace was present and\n+     * parsing the upcoming code will get better results than not parsing\n+     * the code as a block.\n+     *\n+     * The estimate is as follows:\n+     * - tokens are skipped until member, statement or identifier is found,\n+     * - then, if there is a left brace, parse as a block,\n+     * - otherwise, if the head was broken, do not parse as a block,\n+     * - otherwise, look at the next token and:\n+     *   - if it definitelly starts a statement, parse as a block,\n+     *   - otherwise, if it is a closing\/right brace, count opening and closing\n+     *     braces in the rest of the file, to see if imaginarily \"adding\" an opening\n+     *     brace would lead to a balanced count - if yes, parse as a block,\n+     *   - otherwise, speculatively parse the following code as a block, and if\n+     *     it contains statements that cannot be members, parse as a block,\n+     *   - otherwise, don't parse as a block.\n+     *\n+     * @param unclosedParameterList whether there was a serious problem in the\n+     *                              parameters list\n+     * @return true if and only if the following code should be parsed as a block.\n+     *\/\n+    private boolean openingBraceMissing(boolean unclosedParameterList) {\n+        skip(false, true, !unclosedParameterList, !unclosedParameterList);\n+\n+        if (token.kind == LBRACE) {\n+            return true;\n+        } else if (unclosedParameterList) {\n+            return false;\n+        } else {\n+            return switch (token.kind) {\n+                \/\/definitelly sees a statement:\n+                case CASE, DEFAULT, IF, FOR, WHILE, DO, TRY, SWITCH,\n+                    RETURN, THROW, BREAK, CONTINUE, ELSE, FINALLY,\n+                    CATCH, THIS, SUPER, NEW -> true;\n+                case RBRACE -> {\n+                    \/\/check if adding an opening brace would balance out\n+                    \/\/the opening and closing braces:\n+                    int braceBalance = 1;\n+                    VirtualScanner virtualScanner = new VirtualScanner(S);\n+\n+                    virtualScanner.nextToken();\n+\n+                    while (virtualScanner.token().kind != TokenKind.EOF) {\n+                        switch (virtualScanner.token().kind) {\n+                            case LBRACE -> braceBalance++;\n+                            case RBRACE -> braceBalance--;\n+                        }\n+                        virtualScanner.nextToken();\n+                    }\n+\n+                    yield braceBalance == 0;\n+                }\n+                default -> {\n+                    \/\/speculatively try to parse as a block, and check\n+                    \/\/if the result would suggest there is a block\n+                    \/\/e.g.: it contains a statement that is not\n+                    \/\/a member declaration\n+                    JavacParser speculative = new VirtualParser(this);\n+                    JCBlock speculativeResult =\n+                            speculative.block();\n+                    if (!speculativeResult.stats.isEmpty()) {\n+                        JCStatement last = speculativeResult.stats.last();\n+                        yield !speculativeResult.stats.stream().allMatch(s -> s.hasTag(VARDEF) ||\n+                                s.hasTag(CLASSDEF) ||\n+                                s.hasTag(BLOCK) ||\n+                                s == last) ||\n+                            !(last instanceof JCExpressionStatement exprStatement &&\n+                            exprStatement.expr.hasTag(ERRONEOUS));\n+                    } else {\n+                        yield false;\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":90,"deletions":3,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -465,12 +465,0 @@\n-class name java\/nio\/HeapByteBuffer\n-method name hashCode descriptor ()I flags 1\n-\n-class name java\/nio\/HeapByteBufferR\n-method name hashCode descriptor ()I flags 1\n-\n-class name java\/nio\/HeapCharBuffer\n-method name hashCode descriptor ()I flags 1\n-\n-class name java\/nio\/HeapCharBufferR\n-method name hashCode descriptor ()I flags 1\n-\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.base-N.sym.txt","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-        _snprintf(errorMessage, sizeof(errorMessage), \"Symbol not found: %s\", functionName);\n+        snprintf(errorMessage, sizeof(errorMessage), \"Symbol not found: %s\", functionName);\n","filename":"src\/jdk.crypto.cryptoki\/windows\/native\/libj2pkcs11\/j2secmod_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/SunMSCAPI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdDebuggerLocal.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/LinuxDebuggerLocal.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgDebuggerLocal.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -159,0 +159,10 @@\n+    if (VM.getVM().getCommandLineFlag(\"UseObjectMonitorTable\").getBool()) {\n+      Iterator it = ObjectSynchronizer.objectMonitorIterator();\n+      while (it != null && it.hasNext()) {\n+        ObjectMonitor mon = (ObjectMonitor)it.next();\n+        if (getAddress().equals(mon.object())) {\n+          return mon;\n+        }\n+      }\n+      return null;\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    displacedHeaderField = type.getCIntegerField(\"_displaced_header\");\n+    displacedHeaderField = type.getCIntegerField(\"_metadata\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/BasicLock.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-    sun.jvm.hotspot.types.Field f = type.getField(\"_header\");\n-    headerFieldOffset = f.getOffset();\n+    sun.jvm.hotspot.types.Field f = type.getField(\"_metadata\");\n+    metadataFieldOffset = f.getOffset();\n@@ -68,1 +68,1 @@\n-    return new Mark(addr.addOffsetTo(headerFieldOffset));\n+    return new Mark(addr.addOffsetTo(metadataFieldOffset));\n@@ -117,1 +117,1 @@\n-  private static long          headerFieldOffset;\n+  private static long          metadataFieldOffset;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectMonitor.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+      if (VM.getVM().getCommandLineFlag(\"UseObjectMonitorTable\").getBool()) {\n+        return mark.hash();\n+      }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectSynchronizer.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,6 +36,0 @@\n-\/\/ Disable CRT security warning against _snprintf\n-#pragma warning (disable : 4996)\n-\n-#define snprintf  _snprintf\n-#define vsnprintf _vsnprintf\n-\n","filename":"src\/jdk.hotspot.agent\/share\/native\/libsaproc\/sadis.c","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import jdk.javadoc.internal.html.HtmlId;\n@@ -299,1 +300,1 @@\n-                DocPath filename = getPath(linkInfo);\n+                DocPath fileName = getPath(linkInfo);\n@@ -302,17 +303,3 @@\n-                                filename.fragment(linkInfo.getFragment()),\n-                                label,\n-                                linkInfo.getStyle(),\n-                                title));\n-                        Content spacer = Text.EMPTY;\n-                        if (flags.contains(ElementFlag.PREVIEW)) {\n-                            link.add(HtmlTree.SUP(m_writer.links.createLink(\n-                                    filename.fragment(m_writer.htmlIds.forPreviewSection(previewTarget).name()),\n-                                    m_writer.contents.previewMark)));\n-                            spacer = Entity.NO_BREAK_SPACE;\n-                        }\n-                        if (flags.contains(ElementFlag.RESTRICTED)) {\n-                            link.add(spacer);\n-                            link.add(HtmlTree.SUP(m_writer.links.createLink(\n-                                    filename.fragment(m_writer.htmlIds.forRestrictedSection(restrictedTarget).name()),\n-                                    m_writer.contents.restrictedMark)));\n-                        }\n+                                fileName.fragment(linkInfo.getFragment()),\n+                                label, linkInfo.getStyle(), title));\n+                        addSuperscript(link, flags, fileName, null, previewTarget, restrictedTarget);\n@@ -328,17 +315,1 @@\n-                Content spacer = Text.EMPTY;\n-                if (flags.contains(ElementFlag.PREVIEW)) {\n-                    link.add(HtmlTree.SUP(m_writer.getCrossClassLink(\n-                        typeElement,\n-                        m_writer.htmlIds.forPreviewSection(previewTarget).name(),\n-                        m_writer.contents.previewMark,\n-                        null, false)));\n-                    spacer = Entity.NO_BREAK_SPACE;\n-                }\n-                if (flags.contains(ElementFlag.RESTRICTED)) {\n-                    link.add(spacer);\n-                    link.add(HtmlTree.SUP(m_writer.getCrossClassLink(\n-                            typeElement,\n-                            m_writer.htmlIds.forRestrictedSection(restrictedTarget).name(),\n-                            m_writer.contents.restrictedMark,\n-                            null, false)));\n-                }\n+                addSuperscript(link, flags, null, typeElement, previewTarget, restrictedTarget);\n@@ -350,0 +321,17 @@\n+        addSuperscript(link, flags, null, null, previewTarget, restrictedTarget);\n+        return link;\n+    }\n+\n+    \/**\n+     * Adds PREVIEW and RESTRICTED superscript labels. Depending on the parameter values,\n+     * labels will be formatted as local or external links or plain text.\n+     *\n+     * @param content the content to add to\n+     * @param flags the flags\n+     * @param fileName file name to link to, or null if no local link target\n+     * @param typeElement external type to link to, or null if no external link\n+     * @param previewTarget preview link target element\n+     * @param restrictedTarget restricted link target element\n+     *\/\n+    private void addSuperscript(Content content, Set<ElementFlag> flags, DocPath fileName, TypeElement typeElement,\n+                                Element previewTarget, ExecutableElement restrictedTarget) {\n@@ -352,1 +340,3 @@\n-            link.add(HtmlTree.SUP(m_writer.contents.previewMark));\n+            content.add(HtmlTree.SUP(getSuperscript(fileName, typeElement,\n+                    m_writer.htmlIds.forPreviewSection(previewTarget),\n+                    m_writer.contents.previewMark)));\n@@ -356,2 +346,23 @@\n-            link.add(spacer);\n-            link.add(HtmlTree.SUP(m_writer.contents.restrictedMark));\n+            content.add(spacer);\n+            content.add(HtmlTree.SUP(getSuperscript(fileName, typeElement,\n+                    m_writer.htmlIds.forRestrictedSection(restrictedTarget),\n+                    m_writer.contents.restrictedMark)));\n+        }\n+    }\n+\n+    \/**\n+     * Returns PREVIEW or RESTRICTED superscript as either local or external link or as plain text.\n+     *\n+     * @param fileName local file name to link to, or null if no local link target\n+     * @param typeElement external type to link to, or null if no external link\n+     * @param id the id fragment to link to\n+     * @param label the label content\n+     * @return superscript content\n+     *\/\n+    private Content getSuperscript(DocPath fileName, TypeElement typeElement, HtmlId id, Content label) {\n+        if (fileName != null) {\n+            return m_writer.links.createLink(fileName.fragment(id.name()), label);\n+        } else if (typeElement != null) {\n+            return (m_writer.getCrossClassLink(typeElement, id.name(), label, null, false));\n+        } else {\n+            return label;\n@@ -359,1 +370,0 @@\n-        return link;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkFactory.java","additions":49,"deletions":39,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-    function handleResize(e) {\n+    new ResizeObserver((entries) => {\n@@ -478,3 +478,1 @@\n-    }\n-    window.addEventListener(\"orientationchange\", handleResize);\n-    window.addEventListener(\"resize\", handleResize);\n+    }).observe(document.body);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js.template","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -481,1 +481,2 @@\n-    Recursively copy doc-file subdirectories\n+    Enables deep copying of 'doc-files' directories. Subdirectories and all\\n\\\n+    contents are recursively copied to the destination\n@@ -518,1 +519,1 @@\n-    Include footer text for each page\n+    This option is no longer supported and reports a warning\n@@ -556,1 +557,1 @@\n-    Exclude any doc-files subdirectories with given name.\\n\\\n+    Exclude any 'doc-files' subdirectories with given name.\\n\\\n@@ -617,1 +618,1 @@\n-    Generate warning about @serial tag\n+    Reports compile-time warnings for missing '@serial' tags\n@@ -632,1 +633,1 @@\n-    Specify single argument custom tags\n+    Specifies a custom tag with a single argument\n@@ -657,1 +658,2 @@\n-    Include file that help link links to\n+    Specifies a file containing the text that will be displayed when the\\n\\\n+    help link in the navigation bar is clicked\n@@ -694,1 +696,2 @@\n-    Allow JavaScript in options and comments\n+    Allow JavaScript in documentation comments, and options\\n\\\n+    whose value is html-code\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+                    .skipPreview(isPlain)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LinkTaglet.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -681,1 +681,1 @@\n-         * the {@code --help-extended} option and its aliases.\n+         * the {@code --help-extra} option and its aliases.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    Specifies which members (fields, methods, etc.) will be\\n\\\n+    Specifies which members (fields, methods, or constructors) will be\\n\\\n@@ -90,1 +90,1 @@\n-    Specifies which module's packages will be documented. Possible\\n\\\n+    Specifies which module packages will be documented. Possible\\n\\\n@@ -100,1 +100,1 @@\n-    <value>\n+    (transitive|all)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-        write(annot, true);\n+        write(annot.annotation(), true);\n@@ -104,1 +104,1 @@\n-        write(annot, resolveIndices);\n+        write(annot.annotation(), resolveIndices);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AnnotationWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+    @SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jdi\/windows\/classes\/com\/sun\/tools\/jdi\/SharedMemoryTransportService.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-        size_t result_len = (size_t)_snprintf(buffer, buflen, \"%s\\\\%s.dll\", path, fname);\n+        size_t result_len = (size_t) snprintf(buffer, buflen, \"%s\\\\%s.dll\", path, fname);\n","filename":"src\/jdk.jdwp.agent\/windows\/native\/libjdwp\/linker_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,5 +37,0 @@\n-\/* Needed on Windows because names seem to be hidden in stdio.h. *\/\n-\n-#define snprintf        _snprintf\n-#define vsnprintf       _vsnprintf\n-\n","filename":"src\/jdk.jdwp.agent\/windows\/native\/libjdwp\/util_md.h","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-                    delegate.combine(Collections.unmodifiableSet(values));\n+                    return delegate.combine(Collections.unmodifiableSet(values));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Control.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.vm.Continuation;\n@@ -32,2 +33,2 @@\n-    public static final int MAX_LIMIT = 128; \/* 0 MAX means disabled *\/\n-\n+    public static final int MAX_LIMIT = 131072; \/* 0 MAX means disabled *\/\n+    private static final int PRECACHE_THRESHOLD = 128;\n@@ -74,9 +75,35 @@\n-    \/* synchronized because of writing the string to the JVM. *\/\n-    private static synchronized long storeString(String s) {\n-        Long lsid = cache.get(s);\n-        long internalSid;\n-        if (lsid != null) {\n-            internalSid = lsid.longValue();\n-            if (isCurrentGeneration(internalSid)) {\n-                \/\/ Someone already updated the cache.\n-                return externalSid(internalSid);\n+    \/* Explicitly pin a virtual thread before acquiring the string pool monitor\n+     * because migrating the EventWriter onto another carrier thread is impossible.\n+     *\/\n+    private static long storeString(String s, boolean pinVirtualThread) {\n+        if (pinVirtualThread) {\n+            assert(Thread.currentThread().isVirtual());\n+            Continuation.pin();\n+        }\n+        try {\n+            \/* synchronized because of writing the string to the JVM. *\/\n+            synchronized (StringPool.class) {\n+                Long lsid = cache.get(s);\n+                long internalSid;\n+                if (lsid != null) {\n+                    internalSid = lsid.longValue();\n+                    if (isCurrentGeneration(internalSid)) {\n+                        \/\/ Someone already updated the cache.\n+                        return externalSid(internalSid);\n+                    }\n+                    internalSid = updateInternalSid(internalSid);\n+                } else {\n+                    \/\/ Not yet added or the cache was cleared.\n+                    internalSid = nextInternalSid();\n+                    currentSizeUTF16 += s.length();\n+                }\n+                long extSid = externalSid(internalSid);\n+                \/\/ Write the string to the JVM before publishing to the cache.\n+                JVM.addStringConstant(extSid, s);\n+                cache.put(s, internalSid);\n+                return extSid;\n+            }\n+        } finally {\n+            if (pinVirtualThread) {\n+                assert(Thread.currentThread().isVirtual());\n+                Continuation.unpin();\n@@ -84,5 +111,0 @@\n-            internalSid = updateInternalSid(internalSid);\n-        } else {\n-            \/\/ Not yet added or the cache was cleared.\n-            internalSid = nextInternalSid();\n-            currentSizeUTF16 += s.length();\n@@ -90,5 +112,0 @@\n-        long extSid = externalSid(internalSid);\n-        \/\/ Write the string to the JVM before publishing to the cache.\n-        JVM.addStringConstant(extSid, s);\n-        cache.put(s, internalSid);\n-        return extSid;\n@@ -98,1 +115,1 @@\n-    private static long ensureCurrentGeneration(String s, Long lsid) {\n+    private static long ensureCurrentGeneration(String s, Long lsid, boolean pinVirtualThread) {\n@@ -100,1 +117,1 @@\n-        return isCurrentGeneration(internalSid) ? externalSid(internalSid) : storeString(s);\n+        return isCurrentGeneration(internalSid) ? externalSid(internalSid) : storeString(s, pinVirtualThread);\n@@ -112,1 +129,1 @@\n-    public static long addString(String s) {\n+    public static long addString(String s, boolean pinVirtualThread) {\n@@ -115,1 +132,1 @@\n-            return ensureCurrentGeneration(s, lsid);\n+            return ensureCurrentGeneration(s, lsid, pinVirtualThread);\n@@ -117,1 +134,1 @@\n-        if (!preCache(s)) {\n+        if (s.length() <= PRECACHE_THRESHOLD && !preCache(s)) {\n@@ -123,1 +140,1 @@\n-            reset();\n+            reset(pinVirtualThread);\n@@ -125,1 +142,1 @@\n-        return storeString(s);\n+        return storeString(s, pinVirtualThread);\n@@ -146,3 +163,16 @@\n-    private static synchronized void reset() {\n-        cache.clear();\n-        currentSizeUTF16 = 0;\n+    private static void reset(boolean pinVirtualThread) {\n+        if (pinVirtualThread) {\n+            assert(Thread.currentThread().isVirtual());\n+            Continuation.pin();\n+        }\n+        try {\n+            synchronized (StringPool.class) {\n+                cache.clear();\n+                currentSizeUTF16 = 0;\n+            }\n+        } finally {\n+            if (pinVirtualThread) {\n+                assert(Thread.currentThread().isVirtual());\n+                Continuation.unpin();\n+            }\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/StringPool.java","additions":62,"deletions":32,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+    private boolean pinVirtualThread;\n@@ -147,1 +148,1 @@\n-            long l = StringPool.addString(s);\n+            long l = StringPool.addString(s, pinVirtualThread);\n@@ -299,1 +300,1 @@\n-    private EventWriter(long startPos, long maxPos, long threadID, boolean valid, boolean excluded) {\n+    private EventWriter(long startPos, long maxPos, long threadID, boolean valid, boolean pinVirtualThread, boolean excluded) {\n@@ -304,0 +305,1 @@\n+        this.pinVirtualThread = pinVirtualThread;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventWriter.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/ExecutableRebrander.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExeBundler.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WindowsRegistry.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.management.agent\/unix\/classes\/jdk\/internal\/agent\/FileSystemImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.management.agent\/windows\/classes\/jdk\/internal\/agent\/FileSystemImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/Flag.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/PlatformMBeanProviderImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -439,7 +439,7 @@\n-        _snprintf(fullCounterPath,\n-                  fullCounterPathLen,\n-                  PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n-                  objectName,\n-                  imageName,\n-                  instance,\n-                  counterName);\n+        snprintf(fullCounterPath,\n+                 fullCounterPathLen,\n+                 PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n+                 objectName,\n+                 imageName,\n+                 instance,\n+                 counterName);\n@@ -475,6 +475,6 @@\n-            _snprintf(fullCounterPath,\n-                      fullCounterPathLen,\n-                      OBJECT_WITH_INSTANCES_COUNTER_FMT,\n-                      objectName,\n-                      instance,\n-                      counterName);\n+            snprintf(fullCounterPath,\n+                     fullCounterPathLen,\n+                     OBJECT_WITH_INSTANCES_COUNTER_FMT,\n+                     objectName,\n+                     instance,\n+                     counterName);\n@@ -482,5 +482,5 @@\n-            _snprintf(fullCounterPath,\n-                      fullCounterPathLen,\n-                      OBJECT_COUNTER_FMT,\n-                      objectName,\n-                      counterName);\n+            snprintf(fullCounterPath,\n+                     fullCounterPathLen,\n+                     OBJECT_COUNTER_FMT,\n+                     objectName,\n+                     counterName);\n@@ -722,4 +722,4 @@\n-            _snprintf(fullIDProcessCounterPath,\n-                      MAX_PATH,\n-                      pdhIDProcessCounterFmt,\n-                      index);\n+            snprintf(fullIDProcessCounterPath,\n+                     MAX_PATH,\n+                     pdhIDProcessCounterFmt,\n+                     index);\n@@ -1062,7 +1062,7 @@\n-    _snprintf(pdhIDProcessCounterFmt,\n-              pdhIDProcessCounterFmtLen,\n-              PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n-              pdhLocalizedProcessObject,\n-              pdhProcessImageName,\n-              \"%d\",\n-              pdhLocalizedIDProcessCounter);\n+    snprintf(pdhIDProcessCounterFmt,\n+             pdhIDProcessCounterFmtLen,\n+             PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n+             pdhLocalizedProcessObject,\n+             pdhProcessImageName,\n+             \"%d\",\n+             pdhLocalizedIDProcessCounter);\n","filename":"src\/jdk.management\/windows\/native\/libmanagement_ext\/OperatingSystemImpl.c","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/aix\/classes\/jdk\/net\/AIXSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/linux\/classes\/jdk\/net\/LinuxSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/macosx\/classes\/jdk\/net\/MacOSXSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/windows\/classes\/jdk\/net\/WindowsSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1097,1 +1097,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpNet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-\n+    @SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/module\/NTSystem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    @SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/module\/UnixSystem.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-      FLAG_SET_ERGO(MaxNewSize, 80 * M);\n+      FLAG_SET_ERGO(MaxNewSize, 40 * M);\n@@ -162,0 +162,3 @@\n+\/\/ Tests require at least 128M of MaxHeap\n+\/\/ otherwise ergonomic is different and generation sizes might be changed.\n+\n@@ -166,0 +169,3 @@\n+  if (MaxHeapSize < 128 * M) {\n+      return;\n+  }\n@@ -178,0 +184,3 @@\n+  if (MaxHeapSize < 128 * M) {\n+    return;\n+  }\n@@ -190,2 +199,2 @@\n-  TestGenCollectorPolicy::SetNewSizeCmd setter_large(80 * M);\n-  TestGenCollectorPolicy::CheckYoungInitial checker_large(80 * M);\n+  TestGenCollectorPolicy::SetNewSizeCmd setter_large(40 * M);\n+  TestGenCollectorPolicy::CheckYoungInitial checker_large(40 * M);\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_collectorPolicy.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    cld->metaspace_non_null()->deallocate(p, sz, in_class_space);\n+    cld->metaspace_non_null()->deallocate(p, sz);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspace_misc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- uint cache_line_size = VM_Version::L1_data_cache_line_size();\n+  uint cache_line_size = VM_Version::L1_data_cache_line_size();\n@@ -32,9 +32,1 @@\n- if (cache_line_size != 0) {\n-   \/\/ We were able to determine the L1 data cache line size so\n-   \/\/ do some cache line specific sanity checks\n-   EXPECT_EQ((size_t) 0, sizeof (PaddedEnd<ObjectMonitor>) % cache_line_size)\n-        << \"PaddedEnd<ObjectMonitor> size is not a \"\n-        << \"multiple of a cache line which permits false sharing. \"\n-        << \"sizeof(PaddedEnd<ObjectMonitor>) = \"\n-        << sizeof (PaddedEnd<ObjectMonitor>)\n-        << \"; cache_line_size = \" << cache_line_size;\n+  if (cache_line_size != 0) {\n@@ -42,2 +34,10 @@\n-   EXPECT_GE((size_t) in_bytes(ObjectMonitor::owner_offset()), cache_line_size)\n-        << \"the _header and _owner fields are closer \"\n+    EXPECT_EQ(in_bytes(ObjectMonitor::metadata_offset()), 0)\n+        << \"_metadata at a non 0 offset. metadata_offset = \"\n+        << in_bytes(ObjectMonitor::metadata_offset());\n+\n+    EXPECT_GE((size_t) in_bytes(ObjectMonitor::owner_offset()), cache_line_size)\n+        << \"the _metadata and _owner fields are closer \"\n+        << \"than a cache line which permits false sharing.\";\n+\n+    EXPECT_GE((size_t) in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), cache_line_size)\n+        << \"the _owner and _recursions fields are closer \"\n","filename":"test\/hotspot\/gtest\/runtime\/test_objectMonitor.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,5 +32,0 @@\n-vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\/TestDescription.java#id0            8205957 generic-all\n-vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\/TestDescription.java#logging        8205957 generic-all\n-vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java#id0     8205957 generic-all\n-vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java#logging 8205957 generic-all\n-\n@@ -59,0 +54,2 @@\n+\n+runtime\/interpreter\/LastJsrTest.java 8338924 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,9 +49,0 @@\n-    public static long lseed = 1;\n-    public static int iseed = 2;\n-    public static short sseed = 3;\n-    public static byte bseed = 4;\n-    public static long lres = lseed;\n-    public static int ires = iseed;\n-    public static short sres = sseed;\n-    public static byte bres = bseed;\n-\n@@ -62,1 +53,1 @@\n-        private static final long data;\n+        private static final long lseed = 1;\n@@ -72,1 +63,0 @@\n-            lres += UNSAFE.getLongUnaligned(BYTES, 1030);\n@@ -74,2 +64,1 @@\n-            UNSAFE.putLongUnaligned(BYTES, 127, lres);\n-            lres += UNSAFE.getLongUnaligned(BYTES, 127);\n+            UNSAFE.putLongUnaligned(BYTES, 127, rawdata+lseed);\n@@ -77,2 +66,1 @@\n-            UNSAFE.putLongUnaligned(BYTES, 1096, lres);\n-            data = UNSAFE.getLongUnaligned(BYTES, 1096);\n+            UNSAFE.putLongUnaligned(BYTES, 1096, rawdata-lseed);\n@@ -87,1 +75,1 @@\n-        private static final int data;\n+        private static final int iseed = 2;\n@@ -96,1 +84,0 @@\n-            ires += UNSAFE.getIntUnaligned(BYTES, 274);\n@@ -98,2 +85,1 @@\n-            UNSAFE.putIntUnaligned(BYTES, 255, ires);\n-            ires += UNSAFE.getIntUnaligned(BYTES, 255);\n+            UNSAFE.putIntUnaligned(BYTES, 255, rawdata + iseed);\n@@ -101,2 +87,1 @@\n-            UNSAFE.putIntUnaligned(BYTES, 528, ires);\n-            data = UNSAFE.getIntUnaligned(BYTES, 528);\n+            UNSAFE.putIntUnaligned(BYTES, 528, rawdata - iseed);\n@@ -111,1 +96,1 @@\n-        private static final short data;\n+        private static final short sseed = 3;\n@@ -120,1 +105,0 @@\n-            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 257));\n@@ -122,2 +106,1 @@\n-            UNSAFE.putShortUnaligned(BYTES, 253, sres);\n-            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 253));\n+            UNSAFE.putShortUnaligned(BYTES, 253, (short) (rawdata + sseed));\n@@ -125,2 +108,1 @@\n-            UNSAFE.putShortUnaligned(BYTES, 272, sres);\n-            data = UNSAFE.getShortUnaligned(BYTES, 272);\n+            UNSAFE.putShortUnaligned(BYTES, 272, (short) (rawdata - sseed));\n@@ -135,1 +117,1 @@\n-        private static final byte data;\n+        private static final byte bseed = 4;\n@@ -144,1 +126,0 @@\n-            bres = (byte) (bres + UNSAFE.getByte(BYTES, 272));\n@@ -146,2 +127,1 @@\n-            UNSAFE.putByte(BYTES, 53, bres);\n-            bres = (byte) (bres + UNSAFE.getByte(BYTES, 53));\n+            UNSAFE.putByte(BYTES, 53, (byte) (rawdata + bseed));\n@@ -149,2 +129,1 @@\n-            UNSAFE.putByte(BYTES, 1027, bres);\n-            data = UNSAFE.getByte(BYTES, 1027);\n+            UNSAFE.putByte(BYTES, 1027, (byte) (rawdata - bseed));\n@@ -157,1 +136,3 @@\n-        Asserts.assertEquals(ta.data, (ta.rawdata + lseed) * 2, \"putUnaligned long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLongUnaligned(ta.BYTES, 1030), ta.rawdata, \"putUnaligned long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLongUnaligned(ta.BYTES, 127), ta.rawdata + ta.lseed, \"putUnaligned long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLongUnaligned(ta.BYTES, 1096), ta.rawdata - ta.lseed, \"putUnaligned long failed!\");\n@@ -160,1 +141,3 @@\n-        Asserts.assertEquals(tb.data, (tb.rawdata + iseed) * 2, \"putUnaligned int failed!\");\n+        Asserts.assertEquals(UNSAFE.getIntUnaligned(tb.BYTES, 274), tb.rawdata, \"putUnaligned int failed!\");\n+        Asserts.assertEquals(UNSAFE.getIntUnaligned(tb.BYTES, 255), tb.rawdata + tb.iseed, \"putUnaligned int failed!\");\n+        Asserts.assertEquals(UNSAFE.getIntUnaligned(tb.BYTES, 528), tb.rawdata - tb.iseed, \"putUnaligned int failed!\");\n@@ -163,1 +146,3 @@\n-        Asserts.assertEquals(tc.data, (short) (((short) (tc.rawdata + sseed)) * 2), \"putUnaligned short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShortUnaligned(tc.BYTES, 257), tc.rawdata, \"putUnaligned short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShortUnaligned(tc.BYTES, 253), (short) (tc.rawdata + tc.sseed), \"putUnaligned short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShortUnaligned(tc.BYTES, 272), (short) (tc.rawdata - tc.sseed), \"putUnaligned short failed!\");\n@@ -166,1 +151,3 @@\n-        Asserts.assertEquals(td.data, (byte) (((byte) (td.rawdata + bseed)) * 2), \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(td.BYTES, 272), td.rawdata, \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(td.BYTES, 53), (byte) (td.rawdata + td.bseed), \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(td.BYTES, 1027), (byte) (td.rawdata - td.bseed), \"put byte failed!\");\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUnalignedAccess.java","additions":24,"deletions":37,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.gvn;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Random;\n+\n+\/**\n+ * @test\n+ * @bug 8327381\n+ * @summary Refactor boolean node tautology transformations\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.TestBoolNodeGVN\n+ *\/\n+public class TestBoolNodeGVN {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+        testCorrectness();\n+    }\n+\n+    \/**\n+     * Test changing ((x & m) u<= m) or ((m & x) u<= m) to always true, same with ((x & m) u< m+1) and ((m & x) u< m+1)\n+     * The test is only applicable to x64, aarch64 and riscv64 for having <code>Integer.compareUnsigned<\/code>\n+     * intrinsified.\n+     *\/\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase1(int x, int m) {\n+        return !(Integer.compareUnsigned((x & m), m) > 0); \/\/ assert in inversions to generates the pattern looking for\n+    }\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase2(int x, int m) {\n+        return !(Integer.compareUnsigned((m & x), m) > 0);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase3(int x, int m) {\n+        return Integer.compareUnsigned((x & m), m + 1) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase4(int x, int m) {\n+        return Integer.compareUnsigned((m & x), m + 1) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase1(int x, int m) {\n+        return !(Integer.compareUnsigned((x & m), m - 1) > 0);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase2(int x, int m) {\n+        return !(Integer.compareUnsigned((m & x), m - 1) > 0);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase3(int x, int m) {\n+        return Integer.compareUnsigned((x & m), m + 2) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase4(int x, int m) {\n+        return Integer.compareUnsigned((m & x), m + 2) < 0;\n+    }\n+\n+    private static void testCorrectness() {\n+        int[] values = {\n+                0, 1, 5, 8, 16, 42, 100, new Random().nextInt(0, Integer.MAX_VALUE), Integer.MAX_VALUE\n+        };\n+\n+        for (int x : values) {\n+            for (int m : values) {\n+                if (!testShouldReplaceCpmUCase1(x, m) |\n+                    !testShouldReplaceCpmUCase2(x, m) |\n+                    !testShouldReplaceCpmUCase3(x, m) |\n+                    !testShouldReplaceCpmUCase4(x, m)) {\n+                    throw new RuntimeException(\"Bad result for x = \" + x + \" and m = \" + m + \", expected always true\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBoolNodeGVN.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2024 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests.scalarReplacement;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8333334\n+ * @summary Tests that dead barrier control flows do not affect the scalar replacement.\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.gc.G1\n+ * @run driver compiler.c2.irTests.scalarReplacement.ScalarReplacementWithGCBarrierTests\n+ *\/\n+public class ScalarReplacementWithGCBarrierTests {\n+    static class List {\n+        public Node head;\n+\n+        public void push(int value) {\n+            Node n = new Node();\n+            n.value = value;\n+            n.next = head;\n+            head = n;\n+        }\n+\n+        @ForceInline\n+        public Iter iter() {\n+            Iter iter = new Iter();\n+            iter.list = this;\n+            iter.n = head;\n+            iter.sum = 0;\n+            return iter;\n+        }\n+    }\n+\n+    static class Node {\n+        public int value;\n+        public Node next;\n+    }\n+\n+    static class Iter {\n+        public List list;\n+        public Node n;\n+        public Integer sum;\n+\n+        @ForceInline\n+        public boolean next() {\n+            int lastSum = sum;\n+            while (sum - lastSum < 1000) {\n+                while (n != null && n.value < 30) n = n.next;\n+                if (n == null) return false;\n+                sum += n.value;\n+                n = n.next;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private static final int SIZE = 1000;\n+\n+    public static void main(String[] args) {\n+        \/\/ Must use G1 GC to ensure there is a pre-barrier\n+        \/\/ before the first field write.\n+        TestFramework.runWithFlags(\"-XX:+UseG1GC\");\n+    }\n+\n+    @Run(test = \"testScalarReplacementWithGCBarrier\")\n+    private void runner() {\n+        List list = new List();\n+        for (int i = 0; i < SIZE; i++) {\n+            list.push(i);\n+        }\n+        testScalarReplacementWithGCBarrier(list);\n+    }\n+\n+    \/\/ Allocation of `Iter iter` should be eliminated by scalar replacement, and\n+    \/\/ the allocation of `Integer sum` can not be eliminated, so there should be\n+    \/\/ 1 allocation after allocations and locks elimination.\n+    \/\/\n+    \/\/ Before the patch of JDK-8333334, both allocations of `Iter` and `Integer`\n+    \/\/ could not be eliminated.\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.ALLOC, \"1\" })\n+    @IR(phase = { CompilePhase.INCREMENTAL_BOXING_INLINE }, counts = { IRNode.ALLOC, \"2\" })\n+    @IR(phase = { CompilePhase.ITER_GVN_AFTER_ELIMINATION }, counts = { IRNode.ALLOC, \"1\" })\n+    private int testScalarReplacementWithGCBarrier(List list) {\n+        Iter iter = list.iter();\n+        while (true) {\n+            while (iter.next()) {}\n+            if (list.head == null) break;\n+            list.head = list.head.next;\n+            iter.n = list.head;\n+        }\n+        return iter.sum;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/ScalarReplacementWithGCBarrierTests.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimArrayTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimArrayTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final int[] EMPTY_INTEGER = new int[] { 0 };\n+    static final int[] FULL_INTEGER = new int[] { 42 };\n+\n+    static class Carrier {\n+        @Stable\n+        int[] field;\n+\n+        @ForceInline\n+        public Carrier(int initLevel) {\n+            switch (initLevel) {\n+                case 0:\n+                    \/\/ Do nothing.\n+                    break;\n+                case 1:\n+                    field = EMPTY_INTEGER;\n+                    break;\n+                case 2:\n+                    field = FULL_INTEGER;\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown level\");\n+            }\n+        }\n+\n+        @ForceInline\n+        public void initEmpty() {\n+            field = EMPTY_INTEGER;\n+        }\n+\n+        @ForceInline\n+        public void initFull() {\n+            field = FULL_INTEGER;\n+        }\n+\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(0);\n+    static final Carrier INIT_EMPTY_CARRIER = new Carrier(1);\n+    static final Carrier INIT_FULL_CARRIER = new Carrier(2);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        int[] is = BLANK_CARRIER.field;\n+        if (is != null) {\n+            return is[0];\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testPartialFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        int[] is = INIT_EMPTY_CARRIER.field;\n+        if (is != null) {\n+            return is[0];\n+        }\n+        return 0;\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        int[] is = INIT_FULL_CARRIER.field;\n+        if (is != null) {\n+            return is[0];\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorEmptyInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(2);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodEmptyInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_EMPTY_CARRIER.initEmpty();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodFullInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_FULL_CARRIER.initFull();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimArrayTest.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimFinalTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimFinalTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static class Carrier {\n+        @Stable\n+        final int field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            field = init ? 42 : 0;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for final fields.\n+        return BLANK_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        return INIT_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Single header+final barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Single header+final barrier.\n+        return new Carrier(true);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimFinalTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimPlainTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimPlainTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static class Carrier {\n+        @Stable\n+        int field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = 42;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = 42;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        return BLANK_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        return INIT_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodInit() {\n+        \/\/ Primitive inits have no membars.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimPlainTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimVolatileTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimVolatileTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static class Carrier {\n+        @Stable\n+        volatile int field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = 42;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = 42;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ Barriers expected for volatile fields.\n+        return BLANK_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        return INIT_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Expect only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Volatile barriers expected.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static void testMethodInit() {\n+        \/\/ Volatile barriers expected.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimVolatileTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefArrayTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefArrayTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer[] EMPTY_INTEGER = new Integer[] { null };\n+    static final Integer[] FULL_INTEGER = new Integer[] { 42 };\n+\n+    static class Carrier {\n+        @Stable\n+        Integer[] field;\n+\n+        @ForceInline\n+        public Carrier(int initLevel) {\n+            switch (initLevel) {\n+                case 0:\n+                    \/\/ Do nothing.\n+                    break;\n+                case 1:\n+                    field = EMPTY_INTEGER;\n+                    break;\n+                case 2:\n+                    field = FULL_INTEGER;\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown level\");\n+            }\n+        }\n+\n+        @ForceInline\n+        public void initEmpty() {\n+            field = EMPTY_INTEGER;\n+        }\n+\n+        @ForceInline\n+        public void initFull() {\n+            field = FULL_INTEGER;\n+        }\n+\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(0);\n+    static final Carrier INIT_EMPTY_CARRIER = new Carrier(1);\n+    static final Carrier INIT_FULL_CARRIER = new Carrier(2);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer[] is = BLANK_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testPartialFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer[] is = INIT_EMPTY_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer[] is = INIT_FULL_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorEmptyInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(2);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodEmptyInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_EMPTY_CARRIER.initEmpty();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodFullInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_FULL_CARRIER.initFull();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefArrayTest.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefFinalTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefFinalTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer INTEGER = 42;\n+\n+    static class Carrier {\n+        @Stable\n+        final Integer field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            field = init ? INTEGER : null;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer i = BLANK_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer i = INIT_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorInit() {\n+        \/\/ Only the header+final barrier.\n+        return new Carrier(true);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefFinalTest.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefPlainTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefPlainTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer INTEGER = 42;\n+\n+    static class Carrier {\n+        @Stable\n+        Integer field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = INTEGER;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = INTEGER;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer i = BLANK_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer i = INIT_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefPlainTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefVolatileTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefVolatileTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer INTEGER = 42;\n+\n+    static class Carrier {\n+        @Stable\n+        volatile Integer field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = INTEGER;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = INTEGER;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ Barriers are expected for volatile field.\n+        Integer i = BLANK_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer i = INIT_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Volatile writes, expect more barriers.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static void testMethodInit() {\n+        \/\/ Barriers are expected for volatile fields.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefVolatileTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -442,1 +442,1 @@\n-        beforeMatchingNameRegex(CMP_U, \"CmpU\");\n+        beforeMatchingNameRegex(CMP_U, \"CmpU\\\\b\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336830\n+ * @summary C2: assert(get_loop(lca)->_nest < n_loop->_nest || lca->in(0)->is_NeverBranch()) failed: must not be moved into inner loop\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:CompileCommand=compileonly,TestSunkNodeInInfiniteLoop::* -Xcomp TestSunkNodeInInfiniteLoop\n+ *\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+\n+public class TestSunkNodeInInfiniteLoop {\n+    public static void main(String[] args) throws InterruptedException {\n+        byte[] a = new byte[1];\n+        Thread thread = new Thread(() -> test(a));\n+        thread.setDaemon(true);\n+        thread.start();\n+        Thread.sleep(Utils.adjustTimeout(4000));\n+    }\n+\n+    static void test(byte[] a) {\n+        \/\/ L0:\n+        while(true) {\n+            int i1 = a.length;\n+            \/\/ L3:\n+            while(true) {\n+                int i2 = 0;\n+                if ((i1--) <= 0) { break; \/* ifle L0 *\/}\n+                a[i2++] = -1;\n+                \/\/ goto L3\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestSunkNodeInInfiniteLoop.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-* @bug 8299259\n+* @bug 8299259 8336729\n@@ -38,1 +38,1 @@\n-* @bug 8299259\n+* @bug 8299259 8336729\n@@ -46,0 +46,22 @@\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @bug 8336729\n+ * @requires vm.compiler2.enabled\n+ * @summary Test various cases of divisions\/modulo which should not be split through iv phis.\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:LoopUnrollLimit=0 -XX:+StressGCM -XX:StressSeed=3434\n+ *                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivisionThroughPhi::*\n+ *                   compiler.splitif.TestSplitDivisionThroughPhi\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @bug 8336729\n+ * @requires vm.compiler2.enabled\n+ * @summary Test various cases of divisions\/modulo which should not be split through iv phis.\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:LoopUnrollLimit=0 -XX:+StressGCM\n+ *                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivisionThroughPhi::*\n+ *                   compiler.splitif.TestSplitDivisionThroughPhi\n+ *\/\n+\n@@ -64,0 +86,2 @@\n+            testPushDivLThruPhiForOuterLongLoop();\n+            testPushModLThruPhiForOuterLongLoop();\n@@ -81,0 +105,21 @@\n+    \/\/ Fixed with JDK-8336729.\n+    static void testPushDivLThruPhiForOuterLongLoop() {\n+        \/\/ This loop is first transformed into a LongCountedLoop in the first loop opts phase.\n+        \/\/ In the second loop opts phase, the LongCountedLoop is split into an inner and an outer loop. Both get the\n+        \/\/ same iv phi type which is [2..10]. Only the inner loop is transformed into a CountedLoopNode while the outer\n+        \/\/ loop is still a LoopNode. We run into the same problem as described in testPushDivIThruPhi() when splitting\n+        \/\/ the DivL node through the long iv phi of the outer LoopNode.\n+        \/\/ The fix for JDK-8299259 only prevents this splitting for CountedLoopNodes. We now extend it to LoopNodes\n+        \/\/ in general.\n+        for (long i = 10; i > 1; i -= 2) {\n+            lFld = 10 \/ i;\n+        }\n+    }\n+\n+    \/\/ Same as testPushDivLThruPhiForOuterLongLoop() but for ModL.\n+    static void testPushModLThruPhiForOuterLongLoop() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            iFld = 10 % i;\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/splitif\/TestSplitDivisionThroughPhi.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,211 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test id=default\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ShenandoahHumongousThreshold=90 -XX:ShenandoahGCHeuristics=aggressive\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ShenandoahHumongousThreshold=90 -XX:ShenandoahGCHeuristics=aggressive\n- *                   TestHumongousThreshold\n- *\/\n-\n-\/*\n- * @test id=16b\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @requires vm.bits == \"64\"\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\/\n-\n-\/*\n- * @test id=generational\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\/\n-\n-\/*\n- * @test id=generational-16b\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @requires vm.bits == \"64\"\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\/\n-\n-import java.util.Random;\n-import jdk.test.lib.Utils;\n-\n-public class TestHumongousThreshold {\n-\n-    static final long TARGET_MB = Long.getLong(\"target\", 20_000); \/\/ 20 Gb allocation\n-\n-    static volatile Object sink;\n-\n-    public static void main(String[] args) throws Exception {\n-        final int min = 0;\n-        final int max = 384 * 1024;\n-        long count = TARGET_MB * 1024 * 1024 \/ (16 + 4 * (min + (max - min) \/ 2));\n-\n-        Random r = Utils.getRandomInstance();\n-        for (long c = 0; c < count; c++) {\n-            sink = new int[min + r.nextInt(max - min)];\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestHumongousThreshold.java","additions":0,"deletions":211,"binary":false,"changes":211,"status":"deleted"},{"patch":"@@ -147,1 +147,1 @@\n- * @run main\/othervm\/timeout=300 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=240 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSieveObjects.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test that Shenandoah humongous threshold args are checked\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver TestHumongousThresholdArgs\n- *\/\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class TestHumongousThresholdArgs {\n-    public static void main(String[] args) throws Exception {\n-        {\n-            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx128m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    \"-version\");\n-            output.shouldHaveExitValue(0);\n-        }\n-\n-        int[] valid = new int[] {1, 10, 50, 90, 100};\n-        int[] invalid = new int[] {-100, -1, 0, 101, 1000};\n-\n-        for (int v : valid) {\n-            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx128m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    \"-XX:ShenandoahHumongousThreshold=\" + v,\n-                    \"-version\");\n-            output.shouldHaveExitValue(0);\n-        }\n-\n-        for (int v : invalid) {\n-            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx128m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    \"-XX:ShenandoahHumongousThreshold=\" + v,\n-                    \"-version\");\n-            output.shouldHaveExitValue(1);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestHumongousThresholdArgs.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -73,0 +73,3 @@\n+        if (Platform.isLinux()) {\n+            deprecated.add(new String[] { \"UseLinuxPosixThreadCPUClocks\", \"true\" });\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=NormalDeflation\n+ * @summary A collection of small tests using synchronized, wait, notify to try\n+ *          and achieve good cheap coverage of UseObjectMonitorTable.\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+UseObjectMonitorTable\n+ *                   UseObjectMonitorTableTest\n+ *\/\n+\n+\/**\n+ * @test id=ExtremeDeflation\n+ * @summary Run the same tests but with deflation running constantly.\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:GuaranteedAsyncDeflationInterval=1\n+ *                   -XX:+UseObjectMonitorTable\n+ *                   UseObjectMonitorTableTest\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+\n+import java.lang.Runnable;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.Random;\n+import java.util.stream.Stream;\n+\n+public class UseObjectMonitorTableTest {\n+    static final ThreadFactory TF = Executors.defaultThreadFactory();\n+\n+    static class WaitNotifyTest implements Runnable {\n+        static final int ITERATIONS = 10_000;\n+        static final int THREADS = 10;\n+        final WaitNotifySyncChannel startLatchChannel = new WaitNotifySyncChannel();\n+        final WaitNotifySyncChannel endLatchChannel = new WaitNotifySyncChannel();\n+        int count = 0;\n+\n+        static class WaitNotifyCountDownLatch {\n+            int latch;\n+            WaitNotifyCountDownLatch(int count) {\n+                latch = count;\n+            }\n+            synchronized void await() {\n+                while (latch != 0) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        throw new RuntimeException(\"WaitNotifyTest: Unexpected interrupt\", e);\n+                    }\n+                }\n+            }\n+            synchronized void countDown() {\n+                if (latch != 0) {\n+                    latch--;\n+                    if (latch == 0) {\n+                        notifyAll();\n+                    }\n+                }\n+            }\n+        }\n+        static class WaitNotifySyncChannel extends WaitNotifyCountDownLatch {\n+            WaitNotifyCountDownLatch object;\n+            WaitNotifySyncChannel() { super(0); }\n+            synchronized void send(WaitNotifyCountDownLatch object, int count) {\n+                await();\n+                latch = count;\n+                this.object = object;\n+                notifyAll();\n+            }\n+            synchronized WaitNotifyCountDownLatch receive() {\n+                while (latch == 0) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        throw new RuntimeException(\"WaitNotifyTest: Unexpected interrupt\", e);\n+                    }\n+                }\n+                countDown();\n+                return object;\n+            }\n+        }\n+        synchronized int getCount() {\n+            return count;\n+        }\n+        synchronized void increment() {\n+            count++;\n+        }\n+        public void run() {\n+            System.out.println(\"WaitNotifyTest started.\");\n+            for (int t = 0; t < THREADS; t++) {\n+                TF.newThread(() -> {\n+                    for (int i = 0; i < ITERATIONS; i++) {\n+                        startLatchChannel.receive().await();\n+                        increment();\n+                        endLatchChannel.receive().countDown();\n+                    }\n+                }).start();\n+            }\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                WaitNotifyCountDownLatch startLatch = new WaitNotifyCountDownLatch(1);\n+                WaitNotifyCountDownLatch endLatch = new WaitNotifyCountDownLatch(THREADS);\n+                int count = getCount();\n+                if (count != i * THREADS) {\n+                    throw new RuntimeException(\"WaitNotifyTest: Invalid Count \" + count +\n+                                               \" pre-iteration \" + i);\n+                }\n+                startLatchChannel.send(startLatch, 10);\n+                startLatch.countDown();\n+                endLatchChannel.send(endLatch, 10);\n+                endLatch.await();\n+            }\n+            int count = getCount();\n+            if (count != ITERATIONS * THREADS) {\n+                throw new RuntimeException(\"WaitNotifyTest: Invalid Count \" + count);\n+            }\n+            System.out.println(\"WaitNotifyTest passed.\");\n+        }\n+    }\n+\n+    static class RandomDepthTest implements Runnable {\n+        static final int THREADS = 10;\n+        static final int ITERATIONS = 10_000;\n+        static final int MAX_DEPTH = 20;\n+        static final int MAX_RECURSION_COUNT = 10;\n+        static final double RECURSION_CHANCE = .25;\n+        final Random random = Utils.getRandomInstance();\n+        final Locker lockers[] = new Locker[MAX_DEPTH];\n+        final CyclicBarrier syncBarrier = new CyclicBarrier(THREADS + 1);\n+        int count = 0;\n+\n+        class Locker {\n+            final int depth;\n+            Locker(int depth) {\n+                this.depth = depth;\n+            }\n+            synchronized int getCount() {\n+                if (depth == MAX_DEPTH) {\n+                    return count;\n+                }\n+                return lockers[depth].getCount();\n+            }\n+            synchronized void increment(int recursion_count) {\n+                if (recursion_count != MAX_RECURSION_COUNT &&\n+                    random.nextDouble() < RECURSION_CHANCE) {\n+                    this.increment(recursion_count + 1);\n+                    return;\n+                }\n+                if (depth == MAX_DEPTH) {\n+                    count++;\n+                    return;\n+                }\n+                lockers[depth + random.nextInt(MAX_DEPTH - depth)].increment(recursion_count);\n+            }\n+            synchronized Locker create() {\n+                if (depth != MAX_DEPTH) {\n+                    lockers[depth] = (new Locker(depth + 1)).create();\n+                }\n+                return this;\n+            }\n+        }\n+        int getCount() {\n+            return lockers[0].getCount();\n+        }\n+        void increment() {\n+            lockers[random.nextInt(MAX_DEPTH)].increment(0);\n+        }\n+        void create() {\n+            lockers[0] = (new Locker(1)).create();\n+        }\n+        void syncPoint() {\n+            try {\n+                syncBarrier.await();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"RandomDepthTest: Unexpected interrupt\", e);\n+            } catch (BrokenBarrierException e) {\n+                throw new RuntimeException(\"RandomDepthTest: Unexpected broken barrier\", e);\n+            }\n+        }\n+        public void run() {\n+            System.out.println(\"RandomDepthTest started.\");\n+            for (int t = 0; t < THREADS; t++) {\n+                TF.newThread(() -> {\n+                    syncPoint();\n+                    for (int i = 0; i < ITERATIONS; i++) {\n+                        increment();\n+                    }\n+                    syncPoint();\n+                }).start();\n+            }\n+            create();\n+            syncPoint();\n+            syncPoint();\n+            int count = getCount();\n+            if (count != THREADS * ITERATIONS) {\n+                throw new RuntimeException(\"RandomDepthTest: Invalid Count \" + count);\n+            }\n+            System.out.println(\"RandomDepthTest passed.\");\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        Stream.of(\n+            TF.newThread(new WaitNotifyTest()),\n+            TF.newThread(new RandomDepthTest())\n+        ).map(t -> {\n+            t.start();\n+            return t;\n+        }).forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"UseObjectMonitorTableTest: Unexpected interrupt\", e);\n+            }\n+        });\n+\n+        System.out.println(\"UseObjectMonitorTableTest passed.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/UseObjectMonitorTableTest.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -119,2 +119,3 @@\n-                                     \"|(java.lang.OutOfMemoryError: Java heap space)\" +\n-                                     \"|(Initial heap size set to a larger value than the maximum heap size))\";\n+                                     \"|(Initial heap size set to a larger value than the maximum heap size)\" +\n+                                     \"|(java.lang.OutOfMemoryError)\" +\n+                                     \"|(Error: A JNI error has occurred, please check your installation and try again))\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestParallelGCWithCDS.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8293650\n+ * @requires vm.cds\n+ * @requires vm.bits == 64\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.gc.G1\n+ * @requires vm.gc == null\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/Hello.java\n+ * @run driver TestShenandoahWithCDS\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestShenandoahWithCDS {\n+    public final static String HELLO = \"Hello World\";\n+    static String helloJar;\n+\n+    public static void main(String... args) throws Exception {\n+        helloJar = JarBuilder.build(\"hello\", \"Hello\");\n+\n+        \/\/ Run with the variety of region sizes, and combinations\n+        \/\/ of G1\/Shenandoah at dump\/exec times. \"-1\" means to use G1.\n+        final int[] regionSizes = { -1, 256, 512, 1024, 2048 };\n+\n+        for (int dumpRegionSize : regionSizes) {\n+            for (int execRegionSize : regionSizes) {\n+                test(dumpRegionSize, execRegionSize);\n+            }\n+        }\n+    }\n+\n+    static void test(int dumpRegionSize, int execRegionSize) throws Exception {\n+        String exp = \"-XX:+UnlockExperimentalVMOptions\";\n+        String optDumpGC = (dumpRegionSize != -1) ? \"-XX:+UseShenandoahGC\" : \"-XX:+UseG1GC\";\n+        String optExecGC = (execRegionSize != -1) ? \"-XX:+UseShenandoahGC\" : \"-XX:+UseG1GC\";\n+        String optDumpRegionSize = (dumpRegionSize != -1) ? \"-XX:ShenandoahRegionSize=\" + dumpRegionSize + \"K\" : exp;\n+        String optExecRegionSize = (execRegionSize != -1) ? \"-XX:ShenandoahRegionSize=\" + execRegionSize + \"K\" : exp;\n+        OutputAnalyzer out;\n+\n+        System.out.println(\"0. Dump with \" + optDumpGC + \" and \" + optDumpRegionSize);\n+        out = TestCommon.dump(helloJar,\n+                              new String[] {\"Hello\"},\n+                              exp,\n+                              \"-Xmx1g\",\n+                              optDumpGC,\n+                              optDumpRegionSize,\n+                              \"-Xlog:cds\");\n+        out.shouldContain(\"Dumping shared data to file:\");\n+        out.shouldHaveExitValue(0);\n+\n+        System.out.println(\"1. Exec with \" + optExecGC + \" and \" + optExecRegionSize);\n+        out = TestCommon.exec(helloJar,\n+                              exp,\n+                              \"-Xmx1g\",\n+                              optExecGC,\n+                              optExecRegionSize,\n+                              \"-Xlog:cds\",\n+                              \"Hello\");\n+        out.shouldContain(HELLO);\n+        out.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestShenandoahWithCDS.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8056900\n+ * @bug 8056900 8338888\n@@ -31,1 +31,1 @@\n- * @run main\/native NoClassDefFoundErrorTest\n+ * @run main\/native\/othervm -Xlog:exceptions=info NoClassDefFoundErrorTest\n@@ -39,0 +39,1 @@\n+    \/\/ Use the specified name\n@@ -41,0 +42,5 @@\n+    \/\/ Use a name longer than a Java string - returns false\n+    \/\/ if native allocation failed.\n+    static native boolean tryCallDefineClass();\n+    static native boolean tryCallFindClass();\n+\n@@ -57,1 +63,1 @@\n-        \/\/ Test JVM_DefineClass() with long name.\n+        System.out.println(\"Test JVM_DefineClass() with long name\");\n@@ -67,1 +73,1 @@\n-        \/\/ Test JNI_DefineClass() with long name.\n+        System.out.println(\"Test JNI_DefineClass() with long name\");\n@@ -77,1 +83,1 @@\n-        \/\/ Test JNI_FindClass() with long name.\n+        System.out.println(\"Test JNI_FindClass() with long name\");\n@@ -80,1 +86,1 @@\n-            throw new RuntimeException(\"DefineClass did not throw expected NoClassDefFoundError\");\n+            throw new RuntimeException(\"FindClass did not throw expected NoClassDefFoundError\");\n@@ -87,1 +93,1 @@\n-        \/\/ Test JNI_FindClass() with null name.\n+        System.out.println(\"Test JNI_FindClass() with null name\");\n@@ -96,0 +102,26 @@\n+\n+        System.out.println(\"Test JNI_DefineClass() with giant name\");\n+        try {\n+            if (tryCallDefineClass()) {\n+                throw new RuntimeException(\"DefineClass did not throw expected NoClassDefFoundError\");\n+            } else {\n+                System.out.println(\"Test skipped due to native allocation failure\");\n+            }\n+        } catch (NoClassDefFoundError e) {\n+            if (!e.getMessage().contains(\"Class name exceeds maximum length of \")) {\n+                throw new RuntimeException(\"Wrong NoClassDefFoundError: \" + e.getMessage());\n+            }\n+        }\n+\n+        System.out.println(\"Test JNI_FindClass() with giant name\");\n+        try {\n+            if (tryCallFindClass()) {\n+                throw new RuntimeException(\"FindClass did not throw expected NoClassDefFoundError\");\n+            } else {\n+                System.out.println(\"Test skipped due to native allocation failure\");\n+            }\n+        } catch (NoClassDefFoundError e) {\n+            if (!e.getMessage().contains(\"Class name exceeds maximum length of \")) {\n+                throw new RuntimeException(\"Wrong NoClassDefFoundError: \" + e.getMessage());\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/NoClassDefFoundError\/NoClassDefFoundErrorTest.java","additions":40,"deletions":8,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,4 @@\n+#include <limits.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n@@ -45,0 +49,31 @@\n+static char* giant_string() {\n+    size_t len = ((size_t)INT_MAX) + 3;\n+    char* c_name = malloc(len * sizeof(char));\n+    if (c_name != NULL) {\n+        memset(c_name, 'Y', len - 1);\n+        c_name[len - 1] = '\\0';\n+    }\n+    return c_name;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NoClassDefFoundErrorTest_tryCallDefineClass(JNIEnv *env, jclass klass) {\n+    char* c_name = giant_string();\n+    if (c_name != NULL) {\n+        (*env)->DefineClass(env, c_name, NULL, NULL, 0);\n+        free(c_name);\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NoClassDefFoundErrorTest_tryCallFindClass(JNIEnv *env, jclass klass) {\n+    char* c_name = giant_string();\n+    if (c_name != NULL) {\n+        jclass cls = (*env)->FindClass(env, c_name);\n+        free(c_name);\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/NoClassDefFoundError\/libNoClassDefFoundErrorTest.c","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class LastJsr\n+{\n+    public static Method test:\"()V\"\n+    stack 100 locals 100\n+    {\n+        return;\n+    LABEL:\n+        nop;\n+        jsr LABEL; \/\/ bci=2. Compute bci + length(jsr) -> bci = 5 accessed, out of bounds.\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/LastJsr.jasm","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class LastJsrReachable\n+{\n+    public static Method test:\"()V\"\n+    stack 100 locals 100\n+    {\n+        goto LB2;\n+    LABEL:\n+        return;\n+    LB2:\n+        nop;\n+        jsr LABEL;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/LastJsrReachable.jasm","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335664\n+ * @summary Ensure a program that ends with a JSR does not crash\n+ * @library \/test\/lib\n+ * @compile LastJsr.jasm\n+ * @compile LastJsrReachable.jasm\n+ * @run main\/othervm LastJsrTest\n+ *\/\n+\n+public class LastJsrTest {\n+    public static void main(String[] args) {\n+        LastJsr.test();\n+        LastJsrReachable.test();\n+        System.out.println(\"PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/LastJsrTest.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -52,0 +52,1 @@\n+                                                                 \"--enable-native-access=ALL-UNNAMED\",\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestCheckedReleaseArrayElements.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        output.shouldContain(\"inflate(has_locker):\");\n+        output.shouldContain(\"inflate:\");\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/MonitorInflationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,8 +50,0 @@\n-\n-\/*\n- * @test id=logging\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:setfmodw001 -XX:TraceJVMTI=ec+,+ioe,+s -Xlog:jvmti=trace:file=vm.%p.log nsk.jvmti.SetFieldModificationWatch.setfmodw001\n- *\/\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java 8005021,8332158 macosx-all,linux-x64\n+java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java 8005021 macosx-all\n@@ -746,0 +746,1 @@\n+jdk\/jfr\/event\/compiler\/TestCodeSweeper.java                     8338127 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -87,0 +87,5 @@\n+\n+            \/\/ Read the first character of output to make sure we've waited until the\n+            \/\/ debuggee is ready. This will be the debug agent's \"Listening...\" message.\n+            char firstChar = (char)is.read();\n+\n@@ -95,2 +100,2 @@\n-            System.out.println(\"Deuggee output:\");\n-            System.out.println(out.getOutput());\n+            System.out.println(\"Debuggee output:\");\n+            System.out.println(firstChar + out.getOutput());\n","filename":"test\/jdk\/com\/sun\/jdi\/DataDumpTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,3 @@\n- * @comment Don't allow -Xcomp or -Xint as they impact memory useage and number of iterations\n- * @requires (vm.compMode == \"Xmixed\")\n+ * @comment Don't allow -Xcomp or -Xint as they impact memory useage and number of iterations.\n+ *          Require compressed oops because not doing so increases memory usage.\n+ * @requires (vm.compMode == \"Xmixed\") & vm.opt.final.UseCompressedOops\n","filename":"test\/jdk\/com\/sun\/jdi\/ThreadMemoryLeakTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+import java.io.File;\n+import java.io.IOException;\n+\n+import javax.imageio.ImageIO;\n@@ -81,0 +85,6 @@\n+                try {\n+                    ImageIO.write(imageAfterChecked, \"png\",\n+                            new File(\"imageAfterChecked.png\"));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n","filename":"test\/jdk\/java\/awt\/Checkbox\/CheckboxCheckerScalingTest.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    private static final int OFFSET = 2;\n+    private static final int OFFSET = 5;\n","filename":"test\/jdk\/java\/awt\/Frame\/MaximizeUndecoratedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+ * @library \/test\/lib\n+ * @build   jdk.test.lib.Platform\n@@ -33,3 +35,8 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.*;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+import jdk.test.lib.Platform;\n@@ -44,0 +51,3 @@\n+        if (Platform.isOnWayland()) {\n+            return;\n+        }\n","filename":"test\/jdk\/java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -122,0 +122,24 @@\n+    static final MemoryLayout A_VALUE = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"b\")\n+                    .withTargetLayout(ValueLayout.JAVA_INT)\n+    );\n+\n+    static final VarHandle a_value = A_VALUE.varHandle(\n+            PathElement.groupElement(\"b\"), PathElement.dereferenceElement());\n+\n+    @Test\n+    public void testDerefValue() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            \/\/ init structs\n+            MemorySegment a = arena.allocate(A);\n+            MemorySegment b = arena.allocate(ValueLayout.JAVA_INT);\n+            \/\/ init struct fields\n+            a.set(ValueLayout.ADDRESS, 0, b);\n+            b.set(ValueLayout.JAVA_INT, 0, 42);\n+            \/\/ dereference\n+            int val = (int) a_value.get(a, 0L);\n+            assertEquals(val, 42);\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -335,0 +335,8 @@\n+    @Test(dataProvider = \"testLayouts\", expectedExceptions = ArithmeticException.class)\n+    public void testOffsetHandleOverflow(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                         long expectedByteOffset) throws Throwable {\n+        MethodHandle byteOffsetHandle = layout.byteOffsetHandle(pathElements);\n+        byteOffsetHandle = byteOffsetHandle.asSpreader(long[].class, indexes.length);\n+        byteOffsetHandle.invoke(Long.MAX_VALUE, indexes);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -91,1 +91,5 @@\n-            RestrictedMethod.of(ModuleLayer.Controller.class, \"enableNativeAccess\", ModuleLayer.Controller.class, Module.class)\n+            RestrictedMethod.of(ModuleLayer.Controller.class, \"enableNativeAccess\", ModuleLayer.Controller.class, Module.class),\n+            RestrictedMethod.of(System.class, \"load\", void.class, String.class),\n+            RestrictedMethod.of(System.class, \"loadLibrary\", void.class, String.class),\n+            RestrictedMethod.of(Runtime.class, \"load\", void.class, String.class),\n+            RestrictedMethod.of(Runtime.class, \"loadLibrary\", void.class, String.class)\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+ *        panama_jni_load_module\/*\n+ *        panama_jni_def_module\/*\n+ *        panama_jni_use_module\/*\n+ *\n@@ -65,1 +69,0 @@\n-                { \"panama_enable_native_access_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--enable-native-access=ALL-UNNAMED\"} },\n@@ -70,1 +73,1 @@\n-                { \"panama_comma_separated_enable_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--enable-native-access=java.base,ALL-UNNAMED\"} },\n+                { \"panama_comma_separated_enable_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--enable-native-access=panama_jni_load_module,panama_jni_def_module,ALL-UNNAMED\"} },\n@@ -75,1 +78,6 @@\n-                { \"panama_enable_native_access_warn_jni\", PANAMA_JNI, successWithWarning(\"ALL-UNNAMED\"), new String[]{} },\n+                { \"panama_enable_native_access_warn_jni\", PANAMA_JNI, successWithWarnings(\"panama_jni_load_module\", \"panama_jni_def_module\", \"ALL-UNNAMED\"), new String[]{} },\n+\n+                { \"panama_enable_native_access_allow\", PANAMA_MAIN, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n+                { \"panama_enable_native_access_allow_reflection\", PANAMA_REFLECTION, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n+                { \"panama_enable_native_access_allow_invoke\", PANAMA_INVOKE, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n+                { \"panama_enable_native_access_allow_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n@@ -79,0 +87,1 @@\n+                { \"panama_allow_unnamed_module_native_access\", UNNAMED, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n@@ -134,1 +143,1 @@\n-        run(\"panama_enable_native_access_warn_unknown_module\", PANAMA_MAIN,\n+        run(\"panama_deny_bad_unknown_module\", PANAMA_MAIN,\n@@ -136,2 +145,2 @@\n-                \"--enable-native-access=BAD\");\n-        run(\"panama_no_all_module_path_blanket_native_access\", PANAMA_MAIN,\n+                \"--illegal-native-access=deny\", \"--enable-native-access=BAD\");\n+        run(\"panama_deny_bad_all_module_path_module\", PANAMA_MAIN,\n@@ -139,1 +148,27 @@\n-                \"--enable-native-access=ALL-MODULE-PATH\" );\n+                \"--illegal-native-access=deny\", \"--enable-native-access=ALL-MODULE-PATH\" );\n+        run(\"panama_deny_no_module_main\", PANAMA_MAIN,\n+                failWithError(\"module panama_module\"),\n+                \"--illegal-native-access=deny\");\n+        run(\"panama_deny_no_module_invoke\", PANAMA_INVOKE,\n+                failWithError(\"module panama_module\"),\n+                \"--illegal-native-access=deny\");\n+        run(\"panama_deny_no_module_reflection\", PANAMA_REFLECTION,\n+                failWithError(\"module panama_module\"),\n+                \"--illegal-native-access=deny\");\n+        run(\"panama_deny_no_module_jni\", PANAMA_JNI,\n+                failWithError(\"module panama_jni_load_module\"),\n+                \"--illegal-native-access=deny\");\n+    }\n+\n+    public void testDetailedWarningMessage() throws Exception {\n+        run(\"panama_enable_native_access_warn_jni\", PANAMA_JNI,\n+                success()\n+                        \/\/ call to System::loadLibrary from panama_jni_load_module\n+                        .expect(\"WARNING: A restricted method in java.lang.System has been called\")\n+                        .expect(\"WARNING: java.lang.System::loadLibrary has been called by org.openjdk.jni.PanamaMainJNI in module panama_jni_load_module\")\n+                        \/\/ JNI native method binding in panama_jni_def_module\n+                        .expect(\"WARNING: A native method in org.openjdk.jni.def.PanamaJNIDef has been bound\")\n+                        .expect(\"WARNING: org.openjdk.jni.def.PanamaJNIDef::nativeLinker0 is declared in module panama_jni_def_module\")\n+                        \/\/ upcall to Linker::downcallHandle from JNI code\n+                        .expect(\"WARNING: A restricted method in java.lang.foreign.Linker has been called\")\n+                        .expect(\"WARNING: java.lang.foreign.Linker::downcallHandle has been called by code in an unnamed module\"));\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccess.java","additions":42,"deletions":7,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-    static final String PANAMA_JNI_CLS = \"org.openjdk.foreigntest.PanamaMainJNI\";\n-    static final String PANAMA_JNI = \"panama_module\/\" + PANAMA_JNI_CLS;\n+    static final String PANAMA_JNI_CLS = \"org.openjdk.jni.PanamaMainJNI\";\n+    static final String PANAMA_JNI = \"panama_jni_load_module\/\" + PANAMA_JNI_CLS;\n@@ -102,0 +102,8 @@\n+    static Result successWithWarnings(String... moduleNames) {\n+        Result result = success();\n+        for (String moduleName : moduleNames) {\n+            result = result.expect(\"WARNING\").expect(\"--enable-native-access=\" + moduleName);\n+        }\n+        return result;\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessBase.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        String errMsg = \"Illegal native access from: module panama_module\";\n+        String errMsg = \"Illegal native access from module panama_module\";\n@@ -76,0 +76,1 @@\n+        list.add(\"--illegal-native-access=deny\");\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessDynamic.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module panama_jni_def_module {\n+    exports org.openjdk.jni.def;\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_def_module\/module-info.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jni.def;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+\n+public class PanamaJNIDef {\n+\n+    public static native void nativeLinker0(Linker linker, FunctionDescriptor desc, Linker.Option[] options);\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_def_module\/org\/openjdk\/jni\/def\/PanamaJNIDef.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -50,1 +50,1 @@\n-    Java_org_openjdk_foreigntest_PanamaMainJNI_nativeLinker0(JNIEnv *env, jclass cls, jobject linker, jobject desc, jobjectArray opts) {\n+    Java_org_openjdk_jni_def_PanamaJNIDef_nativeLinker0(JNIEnv *env, jclass cls, jobject linker, jobject desc, jobjectArray opts) {\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_def_module\/org\/openjdk\/jni\/def\/libLinkerInvokerModule.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/libLinkerInvokerModule.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module panama_jni_load_module {\n+    exports org.openjdk.jni;\n+    requires panama_jni_use_module;\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_load_module\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jni;\n+\n+import org.openjdk.jni.use.PanamaJNIUse;\n+\n+public class PanamaMainJNI {\n+\n+    public static void main(String[] args) {\n+        System.loadLibrary(\"LinkerInvokerModule\");\n+        PanamaJNIUse.run();\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_load_module\/org\/openjdk\/jni\/PanamaMainJNI.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module panama_jni_use_module {\n+    exports org.openjdk.jni.use;\n+    requires panama_jni_def_module;\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_use_module\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jni.use;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+\n+import org.openjdk.jni.def.PanamaJNIDef;\n+\n+public class PanamaJNIUse {\n+    public static void run() {\n+        testDirectAccessCLinker();\n+    }\n+\n+    public static void testDirectAccessCLinker() {\n+        System.out.println(\"Trying to get downcall handle\");\n+        PanamaJNIDef.nativeLinker0(Linker.nativeLinker(), FunctionDescriptor.ofVoid(), new Linker.Option[0]);\n+        System.out.println(\"Got downcall handle\");\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_use_module\/org\/openjdk\/jni\/use\/PanamaJNIUse.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -1,23 +0,0 @@\n-package org.openjdk.foreigntest;\n-\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-\n-public class PanamaMainJNI {\n-\n-    static {\n-        System.loadLibrary(\"LinkerInvokerModule\");\n-    }\n-\n-    public static void main(String[] args) {\n-        testDirectAccessCLinker();\n-    }\n-\n-    public static void testDirectAccessCLinker() {\n-        System.out.println(\"Trying to get downcall handle\");\n-        nativeLinker0(Linker.nativeLinker(), FunctionDescriptor.ofVoid(), new Linker.Option[0]);\n-        System.out.println(\"Got downcall handle\");\n-    }\n-\n-    static native void nativeLinker0(Linker linker, FunctionDescriptor desc, Linker.Option[] options);\n-}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainJNI.java","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm --enable-native-access=invoker_module\n+ * @run testng\/othervm --illegal-native-access=deny --enable-native-access=invoker_module\n","filename":"test\/jdk\/java\/foreign\/handles\/Driver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+        addDefaultMapping(Runtime.class, Runtime.getRuntime());\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,0 +74,12 @@\n+                    { MethodHandles.lookup().findStatic(System.class, \"load\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"System::load\" },\n+                    { MethodHandles.lookup().findStatic(System.class, \"loadLibrary\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"System::loadLibrary\" },\n+                    { MethodHandles.lookup().findVirtual(Runtime.class, \"load\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"Runtime::load\" },\n+                    { MethodHandles.lookup().findVirtual(Runtime.class, \"loadLibrary\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"Runtime::loadLibrary\" }\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.StringBuilder;\n+\n+import java.lang.invoke.*;\n+import java.lang.management.ManagementFactory;\n+\n+\/**\n+ * @test\n+ * @summary Test whether the hidden class unloading of StringConcatFactory works\n+ *\n+ * @requires vm.flagless\n+ * @run main\/othervm -Xmx8M -Xms8M -Xverify:all HiddenClassUnloading\n+ * @run main\/othervm -Xmx8M -Xms8M -Xverify:all -XX:-CompactStrings HiddenClassUnloading\n+ *\/\n+public class HiddenClassUnloading {\n+    public static void main(String[] args) throws Throwable {\n+        var lookup = MethodHandles.lookup();\n+        var types  = new Class<?>[] {\n+                int.class, long.class, double.class, float.class, char.class, boolean.class, String.class,\n+        };\n+\n+        long initUnloadedClassCount = ManagementFactory.getClassLoadingMXBean().getUnloadedClassCount();\n+\n+        for (int i = 0; i < 2000; i++) {\n+            int radix = types.length;\n+            String str = Integer.toString(i, radix);\n+            int length = str.length();\n+            var ptypes = new Class[length];\n+            for (int j = 0; j < length; j++) {\n+                int index = Integer.parseInt(str.substring(j, j + 1), radix);\n+                ptypes[j] = types[index];\n+            }\n+            StringConcatFactory.makeConcatWithConstants(\n+                    lookup,\n+                    \"concat\",\n+                    MethodType.methodType(String.class, ptypes),\n+                    \"\\1\".repeat(length), \/\/ recipe\n+                    new Object[0]\n+            );\n+        }\n+\n+        long unloadedClassCount = ManagementFactory.getClassLoadingMXBean().getUnloadedClassCount();\n+        if (initUnloadedClassCount == unloadedClassCount) {\n+            throw new RuntimeException(\"unloadedClassCount is zero\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/concat\/HiddenClassUnloading.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -72,1 +72,1 @@\n-       int ret = ConstantUtils.skipOverFieldSignature(\"(V)V\", 1, 4, false);\n+       int ret = ConstantUtils.skipOverFieldSignature(\"(V)V\", 1, 4);\n","filename":"test\/jdk\/java\/lang\/constant\/boottest\/java.base\/jdk\/internal\/constant\/ConstantUtilsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import java.nio.file.FileStore;\n@@ -50,0 +51,1 @@\n+import org.testng.SkipException;\n@@ -210,2 +212,7 @@\n-        if (!Files.getFileStore(Paths.get(\".\"))\n-                  .supportsFileAttributeView(PosixFileAttributeView.class)) {\n+        FileStore fs;\n+        try {\n+            fs = Files.getFileStore(Paths.get(\".\"));\n+        } catch (IOException e) {\n+            throw new SkipException(\"WARNING: IOException occurred: \" + e + \", Skipping testDumpDirNotWritable test.\");\n+        }\n+        if (!fs.supportsFileAttributeView(PosixFileAttributeView.class)) {\n@@ -213,6 +220,1 @@\n-            \/\/ We would like to skip the test with a cause with\n-            \/\/     throw new SkipException(\"Posix not supported\");\n-            \/\/ but jtreg will report failure so we just pass the test\n-            \/\/ which we can look at if jtreg changed its behavior\n-            System.out.println(\"WARNING: POSIX is not supported. Skipping testDumpDirNotWritable test.\");\n-            return;\n+            throw new SkipException(\"WARNING: POSIX is not supported. Skipping testDumpDirNotWritable test.\");\n@@ -230,2 +232,1 @@\n-                System.out.println(\"WARNING: The dump directory is writeable. Skipping testDumpDirNotWritable test.\");\n-                return;\n+                throw new SkipException(\"WARNING: The dump directory is writeable. Skipping testDumpDirNotWritable test.\");\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LogGeneratedClassesTest.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8338139\n+ * @summary Basic unit test of ClassLoadingMXBean.set\/isVerbose() when\n+ *          related unified logging is enabled.\n+ *\n+ * @run main\/othervm -Xlog:class+load=trace:file=vm.log TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=debug:file=vm.log TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=info:file=vm.log TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:class+load=trace TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=debug TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=info TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=warning TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=error TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=off TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:class+load*=trace TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=debug TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=warning TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=error TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=off TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=trace TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=debug TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=info TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=warning TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=error TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=off TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:all=trace:file=vm.log TestVerboseClassLoading false\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ClassLoadingMXBean;\n+\n+public class TestVerboseClassLoading {\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassLoadingMXBean mxBean = ManagementFactory.getClassLoadingMXBean();\n+        boolean expected = Boolean.parseBoolean(args[0]);\n+        boolean initial = mxBean.isVerbose();\n+        if (expected != initial) {\n+            throw new Error(\"Initial verbosity setting was unexpectedly \" + initial);\n+        }\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+        mxBean.setVerbose(true);\n+        if (!mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still disabled\");\n+        }\n+        \/\/ Turn off again as a double-check and also to avoid excessive logging\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/management\/ClassLoadingMXBean\/TestVerboseClassLoading.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8338139\n+ * @summary Basic unit test of TestVerboseMemory.set\/isVerbose() when\n+ *          related unified logging is enabled.\n+ *\n+ * @run main\/othervm -Xlog:gc=trace:file=vm.log TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=debug:file=vm.log TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=info:file=vm.log TestVerboseMemory false\n+ *\n+ * @run main\/othervm -Xlog:gc=off TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=error TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=warning TestVerboseMemory false\n+ *\n+ * @run main\/othervm -Xlog:gc=info TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc=trace TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc=debug TestVerboseMemory true\n+ *\n+ * @run main\/othervm -Xlog:gc*=info TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc*=debug TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc*=trace TestVerboseMemory true\n+ *\n+ * @run main\/othervm -Xlog:gc=info,gc+init=off TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc=off,gc+init=info TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc,gc+init TestVerboseMemory true\n+ *\n+ * @run main\/othervm -Xlog:all=trace:file=vm.log TestVerboseMemory false\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+public class TestVerboseMemory {\n+\n+    public static void main(String[] args) throws Exception {\n+        MemoryMXBean mxBean = ManagementFactory.getMemoryMXBean();\n+        boolean expected = Boolean.parseBoolean(args[0]);\n+        boolean initial = mxBean.isVerbose();\n+        if (expected != initial) {\n+            throw new Error(\"Initial verbosity setting was unexpectedly \" + initial);\n+        }\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+        mxBean.setVerbose(true);\n+        if (!mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still disabled\");\n+        }\n+        \/\/ Turn off again as a double-check and also to avoid excessive logging\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/TestVerboseMemory.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+\n+import jdk.test.lib.util.JarUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+\/*\n+ * @test\n+ * @bug 8338445\n+ * @summary verify that the jdk.internal.loader.URLClassPath closes the JarFile\n+ *          instances that it no longer uses for loading\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.util.JarUtils\n+ * @comment This test expects MalformedURLException for some specific URLs.\n+ *          We use othervm to prevent interference from other tests which\n+ *          might have installed custom URLStreamHandler(s)\n+ * @run junit\/othervm JarLoaderCloseTest\n+ *\/\n+public class JarLoaderCloseTest {\n+\n+    private static final String RESOURCE_NAME = \"foo-bar.txt\";\n+    private static final String RESOURCE_CONTENT = \"Hello world\";\n+    private static final Path TEST_SCRATCH_DIR = Path.of(\".\");\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        \/\/ create a file which will be added to the JAR file that gets tested\n+        Files.writeString(TEST_SCRATCH_DIR.resolve(RESOURCE_NAME), RESOURCE_CONTENT);\n+    }\n+\n+    \/*\n+     * Creates a JAR file with a manifest which has a Class-Path entry value with malformed URLs.\n+     * Then uses a URLClassLoader backed by the JAR file in its classpath, loads some resource,\n+     * closes the URLClassLoader and then expects that the underlying JAR file can be deleted\n+     * from the filesystem.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"C:\\\\foo\\\\bar\\\\hello\/world.jar lib2.jar\",\n+            \"C:\/hello\/world\/foo.jar\",\n+            \"lib4.jar C:\\\\bar\\\\foo\\\\world\/hello.jar\"\n+    })\n+    public void testMalformedClassPathEntry(final String classPathValue) throws Exception {\n+        final Manifest manifest = createManifestWithClassPath(classPathValue);\n+        final Path jar = Files.createTempFile(TEST_SCRATCH_DIR, \"8338445\", \".jar\");\n+        \/\/ create the JAR file with the given manifest and an arbitrary file\n+        JarUtils.createJarFile(jar, manifest, TEST_SCRATCH_DIR, Path.of(RESOURCE_NAME));\n+        System.out.println(\"created jar at \" + jar + \" with manifest:\");\n+        manifest.write(System.out);\n+        final URL[] urlClassPath = new URL[]{jar.toUri().toURL()};\n+        \/\/ Create a URLClassLoader backed by the JAR file and load a non-existent resource just to\n+        \/\/ exercise the URLClassPath code of loading the jar and parsing the Class-Path entry.\n+        \/\/ Then close the classloader. After the classloader is closed\n+        \/\/ issue a delete on the underlying JAR file on the filesystem. The delete is expected\n+        \/\/ to succeed.\n+        try (final URLClassLoader cl = new URLClassLoader(urlClassPath)) {\n+            try (final InputStream is = cl.getResourceAsStream(\"non-existent.txt\")) {\n+                assertNull(is, \"unexpectedly found a resource in classpath \"\n+                        + Arrays.toString(urlClassPath));\n+            }\n+        }\n+        \/\/ now delete the JAR file and verify the delete worked\n+        Files.delete(jar);\n+        assertFalse(Files.exists(jar), jar + \" exists even after being deleted\");\n+    }\n+\n+    \/*\n+     * Creates a JAR file with a manifest which has a Class-Path entry value with URLs\n+     * that are parsable but point to files that don't exist on the filesystem.\n+     * Then uses a URLClassLoader backed by the JAR file in its classpath, loads some resource,\n+     * closes the URLClassLoader and then expects that the underlying JAR file can be deleted\n+     * from the filesystem.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/home\/me\/hello\/world.jar lib9.jar\",\n+            \"lib10.jar\"\n+    })\n+    public void testParsableClassPathEntry(final String classPathValue) throws Exception {\n+        final Manifest manifest = createManifestWithClassPath(classPathValue);\n+        final Path jar = Files.createTempFile(TEST_SCRATCH_DIR, \"8338445\", \".jar\");\n+        \/\/ create the JAR file with the given manifest and an arbitrary file\n+        JarUtils.createJarFile(jar, manifest, TEST_SCRATCH_DIR, Path.of(RESOURCE_NAME));\n+        System.out.println(\"created jar at \" + jar + \" with manifest:\");\n+        manifest.write(System.out);\n+        final URL[] urlClassPath = new URL[]{jar.toUri().toURL()};\n+        \/\/ Create a URLClassLoader backed by the JAR file and load a resource\n+        \/\/ and verify the resource contents.\n+        \/\/ Then close the classloader. After the classloader is closed\n+        \/\/ issue a delete on the underlying JAR file on the filesystem. The delete is expected\n+        \/\/ to succeed.\n+        try (final URLClassLoader cl = new URLClassLoader(urlClassPath)) {\n+            try (final InputStream is = cl.getResourceAsStream(RESOURCE_NAME)) {\n+                assertNotNull(is, RESOURCE_NAME + \" not located by classloader in classpath \"\n+                        + Arrays.toString(urlClassPath));\n+                final String content = new String(is.readAllBytes(), US_ASCII);\n+                assertEquals(RESOURCE_CONTENT, content, \"unexpected content in \" + RESOURCE_NAME);\n+            }\n+        }\n+        \/\/ now delete the JAR file and verify the delete worked\n+        Files.delete(jar);\n+        assertFalse(Files.exists(jar), jar + \" exists even after being deleted\");\n+    }\n+\n+    private static Manifest createManifestWithClassPath(final String classPathValue) {\n+        final Manifest manifest = new Manifest();\n+        final Attributes mainAttributes = manifest.getMainAttributes();\n+        mainAttributes.putValue(\"Manifest-Version\", \"1.0\");\n+        mainAttributes.putValue(\"Class-Path\", classPathValue);\n+        return manifest;\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/URLClassLoader\/JarLoaderCloseTest.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,2 +88,2 @@\n-    URI getUri, postUri, hangUri;\n-    URI h2postUri, h2hangUri, h2endStreamUri, h2warmupURI;\n+    URI getUri, postUri, forcePostUri, hangUri;\n+    URI h2postUri, h2forcePostUri, h2hangUri, h2endStreamUri, h2warmupURI;\n@@ -100,0 +100,1 @@\n+                { forcePostUri, 200, false, HTTP_1_1 },\n@@ -102,0 +103,1 @@\n+                { h2forcePostUri, 200, false, HTTP_2 },\n@@ -130,1 +132,1 @@\n-            verifyRequest(expectedStatusCode, resp, exceptionally, testThrowable);\n+            verifyRequest(uri.getPath(), expectedStatusCode, resp, exceptionally, testThrowable);\n@@ -140,0 +142,1 @@\n+        http1TestServer.addHandler(new ForcePostHandler(), \"\/http1\/forcePost\");\n@@ -142,0 +145,1 @@\n+        forcePostUri = URI.create(\"http:\/\/\" + http1TestServer.serverAuthority() + \"\/http1\/forcePost\");\n@@ -152,0 +156,1 @@\n+        http2TestServer.addHandler(new ForcePostHandler().toHttp2Handler(), \"\/http2\/forcePost\");\n@@ -157,0 +162,1 @@\n+        h2forcePostUri = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/forcePost\");\n@@ -160,3 +166,3 @@\n-        out.printf(\"HTTP\/1.1 server listening at: %s\", http1TestServer.serverAuthority());\n-        out.printf(\"HTTP\/1.1 hang server listening at: %s\", hangUri.getRawAuthority());\n-        out.printf(\"HTTP\/2 clear server listening at: %s\", http2TestServer.serverAuthority());\n+        out.printf(\"HTTP\/1.1 server listening at: %s %n\", http1TestServer.serverAuthority());\n+        out.printf(\"HTTP\/1.1 hang server listening at: %s %n\", hangUri.getRawAuthority());\n+        out.printf(\"HTTP\/2 clear server listening at: %s %n\", http2TestServer.serverAuthority());\n@@ -210,0 +216,12 @@\n+    static class ForcePostHandler implements HttpTestHandler {\n+        @Override\n+        public void handle(HttpTestExchange exchange) throws IOException {\n+            try (InputStream is = exchange.getRequestBody()) {\n+                err.println(\"Server reading body inside the force Post\");\n+                is.readAllBytes();\n+                err.println(\"Server send 200 (length=0) in the force post\");\n+                exchange.sendResponseHeaders(200, 0);\n+            }\n+        }\n+    }\n+\n@@ -340,1 +358,4 @@\n-    private void verifyRequest(int expectedStatusCode, HttpResponse<String> resp, boolean exceptionally, Throwable testThrowable) {\n+    private void verifyRequest(String path, int expectedStatusCode, HttpResponse<String> resp, boolean exceptionally, Throwable testThrowable) {\n+        if (!exceptionally) {\n+            err.printf(\"Response code %s received for path %s %n\", resp.statusCode(), path);\n+        }\n@@ -342,1 +363,1 @@\n-            err.println(testThrowable);\n+            err.println(\"Finished exceptionally Test throwable: \" + testThrowable);\n@@ -348,1 +369,1 @@\n-            err.println(\"Request completed successfully\");\n+            err.println(\"Request completed successfully for path \" + path);\n","filename":"test\/jdk\/java\/net\/httpclient\/ExpectContinueTest.java","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import static jdk.test.lib.NetworkConfiguration.isSameInterface;\n@@ -298,2 +299,2 @@\n-        assertTrue(s.getNetworkInterface().equals(ni));\n-        assertTrue(s.getOption(IP_MULTICAST_IF).equals(ni));\n+        assertTrue(isSameInterface(s.getNetworkInterface(), ni));\n+        assertTrue(isSameInterface(s.getOption(IP_MULTICAST_IF), ni));\n@@ -318,2 +319,2 @@\n-        assertTrue(s.getOption(IP_MULTICAST_IF).equals(ni));\n-        assertTrue(s.getNetworkInterface().equals(ni));\n+        assertTrue(isSameInterface(s.getOption(IP_MULTICAST_IF), ni));\n+        assertTrue(isSameInterface(s.getNetworkInterface(), ni));\n@@ -415,1 +416,2 @@\n-        byte[] message = \"hello\".getBytes(\"UTF-8\");\n+        String msg = \"AdaptorMulticasting:  \" + System.nanoTime();\n+        byte[] message = msg.getBytes(\"UTF-8\");\n@@ -424,2 +426,16 @@\n-        p = new DatagramPacket(new byte[1024], 100);\n-        s.receive(p);\n+        while (true) {\n+            p = new DatagramPacket(new byte[1024], 100);\n+            s.receive(p);\n+            if (p.getPort() == s.getLocalPort()) {\n+                String str = new String(p.getData(), p.getOffset(), p.getLength(), \"UTF-8\");\n+                if (Arrays.equals(p.getData(), p.getOffset(), p.getLength(), message, 0, message.length)) {\n+                    System.out.format(\"Got expected message \\\"%s\\\" from %s%n\", str, p.getSocketAddress());\n+                    break;\n+                }\n+                System.out.println(\"Unexpected message received. Expected: \" + msg);\n+                System.out.println(\"Received message doesn't match - skipping: \" + str);\n+            } else {\n+                System.out.println(\"Unexpected message received. Expected message from: \" + s.getLocalAddress());\n+                System.out.println(\"Received message sender doesn't match - skipping: \" + p.getSocketAddress());\n+            }\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/AdaptorMulticasting.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.net.BindException;\n@@ -49,0 +50,1 @@\n+import java.util.function.Predicate;\n@@ -57,0 +59,32 @@\n+    interface RetryableTest<T extends Exception> {\n+        public void runTest() throws T;\n+    }\n+\n+    \/\/ retry the given lambda (RetryableTest) if an exception\n+    \/\/ that satisfies the predicate (retryOn) is caught.\n+    <T extends Exception> void testWithRetry(RetryableTest<T> test,\n+                                             Predicate<Throwable> retryOn,\n+                                             int max) throws T {\n+        for (int i=0; i < max; i++) {\n+            try {\n+                test.runTest();\n+                break;\n+            } catch (Throwable t) {\n+                if (i < max -1 && retryOn.test(t)) {\n+                    System.out.println(\"Got \" + t + \"; will retry\");\n+                } else throw t;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * When calling {@link DatagramChannel#disconnect()} a {@link BindException}\n+     * may occur. In which case we want to retry the test.\n+     *\/\n+    class BindExceptionOnDisconnect extends BindException {\n+        BindExceptionOnDisconnect(BindException x) {\n+            super(x.getMessage());\n+            initCause(x);\n+        }\n+    }\n+\n@@ -64,11 +98,3 @@\n-        try (DatagramChannel dc = DatagramChannel.open()) {\n-            System.out.println(\"Test with default\");\n-            dc.bind(new InetSocketAddress(lb, 0));\n-            test(dc);\n-            test(dc);\n-        }\n-\n-        \/\/ test with IPv6 socket\n-        if (IPSupport.hasIPv6()) {\n-            System.out.println(\"Test with IPv6 socket\");\n-            try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET6)) {\n+        System.out.println(\"Test with default\");\n+        testWithRetry(() -> {\n+            try (DatagramChannel dc = DatagramChannel.open()) {\n@@ -79,0 +105,12 @@\n+        }, BindExceptionOnDisconnect.class::isInstance, 5);\n+\n+        \/\/ test with IPv6 socket\n+        if (IPSupport.hasIPv6()) {\n+            System.out.println(\"Test with IPv6 socket\");\n+            testWithRetry(() -> {\n+                try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET6)) {\n+                    dc.bind(new InetSocketAddress(lb, 0));\n+                    test(dc);\n+                    test(dc);\n+                }\n+            }, BindExceptionOnDisconnect.class::isInstance, 5);\n@@ -84,5 +122,7 @@\n-            try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET)) {\n-                dc.bind(new InetSocketAddress(lb, 0));\n-                test(dc);\n-                test(dc);\n-            }\n+            testWithRetry(() -> {\n+                try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET)) {\n+                    dc.bind(new InetSocketAddress(lb, 0));\n+                    test(dc);\n+                    test(dc);\n+                }\n+            }, BindExceptionOnDisconnect.class::isInstance, 5);\n@@ -92,0 +132,1 @@\n+\n@@ -114,1 +155,5 @@\n-            dc.disconnect();\n+            try {\n+                dc.disconnect();\n+            } catch (BindException x) {\n+                throw new BindExceptionOnDisconnect(x);\n+            }\n@@ -137,1 +182,5 @@\n-        dc.disconnect();\n+        try {\n+            dc.disconnect();\n+        } catch (BindException x) {\n+            throw new BindExceptionOnDisconnect(x);\n+        }\n@@ -171,1 +220,5 @@\n-            dc.disconnect();\n+            try {\n+                dc.disconnect();\n+            } catch (BindException x) {\n+                throw new BindExceptionOnDisconnect(x);\n+            }\n@@ -213,1 +266,5 @@\n-            dc.disconnect();\n+            try {\n+                dc.disconnect();\n+            } catch (BindException x) {\n+                throw new BindExceptionOnDisconnect(x);\n+            }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/AfterDisconnect.java","additions":78,"deletions":21,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform Connect\n@@ -41,0 +43,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -117,0 +121,11 @@\n+                \/\/ When connecting an unbound datagram channel, the underlying\n+                \/\/ socket will first be bound to the wildcard address. On macOS,\n+                \/\/ the system may allocate the same port on which another socket\n+                \/\/ is already bound with a more specific address. This may prevent\n+                \/\/ datagrams directed at the connected socket to reach it.\n+                \/\/ To avoid this, when on macOS, we preemptively bind `dc` to the\n+                \/\/ specific address instead of letting it bind to the wildcard.\n+                if (Platform.isOSX()) {\n+                    dc.bind(new InetSocketAddress(((InetSocketAddress)connectSocketAddress).getAddress(), 0));\n+                    err.println(\"Initiator bound to: \" + connectSocketAddress);\n+                }\n@@ -120,0 +135,1 @@\n+                assert !connectSocketAddress.equals(dc.getLocalAddress());\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Connect.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- *     sender address\n+ *     sender address.\n@@ -66,0 +66,1 @@\n+            System.out.println(\"\\nReader bound to: \" + reader.getLocalAddress());\n@@ -78,0 +79,1 @@\n+            System.out.println(\"\\nSender bound to: \" + sender.getLocalAddress());\n@@ -100,0 +102,5 @@\n+            System.out.println(\"Sender bound to: \" + local);\n+            if (((InetSocketAddress)local).getPort() == remotePort) {\n+                System.out.println(\"testSend: Sender and reader have same port: skipping\");\n+                return;\n+            }\n@@ -108,0 +115,2 @@\n+                System.out.format(\"testSend: reader waiting to receive at: %s%n\",\n+                        reader.getLocalAddress());\n@@ -141,0 +150,5 @@\n+            System.out.println(\"Reader bound to: \" + remote);\n+            if (((InetSocketAddress)local).getPort() == ((InetSocketAddress)remote).getPort()) {\n+                System.out.println(\"testReceive: Sender and reader have same port: skipping\");\n+                return;\n+            }\n@@ -146,0 +160,2 @@\n+                System.out.format(\"testReceive: reader waiting to receive at: %s%n\",\n+                        reader.getLocalAddress());\n@@ -168,1 +184,6 @@\n-            return Optional.ofNullable(NetworkInterface.getByInetAddress(ia));\n+            NetworkInterface nif = NetworkInterface.getByInetAddress(ia);\n+            if (nif != null) {\n+                System.out.format(\"Selecting interface %s[%d]%n\\twith addresses:%n\\t%s%n\",\n+                    nif.getDisplayName(), nif.getIndex(), nif.inetAddresses().toList());\n+            }\n+            return Optional.ofNullable(nif);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/ManySourcesAndTargets.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,1 @@\n+            long elapsed = 0;\n@@ -104,0 +105,1 @@\n+                long start = System.nanoTime();\n@@ -105,0 +107,3 @@\n+                long waited = (System.nanoTime() - start) \/ 1000_000;\n+                elapsed += waited;\n+                buf.clear();\n@@ -110,1 +115,6 @@\n-                        throw new RuntimeException(\"Expected message not received\");\n+                        if (elapsed > 4800) {\n+                            throw new RuntimeException(\"Expected message not received\");\n+                        } else {\n+                            sel.selectedKeys().clear();\n+                            continue;\n+                        }\n@@ -126,2 +136,2 @@\n-                    System.out.format(\"Received message from %s (id=0x%x)\\n\",\n-                            sender, receivedId);\n+                    System.out.format(\"Received message from %s (id=0x%x, length=%s)\\n\",\n+                            sender, receivedId, bytes.length);\n@@ -145,1 +155,0 @@\n-                buf.rewind();\n@@ -163,0 +172,2 @@\n+        System.out.format(\"With interface=%s[%s]%n\\twith bound addresses:%n\\t%s%n\",\n+                nif.getDisplayName(), nif.getIndex(), nif.inetAddresses().toList());\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/MulticastSendReceiveTests.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- *     the channel's socket to be bound to a local address\n+ *     the channel's socket to be bound to a local address.\n+ * @run main\/othervm NotBound\n@@ -34,0 +35,3 @@\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -37,0 +41,2 @@\n+    static final CountDownLatch received = new CountDownLatch(1);\n+\n@@ -40,0 +46,1 @@\n+        System.out.println(\"Bound to: \" + dc.getLocalAddress());\n@@ -54,0 +61,1 @@\n+                    System.out.format(\"receiver bound to: %s%n\", local);\n@@ -55,10 +63,35 @@\n-                    \/\/ send message to channel to wakeup receiver\n-                    DatagramChannel sender = DatagramChannel.open();\n-                    try {\n-                        ByteBuffer bb = ByteBuffer.wrap(\"hello\".getBytes());\n-                        InetAddress lh = InetAddress.getLocalHost();\n-                        SocketAddress target =\n-                            new InetSocketAddress(lh, local.getPort());\n-                        sender.send(bb, target);\n-                    } finally {\n-                        sender.close();\n+                    boolean isAnyLocal = local.getAddress().isAnyLocalAddress();\n+                    int maxAttempts = 5;\n+                    int localPort = 0;\n+                    List<InetAddress> llh = isAnyLocal\n+                            ? List.of(InetAddress.getLocalHost(), InetAddress.getLoopbackAddress())\n+                            : List.of(local.getAddress());\n+                    SocketAddress target = null;\n+                    for (int i = 0 ; i < maxAttempts ; i++) {\n+                        InetAddress lh = llh.get(i % llh.size());\n+                        target = new InetSocketAddress(lh, local.getPort());\n+                        \/\/ send message to channel to wakeup receiver\n+                        try (DatagramChannel sender = DatagramChannel.open()) {\n+                            ByteBuffer bb = ByteBuffer.wrap(\"NotBound: hello\".getBytes());\n+                            sender.send(bb, target);\n+                            System.out.format(\"Woke up receiver: sent datagram to %s from %s%n\",\n+                                    target, sender.getLocalAddress());\n+                            localPort = ((InetSocketAddress)sender.getLocalAddress()).getPort();\n+                        }\n+                        if (received.await(250, TimeUnit.MILLISECONDS)) {\n+                            \/\/ The datagram has been received: no need to continue\n+                            \/\/ sending\n+                            break;\n+                        }\n+                        \/\/ if sender port and destination port were identical, which\n+                        \/\/ could happen on some systems, the receiver might not receive\n+                        \/\/ the datagram. So in that case we try again, bailing out if\n+                        \/\/ we had to retry too many times\n+                        if (localPort == local.getPort()) {\n+                            System.out.println(\"Local port and peer port are identical. Retrying...\");\n+                        } else {\n+                            System.out.println(\"Datagram not received after 250ms. Retrying...\");\n+                        }\n+                    }\n+                    if (localPort == local.getPort()) {\n+                        System.out.println(\"Couldn't find a port to send to \" + target);\n@@ -66,1 +99,0 @@\n-\n@@ -80,4 +112,4 @@\n-            DatagramChannel peer = DatagramChannel.open()\n-                .bind(new InetSocketAddress(0));\n-            int peerPort = ((InetSocketAddress)(peer.getLocalAddress())).getPort();\n-            try {\n+            System.out.println(\"Check that connect() binds the socket\");\n+            try (DatagramChannel peer = DatagramChannel.open()) {\n+                peer.bind(new InetSocketAddress(0));\n+                int peerPort = ((InetSocketAddress)(peer.getLocalAddress())).getPort();\n@@ -86,2 +118,0 @@\n-            } finally {\n-                peer.close();\n@@ -96,1 +126,2 @@\n-            ByteBuffer bb = ByteBuffer.wrap(\"ignore this\".getBytes());\n+            System.out.println(\"Check that send() binds the socket\");\n+            ByteBuffer bb = ByteBuffer.wrap(\"NotBound: ignore this\".getBytes());\n@@ -108,0 +139,1 @@\n+            System.out.println(\"Check that blocking receive() binds the socket\");\n@@ -111,0 +143,1 @@\n+            received.countDown();\n@@ -121,0 +154,1 @@\n+            System.out.println(\"Check that non-blocking receive() binds the socket\");\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/NotBound.java","additions":54,"deletions":20,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,3 @@\n-            System.out.format(\"Send message -> group %s (id=0x%x)\\n\",\n-                    group.getHostAddress(), id);\n+            System.out.format(\"Send message -> group [%s]:%d (id=0x%x) nif:%s[%s]%n\",\n+                    group.getHostAddress(), port, id, nif.getDisplayName(), nif.getIndex());\n+            System.out.format(\"bound address before send: %s%n\", dc.getLocalAddress());\n@@ -77,0 +78,1 @@\n+            System.out.format(\"bound address after send: %s%n\", dc.getLocalAddress());\n@@ -100,0 +102,1 @@\n+            long elapsed = 0;\n@@ -102,0 +105,1 @@\n+                long start = System.nanoTime();\n@@ -103,0 +107,3 @@\n+                long waited = (System.nanoTime() - start) \/ 1000_000;\n+                elapsed += waited;\n+                buf.clear();\n@@ -108,1 +115,7 @@\n-                        throw new RuntimeException(\"Expected message not received\");\n+                        if (elapsed > 4800) {\n+                            throw new RuntimeException(\"Expected message not received\");\n+                        } else {\n+                            sel.selectedKeys().clear();\n+                            \/\/ We haven't waited long enough,\n+                            continue;\n+                        }\n@@ -124,2 +137,2 @@\n-                    System.out.format(\"Received message from %s (id=0x%x)\\n\",\n-                            sender, receivedId);\n+                    System.out.format(\"Received message from %s (id=0x%x, length=%s)\\n\",\n+                            sender, receivedId, bytes.length);\n@@ -143,1 +156,0 @@\n-                buf.rewind();\n@@ -158,0 +170,2 @@\n+        System.out.format(\"With interface=%s[%s]%n\\twith bound addresses:%n\\t%s%n\",\n+                nif.getDisplayName(), nif.getIndex(), nif.inetAddresses().toList());\n@@ -159,4 +173,4 @@\n-        DatagramChannel dc1 = (family == UNSPEC) ?\n-            DatagramChannel.open() : DatagramChannel.open(family);\n-        DatagramChannel dc2 = (family == UNSPEC) ?\n-            DatagramChannel.open() : DatagramChannel.open(family);\n+        try (DatagramChannel dc1 = (family == UNSPEC) ?\n+                DatagramChannel.open() : DatagramChannel.open(family);\n+            DatagramChannel dc2 = (family == UNSPEC) ?\n+                DatagramChannel.open() : DatagramChannel.open(family)) {\n@@ -164,1 +178,0 @@\n-        try {\n@@ -187,1 +200,0 @@\n-            receiveDatagram(dc1, \"dc1\", false, id);\n@@ -189,4 +201,1 @@\n-\n-        } finally {\n-            dc1.close();\n-            dc2.close();\n+            receiveDatagram(dc1, \"dc1\", false, id);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Promiscuous.java","additions":26,"deletions":17,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,6 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ *        jdk.test.lib.Platform\n+ *        ReceiveISA\n+ * @run main\/othervm ReceiveISA\n+ *\n@@ -34,0 +40,3 @@\n+\n+import jdk.test.lib.Platform;\n+\n@@ -47,1 +56,5 @@\n-            dc3.socket().bind((SocketAddress) null); \/\/ bind server to any port\n+            InetAddress lh = InetAddress.getLocalHost();\n+            InetSocketAddress dest = Platform.isOSX()\n+                    ? new InetSocketAddress(lh, 0)\n+                    : null;\n+            dc3.socket().bind(dest); \/\/ bind server to any port\n@@ -50,1 +63,0 @@\n-            InetAddress lh = InetAddress.getLocalHost();\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/ReceiveISA.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-    static final int MAX_TRIES = 3;\n-    static final String GREETINGS_MESSAGE = \"Greetings from SelectWhenRefused!\";\n+    static final int MAX_TRIES = 10;\n+    static final String GREETINGS_MESSAGE = System.nanoTime() + \": Greetings from SelectWhenRefused!\";\n@@ -52,0 +52,1 @@\n+        System.err.println(\"Refuser is: \" + refuser);\n@@ -53,1 +54,29 @@\n-        DatagramChannel dc = DatagramChannel.open().bind(new InetSocketAddress(0));\n+        DatagramChannel dc = null;\n+        for (int i=0; i < MAX_TRIES; i++) {\n+            dc = DatagramChannel.open();\n+            try {\n+                dc.bind(new InetSocketAddress(0));\n+            } catch (Throwable t) {\n+                dc.close();\n+                throw t;\n+            }\n+\n+            \/\/ check the port assigned to dc\n+            if (((InetSocketAddress)dc.getLocalAddress()).getPort() != port) {\n+                \/\/ We got a good port. Do not retry\n+                break;\n+            }\n+\n+            \/\/ We bound to the same port that the refuser is using, This will not\n+            \/\/ work. Retry binding if possible.\n+            if (i < MAX_TRIES - 1) {\n+                \/\/ we will retry...\n+                System.err.format(\"Refuser port has been reused by dc: %s, retrying...%n\",\n+                        dc.getLocalAddress());\n+            } else {\n+                \/\/ that was the last attempt... Skip the test\n+                System.err.format(\"Skipping test: refuser port has been reused by dc: %s%n\",\n+                        dc.getLocalAddress());\n+                return;\n+            }\n+        }\n@@ -55,0 +84,1 @@\n+        assert dc != null;\n@@ -91,1 +121,1 @@\n-            System.out.println(\"Skipping test: refuser port has been reused: \" + e);\n+            System.err.println(\"Skipping test: refuser port has been reused: \" + e);\n@@ -122,1 +152,3 @@\n-            DatagramChannel.open().bind(refuser).close();\n+            try (DatagramChannel dc2 = DatagramChannel.open()) {\n+                dc2.bind(refuser);\n+            }\n@@ -154,1 +186,1 @@\n-                    System.out.format(\"received %s at %s from %s%n\", message, dc.getLocalAddress(), sa);\n+                    System.err.format(\"received %s at %s from %s%n\", message, dc.getLocalAddress(), sa);\n@@ -169,1 +201,3 @@\n-                DatagramChannel.open().bind(refuser).close();\n+                try (DatagramChannel dc2 = DatagramChannel.open()) {\n+                    dc2.bind(refuser);\n+                }\n@@ -172,1 +206,1 @@\n-                System.out.println(\"Got expected PortUnreachableException \" + pue);\n+                System.err.println(\"Got expected PortUnreachableException \" + pue);\n@@ -218,1 +252,1 @@\n-        System.out.format(\"Received %d keys%n\", selectedKeys.size());\n+        System.err.format(\"Received %d keys%n\", selectedKeys.size());\n@@ -222,1 +256,1 @@\n-                System.out.println(\"Invalid or unreadable key: \" + key);\n+                System.err.println(\"Invalid or unreadable key: \" + key);\n@@ -227,1 +261,1 @@\n-                System.out.println(\"Attempting to read datagram from key: \" + key);\n+                System.err.println(\"Attempting to read datagram from key: \" + key);\n@@ -237,1 +271,1 @@\n-                    System.out.format(\"received %s at %s from %s%n\", message, datagramChannel.getLocalAddress(), sa);\n+                    System.err.format(\"received %s at %s from %s%n\", message, datagramChannel.getLocalAddress(), sa);\n@@ -246,1 +280,1 @@\n-                System.out.println(\"Unable to read from datagram \" + io);\n+                System.err.println(\"Unable to read from datagram \" + io);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/SelectWhenRefused.java","additions":47,"deletions":13,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import org.testng.Assert;\n@@ -49,0 +50,1 @@\n+import java.net.SocketAddress;\n@@ -142,1 +144,3 @@\n-                sender.bind(null);\n+                sender.bind(new InetSocketAddress(host, 0));\n+                System.out.format(\"testSendReceiveMaxSize: sender: %s -> receiver: %s%n\",\n+                        sender.getLocalAddress(), receiver.getLocalAddress());\n@@ -153,1 +157,12 @@\n-                receiver.receive(receiveBuf);\n+                SocketAddress src;\n+                int count = 0;\n+                do {\n+                    receiveBuf.clear();\n+                    src = receiver.receive(receiveBuf);\n+                    if (sender.getLocalAddress().equals(src)) break;\n+                    System.out.println(\"step1: received unexpected datagram from: \" + src);\n+                    System.out.println(\"\\texpected: \" + sender.getLocalAddress());\n+                    if (++count > 10) {\n+                        throw new AssertionError(\"too many unexpected messages\");\n+                    }\n+                } while (true);\n@@ -170,1 +185,11 @@\n-                receiver.receive(receiveBuf);\n+                count = 0;\n+                do {\n+                    receiveBuf.clear();\n+                    src = receiver.receive(receiveBuf);\n+                    if (sender.getLocalAddress().equals(src)) break;\n+                    System.out.println(\"step1: received unexpected datagram from: \" + src);\n+                    System.out.println(\"\\texpected: \" + sender.getLocalAddress());\n+                    if (++count > 10) {\n+                        throw new AssertionError(\"too many unexpected messages\");\n+                    }\n+                } while (true);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/SendReceiveMaxSize.java","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform Sender\n+ * @run main Sender\n@@ -39,0 +42,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -49,2 +54,2 @@\n-        Server server = new Server();\n-        Client client = new Client(server.port());\n+        try (Server server = new Server()) {\n+            Client client = new Client(server.port());\n@@ -52,2 +57,2 @@\n-        Thread serverThread = new Thread(server);\n-        serverThread.start();\n+            Thread serverThread = new Thread(server);\n+            serverThread.start();\n@@ -55,2 +60,2 @@\n-        Thread clientThread = new Thread(client);\n-        clientThread.start();\n+            Thread clientThread = new Thread(client);\n+            clientThread.start();\n@@ -58,2 +63,2 @@\n-        serverThread.join();\n-        clientThread.join();\n+            serverThread.join();\n+            clientThread.join();\n@@ -61,2 +66,3 @@\n-        server.throwException();\n-        client.throwException();\n+            server.throwException();\n+            client.throwException();\n+        }\n@@ -67,1 +73,1 @@\n-        Exception e = null;\n+        volatile Exception e = null;\n@@ -79,2 +85,1 @@\n-            try {\n-                DatagramChannel dc = DatagramChannel.open();\n+            try (DatagramChannel dc = DatagramChannel.open()) {\n@@ -87,0 +92,4 @@\n+                if (Platform.isOSX()) {\n+                    \/\/ avoid binding on wildcard on macOS\n+                    dc.bind(new InetSocketAddress(address, 0));\n+                }\n@@ -96,1 +105,1 @@\n-    public static class Server implements Runnable {\n+    public static class Server implements Runnable, AutoCloseable {\n@@ -98,1 +107,1 @@\n-        Exception e = null;\n+        volatile Exception e = null;\n@@ -101,1 +110,5 @@\n-            dc = DatagramChannel.open().bind(new InetSocketAddress(0));\n+            \/\/ avoid binding to wildcard address on macOS\n+            InetSocketAddress lo = Platform.isOSX()\n+                    ? new InetSocketAddress(InetAddress.getLocalHost(), 0)\n+                    : new InetSocketAddress(0);\n+            dc = DatagramChannel.open().bind(lo);\n@@ -152,0 +165,5 @@\n+\n+        @Override\n+        public void close() throws IOException {\n+            dc.close();\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Sender.java","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8177552 8217721 8222756 8295372 8306116 8319990\n+ * @bug 8177552 8217721 8222756 8295372 8306116 8319990 8338690\n@@ -63,0 +63,3 @@\n+    private static final NumberFormat FORMAT_IT_LONG = NumberFormat\n+            .getCompactNumberInstance(Locale.ITALIAN, NumberFormat.Style.LONG);\n+\n@@ -92,0 +95,7 @@\n+\n+    private static final NumberFormat FORMAT_PL_LONG = NumberFormat\n+            .getCompactNumberInstance(Locale.of(\"pl\"), NumberFormat.Style.LONG);\n+\n+    private static final NumberFormat FORMAT_FR_LONG = NumberFormat\n+            .getCompactNumberInstance(Locale.FRENCH, NumberFormat.Style.LONG);\n+\n@@ -362,0 +372,6 @@\n+\n+            \/\/ 8338690\n+            {FORMAT_PL_LONG, 5_000, \"5 tysi\\u0119cy\"},\n+            {FORMAT_PL_LONG, 4_949, \"5 tysi\\u0119cy\"},\n+            {FORMAT_FR_LONG, 1_949, \"2 mille\"},\n+            {FORMAT_IT_LONG, 1_949, \"2 mila\"},\n@@ -469,0 +485,4 @@\n+                \/\/ 8338690\n+                {FORMAT_PL_LONG, \"5 tysi\\u0119cy\", 5_000L, Long.class},\n+                {FORMAT_FR_LONG, \"2 mille\", 2_000L, Long.class},\n+                {FORMAT_IT_LONG, \"2 mila\", 2_000L, Long.class},\n@@ -517,0 +537,4 @@\n+            \/\/ 8338690\n+            {FORMAT_PL_LONG, \"5 tysice\", 5L},\n+            {FORMAT_FR_LONG, \"2 millier\", 2L},\n+            {FORMAT_IT_LONG, \"2 mille\", 2L},\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestCompactNumber.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 4615343\n- * @summary Check that ZipError is thrown instead of InternalError when\n- * iterating entries of an invalid zip file\n- *\/\n-\n-import java.io.*;\n-import java.util.*;\n-import java.util.zip.*;\n-\n-public class TestZipError {\n-    public static void realMain(String[] args) throws Throwable {\n-        \/\/ Causing a ZipError is hard, especially on non-Windows systems.  See\n-        \/\/ comments below.\n-        String osName = System.getProperty(\"os.name\");\n-        if (!System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n-            return;\n-        }\n-\n-        String fileName = \"error4615343.zip\";\n-        File f = new File(fileName);\n-        f.delete();\n-        ZipOutputStream zos;\n-        ZipEntry ze;\n-\n-        \/\/ Create a zip file with two entries.\n-        zos = new ZipOutputStream(new FileOutputStream(f));\n-        ze = new ZipEntry(\"one\");\n-        zos.putNextEntry(ze);\n-        zos.write(\"hello\".getBytes());\n-        zos.closeEntry();\n-        ze = new ZipEntry(\"two\");\n-        zos.putNextEntry(ze);\n-        zos.write(\"world\".getBytes());\n-        zos.closeEntry();\n-        zos.close();\n-\n-        \/\/ Open the ZipFile.  This will read the zip file's central\n-        \/\/ directory into in-memory data structures.\n-        ZipFile zf = new ZipFile(fileName);\n-\n-        \/\/ Delete the file; of course this does not change the in-memory data\n-        \/\/ structures that represent the central directory!\n-        f.delete();\n-\n-        \/\/ Re-create zip file, with different entries than earlier.  However,\n-        \/\/ recall that we have in-memory information about the central\n-        \/\/ directory of the file at its previous state.\n-        zos = new ZipOutputStream(new FileOutputStream(f));\n-        ze = new ZipEntry(\"uno\");\n-        zos.putNextEntry(ze);\n-        zos.write(\"hola\".getBytes());\n-        zos.closeEntry();\n-        zos.close();\n-\n-        \/\/ Iterate zip file's contents.  On Windows, this will result in a\n-        \/\/ ZipError, because the data in the file differs from the in-memory\n-        \/\/ central directory information we read earlier.\n-        Enumeration<? extends ZipEntry> entries = zf.entries();\n-        try {\n-            while (entries.hasMoreElements()) {\n-                ze = entries.nextElement();\n-                zf.getInputStream(ze).readAllBytes();\n-            }\n-            fail(\"Did not get expected exception\");\n-        } catch (ZipException e) {\n-            pass();\n-        } catch (InternalError e) {\n-            fail(\"Caught InternalError instead of expected ZipError\");\n-        } catch (Throwable t) {\n-            unexpected(t);\n-        } finally {\n-            zf.close();\n-            f.delete();\n-        }\n-    }\n-\n-    \/\/--------------------- Infrastructure ---------------------------\n-    static volatile int passed = 0, failed = 0;\n-    static void pass() {passed++;}\n-    static void fail() {failed++; Thread.dumpStack();}\n-    static void fail(String msg) {System.out.println(msg); fail();}\n-    static void unexpected(Throwable t) {failed++; t.printStackTrace();}\n-    static void check(boolean cond) {if (cond) pass(); else fail();}\n-    static void equal(Object x, Object y) {\n-        if (x == null ? y == null : x.equals(y)) pass();\n-        else fail(x + \" not equal to \" + y);}\n-    public static void main(String[] args) throws Throwable {\n-        try {realMain(args);} catch (Throwable t) {unexpected(t);}\n-        System.out.println(\"\\nPassed = \" + passed + \" failed = \" + failed);\n-        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n-}\n","filename":"test\/jdk\/java\/util\/zip\/TestZipError.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -42,1 +42,2 @@\n-        TLSBase.Client client1 = new TLSBase.Client(true, false);\n+        TLSBase.Client client = new TLSBase.Client(true, false);\n+        client.connect();\n@@ -44,2 +45,3 @@\n-        server.getSession(client1).getSessionContext();\n-        server.done();\n+        \/\/ Close must be called to gather all the exceptions thrown\n+        client.close();\n+        server.close();\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CertMsgCheck.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+        client1.connect();\n@@ -69,0 +70,1 @@\n+        client2.connect();\n@@ -76,1 +78,0 @@\n-        server.done();\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CheckSessionContext.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n@@ -55,0 +57,1 @@\n+        private InetAddress listenInterface = InetAddress.getLoopbackAddress();\n@@ -60,0 +63,9 @@\n+        public InetAddress getListenInterface() {\n+            return listenInterface;\n+        }\n+\n+        public Builder setListenInterface(InetAddress listenInterface) {\n+            this.listenInterface = listenInterface;\n+            return this;\n+        }\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/interop\/AbstractServer.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import java.net.InetAddress;\n@@ -56,1 +57,2 @@\n-                = (SSLServerSocket) serverFactory.createServerSocket(builder.getPort());\n+                = (SSLServerSocket) serverFactory.createServerSocket(builder.getPort(),\n+                    0, builder.getListenInterface());\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/interop\/JdkServer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -32,1 +33,0 @@\n-import java.util.Arrays;\n@@ -35,0 +35,3 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n@@ -42,1 +45,1 @@\n- * Server.done() must be called or the server will never exit and hang the test.\n+ * Server.close() must be called so the server will exit and end threading.\n@@ -55,1 +58,1 @@\n-    static String pathToStores = \"..\/etc\";\n+    static String pathToStores = \"javax\/net\/ssl\/etc\";\n@@ -60,0 +63,3 @@\n+    static final String TESTROOT =\n+        System.getProperty(\"test.root\", \"..\/..\/..\/..\");\n+\n@@ -64,1 +70,1 @@\n-    String name;\n+    public String name;\n@@ -67,6 +73,4 @@\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n+\n+        String keyFilename = TESTROOT +  \"\/\" + pathToStores + \"\/\" + keyStoreFile;\n+        String trustFilename = TESTROOT + \"\/\" + pathToStores + \"\/\" +\n+            trustStoreFile;\n@@ -81,5 +85,4 @@\n-        BufferedReader reader = new BufferedReader(\n-            new InputStreamReader(sock.getInputStream()));\n-        String s = reader.readLine();\n-        System.err.println(\"(read) \" + name + \": \" + s);\n-        return s.getBytes();\n+        BufferedInputStream is = new BufferedInputStream(sock.getInputStream());\n+        byte[] b = is.readNBytes(5);\n+        System.err.println(\"(read) \" + Thread.currentThread().getName() + \": \" + new String(b));\n+        return b;\n@@ -90,5 +93,2 @@\n-        PrintWriter out = new PrintWriter(\n-            new OutputStreamWriter(sock.getOutputStream()));\n-        out.println(new String(data));\n-        out.flush();\n-        System.err.println(\"(write)\" + name + \": \" + new String(data));\n+        sock.getOutputStream().write(data);\n+        System.err.println(\"(write)\" + Thread.currentThread().getName() + \": \" + new String(data));\n@@ -100,1 +100,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") +\n@@ -116,1 +116,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") +\n@@ -153,0 +153,5 @@\n+        ExecutorService threadPool = Executors.newFixedThreadPool(1,\n+            r -> {\n+                Thread t = Executors.defaultThreadFactory().newThread(r);\n+                return t;\n+            });\n@@ -163,0 +168,1 @@\n+                ssock.setReuseAddress(true);\n@@ -165,0 +171,1 @@\n+                System.out.println(\"Server Port: \" + serverPort);\n@@ -174,11 +181,2 @@\n-                        System.err.println(\"Server ready on port \" +\n-                            serverPort);\n-                        SSLSocket c = (SSLSocket)ssock.accept();\n-                        clientMap.put(c.getPort(), c);\n-                        try {\n-                            write(c, read(c));\n-                        } catch (Exception e) {\n-                            System.out.println(\"Caught \" + e.getMessage());\n-                            e.printStackTrace();\n-                            exceptionList.add(e);\n-                        }\n+                        SSLSocket sock = (SSLSocket)ssock.accept();\n+                        threadPool.submit(new ServerThread(sock));\n@@ -189,0 +187,2 @@\n+                } finally {\n+                    threadPool.close();\n@@ -194,3 +194,2 @@\n-        Server() {\n-            this(new ServerBuilder());\n-        }\n+        class ServerThread extends Thread {\n+            SSLSocket sock;\n@@ -198,42 +197,4 @@\n-        \/**\n-         * @param km - true for an empty key manager\n-         * @param tm - true for an empty trust manager\n-         *\/\n-        Server(boolean km, boolean tm) {\n-            super();\n-            name = \"server\";\n-            try {\n-                sslContext = SSLContext.getInstance(\"TLS\");\n-                sslContext.init(TLSBase.getKeyManager(km),\n-                    TLSBase.getTrustManager(tm), null);\n-                fac = sslContext.getServerSocketFactory();\n-                ssock = (SSLServerSocket) fac.createServerSocket(0);\n-                ssock.setNeedClientAuth(true);\n-                serverPort = ssock.getLocalPort();\n-            } catch (Exception e) {\n-                System.err.println(\"Failure during server initialization\");\n-                e.printStackTrace();\n-            }\n-\n-                \/\/ Thread to allow multiple clients to connect\n-                t = new Thread(() -> {\n-                    try {\n-                        while (true) {\n-                            System.err.println(\"Server ready on port \" +\n-                                serverPort);\n-                            SSLSocket c = (SSLSocket)ssock.accept();\n-                            clientMap.put(c.getPort(), c);\n-                            try {\n-                                write(c, read(c));\n-                            } catch (Exception e) {\n-                                System.out.println(\"Caught \" + e.getMessage());\n-                                e.printStackTrace();\n-                                exceptionList.add(e);\n-                            }\n-                        }\n-                    } catch (Exception ex) {\n-                        System.err.println(\"Server Down\");\n-                        ex.printStackTrace();\n-                    }\n-                });\n-                t.start();\n+            ServerThread(SSLSocket s) {\n+                this.sock = s;\n+                System.err.println(\"ServerThread(\"+sock.getPort()+\")\");\n+                clientMap.put(sock.getPort(), sock);\n@@ -242,17 +203,8 @@\n-        \/\/ Exit test to quit the test.  This must be called at the end of the\n-        \/\/ test or the test will never end.\n-        void done() {\n-            try {\n-                t.join(5000);\n-                ssock.close();\n-            } catch (Exception e) {\n-                System.err.println(e.getMessage());\n-                e.printStackTrace();\n-            }\n-        }\n-\n-        \/\/ Read from the client\n-        byte[] read(Client client) throws Exception {\n-            SSLSocket s = clientMap.get(Integer.valueOf(client.getPort()));\n-            if (s == null) {\n-                System.err.println(\"No socket found, port \" + client.getPort());\n+            public void run() {\n+                try {\n+                    write(sock, read(sock));\n+                } catch (Exception e) {\n+                    System.out.println(\"Caught \" + e.getMessage());\n+                    e.printStackTrace();\n+                    exceptionList.add(e);\n+                }\n@@ -260,1 +212,0 @@\n-            return read(s);\n@@ -263,3 +214,2 @@\n-        \/\/ Write to the client\n-        void write(Client client, byte[] data) throws Exception {\n-            write(clientMap.get(client.getPort()), data);\n+        Server() {\n+            this(new ServerBuilder());\n@@ -268,5 +218,7 @@\n-        \/\/ Server writes to the client, then reads from the client.\n-        \/\/ Return true if the read & write data match, false if not.\n-        boolean writeRead(Client client, String s) throws Exception{\n-            write(client, s.getBytes());\n-            return (Arrays.compare(s.getBytes(), client.read()) == 0);\n+        public SSLSession getSession(Client client) throws Exception {\n+            System.err.println(\"getSession(\"+client.getPort()+\")\");\n+            SSLSocket clientSocket = clientMap.get(client.getPort());\n+            if (clientSocket == null) {\n+                throw new Exception(\"Server can't find client socket\");\n+            }\n+            return clientSocket.getSession();\n@@ -275,4 +227,7 @@\n-        \/\/ Get the SSLSession from the server side socket\n-        SSLSession getSession(Client c) {\n-            SSLSocket s = clientMap.get(Integer.valueOf(c.getPort()));\n-            return s.getSession();\n+        void close(Client client) {\n+            try {\n+                System.err.println(\"close(\"+client.getPort()+\")\");\n+                clientMap.remove(client.getPort()).close();\n+            } catch (Exception e) {\n+                ;\n+            }\n@@ -280,5 +235,7 @@\n-\n-        \/\/ Close client socket\n-        void close(Client c) throws IOException {\n-            SSLSocket s = clientMap.get(Integer.valueOf(c.getPort()));\n-            s.close();\n+        void close() throws InterruptedException {\n+            clientMap.values().stream().forEach(s -> {\n+                try {\n+                    s.close();\n+                } catch (IOException e) {}\n+            });\n+            threadPool.awaitTermination(500, TimeUnit.MILLISECONDS);\n@@ -315,1 +272,1 @@\n-     * Client side will establish a connection from the constructor and wait.\n+     * Client side will establish a SSLContext instance.\n@@ -319,1 +276,1 @@\n-        SSLSocket sock;\n+        public SSLSocket socket;\n@@ -333,5 +290,0 @@\n-            connect();\n-        }\n-\n-        \/\/ Connect to server.  Maybe runnable in the future\n-        public SSLSocket connect() {\n@@ -341,7 +293,1 @@\n-                sock = (SSLSocket)sslContext.getSocketFactory().createSocket();\n-                sock.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), serverPort));\n-                System.err.println(\"Client connected using port \" +\n-                        sock.getLocalPort());\n-                name = \"client(\" + sock.toString() + \")\";\n-                write(\"Hello\");\n-                read();\n+                socket = createSocket();\n@@ -351,1 +297,0 @@\n-            return sock;\n@@ -354,3 +299,3 @@\n-        \/\/ Read from the client socket\n-        byte[] read() throws Exception {\n-            return read(sock);\n+        Client(Client cl) {\n+            sslContext = cl.sslContext;\n+            socket = createSocket();\n@@ -359,3 +304,7 @@\n-        \/\/ Write to the client socket\n-        void write(byte[] data) throws Exception {\n-            write(sock, data);\n+        public SSLSocket createSocket() {\n+            try {\n+                return (SSLSocket) sslContext.getSocketFactory().createSocket();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            return null;\n@@ -363,2 +312,12 @@\n-        void write(String s) throws Exception {\n-            write(sock, s.getBytes());\n+\n+        public SSLSocket connect() {\n+            try {\n+                socket.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), serverPort));\n+                System.err.println(\"Client (\" + Thread.currentThread().getName() + \") connected using port \" +\n+                    socket.getLocalPort() + \" to \" + socket.getPort());\n+                writeRead();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+                return null;\n+            }\n+            return socket;\n@@ -367,5 +326,9 @@\n-        \/\/ Client writes to the server, then reads from the server.\n-        \/\/ Return true if the read & write data match, false if not.\n-        boolean writeRead(Server server, String s) throws Exception {\n-            write(s.getBytes());\n-            return (Arrays.compare(s.getBytes(), server.read(this)) == 0);\n+        public SSLSession getSession() {\n+            return socket.getSession();\n+        }\n+        public void close() {\n+            try {\n+                socket.close();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n@@ -374,3 +337,2 @@\n-        \/\/ Get port from the socket\n-        int getPort() {\n-            return sock.getLocalPort();\n+        public int getPort() {\n+            return socket.getLocalPort();\n@@ -379,3 +341,8 @@\n-        \/\/ Close socket\n-        void close() throws IOException {\n-            sock.close();\n+        private SSLSocket writeRead() {\n+            try {\n+                write(socket, \"Hello\".getBytes(StandardCharsets.ISO_8859_1));\n+                read(socket);\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            return socket;\n@@ -383,0 +350,1 @@\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/TLSBase.java","additions":115,"deletions":147,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -0,0 +1,352 @@\n+\/*\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.Raster;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.imageio.ImageIO;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 8338103\n+ * @key headful\n+ * @summary Verifies that the OpenGL pipeline does not create artifacts\n+ * with swing components after window is zoomed to maximum size and then\n+ * resized back to normal. The test case simulates this operation using\n+ * a JButton. A file image of the component will be saved before and after\n+ * the window resize if the test fails. The test passes if both the button\n+ * images are the same.\n+ * @run main\/othervm -Dsun.java2d.opengl=true -Dsun.java2d.opengl.fbobject=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.opengl=true -Dsun.java2d.opengl.fbobject=true SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.opengl=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"windows\")\n+ * @run main\/othervm -Dsun.java2d.d3d=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.d3d=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"linux\")\n+ * @run main\/othervm -Dsun.java2d.xrender=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.xrender=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @run main\/othervm -Dsun.java2d.metal=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.metal=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+public class SwingButtonResizeTestWithOpenGL {\n+    private static Robot robot;\n+    private static CountDownLatch focusGainedLatch;\n+    private JFrame frame;\n+    private JButton button;\n+\n+    public SwingButtonResizeTestWithOpenGL() {\n+\n+        try {\n+            SwingUtilities.invokeAndWait(() -> createGUI());\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Problems creating GUI\");\n+        }\n+    }\n+\n+    private void createGUI() {\n+        frame = new JFrame(\"SwingButtonResizeTestWithOpenGL\");\n+        button = new JButton(\"Button A\");\n+        frame.setLocation(200, 200);\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        button.setPreferredSize(new Dimension(300, 300));\n+        button.addFocusListener(new FocusAdapter() {\n+            public void focusGained(FocusEvent fe) {\n+                focusGainedLatch.countDown();\n+            }\n+        });\n+        frame.getContentPane().setLayout(new FlowLayout());\n+        frame.getContentPane().add(button);\n+        frame.pack();\n+        frame.setVisible(true);\n+        frame.toFront();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        focusGainedLatch = new CountDownLatch(1);\n+        SwingButtonResizeTestWithOpenGL test =\n+                new SwingButtonResizeTestWithOpenGL();\n+        test.runTest();\n+    }\n+\n+    public void runTest() throws Exception {\n+        BufferedImage bimage1;\n+        BufferedImage bimage2;\n+\n+        try {\n+            robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+            robot.setAutoDelay(200);\n+\n+            if (focusGainedLatch.await(3, TimeUnit.SECONDS)) {\n+                System.out.println(\"Button focus gained...\");\n+            } else {\n+                System.out.println(\"Button focus not gained...\");\n+                throw new RuntimeException(\n+                        \"Can't gain focus on button even after waiting \" +\n+                        \"too long..\");\n+            }\n+\n+            System.out.println(\"Getting initial button image..image1\");\n+            bimage1 = getButtonImage();\n+\n+            \/\/ some platforms may not support maximize frame\n+            if (frame.getToolkit().isFrameStateSupported(\n+                    JFrame.MAXIMIZED_BOTH)) {\n+                robot.waitForIdle();\n+                \/\/ maximize frame from normal size\n+                frame.setExtendedState(JFrame.MAXIMIZED_BOTH);\n+                System.out.println(\"Frame is maximized\");\n+                robot.waitForIdle();\n+\n+                if (frame.getToolkit().isFrameStateSupported(JFrame.NORMAL)) {\n+                    System.out.println(\"Frame is back to normal\");\n+                    \/\/ resize from maximum size to normal\n+                    frame.setExtendedState(JFrame.NORMAL);\n+\n+                    \/\/ capture image of JButton after resize\n+                    System.out.println(\n+                            \"Getting image of JButton after resize..image2\");\n+                    bimage2 = getButtonImage();\n+\n+                    \/\/ compare button images from before and after frame resize\n+                    DiffImage di = new DiffImage(bimage1.getWidth(),\n+                                                 bimage1.getHeight());\n+                    System.out.println(\n+                            \"Taking the diff of two images, image1 and image2\");\n+                    if (!di.compare(bimage1, bimage2)) {\n+                        throw new RuntimeException(\n+                                \"Button renderings are different after window \"\n+                                + \"resize, num of Diff Pixels=\"\n+                                + di.getNumDiffPixels());\n+                    } else {\n+                        System.out.println(\"Test passed...\");\n+                    }\n+\n+                } else {\n+                    System.out.println(\n+                            \"Test skipped: JFrame.NORMAL resize is \" +\n+                            \"not supported\");\n+                }\n+\n+            } else {\n+                System.out.println(\n+                        \"Test skipped: JFrame.MAXIMIZED_BOTH resize is \" +\n+                        \"not supported\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> disposeFrame());\n+        }\n+    }\n+\n+    \/\/ Capture button rendering as a BufferedImage\n+    private BufferedImage getButtonImage() {\n+        try {\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            AtomicReference<Point> buttonLocRef = new AtomicReference<>();\n+            SwingUtilities.invokeAndWait(\n+                    () -> buttonLocRef.set(button.getLocationOnScreen()));\n+            Point buttonLoc = buttonLocRef.get();\n+            System.out.println(\"Button loc: \" + buttonLoc);\n+            return robot.createScreenCapture(\n+                    new Rectangle(buttonLoc.x, buttonLoc.y, button.getWidth(),\n+                                  button.getHeight()));\n+        } catch (Exception e) {\n+            throw new RuntimeException(\n+                    \"Problems capturing button image from Robot\", e);\n+        }\n+    }\n+\n+    private void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n+    \/\/ Save BufferedImage to PNG file\n+    private void saveButtonImage(BufferedImage image, File file) {\n+        if (image != null) {\n+            try {\n+                System.out.println(\n+                        \"Saving button image to \" + file.getAbsolutePath());\n+                ImageIO.write(image, \"PNG\", file);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Could not write image file\");\n+            }\n+        } else {\n+            throw new RuntimeException(\"BufferedImage was set to null\");\n+        }\n+    }\n+\n+    private class DiffImage extends BufferedImage {\n+\n+        public boolean diff = false;\n+        public int nDiff = -1;\n+\n+        Color bgColor;\n+\n+        int threshold = 0;\n+\n+        public DiffImage(int w, int h) {\n+            super(w, h, BufferedImage.TYPE_INT_ARGB);\n+            bgColor = Color.LIGHT_GRAY;\n+        }\n+\n+        public int getNumDiffPixels() {\n+            return nDiff;\n+        }\n+\n+        public boolean compare(BufferedImage img1, BufferedImage img2)\n+                throws IOException {\n+\n+            int minx1 = img1.getMinX();\n+            int minx2 = img2.getMinX();\n+            int miny1 = img1.getMinY();\n+            int miny2 = img2.getMinY();\n+\n+            int w1 = img1.getWidth();\n+            int w2 = img2.getWidth();\n+            int h1 = img1.getHeight();\n+            int h2 = img2.getHeight();\n+\n+            if ((minx1 != minx2) || (miny1 != miny2) || (w1 != w2)\n+                || (h1 != h2)) {\n+                \/\/ image sizes are different\n+                throw new RuntimeException(\n+                        \"img1: <\" + minx1 + \",\" + miny1 + \",\" + w1 + \"x\" + h1\n+                        + \">\" + \" img2: \" + minx2 + \",\" + miny2 + \",\" + w2 + \"x\"\n+                        + h2 + \">\" + \" are different sizes\");\n+            }\n+            \/\/ Get the actual data behind the images\n+            Raster ras1 = img1.getData();\n+            Raster ras2 = img2.getData();\n+\n+            ColorModel cm1 = img1.getColorModel();\n+            ColorModel cm2 = img2.getColorModel();\n+\n+            int r1, r2;  \/\/ red\n+            int g1, g2;  \/\/ green\n+            int b1, b2;  \/\/ blue\n+\n+            Object o1 = null;\n+            Object o2 = null;\n+            nDiff = 0;\n+            for (int x = minx1; x < (minx1 + w1); x++) {\n+                for (int y = miny1; y < (miny1 + h1); y++) {\n+                    \/\/ Causes rasters to allocate data\n+                    o1 = ras1.getDataElements(x, y, o1);\n+                    \/\/ and we reuse the data on every loop\n+                    o2 = ras2.getDataElements(x, y, o2);\n+\n+                    r1 = cm1.getRed(o1);\n+                    r2 = cm2.getRed(o2);\n+                    g1 = cm1.getGreen(o1);\n+                    g2 = cm2.getGreen(o2);\n+                    b1 = cm1.getBlue(o1);\n+                    b2 = cm2.getBlue(o2);\n+\n+                    int redAbs = Math.abs(r1 - r2);\n+                    int greenAbs = Math.abs(g1 - g2);\n+                    int blueAbs = Math.abs(b1 - b2);\n+                    if ((redAbs > threshold)\n+                        || (greenAbs > threshold)\n+                        || (blueAbs > threshold)) {\n+                        \/\/ pixel is different\n+                        setDiffPixel(x, y, redAbs, greenAbs, blueAbs);\n+                        nDiff++;\n+                    } else {\n+                        setSamePixel(x, y);\n+                    }\n+\n+                }\n+            }\n+            if (nDiff != 0) {\n+                ImageIO.write(this, \"png\",\n+                              new File(\"diffImage.png\"));\n+                saveButtonImage(img1, new File(\"image1.png\"));\n+                saveButtonImage(img2, new File(\"image2.png\"));\n+            }\n+            return nDiff == 0;\n+        }\n+\n+        void setDiffPixel(int x, int y, int r, int g, int b) {\n+            diff = true;\n+            setPixelValue(x, y, 255, r, g, b);\n+        }\n+\n+        void setSamePixel(int x, int y) {\n+            if (bgColor != null) {\n+                setPixelValue(x, y, 255, bgColor.getRed(),\n+                              bgColor.getGreen(),\n+                              bgColor.getBlue());\n+            } else {\n+                setPixelValue(x, y, 255, Color.black.getRed(),\n+                              Color.black.getGreen(), Color.black.getBlue());\n+            }\n+        }\n+\n+        void setPixelValue(int x, int y, int a, int r, int g, int b) {\n+            \/\/ setRGB uses BufferedImage.TYPE_INT_ARGB format\n+            int pixel =\n+                    ((a & 0xff) << 24) + ((r & 0xff) << 16) + ((g & 0xff) << 8)\n+                    + ((b & 0xff));\n+            setRGB(x, y, pixel);\n+        }\n+\n+    }\n+\n+}\n+\n+\n","filename":"test\/jdk\/javax\/swing\/JButton\/SwingButtonResizeTestWithOpenGL.java","additions":352,"deletions":0,"binary":false,"changes":352,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,11 @@\n- * @author Alexey Ivanov\n+ * @requires os.family != \"linux\"\n+ * @modules java.desktop\/sun.swing\n+ * @run main bug8080628\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8080628\n+ * @key headful\n+ * @summary No mnemonics on Open and Save buttons in JFileChooser.\n+ * @requires os.family == \"linux\"\n@@ -84,0 +94,1 @@\n+                    System.out.println(\"Unsupported L&F: \" + info.getClassName());\n@@ -86,0 +97,1 @@\n+                System.out.println(\"Testing L&F: \" + info.getClassName());\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/8080628\/bug8080628.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6318027\n+ * @key headful\n+ * @summary  Verifies BasicScrollBarUI disables timer when enclosing frame is disabled\n+ * @run main DisableFrameFromScrollBar\n+ *\/\n+\n+import java.awt.FlowLayout;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.AdjustmentEvent;\n+import java.awt.event.AdjustmentListener;\n+import java.awt.event.InputEvent;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JScrollBar;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+\n+public class DisableFrameFromScrollBar {\n+\n+    private static JFrame frame;\n+    private static JScrollBar bar;\n+    private static int oldValue;\n+    private static volatile boolean doCheck;\n+    private static volatile boolean isAdjusting;\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported LAF: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void createUI() {\n+        frame = new JFrame(DisableFrameFromScrollBar.class.getName());\n+        bar = new JScrollBar();\n+        bar.getModel().addChangeListener(new DisableChangeListener(frame));\n+        frame.getContentPane().setLayout(new FlowLayout());\n+        frame.add(bar);\n+\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setSize(150, 150);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo laf : UIManager.getInstalledLookAndFeels()) {\n+            System.out.println(\"Testing LAF : \" + laf.getClassName());\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            try {\n+                SwingUtilities.invokeAndWait(() -> {\n+                    setLookAndFeel(laf);\n+                    createUI();\n+                });\n+\n+                robot.waitForIdle();\n+                robot.delay(1000);\n+                Point point = getClickPoint();\n+                robot.mouseMove(point.x, point.y);\n+                robot.waitForIdle();\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+                SwingUtilities.invokeAndWait(() -> {\n+                    oldValue = bar.getValue();\n+                    bar.addAdjustmentListener(new AdjustmentListener() {\n+                        public void adjustmentValueChanged(AdjustmentEvent e) {\n+                            int curValue = e.getValue();\n+                            int extent = bar.getMaximum() - bar.getVisibleAmount();\n+                            if (curValue < extent && curValue != oldValue) {\n+                                oldValue = curValue;\n+                                isAdjusting = true;\n+                            } else {\n+                                doCheck = true;\n+                                isAdjusting = false;\n+                            }\n+                        }\n+                    });\n+                });\n+                do {\n+                    Thread.sleep(200);\n+                } while (isAdjusting && !doCheck);\n+                if (bar.getValue() == (bar.getMaximum() - bar.getVisibleAmount())) {\n+                    throw new RuntimeException(\"ScrollBar didn't disable timer\");\n+                }\n+            } finally {\n+                SwingUtilities.invokeAndWait(() -> {\n+                    if (frame != null) {\n+                       frame.dispose();\n+                    }\n+               });\n+            }\n+        }\n+    }\n+\n+    private static Point getClickPoint() throws Exception {\n+        final Point[] result = new Point[1];\n+\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+\n+            @Override\n+            public void run() {\n+                Point p = bar.getLocationOnScreen();\n+                Rectangle rect = bar.getBounds();\n+                result[0] = new Point((int) (p.x + rect.width \/ 2),\n+                        (int) (p.y + rect.height - 10));\n+            }\n+        });\n+\n+        return result[0];\n+\n+    }\n+\n+    public static class DisableChangeListener implements ChangeListener {\n+        private final JFrame m_frame;\n+        private boolean m_done;\n+\n+        public DisableChangeListener(JFrame p_frame) {\n+            m_frame = p_frame;\n+        }\n+\n+        public void stateChanged(ChangeEvent p_e) {\n+            if (!m_done) {\n+                m_frame.setEnabled(false);\n+                Thread t = new Thread(new Enabler(m_frame));\n+                t.start();\n+                m_done = true;\n+            }\n+        }\n+    }\n+\n+    public static class Enabler implements Runnable {\n+        private JFrame m_frame;\n+\n+        Enabler(JFrame p_frame) {\n+            m_frame = p_frame;\n+        }\n+\n+        public void run() {\n+            try {\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            m_frame.setEnabled(true);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JScrollBar\/DisableFrameFromScrollBar.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n- * @bug 4112270 8264102\n+ * @bug 4112270 8264102 8329756\n@@ -181,1 +181,1 @@\n-                 and verifying each key combinations against the spec defined.\n+                 and verify each key combination against the spec defined.\n@@ -273,1 +273,1 @@\n-                FN+Up Arrow\/FN+Down Arrow - Deselect current selection;\n+                fn+Up\/Down Arrow - Deselect current selection;\n@@ -276,4 +276,1 @@\n-                Control-FN+Up Arrow\/FN+Down Arrow - Deselect current selection;\n-                                                    move focus and view to\n-                                                    first\/last cell in current row\n-                F2 - Allows editing in a cell containing information without\n+                fn - Allows editing in a cell containing information without\n@@ -283,2 +280,1 @@\n-                Ctrl+A, Ctrl+\/ - Select All\n-                Ctrl+\\\\ - Deselect all\n+                Cmd+A - Select All\n@@ -287,4 +283,3 @@\n-                FN-Shift Up\/Down Arrow -  Extend selection to top\/bottom of column\n-                Shift-PageUp\/PageDown - Extend selection up\/down one view and scroll\n-                                        table\n-                                \"\"\";\n+                Ctrl-Shift Up\/Down Arrow -  Extend selection to top\/bottom of row\n+                Ctrl-Shift Left\/Right Arrow -  Extend selection to first\/last of column\n+                \"\"\";\n","filename":"test\/jdk\/javax\/swing\/JTable\/KeyBoardNavigation.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JTable;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+\/*\n+ * @test\n+ * @bug 8338041\n+ * @key headful\n+ * @summary Verify that Ctrl Shift RIGHT\/LEFT key extends columns till\n+ * Last\/First Columns in JTable\n+ * @requires (os.family == \"linux\")\n+ * @run main JTableCtrlShiftRightLeftKeyTest\n+ *\/\n+\n+public class JTableCtrlShiftRightLeftKeyTest {\n+    private static JFrame frame;\n+    private static JTable table;\n+    private static volatile Point tableLoc;\n+    private static volatile Rectangle cellRect;\n+    private static volatile int[] selectedColumnAfterKeyPress;\n+    private static Robot robot;\n+    private static final int SELECTED_COLUMN = 2;\n+\n+    public static void main(String[] args) throws Exception {\n+        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\");\n+        robot = new Robot();\n+        robot.setAutoDelay(50);\n+        try {\n+            SwingUtilities.invokeAndWait(JTableCtrlShiftRightLeftKeyTest::createAndShowUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                tableLoc = table.getLocationOnScreen();\n+                cellRect = table.getCellRect(0, SELECTED_COLUMN, true);\n+            });\n+\n+            robot.mouseMove(tableLoc.x + cellRect.x + cellRect.width \/ 2,\n+                    tableLoc.y + cellRect.y + cellRect.height \/ 2);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            testCtrlShift(KeyEvent.VK_RIGHT, SELECTED_COLUMN,\n+                    table.getColumnCount() - 1, \"RIGHT\");\n+\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            testCtrlShift(KeyEvent.VK_LEFT, 0,\n+                    SELECTED_COLUMN, \"LEFT\");\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            System.out.println(\"Test Passed!\");\n+\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void testCtrlShift(int keySelected, int startCellCheck,\n+                                      int endCellCheck, String key) throws Exception {\n+        robot.keyPress(KeyEvent.VK_SHIFT);\n+        robot.keyPress(KeyEvent.VK_CONTROL);\n+        robot.keyPress(keySelected);\n+        robot.keyRelease(keySelected);\n+        robot.keyRelease(KeyEvent.VK_SHIFT);\n+        robot.keyRelease(KeyEvent.VK_CONTROL);\n+        robot.waitForIdle();\n+        robot.delay(100);\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            selectedColumnAfterKeyPress = table.getSelectedColumns();\n+        });\n+\n+        if (selectedColumnAfterKeyPress[0] != startCellCheck ||\n+                selectedColumnAfterKeyPress[selectedColumnAfterKeyPress.length - 1] !=\n+                        endCellCheck) {\n+            System.out.println(\"Selected Columns: \");\n+            for (int columnsSelected : selectedColumnAfterKeyPress) {\n+                System.out.println(columnsSelected);\n+            }\n+            String failureMsg = \"Test Failure. Failed to select cells for Ctrl\" +\n+                    \" Shift \" + key + \" selection\";\n+            throw new RuntimeException(failureMsg);\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        frame = new JFrame(\"Test Ctrl Shift RIGHT\/LEFT Key Press\");\n+        table = new JTable(2, 5);\n+        table.setColumnSelectionAllowed(true);\n+        frame.getContentPane().add(table);\n+\n+        frame.setSize(200, 200);\n+        frame.setLocationRelativeTo(null);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/gtk\/JTableCtrlShiftRightLeftKeyTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -69,1 +69,1 @@\n-                                                  ClassDesc.of(\"Boo\"), List.of()))))))\n+                                                  Annotation.of(ClassDesc.of(\"Boo\"), List.of())))))))\n@@ -104,1 +104,1 @@\n-                                                ClassDesc.of(\"Boo\"), List.of())));\n+                                                Annotation.of(ClassDesc.of(\"Boo\"), List.of()))));\n@@ -119,1 +119,1 @@\n-                                          ClassDesc.of(\"Fee\"), List.of(AnnotationElement.ofBoolean(\"yes\", false)))))\n+                                          Annotation.of(ClassDesc.of(\"Fee\"), List.of(AnnotationElement.ofBoolean(\"yes\", false))))))\n","filename":"test\/jdk\/jdk\/classfile\/ClassPrinterTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304031 8338406\n+ * @summary Testing handling of various constant descriptors in ClassFile API.\n+ * @run junit ConstantDescSymbolsTest\n+ *\/\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.function.Supplier;\n+import java.lang.classfile.ClassFile;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class ConstantDescSymbolsTest {\n+\n+    \/\/ Testing that primitive class descs are encoded properly as loadable constants.\n+    @Test\n+    void testPrimitiveClassDesc() throws Throwable {\n+        ClassDesc ape = ClassDesc.of(\"Ape\");\n+        var lookup = MethodHandles.lookup();\n+        Class<?> a = lookup.defineClass(ClassFile.of().build(ape, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow());\n+            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> {\n+                cob.loadConstant(CD_int);\n+                cob.areturn();\n+            });\n+            clb.withMethodBody(\"get2\", MethodTypeDesc.of(CD_Class), ACC_PUBLIC, cob -> {\n+                Assertions.assertThrows(IllegalArgumentException.class, () -> cob.constantPool().classEntry(CD_long));\n+                var t = cob.constantPool().loadableConstantEntry(CD_long);\n+                cob.ldc(t);\n+                cob.areturn();\n+            });\n+        }));\n+        Supplier<?> t = (Supplier<?>) lookup.findConstructor(a, MethodType.methodType(void.class))\n+                .asType(MethodType.methodType(Supplier.class))\n+                .invokeExact();\n+        assertSame(int.class, t.get());\n+    }\n+\n+    \/\/ Tests that condy symbols with non-static-method bootstraps are using the right lookup descriptor.\n+    @Test\n+    void testConstantDynamicNonStaticBootstrapMethod() throws Throwable {\n+        record CondyBoot(MethodHandles.Lookup lookup, String name, Class<?> type) {}\n+        var bootClass = CondyBoot.class.describeConstable().orElseThrow();\n+        var bootMhDesc = MethodHandleDesc.ofConstructor(bootClass, CD_MethodHandles_Lookup, CD_String, CD_Class);\n+        var condyDesc = DynamicConstantDesc.of(bootMhDesc);\n+\n+        var targetCd = ClassDesc.of(\"Bat\");\n+        var lookup = MethodHandles.lookup();\n+        Class<?> a = lookup.defineClass(ClassFile.of().build(targetCd, clb -> {\n+            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow())\n+                    .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> cob\n+                            .aload(0).invokespecial(CD_Object, INIT_NAME, MTD_void).return_())\n+                    .withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> cob\n+                            .loadConstant(condyDesc).areturn());\n+        }));\n+        @SuppressWarnings(\"unchecked\")\n+        Supplier<CondyBoot> t = (Supplier<CondyBoot>) lookup.findConstructor(a, MethodType.methodType(void.class))\n+                .asType(MethodType.methodType(Supplier.class)).invokeExact();\n+        var cb = t.get();\n+        assertEquals(MethodHandles.Lookup.ORIGINAL, cb.lookup.lookupModes() & MethodHandles.Lookup.ORIGINAL);\n+        assertSame(a, cb.lookup.lookupClass());\n+        assertEquals(DEFAULT_NAME, cb.name);\n+        assertEquals(CondyBoot.class, cb.type);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ConstantDescSymbolsTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8304031\n- * @summary Testing that primitive class descs are encoded properly as loadable constants.\n- * @run junit PrimitiveClassConstantTest\n- *\/\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.function.Supplier;\n-import java.lang.classfile.ClassFile;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import static java.lang.constant.ConstantDescs.CD_Class;\n-import static java.lang.constant.ConstantDescs.CD_Object;\n-import static java.lang.constant.ConstantDescs.CD_int;\n-import static java.lang.constant.ConstantDescs.CD_long;\n-import static java.lang.constant.ConstantDescs.INIT_NAME;\n-import static java.lang.constant.ConstantDescs.MTD_void;\n-import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n-\n-public final class PrimitiveClassConstantTest {\n-\n-    @Test\n-    public void test() throws Throwable {\n-        ClassDesc ape = ClassDesc.of(\"Ape\");\n-        var lookup = MethodHandles.lookup();\n-        Class<?> a = lookup.defineClass(ClassFile.of().build(ape, clb -> {\n-            clb.withSuperclass(CD_Object);\n-            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow());\n-            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n-                cob.aload(0);\n-                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n-                cob.return_();\n-            });\n-            clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> {\n-                cob.loadConstant(CD_int);\n-                cob.areturn();\n-            });\n-            clb.withMethodBody(\"get2\", MethodTypeDesc.of(CD_Class), ACC_PUBLIC, cob -> {\n-                Assertions.assertThrows(IllegalArgumentException.class, () -> cob.constantPool().classEntry(CD_long));\n-                var t = cob.constantPool().loadableConstantEntry(CD_long);\n-                cob.ldc(t);\n-                cob.areturn();\n-            });\n-        }));\n-        Supplier<?> t = (Supplier<?>) lookup.findConstructor(a, MethodType.methodType(void.class))\n-                .asType(MethodType.methodType(Supplier.class))\n-                .invokeExact();\n-        Assertions.assertSame(int.class, t.get());\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/classfile\/PrimitiveClassConstantTest.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8305990 8320222 8320618 8335475\n+ * @bug 8305990 8320222 8320618 8335475 8338623 8338661\n@@ -34,0 +34,2 @@\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n@@ -35,0 +37,4 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -39,0 +45,1 @@\n+import java.util.List;\n@@ -43,1 +50,0 @@\n-import static java.lang.constant.ConstantDescs.MTD_void;\n@@ -47,5 +53,1 @@\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.reflect.AccessFlag;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -344,0 +346,53 @@\n+\n+    private static final MethodTypeDesc MTD_int = MethodTypeDesc.of(CD_int);\n+    private static final MethodTypeDesc MTD_int_String = MethodTypeDesc.of(CD_int, CD_String);\n+\n+    @ParameterizedTest\n+    @EnumSource(ClassFile.StackMapsOption.class)\n+    void testInvocationCounters(ClassFile.StackMapsOption option) {\n+        var cf = ClassFile.of(option);\n+        var cd = ClassDesc.of(\"Test\");\n+        var bytes = cf.build(cd, clb -> clb\n+            .withMethodBody(\"a\", MTD_int_String, ACC_STATIC, cob -> cob\n+                    .aload(0)\n+                    .invokevirtual(CD_String, \"hashCode\", MTD_int)\n+                    .ireturn())\n+            .withMethodBody(\"b\", MTD_int, 0, cob -> cob\n+                    .aload(0)\n+                    .invokevirtual(cd, \"hashCode\", MTD_int)\n+                    .ireturn())\n+        );\n+\n+        var cm = ClassFile.of().parse(bytes);\n+        for (var method : cm.methods()) {\n+            var code = method.findAttribute(Attributes.code()).orElseThrow();\n+            assertEquals(1, code.maxLocals());\n+            assertEquals(1, code.maxStack());\n+        }\n+    }\n+\n+    @Test\n+    void testDeadCodeCountersWithCustomSMTA() {\n+        ClassDesc bar = ClassDesc.of(\"Bar\");\n+        byte[] bytes = ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS).build(bar, clb -> clb\n+                .withMethodBody(\n+                        \"foo\", MethodTypeDesc.of(ConstantDescs.CD_long), ACC_STATIC, cob -> {\n+                            cob.lconst_0().lreturn();\n+                            Label f2 = cob.newBoundLabel();\n+                            cob.lstore(0);\n+                            Label f3 = cob.newBoundLabel();\n+                            cob.lload(0).lreturn().with(\n+                                    StackMapTableAttribute.of(List.of(\n+                                    StackMapFrameInfo.of(f2,\n+                                            List.of(),\n+                                            List.of(StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_LONG)),\n+                                    StackMapFrameInfo.of(f3,\n+                                            List.of(StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_LONG),\n+                                            List.of()))));\n+                        }\n+                ));\n+        assertEmpty(ClassFile.of().verify(bytes));\n+        var code = (CodeAttribute) ClassFile.of().parse(bytes).methods().getFirst().code().orElseThrow();\n+        assertEquals(2, code.maxLocals());\n+        assertEquals(2, code.maxStack());\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":62,"deletions":7,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8336010 8336588\n+ * @bug 8335935 8336588\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -831,1 +831,1 @@\n-                    AnnotationRecord.ofAnnotation(ann));\n+                    AnnotationRecord.ofAnnotation(ann.annotation()));\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/ClassRecord.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,2 +182,1 @@\n-                        ta.classSymbol(),\n-                        ta.elements().stream().map(ae -> AnnotationElement.of(ae.name().stringValue(), transformAnnotationValue(ae.value()))).toList())).toArray(TypeAnnotation[]::new);\n+                        transformAnnotation(ta.annotation()))).toArray(TypeAnnotation[]::new);\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,1 @@\n+        assertEquals(2, makeCombineControl());\n@@ -97,0 +98,28 @@\n+    private static int makeCombineControl() throws Exception {\n+        try (Recording r1 = new Recording()) {\n+            r1.enable(HTTPPostEvent.class).with(\"uriFilter\", \"https:\/\/www.example.com\/list\");\n+            r1.start();\n+\n+            try (Recording r2 = new Recording()) {\n+                r2.enable(HTTPPostEvent.class).with(\"uriFilter\", \"https:\/\/www.example.com\/get\");\n+                r2.start();\n+\n+                HTTPPostEvent e1 = new HTTPPostEvent();\n+                e1.uri = \"https:\/\/www.example.com\/list\";\n+                e1.commit();\n+\n+                HTTPPostEvent e2 = new HTTPPostEvent();\n+                e2.uri = \"https:\/\/www.example.com\/get\";\n+                e2.commit();\n+\n+                HTTPPostEvent e3 = new HTTPPostEvent();\n+                e3.uri = \"https:\/\/www.example.com\/put\";\n+                e3.commit();\n+            }\n+\n+            r1.stop();\n+\n+            return Events.fromRecording(r1).size();\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/api\/settings\/TestFilterEvents.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Collections;\n@@ -33,2 +32,1 @@\n-import jdk.jfr.Event;\n-import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.Recording;\n@@ -44,1 +42,1 @@\n- * Test for events: jdk.CodeCacheFull jdk.CompilationFailure\n+ * Test for events: vm\/code_cache\/full vm\/compiler\/failure\n@@ -63,2 +61,0 @@\n-    static class ProvocationEvent extends Event {\n-    }\n@@ -70,2 +66,2 @@\n-    private static final String EVENT_CODE_CACHE_FULL = EventNames.CodeCacheFull;\n-    private static final String EVENT_COMPILATION_FAILURE = EventNames.CompilationFailure;\n+    private static final String pathFull = EventNames.CodeCacheFull;\n+    private static final String pathFailure = EventNames.CompilationFailure;\n@@ -84,24 +80,7 @@\n-        List<RecordedEvent> events = Collections.synchronizedList(new ArrayList<>());\n-        try (RecordingStream rs = new RecordingStream()) {\n-            rs.setReuse(false);\n-            rs.enable(EVENT_CODE_CACHE_FULL);\n-            rs.enable(EVENT_COMPILATION_FAILURE);\n-            rs.onEvent(EVENT_CODE_CACHE_FULL, events::add);\n-            rs.onEvent(EVENT_COMPILATION_FAILURE, events::add);\n-            rs.onEvent(ProvocationEvent.class.getName(), e -> {\n-                if (!events.isEmpty()) {\n-                    rs.close();\n-                    return;\n-                }\n-                \/\/ Retry if CodeCacheFull or CompilationFailure events weren't provoked\n-                try {\n-                    provokeEvents();\n-                } catch (Exception ex) {\n-                    ex.printStackTrace();\n-                    rs.close();\n-                }\n-            });\n-            rs.startAsync();\n-            provokeEvents();\n-            rs.awaitTermination();\n-        }\n+\n+        Recording r = new Recording();\n+        r.enable(pathFull);\n+        r.enable(pathFailure);\n+        r.start();\n+        provokeEvents();\n+        r.stop();\n@@ -111,0 +90,2 @@\n+\n+        List<RecordedEvent> events = Events.fromRecording(r);\n@@ -112,1 +93,1 @@\n-        for (RecordedEvent event : new ArrayList<>(events)) {\n+        for (RecordedEvent event : events) {\n@@ -114,1 +95,1 @@\n-            case EVENT_CODE_CACHE_FULL:\n+            case pathFull:\n@@ -118,1 +99,1 @@\n-            case EVENT_COMPILATION_FAILURE:\n+            case pathFailure:\n@@ -137,2 +118,0 @@\n-        System.out.println(\"provokeEvents()\");\n-        ProvocationEvent provocationEvent = new ProvocationEvent();\n@@ -183,1 +162,0 @@\n-        provocationEvent.commit();\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCodeSweeper.java","additions":16,"deletions":38,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+\n+\/**\n+ * @test\n+ * @summary Verify that duplicate longer strings doesn't take up unneccessary space\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.jvm.TestLongStringsInPool\n+ *\/\n+public class TestLongStringsInPool {\n+    private static class StringEvent extends Event {\n+        String message;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Create two recordings; first has only one large\n+        \/\/ string, second has several occurences of the same\n+        \/\/ string. With long strings (>128 chars) being pooled,\n+        \/\/ the two recording should be roughly the same size.\n+        final int numEvents = 10;\n+        final String longString = generateString();\n+        final int strLen = longString.length();\n+        final StringEvent event = new StringEvent();\n+        event.message = longString;\n+\n+        Recording firstRec = new Recording();\n+        firstRec.start();\n+        \/\/ commit events with empty message (both recordings\n+        \/\/ will have the same number of events)\n+        for (int i = 0; i < numEvents - 1; i++) {\n+            event.message = \"\";\n+            event.commit();\n+        }\n+        \/\/ commit 1 event with a long string\n+        event.message = longString;\n+        event.commit();\n+\n+        firstRec.stop();\n+        Path rec1 = Paths.get(\".\", \"rec1.jfr\");\n+        firstRec.dump(rec1);\n+        firstRec.close();\n+\n+\n+        Recording secondRec = new Recording();\n+        secondRec.start();\n+        \/\/ commit events with the same long string\n+        for (int i = 0; i < numEvents - 1; i++) {\n+          event.message = longString;\n+          event.commit();\n+        }\n+        \/\/ commit 1 event with a long string\n+        event.message = longString;\n+        event.commit();\n+\n+        secondRec.stop();\n+        Path rec2 = Paths.get(\".\", \"rec2.jfr\");\n+        secondRec.dump(rec2);\n+        secondRec.close();\n+\n+        \/\/ the files aren't exactly the same size, but rec2 should\n+        \/\/ not take up space for all strings if they're pooled correctly\n+        long maxAllowedDiff = (numEvents - 1) * strLen;\n+        long diff = Math.abs(Files.size(rec2) - Files.size(rec1));\n+\n+        Asserts.assertTrue(diff <= maxAllowedDiff, \"Size difference between recordings is too large: \"+ diff +\" > \" + maxAllowedDiff);\n+        Asserts.assertFalse(RecordingFile.readAllEvents(rec1).isEmpty(), \"No events found in recording 1\");\n+        Asserts.assertFalse(RecordingFile.readAllEvents(rec2).isEmpty(), \"No events found in recording 2\");\n+        Asserts.assertEquals(RecordingFile.readAllEvents(rec1).size(), RecordingFile.readAllEvents(rec2).size(), \"The recordings don't have the same number of events\");\n+    }\n+\n+    \/**\n+     * Generate a string of 256 chars length.\n+     * @return\n+     *\/\n+    private static String generateString() {\n+        final StringBuilder builder = new StringBuilder();\n+        for (int i = 0; i < 32; i++) {\n+            builder.append(\"abcdefgh\");\n+        }\n+        return builder.toString();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestLongStringsInPool.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.threading;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ThreadFactory;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedThread;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8338417\n+ * @summary Tests pinning of virtual threads when the JFR string pool monitor is contended.\n+ * @key jfr\n+ * @requires vm.hasJFR & vm.continuations\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.threading.TestStringPoolVirtualThreadPinning\n+ *\/\n+public class TestStringPoolVirtualThreadPinning {\n+\n+    private static final int VIRTUAL_THREAD_COUNT = 100_000;\n+    private static final int STARTER_THREADS = 10;\n+\n+    @Name(\"test.Tester\")\n+    private static class TestEvent extends Event {\n+        private String eventString = Thread.currentThread().getName();\n+    }\n+\n+    \/*\n+     * During event commit, the thread is in a critical section because it has loaded a carrier thread local event writer object.\n+     * For virtual threads, a contended monitor, such as a synchronized block, is a point where a thread could become unmounted.\n+     * A monitor guards the JFR string pool, but because of the event writer, remounting a virtual thread onto another carrier is impossible.\n+     *\n+     * The test provokes JFR string pool monitor contention to exercise explicit pin constructs to ensure the pinning of virtual threads.\n+    *\/\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+\n+            ThreadFactory factory = Thread.ofVirtual().factory();\n+            CompletableFuture<?>[] c = new CompletableFuture[STARTER_THREADS];\n+            for (int j = 0; j < STARTER_THREADS; j++) {\n+                c[j] = CompletableFuture.runAsync(() -> {\n+                    for (int i = 0; i < VIRTUAL_THREAD_COUNT \/ STARTER_THREADS; i++) {\n+                        try {\n+                            Thread vt = factory.newThread(TestStringPoolVirtualThreadPinning::emitEvent);\n+                            \/\/ For an event field string to be placed in the JFR string pool, it must exceed 16 characters.\n+                            \/\/ We use the virtual thread name as the event field string so we can verify the result as a 1-1 mapping.\n+                            vt.setName(\"VirtualTestThread-\" + i);\n+                            vt.start();\n+                            vt.join();\n+                        } catch (InterruptedException ie) {\n+                            ie.printStackTrace();\n+                        }\n+                    }\n+                });\n+            }\n+            for (int j = 0; j < STARTER_THREADS; j++) {\n+                c[j].get();\n+            }\n+\n+            r.stop();\n+            Path p = Utils.createTempFile(\"test\", \".jfr\");\n+            r.dump(p);\n+            List<RecordedEvent> events = RecordingFile.readAllEvents(p);\n+            Asserts.assertEquals(events.size(), VIRTUAL_THREAD_COUNT, \"Expected \" + VIRTUAL_THREAD_COUNT + \" events\");\n+            for (RecordedEvent e : events) {\n+                RecordedThread t = e.getThread();\n+                Asserts.assertNotNull(t);\n+                Asserts.assertTrue(t.isVirtual());\n+                Asserts.assertEquals(e.getString(\"eventString\"), t.getJavaName());\n+            }\n+        }\n+    }\n+\n+    private static void emitEvent() {\n+        TestEvent t = new TestEvent();\n+        t.commit();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestStringPoolVirtualThreadPinning.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import javax.swing.JApplet;\n@@ -45,2 +44,0 @@\n- *\n- * @author Jeff Dinkins\n@@ -48,1 +45,1 @@\n-public class DemoModule extends JApplet {\n+public class DemoModule extends JPanel {\n@@ -217,5 +214,0 @@\n-    public void init() {\n-        getContentPane().setLayout(new BorderLayout());\n-        getContentPane().add(getDemoPanel(), BorderLayout.CENTER);\n-    }\n-\n@@ -223,1 +215,2 @@\n-}\n\\ No newline at end of file\n+}\n+\n","filename":"test\/jdk\/sanity\/client\/lib\/SwingSet2\/src\/DemoModule.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies multiple PSKs are used by JSSE\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=1\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=3\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=10\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.2 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+\/**\n+ * This test verifies that multiple NSTs and PSKs are sent by a JSSE server.\n+ * Then JSSE client is able to store them all and resume the connection.  It\n+ * requires specific text in the TLS debugging to verify the success.\n+ *\/\n+\n+public class MultiNSTClient {\n+\n+    static HexFormat hex = HexFormat.of();\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> {\n+                sb.append(a);\n+                sb.append(\" \");\n+            });\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params\n+                );\n+\n+            boolean TLS13 = args[0].contains(\"1.3\");\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTClient\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            System.out.println(\"I'm here\");\n+            boolean pass = true;\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> serverPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                for (int i = 0; i < 2; i++) {\n+                    String svr = serverPSK.getFirst();\n+                    String cli = clientPSK.getFirst();\n+                    if (svr.regionMatches(svr.length() - 16, cli, cli.length() - 16, 16)) {\n+                        System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                    } else {\n+                        System.out.println(\"entry \" + (i + 1) + \" server and client PSK didn't match:\");\n+                        System.out.println(\"  server: \" + svr);\n+                        System.out.println(\"  client: \" + cli);\n+                        pass = false;\n+                    }\n+                }\n+            } catch (RuntimeException e) {\n+                System.out.println(\"No MultiNST PSK found.\");\n+                pass = false;\n+            }\n+\n+            if (TLS13) {\n+                if (!pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            } else {\n+                if (pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Start connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        SSLSession initialSession = initial.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  getNewSession from original client\");\n+        TLSBase.Client resumClient = new TLSBase.Client(initial);\n+        SSLSession resumption = resumClient.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  Second getNewSession from original client\");\n+        TLSBase.Client resumClient2 = new TLSBase.Client(initial);\n+        resumption = resumClient2.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  New client connection\");\n+        TLSBase.Client newConnection = new TLSBase.Client();\n+        SSLSession newSession = newConnection.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(newSession.getId()));\n+        System.out.println(\"session = \" + newSession);\n+        if (initialSession.toString().equalsIgnoreCase(newSession.toString())) {\n+            throw new Exception(\"new session is the same as the initial.\");\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        resumClient.close();\n+        resumClient2.close();\n+        newConnection.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTClient.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies resumption fails with 0 NSTs and session creation off\n+ * @run main\/othervm MultiNSTNoSessionCreation -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=0\n+ * @run main\/othervm MultiNSTNoSessionCreation -Djdk.tls.client.protocols=TLSv1.2 -Djdk.tls.server.newSessionTicketCount=0\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * With no NSTs sent by the server, try to resume the session with\n+ * setEnabledSessionCreation(false).  The test should get an exception and\n+ * fail to connect.\n+ *\/\n+\n+public class MultiNSTNoSessionCreation {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> sb.append(a).append(\" \"));\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params);\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTNoSessionCreation\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            try {\n+                if (output.stderrContains(\n+                    \"(PROTOCOL_VERSION): New session creation is disabled\")) {\n+                    return;\n+                }\n+            } catch (RuntimeException e) {\n+                throw new Exception(\"Error collecting data\", e);\n+            }\n+            throw new Exception(\"Disabled creation msg not found\");\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Initial connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        initial.connect();\n+        System.out.println(\n+            \"------  Resume client w\/ setEnableSessionCreation set to false\");\n+        TLSBase.Client resumClient = new TLSBase.Client(initial);\n+        resumClient.socket.setEnableSessionCreation(false);\n+        resumClient.connect();\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        resumClient.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTNoSessionCreation.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies multiple PSKs are used by TLSv1.3\n+ * @run main\/othervm MultiNSTParallel 10 -Djdk.tls.client.protocols=TLSv1.3\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.ArrayList;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * This test verifies that parallel resumption connections successfully get\n+ * a PSK entry and not initiate a full handshake.\n+ *\n+ * Note:  THe first argument after 'MultiNSTParallel' is the ticket count\n+ * The test will set 'jdk.tls.server.NewSessionTicketCount` to that number and\n+ * will start the same number of resumption client attempts. The ticket count\n+ * must be the same or larger than resumption attempts otherwise the queue runs\n+ * empty and the test will fail.\n+ *\n+ * Because this test runs parallel connections, the thread order finish is not\n+ * guaranteed.  Each client NST id is checked with all server NSTs ids until\n+ * a match is found.  When a match is found, it is removed from the list to\n+ * verify no NST was used more than once.\n+ *\n+ * TLS 1.2 spec does not specify multiple NST behavior.\n+ *\/\n+\n+public class MultiNSTParallel {\n+\n+    static HexFormat hex = HexFormat.of();\n+    final static CountDownLatch wait = new CountDownLatch(1);\n+\n+    static class ClientThread extends Thread {\n+        TLSBase.Client client;\n+\n+        ClientThread(TLSBase.Client c) {\n+            client = c;\n+        }\n+\n+        public void run() {\n+            String name = Thread.currentThread().getName();\n+            SSLSession r;\n+            System.err.println(\"waiting \" + Thread.currentThread().getName());\n+            try {\n+                wait.await();\n+                r = new TLSBase.Client(client).connect().getSession();\n+            } catch (Exception e) {\n+                throw new RuntimeException(name + \": \" +e);\n+            }\n+            StringBuffer sb = new StringBuffer(100);\n+            sb.append(\"(\").append(name).append(\") id = \");\n+            sb.append(hex.formatHex(r.getId()));\n+            sb.append(\"\\n(\").append(name).append(\") session = \").append(r);\n+            if (!client.getSession().toString().equalsIgnoreCase(r.toString())) {\n+                throw new RuntimeException(\"(\" + name +\n+                    \") Resumed session did not match\");\n+            }\n+        }\n+    }\n+\n+    static boolean pass = true;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            int ticketCount = Integer.parseInt(args[0]);\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 1; i < args.length; i++) {\n+                sb.append(\" \").append(args[i]);\n+            }\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" +\n+                    \" -Djdk.tls.server.newSessionTicketCount=\" + ticketCount +\n+                    params);\n+\n+            boolean TLS13 = args[1].contains(\"1.3\");\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTParallel\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> sp = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> serverPSK = new ArrayList<>(sp.stream().toList());\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+\n+                \/\/ Must search all results as order is not guaranteed.\n+                clientPSK.stream().forEach(cli -> {\n+                    for (int i = 0; i < serverPSK.size(); i++) {\n+                        String svr = serverPSK.get(i);\n+                        if (svr.regionMatches(svr.length() - 16, cli,\n+                            cli.length() - 16, 16)) {\n+                            System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                            serverPSK.remove(i);\n+                            return;\n+                        }\n+                    }\n+                    System.out.println(\"client entry (\" + cli.substring(0, 16) +\n+                        \") not found in server list\");\n+                    pass = false;\n+                });\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Error looking at PSK results.\");\n+                throw new Exception(e);\n+            }\n+\n+            if (TLS13) {\n+                if (!pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            } else {\n+                if (pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        int ticketCount = Integer.parseInt(\n+            System.getProperty(\"jdk.tls.server.newSessionTicketCount\"));\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Start connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        SSLSession initialSession = initial.getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  getNewSession from original client\");\n+\n+        ArrayList<Thread> slist = new ArrayList<>(ticketCount);\n+\n+        System.out.println(\"tx \" + ticketCount);\n+        for (int i = 0; ticketCount > i; i++) {\n+            Thread t = new ClientThread(initial);\n+            t.setName(\"Iteration \" + i);\n+            slist.add(t);\n+            t.start();\n+        }\n+\n+        wait.countDown();\n+        for (Thread t : slist) {\n+            t.join(1000);\n+            System.err.println(\"released: \" + t.getName());\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTParallel.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies sequence of used NST entries from the cache queue.\n+ * @run main\/othervm MultiNSTSequence -Djdk.tls.server.newSessionTicketCount=2\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+\/**\n+ * This test verifies that multiple NSTs take the oldest PSK from the\n+ * QueueCacheEntry stored in the TLS Session Cache.\n+ *\n+ * Note: Beyond 9 iterations the PSK id verification code becomes complicated\n+ * with a QueueCacheEntry limit set to retain only the 10 newest entries.\n+ *\n+ * TLS 1.2 spec does not specify multiple NST behavior.\n+ *\/\n+\n+public class MultiNSTSequence {\n+\n+    static HexFormat hex = HexFormat.of();\n+    static final int ITERATIONS = 9;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> sb.append(a).append(\" \"));\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params\n+                              );\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTSequence\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            boolean pass = true;\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> serverPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                int i;\n+                for (i = 0; i < ITERATIONS; i++) {\n+                    String svr = serverPSK.get(i);\n+                    String cli = clientPSK.get(i);\n+                    if (svr.regionMatches(svr.length() - 16, cli, cli.length() - 16, 16)) {\n+                        System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                    } else {\n+                        System.out.println(\"entry \" + (i + 1) + \" server and client PSK didn't match:\");\n+                        System.out.println(\"  server: \" + svr);\n+                        System.out.println(\"  client: \" + cli);\n+                        pass = false;\n+                    }\n+                }\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Server and Client PSK usage order is not\" +\n+                    \" the same.\");\n+                pass = false;\n+            }\n+\n+            if (!pass) {\n+                throw new Exception(\"Test failed: \" + params);\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Initial connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+\n+        SSLSession initialSession = initial.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  Resume client\");\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            SSLSession r = new TLSBase.Client(initial).connect().getSession();\n+            StringBuilder sb = new StringBuilder(100);\n+            sb.append(\"Iteration: \").append(i);\n+            sb.append(\"\\tid = \").append(hex.formatHex(r.getId()));\n+            sb.append(\"\\tsession = \").append(r);\n+            System.out.println(sb);\n+            if (!initialSession.toString().equalsIgnoreCase(r.toString())) {\n+                throw new Exception(\"Resumed session did not match\");\n+            }\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTSequence.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- *           8331947\n+ *           8331947 8281533\n@@ -159,1 +159,14 @@\n-                    <\/ol>\"\"\");\n+                    <\/ol>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\">Preview feature. Links: <a href=\"CoreRecord.html\" title=\"cla\\\n+                    ss in preview\"><code>CoreRecord<\/code><\/a><sup><a href=\"CoreRecord.html#preview\\\n+                    -preview.CoreRecord\">PREVIEW<\/a><\/sup>, <a href=\"CoreRecord.html\" title=\"class \\\n+                    in preview\"><code>core record<\/code><\/a><sup><a href=\"CoreRecord.html#preview-p\\\n+                    review.CoreRecord\">PREVIEW<\/a><\/sup>,\n+                     <a href=\"CoreRecord.html\" title=\"class in preview\">CoreRecord<\/a>, <a href=\"Co\\\n+                    reRecord.html\" title=\"class in preview\">core record<\/a>.<\/div>\"\"\",\n+                \"\"\"\n+                    <li><a href=\"CoreRecord.html\" title=\"class in preview\"><code>CoreRecord<\/code><\\\n+                    \/a><sup><a href=\"CoreRecord.html#preview-preview.CoreRecord\">PREVIEW<\/a><\/sup><\\\n+                    \/li>\n+                    <li><a href=\"CoreRecord.html\" title=\"class in preview\">core record<\/a><\/li>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPreview\/TestPreview.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+\/**\n+ * Preview feature. Links: {@link CoreRecord}, {@link CoreRecord core record},\n+ * {@linkplain CoreRecord}, {@linkplain CoreRecord core record}.\n+ *\n+ * @see CoreRecord\n+ * @see CoreRecord core record\n+ *\/\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPreview\/api\/preview\/Core.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -606,1 +606,1 @@\n-            boolean matches = checkMatch((Annotation) anno);\n+            boolean matches = checkMatch(anno.annotation());\n@@ -1200,2 +1200,2 @@\n-                    for(Annotation anno : rvattr.annotations()) {\n-                        expected.matchAnnotation(anno);\n+                    for(var anno : rvattr.annotations()) {\n+                        expected.matchAnnotation(anno.annotation());\n","filename":"test\/langtools\/lib\/annotations\/annotations\/classfile\/ClassfileInspector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-            name = annotation.classSymbol().descriptorString();\n+            name = annotation.annotation().classSymbol().descriptorString();\n@@ -230,1 +230,1 @@\n-                annotationValueDebugString(cm, annotation),\n+                annotationValueDebugString(cm, annotation.annotation()),\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/AnonymousClassTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-            tad.annotation = anno.className().stringValue();\n+            tad.annotation = anno.annotation().className().stringValue();\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/ReferenceInfoUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976 8324859\n@@ -2486,0 +2486,531 @@\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion1() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              return true;\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             return true;\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion2() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }                       \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion2: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion3() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion3: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion4() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          }\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion4: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion5() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test(String,\n+                      }\n+                      class T {}\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:38:compiler.err.expected\",\n+                             \"4:1:compiler.err.illegal.start.of.type\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test(String <error>, (ERROR: ) <error>);\n+                     }\n+                     class T {\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion6() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          private Object testMethod(final String arg1 final String arg2) {\n+                              return null;\n+                          }\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:48:compiler.err.expected3\",\n+                             \"3:66:compiler.err.expected\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         private Object testMethod(final String arg1);\n+                         final String arg2;\n+                         {\n+                             return null;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion7() throws IOException {\n+        \/\/after 'default' attribute value, only semicolon (';') is expected,\n+        \/\/not left brace ('{'):\n+        String code = \"\"\"\n+                      package tests;\n+                      public @interface A {\n+                          public String value() default \"\"\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:37:compiler.err.expected\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public @interface A {\n+                         \\n\\\n+                         public String value() default \"\";\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion10() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              String s = \"\";\n+                              return s.isEmpty();\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             String s = \"\";\n+                             return s.isEmpty();\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion11() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          String s = \"\"; \/\/field declaration\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         String s = \"\";\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion12() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              final String s = \"\";\n+                              return s.isEmpty();\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             final String s = \"\";\n+                             return s.isEmpty();\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion13() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          final String s = \"\"; \/\/field declaration?\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         final String s = \"\";\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion14() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              String s = \"\";\n+                              s.length();\n+                              if (true); \/\/force parse as block\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\",\n+                             \"7:5:compiler.err.illegal.start.of.expr\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             String s = \"\";\n+                             s.length();\n+                             if (true) ;\n+                             (ERROR: );\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":532,"deletions":1,"binary":false,"changes":533,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-                    actual.append(ta.className().stringValue() + \" pos: [\" + ta.targetInfo().targetType());\n+                    actual.append(ta.annotation().className().stringValue() + \" pos: [\" + ta.targetInfo().targetType());\n","filename":"test\/langtools\/tools\/javac\/patterns\/Annotations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1618,1 +1618,1 @@\n-        String annotationName = tAnno.classSymbol().displayName();\n+        String annotationName = tAnno.annotation().classSymbol().displayName();\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301580 8322159 8333107 8332230\n+ * @bug 8301580 8322159 8333107 8332230 8338678\n@@ -37,0 +37,5 @@\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n@@ -38,0 +43,1 @@\n+import java.util.IdentityHashMap;\n@@ -39,0 +45,1 @@\n+import java.util.Map;\n@@ -40,0 +47,7 @@\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.tools.Diagnostic;\n@@ -237,0 +251,76 @@\n+    @Test\n+    public void testParameterizedErroneousType() throws Exception {\n+        String code = \"\"\"\n+                      public class C {\n+                          Undefined1<Undefined2, Undefined3> variable1;\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .callback(task -> {\n+                    task.addTaskListener(new TaskListener() {\n+                        @Override\n+                        public void finished(TaskEvent e) {\n+                            Trees trees = Trees.instance(task);\n+\n+                            if (e.getKind() == TaskEvent.Kind.ANALYZE) {\n+                                new TreePathScanner<Void, Void>() {\n+                                    @Override\n+                                    public Void visitVariable(VariableTree tree, Void p) {\n+                                        VariableElement var = (VariableElement) trees.getElement(getCurrentPath());\n+\n+                                        trees.printMessage(Diagnostic.Kind.NOTE, type2String(var.asType()), tree, e.getCompilationUnit());\n+\n+                                        return super.visitVariable(tree, p);\n+                                    }\n+                                }.scan(e.getCompilationUnit(), null);\n+                            }\n+                        }\n+                        Map<Element, Integer> identityRename = new IdentityHashMap<>();\n+                        String type2String(TypeMirror type) {\n+                            StringBuilder result = new StringBuilder();\n+\n+                            result.append(type.getKind());\n+                            result.append(\":\");\n+                            result.append(type.toString());\n+\n+                            if (type.getKind() == TypeKind.DECLARED ||\n+                                type.getKind() == TypeKind.ERROR) {\n+                                DeclaredType dt = (DeclaredType) type;\n+                                Element el = task.getTypes().asElement(dt);\n+                                result.append(\":\");\n+                                result.append(el.toString());\n+                                if (!dt.getTypeArguments().isEmpty()) {\n+                                    result.append(dt.getTypeArguments()\n+                                                    .stream()\n+                                                    .map(tm -> type2String(tm))\n+                                                    .collect(Collectors.joining(\", \", \"<\", \">\")));\n+                                }\n+                            } else {\n+                                throw new AssertionError(type.getKind().name());\n+                            }\n+\n+                            return result.toString();\n+                        }\n+                    });\n+                })\n+                .run(Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"C.java:2:5: compiler.err.cant.resolve.location: kindname.class, Undefined1, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:16: compiler.err.cant.resolve.location: kindname.class, Undefined2, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:28: compiler.err.cant.resolve.location: kindname.class, Undefined3, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:40: compiler.note.proc.messager: ERROR:Undefined1<Undefined2,Undefined3>:Undefined1<ERROR:Undefined2:Undefined2, ERROR:Undefined3:Undefined3>\",\n+                \"3 errors\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":91,"deletions":1,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,2 +130,2 @@\n-            if (nif.getName().contains(\"awdl\")) {\n-                return false; \/\/ exclude awdl\n+            if (nif.getName().contains(\"awdl\") || nif.getName().contains(\"docker\")) {\n+                return false; \/\/ exclude awdl or docker\n@@ -148,0 +148,7 @@\n+\n+        if (Platform.isLinux()) {\n+            String dName = nif.getDisplayName();\n+            if (dName != null && dName.contains(\"docker\")) {\n+                return false;\n+            }\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/NetworkConfiguration.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -324,4 +324,5 @@\n-        String template =\n-            \"FROM %s:%s\\n\" +\n-            \"RUN apt-get install libubsan1\\n\" +\n-            \"COPY \/jdk \/jdk\\n\" +\n+        String template = \"FROM %s:%s\\n\";\n+        if (baseImage.contains(\"ubuntu\") && DockerfileConfig.isUbsan()) {\n+            template += \"RUN apt-get update && apt-get install -y libubsan1\\n\";\n+        }\n+        template = template + \"COPY \/jdk \/jdk\\n\" +\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerTestUtils.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+\n+    public static boolean isUbsan() {\n+        return Boolean.getBoolean(\"jdk.test.docker.image.isUbsan\");\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerfileConfig.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -51,1 +52,2 @@\n-\n+    public Integer integerValue = intValue;\n+    public float floatValue = 156456.36435637F + intValue;\n@@ -53,1 +55,0 @@\n-\n@@ -55,1 +56,0 @@\n-\n@@ -57,1 +57,1 @@\n-\n+    public Boolean booleanValue = Boolean.TRUE;\n@@ -59,1 +59,0 @@\n-\n@@ -62,0 +61,10 @@\n+    @Benchmark\n+    public String concatConstBool() {\n+        return \"string\" + boolValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstBoolean() {\n+        return \"string\" + booleanValue;\n+    }\n+\n@@ -67,0 +76,10 @@\n+    @Benchmark\n+    public String concatConstInteger() {\n+        return \"string\" + integerValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstFloat() {\n+        return \"string\" + floatValue;\n+    }\n+\n@@ -97,0 +116,25 @@\n+    @Benchmark\n+    public String concatConstBoolString() {\n+        return \"string\" + boolValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstBooleanString() {\n+        return \"string\" + booleanValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntString() {\n+        return \"string\" + intValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntegerString() {\n+        return \"string\" + integerValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstFloatString() {\n+        return \"string\" + floatValue + stringValue;\n+    }\n+\n@@ -107,0 +151,30 @@\n+    @Benchmark\n+    public String concatConstStringConst() {\n+        return \"string\" + stringValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntConst() {\n+        return \"string\" + intValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntegerConst() {\n+        return \"string\" + integerValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstFloatConst() {\n+        return \"string\" + floatValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstObjectConst() {\n+        return \"string\" + objectValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstBooleanConst() {\n+        return \"string\" + booleanValue + \"string\";\n+    }\n+\n@@ -117,0 +191,25 @@\n+    @Benchmark\n+    public String concat3String() {\n+        return stringValue + stringValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringBoolString() {\n+        return stringValue + boolValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringBooleanString() {\n+        return stringValue + booleanValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringIntString() {\n+        return stringValue + intValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringIntegerString() {\n+        return stringValue + integerValue + stringValue;\n+    }\n+\n@@ -179,0 +278,9 @@\n+\n+    @Benchmark\n+    public String concat30Mix() {\n+        return f0 + \",\" + f1 + \",\"+ f2 + \",\"+  f3 + \",\"+  f4 + \",\"+  f5 + \",\"+  f6 + \",\"+  f7 + \",\"+  f8 + \",\"+  f9 + \",\"\n+              +f10 + \",\"+f11 + \",\"+f12 + \",\"+ f13 + \",\"+ f14 + \",\"+ f15 + \",\"+ f16 + \",\"+ f17 + \",\"+ f18 + \",\"+ f19 + \",\"\n+              +f20 + \",\"+f21 + \",\"+f22 + \",\" + boolValue + \",\" + booleanValue + \",\" + intValue + \",\" + integerValue\n+              + \",\" + floatValue + \",\" + byteValue + \",\" + objectValue;\n+    }\n+\n@@ -196,0 +304,29 @@\n+    @Benchmark\n+    public String concat13StringConst() {\n+        return f0  + f1  + f2  + f3 + f4\n+             + f5  + f6  + f7  + f8 + f9\n+             +f10 + f11 + f12 + \"\"\"\n+                A really long constant string. Such as a copyright header:\n+                 * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+                 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+                 *\n+                 * This code is free software; you can redistribute it and\/or modify it\n+                 * under the terms of the GNU General Public License version 2 only, as\n+                 * published by the Free Software Foundation.\n+                 *\n+                 * This code is distributed in the hope that it will be useful, but WITHOUT\n+                 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+                 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+                 * version 2 for more details (a copy is included in the LICENSE file that\n+                 * accompanied this code).\n+                 *\n+                 * You should have received a copy of the GNU General Public License version\n+                 * 2 along with this work; if not, write to the Free Software Foundation,\n+                 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+                 *\n+                 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+                 * or visit www.oracle.com if you need additional information or have any\n+                 * questions.\n+                \"\"\";\n+    }\n+\n@@ -198,1 +335,1 @@\n-        return f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + \"\"\"\n+        return f0 + f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8 + f9 + f10 + f11 + f12 + f13 + f14 + f15 + f16 + f17 + f18 + f19 + f20 + f21 + f22 + \"\"\"\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConcat.java","additions":143,"deletions":6,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -47,1 +49,7 @@\n-        String[] selection = new String[] { \"StringLarge\", \"MixedSmall\", \"StringSingle\", \"MixedLarge\" };\n+        String[] selection = {\n+                \"StringLarge\",\n+                \"MixedSmall\",\n+                \"StringSingle\",\n+                \"StringThree\",\n+                \"MixedLarge\"\n+        };\n@@ -53,1 +61,13 @@\n-                case \"StringSingle\" -> new StringSingle().run();\n+                case \"StringSingle\" -> {\n+                    new StringSingle().constInt();\n+                    new StringSingle().constFloat();\n+                    new StringSingle().constString();\n+                    new StringSingle().const2String();\n+                    new StringSingle().constIntString();\n+                    new StringSingle().constFloatString();\n+                    new StringSingle().constBooleanString();\n+                }\n+                case \"StringThree\" -> {\n+                    new StringThree().stringIntString();\n+                    new StringThree().stringIntegerString();\n+                }\n@@ -67,1 +87,7 @@\n-        public String s = \"foo\";\n+        @Param(\"4711\")\n+        public int intValue;\n+        public Integer integerValue = intValue;\n+        public float floatValue = 156456.36435637F + intValue;\n+        public String stringValue = String.valueOf(intValue);\n+        public boolean boolValue = true;\n+        public Boolean booleanValue = Boolean.TRUE;\n@@ -70,2 +96,56 @@\n-        public String run() {\n-            return \"\" + s;\n+        public String constBool() {\n+            return \"string\" + boolValue;\n+        }\n+\n+        @Benchmark\n+        public String constBoolean() {\n+            return \"string\" + booleanValue;\n+        }\n+\n+        @Benchmark\n+        public String constInt() {\n+            return \"string\" + intValue;\n+        }\n+\n+        @Benchmark\n+        public String constInteger() {\n+            return \"string\" + integerValue;\n+        }\n+\n+        @Benchmark\n+        public String constFloat() {\n+            return \"string\" + floatValue;\n+        }\n+\n+        @Benchmark\n+        public String constString() {\n+            return \"string\" + stringValue;\n+        }\n+\n+        public String const2String() {\n+            return \"string\" + stringValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constIntString() {\n+            return \"string\" + intValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constIntegerString() {\n+            return \"string\" + integerValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constFloatString() {\n+            return \"string\" + floatValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constBoolString() {\n+            return \"string\" + boolValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constBooleanString() {\n+            return \"string\" + booleanValue + stringValue;\n@@ -75,0 +155,21 @@\n+    @BenchmarkMode(Mode.SingleShotTime)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    @State(Scope.Thread)\n+    @Fork(value = 40, warmups = 2)\n+    public static class StringThree {\n+\n+        @Param(\"4711\")\n+        public int intValue;\n+        public Integer integerValue = intValue;\n+        public String stringValue = String.valueOf(intValue);\n+\n+        @Benchmark\n+        public String stringIntString() {\n+            return stringValue + intValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String stringIntegerString() {\n+            return stringValue + integerValue + stringValue;\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConcatStartup.java","additions":106,"deletions":5,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -61,0 +61,4 @@\n+            \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/lang\/Object;\",\n+            \"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/String;\",\n+            \"(Ljava\/lang\/Integer;Ljava\/lang\/Integer;)Ljava\/lang\/Integer;\",\n+            \"()Ljava\/lang\/Object;\",\n@@ -64,0 +68,1 @@\n+            \"([III.Z[B..[.[B).\",\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/MethodTypeDescFactories.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -115,7 +115,0 @@\n-\n-    @Benchmark\n-    public void forPrimitiveType(Blackhole bh) throws Throwable {\n-        for (char c : PRIM_TYPES) {\n-            bh.consume(Wrapper.forPrimitiveType(c));\n-        }\n-    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/Wrappers.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    @Param({\"4\"})\n+    @Param({\"4\", \"32\", \"76\", \"128\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/Base64Decode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -38,0 +39,1 @@\n+import java.util.Enumeration;\n@@ -130,0 +132,15 @@\n+    @Benchmark\n+    public int testConcurrentHashMapIterators() {\n+        ConcurrentHashMap<Integer, Integer> map = (ConcurrentHashMap<Integer, Integer>) staticMap;\n+        int sum = 0;\n+        Enumeration it = map.elements();\n+        while (it.hasMoreElements()) {\n+            sum += (int) it.nextElement();\n+        }\n+        it = map.keys();\n+        while (it.hasMoreElements()) {\n+            sum += (int) it.nextElement();\n+        }\n+        return sum;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/concurrent\/Maps.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -63,0 +63,6 @@\n+    public static void main(String... args) {\n+        FindAny findAny = new FindAny();\n+        findAny.size = 100000;\n+        findAny.seq_invoke();\n+        findAny.par_invoke();\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/FindAny.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -125,0 +125,1 @@\n+                null,\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/CodeAttributeTools.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+    public volatile Object lockObject3Inflated;\n+    public volatile Object lockObject4Inflated;\n@@ -65,0 +67,15 @@\n+        lockObject3Inflated = new Object();\n+        lockObject4Inflated = new Object();\n+\n+        \/\/ Inflate the lock to use an ObjectMonitor\n+        try {\n+          synchronized (lockObject3Inflated) {\n+            lockObject3Inflated.wait(1);\n+          }\n+          synchronized (lockObject4Inflated) {\n+            lockObject4Inflated.wait(1);\n+          }\n+        } catch (InterruptedException e) {\n+          throw new RuntimeException(e);\n+        }\n+\n@@ -71,1 +88,1 @@\n-    public void testSimpleLockUnlock() {\n+    public void testBasicSimpleLockUnlockLocal() {\n@@ -81,0 +98,34 @@\n+    \/** Perform a synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testBasicSimpleLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject1) {\n+                dummyInt1++;\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform a synchronized on a local object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedSimpleLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (localObject) {\n+                dummyInt1++;\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform a synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedSimpleLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n@@ -83,1 +134,1 @@\n-    public void testRecursiveLockUnlock() {\n+    public void testBasicRecursiveLockUnlockLocal() {\n@@ -95,0 +146,13 @@\n+    \/** Perform a recursive synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testBasicRecursiveLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject1) {\n+                synchronized (lockObject1) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n@@ -97,1 +161,1 @@\n-    public void testSerialLockUnlock() {\n+    public void testBasicSerialLockUnlockLocal() {\n@@ -109,0 +173,120 @@\n+  \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testBasicSerialLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject1) {\n+                dummyInt1++;\n+            }\n+            synchronized (lockObject1) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same local object. *\/\n+    @Benchmark\n+    public void testInflatedSerialLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (localObject) {\n+                dummyInt1++;\n+            }\n+            synchronized (localObject) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedSerialLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+            }\n+            synchronized (lockObject3Inflated) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedMultipleSerialLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+            }\n+            synchronized (lockObject4Inflated) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedMultipleRecursiveLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+                synchronized (lockObject4Inflated) {\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+      \/** Perform a recursive-only synchronized on a local object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveOnlyLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        synchronized (localObject) {\n+            for (int i = 0; i < innerCount; i++) {\n+                synchronized (localObject) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Perform a recursive-only synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveOnlyLockUnlock() {\n+        synchronized (lockObject3Inflated) {\n+            for (int i = 0; i < innerCount; i++) {\n+                synchronized (lockObject3Inflated) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Perform a recursive-only synchronized on a local object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (localObject) {\n+                synchronized (localObject) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Perform a recursive-only synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                synchronized (lockObject3Inflated) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/LockUnlock.java","additions":187,"deletions":3,"binary":false,"changes":190,"status":"modified"}]}