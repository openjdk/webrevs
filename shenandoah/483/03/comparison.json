{"files":[{"patch":"@@ -44,1 +44,1 @@\n-        value=\"$(grep -h ${{ inputs.var }}= make\/conf\/github-actions.conf | cut -d '=' -f 2-)\"\n+        value=\"$(grep -h '^${{ inputs.var }}'= make\/conf\/github-actions.conf | cut -d '=' -f 2-)\"\n","filename":".github\/actions\/config\/action.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+name: 'Build (alpine-linux)'\n+\n+on:\n+  workflow_call:\n+    inputs:\n+      platform:\n+        required: true\n+        type: string\n+      extra-conf-options:\n+        required: false\n+        type: string\n+      make-target:\n+        required: false\n+        type: string\n+        default: 'product-bundles test-bundles'\n+      debug-levels:\n+        required: false\n+        type: string\n+        default: '[ \"debug\", \"release\" ]'\n+      apk-extra-packages:\n+        required: false\n+        type: string\n+      configure-arguments:\n+        required: false\n+        type: string\n+      make-arguments:\n+        required: false\n+        type: string\n+\n+jobs:\n+  build-linux:\n+    name: build\n+    runs-on: ubuntu-22.04\n+    container:\n+      image: alpine:3.20\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        debug-level: ${{ fromJSON(inputs.debug-levels) }}\n+        include:\n+          - debug-level: debug\n+            flags: --with-debug-level=fastdebug\n+            suffix: -debug+\n+\n+    steps:\n+      - name: 'Checkout the JDK source'\n+        uses: actions\/checkout@v4\n+\n+      - name: 'Install toolchain and dependencies'\n+        run: |\n+          apk update\n+          apk add alpine-sdk alsa-lib-dev autoconf bash cups-dev cups-libs fontconfig-dev freetype-dev grep libx11-dev libxext-dev libxrandr-dev libxrender-dev libxt-dev libxtst-dev linux-headers wget zip ${{ inputs.apk-extra-packages }}\n+\n+      - name: 'Get the BootJDK'\n+        id: bootjdk\n+        uses: .\/.github\/actions\/get-bootjdk\n+        with:\n+          platform: alpine-linux-x64\n+\n+      - name: 'Configure'\n+        run: >\n+          bash configure\n+          --with-conf-name=${{ inputs.platform }}\n+          ${{ matrix.flags }}\n+          --with-version-opt=${GITHUB_ACTOR}-${GITHUB_SHA}\n+          --with-boot-jdk=${{ steps.bootjdk.outputs.path }}\n+          --with-zlib=system\n+          --with-jmod-compress=zip-1\n+          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n+          echo \"Dumping config.log:\" &&\n+          cat config.log &&\n+          exit 1)\n+\n+      - name: 'Build'\n+        id: build\n+        uses: .\/.github\/actions\/do-build\n+        with:\n+          make-target: '${{ inputs.make-target }} ${{ inputs.make-arguments }}'\n+          platform: ${{ inputs.platform }}\n+          debug-suffix: '${{ matrix.suffix }}'\n+\n+      - name: 'Upload bundles'\n+        uses: .\/.github\/actions\/upload-bundles\n+        with:\n+          platform: ${{ inputs.platform }}\n+          debug-suffix: '${{ matrix.suffix }}'\n","filename":".github\/workflows\/build-alpine-linux.yml","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -39,1 +39,1 @@\n-        default: 'linux-x64, linux-x86, linux-x64-variants, linux-cross-compile, macos-x64, macos-aarch64, windows-x64, windows-aarch64, docs'\n+        default: 'linux-x64, linux-x86-hs, linux-x64-variants, linux-cross-compile, alpine-linux-x64, macos-x64, macos-aarch64, windows-x64, windows-aarch64, docs'\n@@ -60,0 +60,3 @@\n+    env:\n+      # List of platforms to exclude by default\n+      EXCLUDED_PLATFORMS: 'alpine-linux-x64'\n@@ -62,1 +65,1 @@\n-      linux-x86: ${{ steps.include.outputs.linux-x86 }}\n+      linux-x86-hs: ${{ steps.include.outputs.linux-x86-hs }}\n@@ -65,0 +68,1 @@\n+      alpine-linux-x64: ${{ steps.include.outputs.alpine-linux-x64 }}\n@@ -81,0 +85,4 @@\n+\n+          # Convert EXCLUDED_PLATFORMS from a comma-separated string to an array\n+          IFS=',' read -r -a excluded_array <<< \"$EXCLUDED_PLATFORMS\"\n+\n@@ -97,1 +105,7 @@\n-              # For an empty input, assume all platforms should run\n+              # For an empty input, assume all platforms should run, except those in the EXCLUDED_PLATFORMS list\n+              for excluded in \"${excluded_array[@]}\"; do\n+                if [[ \"$1\" == \"$excluded\" ]]; then\n+                  echo 'false'\n+                  return\n+                fi\n+              done\n@@ -108,0 +122,8 @@\n+\n+              # If not explicitly included, check against the EXCLUDED_PLATFORMS list\n+              for excluded in \"${excluded_array[@]}\"; do\n+                if [[ \"$1\" == \"$excluded\" ]]; then\n+                  echo 'false'\n+                  return\n+                fi\n+              done\n@@ -114,1 +136,1 @@\n-          echo \"linux-x86=$(check_platform linux-x86 linux x86)\" >> $GITHUB_OUTPUT\n+          echo \"linux-x86-hs=$(check_platform linux-x86-hs linux x86)\" >> $GITHUB_OUTPUT\n@@ -117,0 +139,1 @@\n+          echo \"alpine-linux-x64=$(check_platform alpine-linux-x64 alpine-linux x64)\" >> $GITHUB_OUTPUT\n@@ -138,2 +161,2 @@\n-  build-linux-x86:\n-    name: linux-x86\n+  build-linux-x86-hs:\n+    name: linux-x86-hs\n@@ -144,0 +167,1 @@\n+      make-target: 'hotspot'\n@@ -153,1 +177,1 @@\n-    if: needs.select.outputs.linux-x86 == 'true'\n+    if: needs.select.outputs.linux-x86-hs == 'true'\n@@ -223,0 +247,10 @@\n+  build-alpine-linux-x64:\n+    name: alpine-linux-x64\n+    needs: select\n+    uses: .\/.github\/workflows\/build-alpine-linux.yml\n+    with:\n+      platform: alpine-linux-x64\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n+    if: needs.select.outputs.alpine-linux-x64 == 'true'\n+\n@@ -303,10 +337,0 @@\n-  test-linux-x86:\n-    name: linux-x86\n-    needs:\n-      - build-linux-x86\n-    uses: .\/.github\/workflows\/test.yml\n-    with:\n-      platform: linux-x86\n-      bootjdk-platform: linux-x64\n-      runs-on: ubuntu-22.04\n-\n@@ -350,1 +374,1 @@\n-      - build-linux-x86\n+      - build-linux-x86-hs\n@@ -356,0 +380,1 @@\n+      - build-alpine-linux-x64\n@@ -361,1 +386,0 @@\n-      - test-linux-x86\n","filename":".github\/workflows\/main.yml","additions":43,"deletions":19,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+          $(CHMOD) u+w '$(call DecodeSpace, $@)'; \\\n","filename":"make\/common\/FileUtils.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+ALPINE_LINUX_X64_BOOT_JDK_EXT=tar.gz\n+ALPINE_LINUX_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin22-binaries\/releases\/download\/jdk-22.0.2%2B9\/OpenJDK22U-jdk_x64_alpine-linux_hotspot_22.0.2_9.tar.gz\n+ALPINE_LINUX_X64_BOOT_JDK_SHA256=49f73414824b1a7c268a611225fa4d7ce5e25600201e0f1cd59f94d1040b5264\n+\n","filename":"make\/conf\/github-actions.conf","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2723,1 +2723,1 @@\n-      \/* Fix up any out-of-range offsets. *\/\n+      \/\/ Fix up any out-of-range offsets.\n@@ -2764,1 +2764,5 @@\n-      (masm->*insn)(reg, T, Address(base, disp));\n+      \/\/ Fix up any out-of-range offsets.\n+      assert_different_registers(rscratch1, base);\n+      Address addr = Address(base, disp);\n+      addr = __ legitimize_address(addr, (1 << T), rscratch1);\n+      (masm->*insn)(reg, T, addr);\n@@ -2819,1 +2823,1 @@\n-  enc_class aarch64_enc_ldrsbw(iRegI dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrsbw(iRegI dst, memory mem) %{\n@@ -2827,1 +2831,1 @@\n-  enc_class aarch64_enc_ldrsb(iRegI dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrsb(iRegI dst, memory mem) %{\n@@ -2835,1 +2839,1 @@\n-  enc_class aarch64_enc_ldrb(iRegI dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrb(iRegI dst, memory mem) %{\n@@ -2843,1 +2847,1 @@\n-  enc_class aarch64_enc_ldrb(iRegL dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrb(iRegL dst, memory mem) %{\n@@ -2851,1 +2855,1 @@\n-  enc_class aarch64_enc_ldrshw(iRegI dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrshw(iRegI dst, memory mem) %{\n@@ -2859,1 +2863,1 @@\n-  enc_class aarch64_enc_ldrsh(iRegI dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrsh(iRegI dst, memory mem) %{\n@@ -2867,1 +2871,1 @@\n-  enc_class aarch64_enc_ldrh(iRegI dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrh(iRegI dst, memory mem) %{\n@@ -2875,1 +2879,1 @@\n-  enc_class aarch64_enc_ldrh(iRegL dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrh(iRegL dst, memory mem) %{\n@@ -2883,1 +2887,1 @@\n-  enc_class aarch64_enc_ldrw(iRegI dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrw(iRegI dst, memory mem) %{\n@@ -2891,1 +2895,1 @@\n-  enc_class aarch64_enc_ldrw(iRegL dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrw(iRegL dst, memory mem) %{\n@@ -2899,1 +2903,1 @@\n-  enc_class aarch64_enc_ldrsw(iRegL dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrsw(iRegL dst, memory mem) %{\n@@ -2907,1 +2911,1 @@\n-  enc_class aarch64_enc_ldr(iRegL dst, memory8 mem) %{\n+  enc_class aarch64_enc_ldr(iRegL dst, memory mem) %{\n@@ -2915,1 +2919,1 @@\n-  enc_class aarch64_enc_ldrs(vRegF dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrs(vRegF dst, memory mem) %{\n@@ -2923,1 +2927,1 @@\n-  enc_class aarch64_enc_ldrd(vRegD dst, memory8 mem) %{\n+  enc_class aarch64_enc_ldrd(vRegD dst, memory mem) %{\n@@ -2931,1 +2935,1 @@\n-  enc_class aarch64_enc_strb(iRegI src, memory1 mem) %{\n+  enc_class aarch64_enc_strb(iRegI src, memory mem) %{\n@@ -2939,1 +2943,1 @@\n-  enc_class aarch64_enc_strb0(memory1 mem) %{\n+  enc_class aarch64_enc_strb0(memory mem) %{\n@@ -2946,1 +2950,1 @@\n-  enc_class aarch64_enc_strh(iRegI src, memory2 mem) %{\n+  enc_class aarch64_enc_strh(iRegI src, memory mem) %{\n@@ -2954,1 +2958,1 @@\n-  enc_class aarch64_enc_strh0(memory2 mem) %{\n+  enc_class aarch64_enc_strh0(memory mem) %{\n@@ -2961,1 +2965,1 @@\n-  enc_class aarch64_enc_strw(iRegI src, memory4 mem) %{\n+  enc_class aarch64_enc_strw(iRegI src, memory mem) %{\n@@ -2969,1 +2973,1 @@\n-  enc_class aarch64_enc_strw0(memory4 mem) %{\n+  enc_class aarch64_enc_strw0(memory mem) %{\n@@ -2976,1 +2980,1 @@\n-  enc_class aarch64_enc_str(iRegL src, memory8 mem) %{\n+  enc_class aarch64_enc_str(iRegL src, memory mem) %{\n@@ -2991,1 +2995,1 @@\n-  enc_class aarch64_enc_str0(memory8 mem) %{\n+  enc_class aarch64_enc_str0(memory mem) %{\n@@ -2998,1 +3002,1 @@\n-  enc_class aarch64_enc_strs(vRegF src, memory4 mem) %{\n+  enc_class aarch64_enc_strs(vRegF src, memory mem) %{\n@@ -3006,1 +3010,1 @@\n-  enc_class aarch64_enc_strd(vRegD src, memory8 mem) %{\n+  enc_class aarch64_enc_strd(vRegD src, memory mem) %{\n@@ -3014,1 +3018,1 @@\n-  enc_class aarch64_enc_strb0_ordered(memory4 mem) %{\n+  enc_class aarch64_enc_strb0_ordered(memory mem) %{\n@@ -3216,1 +3220,1 @@\n-  enc_class aarch64_enc_ldaxr(iRegL dst, memory8 mem) %{\n+  enc_class aarch64_enc_ldaxr(iRegL dst, memory mem) %{\n@@ -3244,1 +3248,1 @@\n-  enc_class aarch64_enc_stlxr(iRegLNoSp src, memory8 mem) %{\n+  enc_class aarch64_enc_stlxr(iRegLNoSp src, memory mem) %{\n@@ -4172,1 +4176,1 @@\n-\/\/ Offset for scaled or unscaled immediate loads and stores\n+\/\/ Offset for immediate loads and stores\n@@ -4175,51 +4179,1 @@\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 0));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset1()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 0));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset2()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 1));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset4()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 2));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset8()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 3));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset16()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 4));\n+  predicate(n->get_int() >= -256 && n->get_int() <= 65520);\n@@ -4243,50 +4197,0 @@\n-operand immLoffset1()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 0));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset2()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 1));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset4()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 2));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset8()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 3));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset16()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 4));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -5205,15 +5109,1 @@\n-operand indOffI1(iRegP reg, immIOffset1 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffI2(iRegP reg, immIOffset2 off)\n+operand indOffI(iRegP reg, immIOffset off)\n@@ -5233,99 +5123,1 @@\n-operand indOffI4(iRegP reg, immIOffset4 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffI8(iRegP reg, immIOffset8 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffI16(iRegP reg, immIOffset16 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL1(iRegP reg, immLoffset1 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL2(iRegP reg, immLoffset2 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL4(iRegP reg, immLoffset4 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL8(iRegP reg, immLoffset8 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL16(iRegP reg, immLoffset16 off)\n+operand indOffL(iRegP reg, immLOffset off)\n@@ -5707,4 +5499,1 @@\n-opclass vmem2(indirect, indIndex, indOffI2, indOffL2);\n-opclass vmem4(indirect, indIndex, indOffI4, indOffL4);\n-opclass vmem8(indirect, indIndex, indOffI8, indOffL8);\n-opclass vmem16(indirect, indIndex, indOffI16, indOffL16);\n+opclass vmem(indirect, indIndex, indOffI, indOffL, indOffIN, indOffLN);\n@@ -5722,17 +5511,3 @@\n-opclass memory1(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI1, indOffL1,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n-\n-opclass memory2(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI2, indOffL2,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n-\n-opclass memory4(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI4, indOffL4,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n-\n-opclass memory8(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI8, indOffL8,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n-\n-\/\/ All of the memory operands. For the pipeline description.\n-opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex,\n-               indOffI1, indOffL1, indOffI2, indOffL2, indOffI4, indOffL4, indOffI8, indOffL8,\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n-\n+opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI, indOffL,\n+               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN,\n+               indOffLN, indirectX2P, indOffX2P);\n@@ -6440,1 +6215,1 @@\n-instruct loadB(iRegINoSp dst, memory1 mem)\n+instruct loadB(iRegINoSp dst, memory mem)\n@@ -6454,1 +6229,1 @@\n-instruct loadB2L(iRegLNoSp dst, memory1 mem)\n+instruct loadB2L(iRegLNoSp dst, memory mem)\n@@ -6468,1 +6243,1 @@\n-instruct loadUB(iRegINoSp dst, memory1 mem)\n+instruct loadUB(iRegINoSp dst, memory mem)\n@@ -6482,1 +6257,1 @@\n-instruct loadUB2L(iRegLNoSp dst, memory1 mem)\n+instruct loadUB2L(iRegLNoSp dst, memory mem)\n@@ -6496,1 +6271,1 @@\n-instruct loadS(iRegINoSp dst, memory2 mem)\n+instruct loadS(iRegINoSp dst, memory mem)\n@@ -6510,1 +6285,1 @@\n-instruct loadS2L(iRegLNoSp dst, memory2 mem)\n+instruct loadS2L(iRegLNoSp dst, memory mem)\n@@ -6524,1 +6299,1 @@\n-instruct loadUS(iRegINoSp dst, memory2 mem)\n+instruct loadUS(iRegINoSp dst, memory mem)\n@@ -6538,1 +6313,1 @@\n-instruct loadUS2L(iRegLNoSp dst, memory2 mem)\n+instruct loadUS2L(iRegLNoSp dst, memory mem)\n@@ -6552,1 +6327,1 @@\n-instruct loadI(iRegINoSp dst, memory4 mem)\n+instruct loadI(iRegINoSp dst, memory mem)\n@@ -6566,1 +6341,1 @@\n-instruct loadI2L(iRegLNoSp dst, memory4 mem)\n+instruct loadI2L(iRegLNoSp dst, memory mem)\n@@ -6580,1 +6355,1 @@\n-instruct loadUI2L(iRegLNoSp dst, memory4 mem, immL_32bits mask)\n+instruct loadUI2L(iRegLNoSp dst, memory mem, immL_32bits mask)\n@@ -6594,1 +6369,1 @@\n-instruct loadL(iRegLNoSp dst, memory8 mem)\n+instruct loadL(iRegLNoSp dst, memory mem)\n@@ -6608,1 +6383,1 @@\n-instruct loadRange(iRegINoSp dst, memory4 mem)\n+instruct loadRange(iRegINoSp dst, memory mem)\n@@ -6621,1 +6396,1 @@\n-instruct loadP(iRegPNoSp dst, memory8 mem)\n+instruct loadP(iRegPNoSp dst, memory mem)\n@@ -6635,1 +6410,1 @@\n-instruct loadN(iRegNNoSp dst, memory4 mem)\n+instruct loadN(iRegNNoSp dst, memory mem)\n@@ -6649,1 +6424,1 @@\n-instruct loadKlass(iRegPNoSp dst, memory8 mem)\n+instruct loadKlass(iRegPNoSp dst, memory mem)\n@@ -6663,1 +6438,1 @@\n-instruct loadNKlass(iRegNNoSp dst, memory4 mem)\n+instruct loadNKlass(iRegNNoSp dst, memory mem)\n@@ -6677,1 +6452,1 @@\n-instruct loadF(vRegF dst, memory4 mem)\n+instruct loadF(vRegF dst, memory mem)\n@@ -6691,1 +6466,1 @@\n-instruct loadD(vRegD dst, memory8 mem)\n+instruct loadD(vRegD dst, memory mem)\n@@ -6895,1 +6670,1 @@\n-instruct storeimmCM0(immI0 zero, memory1 mem)\n+instruct storeimmCM0(immI0 zero, memory mem)\n@@ -6910,1 +6685,1 @@\n-instruct storeimmCM0_ordered(immI0 zero, memory1 mem)\n+instruct storeimmCM0_ordered(immI0 zero, memory mem)\n@@ -6925,1 +6700,1 @@\n-instruct storeB(iRegIorL2I src, memory1 mem)\n+instruct storeB(iRegIorL2I src, memory mem)\n@@ -6939,1 +6714,1 @@\n-instruct storeimmB0(immI0 zero, memory1 mem)\n+instruct storeimmB0(immI0 zero, memory mem)\n@@ -6953,1 +6728,1 @@\n-instruct storeC(iRegIorL2I src, memory2 mem)\n+instruct storeC(iRegIorL2I src, memory mem)\n@@ -6966,1 +6741,1 @@\n-instruct storeimmC0(immI0 zero, memory2 mem)\n+instruct storeimmC0(immI0 zero, memory mem)\n@@ -6981,1 +6756,1 @@\n-instruct storeI(iRegIorL2I src, memory4 mem)\n+instruct storeI(iRegIorL2I src, memory mem)\n@@ -6994,1 +6769,1 @@\n-instruct storeimmI0(immI0 zero, memory4 mem)\n+instruct storeimmI0(immI0 zero, memory mem)\n@@ -7008,1 +6783,1 @@\n-instruct storeL(iRegL src, memory8 mem)\n+instruct storeL(iRegL src, memory mem)\n@@ -7022,1 +6797,1 @@\n-instruct storeimmL0(immL0 zero, memory8 mem)\n+instruct storeimmL0(immL0 zero, memory mem)\n@@ -7036,1 +6811,1 @@\n-instruct storeP(iRegP src, memory8 mem)\n+instruct storeP(iRegP src, memory mem)\n@@ -7050,1 +6825,1 @@\n-instruct storeimmP0(immP0 zero, memory8 mem)\n+instruct storeimmP0(immP0 zero, memory mem)\n@@ -7064,1 +6839,1 @@\n-instruct storeN(iRegN src, memory4 mem)\n+instruct storeN(iRegN src, memory mem)\n@@ -7077,1 +6852,1 @@\n-instruct storeImmN0(immN0 zero, memory4 mem)\n+instruct storeImmN0(immN0 zero, memory mem)\n@@ -7091,1 +6866,1 @@\n-instruct storeF(vRegF src, memory4 mem)\n+instruct storeF(vRegF src, memory mem)\n@@ -7108,1 +6883,1 @@\n-instruct storeD(vRegD src, memory8 mem)\n+instruct storeD(vRegD src, memory mem)\n@@ -7122,1 +6897,1 @@\n-instruct storeNKlass(iRegN src, memory4 mem)\n+instruct storeNKlass(iRegN src, memory mem)\n@@ -7141,1 +6916,1 @@\n-instruct prefetchalloc( memory8 mem ) %{\n+instruct prefetchalloc( memory mem ) %{\n@@ -7710,1 +7485,1 @@\n-instruct popCountI_mem(iRegINoSp dst, memory4 mem, vRegF tmp) %{\n+instruct popCountI_mem(iRegINoSp dst, memory mem, vRegF tmp) %{\n@@ -7751,1 +7526,1 @@\n-instruct popCountL_mem(iRegINoSp dst, memory8 mem, vRegD tmp) %{\n+instruct popCountL_mem(iRegINoSp dst, memory mem, vRegD tmp) %{\n@@ -16021,1 +15796,1 @@\n-    __ fast_lock_lightweight($object$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n+    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -16037,1 +15812,1 @@\n-    __ fast_unlock_lightweight($object$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n+    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -16900,1 +16675,1 @@\n-instruct compressBitsI_memcon(iRegINoSp dst, memory4 mem, immI mask,\n+instruct compressBitsI_memcon(iRegINoSp dst, memory mem, immI mask,\n@@ -16937,1 +16712,1 @@\n-instruct compressBitsL_memcon(iRegLNoSp dst, memory8 mem, immL mask,\n+instruct compressBitsL_memcon(iRegLNoSp dst, memory mem, immL mask,\n@@ -16974,1 +16749,1 @@\n-instruct expandBitsI_memcon(iRegINoSp dst, memory4 mem, immI mask,\n+instruct expandBitsI_memcon(iRegINoSp dst, memory mem, immI mask,\n@@ -17012,1 +16787,1 @@\n-instruct expandBitsL_memcon(iRegINoSp dst, memory8 mem, immL mask,\n+instruct expandBitsL_memcon(iRegINoSp dst, memory mem, immL mask,\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":86,"deletions":311,"binary":false,"changes":397,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-instruct loadV2(vReg dst, vmem2 mem) %{\n+instruct loadV2(vReg dst, vmem mem) %{\n@@ -357,1 +357,1 @@\n-instruct storeV2(vReg src, vmem2 mem) %{\n+instruct storeV2(vReg src, vmem mem) %{\n@@ -366,1 +366,1 @@\n-instruct loadV4(vReg dst, vmem4 mem) %{\n+instruct loadV4(vReg dst, vmem mem) %{\n@@ -375,1 +375,1 @@\n-instruct storeV4(vReg src, vmem4 mem) %{\n+instruct storeV4(vReg src, vmem mem) %{\n@@ -384,1 +384,1 @@\n-instruct loadV8(vReg dst, vmem8 mem) %{\n+instruct loadV8(vReg dst, vmem mem) %{\n@@ -393,1 +393,1 @@\n-instruct storeV8(vReg src, vmem8 mem) %{\n+instruct storeV8(vReg src, vmem mem) %{\n@@ -402,1 +402,1 @@\n-instruct loadV16(vReg dst, vmem16 mem) %{\n+instruct loadV16(vReg dst, vmem mem) %{\n@@ -411,1 +411,1 @@\n-instruct storeV16(vReg src, vmem16 mem) %{\n+instruct storeV16(vReg src, vmem mem) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-instruct $1V$2(vReg $3, vmem$2 mem) %{\n+instruct $1V$2(vReg $3, vmem mem) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  enc_class aarch64_enc_$2($1 dst, memory$5 mem) %{dnl\n+  enc_class aarch64_enc_$2($1 dst, memory mem) %{dnl\n@@ -56,1 +56,1 @@\n-  enc_class aarch64_enc_$2($1 src, memory$5 mem) %{dnl\n+  enc_class aarch64_enc_$2($1 src, memory mem) %{dnl\n@@ -61,1 +61,1 @@\n-  enc_class aarch64_enc_$2`'0(memory$4 mem) %{\n+  enc_class aarch64_enc_$2`'0(memory mem) %{\n@@ -85,1 +85,1 @@\n-  enc_class aarch64_enc_strb0_ordered(memory4 mem) %{\n+  enc_class aarch64_enc_strb0_ordered(memory mem) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/ad_encode.m4","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    lightweight_lock(obj, hdr, temp, rscratch2, slow_case);\n+    lightweight_lock(disp_hdr, obj, hdr, temp, rscratch2, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register t1,\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register t1,\n@@ -230,1 +230,1 @@\n-  assert_different_registers(obj, t1, t2, t3);\n+  assert_different_registers(obj, box, t1, t2, t3);\n@@ -239,0 +239,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    str(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }\n+\n@@ -247,0 +252,1 @@\n+  const Register t3_t = t3;\n@@ -254,1 +260,0 @@\n-    const Register t3_t = t3;\n@@ -292,3 +297,38 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register t1_tagged_monitor = t1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register t1_monitor = t1;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(t1_monitor == t1_mark, \"should be the same here\");\n+    } else {\n+      Label monitor_found;\n+\n+      \/\/ Load cache address\n+      lea(t3_t, Address(rthread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        ldr(t1, Address(t3_t));\n+        cmp(obj, t1);\n+        br(Assembler::EQ, monitor_found);\n+        increment(t3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      Label loop;\n+\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      ldr(t1, Address(t3_t));\n+      cmp(obj, t1);\n+      br(Assembler::EQ, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      increment(t3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      cbnz(t1, loop);\n+      \/\/ Cache Miss, NE set from cmp above, cbnz does not set flags\n+      b(slow_path);\n+\n+      bind(monitor_found);\n+      ldr(t1_monitor, Address(t3_t, OMCache::oop_to_monitor_difference()));\n+    }\n+\n@@ -297,0 +337,5 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address owner_address(t1_monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+    const Address recursions_address(t1_monitor, ObjectMonitor::recursions_offset() - monitor_tag);\n+\n+    Label monitor_locked;\n@@ -299,1 +344,1 @@\n-    lea(t2_owner_addr, Address(t1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n+    lea(t2_owner_addr, owner_address);\n@@ -304,1 +349,1 @@\n-    br(Assembler::EQ, locked);\n+    br(Assembler::EQ, monitor_locked);\n@@ -311,1 +356,6 @@\n-    increment(Address(t1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1);\n+    increment(recursions_address, 1);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      str(t1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+    }\n@@ -334,2 +384,2 @@\n-void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register t1, Register t2,\n-                                                Register t3) {\n+void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register box, Register t1,\n+                                                Register t2, Register t3) {\n@@ -337,1 +387,1 @@\n-  assert_different_registers(obj, t1, t2, t3);\n+  assert_different_registers(obj, box, t1, t2, t3);\n@@ -340,1 +390,1 @@\n-  Label inflated, inflated_load_monitor;\n+  Label inflated, inflated_load_mark;\n@@ -352,0 +402,2 @@\n+    Label push_and_slow_path;\n+\n@@ -358,1 +410,1 @@\n-    br(Assembler::NE, inflated_load_monitor);\n+    br(Assembler::NE, inflated_load_mark);\n@@ -375,1 +427,4 @@\n-    tbnz(t1_mark, exact_log2(markWord::monitor_value), inflated);\n+    \/\/ Because we got here by popping (meaning we pushed in locked)\n+    \/\/ there will be no monitor in the box. So we need to push back the obj\n+    \/\/ so that the runtime can fix any potential anonymous owner.\n+    tbnz(t1_mark, exact_log2(markWord::monitor_value), UseObjectMonitorTable ? push_and_slow_path : inflated);\n@@ -384,0 +439,1 @@\n+    bind(push_and_slow_path);\n@@ -394,1 +450,1 @@\n-    bind(inflated_load_monitor);\n+    bind(inflated_load_mark);\n@@ -415,3 +471,4 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register t1_monitor = t1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register t1_monitor = t1;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(t1_monitor == t1_mark, \"should be the same here\");\n@@ -419,2 +476,8 @@\n-    \/\/ Untag the monitor.\n-    sub(t1_monitor, t1_mark, monitor_tag);\n+      \/\/ Untag the monitor.\n+      add(t1_monitor, t1_mark, -(int)markWord::monitor_value);\n+    } else {\n+      ldr(t1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ null check with Flags == NE, no valid pointer below alignof(ObjectMonitor*)\n+      cmp(t1_monitor, checked_cast<uint8_t>(alignof(ObjectMonitor*)));\n+      br(Assembler::LO, slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":84,"deletions":21,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-  void fast_lock_lightweight(Register object, Register t1, Register t2, Register t3);\n-  void fast_unlock_lightweight(Register object, Register t1, Register t2, Register t3);\n+  void fast_lock_lightweight(Register object, Register box, Register t1, Register t2, Register t3);\n+  void fast_unlock_lightweight(Register object, Register box, Register t1, Register t2, Register t3);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-instruct xLoadP(iRegPNoSp dst, memory8 mem, rFlagsReg cr)\n+instruct xLoadP(iRegPNoSp dst, memory mem, rFlagsReg cr)\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/x\/x_aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-instruct zLoadP(iRegPNoSp dst, memory8 mem, rFlagsReg cr)\n+instruct zLoadP(iRegPNoSp dst, memory mem, rFlagsReg cr)\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -699,1 +699,1 @@\n-      lightweight_lock(obj_reg, tmp, tmp2, tmp3, slow_case);\n+      lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n@@ -755,9 +755,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-              obj_reg);\n-    } else {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-              lock_reg);\n-    }\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+            lock_reg);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -747,1 +747,1 @@\n-    lea(rscratch1, RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+    lea(rscratch1, RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n@@ -6753,1 +6753,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register t1, Register t2, Register t3, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register t1, Register t2, Register t3, Label& slow) {\n@@ -6755,1 +6755,1 @@\n-  assert_different_registers(obj, t1, t2, t3, rscratch1);\n+  assert_different_registers(basic_lock, obj, t1, t2, t3, rscratch1);\n@@ -6766,0 +6766,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    str(zr, Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1642,1 +1642,1 @@\n-  void lightweight_lock(Register obj, Register t1, Register t2, Register t3, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register t1, Register t2, Register t3, Label& slow);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_AbstractMethodError_entry()));\n@@ -454,1 +454,1 @@\n-      __ far_jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));\n+      __ far_jump(RuntimeAddress(SharedRuntime::throw_IncompatibleClassChangeError_entry()));\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif\n+\n@@ -1814,1 +1820,1 @@\n-      __ lightweight_lock(obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n+      __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -2767,0 +2773,190 @@\n+\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Since we need to preserve callee-saved values (currently\n+\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+\/\/ map and therefore have to make these stubs into RuntimeStubs\n+\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+\/\/ be preserved between the fault point and the exception handler\n+\/\/ then it must assume responsibility for that in\n+\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  \/\/ n.b. aarch64 asserts that frame::arg_reg_save_area_bytes == 0\n+  enum layout {\n+    rfp_off = 0,\n+    rfp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 512;\n+  int locs_size  = 64;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+\n+  __ enter(); \/\/ Save FP and LR before call\n+\n+  assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n+\n+  \/\/ lr and fp are already in place\n+  __ sub(sp, rfp, ((uint64_t)framesize-4) << LogBytesPerInt); \/\/ prolog\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n+\n+  __ mov(c_rarg0, rthread);\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ mov(rscratch1, runtime_entry);\n+  __ blr(rscratch1);\n+\n+  \/\/ Generate oop map\n+  OopMap* map = new OopMap(framesize, 0);\n+\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+  \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+  __ reinitialize_ptrue();\n+\n+  __ leave();\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));\n+  __ cbnz(rscratch1, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/\/ ASSERT\n+  __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+static void jfr_prologue(address the_pc, MacroAssembler* masm, Register thread) {\n+  __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n+  __ mov(c_rarg0, thread);\n+}\n+\n+\/\/ The handle is dereferenced through a load barrier.\n+static void jfr_epilogue(MacroAssembler* masm) {\n+  __ reset_last_Java_frame(true);\n+}\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+  jfr_epilogue(masm);\n+  __ resolve_global_jobject(r0, rscratch1, rscratch2);\n+  __ leave();\n+  __ ret(lr);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+\n+  CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  jfr_epilogue(masm);\n+\n+  __ leave();\n+  __ ret(lr);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":197,"deletions":1,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -7048,1 +7048,1 @@\n-    __ lea(rscratch1, RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+    __ lea(rscratch1, RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -7308,92 +7308,0 @@\n-#if INCLUDE_JFR\n-\n-  static void jfr_prologue(address the_pc, MacroAssembler* _masm, Register thread) {\n-    __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n-    __ mov(c_rarg0, thread);\n-  }\n-\n-  \/\/ The handle is dereferenced through a load barrier.\n-  static void jfr_epilogue(MacroAssembler* _masm) {\n-    __ reset_last_Java_frame(true);\n-  }\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      rbp_off,\n-      rbpH_off,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-    jfr_epilogue(_masm);\n-    __ resolve_global_jobject(r0, rscratch1, rscratch2);\n-    __ leave();\n-    __ ret(lr);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      rbp_off,\n-      rbpH_off,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-    jfr_epilogue(_masm);\n-\n-    __ leave();\n-    __ ret(lr);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -7415,16 +7323,0 @@\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Since we need to preserve callee-saved values (currently\n-  \/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-  \/\/ map and therefore have to make these stubs into RuntimeStubs\n-  \/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-  \/\/ be preserved between the fault point and the exception handler\n-  \/\/ then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n@@ -7434,90 +7326,0 @@\n-  address generate_throw_exception(const char* name,\n-                                   address runtime_entry,\n-                                   Register arg1 = noreg,\n-                                   Register arg2 = noreg) {\n-    \/\/ Information about frame layout at time of blocking runtime call.\n-    \/\/ Note that we only have to preserve callee-saved registers since\n-    \/\/ the compilers are responsible for supplying a continuation point\n-    \/\/ if they expect all registers to be preserved.\n-    \/\/ n.b. aarch64 asserts that frame::arg_reg_save_area_bytes == 0\n-    enum layout {\n-      rfp_off = 0,\n-      rfp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 512;\n-    int locs_size  = 64;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-\n-    __ enter(); \/\/ Save FP and LR before call\n-\n-    assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n-\n-    \/\/ lr and fp are already in place\n-    __ sub(sp, rfp, ((uint64_t)framesize-4) << LogBytesPerInt); \/\/ prolog\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    address the_pc = __ pc();\n-    __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n-\n-    \/\/ Call runtime\n-    if (arg1 != noreg) {\n-      assert(arg2 != c_rarg1, \"clobbered\");\n-      __ mov(c_rarg1, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mov(c_rarg2, arg2);\n-    }\n-    __ mov(c_rarg0, rthread);\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ mov(rscratch1, runtime_entry);\n-    __ blr(rscratch1);\n-\n-    \/\/ Generate oop map\n-    OopMap* map = new OopMap(framesize, 0);\n-\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    __ reset_last_Java_frame(true);\n-\n-    \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n-    \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n-    __ reinitialize_ptrue();\n-\n-    __ leave();\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));\n-    __ cbnz(rscratch1, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/\/ ASSERT\n-    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-    \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name,\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub->entry_point();\n-  }\n-\n@@ -8366,10 +8168,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_StackOverflowError));\n-    StubRoutines::_throw_delayed_StackOverflowError_entry =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_delayed_StackOverflowError));\n-\n@@ -8411,10 +8203,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n-  }\n-\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -8422,1 +8204,0 @@\n-#endif \/\/ INCLUDE_JFR\n@@ -8429,17 +8210,0 @@\n-    StubRoutines::_throw_AbstractMethodError_entry =\n-      generate_throw_exception(\"AbstractMethodError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_AbstractMethodError));\n-\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry =\n-      generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_IncompatibleClassChangeError));\n-\n-    StubRoutines::_throw_NullPointerException_at_call_entry =\n-      generate_throw_exception(\"NullPointerException at call throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_NullPointerException_at_call));\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":237,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -755,2 +755,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -988,9 +988,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Pass oop, not lock, in fast lock case. call_VM wants R1 though.\n-      push(R1);\n-      mov(R1, Robj);\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj), R1);\n-      pop(R1);\n-    } else {\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), Rlock);\n-    }\n+    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), Rlock);\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -143,1 +144,1 @@\n-  __ jump(StubRoutines::throw_AbstractMethodError_entry(), relocInfo::runtime_call_type, Rtemp);\n+  __ jump(SharedRuntime::throw_AbstractMethodError_entry(), relocInfo::runtime_call_type, Rtemp);\n@@ -464,1 +465,1 @@\n-      __ jump(StubRoutines::throw_IncompatibleClassChangeError_entry(), relocInfo::runtime_call_type, Rtemp);\n+      __ jump(SharedRuntime::throw_IncompatibleClassChangeError_entry(), relocInfo::runtime_call_type, Rtemp);\n","filename":"src\/hotspot\/cpu\/arm\/methodHandles_arm.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1731,0 +1731,140 @@\n+\n+\/\/------------------------------------------------------------------------------------------------------------------------\n+\/\/ Continuation point for throwing of implicit exceptions that are not handled in\n+\/\/ the current activation. Fabricates an exception oop and initiates normal\n+\/\/ exception dispatching in this frame.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  int insts_size = 128;\n+  int locs_size  = 32;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps;\n+  int frame_size;\n+  int frame_complete;\n+\n+  oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  frame_size = 2;\n+  __ mov(Rexception_pc, LR);\n+  __ raw_push(FP, LR);\n+\n+  frame_complete = __ pc() - start;\n+\n+  \/\/ Any extra arguments are already supposed to be R1 and R2\n+  __ mov(R0, Rthread);\n+\n+  int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp);\n+  assert(((__ pc()) - start) == __ offset(), \"warning: start differs from code_begin\");\n+  __ call(runtime_entry);\n+  if (pc_offset == -1) {\n+    pc_offset = __ offset();\n+  }\n+\n+  \/\/ Generate oop map\n+  OopMap* map =  new OopMap(frame_size*VMRegImpl::slots_per_word, 0);\n+  oop_maps->add_gc_map(pc_offset, map);\n+  __ reset_last_Java_frame(Rtemp); \/\/ Rtemp free since scratched by far call\n+\n+  __ raw_pop(FP, LR);\n+  __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);\n+\n+  RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                                    frame_size, oop_maps, false);\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    r1_off,\n+    r2_off,\n+    return_off,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ raw_push(R1, R2, LR);\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(SP, FP, true, Rtemp);\n+  __ mov(c_rarg0, Rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), c_rarg0);\n+  __ reset_last_Java_frame(Rtemp);\n+\n+  \/\/ R0 is jobject handle result, unpack and process it through a barrier.\n+  __ resolve_global_jobject(R0, Rtemp, R1);\n+\n+  __ raw_pop(R1, R2, LR);\n+  __ ret();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    r1_off,\n+    r2_off,\n+    return_off,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_return_lease\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ raw_push(R1, R2, LR);\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(SP, FP, true, Rtemp);\n+  __ mov(c_rarg0, Rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), c_rarg0);\n+  __ reset_last_Java_frame(Rtemp);\n+\n+  __ raw_pop(R1, R2, LR);\n+  __ ret();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":140,"deletions":0,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2964,46 +2964,0 @@\n-  \/\/------------------------------------------------------------------------------------------------------------------------\n-  \/\/ Continuation point for throwing of implicit exceptions that are not handled in\n-  \/\/ the current activation. Fabricates an exception oop and initiates normal\n-  \/\/ exception dispatching in this frame.\n-  address generate_throw_exception(const char* name, address runtime_entry) {\n-    int insts_size = 128;\n-    int locs_size  = 32;\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps;\n-    int frame_size;\n-    int frame_complete;\n-\n-    oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-\n-    frame_size = 2;\n-    __ mov(Rexception_pc, LR);\n-    __ raw_push(FP, LR);\n-\n-    frame_complete = __ pc() - start;\n-\n-    \/\/ Any extra arguments are already supposed to be R1 and R2\n-    __ mov(R0, Rthread);\n-\n-    int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp);\n-    assert(((__ pc()) - start) == __ offset(), \"warning: start differs from code_begin\");\n-    __ call(runtime_entry);\n-    if (pc_offset == -1) {\n-      pc_offset = __ offset();\n-    }\n-\n-    \/\/ Generate oop map\n-    OopMap* map =  new OopMap(frame_size*VMRegImpl::slots_per_word, 0);\n-    oop_maps->add_gc_map(pc_offset, map);\n-    __ reset_last_Java_frame(Rtemp); \/\/ Rtemp free since scratched by far call\n-\n-    __ raw_pop(FP, LR);\n-    __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);\n-\n-    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n-                                                      frame_size, oop_maps, false);\n-    return stub->entry_point();\n-  }\n-\n@@ -3028,89 +2982,0 @@\n-#if INCLUDE_JFR\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      r1_off,\n-      r2_off,\n-      return_off,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-    __ raw_push(R1, R2, LR);\n-    address the_pc = __ pc();\n-\n-    int frame_complete = the_pc - start;\n-\n-    __ set_last_Java_frame(SP, FP, true, Rtemp);\n-    __ mov(c_rarg0, Rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), c_rarg0);\n-    __ reset_last_Java_frame(Rtemp);\n-\n-    \/\/ R0 is jobject handle result, unpack and process it through a barrier.\n-    __ resolve_global_jobject(R0, Rtemp, R1);\n-\n-    __ raw_pop(R1, R2, LR);\n-    __ ret();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(frame_complete, map);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps,\n-                                    false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      r1_off,\n-      r2_off,\n-      return_off,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    CodeBuffer code(\"jfr_return_lease\", 512, 64);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-    __ raw_push(R1, R2, LR);\n-    address the_pc = __ pc();\n-\n-    int frame_complete = the_pc - start;\n-\n-    __ set_last_Java_frame(SP, FP, true, Rtemp);\n-    __ mov(c_rarg0, Rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), c_rarg0);\n-    __ reset_last_Java_frame(Rtemp);\n-\n-    __ raw_pop(R1, R2, LR);\n-    __ ret();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(frame_complete, map);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps,\n-                                    false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -3135,2 +3000,0 @@\n-    StubRoutines::_throw_StackOverflowError_entry  = generate_throw_exception(\"StackOverflowError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));\n-\n@@ -3158,2 +3021,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n@@ -3162,9 +3023,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-  }\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -3174,6 +3026,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in non-core builds\n-    \/\/ and need to be relocatable, so they each fabricate a RuntimeStub internally.\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));\n-\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":0,"deletions":154,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -563,1 +563,1 @@\n-  __ b(StubRoutines::throw_StackOverflowError_entry(), ls);\n+  __ b(SharedRuntime::throw_StackOverflowError_entry(), ls);\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1046,5 +1046,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj), object);\n-    } else {\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-    }\n+    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1504,1 +1504,1 @@\n-  load_const_optimized(R0, StubRoutines::throw_delayed_StackOverflowError_entry());\n+  load_const_optimized(R0, SharedRuntime::throw_delayed_StackOverflowError_entry());\n@@ -2173,1 +2173,0 @@\n-\/\/ Return true: we succeeded in generating this code\n@@ -2295,3 +2294,2 @@\n-  assert(Klass::SECONDARY_SUPERS_BITMAP_FULL == ~uintx(0), \"\");\n-  cmpdi(CCR0, r_bitmap, -1);\n-  beq(CCR0, L_huge);\n+  cmpwi(CCR0, r_array_length, (int32_t)Klass::SECONDARY_SUPERS_TABLE_SIZE - 2);\n+  bgt(CCR0, L_huge);\n@@ -2807,26 +2805,33 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tagged_monitor = mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-    const Register owner_addr = tmp2;\n-\n-    \/\/ Compute owner address.\n-    addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n-\n-    \/\/ CAS owner (null => current thread).\n-    cmpxchgd(\/*flag=*\/flag,\n-            \/*current_value=*\/t,\n-            \/*compare_value=*\/(intptr_t)0,\n-            \/*exchange_value=*\/R16_thread,\n-            \/*where=*\/owner_addr,\n-            MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-            MacroAssembler::cmpxchgx_hint_acquire_lock());\n-    beq(flag, locked);\n-\n-    \/\/ Check if recursive.\n-    cmpd(flag, t, R16_thread);\n-    bne(flag, slow_path);\n-\n-    \/\/ Recursive.\n-    ld(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n-    addi(tmp1, tmp1, 1);\n-    std(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register tagged_monitor = mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+      const Register owner_addr = tmp2;\n+\n+      \/\/ Compute owner address.\n+      addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n+\n+      \/\/ CAS owner (null => current thread).\n+      cmpxchgd(\/*flag=*\/flag,\n+              \/*current_value=*\/t,\n+              \/*compare_value=*\/(intptr_t)0,\n+              \/*exchange_value=*\/R16_thread,\n+              \/*where=*\/owner_addr,\n+              MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n+              MacroAssembler::cmpxchgx_hint_acquire_lock());\n+      beq(flag, locked);\n+\n+      \/\/ Check if recursive.\n+      cmpd(flag, t, R16_thread);\n+      bne(flag, slow_path);\n+\n+      \/\/ Recursive.\n+      ld(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+      addi(tmp1, tmp1, 1);\n+      std(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      crxor(flag, Assembler::equal, flag, Assembler::equal);\n+      b(slow_path);\n+    }\n@@ -2946,43 +2951,50 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register monitor = mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-\n-    \/\/ Untag the monitor.\n-    subi(monitor, mark, monitor_tag);\n-\n-    const Register recursions = tmp2;\n-    Label not_recursive;\n-\n-    \/\/ Check if recursive.\n-    ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-    addic_(recursions, recursions, -1);\n-    blt(CCR0, not_recursive);\n-\n-    \/\/ Recursive unlock.\n-    std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-    crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n-    b(unlocked);\n-\n-    bind(not_recursive);\n-\n-    Label release_;\n-    const Register t2 = tmp2;\n-\n-    \/\/ Check if the entry lists are empty.\n-    ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n-    ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n-    orr(t, t, t2);\n-    cmpdi(flag, t, 0);\n-    beq(flag, release_);\n-\n-    \/\/ The owner may be anonymous and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n-    b(slow_path);\n-\n-    bind(release_);\n-    \/\/ Set owner to null.\n-    release();\n-    \/\/ t contains 0\n-    std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register monitor = mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+\n+      \/\/ Untag the monitor.\n+      subi(monitor, mark, monitor_tag);\n+\n+      const Register recursions = tmp2;\n+      Label not_recursive;\n+\n+      \/\/ Check if recursive.\n+      ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+      addic_(recursions, recursions, -1);\n+      blt(CCR0, not_recursive);\n+\n+      \/\/ Recursive unlock.\n+      std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+      crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n+      b(unlocked);\n+\n+      bind(not_recursive);\n+\n+      Label release_;\n+      const Register t2 = tmp2;\n+\n+      \/\/ Check if the entry lists are empty.\n+      ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n+      ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n+      orr(t, t, t2);\n+      cmpdi(flag, t, 0);\n+      beq(flag, release_);\n+\n+      \/\/ The owner may be anonymous and we removed the last obj entry in\n+      \/\/ the lock-stack. This loses the information about the owner.\n+      \/\/ Write the thread to the owner field so the runtime knows the owner.\n+      std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+      b(slow_path);\n+\n+      bind(release_);\n+      \/\/ Set owner to null.\n+      release();\n+      \/\/ t contains 0\n+      std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      crxor(flag, Assembler::equal, flag, Assembler::equal);\n+      b(slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":86,"deletions":74,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -161,2 +161,2 @@\n-  assert(StubRoutines::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n-  __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());\n+  assert(SharedRuntime::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n+  __ load_const_optimized(target, SharedRuntime::throw_AbstractMethodError_entry());\n@@ -492,1 +492,1 @@\n-      __ load_const_optimized(temp1, StubRoutines::throw_IncompatibleClassChangeError_entry());\n+      __ load_const_optimized(temp1, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n","filename":"src\/hotspot\/cpu\/ppc\/methodHandles_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -3407,0 +3408,94 @@\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Only callee-saved registers are preserved (through the\n+\/\/ normal register window \/ RegisterMap handling).  If the compiler\n+\/\/ needs all registers to be preserved between the fault point and\n+\/\/ the exception handler then it must assume responsibility for that\n+\/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\/\/\n+\/\/ Note that we generate only this stub into a RuntimeStub, because\n+\/\/ it needs to be properly traversed and ignored during GC, so we\n+\/\/ change the meaning of the \"__\" macro within this method.\n+\/\/\n+\/\/ Note: the routine set_pc_not_at_call_for_caller in\n+\/\/ SharedRuntime.cpp requires that this code be generated into a\n+\/\/ RuntimeStub.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, 1024 DEBUG_ONLY(+ 512), 0);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  int frame_size_in_bytes = frame::native_abi_reg_args_size;\n+  OopMap* map = new OopMap(frame_size_in_bytes \/ sizeof(jint), 0);\n+\n+  address start = __ pc();\n+\n+  __ save_LR(R11_scratch1);\n+\n+  \/\/ Push a frame.\n+  __ push_frame_reg_args(0, R11_scratch1);\n+\n+  address frame_complete_pc = __ pc();\n+\n+  \/\/ Note that we always have a runtime stub frame on the top of\n+  \/\/ stack by this point. Remember the offset of the instruction\n+  \/\/ whose address will be moved to R11_scratch1.\n+  address gc_map_pc = __ get_PC_trash_LR(R11_scratch1);\n+\n+  __ set_last_Java_frame(\/*sp*\/R1_SP, \/*pc*\/R11_scratch1);\n+\n+  __ mr(R3_ARG1, R16_thread);\n+#if defined(ABI_ELFv2)\n+  __ call_c(runtime_entry, relocInfo::none);\n+#else\n+  __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, runtime_entry), relocInfo::none);\n+#endif\n+\n+  \/\/ Set an oopmap for the call site.\n+  oop_maps->add_gc_map((int)(gc_map_pc - start), map);\n+\n+  __ reset_last_Java_frame();\n+\n+#ifdef ASSERT\n+  \/\/ Make sure that this code is only executed if there is a pending\n+  \/\/ exception.\n+  {\n+    Label L;\n+    __ ld(R0,\n+          in_bytes(Thread::pending_exception_offset()),\n+          R16_thread);\n+    __ cmpdi(CCR0, R0, 0);\n+    __ bne(CCR0, L);\n+    __ stop(\"SharedRuntime::throw_exception: no pending exception\");\n+    __ bind(L);\n+  }\n+#endif\n+\n+  \/\/ Pop frame.\n+  __ pop_frame();\n+\n+  __ restore_LR(R11_scratch1);\n+\n+  __ load_const(R11_scratch1, StubRoutines::forward_exception_entry());\n+  __ mtctr(R11_scratch1);\n+  __ bctr();\n+\n+  \/\/ Create runtime stub with OopMap.\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name, &code,\n+                                  \/*frame_complete=*\/ (int)(frame_complete_pc - start),\n+                                  frame_size_in_bytes\/wordSize,\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n@@ -3650,0 +3745,78 @@\n+\n+#if INCLUDE_JFR\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  Register tmp1 = R10_ARG8;\n+  Register tmp2 = R9_ARG7;\n+\n+  int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n+  address start = __ pc();\n+  __ mflr(tmp1);\n+  __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n+  __ push_frame_reg_args(0, tmp1);\n+  int frame_complete = __ pc() - start;\n+  __ set_last_Java_frame(R1_SP, noreg);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), R16_thread);\n+  address calls_return_pc = __ last_calls_return_pc();\n+  __ reset_last_Java_frame();\n+  \/\/ The handle is dereferenced through a load barrier.\n+  __ resolve_global_jobject(R3_RET, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n+  __ pop_frame();\n+  __ ld(tmp1, _abi0(lr), R1_SP);\n+  __ mtlr(tmp1);\n+  __ blr();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 0);\n+  oop_maps->add_gc_map(calls_return_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  CodeBuffer code(\"jfr_return_lease\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  Register tmp1 = R10_ARG8;\n+  Register tmp2 = R9_ARG7;\n+\n+  int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n+  address start = __ pc();\n+  __ mflr(tmp1);\n+  __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n+  __ push_frame_reg_args(0, tmp1);\n+  int frame_complete = __ pc() - start;\n+  __ set_last_Java_frame(R1_SP, noreg);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), R16_thread);\n+  address calls_return_pc = __ last_calls_return_pc();\n+  __ reset_last_Java_frame();\n+  __ pop_frame();\n+  __ ld(tmp1, _abi0(lr), R1_SP);\n+  __ mtlr(tmp1);\n+  __ blr();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 0);\n+  oop_maps->add_gc_map(calls_return_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":173,"deletions":0,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -520,103 +520,0 @@\n-#define __ masm->\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Only callee-saved registers are preserved (through the\n-  \/\/ normal register window \/ RegisterMap handling).  If the compiler\n-  \/\/ needs all registers to be preserved between the fault point and\n-  \/\/ the exception handler then it must assume responsibility for that\n-  \/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-  \/\/\n-  \/\/ Note that we generate only this stub into a RuntimeStub, because\n-  \/\/ it needs to be properly traversed and ignored during GC, so we\n-  \/\/ change the meaning of the \"__\" macro within this method.\n-  \/\/\n-  \/\/ Note: the routine set_pc_not_at_call_for_caller in\n-  \/\/ SharedRuntime.cpp requires that this code be generated into a\n-  \/\/ RuntimeStub.\n-  address generate_throw_exception(const char* name, address runtime_entry, bool restore_saved_exception_pc,\n-                                   Register arg1 = noreg, Register arg2 = noreg) {\n-    CodeBuffer code(name, 1024 DEBUG_ONLY(+ 512), 0);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    int frame_size_in_bytes = frame::native_abi_reg_args_size;\n-    OopMap* map = new OopMap(frame_size_in_bytes \/ sizeof(jint), 0);\n-\n-    address start = __ pc();\n-\n-    __ save_LR(R11_scratch1);\n-\n-    \/\/ Push a frame.\n-    __ push_frame_reg_args(0, R11_scratch1);\n-\n-    address frame_complete_pc = __ pc();\n-\n-    if (restore_saved_exception_pc) {\n-      __ unimplemented(\"StubGenerator::throw_exception with restore_saved_exception_pc\");\n-    }\n-\n-    \/\/ Note that we always have a runtime stub frame on the top of\n-    \/\/ stack by this point. Remember the offset of the instruction\n-    \/\/ whose address will be moved to R11_scratch1.\n-    address gc_map_pc = __ get_PC_trash_LR(R11_scratch1);\n-\n-    __ set_last_Java_frame(\/*sp*\/R1_SP, \/*pc*\/R11_scratch1);\n-\n-    __ mr(R3_ARG1, R16_thread);\n-    if (arg1 != noreg) {\n-      __ mr(R4_ARG2, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mr(R5_ARG3, arg2);\n-    }\n-#if defined(ABI_ELFv2)\n-    __ call_c(runtime_entry, relocInfo::none);\n-#else\n-    __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, runtime_entry), relocInfo::none);\n-#endif\n-\n-    \/\/ Set an oopmap for the call site.\n-    oop_maps->add_gc_map((int)(gc_map_pc - start), map);\n-\n-    __ reset_last_Java_frame();\n-\n-#ifdef ASSERT\n-    \/\/ Make sure that this code is only executed if there is a pending\n-    \/\/ exception.\n-    {\n-      Label L;\n-      __ ld(R0,\n-                in_bytes(Thread::pending_exception_offset()),\n-                R16_thread);\n-      __ cmpdi(CCR0, R0, 0);\n-      __ bne(CCR0, L);\n-      __ stop(\"StubRoutines::throw_exception: no pending exception\");\n-      __ bind(L);\n-    }\n-#endif\n-\n-    \/\/ Pop frame.\n-    __ pop_frame();\n-\n-    __ restore_LR(R11_scratch1);\n-\n-    __ load_const(R11_scratch1, StubRoutines::forward_exception_entry());\n-    __ mtctr(R11_scratch1);\n-    __ bctr();\n-\n-    \/\/ Create runtime stub with OopMap.\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name, &code,\n-                                    \/*frame_complete=*\/ (int)(frame_complete_pc - start),\n-                                    frame_size_in_bytes\/wordSize,\n-                                    oop_maps,\n-                                    false);\n-    return stub->entry_point();\n-  }\n-#undef __\n@@ -4619,1 +4516,1 @@\n-    __ load_const_optimized(tmp1, (StubRoutines::throw_StackOverflowError_entry()), R0);\n+    __ load_const_optimized(tmp1, (SharedRuntime::throw_StackOverflowError_entry()), R0);\n@@ -4678,78 +4575,0 @@\n-#if INCLUDE_JFR\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  RuntimeStub* generate_jfr_write_checkpoint() {\n-    CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n-    MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-    Register tmp1 = R10_ARG8;\n-    Register tmp2 = R9_ARG7;\n-\n-    int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n-    address start = __ pc();\n-    __ mflr(tmp1);\n-    __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n-    __ push_frame_reg_args(0, tmp1);\n-    int frame_complete = __ pc() - start;\n-    __ set_last_Java_frame(R1_SP, noreg);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), R16_thread);\n-    address calls_return_pc = __ last_calls_return_pc();\n-    __ reset_last_Java_frame();\n-    \/\/ The handle is dereferenced through a load barrier.\n-    __ resolve_global_jobject(R3_RET, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n-    __ pop_frame();\n-    __ ld(tmp1, _abi0(lr), R1_SP);\n-    __ mtlr(tmp1);\n-    __ blr();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 0);\n-    oop_maps->add_gc_map(calls_return_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  RuntimeStub* generate_jfr_return_lease() {\n-    CodeBuffer code(\"jfr_return_lease\", 512, 64);\n-    MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-    Register tmp1 = R10_ARG8;\n-    Register tmp2 = R9_ARG7;\n-\n-    int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n-    address start = __ pc();\n-    __ mflr(tmp1);\n-    __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n-    __ push_frame_reg_args(0, tmp1);\n-    int frame_complete = __ pc() - start;\n-    __ set_last_Java_frame(R1_SP, noreg);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), R16_thread);\n-    address calls_return_pc = __ last_calls_return_pc();\n-    __ reset_last_Java_frame();\n-    __ pop_frame();\n-    __ ld(tmp1, _abi0(lr), R1_SP);\n-    __ mtlr(tmp1);\n-    __ blr();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 0);\n-    oop_maps->add_gc_map(calls_return_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -4789,8 +4608,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry   =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError), false);\n-    StubRoutines::_throw_delayed_StackOverflowError_entry =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError), false);\n-\n@@ -4815,10 +4626,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n-  }\n-\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -4826,1 +4627,0 @@\n-#endif \/\/ INCLUDE_JFR\n@@ -4831,7 +4631,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in\n-    \/\/ non-core builds\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError),  false);\n-    \/\/ Handle IncompatibleClassChangeError in itable stubs.\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError),  false);\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call), false);\n-\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":1,"deletions":208,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -786,2 +786,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"generated in wrong order\");\n-  __ load_const_optimized(Rscratch1, (StubRoutines::throw_StackOverflowError_entry()), R0);\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"generated in wrong order\");\n+  __ load_const_optimized(Rscratch1, (SharedRuntime::throw_StackOverflowError_entry()), R0);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    lightweight_lock(obj, hdr, temp, t1, slow_case);\n+    lightweight_lock(disp_hdr, obj, hdr, temp, t1, slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,1 +256,2 @@\n-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register tmp1, Register tmp2, Register tmp3) {\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box,\n+                                              Register tmp1, Register tmp2, Register tmp3) {\n@@ -261,1 +262,1 @@\n-  assert_different_registers(obj, tmp1, tmp2, tmp3, flag, t0);\n+  assert_different_registers(obj, box, tmp1, tmp2, tmp3, flag, t0);\n@@ -272,0 +273,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    sd(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }\n+\n@@ -280,0 +286,1 @@\n+  const Register tmp3_t = tmp3;\n@@ -287,1 +294,0 @@\n-    const Register tmp3_t = tmp3;\n@@ -326,3 +332,35 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tmp1_tagged_monitor = tmp1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register tmp1_monitor = tmp1;\n+    if (!UseObjectMonitorTable) {\n+      assert(tmp1_monitor == tmp1_mark, \"should be the same here\");\n+    } else {\n+      Label monitor_found;\n+\n+      \/\/ Load cache address\n+      la(tmp3_t, Address(xthread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        ld(tmp1, Address(tmp3_t));\n+        beq(obj, tmp1, monitor_found);\n+        add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      Label loop;\n+\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      ld(tmp1, Address(tmp3_t));\n+      beq(obj, tmp1, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      bnez(tmp1, loop);\n+      \/\/ Cache Miss. Take the slowpath.\n+      j(slow_path);\n+\n+      bind(monitor_found);\n+      ld(tmp1_monitor, Address(tmp3_t, OMCache::oop_to_monitor_difference()));\n+    }\n+\n@@ -332,0 +370,6 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address owner_address(tmp1_monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+    const Address recursions_address(tmp1_monitor, ObjectMonitor::recursions_offset() - monitor_tag);\n+\n+    Label monitor_locked;\n+\n@@ -333,1 +377,1 @@\n-    la(tmp2_owner_addr, Address(tmp1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n+    la(tmp2_owner_addr, owner_address);\n@@ -338,1 +382,1 @@\n-    beqz(tmp3_owner, locked);\n+    beqz(tmp3_owner, monitor_locked);\n@@ -344,1 +388,6 @@\n-    increment(Address(tmp1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1, tmp2, tmp3);\n+    increment(recursions_address, 1, tmp2, tmp3);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      sd(tmp1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+    }\n@@ -368,2 +417,2 @@\n-void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register tmp1, Register tmp2,\n-                                                Register tmp3) {\n+void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register box,\n+                                                Register tmp1, Register tmp2, Register tmp3) {\n@@ -374,1 +423,1 @@\n-  assert_different_registers(obj, tmp1, tmp2, tmp3, flag, t0);\n+  assert_different_registers(obj, box, tmp1, tmp2, tmp3, flag, t0);\n@@ -379,1 +428,1 @@\n-  Label inflated, inflated_load_monitor;\n+  Label inflated, inflated_load_mark;\n@@ -390,0 +439,1 @@\n+    Label push_and_slow_path;\n@@ -397,1 +447,1 @@\n-    bne(obj, tmp3_t, inflated_load_monitor);\n+    bne(obj, tmp3_t, inflated_load_mark);\n@@ -414,0 +464,3 @@\n+    \/\/ Because we got here by popping (meaning we pushed in locked)\n+    \/\/ there will be no monitor in the box. So we need to push back the obj\n+    \/\/ so that the runtime can fix any potential anonymous owner.\n@@ -415,1 +468,1 @@\n-    bnez(tmp3_t, inflated);\n+    bnez(tmp3_t, UseObjectMonitorTable ? push_and_slow_path : inflated);\n@@ -424,0 +477,1 @@\n+    bind(push_and_slow_path);\n@@ -434,1 +488,1 @@\n-    bind(inflated_load_monitor);\n+    bind(inflated_load_mark);\n@@ -456,6 +510,12 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tmp1_monitor = tmp1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-\n-    \/\/ Untag the monitor.\n-    sub(tmp1_monitor, tmp1_mark, monitor_tag);\n+    const Register tmp1_monitor = tmp1;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(tmp1_monitor == tmp1_mark, \"should be the same here\");\n+      \/\/ Untag the monitor.\n+      add(tmp1_monitor, tmp1_mark, -(int)markWord::monitor_value);\n+    } else {\n+      ld(tmp1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ No valid pointer below alignof(ObjectMonitor*). Take the slow path.\n+      mv(tmp3_t, alignof(ObjectMonitor*));\n+      bltu(tmp1_monitor, tmp3_t, slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":82,"deletions":22,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-  void fast_lock_lightweight(Register object, Register tmp1, Register tmp2, Register tmp3);\n-  void fast_unlock_lightweight(Register object, Register tmp1, Register tmp2, Register tmp3);\n+  void fast_lock_lightweight(Register object, Register box, Register tmp1, Register tmp2, Register tmp3);\n+  void fast_unlock_lightweight(Register object, Register box, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -759,1 +759,1 @@\n-      lightweight_lock(obj_reg, tmp, tmp2, tmp3, slow_case);\n+      lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n@@ -795,9 +795,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-              obj_reg);\n-    } else {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-              lock_reg);\n-    }\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+            lock_reg);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4147,1 +4147,1 @@\n-  la(t0, RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+  la(t0, RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n@@ -5795,1 +5795,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow) {\n@@ -5797,1 +5797,1 @@\n-  assert_different_registers(obj, tmp1, tmp2, tmp3, t0);\n+  assert_different_registers(basic_lock, obj, tmp1, tmp2, tmp3, t0);\n@@ -5808,0 +5808,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    sd(zr, Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1605,1 +1605,1 @@\n-  void lightweight_lock(Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_AbstractMethodError_entry()));\n@@ -444,1 +444,1 @@\n-      __ far_jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));\n+      __ far_jump(RuntimeAddress(SharedRuntime::throw_IncompatibleClassChangeError_entry()));\n","filename":"src\/hotspot\/cpu\/riscv\/methodHandles_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -10556,1 +10556,1 @@\n-instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP_R10 box, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -10560,1 +10560,1 @@\n-  effect(TEMP tmp1, TEMP tmp2, USE_KILL box);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n@@ -10563,1 +10563,1 @@\n-  format %{ \"fastlock $object,$box\\t! kills $box,$tmp1,$tmp2 #@cmpFastLockLightweight\" %}\n+  format %{ \"fastlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3 #@cmpFastLockLightweight\" %}\n@@ -10566,1 +10566,1 @@\n-    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -10572,1 +10572,1 @@\n-instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP_R10 box, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -10576,1 +10576,1 @@\n-  effect(TEMP tmp1, TEMP tmp2, USE_KILL box);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n@@ -10579,1 +10579,1 @@\n-  format %{ \"fastunlock $object,$box\\t! kills $box,$tmp1,$tmp2, #@cmpFastUnlockLightweight\" %}\n+  format %{ \"fastunlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3 #@cmpFastUnlockLightweight\" %}\n@@ -10582,1 +10582,1 @@\n-    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -68,0 +69,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif\n+\n@@ -1698,1 +1705,1 @@\n-      __ lightweight_lock(obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n+      __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -2631,0 +2638,188 @@\n+\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Since we need to preserve callee-saved values (currently\n+\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+\/\/ map and therefore have to make these stubs into RuntimeStubs\n+\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+\/\/ be preserved between the fault point and the exception handler\n+\/\/ then it must assume responsibility for that in\n+\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  \/\/ n.b. riscv asserts that frame::arg_reg_save_area_bytes == 0\n+  assert_cond(runtime_entry != nullptr);\n+  enum layout {\n+    fp_off = 0,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  const int insts_size = 1024;\n+  const int locs_size  = 64;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  assert_cond(oop_maps != nullptr && masm != nullptr);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+\n+  __ enter(); \/\/ Save FP and RA before call\n+\n+  assert(is_even(framesize \/ 2), \"sp not 16-byte aligned\");\n+\n+  \/\/ ra and fp are already in place\n+  __ addi(sp, fp, 0 - ((unsigned)framesize << LogBytesPerInt)); \/\/ prolog\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, fp, the_pc, t0);\n+\n+  \/\/ Call runtime\n+  __ mv(c_rarg0, xthread);\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ rt_call(runtime_entry);\n+\n+  \/\/ Generate oop map\n+  OopMap* map = new OopMap(framesize, 0);\n+  assert_cond(map != nullptr);\n+\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave();\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n+  __ bnez(t0, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/\/ ASSERT\n+  __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  assert(stub != nullptr, \"create runtime stub fail!\");\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+static void jfr_prologue(address the_pc, MacroAssembler* masm, Register thread) {\n+  __ set_last_Java_frame(sp, fp, the_pc, t0);\n+  __ mv(c_rarg0, thread);\n+}\n+\n+static void jfr_epilogue(MacroAssembler* masm) {\n+  __ reset_last_Java_frame(true);\n+}\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    fp_off,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, xthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+\n+  jfr_epilogue(masm);\n+  __ resolve_global_jobject(x10, t0, t1);\n+  __ leave();\n+  __ ret();\n+\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    fp_off,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, xthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+\n+  jfr_epilogue(masm);\n+  __ leave();\n+  __ ret();\n+\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":196,"deletions":1,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -3777,1 +3777,1 @@\n-    __ la(t0, RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+    __ la(t0, RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -5837,91 +5837,0 @@\n-#if INCLUDE_JFR\n-\n-  static void jfr_prologue(address the_pc, MacroAssembler* _masm, Register thread) {\n-    __ set_last_Java_frame(sp, fp, the_pc, t0);\n-    __ mv(c_rarg0, thread);\n-  }\n-\n-  static void jfr_epilogue(MacroAssembler* _masm) {\n-    __ reset_last_Java_frame(true);\n-  }\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      fp_off,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, xthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-\n-    jfr_epilogue(_masm);\n-    __ resolve_global_jobject(x10, t0, t1);\n-    __ leave();\n-    __ ret();\n-\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      fp_off,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, xthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-\n-    jfr_epilogue(_masm);\n-    __ leave();\n-    __ ret();\n-\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -5942,108 +5851,0 @@\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Since we need to preserve callee-saved values (currently\n-  \/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-  \/\/ map and therefore have to make these stubs into RuntimeStubs\n-  \/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-  \/\/ be preserved between the fault point and the exception handler\n-  \/\/ then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n-#undef __\n-#define __ masm->\n-\n-  address generate_throw_exception(const char* name,\n-                                   address runtime_entry,\n-                                   Register arg1 = noreg,\n-                                   Register arg2 = noreg) {\n-    \/\/ Information about frame layout at time of blocking runtime call.\n-    \/\/ Note that we only have to preserve callee-saved registers since\n-    \/\/ the compilers are responsible for supplying a continuation point\n-    \/\/ if they expect all registers to be preserved.\n-    \/\/ n.b. riscv asserts that frame::arg_reg_save_area_bytes == 0\n-    assert_cond(runtime_entry != nullptr);\n-    enum layout {\n-      fp_off = 0,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    const int insts_size = 1024;\n-    const int locs_size  = 64;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    assert_cond(oop_maps != nullptr && masm != nullptr);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-\n-    __ enter(); \/\/ Save FP and RA before call\n-\n-    assert(is_even(framesize \/ 2), \"sp not 16-byte aligned\");\n-\n-    \/\/ ra and fp are already in place\n-    __ addi(sp, fp, 0 - ((unsigned)framesize << LogBytesPerInt)); \/\/ prolog\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    address the_pc = __ pc();\n-    __ set_last_Java_frame(sp, fp, the_pc, t0);\n-\n-    \/\/ Call runtime\n-    if (arg1 != noreg) {\n-      assert(arg2 != c_rarg1, \"clobbered\");\n-      __ mv(c_rarg1, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mv(c_rarg2, arg2);\n-    }\n-    __ mv(c_rarg0, xthread);\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ rt_call(runtime_entry);\n-\n-    \/\/ Generate oop map\n-    OopMap* map = new OopMap(framesize, 0);\n-    assert_cond(map != nullptr);\n-\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    __ reset_last_Java_frame(true);\n-\n-    __ leave();\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n-    __ bnez(t0, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/\/ ASSERT\n-    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-    \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name,\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    assert(stub != nullptr, \"create runtime stub fail!\");\n-    return stub->entry_point();\n-  }\n-\n@@ -6074,10 +5875,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_StackOverflowError));\n-    StubRoutines::_throw_delayed_StackOverflowError_entry =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_delayed_StackOverflowError));\n-\n@@ -6096,10 +5887,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n-  }\n-\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -6107,1 +5888,0 @@\n-#endif \/\/ INCLUDE_JFR\n@@ -6115,17 +5895,0 @@\n-    StubRoutines::_throw_AbstractMethodError_entry =\n-      generate_throw_exception(\"AbstractMethodError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_AbstractMethodError));\n-\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry =\n-      generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_IncompatibleClassChangeError));\n-\n-    StubRoutines::_throw_NullPointerException_at_call_entry =\n-      generate_throw_exception(\"NullPointerException at call throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_NullPointerException_at_call));\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":1,"deletions":238,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -661,2 +661,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1075,10 +1075,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    \/\/ for lightweight locking we need to use monitorenter_obj, see interpreterRuntime.cpp\n-    call_VM(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-            object);\n-  } else {\n-    call_VM(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            monitor);\n-  }\n+  call_VM(noreg,\n+          CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+          monitor);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2754,1 +2754,1 @@\n-  load_const_optimized(Z_R1, StubRoutines::throw_delayed_StackOverflowError_entry());\n+  load_const_optimized(Z_R1, SharedRuntime::throw_delayed_StackOverflowError_entry());\n@@ -3323,2 +3323,2 @@\n-  z_cghi(r_bitmap, Klass::SECONDARY_SUPERS_BITMAP_FULL);\n-  z_bre(L_huge);\n+  z_chi(r_array_length, Klass::SECONDARY_SUPERS_BITMAP_FULL - 2);\n+  z_brh(L_huge);\n@@ -6221,20 +6221,27 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tagged_monitor = mark;\n-    const Register zero           = tmp2;\n-\n-    \/\/ Try to CAS m->owner from null to current thread.\n-    \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n-    \/\/ Otherwise, register zero is filled with the current owner.\n-    z_lghi(zero, 0);\n-    z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), tagged_monitor);\n-    z_bre(locked);\n-\n-    \/\/ Check if recursive.\n-    z_cgr(Z_thread, zero); \/\/ zero contains the owner from z_csg instruction\n-    z_brne(slow_path);\n-\n-    \/\/ Recursive\n-    z_agsi(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n-    z_cgr(zero, zero);\n-    \/\/ z_bru(locked);\n-    \/\/ Uncomment above line in the future, for now jump address is right next to us.\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register tagged_monitor = mark;\n+      const Register zero           = tmp2;\n+\n+      \/\/ Try to CAS m->owner from null to current thread.\n+      \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n+      \/\/ Otherwise, register zero is filled with the current owner.\n+      z_lghi(zero, 0);\n+      z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), tagged_monitor);\n+      z_bre(locked);\n+\n+      \/\/ Check if recursive.\n+      z_cgr(Z_thread, zero); \/\/ zero contains the owner from z_csg instruction\n+      z_brne(slow_path);\n+\n+      \/\/ Recursive\n+      z_agsi(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n+      z_cgr(zero, zero);\n+      \/\/ z_bru(locked);\n+      \/\/ Uncomment above line in the future, for now jump address is right next to us.\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      z_ltgr(obj, obj);\n+      z_bru(slow_path);\n+    }\n@@ -6367,2 +6374,3 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register monitor = mark;\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register monitor = mark;\n@@ -6370,2 +6378,2 @@\n-    NearLabel not_recursive;\n-    const Register recursions = tmp2;\n+      NearLabel not_recursive;\n+      const Register recursions = tmp2;\n@@ -6373,3 +6381,3 @@\n-    \/\/ Check if recursive.\n-    load_and_test_long(recursions, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-    z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+      \/\/ Check if recursive.\n+      load_and_test_long(recursions, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+      z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n@@ -6377,4 +6385,4 @@\n-    \/\/ Recursive unlock\n-    z_agsi(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n-    z_cgr(monitor, monitor); \/\/ set the CC to EQUAL\n-    z_bru(unlocked);\n+      \/\/ Recursive unlock\n+      z_agsi(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n+      z_cgr(monitor, monitor); \/\/ set the CC to EQUAL\n+      z_bru(unlocked);\n@@ -6382,1 +6390,1 @@\n-    bind(not_recursive);\n+      bind(not_recursive);\n@@ -6384,6 +6392,6 @@\n-    NearLabel not_ok;\n-    \/\/ Check if the entry lists are empty.\n-    load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-    z_brne(not_ok);\n-    load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-    z_brne(not_ok);\n+      NearLabel not_ok;\n+      \/\/ Check if the entry lists are empty.\n+      load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+      z_brne(not_ok);\n+      load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n+      z_brne(not_ok);\n@@ -6391,2 +6399,2 @@\n-    z_release();\n-    z_stg(tmp2 \/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+      z_release();\n+      z_stg(tmp2 \/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n@@ -6394,1 +6402,1 @@\n-    z_bru(unlocked); \/\/ CC = EQ here\n+      z_bru(unlocked); \/\/ CC = EQ here\n@@ -6396,1 +6404,1 @@\n-    bind(not_ok);\n+      bind(not_ok);\n@@ -6398,5 +6406,11 @@\n-    \/\/ The owner may be anonymous, and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    z_stg(Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n-    z_bru(slow_path); \/\/ CC = NE here\n+      \/\/ The owner may be anonymous, and we removed the last obj entry in\n+      \/\/ the lock-stack. This loses the information about the owner.\n+      \/\/ Write the thread to the owner field so the runtime knows the owner.\n+      z_stg(Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+      z_bru(slow_path); \/\/ CC = NE here\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      z_ltgr(obj, obj);\n+      z_bru(slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":64,"deletions":50,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -183,2 +183,2 @@\n-  assert(StubRoutines::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n-  __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());\n+  assert(SharedRuntime::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n+  __ load_const_optimized(target, SharedRuntime::throw_AbstractMethodError_entry());\n@@ -546,1 +546,1 @@\n-      __ load_const_optimized(Z_R1, StubRoutines::throw_IncompatibleClassChangeError_entry());\n+      __ load_const_optimized(Z_R1, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n","filename":"src\/hotspot\/cpu\/s390\/methodHandles_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3013,0 +3013,79 @@\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Only callee-saved registers are preserved (through the\n+\/\/ normal RegisterMap handling). If the compiler\n+\/\/ needs all registers to be preserved between the fault point and\n+\/\/ the exception handler then it must assume responsibility for that\n+\/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\n+\/\/ Note that we generate only this stub into a RuntimeStub, because\n+\/\/ it needs to be properly traversed and ignored during GC, so we\n+\/\/ change the meaning of the \"__\" macro within this method.\n+\n+\/\/ Note: the routine set_pc_not_at_call_for_caller in\n+\/\/ SharedRuntime.cpp requires that this code be generated into a\n+\/\/ RuntimeStub.\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+\n+  int insts_size = 256;\n+  int locs_size  = 0;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer      code(name, insts_size, locs_size);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  int framesize_in_bytes;\n+  address start = __ pc();\n+\n+  __ save_return_pc();\n+  framesize_in_bytes = __ push_frame_abi160(0);\n+\n+  address frame_complete_pc = __ pc();\n+\n+  \/\/ Note that we always have a runtime stub frame on the top of stack at this point.\n+  __ get_PC(Z_R1);\n+  __ set_last_Java_frame(\/*sp*\/Z_SP, \/*pc*\/Z_R1);\n+\n+  \/\/ Do the call.\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ call_VM_leaf(runtime_entry, Z_thread);\n+\n+  __ reset_last_Java_frame();\n+\n+#ifdef ASSERT\n+  \/\/ Make sure that this code is only executed if there is a pending exception.\n+  { Label L;\n+    __ z_lg(Z_R0,\n+            in_bytes(Thread::pending_exception_offset()),\n+            Z_thread);\n+    __ z_ltgr(Z_R0, Z_R0);\n+    __ z_brne(L);\n+    __ stop(\"SharedRuntime::throw_exception: no pending exception\");\n+    __ bind(L);\n+  }\n+#endif\n+\n+  __ pop_frame();\n+  __ restore_return_pc();\n+\n+  __ load_const_optimized(Z_R1, StubRoutines::forward_exception_entry());\n+  __ z_br(Z_R1);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name, &code,\n+                                  frame_complete_pc - start,\n+                                  framesize_in_bytes\/wordSize,\n+                                  nullptr \/*oop_maps*\/, false);\n+\n+  return stub;\n+}\n+\n@@ -3266,0 +3345,15 @@\n+\n+#if INCLUDE_JFR\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  if (!Continuations::enabled()) return nullptr;\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  if (!Continuations::enabled()) return nullptr;\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -575,83 +575,0 @@\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Only callee-saved registers are preserved (through the\n-  \/\/ normal RegisterMap handling). If the compiler\n-  \/\/ needs all registers to be preserved between the fault point and\n-  \/\/ the exception handler then it must assume responsibility for that\n-  \/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n-  \/\/ Note that we generate only this stub into a RuntimeStub, because\n-  \/\/ it needs to be properly traversed and ignored during GC, so we\n-  \/\/ change the meaning of the \"__\" macro within this method.\n-\n-  \/\/ Note: the routine set_pc_not_at_call_for_caller in\n-  \/\/ SharedRuntime.cpp requires that this code be generated into a\n-  \/\/ RuntimeStub.\n-#undef __\n-#define __ masm->\n-\n-  address generate_throw_exception(const char* name, address runtime_entry,\n-                                   bool restore_saved_exception_pc,\n-                                   Register arg1 = noreg, Register arg2 = noreg) {\n-    assert_different_registers(arg1, Z_R0_scratch);  \/\/ would be destroyed by push_frame()\n-    assert_different_registers(arg2, Z_R0_scratch);  \/\/ would be destroyed by push_frame()\n-\n-    int insts_size = 256;\n-    int locs_size  = 0;\n-    CodeBuffer      code(name, insts_size, locs_size);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    int framesize_in_bytes;\n-    address start = __ pc();\n-\n-    __ save_return_pc();\n-    framesize_in_bytes = __ push_frame_abi160(0);\n-\n-    address frame_complete_pc = __ pc();\n-    if (restore_saved_exception_pc) {\n-      __ unimplemented(\"StubGenerator::throw_exception\", 74);\n-    }\n-\n-    \/\/ Note that we always have a runtime stub frame on the top of stack at this point.\n-    __ get_PC(Z_R1);\n-    __ set_last_Java_frame(\/*sp*\/Z_SP, \/*pc*\/Z_R1);\n-\n-    \/\/ Do the call.\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ call_VM_leaf(runtime_entry, Z_thread, arg1, arg2);\n-\n-    __ reset_last_Java_frame();\n-\n-#ifdef ASSERT\n-    \/\/ Make sure that this code is only executed if there is a pending exception.\n-    { Label L;\n-      __ z_lg(Z_R0,\n-                in_bytes(Thread::pending_exception_offset()),\n-                Z_thread);\n-      __ z_ltgr(Z_R0, Z_R0);\n-      __ z_brne(L);\n-      __ stop(\"StubRoutines::throw_exception: no pending exception\");\n-      __ bind(L);\n-    }\n-#endif\n-\n-    __ pop_frame();\n-    __ restore_return_pc();\n-\n-    __ load_const_optimized(Z_R1, StubRoutines::forward_exception_entry());\n-    __ z_br(Z_R1);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name, &code,\n-                                    frame_complete_pc - start,\n-                                    framesize_in_bytes\/wordSize,\n-                                    nullptr \/*oop_maps*\/, false);\n-\n-    return stub->entry_point();\n-  }\n-\n@@ -3124,15 +3041,0 @@\n-  #if INCLUDE_JFR\n-  RuntimeStub* generate_jfr_write_checkpoint() {\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n-  }\n-\n-  RuntimeStub* generate_jfr_return_lease() {\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n-  }\n-\n-  #endif \/\/ INCLUDE_JFR\n-\n@@ -3167,8 +3069,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry          =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError), false);\n-    StubRoutines::_throw_delayed_StackOverflowError_entry  =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError), false);\n-\n@@ -3199,2 +3093,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n@@ -3203,9 +3095,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-  }\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -3217,5 +3100,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in non-core builds.\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError),  false);\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError),  false);\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call), false);\n-\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":0,"deletions":122,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -853,3 +853,3 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  AddressLiteral stub(StubRoutines::throw_StackOverflowError_entry());\n-  __ load_absolute_address(tmp1, StubRoutines::throw_StackOverflowError_entry());\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  AddressLiteral stub(SharedRuntime::throw_StackOverflowError_entry());\n+  __ load_absolute_address(tmp1, SharedRuntime::throw_StackOverflowError_entry());\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+    lightweight_lock(disp_hdr, obj, hdr, thread, tmp, slow_case);\n@@ -70,2 +71,4 @@\n-    const Register thread = disp_hdr;\n-    get_thread(thread);\n+    \/\/ Implicit null check.\n+    movptr(hdr, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+    jmp(slow_case);\n@@ -73,1 +76,0 @@\n-    lightweight_lock(obj, hdr, thread, tmp, slow_case);\n@@ -142,4 +144,2 @@\n-    \/\/ This relies on the implementation of lightweight_unlock being able to handle\n-    \/\/ that the reg_rax and thread Register parameters may alias each other.\n-    get_thread(disp_hdr);\n-    lightweight_unlock(obj, disp_hdr, disp_hdr, hdr, slow_case);\n+    \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+    jmp(slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+    __ bind(_slow_path);\n@@ -115,0 +116,4 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address succ_address(monitor, ObjectMonitor::succ_offset() - monitor_tag);\n+    const Address owner_address(monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+\n@@ -116,1 +121,1 @@\n-    __ cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n+    __ cmpptr(succ_address, NULL_WORD);\n@@ -120,1 +125,1 @@\n-    __ movptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n+    __ movptr(owner_address, NULL_WORD);\n@@ -127,1 +132,1 @@\n-    __ cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n+    __ cmpptr(succ_address, NULL_WORD);\n@@ -136,1 +141,1 @@\n-    __ lock(); __ cmpxchgptr(_thread, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+    __ lock(); __ cmpxchgptr(_thread, owner_address);\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -593,0 +593,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    movptr(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), 0);\n+  }\n+\n@@ -606,1 +611,1 @@\n-    const Register top = box;\n+    const Register top = UseObjectMonitorTable ? rax_reg : box;\n@@ -633,0 +638,4 @@\n+    if (UseObjectMonitorTable) {\n+      \/\/ Need to reload top, clobbered by CAS.\n+      movl(top, Address(thread, JavaThread::lock_stack_top_offset()));\n+    }\n@@ -643,1 +652,44 @@\n-    const Register tagged_monitor = mark;\n+    const Register monitor = t;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(mark == monitor, \"should be the same here\");\n+    } else {\n+      \/\/ Uses ObjectMonitorTable.  Look for the monitor in the om_cache.\n+      \/\/ Fetch ObjectMonitor* from the cache or take the slow-path.\n+      Label monitor_found;\n+\n+      \/\/ Load cache address\n+      lea(t, Address(thread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        cmpptr(obj, Address(t));\n+        jccb(Assembler::equal, monitor_found);\n+        increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      Label loop;\n+\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      cmpptr(obj, Address(t));\n+      jccb(Assembler::equal, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      cmpptr(Address(t), 1);\n+      jcc(Assembler::below, slow_path); \/\/ 0 check, but with ZF=0 when *t == 0\n+      increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+      jmpb(loop);\n+\n+      \/\/ Cache hit.\n+      bind(monitor_found);\n+      movptr(monitor, Address(t, OMCache::oop_to_monitor_difference()));\n+    }\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address recursions_address(monitor, ObjectMonitor::recursions_offset() - monitor_tag);\n+    const Address owner_address(monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+\n+    Label monitor_locked;\n+    \/\/ Lock the monitor.\n@@ -647,2 +699,2 @@\n-    lock(); cmpxchgptr(thread, Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-    jccb(Assembler::equal, locked);\n+    lock(); cmpxchgptr(thread, owner_address);\n+    jccb(Assembler::equal, monitor_locked);\n@@ -655,1 +707,7 @@\n-    increment(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+    increment(recursions_address);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      \/\/ Cache the monitor for unlock\n+      movptr(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), monitor);\n+    }\n@@ -697,1 +755,3 @@\n-  const Register top = reg_rax;\n+  const Register monitor = t;\n+  const Register top = UseObjectMonitorTable ? t : reg_rax;\n+  const Register box = reg_rax;\n@@ -709,0 +769,1 @@\n+  Label& slow_path = stub == nullptr ? dummy : stub->slow_path();\n@@ -715,2 +776,4 @@\n-    \/\/ Prefetch mark.\n-    movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    if (!UseObjectMonitorTable) {\n+      \/\/ Prefetch mark.\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n@@ -733,0 +796,5 @@\n+    if (UseObjectMonitorTable) {\n+      \/\/ Load mark.\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n+\n@@ -754,0 +822,3 @@\n+    if (UseObjectMonitorTable) {\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n@@ -761,13 +832,14 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register monitor = mark;\n-\n-#ifndef _LP64\n-    \/\/ Check if recursive.\n-    xorptr(reg_rax, reg_rax);\n-    orptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-    jcc(Assembler::notZero, check_successor);\n-\n-    \/\/ Check if the entry lists are empty.\n-    movptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-    orptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-    jcc(Assembler::notZero, check_successor);\n+    if (!UseObjectMonitorTable) {\n+      assert(mark == monitor, \"should be the same here\");\n+    } else {\n+      \/\/ Uses ObjectMonitorTable.  Look for the monitor in our BasicLock on the stack.\n+      movptr(monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ null check with ZF == 0, no valid pointer below alignof(ObjectMonitor*)\n+      cmpptr(monitor, alignof(ObjectMonitor*));\n+      jcc(Assembler::below, slow_path);\n+    }\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address recursions_address{monitor, ObjectMonitor::recursions_offset() - monitor_tag};\n+    const Address cxq_address{monitor, ObjectMonitor::cxq_offset() - monitor_tag};\n+    const Address EntryList_address{monitor, ObjectMonitor::EntryList_offset() - monitor_tag};\n+    const Address owner_address{monitor, ObjectMonitor::owner_offset() - monitor_tag};\n@@ -775,3 +847,0 @@\n-    \/\/ Release lock.\n-    movptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n-#else \/\/ _LP64\n@@ -781,1 +850,1 @@\n-    cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 0);\n+    cmpptr(recursions_address, 0);\n@@ -785,2 +854,2 @@\n-    movptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-    orptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+    movptr(reg_rax, cxq_address);\n+    orptr(reg_rax, EntryList_address);\n@@ -790,1 +859,1 @@\n-    movptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n+    movptr(owner_address, NULL_WORD);\n@@ -795,1 +864,1 @@\n-    decrement(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+    decrement(recursions_address);\n@@ -797,1 +866,0 @@\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":98,"deletions":30,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -1186,0 +1186,1 @@\n+      lightweight_lock(lock_reg, obj_reg, swap_reg, thread, tmp_reg, slow_case);\n@@ -1187,2 +1188,2 @@\n-      const Register thread = lock_reg;\n-      get_thread(thread);\n+      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+      jmp(slow_case);\n@@ -1190,1 +1191,0 @@\n-      lightweight_lock(obj_reg, swap_reg, thread, tmp_reg, slow_case);\n@@ -1252,9 +1252,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-              obj_reg);\n-    } else {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-              lock_reg);\n-    }\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+            lock_reg);\n@@ -1309,4 +1303,2 @@\n-      \/\/ This relies on the implementation of lightweight_unlock being able to handle\n-      \/\/ that the reg_rax and thread Register parameters may alias each other.\n-      get_thread(swap_reg);\n-      lightweight_unlock(obj_reg, swap_reg, swap_reg, header_reg, slow_case);\n+      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+      jmp(slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1306,1 +1306,1 @@\n-  jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+  jump(RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n@@ -10278,1 +10278,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register reg_rax, Register thread, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register reg_rax, Register thread, Register tmp, Label& slow) {\n@@ -10280,1 +10280,1 @@\n-  assert_different_registers(obj, reg_rax, thread, tmp);\n+  assert_different_registers(basic_lock, obj, reg_rax, thread, tmp);\n@@ -10289,0 +10289,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    movptr(Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))), 0);\n+  }\n+\n@@ -10327,3 +10332,0 @@\n-\/\/\n-\/\/ x86_32 Note: reg_rax and thread may alias each other due to limited register\n-\/\/              availiability.\n@@ -10332,2 +10334,1 @@\n-  assert_different_registers(obj, reg_rax, tmp);\n-  LP64_ONLY(assert_different_registers(obj, reg_rax, thread, tmp);)\n+  assert_different_registers(obj, reg_rax, thread, tmp);\n@@ -10373,4 +10374,0 @@\n-  if (thread == reg_rax) {\n-    \/\/ On x86_32 we may lose the thread.\n-    get_thread(thread);\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2151,1 +2151,1 @@\n-  void lightweight_lock(Register obj, Register reg_rax, Register thread, Register tmp, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register reg_rax, Register thread, Register tmp, Label& slow);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-  __ jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));\n+  __ jump(RuntimeAddress(SharedRuntime::throw_AbstractMethodError_entry()));\n@@ -513,1 +513,1 @@\n-      __ jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));\n+      __ jump(RuntimeAddress(SharedRuntime::throw_IncompatibleClassChangeError_entry()));\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,3 +65,5 @@\n-    \/\/ check if monitor\n-    __ testptr(result, markWord::monitor_value);\n-    __ jcc(Assembler::notZero, slowCase);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ check if monitor\n+      __ testptr(result, markWord::monitor_value);\n+      __ jcc(Assembler::notZero, slowCase);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -59,0 +60,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif \/\/ PRODUCT\n+\n@@ -1689,1 +1696,2 @@\n-      __ lightweight_lock(obj_reg, swap_reg, thread, lock_reg, slow_path_lock);\n+      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+      __ jmp(slow_path_lock);\n@@ -2633,0 +2641,204 @@\n+\n+  \/\/------------------------------------------------------------------------------------------------------------------------\n+  \/\/ Continuation point for throwing of implicit exceptions that are not handled in\n+  \/\/ the current activation. Fabricates an exception oop and initiates normal\n+  \/\/ exception dispatching in this frame.\n+  \/\/\n+  \/\/ Previously the compiler (c2) allowed for callee save registers on Java calls.\n+  \/\/ This is no longer true after adapter frames were removed but could possibly\n+  \/\/ be brought back in the future if the interpreter code was reworked and it\n+  \/\/ was deemed worthwhile. The comment below was left to describe what must\n+  \/\/ happen here if callee saves were resurrected. As it stands now this stub\n+  \/\/ could actually be a vanilla BufferBlob and have now oopMap at all.\n+  \/\/ Since it doesn't make much difference we've chosen to leave it the\n+  \/\/ way it was in the callee save days and keep the comment.\n+\n+  \/\/ If we need to preserve callee-saved values we need a callee-saved oop map and\n+  \/\/ therefore have to make these stubs into RuntimeStubs rather than BufferBlobs.\n+  \/\/ If the compiler needs all registers to be preserved between the fault\n+  \/\/ point and the exception handler then it must assume responsibility for that in\n+  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+  \/\/ continuation_for_implicit_division_by_zero_exception. All other implicit\n+  \/\/ exceptions (e.g., NullPointerException or AbstractMethodError on entry) are\n+  \/\/ either at call sites or otherwise assume that stack unwinding will be initiated,\n+  \/\/ so caller saved registers were assumed volatile in the compiler.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  enum layout {\n+    thread_off,    \/\/ last_java_sp\n+    arg1_off,\n+    arg2_off,\n+    rbp_off,       \/\/ callee saved register\n+    ret_pc,\n+    framesize\n+  };\n+\n+  int insts_size = 256;\n+  int locs_size  = 32;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+  Register java_thread = rbx;\n+  __ get_thread(java_thread);\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ pc and rbp, already pushed\n+  __ subptr(rsp, (framesize-2) * wordSize); \/\/ prolog\n+\n+  \/\/ Frame is now completed as far as size and linkage.\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ push java thread (becomes first argument of C function)\n+  __ movptr(Address(rsp, thread_off * wordSize), java_thread);\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  __ set_last_Java_frame(java_thread, rsp, rbp, nullptr, noreg);\n+\n+  \/\/ Call runtime\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ call(RuntimeAddress(runtime_entry));\n+  \/\/ Generate oop map\n+  OopMap* map =  new OopMap(framesize, 0);\n+  oop_maps->add_gc_map(__ pc() - start, map);\n+\n+  \/\/ restore the thread (cannot use the pushed argument since arguments\n+  \/\/ may be overwritten by C code generated by an optimizing compiler);\n+  \/\/ however can use the register value directly if it is callee saved.\n+  __ get_thread(java_thread);\n+\n+  __ reset_last_Java_frame(java_thread, true);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n+  __ jcc(Assembler::notEqual, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/* ASSERT *\/\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+\n+  RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete, framesize, oop_maps, false);\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+static void jfr_prologue(address the_pc, MacroAssembler* masm) {\n+  Register java_thread = rdi;\n+  __ get_thread(java_thread);\n+  __ set_last_Java_frame(java_thread, rsp, rbp, the_pc, noreg);\n+  __ movptr(Address(rsp, 0), java_thread);\n+}\n+\n+\/\/ The handle is dereferenced through a load barrier.\n+static void jfr_epilogue(MacroAssembler* masm) {\n+  Register java_thread = rdi;\n+  __ get_thread(java_thread);\n+  __ reset_last_Java_frame(java_thread, true);\n+}\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    FPUState_off         = 0,\n+    rbp_off              = FPUStateSizeInWords,\n+    rdi_off,\n+    rsi_off,\n+    rcx_off,\n+    rbx_off,\n+    saved_argument_off,\n+    saved_argument_off2, \/\/ 2nd half of double\n+    framesize\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+  jfr_epilogue(masm);\n+  __ resolve_global_jobject(rax, rdi, rdx);\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    FPUState_off = 0,\n+    rbp_off = FPUStateSizeInWords,\n+    rdi_off,\n+    rsi_off,\n+    rcx_off,\n+    rbx_off,\n+    saved_argument_off,\n+    saved_argument_off2, \/\/ 2nd half of double\n+    framesize\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  jfr_epilogue(masm);\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":213,"deletions":1,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -73,0 +74,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif \/\/ PRODUCT\n+\n@@ -2269,1 +2276,1 @@\n-      __ lightweight_lock(obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n+      __ lightweight_lock(lock_reg, obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n@@ -3213,0 +3220,95 @@\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Since we need to preserve callee-saved values (currently\n+\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+\/\/ map and therefore have to make these stubs into RuntimeStubs\n+\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+\/\/ be preserved between the fault point and the exception handler\n+\/\/ then it must assume responsibility for that in\n+\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  enum layout {\n+    rbp_off = frame::arg_reg_save_area_bytes\/BytesPerInt,\n+    rbp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 512;\n+  int locs_size  = 64;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n+\n+  \/\/ return address and rbp are already in place\n+  __ subptr(rsp, (framesize-4) << LogBytesPerInt); \/\/ prolog\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n+  __ andptr(rsp, -(StackAlignmentInBytes));    \/\/ Align stack\n+\n+  \/\/ Call runtime\n+  __ movptr(c_rarg0, r15_thread);\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ call(RuntimeAddress(runtime_entry));\n+\n+  \/\/ Generate oop map\n+  OopMap* map = new OopMap(framesize, 0);\n+\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n+  __ jcc(Assembler::notEqual, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/\/ ASSERT\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+\n+  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n@@ -3478,0 +3580,91 @@\n+#if INCLUDE_JFR\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_write_checkpoint\", 1024, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  address start = __ pc();\n+\n+  __ enter();\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n+  __ movptr(c_rarg0, r15_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+  __ reset_last_Java_frame(true);\n+\n+  \/\/ rax is jobject handle result, unpack and process it through a barrier.\n+  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_return_lease\", 1024, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  address start = __ pc();\n+\n+  __ enter();\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch2);\n+  __ movptr(c_rarg0, r15_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":194,"deletions":1,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -3846,14 +3846,0 @@\n- public:\n-  \/\/ Information about frame layout at time of blocking runtime call.\n-  \/\/ Note that we only have to preserve callee-saved registers since\n-  \/\/ the compilers are responsible for supplying a continuation point\n-  \/\/ if they expect all registers to be preserved.\n-  enum layout {\n-    thread_off,    \/\/ last_java_sp\n-    arg1_off,\n-    arg2_off,\n-    rbp_off,       \/\/ callee saved register\n-    ret_pc,\n-    framesize\n-  };\n-\n@@ -3862,99 +3848,0 @@\n-#undef  __\n-#define __ masm->\n-\n-  \/\/------------------------------------------------------------------------------------------------------------------------\n-  \/\/ Continuation point for throwing of implicit exceptions that are not handled in\n-  \/\/ the current activation. Fabricates an exception oop and initiates normal\n-  \/\/ exception dispatching in this frame.\n-  \/\/\n-  \/\/ Previously the compiler (c2) allowed for callee save registers on Java calls.\n-  \/\/ This is no longer true after adapter frames were removed but could possibly\n-  \/\/ be brought back in the future if the interpreter code was reworked and it\n-  \/\/ was deemed worthwhile. The comment below was left to describe what must\n-  \/\/ happen here if callee saves were resurrected. As it stands now this stub\n-  \/\/ could actually be a vanilla BufferBlob and have now oopMap at all.\n-  \/\/ Since it doesn't make much difference we've chosen to leave it the\n-  \/\/ way it was in the callee save days and keep the comment.\n-\n-  \/\/ If we need to preserve callee-saved values we need a callee-saved oop map and\n-  \/\/ therefore have to make these stubs into RuntimeStubs rather than BufferBlobs.\n-  \/\/ If the compiler needs all registers to be preserved between the fault\n-  \/\/ point and the exception handler then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other implicit\n-  \/\/ exceptions (e.g., NullPointerException or AbstractMethodError on entry) are\n-  \/\/ either at call sites or otherwise assume that stack unwinding will be initiated,\n-  \/\/ so caller saved registers were assumed volatile in the compiler.\n-  address generate_throw_exception(const char* name, address runtime_entry,\n-                                   Register arg1 = noreg, Register arg2 = noreg) {\n-\n-    int insts_size = 256;\n-    int locs_size  = 32;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-    Register java_thread = rbx;\n-    __ get_thread(java_thread);\n-\n-    __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-    \/\/ pc and rbp, already pushed\n-    __ subptr(rsp, (framesize-2) * wordSize); \/\/ prolog\n-\n-    \/\/ Frame is now completed as far as size and linkage.\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ push java thread (becomes first argument of C function)\n-    __ movptr(Address(rsp, thread_off * wordSize), java_thread);\n-    if (arg1 != noreg) {\n-      __ movptr(Address(rsp, arg1_off * wordSize), arg1);\n-    }\n-    if (arg2 != noreg) {\n-      assert(arg1 != noreg, \"missing reg arg\");\n-      __ movptr(Address(rsp, arg2_off * wordSize), arg2);\n-    }\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    __ set_last_Java_frame(java_thread, rsp, rbp, nullptr, noreg);\n-\n-    \/\/ Call runtime\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ call(RuntimeAddress(runtime_entry));\n-    \/\/ Generate oop map\n-    OopMap* map =  new OopMap(framesize, 0);\n-    oop_maps->add_gc_map(__ pc() - start, map);\n-\n-    \/\/ restore the thread (cannot use the pushed argument since arguments\n-    \/\/ may be overwritten by C code generated by an optimizing compiler);\n-    \/\/ however can use the register value directly if it is callee saved.\n-    __ get_thread(java_thread);\n-\n-    __ reset_last_Java_frame(java_thread, true);\n-\n-    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n-    __ jcc(Assembler::notEqual, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/* ASSERT *\/\n-    __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-\n-    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete, framesize, oop_maps, false);\n-    return stub->entry_point();\n-  }\n-\n-\n@@ -4000,103 +3887,0 @@\n-#if INCLUDE_JFR\n-\n-  static void jfr_prologue(address the_pc, MacroAssembler* masm) {\n-    Register java_thread = rdi;\n-    __ get_thread(java_thread);\n-    __ set_last_Java_frame(java_thread, rsp, rbp, the_pc, noreg);\n-    __ movptr(Address(rsp, 0), java_thread);\n-  }\n-\n-  \/\/ The handle is dereferenced through a load barrier.\n-  static void jfr_epilogue(MacroAssembler* masm) {\n-    Register java_thread = rdi;\n-    __ get_thread(java_thread);\n-    __ reset_last_Java_frame(java_thread, true);\n-  }\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      FPUState_off         = 0,\n-      rbp_off              = FPUStateSizeInWords,\n-      rdi_off,\n-      rsi_off,\n-      rcx_off,\n-      rbx_off,\n-      saved_argument_off,\n-      saved_argument_off2, \/\/ 2nd half of double\n-      framesize\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-    jfr_epilogue(_masm);\n-    __ resolve_global_jobject(rax, rdi, rdx);\n-    __ leave();\n-    __ ret(0);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      FPUState_off = 0,\n-      rbp_off = FPUStateSizeInWords,\n-      rdi_off,\n-      rsi_off,\n-      rcx_off,\n-      rbx_off,\n-      saved_argument_off,\n-      saved_argument_off2, \/\/ 2nd half of double\n-      framesize\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-    jfr_epilogue(_masm);\n-    __ leave();\n-    __ ret(0);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -4133,6 +3917,0 @@\n-    \/\/ Build this early so it's available for the interpreter\n-    StubRoutines::_throw_StackOverflowError_entry          = generate_throw_exception(\"StackOverflowError throw_exception\",\n-                                                                                      CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));\n-    StubRoutines::_throw_delayed_StackOverflowError_entry  = generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                                                                                      CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError));\n-\n@@ -4191,2 +3969,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n@@ -4195,9 +3971,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-  }\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -4207,6 +3974,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in non-core builds\n-    \/\/ and need to be relocatable, so they each fabricate a RuntimeStub internally.\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":0,"deletions":239,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -48,3 +48,0 @@\n-#if INCLUDE_JFR\n-#include \"jfr\/support\/jfrIntrinsics.hpp\"\n-#endif\n@@ -3705,1 +3702,1 @@\n-  __ jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  __ jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -3781,192 +3778,0 @@\n-#if INCLUDE_JFR\n-\n-\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-\/\/ It returns a jobject handle to the event writer.\n-\/\/ The handle is dereferenced and the return value is the event writer oop.\n-RuntimeStub* StubGenerator::generate_jfr_write_checkpoint() {\n-  enum layout {\n-    rbp_off,\n-    rbpH_off,\n-    return_off,\n-    return_off2,\n-    framesize \/\/ inclusive of return address\n-  };\n-\n-  CodeBuffer code(\"jfr_write_checkpoint\", 1024, 64);\n-  MacroAssembler* _masm = new MacroAssembler(&code);\n-  address start = __ pc();\n-\n-  __ enter();\n-  address the_pc = __ pc();\n-\n-  int frame_complete = the_pc - start;\n-\n-  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n-  __ movptr(c_rarg0, r15_thread);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-  __ reset_last_Java_frame(true);\n-\n-  \/\/ rax is jobject handle result, unpack and process it through a barrier.\n-  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n-\n-  __ leave();\n-  __ ret(0);\n-\n-  OopMapSet* oop_maps = new OopMapSet();\n-  OopMap* map = new OopMap(framesize, 1);\n-  oop_maps->add_gc_map(frame_complete, map);\n-\n-  RuntimeStub* stub =\n-    RuntimeStub::new_runtime_stub(code.name(),\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps,\n-                                  false);\n-  return stub;\n-}\n-\n-\/\/ For c2: call to return a leased buffer.\n-RuntimeStub* StubGenerator::generate_jfr_return_lease() {\n-  enum layout {\n-    rbp_off,\n-    rbpH_off,\n-    return_off,\n-    return_off2,\n-    framesize \/\/ inclusive of return address\n-  };\n-\n-  CodeBuffer code(\"jfr_return_lease\", 1024, 64);\n-  MacroAssembler* _masm = new MacroAssembler(&code);\n-  address start = __ pc();\n-\n-  __ enter();\n-  address the_pc = __ pc();\n-\n-  int frame_complete = the_pc - start;\n-\n-  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch2);\n-  __ movptr(c_rarg0, r15_thread);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-  __ reset_last_Java_frame(true);\n-\n-  __ leave();\n-  __ ret(0);\n-\n-  OopMapSet* oop_maps = new OopMapSet();\n-  OopMap* map = new OopMap(framesize, 1);\n-  oop_maps->add_gc_map(frame_complete, map);\n-\n-  RuntimeStub* stub =\n-    RuntimeStub::new_runtime_stub(code.name(),\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps,\n-                                  false);\n-  return stub;\n-}\n-\n-#endif \/\/ INCLUDE_JFR\n-\n-\/\/ Continuation point for throwing of implicit exceptions that are\n-\/\/ not handled in the current activation. Fabricates an exception\n-\/\/ oop and initiates normal exception dispatching in this\n-\/\/ frame. Since we need to preserve callee-saved values (currently\n-\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-\/\/ map and therefore have to make these stubs into RuntimeStubs\n-\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-\/\/ be preserved between the fault point and the exception handler\n-\/\/ then it must assume responsibility for that in\n-\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-\/\/ continuation_for_implicit_division_by_zero_exception. All other\n-\/\/ implicit exceptions (e.g., NullPointerException or\n-\/\/ AbstractMethodError on entry) are either at call sites or\n-\/\/ otherwise assume that stack unwinding will be initiated, so\n-\/\/ caller saved registers were assumed volatile in the compiler.\n-address StubGenerator::generate_throw_exception(const char* name,\n-                                                address runtime_entry,\n-                                                Register arg1,\n-                                                Register arg2) {\n-  \/\/ Information about frame layout at time of blocking runtime call.\n-  \/\/ Note that we only have to preserve callee-saved registers since\n-  \/\/ the compilers are responsible for supplying a continuation point\n-  \/\/ if they expect all registers to be preserved.\n-  enum layout {\n-    rbp_off = frame::arg_reg_save_area_bytes\/BytesPerInt,\n-    rbp_off2,\n-    return_off,\n-    return_off2,\n-    framesize \/\/ inclusive of return address\n-  };\n-\n-  int insts_size = 512;\n-  int locs_size  = 64;\n-\n-  CodeBuffer code(name, insts_size, locs_size);\n-  OopMapSet* oop_maps  = new OopMapSet();\n-  MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-  address start = __ pc();\n-\n-  \/\/ This is an inlined and slightly modified version of call_VM\n-  \/\/ which has the ability to fetch the return PC out of\n-  \/\/ thread-local storage and also sets up last_Java_sp slightly\n-  \/\/ differently than the real call_VM\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n-\n-  \/\/ return address and rbp are already in place\n-  __ subptr(rsp, (framesize-4) << LogBytesPerInt); \/\/ prolog\n-\n-  int frame_complete = __ pc() - start;\n-\n-  \/\/ Set up last_Java_sp and last_Java_fp\n-  address the_pc = __ pc();\n-  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n-  __ andptr(rsp, -(StackAlignmentInBytes));    \/\/ Align stack\n-\n-  \/\/ Call runtime\n-  if (arg1 != noreg) {\n-    assert(arg2 != c_rarg1, \"clobbered\");\n-    __ movptr(c_rarg1, arg1);\n-  }\n-  if (arg2 != noreg) {\n-    __ movptr(c_rarg2, arg2);\n-  }\n-  __ movptr(c_rarg0, r15_thread);\n-  BLOCK_COMMENT(\"call runtime_entry\");\n-  __ call(RuntimeAddress(runtime_entry));\n-\n-  \/\/ Generate oop map\n-  OopMap* map = new OopMap(framesize, 0);\n-\n-  oop_maps->add_gc_map(the_pc - start, map);\n-\n-  __ reset_last_Java_frame(true);\n-\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  \/\/ check for pending exceptions\n-#ifdef ASSERT\n-  Label L;\n-  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n-  __ jcc(Assembler::notEqual, L);\n-  __ should_not_reach_here();\n-  __ bind(L);\n-#endif \/\/ ASSERT\n-  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-\n-  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-  RuntimeStub* stub =\n-    RuntimeStub::new_runtime_stub(name,\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps, false);\n-  return stub->entry_point();\n-}\n-\n@@ -4090,11 +3895,0 @@\n-  \/\/ Build this early so it's available for the interpreter.\n-  StubRoutines::_throw_StackOverflowError_entry =\n-    generate_throw_exception(\"StackOverflowError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_StackOverflowError));\n-  StubRoutines::_throw_delayed_StackOverflowError_entry =\n-    generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_delayed_StackOverflowError));\n@@ -4134,2 +3928,0 @@\n-\n-  JFR_ONLY(generate_jfr_stubs();)\n@@ -4138,9 +3930,0 @@\n-#if INCLUDE_JFR\n-void StubGenerator::generate_jfr_stubs() {\n-  StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-  StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-  StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-  StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-}\n-#endif\n-\n@@ -4150,21 +3933,0 @@\n-  \/\/ These entry points require SharedInfo::stack0 to be set up in\n-  \/\/ non-core builds and need to be relocatable, so they each\n-  \/\/ fabricate a RuntimeStub internally.\n-  StubRoutines::_throw_AbstractMethodError_entry =\n-    generate_throw_exception(\"AbstractMethodError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_AbstractMethodError));\n-\n-  StubRoutines::_throw_IncompatibleClassChangeError_entry =\n-    generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_IncompatibleClassChangeError));\n-\n-  StubRoutines::_throw_NullPointerException_at_call_entry =\n-    generate_throw_exception(\"NullPointerException at call throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_NullPointerException_at_call));\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":239,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -589,10 +589,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs();\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  RuntimeStub* generate_jfr_write_checkpoint();\n-  \/\/ For c2: call to runtime to return a buffer lease.\n-  RuntimeStub* generate_jfr_return_lease();\n-#endif \/\/ INCLUDE_JFR\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -548,2 +548,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  __ jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  __ jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-static RuntimeStub* generate_empty_runtime_stub(const char* name) {\n+static RuntimeStub* generate_empty_runtime_stub() {\n@@ -104,1 +104,0 @@\n-\n@@ -114,1 +113,5 @@\n-  return generate_empty_runtime_stub(\"resolve_blob\");\n+  return generate_empty_runtime_stub();\n+}\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  return generate_empty_runtime_stub();\n@@ -130,0 +133,12 @@\n+\n+#if INCLUDE_JFR\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  return nullptr;\n+}\n+\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  return nullptr;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -206,16 +206,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in\n-    \/\/ non-core builds and need to be relocatable, so they each\n-    \/\/ fabricate a RuntimeStub internally.\n-    StubRoutines::_throw_AbstractMethodError_entry =\n-      ShouldNotCallThisStub();\n-\n-    StubRoutines::_throw_NullPointerException_at_call_entry =\n-      ShouldNotCallThisStub();\n-\n-    StubRoutines::_throw_StackOverflowError_entry =\n-      ShouldNotCallThisStub();\n-\n-    \/\/ support for verify_oop (must happen after universe_init)\n-    StubRoutines::_verify_oop_subroutine_entry =\n-      ShouldNotCallThisStub();\n-\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -47,0 +48,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -334,13 +336,15 @@\n-    markWord disp = lockee->mark().set_unlocked();\n-    monitor->lock()->set_displaced_header(disp);\n-    bool call_vm = (LockingMode == LM_MONITOR);\n-    bool inc_monitor_count = true;\n-    if (call_vm || lockee->cas_set_mark(markWord::from_pointer(monitor), disp) != disp) {\n-      \/\/ Is it simple recursive case?\n-      if (!call_vm && thread->is_lock_owned((address) disp.clear_lock_bits().to_pointer())) {\n-        monitor->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-      } else {\n-        inc_monitor_count = false;\n-        CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));\n-        if (HAS_PENDING_EXCEPTION)\n-          goto unwind_and_return;\n+    bool success = false;\n+    if (LockingMode == LM_LEGACY) {\n+      markWord disp = lockee->mark().set_unlocked();\n+      monitor->lock()->set_displaced_header(disp);\n+      success = true;\n+      if (lockee->cas_set_mark(markWord::from_pointer(monitor), disp) != disp) {\n+        \/\/ Is it simple recursive case?\n+        if (thread->is_lock_owned((address) disp.clear_lock_bits().to_pointer())) {\n+          monitor->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+        } else {\n+          success = false;\n+        }\n+      }\n+      if (success) {\n+        THREAD->inc_held_monitor_count();\n@@ -349,2 +353,4 @@\n-    if (inc_monitor_count) {\n-      THREAD->inc_held_monitor_count();\n+    if (!success) {\n+      CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));\n+          if (HAS_PENDING_EXCEPTION)\n+            goto unwind_and_return;\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1566,1 +1566,1 @@\n-       (scope()->wrote_final() ||\n+       (scope()->wrote_final() || scope()->wrote_stable() ||\n@@ -1744,4 +1744,0 @@\n-  if (field->is_final() && (code == Bytecodes::_putfield)) {\n-    scope()->set_wrote_final();\n-  }\n-\n@@ -1753,0 +1749,6 @@\n+    if (field->is_final()) {\n+      scope()->set_wrote_final();\n+    }\n+    if (field->is_stable()) {\n+      scope()->set_wrote_stable();\n+    }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  _wrote_stable       = false;\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+  bool          _wrote_stable;                   \/\/ has written @Stable field\n@@ -190,0 +191,2 @@\n+  void          set_wrote_stable()               { _wrote_stable = true; }\n+  bool          wrote_stable() const             { return _wrote_stable; }\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -760,2 +760,2 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT || obj == lock->obj(), \"must match\");\n-  SharedRuntime::monitor_enter_helper(obj, LockingMode == LM_LIGHTWEIGHT ? nullptr : lock->lock(), current);\n+  assert(obj == lock->obj(), \"must match\");\n+  SharedRuntime::monitor_enter_helper(obj, lock->lock(), current);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,0 +115,5 @@\n+  \/\/ The minimum region size of all collectors that are supported by CDS.\n+  \/\/ G1 heap region size can never be smaller than 1M.\n+  \/\/ Shenandoah heap region size can never be smaller than 256K.\n+  static constexpr int MIN_GC_REGION_ALIGNMENT = 256 * K;\n+\n@@ -122,6 +127,0 @@\n-  \/\/ The minimum region size of all collectors that are supported by CDS in\n-  \/\/ ArchiveHeapLoader::can_map() mode. Currently only G1 is supported. G1's region size\n-  \/\/ depends on -Xmx, but can never be smaller than 1 * M.\n-  \/\/ (TODO: Perhaps change to 256K to be compatible with Shenandoah)\n-  static constexpr int MIN_GC_REGION_ALIGNMENT = 1 * M;\n-\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2028,1 +2028,1 @@\n-        log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC or UseParallelGC are required.\");\n+        log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC, UseParallelGC, or UseShenandoahGC are required.\");\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -247,0 +247,4 @@\n+  \/\/ The claim size for group cardsets should be smaller to facilitate\n+  \/\/ better work distribution. The group cardsets should be larger than\n+  \/\/ the per region cardsets.\n+  const static uint GroupBucketClaimSize = 4;\n@@ -350,1 +354,9 @@\n-    _table_scanner.set(&_table, BucketClaimSize);\n+    reset_table_scanner(BucketClaimSize);\n+  }\n+\n+  void reset_table_scanner_for_groups() {\n+    reset_table_scanner(GroupBucketClaimSize);\n+  }\n+\n+  void reset_table_scanner(uint claim_size) {\n+    _table_scanner.set(&_table, claim_size);\n@@ -1045,0 +1057,4 @@\n+\n+void G1CardSet::reset_table_scanner_for_groups() {\n+  _table->reset_table_scanner_for_groups();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -383,0 +383,2 @@\n+  void reset_table_scanner_for_groups();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1162,0 +1162,2 @@\n+  _young_regions_cardset_mm(card_set_config(), card_set_freelist_pool()),\n+  _young_regions_cardset(card_set_config(), &_young_regions_cardset_mm),\n@@ -2696,0 +2698,1 @@\n+  hr->install_group_cardset(young_regions_cardset());\n@@ -2905,0 +2908,2 @@\n+      \/\/ Install the group cardset.\n+      new_alloc_region->install_group_cardset(young_regions_cardset());\n@@ -3046,0 +3051,4 @@\n+\n+void G1CollectedHeap::prepare_group_cardsets_for_scan () {\n+  _young_regions_cardset.reset_table_scanner_for_groups();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -782,0 +782,4 @@\n+  \/\/ Group cardsets\n+  G1CardSetMemoryManager _young_regions_cardset_mm;\n+  G1CardSet _young_regions_cardset;\n+\n@@ -783,0 +787,8 @@\n+  G1CardSetConfiguration* card_set_config() { return &_card_set_config; }\n+\n+  G1CardSet* young_regions_cardset() { return &_young_regions_cardset; };\n+\n+  G1CardSetMemoryManager* young_regions_card_set_mm() { return &_young_regions_cardset_mm; }\n+\n+  void prepare_group_cardsets_for_scan();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards);\n+  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards, _g1h->young_regions_cardset()->occupied());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2983,0 +2983,1 @@\n+  _young_cardset_bytes_per_region(0),\n@@ -2993,0 +2994,7 @@\n+  uint num_young_regions = g1h->young_regions_count();\n+  size_t young_cardset_bytes = g1h->young_regions_cardset()->mem_size();\n+\n+  if (num_young_regions > 0) {\n+    _young_cardset_bytes_per_region = young_cardset_bytes \/ num_young_regions;\n+  }\n+\n@@ -3044,0 +3052,4 @@\n+  if (r->is_young()) {\n+    remset_bytes = _young_cardset_bytes_per_region;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -961,0 +961,2 @@\n+  size_t _young_cardset_bytes_per_region;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-  size_t _sampled_card_rs_length;\n@@ -262,1 +261,1 @@\n-    _sampled_card_rs_length(0), _sampled_code_root_rs_length(0) {}\n+    _sampled_code_root_rs_length(0) {}\n@@ -266,1 +265,0 @@\n-    _sampled_card_rs_length += rem_set->occupied();\n@@ -271,1 +269,0 @@\n-  size_t sampled_card_rs_length() const { return _sampled_card_rs_length; }\n@@ -289,0 +286,2 @@\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    G1CollectionSet* cset = g1h->collection_set();\n@@ -290,1 +289,0 @@\n-    G1CollectionSet* cset = G1CollectedHeap::heap()->collection_set();\n@@ -292,1 +290,5 @@\n-    _policy->revise_young_list_target_length(cl.sampled_card_rs_length(), cl.sampled_code_root_rs_length());\n+\n+    size_t card_rs_length = g1h->young_regions_cardset()->occupied();\n+\n+    size_t sampled_code_root_rs_length = cl.sampled_code_root_rs_length();\n+    _policy->revise_young_list_target_length(card_rs_length, sampled_code_root_rs_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+    hr->uninstall_group_cardset();\n@@ -250,0 +251,2 @@\n+  _heap->young_regions_cardset()->clear();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+  uninstall_group_cardset();\n@@ -218,0 +219,3 @@\n+  if (is_young()) {\n+    uninstall_group_cardset();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+class G1CardSet;\n@@ -511,0 +512,3 @@\n+  void install_group_cardset(G1CardSet* group_cardset);\n+  void uninstall_group_cardset();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -514,0 +514,8 @@\n+inline void G1HeapRegion::install_group_cardset(G1CardSet* group_cardset) {\n+  _rem_set->install_group_cardset(group_cardset);\n+}\n+\n+inline void G1HeapRegion::uninstall_group_cardset() {\n+  _rem_set->uninstall_group_cardset();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,0 +58,7 @@\n+void G1HeapRegionRemSet::uninstall_group_cardset() {\n+  if (_saved_card_set != nullptr) {\n+    _card_set = _saved_card_set;\n+    _saved_card_set = nullptr;\n+  }\n+}\n+\n@@ -62,1 +69,2 @@\n-  _card_set(config, &_card_set_mm),\n+  _card_set(new G1CardSet(config, &_card_set_mm)),\n+  _saved_card_set(nullptr),\n@@ -71,0 +79,1 @@\n+  assert(_saved_card_set == nullptr, \"pre-condition\");\n@@ -75,1 +84,1 @@\n-  _card_set.clear();\n+  _card_set->clear();\n@@ -86,1 +95,1 @@\n-  _card_set.reset_table_scanner();\n+  _card_set->reset_table_scanner();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,1 +50,2 @@\n-  G1CardSet _card_set;\n+  G1CardSet* _card_set;\n+  G1CardSet* _saved_card_set;\n@@ -61,0 +62,1 @@\n+  ~G1HeapRegionRemSet() { delete _card_set; }\n@@ -63,1 +65,15 @@\n-    return _card_set.is_empty();\n+    return _card_set->is_empty();\n+  }\n+\n+  void install_group_cardset(G1CardSet* group_cardset) {\n+    assert(group_cardset != nullptr, \"pre-condition\");\n+    assert(_saved_card_set == nullptr, \"pre-condition\");\n+\n+    _saved_card_set = _card_set;\n+    _card_set = group_cardset;\n+  }\n+\n+  void uninstall_group_cardset();\n+\n+  bool has_group_cardset() {\n+    return _saved_card_set != nullptr;\n@@ -71,1 +87,1 @@\n-    return (code_roots_list_length() == 0) && _card_set.occupancy_less_or_equal_to(occ);\n+    return (code_roots_list_length() == 0) && _card_set->occupancy_less_or_equal_to(occ);\n@@ -80,0 +96,3 @@\n+  template <class CardOrRangeVisitor>\n+  inline static void iterate_for_merge(G1CardSet* card_set, CardOrRangeVisitor& cl);\n+\n@@ -81,1 +100,1 @@\n-    return _card_set.occupied();\n+    return _card_set->occupied();\n@@ -84,0 +103,2 @@\n+  G1CardSet* card_set() { return _card_set; }\n+\n@@ -128,1 +149,1 @@\n-    return _card_set.mem_size()\n+    return _card_set->mem_size()\n@@ -134,1 +155,1 @@\n-    return _card_set.unused_mem_size();\n+    return _card_set->unused_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.hpp","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -111,5 +111,1 @@\n-  G1HeapRegionRemSetMergeCardClosure<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(&_card_set,\n-                                                                                       cl,\n-                                                                                       _card_set.config()->log2_card_regions_per_heap_region(),\n-                                                                                       _card_set.config()->log2_cards_per_card_region());\n-  _card_set.iterate_containers(&cl2, true \/* at_safepoint *\/);\n+  iterate_for_merge(_card_set, cl);\n@@ -118,0 +114,8 @@\n+template <class CardOrRangeVisitor>\n+void G1HeapRegionRemSet::iterate_for_merge(G1CardSet* card_set, CardOrRangeVisitor& cl) {\n+  G1HeapRegionRemSetMergeCardClosure<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(card_set,\n+                                                                                       cl,\n+                                                                                       card_set->config()->log2_card_regions_per_heap_region(),\n+                                                                                       card_set->config()->log2_cards_per_card_region());\n+  card_set->iterate_containers(&cl2, true \/* at_safepoint *\/);\n+}\n@@ -133,1 +137,1 @@\n-   return;\n+    return;\n@@ -136,1 +140,1 @@\n-  _card_set.add_card(to_card(from));\n+  _card_set->add_card(to_card(from));\n@@ -140,1 +144,1 @@\n-  return _card_set.contains_card(to_card(from));\n+  return _card_set->contains_card(to_card(from));\n@@ -144,1 +148,1 @@\n-  _card_set.print_info(st, to_card(from));\n+  _card_set->print_info(st, to_card(from));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.inline.hpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1092,0 +1092,5 @@\n+  return predict_base_time_ms(pending_cards, card_rs_length);\n+}\n+\n+double G1Policy::predict_base_time_ms(size_t pending_cards, size_t card_rs_length) const {\n+  bool for_young_only_phase = collector_state()->in_young_only_phase();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,0 +141,2 @@\n+  double predict_base_time_ms(size_t pending_cards, size_t card_rs_length) const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1382,0 +1382,4 @@\n+        if (_initial_evacuation) {\n+          G1HeapRegionRemSet::iterate_for_merge(g1h->young_regions_cardset(), merge);\n+        }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+    size_t occupied_cards = hrrs->occupied();\n@@ -225,0 +226,8 @@\n+\n+    if (r->is_young()) {\n+      uint num_young  =  G1CollectedHeap::heap()->young_regions_count();\n+      occupied_cards \/= num_young;\n+      rs_unused_mem_sz \/= num_young;\n+      rs_mem_sz \/= num_young;\n+    }\n+\n@@ -229,1 +238,1 @@\n-    size_t occupied_cards = hrrs->occupied();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -298,4 +298,3 @@\n-      \/\/ Sample card set sizes for young gen and humongous before GC: this makes\n-      \/\/ the policy to give back memory to the OS keep the most recent amount of\n-      \/\/ memory for these regions.\n-      if (hr->is_young() || hr->is_starts_humongous()) {\n+      \/\/ Sample card set sizes for humongous before GC: this makes the policy to give\n+      \/\/ back memory to the OS keep the most recent amount of memory for these regions.\n+      if (hr->is_starts_humongous()) {\n@@ -510,0 +509,3 @@\n+\n+    _g1h->prepare_group_cardsets_for_scan();\n+\n@@ -517,1 +519,4 @@\n-    _g1h->set_young_gen_card_set_stats(g1_prep_task.all_card_set_stats());\n+    G1MonotonicArenaMemoryStats sampled_card_set_stats = g1_prep_task.all_card_set_stats();\n+    sampled_card_set_stats.add(_g1h->young_regions_card_set_mm()->memory_stats());\n+    _g1h->set_young_gen_card_set_stats(sampled_card_set_stats);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -676,0 +676,4 @@\n+\n+    \/\/ Add the cards from the group cardsets.\n+    _card_rs_length += g1h->young_regions_cardset()->occupied();\n+\n@@ -825,1 +829,0 @@\n-    stats()->account_card_rs_length(r);\n@@ -828,0 +831,2 @@\n+      \/\/ We only use card_rs_length statistics to estimate young regions length.\n+      stats()->account_card_rs_length(r);\n@@ -914,0 +919,2 @@\n+\n+    _g1h->young_regions_cardset()->clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -849,1 +849,9 @@\n-  Generation::print_on(st);\n+  st->print(\" %-10s\", name());\n+\n+  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n+            capacity()\/K, used()\/K);\n+  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+               p2i(_virtual_space.low_boundary()),\n+               p2i(_virtual_space.high()),\n+               p2i(_virtual_space.high_boundary()));\n+\n@@ -858,5 +866,0 @@\n-\n-const char* DefNewGeneration::name() const {\n-  return \"def new generation\";\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -237,2 +237,1 @@\n-  virtual const char* name() const;\n-  virtual const char* short_name() const { return \"DefNew\"; }\n+  const char* name() const { return \"DefNew\"; }\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,12 +61,0 @@\n-\n-void Generation::print() const { print_on(tty); }\n-\n-void Generation::print_on(outputStream* st)  const {\n-  st->print(\" %-20s\", name());\n-  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n-             capacity()\/K, used()\/K);\n-  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-              p2i(_virtual_space.low_boundary()),\n-              p2i(_virtual_space.high()),\n-              p2i(_virtual_space.high_boundary()));\n-}\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -106,7 +106,0 @@\n-  \/\/ Printing\n-  virtual const char* name() const = 0;\n-  virtual const char* short_name() const = 0;\n-\n-  virtual void print() const;\n-  virtual void print_on(outputStream* st) const;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -885,6 +885,6 @@\n-  if (_young_gen != nullptr) {\n-    _young_gen->print_on(st);\n-  }\n-  if (_old_gen != nullptr) {\n-    _old_gen->print_on(st);\n-  }\n+  assert(_young_gen != nullptr, \"precondition\");\n+  assert(_old_gen   != nullptr, \"precondition\");\n+\n+  _young_gen->print_on(st);\n+  _old_gen->print_on(st);\n+\n@@ -911,1 +911,1 @@\n-                     HEAP_CHANGE_FORMAT_ARGS(def_new_gen->short_name(),\n+                     HEAP_CHANGE_FORMAT_ARGS(def_new_gen->name(),\n@@ -927,1 +927,1 @@\n-                     HEAP_CHANGE_FORMAT_ARGS(old_gen()->short_name(),\n+                     HEAP_CHANGE_FORMAT_ARGS(old_gen()->name(),\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -443,1 +443,9 @@\n-  Generation::print_on(st);\n+  st->print(\" %-10s\", name());\n+\n+  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n+            capacity()\/K, used()\/K);\n+  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+               p2i(_virtual_space.low_boundary()),\n+               p2i(_virtual_space.high()),\n+               p2i(_virtual_space.high_boundary()));\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -124,2 +124,1 @@\n-  const char* name() const { return \"tenured generation\"; }\n-  const char* short_name() const { return \"Tenured\"; }\n+  const char* name() const { return \"Tenured\"; }\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  if (!heap->is_in(loc)) return;\n+  if (!heap->is_in_reserved(loc)) return;\n@@ -83,1 +83,1 @@\n-  if (heap->is_in(loc)) {\n+  if (heap->is_in_reserved(loc)) {\n@@ -102,1 +102,1 @@\n-  if (heap->is_in(loc)) {\n+  if (heap->is_in_reserved(loc)) {\n@@ -119,1 +119,1 @@\n-  bool loc_in_heap = (loc != nullptr && heap->is_in(loc));\n+  bool loc_in_heap = (loc != nullptr && heap->is_in_reserved(loc));\n@@ -172,1 +172,1 @@\n-void ShenandoahAsserts::assert_in_heap(void* interior_loc, oop obj, const char *file, int line) {\n+void ShenandoahAsserts::assert_in_heap_bounds(void* interior_loc, oop obj, const char *file, int line) {\n@@ -175,3 +175,3 @@\n-  if (!heap->is_in(obj)) {\n-    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap failed\",\n-                  \"oop must point to a heap address\",\n+  if (!heap->is_in_reserved(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_bounds failed\",\n+                  \"oop must be in heap bounds\",\n@@ -182,1 +182,1 @@\n-void ShenandoahAsserts::assert_in_heap_or_null(void* interior_loc, oop obj, const char *file, int line) {\n+void ShenandoahAsserts::assert_in_heap_bounds_or_null(void* interior_loc, oop obj, const char *file, int line) {\n@@ -185,3 +185,3 @@\n-  if (obj != nullptr && !heap->is_in(obj)) {\n-    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_or_null failed\",\n-                  \"oop must point to a heap address\",\n+  if (obj != nullptr && !heap->is_in_reserved(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_bounds_or_null failed\",\n+                  \"oop must be in heap bounds\",\n@@ -197,1 +197,1 @@\n-  if (!heap->is_in(obj)) {\n+  if (!heap->is_in_reserved(obj)) {\n@@ -199,1 +199,1 @@\n-                  \"oop must point to a heap address\",\n+                  \"oop must be in heap bounds\",\n@@ -216,0 +216,6 @@\n+  if (!heap->is_in(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                  \"Object should be in active region area\",\n+                  file, line);\n+  }\n+\n@@ -229,1 +235,1 @@\n-    if (!heap->is_in(fwd)) {\n+    if (!heap->is_in_reserved(fwd)) {\n@@ -231,1 +237,1 @@\n-                    \"Forwardee must point to a heap address\",\n+                    \"Forwardee must be in heap bounds\",\n@@ -242,0 +248,6 @@\n+    if (!heap->is_in(fwd)) {\n+      print_failure(_safe_oop, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                    \"Forwardee should be in active region area\",\n+                    file, line);\n+    }\n+\n@@ -244,1 +256,1 @@\n-                    \"Non-trivial forwardee should in another region\",\n+                    \"Non-trivial forwardee should be in another region\",\n@@ -260,1 +272,1 @@\n-  if (java_lang_Class::is_instance(obj)) {\n+  if (Universe::is_fully_initialized() && (obj_klass == vmClasses::Class_klass())) {\n@@ -289,1 +301,3 @@\n-  if (alloc_size > ShenandoahHeapRegion::humongous_threshold_words()) {\n+  HeapWord* obj_end = cast_from_oop<HeapWord*>(obj) + alloc_size;\n+\n+  if (ShenandoahHeapRegion::requires_humongous(alloc_size)) {\n@@ -291,2 +305,2 @@\n-    size_t num_regions = ShenandoahHeapRegion::required_regions(alloc_size * HeapWordSize);\n-    for (size_t i = idx; i < idx + num_regions; i++) {\n+    size_t end_idx = heap->heap_region_index_containing(obj_end - 1);\n+    for (size_t i = idx; i < end_idx; i++) {\n@@ -305,0 +319,6 @@\n+  } else {\n+    if (obj_end > r->top()) {\n+      print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_correct_region failed\",\n+                    \"Object end should be within the active area of the region\",\n+                    file, line);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":41,"deletions":21,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-  static void assert_in_heap(void* interior_loc, oop obj, const char* file, int line);\n-  static void assert_in_heap_or_null(void* interior_loc, oop obj, const char* file, int line);\n+  static void assert_in_heap_bounds(void* interior_loc, oop obj, const char* file, int line);\n+  static void assert_in_heap_bounds_or_null(void* interior_loc, oop obj, const char* file, int line);\n@@ -81,4 +81,4 @@\n-#define shenandoah_assert_in_heap(interior_loc, obj) \\\n-                    ShenandoahAsserts::assert_in_heap(interior_loc, obj, __FILE__, __LINE__)\n-#define shenandoah_assert_in_heap_or_null(interior_loc, obj) \\\n-                    ShenandoahAsserts::assert_in_heap_or_null(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_in_heap_bounds(interior_loc, obj) \\\n+                    ShenandoahAsserts::assert_in_heap_bounds(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_in_heap_bounds_or_null(interior_loc, obj) \\\n+                    ShenandoahAsserts::assert_in_heap_bounds_or_null(interior_loc, obj, __FILE__, __LINE__)\n@@ -186,2 +186,2 @@\n-#define shenandoah_assert_in_heap(interior_loc, obj)\n-#define shenandoah_assert_in_heap_or_null(interior_loc, obj)\n+#define shenandoah_assert_in_heap_bounds(interior_loc, obj)\n+#define shenandoah_assert_in_heap_bounds_or_null(interior_loc, obj)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  shenandoah_assert_in_heap_or_null(nullptr, p);\n+  shenandoah_assert_in_heap_bounds_or_null(nullptr, p);\n@@ -50,1 +50,1 @@\n-  assert(p == nullptr || _heap->is_in(p), \"Must be in the heap\");\n+  assert(p == nullptr || _heap->is_in_reserved(p), \"Must be in the heap\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -866,4 +866,1 @@\n-        \/\/ Here we are asserting that an unmarked from-space object is 'correct'. There seems to be a legitimate\n-        \/\/ use-case for accessing from-space objects during concurrent class unloading. In all modes of Shenandoah,\n-        \/\/ concurrent class unloading only happens during a global collection.\n-        shenandoah_assert_correct(p, obj);\n+        \/\/ Note: The obj is dead here. Do not touch it, just clear.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  bool is_humongous = req.size() > ShenandoahHeapRegion::humongous_threshold_words();\n+  bool is_humongous = ShenandoahHeapRegion::requires_humongous(req.size());\n@@ -83,1 +83,1 @@\n-  bool is_humongous = (words > ShenandoahHeapRegion::region_size_words());\n+  bool is_humongous = ShenandoahHeapRegion::requires_humongous(words);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  shenandoah_assert_in_heap(nullptr, obj);\n+  shenandoah_assert_in_heap_bounds(nullptr, obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1987,1 +1987,1 @@\n-  if (req.size() > ShenandoahHeapRegion::humongous_threshold_words()) {\n+  if (ShenandoahHeapRegion::requires_humongous(req.size())) {\n@@ -1997,2 +1997,1 @@\n-        assert(false, \"Trying to allocate TLAB larger than the humongous threshold: \" SIZE_FORMAT \" > \" SIZE_FORMAT,\n-               req.size(), ShenandoahHeapRegion::humongous_threshold_words());\n+        assert(false, \"Trying to allocate TLAB in humongous region: \" SIZE_FORMAT, req.size());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-  \/\/ Precondition: req.size() <= ShenandoahHeapRegion::humongous_threshold_words().\n+  \/\/ Precondition: !ShenandoahHeapRegion::requires_humongous(req.size())\n@@ -320,1 +320,1 @@\n-  \/\/ Precondition: req.size() > ShenandoahHeapRegion::humongous_threshold_words().\n+  \/\/ Precondition: ShenandoahHeapRegion::requires_humongous(req.size())\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+#include \"cds\/archiveHeapWriter.hpp\"\n@@ -708,1 +709,1 @@\n-    if (wasted_bytes > 0 && req.actual_size() > ShenandoahHeapRegion::humongous_threshold_words()) {\n+    if (wasted_bytes > 0 && ShenandoahHeapRegion::requires_humongous(req.actual_size())) {\n@@ -782,0 +783,15 @@\n+bool ShenandoahHeap::is_in(const void* p) const {\n+  if (is_in_reserved(p)) {\n+    if (is_full_gc_move_in_progress()) {\n+      \/\/ Full GC move is running, we do not have a consistent region\n+      \/\/ information yet. But we know the pointer is in heap.\n+      return true;\n+    }\n+    \/\/ Now check if we point to a live section in active region.\n+    ShenandoahHeapRegion* r = heap_region_containing(p);\n+    return (r->is_active() && p < r->top());\n+  } else {\n+    return false;\n+  }\n+}\n+\n@@ -2671,0 +2687,77 @@\n+HeapWord* ShenandoahHeap::allocate_loaded_archive_space(size_t size) {\n+#if INCLUDE_CDS_JAVA_HEAP\n+  \/\/ CDS wants a continuous memory range to load a bunch of objects.\n+  \/\/ This effectively bypasses normal allocation paths, and requires\n+  \/\/ a bit of massaging to unbreak GC invariants.\n+\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);\n+\n+  \/\/ Easy case: a single regular region, no further adjustments needed.\n+  if (!ShenandoahHeapRegion::requires_humongous(size)) {\n+    return allocate_memory(req);\n+  }\n+\n+  \/\/ Hard case: the requested size would cause a humongous allocation.\n+  \/\/ We need to make sure it looks like regular allocation to the rest of GC.\n+\n+  \/\/ CDS code would guarantee no objects straddle multiple regions, as long as\n+  \/\/ regions are as large as MIN_GC_REGION_ALIGNMENT. It is impractical at this\n+  \/\/ point to deal with case when Shenandoah runs with smaller regions.\n+  \/\/ TODO: This check can be dropped once MIN_GC_REGION_ALIGNMENT agrees more with Shenandoah.\n+  if (ShenandoahHeapRegion::region_size_bytes() < ArchiveHeapWriter::MIN_GC_REGION_ALIGNMENT) {\n+    return nullptr;\n+  }\n+\n+  HeapWord* mem = allocate_memory(req);\n+  size_t start_idx = heap_region_index_containing(mem);\n+  size_t num_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);\n+\n+  \/\/ Flip humongous -> regular.\n+  {\n+    ShenandoahHeapLocker locker(lock(), false);\n+    for (size_t c = start_idx; c < start_idx + num_regions; c++) {\n+      get_region(c)->make_regular_bypass();\n+    }\n+  }\n+\n+  return mem;\n+#else\n+  assert(false, \"Archive heap loader should not be available, should not be here\");\n+  return nullptr;\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+}\n+\n+void ShenandoahHeap::complete_loaded_archive_space(MemRegion archive_space) {\n+  \/\/ Nothing to do here, except checking that heap looks fine.\n+#ifdef ASSERT\n+  HeapWord* start = archive_space.start();\n+  HeapWord* end = archive_space.end();\n+\n+  \/\/ No unclaimed space between the objects.\n+  \/\/ Objects are properly allocated in correct regions.\n+  HeapWord* cur = start;\n+  while (cur < end) {\n+    oop oop = cast_to_oop(cur);\n+    shenandoah_assert_in_correct_region(nullptr, oop);\n+    cur += oop->size();\n+  }\n+\n+  \/\/ No unclaimed tail at the end of archive space.\n+  assert(cur == end,\n+         \"Archive space should be fully used: \" PTR_FORMAT \" \" PTR_FORMAT,\n+         p2i(cur), p2i(end));\n+\n+  \/\/ Region bounds are good.\n+  ShenandoahHeapRegion* begin_reg = heap_region_containing(start);\n+  ShenandoahHeapRegion* end_reg = heap_region_containing(end);\n+  assert(begin_reg->is_regular(), \"Must be\");\n+  assert(end_reg->is_regular(), \"Must be\");\n+  assert(begin_reg->bottom() == start,\n+         \"Must agree: archive-space-start: \" PTR_FORMAT \", begin-region-bottom: \" PTR_FORMAT,\n+         p2i(start), p2i(begin_reg->bottom()));\n+  assert(end_reg->top() == end,\n+         \"Must agree: archive-space-end: \" PTR_FORMAT \", end-region-top: \" PTR_FORMAT,\n+         p2i(end), p2i(end_reg->top()));\n+#endif\n+}\n+\n@@ -2692,0 +2785,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":95,"deletions":1,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -601,1 +601,3 @@\n-  inline bool is_in(const void* p) const override;\n+  \/\/ Check the pointer is in active part of Java heap.\n+  \/\/ Use is_in_reserved to check if object is within heap bounds.\n+  bool is_in(const void* p) const override;\n@@ -657,0 +659,6 @@\n+\/\/ ---------- CDS archive support\n+\n+  bool can_load_archived_objects() const override { return UseCompressedOops; }\n+  HeapWord* allocate_loaded_archive_space(size_t size) override;\n+  void complete_loaded_archive_space(MemRegion archive_space) override;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -348,6 +348,0 @@\n-bool ShenandoahHeap::is_in(const void* p) const {\n-  HeapWord* heap_base = (HeapWord*) base();\n-  HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();\n-  return p >= heap_base && p < last_region_end;\n-}\n-\n@@ -369,1 +363,1 @@\n-  assert(is_in(obj), \"only check if is in active generation for objects (\" PTR_FORMAT \") in heap\", p2i(obj));\n+  assert(is_in_reserved(obj), \"only check if is in active generation for objects (\" PTR_FORMAT \") in heap\", p2i(obj));\n@@ -395,1 +389,1 @@\n-  return is_in(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::YOUNG_GENERATION);\n+  return is_in_reserved(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::YOUNG_GENERATION);\n@@ -399,1 +393,1 @@\n-  return is_in(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::OLD_GENERATION);\n+  return is_in_reserved(p) && (_affiliations[heap_region_index_containing(p)] == ShenandoahAffiliation::OLD_GENERATION);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-\n@@ -63,2 +62,0 @@\n-size_t ShenandoahHeapRegion::HumongousThresholdBytes = 0;\n-size_t ShenandoahHeapRegion::HumongousThresholdWords = 0;\n@@ -147,2 +144,4 @@\n-  assert (ShenandoahHeap::heap()->is_full_gc_in_progress() || ShenandoahHeap::heap()->is_degenerated_gc_in_progress(),\n-          \"only for full or degen GC\");\n+  assert (!Universe::is_fully_initialized() ||\n+          ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+          ShenandoahHeap::heap()->is_degenerated_gc_in_progress(),\n+          \"Only for STW GC or when Universe is initializing (CDS)\");\n@@ -750,9 +749,0 @@\n-  guarantee(HumongousThresholdWords == 0, \"we should only set it once\");\n-  HumongousThresholdWords = RegionSizeWords * ShenandoahHumongousThreshold \/ 100;\n-  HumongousThresholdWords = align_down(HumongousThresholdWords, MinObjAlignment);\n-  assert (HumongousThresholdWords <= RegionSizeWords, \"sanity\");\n-\n-  guarantee(HumongousThresholdBytes == 0, \"we should only set it once\");\n-  HumongousThresholdBytes = HumongousThresholdWords * HeapWordSize;\n-  assert (HumongousThresholdBytes <= RegionSizeBytes, \"sanity\");\n-\n@@ -760,2 +750,1 @@\n-  MaxTLABSizeWords = MIN2(RegionSizeWords, HumongousThresholdWords);\n-  MaxTLABSizeWords = align_down(MaxTLABSizeWords, MinObjAlignment);\n+  MaxTLABSizeWords = align_down(RegionSizeWords, MinObjAlignment);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -231,2 +231,0 @@\n-  static size_t HumongousThresholdBytes;\n-  static size_t HumongousThresholdWords;\n@@ -282,0 +280,4 @@\n+  inline static bool requires_humongous(size_t words) {\n+    return words > ShenandoahHeapRegion::RegionSizeWords;\n+  }\n+\n@@ -334,8 +336,0 @@\n-  inline static size_t humongous_threshold_bytes() {\n-    return ShenandoahHeapRegion::HumongousThresholdBytes;\n-  }\n-\n-  inline static size_t humongous_threshold_words() {\n-    return ShenandoahHeapRegion::HumongousThresholdWords;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  log_info(gc, init)(\"Humongous Object Threshold: \" EXACTFMT, EXACTFMTARGS(ShenandoahHeapRegion::humongous_threshold_bytes()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahInitLogger.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-  assert(ShenandoahHeap::heap()->is_in(addr),\n+  assert(ShenandoahHeap::heap()->is_in_reserved(addr),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,4 +64,5 @@\n-  \/\/ TODO: Do these really need to be const?\n-  inline bool is_marked(const oop) const;\n-  inline bool is_marked_strong(const oop obj) const;\n-  inline bool is_marked_weak(const oop obj) const;\n+  inline bool is_marked(oop obj) const;\n+  inline bool is_marked(HeapWord* raw_obj) const;\n+  inline bool is_marked_strong(oop obj) const;\n+  inline bool is_marked_strong(HeapWord* raw_obj) const;\n+  inline bool is_marked_weak(oop obj) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -42,1 +42,5 @@\n-  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked(cast_from_oop<HeapWord *>(obj));\n+  return is_marked(cast_from_oop<HeapWord*>(obj));\n+}\n+\n+inline bool ShenandoahMarkingContext::is_marked(HeapWord* raw_obj) const {\n+  return allocated_after_mark_start(raw_obj) || _mark_bit_map.is_marked(raw_obj);\n@@ -46,1 +50,5 @@\n-  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked_strong(cast_from_oop<HeapWord*>(obj));\n+  return is_marked_strong(cast_from_oop<HeapWord*>(obj));\n+}\n+\n+inline bool ShenandoahMarkingContext::is_marked_strong(HeapWord* raw_obj) const {\n+  return allocated_after_mark_start(raw_obj) || _mark_bit_map.is_marked_strong(raw_obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -112,0 +112,11 @@\n+inline oop reference_coop_decode_raw(narrowOop v) {\n+  return CompressedOops::is_null(v) ? nullptr : CompressedOops::decode_raw(v);\n+}\n+\n+inline oop reference_coop_decode_raw(oop v) {\n+  return v;\n+}\n+\n+\/\/ Raw referent, it can be dead. You cannot treat it as oop without additional safety\n+\/\/ checks, this is why it is HeapWord*. The decoding uses a special-case inlined\n+\/\/ CompressedOops::decode method that bypasses normal oop-ness checks.\n@@ -113,3 +124,3 @@\n-static oop reference_referent(oop reference) {\n-  T heap_oop = Atomic::load(reference_referent_addr<T>(reference));\n-  return CompressedOops::decode(heap_oop);\n+static HeapWord* reference_referent_raw(oop reference) {\n+  T raw_oop = Atomic::load(reference_referent_addr<T>(reference));\n+  return cast_from_oop<HeapWord*>(reference_coop_decode_raw(raw_oop));\n@@ -313,2 +324,2 @@\n-  const oop referent = reference_referent<T>(reference);\n-  if (referent == nullptr) {\n+  HeapWord* raw_referent = reference_referent_raw<T>(reference);\n+  if (raw_referent == nullptr) {\n@@ -324,1 +335,1 @@\n-    return ShenandoahHeap::heap()->complete_marking_context()->is_marked(referent);\n+    return ShenandoahHeap::heap()->complete_marking_context()->is_marked(raw_referent);\n@@ -326,1 +337,1 @@\n-    return ShenandoahHeap::heap()->complete_marking_context()->is_marked_strong(referent);\n+    return ShenandoahHeap::heap()->complete_marking_context()->is_marked_strong(raw_referent);\n@@ -338,1 +349,1 @@\n-    assert(ShenandoahHeap::heap()->marking_context()->is_marked(reference_referent<T>(reference)), \"only make inactive final refs with alive referents\");\n+    assert(ShenandoahHeap::heap()->marking_context()->is_marked(reference_referent_raw<T>(reference)), \"only make inactive final refs with alive referents\");\n@@ -425,0 +436,7 @@\n+  HeapWord* raw_referent = reference_referent_raw<T>(reference);\n+\n+#ifdef ASSERT\n+  assert(raw_referent == nullptr || ShenandoahHeap::heap()->marking_context()->is_marked(raw_referent),\n+         \"only drop references with alive referents\");\n+#endif\n+\n@@ -426,2 +444,0 @@\n-  oop referent = reference_referent<T>(reference);\n-  assert(referent == nullptr || heap->marking_context()->is_marked(referent), \"only drop references with alive referents\");\n@@ -436,1 +452,1 @@\n-  if (heap->mode()->is_generational() && heap->is_in_old(reference) && heap->is_in_young(referent)) {\n+  if (heap->mode()->is_generational() && heap->is_in_old(reference) && heap->is_in_young(raw_referent)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":27,"deletions":11,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -59,7 +59,0 @@\n-class ShenandoahIgnoreReferenceDiscoverer : public ReferenceDiscoverer {\n-public:\n-  virtual bool discover_reference(oop obj, ReferenceType type) {\n-    return true;\n-  }\n-};\n-\n@@ -76,0 +69,1 @@\n+  ReferenceIterationMode _ref_mode;\n@@ -93,1 +87,7 @@\n-      set_ref_discoverer_internal(new ShenandoahIgnoreReferenceDiscoverer());\n+      \/\/ Unknown status for Reference.referent field. Do not touch it, it might be dead.\n+      \/\/ Normally, barriers would prevent us from seeing the dead referents, but verifier\n+      \/\/ runs with barriers disabled.\n+      _ref_mode = DO_FIELDS_EXCEPT_REFERENT;\n+    } else {\n+      \/\/ Otherwise do all fields.\n+      _ref_mode = DO_FIELDS;\n@@ -103,0 +103,4 @@\n+  ReferenceIterationMode reference_iteration_mode() override {\n+    return _ref_mode;\n+  }\n+\n@@ -147,2 +151,2 @@\n-    check(ShenandoahAsserts::_safe_unknown, obj, _heap->is_in(obj),\n-              \"oop must be in heap\");\n+    check(ShenandoahAsserts::_safe_unknown, obj, _heap->is_in_reserved(obj),\n+              \"oop must be in heap bounds\");\n@@ -207,2 +211,2 @@\n-      check(ShenandoahAsserts::_safe_oop, obj, _heap->is_in(fwd),\n-             \"Forwardee must be in heap\");\n+      check(ShenandoahAsserts::_safe_oop, obj, _heap->is_in_reserved(fwd),\n+             \"Forwardee must be in heap bounds\");\n@@ -225,0 +229,3 @@\n+      check(ShenandoahAsserts::_safe_oop, obj, fwd_reg->is_active(),\n+            \"Forwardee should be in active region\");\n+\n@@ -245,1 +252,1 @@\n-    if (java_lang_Class::is_instance(obj)) {\n+    if (obj_klass == vmClasses::Class_klass()) {\n@@ -1128,14 +1135,0 @@\n-void ShenandoahVerifier::verify_after_evacuation() {\n-  verify_at_safepoint(\n-          \"After Evacuation\",\n-          _verify_remembered_disable,  \/\/ do not verify remembered set\n-          _verify_forwarded_allow,     \/\/ objects are still forwarded\n-          _verify_marked_complete,     \/\/ bitmaps might be stale, but alloc-after-mark should be well\n-          _verify_cset_forwarded,      \/\/ all cset refs are fully forwarded\n-          _verify_liveness_disable,    \/\/ no reliable liveness data anymore\n-          _verify_regions_notrash,     \/\/ trash regions have been recycled already\n-          _verify_size_exact,          \/\/ expect generation and heap sizes to match exactly\n-          _verify_gcstate_forwarded    \/\/ evacuation produced some forwarded objects\n-  );\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -219,1 +219,0 @@\n-  void verify_after_evacuation();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -133,7 +133,0 @@\n-  product(intx, ShenandoahHumongousThreshold, 100, EXPERIMENTAL,            \\\n-          \"Humongous objects are allocated in separate regions. \"           \\\n-          \"This setting defines how large the object should be to be \"      \\\n-          \"deemed humongous. Value is in  percents of heap region size. \"   \\\n-          \"This also caps the maximum TLAB size.\")                          \\\n-          range(1, 100)                                                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -728,1 +728,0 @@\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Should call monitorenter_obj() when using the new lightweight locking\");\n@@ -743,17 +742,0 @@\n-\/\/ NOTE: We provide a separate implementation for the new lightweight locking to workaround a limitation\n-\/\/ of registers in x86_32. This entry point accepts an oop instead of a BasicObjectLock*.\n-\/\/ The problem is that we would need to preserve the register that holds the BasicObjectLock,\n-\/\/ but we are using that register to hold the thread. We don't have enough registers to\n-\/\/ also keep the BasicObjectLock, but we don't really need it anyway, we only need\n-\/\/ the object. See also InterpreterMacroAssembler::lock_object().\n-\/\/ As soon as legacy stack-locking goes away we could remove the other monitorenter() entry\n-\/\/ point, and only use oop-accepting entries (same for monitorexit() below).\n-JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter_obj(JavaThread* current, oopDesc* obj))\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"Should call monitorenter() when not using the new lightweight locking\");\n-  Handle h_obj(current, cast_to_oop(obj));\n-  assert(Universe::heap()->is_in_or_null(h_obj()),\n-         \"must be null or an object\");\n-  ObjectSynchronizer::enter(h_obj, nullptr, current);\n-  return;\n-JRT_END\n-\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -57,0 +58,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -64,0 +66,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -627,12 +630,16 @@\n-        \/\/ Traditional lightweight locking.\n-        markWord displaced = rcvr->mark().set_unlocked();\n-        mon->lock()->set_displaced_header(displaced);\n-        bool call_vm = (LockingMode == LM_MONITOR);\n-        bool inc_monitor_count = true;\n-        if (call_vm || rcvr->cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {\n-          \/\/ Is it simple recursive case?\n-          if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-            mon->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-          } else {\n-            inc_monitor_count = false;\n-            CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);\n+        bool success = false;\n+        if (LockingMode == LM_LEGACY) {\n+           \/\/ Traditional fast locking.\n+          markWord displaced = rcvr->mark().set_unlocked();\n+          mon->lock()->set_displaced_header(displaced);\n+          success = true;\n+          if (rcvr->cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {\n+            \/\/ Is it simple recursive case?\n+            if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+              mon->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+            } else {\n+              success = false;\n+            }\n+          }\n+          if (success) {\n+            THREAD->inc_held_monitor_count();\n@@ -641,2 +648,2 @@\n-        if (inc_monitor_count) {\n-          THREAD->inc_held_monitor_count();\n+        if (!success) {\n+            CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);\n@@ -644,0 +651,1 @@\n+\n@@ -726,12 +734,16 @@\n-      \/\/ traditional lightweight locking\n-      markWord displaced = lockee->mark().set_unlocked();\n-      entry->lock()->set_displaced_header(displaced);\n-      bool call_vm = (LockingMode == LM_MONITOR);\n-      bool inc_monitor_count = true;\n-      if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n-        \/\/ Is it simple recursive case?\n-        if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-          entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-        } else {\n-          inc_monitor_count = false;\n-          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n+      bool success = false;\n+      if (LockingMode == LM_LEGACY) {\n+        \/\/ Traditional fast locking.\n+        markWord displaced = lockee->mark().set_unlocked();\n+        entry->lock()->set_displaced_header(displaced);\n+        success = true;\n+        if (lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n+          \/\/ Is it simple recursive case?\n+          if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+            entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+          } else {\n+            success = false;\n+          }\n+        }\n+        if (success) {\n+          THREAD->inc_held_monitor_count();\n@@ -740,2 +752,2 @@\n-      if (inc_monitor_count) {\n-        THREAD->inc_held_monitor_count();\n+      if (!success) {\n+        CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n@@ -743,0 +755,1 @@\n+\n@@ -1656,12 +1669,16 @@\n-          \/\/ traditional lightweight locking\n-          markWord displaced = lockee->mark().set_unlocked();\n-          entry->lock()->set_displaced_header(displaced);\n-          bool call_vm = (LockingMode == LM_MONITOR);\n-          bool inc_monitor_count = true;\n-          if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n-            \/\/ Is it simple recursive case?\n-            if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-              entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-            } else {\n-              inc_monitor_count = false;\n-              CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n+          bool success = false;\n+          if (LockingMode == LM_LEGACY) {\n+            \/\/ Traditional fast locking.\n+            markWord displaced = lockee->mark().set_unlocked();\n+            entry->lock()->set_displaced_header(displaced);\n+            success = true;\n+            if (lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n+              \/\/ Is it simple recursive case?\n+              if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+                entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+              } else {\n+                success = false;\n+              }\n+            }\n+            if (success) {\n+              THREAD->inc_held_monitor_count();\n@@ -1670,2 +1687,2 @@\n-          if (inc_monitor_count) {\n-            THREAD->inc_held_monitor_count();\n+          if (!success) {\n+            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n@@ -1673,0 +1690,1 @@\n+\n@@ -1690,2 +1708,0 @@\n-            markWord header = lock->displaced_header();\n-            most_recent->set_obj(nullptr);\n@@ -1693,10 +1709,16 @@\n-            \/\/ If it isn't recursive we either must swap old header or call the runtime\n-            bool dec_monitor_count = true;\n-            bool call_vm = (LockingMode == LM_MONITOR);\n-            if (header.to_pointer() != nullptr || call_vm) {\n-              markWord old_header = markWord::encode(lock);\n-              if (call_vm || lockee->cas_set_mark(header, old_header) != old_header) {\n-                \/\/ restore object for the slow case\n-                most_recent->set_obj(lockee);\n-                dec_monitor_count = false;\n-                InterpreterRuntime::monitorexit(most_recent);\n+            bool success = false;\n+            if (LockingMode == LM_LEGACY) {\n+              \/\/ If it isn't recursive we either must swap old header or call the runtime\n+              most_recent->set_obj(nullptr);\n+              success = true;\n+              markWord header = lock->displaced_header();\n+              if (header.to_pointer() != nullptr) {\n+                markWord old_header = markWord::encode(lock);\n+                if (lockee->cas_set_mark(header, old_header) != old_header) {\n+                  \/\/ restore object for the slow case\n+                  most_recent->set_obj(lockee);\n+                  success = false;\n+                }\n+              }\n+              if (success) {\n+                THREAD->dec_held_monitor_count();\n@@ -1705,2 +1727,2 @@\n-            if (dec_monitor_count) {\n-              THREAD->dec_held_monitor_count();\n+            if (!success) {\n+              InterpreterRuntime::monitorexit(most_recent);\n@@ -3128,12 +3150,18 @@\n-          markWord header = lock->displaced_header();\n-          end->set_obj(nullptr);\n-\n-          \/\/ If it isn't recursive we either must swap old header or call the runtime\n-          bool dec_monitor_count = true;\n-          if (header.to_pointer() != nullptr) {\n-            markWord old_header = markWord::encode(lock);\n-            if (lockee->cas_set_mark(header, old_header) != old_header) {\n-              \/\/ restore object for the slow case\n-              end->set_obj(lockee);\n-              dec_monitor_count = false;\n-              InterpreterRuntime::monitorexit(end);\n+\n+          bool success = false;\n+          if (LockingMode == LM_LEGACY) {\n+            markWord header = lock->displaced_header();\n+            end->set_obj(nullptr);\n+\n+            \/\/ If it isn't recursive we either must swap old header or call the runtime\n+            success = true;\n+            if (header.to_pointer() != nullptr) {\n+              markWord old_header = markWord::encode(lock);\n+              if (lockee->cas_set_mark(header, old_header) != old_header) {\n+                \/\/ restore object for the slow case\n+                end->set_obj(lockee);\n+                success = false;\n+              }\n+            }\n+            if (success) {\n+              THREAD->dec_held_monitor_count();\n@@ -3142,2 +3170,2 @@\n-          if (dec_monitor_count) {\n-            THREAD->dec_held_monitor_count();\n+          if (!success) {\n+            InterpreterRuntime::monitorexit(end);\n@@ -3191,1 +3219,1 @@\n-          } else if (LockingMode == LM_MONITOR) {\n+          } else if (LockingMode != LM_LEGACY) {\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":99,"deletions":71,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -396,2 +396,1 @@\n-template <typename Instance, void(Instance::*func)()>\n-class JfrVMOperation : public VM_Operation {\n+class JfrSafepointClearVMOperation : public VM_Operation {\n@@ -399,1 +398,10 @@\n-  Instance& _instance;\n+  JfrRecorderService& _instance;\n+ public:\n+  JfrSafepointClearVMOperation(JfrRecorderService& instance) : _instance(instance) {}\n+  void doit() { _instance.safepoint_clear(); }\n+  VMOp_Type type() const { return VMOp_JFRSafepointClear; }\n+};\n+\n+class JfrSafepointWriteVMOperation : public VM_Operation {\n+ private:\n+  JfrRecorderService& _instance;\n@@ -401,3 +409,3 @@\n-  JfrVMOperation(Instance& instance) : _instance(instance) {}\n-  void doit() { (_instance.*func)(); }\n-  VMOp_Type type() const { return VMOp_JFRCheckpoint; }\n+  JfrSafepointWriteVMOperation(JfrRecorderService& instance) : _instance(instance) {}\n+  void doit() { _instance.safepoint_write(); }\n+  VMOp_Type type() const { return VMOp_JFRSafepointWrite; }\n@@ -473,1 +481,1 @@\n-  JfrVMOperation<JfrRecorderService, &JfrRecorderService::safepoint_clear> safepoint_task(*this);\n+  JfrSafepointClearVMOperation op(*this);\n@@ -475,1 +483,1 @@\n-  VMThread::execute(&safepoint_task);\n+  VMThread::execute(&op);\n@@ -580,1 +588,1 @@\n-  JfrVMOperation<JfrRecorderService, &JfrRecorderService::safepoint_write> safepoint_task(*this);\n+  JfrSafepointWriteVMOperation op(*this);\n@@ -583,1 +591,1 @@\n-  VMThread::execute(&safepoint_task);\n+  VMThread::execute(&op);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+  friend class JfrSafepointClearVMOperation;\n+  friend class JfrSafepointWriteVMOperation;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+    static address SharedRuntime_throw_delayed_StackOverflowError_entry;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+address CompilerToVM::Data::SharedRuntime_throw_delayed_StackOverflowError_entry;\n@@ -161,0 +162,1 @@\n+  SharedRuntime_throw_delayed_StackOverflowError_entry = SharedRuntime::throw_delayed_StackOverflowError_entry();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+  static_field(CompilerToVM::Data,             SharedRuntime_throw_delayed_StackOverflowError_entry,                                 \\\n+                                                                                       address)                                      \\\n@@ -154,1 +156,1 @@\n-  volatile_nonstatic_field(BasicLock,          _displaced_header,                      markWord)                                     \\\n+  volatile_nonstatic_field(BasicLock,          _metadata,                              uintptr_t)                                    \\\n@@ -244,0 +246,1 @@\n+  nonstatic_field(JavaThread,                  _om_cache,                                     OMCache)                               \\\n@@ -330,2 +333,0 @@\n-  static_field(StubRoutines,                _throw_delayed_StackOverflowError_entry,          address)                               \\\n-                                                                                                                                     \\\n@@ -534,0 +535,2 @@\n+  declare_constant_with_value(\"OMCache::oop_to_oop_difference\", OMCache::oop_to_oop_difference()) \\\n+  declare_constant_with_value(\"OMCache::oop_to_monitor_difference\", OMCache::oop_to_monitor_difference()) \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+  LOG_TAG(monitortable) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -896,9 +896,11 @@\n-  Log(gc, metaspace, freelist, oom) log;\n-  if (log.is_info()) {\n-    log.info(\"Metaspace (%s) allocation failed for size \" SIZE_FORMAT,\n-             is_class_space_allocation(mdtype) ? \"class\" : \"data\", word_size);\n-    ResourceMark rm;\n-    if (log.is_debug()) {\n-      if (loader_data->metaspace_or_null() != nullptr) {\n-        LogStream ls(log.debug());\n-        loader_data->print_value_on(&ls);\n+  {\n+    LogMessage(gc, metaspace, freelist, oom) log;\n+    if (log.is_info()) {\n+      log.info(\"Metaspace (%s) allocation failed for size \" SIZE_FORMAT,\n+               is_class_space_allocation(mdtype) ? \"class\" : \"data\", word_size);\n+      ResourceMark rm;\n+      if (log.is_debug()) {\n+        if (loader_data->metaspace_or_null() != nullptr) {\n+          NonInterleavingLogStream ls(LogLevelType::Debug, log);\n+          loader_data->print_value_on(&ls);\n+        }\n@@ -906,0 +908,3 @@\n+      NonInterleavingLogStream ls(LogLevelType::Info, log);\n+      \/\/ In case of an OOM, log out a short but still useful report.\n+      MetaspaceUtils::print_basic_report(&ls, 0);\n@@ -907,3 +912,0 @@\n-    LogStream ls(log.info());\n-    \/\/ In case of an OOM, log out a short but still useful report.\n-    MetaspaceUtils::print_basic_report(&ls, 0);\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -228,4 +228,0 @@\n-  \/\/ _is_marked_dependent can be set concurrently, thus cannot be part of the\n-  \/\/ _misc_flags.\n-  bool            _is_marked_dependent;     \/\/ used for marking during flushing and deoptimization\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -70,1 +71,1 @@\n-    if (print_monitor_info) {\n+    if (print_monitor_info && !UseObjectMonitorTable) {\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -200,0 +200,1 @@\n+    assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use markWord for monitors\");\n@@ -205,2 +206,5 @@\n-    return LockingMode == LM_LIGHTWEIGHT  ? lockbits == monitor_value   \/\/ monitor?\n-                                          : (lockbits & unlocked_value) == 0; \/\/ monitor | stack-locked?\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      return !UseObjectMonitorTable && lockbits == monitor_value;\n+    }\n+    \/\/ monitor (0b10) | stack-locked (0b00)?\n+    return (lockbits & unlocked_value) == 0;\n@@ -226,0 +230,1 @@\n+    assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use markWord for monitors\");\n@@ -230,0 +235,4 @@\n+  markWord set_has_monitor() const {\n+    return markWord((value() & ~lock_mask_in_place) | monitor_value);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  Label _slow_path;\n@@ -114,0 +115,1 @@\n+  Label& slow_path() { return _slow_path; }\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3170,1 +3170,1 @@\n-                                              StubRoutines::jfr_return_lease(),\n+                                              SharedRuntime::jfr_return_lease(),\n@@ -3369,1 +3369,1 @@\n-                                                  StubRoutines::jfr_write_checkpoint(),\n+                                                  SharedRuntime::jfr_write_checkpoint(),\n@@ -4607,7 +4607,8 @@\n-  \/\/ Test the header to see if it is safe to read w.r.t. locking.\n-  Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n-  Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n-    Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n-    Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n+  if (!UseObjectMonitorTable) {\n+    \/\/ Test the header to see if it is safe to read w.r.t. locking.\n+    Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n+    Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n+      Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n+      Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n@@ -4615,5 +4616,5 @@\n-    generate_slow_guard(test_monitor, slow_region);\n-  } else {\n-    Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n-    Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n-    Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n+      generate_slow_guard(test_monitor, slow_region);\n+    } else {\n+      Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n+      Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n+      Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n@@ -4621,1 +4622,2 @@\n-    generate_slow_guard(test_not_unlocked, slow_region);\n+      generate_slow_guard(test_not_unlocked, slow_region);\n+    }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1581,1 +1581,1 @@\n-  static bool is_divisor_counted_loop_phi(const Node* divisor, const Node* loop);\n+  static bool is_divisor_loop_phi(const Node* divisor, const Node* loop);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-  return is_divisor_counted_loop_phi(divisor, region) &&\n+  return is_divisor_loop_phi(divisor, region) &&\n@@ -302,2 +302,2 @@\n-bool PhaseIdealLoop::is_divisor_counted_loop_phi(const Node* divisor, const Node* loop) {\n-  return loop->is_BaseCountedLoop() && divisor->is_Phi() && divisor->in(0) == loop;\n+bool PhaseIdealLoop::is_divisor_loop_phi(const Node* divisor, const Node* loop) {\n+  return loop->is_Loop() && divisor->is_Phi() && divisor->in(0) == loop;\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-  Node*         _alloc_with_final;   \/\/ An allocation node with final field\n+  Node*         _alloc_with_final_or_stable; \/\/ An allocation node with final or @Stable field\n@@ -406,4 +406,4 @@\n-  Node*    alloc_with_final() const   { return _alloc_with_final; }\n-  void set_alloc_with_final(Node* n)  {\n-    assert((_alloc_with_final == nullptr) || (_alloc_with_final == n), \"different init objects?\");\n-    _alloc_with_final = n;\n+  Node*    alloc_with_final_or_stable() const   { return _alloc_with_final_or_stable; }\n+  void set_alloc_with_final_or_stable(Node* n)  {\n+    assert((_alloc_with_final_or_stable == nullptr) || (_alloc_with_final_or_stable == n), \"different init objects?\");\n+    _alloc_with_final_or_stable = n;\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -415,1 +415,1 @@\n-  _alloc_with_final = nullptr;\n+  _alloc_with_final_or_stable = nullptr;\n@@ -991,2 +991,2 @@\n-  \/\/ 1. The constructor wrote a final. The effects of all initializations\n-  \/\/    must be committed to memory before any code after the constructor\n+  \/\/ 1. The constructor wrote a final or a @Stable field. All these\n+  \/\/    initializations must be ordered before any code after the constructor\n@@ -1017,1 +1017,1 @@\n-       (wrote_final() ||\n+       (wrote_final() || wrote_stable() ||\n@@ -1020,0 +1020,1 @@\n+    Node* recorded_alloc = alloc_with_final_or_stable();\n@@ -1021,1 +1022,1 @@\n-                          alloc_with_final());\n+                          recorded_alloc);\n@@ -1026,2 +1027,2 @@\n-    if (DoEscapeAnalysis && alloc_with_final()) {\n-      AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_with_final());\n+    if (DoEscapeAnalysis && (recorded_alloc != nullptr)) {\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(recorded_alloc);\n@@ -1032,13 +1033,1 @@\n-      tty->print_cr(\" writes finals and needs a memory barrier\");\n-    }\n-  }\n-\n-  \/\/ Any method can write a @Stable field; insert memory barriers\n-  \/\/ after those also. Can't bind predecessor allocation node (if any)\n-  \/\/ with barrier because allocation doesn't always dominate\n-  \/\/ MemBarRelease.\n-  if (wrote_stable()) {\n-    _exits.insert_mem_bar(Op_MemBarRelease);\n-    if (PrintOpto && (Verbose || WizardMode)) {\n-      method()->print_name();\n-      tty->print_cr(\" writes @Stable and needs a memory barrier\");\n+      tty->print_cr(\" writes finals\/@Stable and needs a memory barrier\");\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -239,1 +239,4 @@\n-    \/\/ Note the presence of writes to final non-static fields, so that we\n+    \/\/ If the field is @Stable, we can be in any method, but we only care about\n+    \/\/ constructors at this point.\n+    \/\/\n+    \/\/ Note the presence of writes to final\/@Stable non-static fields, so that we\n@@ -242,3 +245,7 @@\n-    \/\/ Any method can write a @Stable field; insert memory barriers after those also.\n-    if (field->is_final()) {\n-      set_wrote_final(true);\n+    if (field->is_final() || field->is_stable()) {\n+      if (field->is_final()) {\n+        set_wrote_final(true);\n+      }\n+      if (field->is_stable()) {\n+        set_wrote_stable(true);\n+      }\n@@ -248,2 +255,1 @@\n-        \/\/ Can't bind stable with its allocation, only record allocation for final field.\n-        set_alloc_with_final(obj);\n+        set_alloc_with_final_or_stable(obj);\n@@ -252,3 +258,0 @@\n-    if (field->is_stable()) {\n-      set_wrote_stable(true);\n-    }\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1159,1 +1159,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1212,1 +1212,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1263,1 +1263,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1356,1 +1356,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1409,1 +1409,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1461,1 +1461,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1557,1 +1557,1 @@\n-  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \\\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1612,2 +1612,2 @@\n-  k->initialize(CHECK_0); \\\n-  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \\\n+  k->initialize(CHECK_(ResultType{})); \\\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1666,1 +1666,1 @@\n-  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \\\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_(ResultType{})); \\\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3406,1 +3406,1 @@\n-      THROW_HANDLE_0(h_exception);\n+      THROW_HANDLE_NULL(h_exception);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -1468,1 +1469,0 @@\n-  ObjectMonitor *mon = nullptr;\n@@ -1498,3 +1498,5 @@\n-  if (mark.has_monitor()) {\n-    mon = mark.monitor();\n-    assert(mon != nullptr, \"must have monitor\");\n+  ObjectMonitor* mon = mark.has_monitor()\n+      ? ObjectSynchronizer::read_monitor(current_thread, hobj(), mark)\n+      : nullptr;\n+\n+  if (mon != nullptr) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1819,0 +1819,4 @@\n+  if (UseObjectMonitorTable) {\n+    FLAG_SET_CMDLINE(UseObjectMonitorTable, false);\n+    warning(\"UseObjectMonitorTable not supported on this platform\");\n+  }\n@@ -1821,0 +1825,6 @@\n+  if (UseObjectMonitorTable && LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ ObjectMonitorTable requires lightweight locking.\n+    FLAG_SET_CMDLINE(UseObjectMonitorTable, false);\n+    warning(\"UseObjectMonitorTable requires LM_LIGHTWEIGHT\");\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-#include \"runtime\/basicLock.hpp\"\n+#include \"runtime\/basicLock.inline.hpp\"\n+#include \"runtime\/objectMonitor.hpp\"\n@@ -32,5 +33,12 @@\n-  markWord mark_word = displaced_header();\n-  if (mark_word.value() != 0) {\n-    \/\/ Print monitor info if there's an owning oop and it refers to this BasicLock.\n-    bool print_monitor_info = (owner != nullptr) && (owner->mark() == markWord::from_pointer((void*)this));\n-    mark_word.print_on(st, print_monitor_info);\n+  if (UseObjectMonitorTable) {\n+    ObjectMonitor* mon = object_monitor_cache();\n+    if (mon != nullptr) {\n+      mon->print_on(st);\n+    }\n+  } else if (LockingMode == LM_LEGACY) {\n+    markWord mark_word = displaced_header();\n+    if (mark_word.value() != 0) {\n+      \/\/ Print monitor info if there's an owning oop and it refers to this BasicLock.\n+      bool print_monitor_info = (owner != nullptr) && (owner->mark() == markWord::from_pointer((void*)this));\n+      mark_word.print_on(st, print_monitor_info);\n+    }\n@@ -85,0 +93,5 @@\n+  } else if (UseObjectMonitorTable) {\n+    \/\/ Preserve the ObjectMonitor*, the cache is cleared when a box is reused\n+    \/\/ and only read while the lock is held, so no stale ObjectMonitor* is\n+    \/\/ encountered.\n+    dest->set_object_monitor_cache(object_monitor_cache());\n@@ -88,1 +101,1 @@\n-    dest->set_displaced_header(markWord(badDispHeaderDeopt));\n+    dest->set_bad_metadata_deopt();\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -37,0 +38,3 @@\n+  \/\/ * For LM_MONITOR\n+  \/\/ Unused.\n+  \/\/ * For LM_LEGACY\n@@ -39,1 +43,9 @@\n-  volatile markWord _displaced_header;\n+  \/\/ * For LM_LIGHTWEIGHT\n+  \/\/ Used as a cache of the ObjectMonitor* used when locking. Must either\n+  \/\/ be nullptr or the ObjectMonitor* used when locking.\n+  volatile uintptr_t _metadata;\n+\n+  uintptr_t get_metadata() const { return Atomic::load(&_metadata); }\n+  void set_metadata(uintptr_t value) { Atomic::store(&_metadata, value); }\n+  static int metadata_offset_in_bytes() { return (int)offset_of(BasicLock, _metadata); }\n+\n@@ -41,3 +53,2 @@\n-  markWord displaced_header() const {\n-    return Atomic::load(&_displaced_header);\n-  }\n+  \/\/ LM_MONITOR\n+  void set_bad_metadata_deopt() { set_metadata(badDispHeaderDeopt); }\n@@ -45,3 +56,10 @@\n-  void set_displaced_header(markWord header) {\n-    Atomic::store(&_displaced_header, header);\n-  }\n+  \/\/ LM_LEGACY\n+  inline markWord displaced_header() const;\n+  inline void set_displaced_header(markWord header);\n+  static int displaced_header_offset_in_bytes() { return metadata_offset_in_bytes(); }\n+\n+  \/\/ LM_LIGHTWEIGHT\n+  inline ObjectMonitor* object_monitor_cache() const;\n+  inline void clear_object_monitor_cache();\n+  inline void set_object_monitor_cache(ObjectMonitor* mon);\n+  static int object_monitor_cache_offset_in_bytes() { return metadata_offset_in_bytes(); }\n@@ -53,2 +71,0 @@\n-\n-  static int displaced_header_offset_in_bytes() { return (int)offset_of(BasicLock, _displaced_header); }\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_BASICLOCK_INLINE_HPP\n+#define SHARE_RUNTIME_BASICLOCK_INLINE_HPP\n+\n+#include \"runtime\/basicLock.hpp\"\n+\n+inline markWord BasicLock::displaced_header() const {\n+  assert(LockingMode == LM_LEGACY, \"must be\");\n+  return markWord(get_metadata());\n+}\n+\n+inline void BasicLock::set_displaced_header(markWord header) {\n+  assert(LockingMode == LM_LEGACY, \"must be\");\n+  Atomic::store(&_metadata, header.value());\n+}\n+\n+inline ObjectMonitor* BasicLock::object_monitor_cache() const {\n+  assert(UseObjectMonitorTable, \"must be\");\n+#if defined(X86) || defined(AARCH64) || defined(RISCV64)\n+  return reinterpret_cast<ObjectMonitor*>(get_metadata());\n+#else\n+  \/\/ Other platforms do not make use of the cache yet,\n+  \/\/ and are not as careful with maintaining the invariant\n+  \/\/ that the metadata either is nullptr or ObjectMonitor*.\n+  return nullptr;\n+#endif\n+}\n+\n+inline void BasicLock::clear_object_monitor_cache() {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  set_metadata(0);\n+}\n+\n+inline void BasicLock::set_object_monitor_cache(ObjectMonitor* mon) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  set_metadata(reinterpret_cast<uintptr_t>(mon));\n+}\n+\n+#endif \/\/ SHARE_RUNTIME_BASICLOCK_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -78,0 +79,2 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/lockStack.inline.hpp\"\n@@ -87,1 +90,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -1637,1 +1640,11 @@\n-              mon_info->lock()->set_displaced_header(markWord::unused_mark());\n+              if (LockingMode == LM_LEGACY) {\n+                mon_info->lock()->set_displaced_header(markWord::unused_mark());\n+              } else if (UseObjectMonitorTable) {\n+                mon_info->lock()->clear_object_monitor_cache();\n+              }\n+#ifdef ASSERT\n+              else {\n+                assert(LockingMode == LM_MONITOR || !UseObjectMonitorTable, \"must be\");\n+                mon_info->lock()->set_bad_metadata_deopt();\n+              }\n+#endif\n@@ -1643,0 +1656,1 @@\n+        BasicLock* lock = mon_info->lock();\n@@ -1645,3 +1659,7 @@\n-          \/\/ Inflate the locks instead. Enter then inflate to avoid races with\n-          \/\/ deflation.\n-          ObjectSynchronizer::enter_for(obj, nullptr, deoptee_thread);\n+          \/\/ Entering may create an invalid lock stack. Inflate the lock if it\n+          \/\/ was fast_locked to restore the valid lock stack.\n+          ObjectSynchronizer::enter_for(obj, lock, deoptee_thread);\n+          if (deoptee_thread->lock_stack().contains(obj())) {\n+            LightweightSynchronizer::inflate_fast_locked_object(obj(), ObjectSynchronizer::InflateCause::inflate_cause_vm_internal,\n+                                                                deoptee_thread, thread);\n+          }\n@@ -1649,2 +1667,3 @@\n-          ObjectMonitor* mon = ObjectSynchronizer::inflate_for(deoptee_thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n-          assert(mon->owner() == deoptee_thread, \"must be\");\n+          assert(obj->mark().has_monitor(), \"must be\");\n+          assert(!deoptee_thread->lock_stack().contains(obj()), \"must be\");\n+          assert(ObjectSynchronizer::read_monitor(thread, obj(), obj->mark())->owner() == deoptee_thread, \"must be\");\n@@ -1652,1 +1671,0 @@\n-          BasicLock* lock = mon_info->lock();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1959,0 +1959,11 @@\n+  product(bool, UseObjectMonitorTable, false, DIAGNOSTIC,                   \\\n+          \"With Lightweight Locking mode, use a table to record inflated \"  \\\n+          \"monitors rather than the first word of the object.\")             \\\n+                                                                            \\\n+  product(int, LightweightFastLockingSpins, 13, DIAGNOSTIC,                 \\\n+          \"Specifies the number of times lightweight fast locking will \"    \\\n+          \"attempt to CAS the markWord before inflating. Between each \"     \\\n+          \"CAS it will spin for exponentially more time, resulting in \"     \\\n+          \"a total number of spins on the order of O(2^value)\")             \\\n+          range(1, 30)                                                      \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+  \/\/ stub routines in initial blob are referenced by later generated code\n@@ -130,0 +131,2 @@\n+  \/\/ stack overflow exception blob is referenced by the interpreter\n+  SharedRuntime::generate_initial_stubs();\n@@ -147,0 +150,3 @@\n+#if INCLUDE_JFR\n+  SharedRuntime::generate_jfr_stubs();\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,8 +360,0 @@\n-  \/\/ Since the call stub sets up like the interpreter we call the from_interpreted_entry\n-  \/\/ so we can go compiled via a i2c. Otherwise initial entry method will always\n-  \/\/ run interpreted.\n-  address entry_point = method->from_interpreted_entry();\n-  if (JvmtiExport::can_post_interpreter_events() && thread->is_interp_only_mode()) {\n-    entry_point = method->interpreter_entry();\n-  }\n-\n@@ -401,0 +393,12 @@\n+\n+      address entry_point;\n+      {\n+        \/\/ The enter_interp_only_mode use handshake to set interp_only mode\n+        \/\/ so no safepoint should be allowed between is_interp_only_mode() and call\n+        NoSafepointVerifier nsv;\n+        if (JvmtiExport::can_post_interpreter_events() && thread->is_interp_only_mode()) {\n+          entry_point = method->interpreter_entry();\n+        } else {\n+          \/\/ Since the call stub sets up like the interpreter we call the from_interpreted_entry\n+          \/\/ so we can go compiled via a i2c.\n+          entry_point = method->from_interpreted_entry();\n@@ -402,10 +406,13 @@\n-      \/\/ Gets the alternative target (if any) that should be called\n-      Handle alternative_target = args->alternative_target();\n-      if (!alternative_target.is_null()) {\n-        \/\/ Must extract verified entry point from HotSpotNmethod after VM to Java\n-        \/\/ transition in JavaCallWrapper constructor so that it is safe with\n-        \/\/ respect to nmethod sweeping.\n-        address verified_entry_point = (address) HotSpotJVMCI::InstalledCode::entryPoint(nullptr, alternative_target());\n-        if (verified_entry_point != nullptr) {\n-          thread->set_jvmci_alternate_call_target(verified_entry_point);\n-          entry_point = method->adapter()->get_i2c_entry();\n+          \/\/ Gets the alternative target (if any) that should be called\n+          Handle alternative_target = args->alternative_target();\n+          if (!alternative_target.is_null()) {\n+            \/\/ Must extract verified entry point from HotSpotNmethod after VM to Java\n+            \/\/ transition in JavaCallWrapper constructor so that it is safe with\n+            \/\/ respect to nmethod sweeping.\n+            address verified_entry_point = (address) HotSpotJVMCI::InstalledCode::entryPoint(nullptr, alternative_target());\n+            if (verified_entry_point != nullptr) {\n+              thread->set_jvmci_alternate_call_target(verified_entry_point);\n+              entry_point = method->adapter()->get_i2c_entry();\n+            }\n+          }\n+#endif\n@@ -414,1 +421,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -507,1 +507,2 @@\n-  _lock_stack(this) {\n+  _lock_stack(this),\n+  _om_cache(this) {\n@@ -806,0 +807,2 @@\n+  om_clear_monitor_cache();\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+class ObjectMonitor;\n@@ -1168,0 +1169,1 @@\n+  OMCache _om_cache;\n@@ -1179,0 +1181,7 @@\n+  static ByteSize om_cache_offset()        { return byte_offset_of(JavaThread, _om_cache); }\n+  static ByteSize om_cache_oops_offset()   { return om_cache_offset() + OMCache::entries_offset(); }\n+\n+  void om_set_monitor_cache(ObjectMonitor* monitor);\n+  void om_clear_monitor_cache();\n+  ObjectMonitor* om_get_from_monitor_cache(oop obj);\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/lockStack.inline.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -242,0 +244,21 @@\n+inline void JavaThread::om_set_monitor_cache(ObjectMonitor* monitor) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  assert(monitor != nullptr, \"use om_clear_monitor_cache to clear\");\n+  assert(this == current() || monitor->owner_raw() == this, \"only add owned monitors for other threads\");\n+  assert(this == current() || is_obj_deopt_suspend(), \"thread must not run concurrently\");\n+\n+  _om_cache.set_monitor(monitor);\n+}\n+\n+inline void JavaThread::om_clear_monitor_cache() {\n+  if (UseObjectMonitorTable) {\n+    _om_cache.clear();\n+  }\n+}\n+\n+inline ObjectMonitor* JavaThread::om_get_from_monitor_cache(oop obj) {\n+  assert(obj != nullptr, \"do not look for null objects\");\n+  assert(this == current(), \"only get own thread locals\");\n+  return _om_cache.get_monitor(obj);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,1223 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"jfrfiles\/jfrEventClasses.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"nmt\/memflags.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/basicLock.inline.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/lockStack.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/objectMonitor.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/perfData.inline.hpp\"\n+#include \"runtime\/safepointMechanism.inline.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n+#include \"runtime\/timerTrace.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n+#include \"utilities\/concurrentHashTable.inline.hpp\"\n+#include \"utilities\/concurrentHashTableTasks.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ ConcurrentHashTable storing links from objects to ObjectMonitors\n+class ObjectMonitorTable : AllStatic {\n+  struct Config {\n+    using Value = ObjectMonitor*;\n+    static uintx get_hash(Value const& value, bool* is_dead) {\n+      return (uintx)value->hash();\n+    }\n+    static void* allocate_node(void* context, size_t size, Value const& value) {\n+      ObjectMonitorTable::inc_items_count();\n+      return AllocateHeap(size, MEMFLAGS::mtObjectMonitor);\n+    };\n+    static void free_node(void* context, void* memory, Value const& value) {\n+      ObjectMonitorTable::dec_items_count();\n+      FreeHeap(memory);\n+    }\n+  };\n+  using ConcurrentTable = ConcurrentHashTable<Config, MEMFLAGS::mtObjectMonitor>;\n+\n+  static ConcurrentTable* _table;\n+  static volatile size_t _items_count;\n+  static size_t _table_size;\n+  static volatile bool _resize;\n+\n+  class Lookup : public StackObj {\n+    oop _obj;\n+\n+   public:\n+    explicit Lookup(oop obj) : _obj(obj) {}\n+\n+    uintx get_hash() const {\n+      uintx hash = _obj->mark().hash();\n+      assert(hash != 0, \"should have a hash\");\n+      return hash;\n+    }\n+\n+    bool equals(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return (*value)->object_refers_to(_obj);\n+    }\n+\n+    bool is_dead(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return false;\n+    }\n+  };\n+\n+  class LookupMonitor : public StackObj {\n+    ObjectMonitor* _monitor;\n+\n+   public:\n+    explicit LookupMonitor(ObjectMonitor* monitor) : _monitor(monitor) {}\n+\n+    uintx get_hash() const {\n+      return _monitor->hash();\n+    }\n+\n+    bool equals(ObjectMonitor** value) {\n+      return (*value) == _monitor;\n+    }\n+\n+    bool is_dead(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return (*value)->object_is_dead();\n+    }\n+  };\n+\n+  static void inc_items_count() {\n+    Atomic::inc(&_items_count);\n+  }\n+\n+  static void dec_items_count() {\n+    Atomic::dec(&_items_count);\n+  }\n+\n+  static double get_load_factor() {\n+    return (double)_items_count \/ (double)_table_size;\n+  }\n+\n+  static size_t table_size(Thread* current = Thread::current()) {\n+    return ((size_t)1) << _table->get_size_log2(current);\n+  }\n+\n+  static size_t max_log_size() {\n+    \/\/ TODO[OMTable]: Evaluate the max size.\n+    \/\/ TODO[OMTable]: Need to fix init order to use Universe::heap()->max_capacity();\n+    \/\/                Using MaxHeapSize directly this early may be wrong, and there\n+    \/\/                are definitely rounding errors (alignment).\n+    const size_t max_capacity = MaxHeapSize;\n+    const size_t min_object_size = CollectedHeap::min_dummy_object_size() * HeapWordSize;\n+    const size_t max_objects = max_capacity \/ MAX2(MinObjAlignmentInBytes, checked_cast<int>(min_object_size));\n+    const size_t log_max_objects = log2i_graceful(max_objects);\n+\n+    return MAX2(MIN2<size_t>(SIZE_BIG_LOG2, log_max_objects), min_log_size());\n+  }\n+\n+  static size_t min_log_size() {\n+    \/\/ ~= log(AvgMonitorsPerThreadEstimate default)\n+    return 10;\n+  }\n+\n+  template<typename V>\n+  static size_t clamp_log_size(V log_size) {\n+    return MAX2(MIN2(log_size, checked_cast<V>(max_log_size())), checked_cast<V>(min_log_size()));\n+  }\n+\n+  static size_t initial_log_size() {\n+    const size_t estimate = log2i(MAX2(os::processor_count(), 1)) + log2i(MAX2(AvgMonitorsPerThreadEstimate, size_t(1)));\n+    return clamp_log_size(estimate);\n+  }\n+\n+  static size_t grow_hint () {\n+    return ConcurrentTable::DEFAULT_GROW_HINT;\n+  }\n+\n+ public:\n+  static void create() {\n+    _table = new ConcurrentTable(initial_log_size(), max_log_size(), grow_hint());\n+    _items_count = 0;\n+    _table_size = table_size();\n+    _resize = false;\n+  }\n+\n+  static void verify_monitor_get_result(oop obj, ObjectMonitor* monitor) {\n+#ifdef ASSERT\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      bool has_monitor = obj->mark().has_monitor();\n+      assert(has_monitor == (monitor != nullptr),\n+          \"Inconsistency between markWord and ObjectMonitorTable has_monitor: %s monitor: \" PTR_FORMAT,\n+          BOOL_TO_STR(has_monitor), p2i(monitor));\n+    }\n+#endif\n+  }\n+\n+  static ObjectMonitor* monitor_get(Thread* current, oop obj) {\n+    ObjectMonitor* result = nullptr;\n+    Lookup lookup_f(obj);\n+    auto found_f = [&](ObjectMonitor** found) {\n+      assert((*found)->object_peek() == obj, \"must be\");\n+      result = *found;\n+    };\n+    _table->get(current, lookup_f, found_f);\n+    verify_monitor_get_result(obj, result);\n+    return result;\n+  }\n+\n+  static void try_notify_grow() {\n+    if (!_table->is_max_size_reached() && !Atomic::load(&_resize)) {\n+      Atomic::store(&_resize, true);\n+      if (Service_lock->try_lock()) {\n+        Service_lock->notify();\n+        Service_lock->unlock();\n+      }\n+    }\n+  }\n+\n+  static bool should_shrink() {\n+    \/\/ Not implemented;\n+    return false;\n+  }\n+\n+  static constexpr double GROW_LOAD_FACTOR = 0.75;\n+\n+  static bool should_grow() {\n+    return get_load_factor() > GROW_LOAD_FACTOR && !_table->is_max_size_reached();\n+  }\n+\n+  static bool should_resize() {\n+    return should_grow() || should_shrink() || Atomic::load(&_resize);\n+  }\n+\n+  template<typename Task, typename... Args>\n+  static bool run_task(JavaThread* current, Task& task, const char* task_name, Args&... args) {\n+    if (task.prepare(current)) {\n+      log_trace(monitortable)(\"Started to %s\", task_name);\n+      TraceTime timer(task_name, TRACETIME_LOG(Debug, monitortable, perf));\n+      while (task.do_task(current, args...)) {\n+        task.pause(current);\n+        {\n+          ThreadBlockInVM tbivm(current);\n+        }\n+        task.cont(current);\n+      }\n+      task.done(current);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  static bool grow(JavaThread* current) {\n+    ConcurrentTable::GrowTask grow_task(_table);\n+    if (run_task(current, grow_task, \"Grow\")) {\n+      _table_size = table_size(current);\n+      log_info(monitortable)(\"Grown to size: %zu\", _table_size);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  static bool clean(JavaThread* current) {\n+    ConcurrentTable::BulkDeleteTask clean_task(_table);\n+    auto is_dead = [&](ObjectMonitor** monitor) {\n+      return (*monitor)->object_is_dead();\n+    };\n+    auto do_nothing = [&](ObjectMonitor** monitor) {};\n+    NativeHeapTrimmer::SuspendMark sm(\"ObjectMonitorTable\");\n+    return run_task(current, clean_task, \"Clean\", is_dead, do_nothing);\n+  }\n+\n+  static bool resize(JavaThread* current) {\n+    LogTarget(Info, monitortable) lt;\n+    bool success = false;\n+\n+    if (should_grow()) {\n+      lt.print(\"Start growing with load factor %f\", get_load_factor());\n+      success = grow(current);\n+    } else {\n+      if (!_table->is_max_size_reached() && Atomic::load(&_resize)) {\n+        lt.print(\"WARNING: Getting resize hints with load factor %f\", get_load_factor());\n+      }\n+      lt.print(\"Start cleaning with load factor %f\", get_load_factor());\n+      success = clean(current);\n+    }\n+\n+    Atomic::store(&_resize, false);\n+\n+    return success;\n+  }\n+\n+  static ObjectMonitor* monitor_put_get(Thread* current, ObjectMonitor* monitor, oop obj) {\n+    \/\/ Enter the monitor into the concurrent hashtable.\n+    ObjectMonitor* result = monitor;\n+    Lookup lookup_f(obj);\n+    auto found_f = [&](ObjectMonitor** found) {\n+      assert((*found)->object_peek() == obj, \"must be\");\n+      result = *found;\n+    };\n+    bool grow;\n+    _table->insert_get(current, lookup_f, monitor, found_f, &grow);\n+    verify_monitor_get_result(obj, result);\n+    if (grow) {\n+      try_notify_grow();\n+    }\n+    return result;\n+  }\n+\n+  static bool remove_monitor_entry(Thread* current, ObjectMonitor* monitor) {\n+    LookupMonitor lookup_f(monitor);\n+    return _table->remove(current, lookup_f);\n+  }\n+\n+  static bool contains_monitor(Thread* current, ObjectMonitor* monitor) {\n+    LookupMonitor lookup_f(monitor);\n+    bool result = false;\n+    auto found_f = [&](ObjectMonitor** found) {\n+      result = true;\n+    };\n+    _table->get(current, lookup_f, found_f);\n+    return result;\n+  }\n+\n+  static void print_on(outputStream* st) {\n+    auto printer = [&] (ObjectMonitor** entry) {\n+       ObjectMonitor* om = *entry;\n+       oop obj = om->object_peek();\n+       st->print(\"monitor=\" PTR_FORMAT \", \", p2i(om));\n+       st->print(\"object=\" PTR_FORMAT, p2i(obj));\n+       assert(obj->mark().hash() == om->hash(), \"hash must match\");\n+       st->cr();\n+       return true;\n+    };\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      _table->do_safepoint_scan(printer);\n+    } else {\n+      _table->do_scan(Thread::current(), printer);\n+    }\n+  }\n+};\n+\n+ObjectMonitorTable::ConcurrentTable* ObjectMonitorTable::_table = nullptr;\n+volatile size_t ObjectMonitorTable::_items_count = 0;\n+size_t ObjectMonitorTable::_table_size = 0;\n+volatile bool ObjectMonitorTable::_resize = false;\n+\n+ObjectMonitor* LightweightSynchronizer::get_or_insert_monitor_from_table(oop object, JavaThread* current, bool* inserted) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+\n+  ObjectMonitor* monitor = get_monitor_from_table(current, object);\n+  if (monitor != nullptr) {\n+    *inserted = false;\n+    return monitor;\n+  }\n+\n+  ObjectMonitor* alloced_monitor = new ObjectMonitor(object);\n+  alloced_monitor->set_owner_anonymous();\n+\n+  \/\/ Try insert monitor\n+  monitor = add_monitor(current, alloced_monitor, object);\n+\n+  *inserted = alloced_monitor == monitor;\n+  if (!*inserted) {\n+    delete alloced_monitor;\n+  }\n+\n+  return monitor;\n+}\n+\n+static void log_inflate(Thread* current, oop object, ObjectSynchronizer::InflateCause cause) {\n+  if (log_is_enabled(Trace, monitorinflation)) {\n+    ResourceMark rm(current);\n+    log_trace(monitorinflation)(\"inflate: object=\" INTPTR_FORMAT \", mark=\"\n+                                INTPTR_FORMAT \", type='%s' cause=%s\", p2i(object),\n+                                object->mark().value(), object->klass()->external_name(),\n+                                ObjectSynchronizer::inflate_cause_name(cause));\n+  }\n+}\n+\n+static void post_monitor_inflate_event(EventJavaMonitorInflate* event,\n+                                       const oop obj,\n+                                       ObjectSynchronizer::InflateCause cause) {\n+  assert(event != nullptr, \"invariant\");\n+  event->set_monitorClass(obj->klass());\n+  event->set_address((uintptr_t)(void*)obj);\n+  event->set_cause((u1)cause);\n+  event->commit();\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::get_or_insert_monitor(oop object, JavaThread* current, ObjectSynchronizer::InflateCause cause) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+\n+  EventJavaMonitorInflate event;\n+\n+  bool inserted;\n+  ObjectMonitor* monitor = get_or_insert_monitor_from_table(object, current, &inserted);\n+\n+  if (inserted) {\n+    \/\/ Hopefully the performance counters are allocated on distinct\n+    \/\/ cache lines to avoid false sharing on MP systems ...\n+    OM_PERFDATA_OP(Inflations, inc());\n+    log_inflate(current, object, cause);\n+    if (event.should_commit()) {\n+      post_monitor_inflate_event(&event, object, cause);\n+    }\n+\n+    \/\/ The monitor has an anonymous owner so it is safe from async deflation.\n+    ObjectSynchronizer::_in_use_list.add(monitor);\n+  }\n+\n+  return monitor;\n+}\n+\n+\/\/ Add the hashcode to the monitor to match the object and put it in the hashtable.\n+ObjectMonitor* LightweightSynchronizer::add_monitor(JavaThread* current, ObjectMonitor* monitor, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  assert(obj == monitor->object(), \"must be\");\n+\n+  intptr_t hash = obj->mark().hash();\n+  assert(hash != 0, \"must be set when claiming the object monitor\");\n+  monitor->set_hash(hash);\n+\n+  return ObjectMonitorTable::monitor_put_get(current, monitor, obj);\n+}\n+\n+bool LightweightSynchronizer::remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  assert(monitor->object_peek() == obj, \"must be, cleared objects are removed by is_dead\");\n+\n+  return ObjectMonitorTable::remove_monitor_entry(current, monitor);\n+}\n+\n+void LightweightSynchronizer::deflate_mark_word(oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+\n+  markWord mark = obj->mark_acquire();\n+  assert(!mark.has_no_hash(), \"obj with inflated monitor must have had a hash\");\n+\n+  while (mark.has_monitor()) {\n+    const markWord new_mark = mark.clear_lock_bits().set_unlocked();\n+    mark = obj->cas_set_mark(new_mark, mark);\n+  }\n+}\n+\n+void LightweightSynchronizer::initialize() {\n+  if (!UseObjectMonitorTable) {\n+    return;\n+  }\n+  ObjectMonitorTable::create();\n+}\n+\n+bool LightweightSynchronizer::needs_resize() {\n+  if (!UseObjectMonitorTable) {\n+    return false;\n+  }\n+  return ObjectMonitorTable::should_resize();\n+}\n+\n+bool LightweightSynchronizer::resize_table(JavaThread* current) {\n+  if (!UseObjectMonitorTable) {\n+    return true;\n+  }\n+  return ObjectMonitorTable::resize(current);\n+}\n+\n+class LightweightSynchronizer::LockStackInflateContendedLocks : private OopClosure {\n+ private:\n+  oop _contended_oops[LockStack::CAPACITY];\n+  int _length;\n+\n+  void do_oop(oop* o) final {\n+    oop obj = *o;\n+    if (obj->mark_acquire().has_monitor()) {\n+      if (_length > 0 && _contended_oops[_length - 1] == obj) {\n+        \/\/ Recursive\n+        return;\n+      }\n+      _contended_oops[_length++] = obj;\n+    }\n+  }\n+\n+  void do_oop(narrowOop* o) final {\n+    ShouldNotReachHere();\n+  }\n+\n+ public:\n+  LockStackInflateContendedLocks() :\n+    _contended_oops(),\n+    _length(0) {};\n+\n+  void inflate(JavaThread* current) {\n+    assert(current == JavaThread::current(), \"must be\");\n+    current->lock_stack().oops_do(this);\n+    for (int i = 0; i < _length; i++) {\n+      LightweightSynchronizer::\n+        inflate_fast_locked_object(_contended_oops[i], ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n+    }\n+  }\n+};\n+\n+void LightweightSynchronizer::ensure_lock_stack_space(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+  LockStack& lock_stack = current->lock_stack();\n+\n+  \/\/ Make room on lock_stack\n+  if (lock_stack.is_full()) {\n+    \/\/ Inflate contended objects\n+    LockStackInflateContendedLocks().inflate(current);\n+    if (lock_stack.is_full()) {\n+      \/\/ Inflate the oldest object\n+      inflate_fast_locked_object(lock_stack.bottom(), ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n+    }\n+  }\n+}\n+\n+class LightweightSynchronizer::CacheSetter : StackObj {\n+  JavaThread* const _thread;\n+  BasicLock* const _lock;\n+  ObjectMonitor* _monitor;\n+\n+  NONCOPYABLE(CacheSetter);\n+\n+ public:\n+  CacheSetter(JavaThread* thread, BasicLock* lock) :\n+    _thread(thread),\n+    _lock(lock),\n+    _monitor(nullptr) {}\n+\n+  ~CacheSetter() {\n+    \/\/ Only use the cache if using the table.\n+    if (UseObjectMonitorTable) {\n+      if (_monitor != nullptr) {\n+        _thread->om_set_monitor_cache(_monitor);\n+        _lock->set_object_monitor_cache(_monitor);\n+      } else {\n+        _lock->clear_object_monitor_cache();\n+      }\n+    }\n+  }\n+\n+  void set_monitor(ObjectMonitor* monitor) {\n+    assert(_monitor == nullptr, \"only set once\");\n+    _monitor = monitor;\n+  }\n+\n+};\n+\n+class LightweightSynchronizer::VerifyThreadState {\n+  bool _no_safepoint;\n+\n+ public:\n+  VerifyThreadState(JavaThread* locking_thread, JavaThread* current) : _no_safepoint(locking_thread != current) {\n+    assert(current == Thread::current(), \"must be\");\n+    assert(locking_thread == current || locking_thread->is_obj_deopt_suspend(), \"locking_thread may not run concurrently\");\n+    if (_no_safepoint) {\n+      DEBUG_ONLY(JavaThread::current()->inc_no_safepoint_count();)\n+    }\n+  }\n+  ~VerifyThreadState() {\n+    if (_no_safepoint){\n+      DEBUG_ONLY(JavaThread::current()->dec_no_safepoint_count();)\n+    }\n+  }\n+};\n+\n+inline bool LightweightSynchronizer::fast_lock_try_enter(oop obj, LockStack& lock_stack, JavaThread* current) {\n+  markWord mark = obj->mark();\n+  while (mark.is_unlocked()) {\n+    ensure_lock_stack_space(current);\n+    assert(!lock_stack.is_full(), \"must have made room on the lock stack\");\n+    assert(!lock_stack.contains(obj), \"thread must not already hold the lock\");\n+    \/\/ Try to swing into 'fast-locked' state.\n+    markWord locked_mark = mark.set_fast_locked();\n+    markWord old_mark = mark;\n+    mark = obj->cas_set_mark(locked_mark, old_mark);\n+    if (old_mark == mark) {\n+      \/\/ Successfully fast-locked, push object to lock-stack and return.\n+      lock_stack.push(obj);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool LightweightSynchronizer::fast_lock_spin_enter(oop obj, LockStack& lock_stack, JavaThread* current, bool observed_deflation) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  \/\/ Will spin with exponential backoff with an accumulative O(2^spin_limit) spins.\n+  const int log_spin_limit = os::is_MP() ? LightweightFastLockingSpins : 1;\n+  const int log_min_safepoint_check_interval = 10;\n+\n+  markWord mark = obj->mark();\n+  const auto should_spin = [&]() {\n+    if (!mark.has_monitor()) {\n+      \/\/ Spin while not inflated.\n+      return true;\n+    } else if (observed_deflation) {\n+      \/\/ Spin while monitor is being deflated.\n+      ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n+      return monitor == nullptr || monitor->is_being_async_deflated();\n+    }\n+    \/\/ Else stop spinning.\n+    return false;\n+  };\n+  \/\/ Always attempt to lock once even when safepoint synchronizing.\n+  bool should_process = false;\n+  for (int i = 0; should_spin() && !should_process && i < log_spin_limit; i++) {\n+    \/\/ Spin with exponential backoff.\n+    const int total_spin_count = 1 << i;\n+    const int inner_spin_count = MIN2(1 << log_min_safepoint_check_interval, total_spin_count);\n+    const int outer_spin_count = total_spin_count \/ inner_spin_count;\n+    for (int outer = 0; outer < outer_spin_count; outer++) {\n+      should_process = SafepointMechanism::should_process(current);\n+      if (should_process) {\n+        \/\/ Stop spinning for safepoint.\n+        break;\n+      }\n+      for (int inner = 1; inner < inner_spin_count; inner++) {\n+        SpinPause();\n+      }\n+    }\n+\n+    if (fast_lock_try_enter(obj, lock_stack, current)) return true;\n+  }\n+  return false;\n+}\n+\n+void LightweightSynchronizer::enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  JavaThread* current = JavaThread::current();\n+  VerifyThreadState vts(locking_thread, current);\n+\n+  if (obj->klass()->is_value_based()) {\n+    ObjectSynchronizer::handle_sync_on_value_based_class(obj, locking_thread);\n+  }\n+\n+  locking_thread->inc_held_monitor_count();\n+\n+  CacheSetter cache_setter(locking_thread, lock);\n+\n+  LockStack& lock_stack = locking_thread->lock_stack();\n+\n+  ObjectMonitor* monitor = nullptr;\n+  if (lock_stack.contains(obj())) {\n+    monitor = inflate_fast_locked_object(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n+    bool entered = monitor->enter_for(locking_thread);\n+    assert(entered, \"recursive ObjectMonitor::enter_for must succeed\");\n+  } else {\n+    \/\/ It is assumed that enter_for must enter on an object without contention.\n+    monitor = inflate_and_enter(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n+  }\n+\n+  assert(monitor != nullptr, \"LightweightSynchronizer::enter_for must succeed\");\n+  cache_setter.set_monitor(monitor);\n+}\n+\n+void LightweightSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  if (obj->klass()->is_value_based()) {\n+    ObjectSynchronizer::handle_sync_on_value_based_class(obj, current);\n+  }\n+\n+  current->inc_held_monitor_count();\n+\n+  CacheSetter cache_setter(current, lock);\n+\n+  \/\/ Used when deflation is observed. Progress here requires progress\n+  \/\/ from the deflator. After observing that the deflator is not\n+  \/\/ making progress (after two yields), switch to sleeping.\n+  SpinYield spin_yield(0, 2);\n+  bool observed_deflation = false;\n+\n+  LockStack& lock_stack = current->lock_stack();\n+\n+  if (!lock_stack.is_full() && lock_stack.try_recursive_enter(obj())) {\n+    \/\/ Recursively fast locked\n+    return;\n+  }\n+\n+  if (lock_stack.contains(obj())) {\n+    ObjectMonitor* monitor = inflate_fast_locked_object(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, current, current);\n+    bool entered = monitor->enter(current);\n+    assert(entered, \"recursive ObjectMonitor::enter must succeed\");\n+    cache_setter.set_monitor(monitor);\n+    return;\n+  }\n+\n+  while (true) {\n+    \/\/ Fast-locking does not use the 'lock' argument.\n+    \/\/ Fast-lock spinning to avoid inflating for short critical sections.\n+    \/\/ The goal is to only inflate when the extra cost of using ObjectMonitors\n+    \/\/ is worth it.\n+    \/\/ If deflation has been observed we also spin while deflation is ongoing.\n+    if (fast_lock_try_enter(obj(), lock_stack, current)) {\n+      return;\n+    } else if (UseObjectMonitorTable && fast_lock_spin_enter(obj(), lock_stack, current, observed_deflation)) {\n+      return;\n+    }\n+\n+    if (observed_deflation) {\n+      spin_yield.wait();\n+    }\n+\n+    ObjectMonitor* monitor = inflate_and_enter(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, current, current);\n+    if (monitor != nullptr) {\n+      cache_setter.set_monitor(monitor);\n+      return;\n+    }\n+\n+    \/\/ If inflate_and_enter returns nullptr it is because a deflated monitor\n+    \/\/ was encountered. Fallback to fast locking. The deflater is responsible\n+    \/\/ for clearing out the monitor and transitioning the markWord back to\n+    \/\/ fast locking.\n+    observed_deflation = true;\n+  }\n+}\n+\n+void LightweightSynchronizer::exit(oop object, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(current == Thread::current(), \"must be\");\n+\n+  markWord mark = object->mark();\n+  assert(!mark.is_unlocked(), \"must be\");\n+\n+  LockStack& lock_stack = current->lock_stack();\n+  if (mark.is_fast_locked()) {\n+    if (lock_stack.try_recursive_exit(object)) {\n+      \/\/ This is a recursive exit which succeeded\n+      return;\n+    }\n+    if (lock_stack.is_recursive(object)) {\n+      \/\/ Must inflate recursive locks if try_recursive_exit fails\n+      \/\/ This happens for un-structured unlocks, could potentially\n+      \/\/ fix try_recursive_exit to handle these.\n+      inflate_fast_locked_object(object, ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n+    }\n+  }\n+\n+  while (mark.is_fast_locked()) {\n+    markWord unlocked_mark = mark.set_unlocked();\n+    markWord old_mark = mark;\n+    mark = object->cas_set_mark(unlocked_mark, old_mark);\n+    if (old_mark == mark) {\n+      \/\/ CAS successful, remove from lock_stack\n+      size_t recursion = lock_stack.remove(object) - 1;\n+      assert(recursion == 0, \"Should not have unlocked here\");\n+      return;\n+    }\n+  }\n+\n+  assert(mark.has_monitor(), \"must be\");\n+  \/\/ The monitor exists\n+  ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, object, mark);\n+  if (monitor->is_owner_anonymous()) {\n+    assert(current->lock_stack().contains(object), \"current must have object on its lock stack\");\n+    monitor->set_owner_from_anonymous(current);\n+    monitor->set_recursions(current->lock_stack().remove(object) - 1);\n+  }\n+\n+  monitor->exit(current);\n+}\n+\n+\/\/ LightweightSynchronizer::inflate_locked_or_imse is used to to get an inflated\n+\/\/ ObjectMonitor* with LM_LIGHTWEIGHT. It is used from contexts which require\n+\/\/ an inflated ObjectMonitor* for a monitor, and expects to throw a\n+\/\/ java.lang.IllegalMonitorStateException if it is not held by the current\n+\/\/ thread. Such as notify\/wait and jni_exit. LM_LIGHTWEIGHT keeps it invariant\n+\/\/ that it only inflates if it is already locked by the current thread or the\n+\/\/ current thread is in the process of entering. To maintain this invariant we\n+\/\/ need to throw a java.lang.IllegalMonitorStateException before inflating if\n+\/\/ the current thread is not the owner.\n+\/\/ LightweightSynchronizer::inflate_locked_or_imse facilitates this.\n+ObjectMonitor* LightweightSynchronizer::inflate_locked_or_imse(oop obj, ObjectSynchronizer::InflateCause cause, TRAPS) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  JavaThread* current = THREAD;\n+\n+  for (;;) {\n+    markWord mark = obj->mark_acquire();\n+    if (mark.is_unlocked()) {\n+      \/\/ No lock, IMSE.\n+      THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n+                 \"current thread is not owner\", nullptr);\n+    }\n+\n+    if (mark.is_fast_locked()) {\n+      if (!current->lock_stack().contains(obj)) {\n+        \/\/ Fast locked by other thread, IMSE.\n+        THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n+                   \"current thread is not owner\", nullptr);\n+      } else {\n+        \/\/ Current thread owns the lock, must inflate\n+        return inflate_fast_locked_object(obj, cause, current, current);\n+      }\n+    }\n+\n+    assert(mark.has_monitor(), \"must be\");\n+    ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n+    if (monitor != nullptr) {\n+      if (monitor->is_owner_anonymous()) {\n+        LockStack& lock_stack = current->lock_stack();\n+        if (lock_stack.contains(obj)) {\n+          \/\/ Current thread owns the lock but someone else inflated it.\n+          \/\/ Fix owner and pop lock stack.\n+          monitor->set_owner_from_anonymous(current);\n+          monitor->set_recursions(lock_stack.remove(obj) - 1);\n+        } else {\n+          \/\/ Fast locked (and inflated) by other thread, or deflation in progress, IMSE.\n+          THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n+                     \"current thread is not owner\", nullptr);\n+        }\n+      }\n+      return monitor;\n+    }\n+  }\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* inflating_thread, Thread* current) {\n+\n+  \/\/ The JavaThread* inflating_thread parameter is only used by LM_LIGHTWEIGHT and requires\n+  \/\/ that the inflating_thread == Thread::current() or is suspended throughout the call by\n+  \/\/ some other mechanism.\n+  \/\/ Even with LM_LIGHTWEIGHT the thread might be nullptr when called from a non\n+  \/\/ JavaThread. (As may still be the case from FastHashCode). However it is only\n+  \/\/ important for the correctness of the LM_LIGHTWEIGHT algorithm that the thread\n+  \/\/ is set when called from ObjectSynchronizer::enter from the owning thread,\n+  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n+  EventJavaMonitorInflate event;\n+\n+  for (;;) {\n+    const markWord mark = object->mark_acquire();\n+\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  inflated     - Just return if using stack-locking.\n+    \/\/                   If using fast-locking and the ObjectMonitor owner\n+    \/\/                   is anonymous and the inflating_thread owns the\n+    \/\/                   object lock, then we make the inflating_thread\n+    \/\/                   the ObjectMonitor owner and remove the lock from\n+    \/\/                   the inflating_thread's lock stack.\n+    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  unlocked     - Aggressively inflate the object.\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      ObjectMonitor* inf = mark.monitor();\n+      markWord dmw = inf->header();\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+      if (inf->is_owner_anonymous() &&\n+          inflating_thread != nullptr && inflating_thread->lock_stack().contains(object)) {\n+        inf->set_owner_from_anonymous(inflating_thread);\n+        size_t removed = inflating_thread->lock_stack().remove(object);\n+        inf->set_recursions(removed - 1);\n+      }\n+      return inf;\n+    }\n+\n+    \/\/ CASE: fast-locked\n+    \/\/ Could be fast-locked either by the inflating_thread or by some other thread.\n+    \/\/\n+    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_\n+    \/\/ attempting to set the object's mark to the new ObjectMonitor. If\n+    \/\/ the inflating_thread owns the monitor, then we set the ObjectMonitor's\n+    \/\/ owner to the inflating_thread. Otherwise, we set the ObjectMonitor's owner\n+    \/\/ to anonymous. If we lose the race to set the object's mark to the\n+    \/\/ new ObjectMonitor, then we just delete it and loop around again.\n+    \/\/\n+    if (mark.is_fast_locked()) {\n+      ObjectMonitor* monitor = new ObjectMonitor(object);\n+      monitor->set_header(mark.set_unlocked());\n+      bool own = inflating_thread != nullptr && inflating_thread->lock_stack().contains(object);\n+      if (own) {\n+        \/\/ Owned by inflating_thread.\n+        monitor->set_owner_from(nullptr, inflating_thread);\n+      } else {\n+        \/\/ Owned by somebody else.\n+        monitor->set_owner_anonymous();\n+      }\n+      markWord monitor_mark = markWord::encode(monitor);\n+      markWord old_mark = object->cas_set_mark(monitor_mark, mark);\n+      if (old_mark == mark) {\n+        \/\/ Success! Return inflated monitor.\n+        if (own) {\n+          size_t removed = inflating_thread->lock_stack().remove(object);\n+          monitor->set_recursions(removed - 1);\n+        }\n+        \/\/ Once the ObjectMonitor is configured and object is associated\n+        \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+        ObjectSynchronizer::_in_use_list.add(monitor);\n+\n+        \/\/ Hopefully the performance counters are allocated on distinct\n+        \/\/ cache lines to avoid false sharing on MP systems ...\n+        OM_PERFDATA_OP(Inflations, inc());\n+        log_inflate(current, object, cause);\n+        if (event.should_commit()) {\n+          post_monitor_inflate_event(&event, object, cause);\n+        }\n+        return monitor;\n+      } else {\n+        delete monitor;\n+        continue;  \/\/ Interference -- just retry\n+      }\n+    }\n+\n+    \/\/ CASE: unlocked\n+    \/\/ TODO-FIXME: for entry we currently inflate and then try to CAS _owner.\n+    \/\/ If we know we're inflating for entry it's better to inflate by swinging a\n+    \/\/ pre-locked ObjectMonitor pointer into the object header.   A successful\n+    \/\/ CAS inflates the object *and* confers ownership to the inflating thread.\n+    \/\/ In the current implementation we use a 2-step mechanism where we CAS()\n+    \/\/ to inflate and then CAS() again to try to swing _owner from null to current.\n+    \/\/ An inflateTry() method that we could call from enter() would be useful.\n+\n+    assert(mark.is_unlocked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    ObjectMonitor* m = new ObjectMonitor(object);\n+    \/\/ prepare m for installation - set monitor to initial state\n+    m->set_header(mark);\n+\n+    if (object->cas_set_mark(markWord::encode(m), mark) != mark) {\n+      delete m;\n+      m = nullptr;\n+      continue;\n+      \/\/ interference - the markword changed - just retry.\n+      \/\/ The state-transitions are one-way, so there's no chance of\n+      \/\/ live-lock -- \"Inflated\" is an absorbing state.\n+    }\n+\n+    \/\/ Once the ObjectMonitor is configured and object is associated\n+    \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+    ObjectSynchronizer::_in_use_list.add(m);\n+\n+    \/\/ Hopefully the performance counters are allocated on distinct\n+    \/\/ cache lines to avoid false sharing on MP systems ...\n+    OM_PERFDATA_OP(Inflations, inc());\n+    log_inflate(current, object, cause);\n+    if (event.should_commit()) {\n+      post_monitor_inflate_event(&event, object, cause);\n+    }\n+    return m;\n+  }\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::inflate_fast_locked_object(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used for lightweight\");\n+  VerifyThreadState vts(locking_thread, current);\n+  assert(locking_thread->lock_stack().contains(object), \"locking_thread must have object on its lock stack\");\n+\n+  ObjectMonitor* monitor;\n+\n+  if (!UseObjectMonitorTable) {\n+    return inflate_into_object_header(object, cause, locking_thread, current);\n+  }\n+\n+  \/\/ Inflating requires a hash code\n+  ObjectSynchronizer::FastHashCode(current, object);\n+\n+  markWord mark = object->mark_acquire();\n+  assert(!mark.is_unlocked(), \"Cannot be unlocked\");\n+\n+  for (;;) {\n+    \/\/ Fetch the monitor from the table\n+    monitor = get_or_insert_monitor(object, current, cause);\n+\n+    \/\/ ObjectMonitors are always inserted as anonymously owned, this thread is\n+    \/\/ the current holder of the monitor. So unless the entry is stale and\n+    \/\/ contains a deflating monitor it must be anonymously owned.\n+    if (monitor->is_owner_anonymous()) {\n+      \/\/ The monitor must be anonymously owned if it was added\n+      assert(monitor == get_monitor_from_table(current, object), \"The monitor must be found\");\n+      \/\/ New fresh monitor\n+      break;\n+    }\n+\n+    \/\/ If the monitor was not anonymously owned then we got a deflating monitor\n+    \/\/ from the table. We need to let the deflator make progress and remove this\n+    \/\/ entry before we are allowed to add a new one.\n+    os::naked_yield();\n+    assert(monitor->is_being_async_deflated(), \"Should be the reason\");\n+  }\n+\n+  \/\/ Set the mark word; loop to handle concurrent updates to other parts of the mark word\n+  while (mark.is_fast_locked()) {\n+    mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n+  }\n+\n+  \/\/ Indicate that the monitor now has a known owner\n+  monitor->set_owner_from_anonymous(locking_thread);\n+\n+  \/\/ Remove the entry from the thread's lock stack\n+  monitor->set_recursions(locking_thread->lock_stack().remove(object) - 1);\n+\n+  if (locking_thread == current) {\n+    \/\/ Only change the thread local state of the current thread.\n+    locking_thread->om_set_monitor_cache(monitor);\n+  }\n+\n+  return monitor;\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::inflate_and_enter(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used for lightweight\");\n+  VerifyThreadState vts(locking_thread, current);\n+\n+  \/\/ Note: In some paths (deoptimization) the 'current' thread inflates and\n+  \/\/ enters the lock on behalf of the 'locking_thread' thread.\n+\n+  ObjectMonitor* monitor = nullptr;\n+\n+  if (!UseObjectMonitorTable) {\n+    \/\/ Do the old inflate and enter.\n+    monitor = inflate_into_object_header(object, cause, locking_thread, current);\n+\n+    bool entered;\n+    if (locking_thread == current) {\n+      entered = monitor->enter(locking_thread);\n+    } else {\n+      entered = monitor->enter_for(locking_thread);\n+    }\n+\n+    \/\/ enter returns false for deflation found.\n+    return entered ? monitor : nullptr;\n+  }\n+\n+  NoSafepointVerifier nsv;\n+\n+  \/\/ Lightweight monitors require that hash codes are installed first\n+  ObjectSynchronizer::FastHashCode(locking_thread, object);\n+\n+  \/\/ Try to get the monitor from the thread-local cache.\n+  \/\/ There's no need to use the cache if we are locking\n+  \/\/ on behalf of another thread.\n+  if (current == locking_thread) {\n+    monitor = current->om_get_from_monitor_cache(object);\n+  }\n+\n+  \/\/ Get or create the monitor\n+  if (monitor == nullptr) {\n+    monitor = get_or_insert_monitor(object, current, cause);\n+  }\n+\n+  if (monitor->try_enter(locking_thread)) {\n+    return monitor;\n+  }\n+\n+  \/\/ Holds is_being_async_deflated() stable throughout this function.\n+  ObjectMonitorContentionMark contention_mark(monitor);\n+\n+  \/\/\/ First handle the case where the monitor from the table is deflated\n+  if (monitor->is_being_async_deflated()) {\n+    \/\/ The MonitorDeflation thread is deflating the monitor. The locking thread\n+    \/\/ must spin until further progress has been made.\n+\n+    const markWord mark = object->mark_acquire();\n+\n+    if (mark.has_monitor()) {\n+      \/\/ Waiting on the deflation thread to remove the deflated monitor from the table.\n+      os::naked_yield();\n+\n+    } else if (mark.is_fast_locked()) {\n+      \/\/ Some other thread managed to fast-lock the lock, or this is a\n+      \/\/ recursive lock from the same thread; yield for the deflation\n+      \/\/ thread to remove the deflated monitor from the table.\n+      os::naked_yield();\n+\n+    } else {\n+      assert(mark.is_unlocked(), \"Implied\");\n+      \/\/ Retry immediately\n+    }\n+\n+    \/\/ Retry\n+    return nullptr;\n+  }\n+\n+  for (;;) {\n+    const markWord mark = object->mark_acquire();\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  inflated     - If the ObjectMonitor owner is anonymous\n+    \/\/                   and the locking_thread owns the object\n+    \/\/                   lock, then we make the locking_thread\n+    \/\/                   the ObjectMonitor owner and remove the\n+    \/\/                   lock from the locking_thread's lock stack.\n+    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  neutral      - Inflate the object. Successful CAS is locked\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      LockStack& lock_stack = locking_thread->lock_stack();\n+      if (monitor->is_owner_anonymous() && lock_stack.contains(object)) {\n+        \/\/ The lock is fast-locked by the locking thread,\n+        \/\/ convert it to a held monitor with a known owner.\n+        monitor->set_owner_from_anonymous(locking_thread);\n+        monitor->set_recursions(lock_stack.remove(object) - 1);\n+      }\n+\n+      break; \/\/ Success\n+    }\n+\n+    \/\/ CASE: fast-locked\n+    \/\/ Could be fast-locked either by locking_thread or by some other thread.\n+    \/\/\n+    if (mark.is_fast_locked()) {\n+      markWord old_mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n+      if (old_mark != mark) {\n+        \/\/ CAS failed\n+        continue;\n+      }\n+\n+      \/\/ Success! Return inflated monitor.\n+      LockStack& lock_stack = locking_thread->lock_stack();\n+      if (lock_stack.contains(object)) {\n+        \/\/ The lock is fast-locked by the locking thread,\n+        \/\/ convert it to a held monitor with a known owner.\n+        monitor->set_owner_from_anonymous(locking_thread);\n+        monitor->set_recursions(lock_stack.remove(object) - 1);\n+      }\n+\n+      break; \/\/ Success\n+    }\n+\n+    \/\/ CASE: neutral (unlocked)\n+\n+    \/\/ Catch if the object's header is not neutral (not locked and\n+    \/\/ not marked is what we care about here).\n+    assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    markWord old_mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n+    if (old_mark != mark) {\n+      \/\/ CAS failed\n+      continue;\n+    }\n+\n+    \/\/ Transitioned from unlocked to monitor means locking_thread owns the lock.\n+    monitor->set_owner_from_anonymous(locking_thread);\n+\n+    return monitor;\n+  }\n+\n+  if (current == locking_thread) {\n+    \/\/ One round of spinning\n+    if (monitor->spin_enter(locking_thread)) {\n+      return monitor;\n+    }\n+\n+    \/\/ Monitor is contended, take the time before entering to fix the lock stack.\n+    LockStackInflateContendedLocks().inflate(current);\n+  }\n+\n+  \/\/ enter can block for safepoints; clear the unhandled object oop\n+  PauseNoSafepointVerifier pnsv(&nsv);\n+  object = nullptr;\n+\n+  if (current == locking_thread) {\n+    monitor->enter_with_contention_mark(locking_thread, contention_mark);\n+  } else {\n+    monitor->enter_for_with_contention_mark(locking_thread, contention_mark);\n+  }\n+\n+  return monitor;\n+}\n+\n+void LightweightSynchronizer::deflate_monitor(Thread* current, oop obj, ObjectMonitor* monitor) {\n+  if (obj != nullptr) {\n+    deflate_mark_word(obj);\n+  }\n+  bool removed = remove_monitor(current, monitor, obj);\n+  if (obj != nullptr) {\n+    assert(removed, \"Should have removed the entry if obj was alive\");\n+  }\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::get_monitor_from_table(Thread* current, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  return ObjectMonitorTable::monitor_get(current, obj);\n+}\n+\n+bool LightweightSynchronizer::contains_monitor(Thread* current, ObjectMonitor* monitor) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  return ObjectMonitorTable::contains_monitor(current, monitor);\n+}\n+\n+bool LightweightSynchronizer::quick_enter(oop obj, BasicLock* lock, JavaThread* current) {\n+  assert(current->thread_state() == _thread_in_Java, \"must be\");\n+  assert(obj != nullptr, \"must be\");\n+  NoSafepointVerifier nsv;\n+\n+  \/\/ If quick_enter succeeds with entering, the cache should be in a valid initialized state.\n+  CacheSetter cache_setter(current, lock);\n+\n+  LockStack& lock_stack = current->lock_stack();\n+  if (lock_stack.is_full()) {\n+    \/\/ Always go into runtime if the lock stack is full.\n+    return false;\n+  }\n+\n+  const markWord mark = obj->mark();\n+\n+#ifndef _LP64\n+  \/\/ Only for 32bit which has limited support for fast locking outside the runtime.\n+  if (lock_stack.try_recursive_enter(obj)) {\n+    \/\/ Recursive lock successful.\n+    current->inc_held_monitor_count();\n+    return true;\n+  }\n+\n+  if (mark.is_unlocked()) {\n+    markWord locked_mark = mark.set_fast_locked();\n+    if (obj->cas_set_mark(locked_mark, mark) == mark) {\n+      \/\/ Successfully fast-locked, push object to lock-stack and return.\n+      lock_stack.push(obj);\n+      current->inc_held_monitor_count();\n+      return true;\n+    }\n+  }\n+#endif\n+\n+  if (mark.has_monitor()) {\n+    ObjectMonitor* const monitor = UseObjectMonitorTable ? current->om_get_from_monitor_cache(obj) :\n+                                                           ObjectSynchronizer::read_monitor(mark);\n+\n+    if (monitor == nullptr) {\n+      \/\/ Take the slow-path on a cache miss.\n+      return false;\n+    }\n+\n+    if (monitor->try_enter(current)) {\n+      \/\/ ObjectMonitor enter successful.\n+      cache_setter.set_monitor(monitor);\n+      current->inc_held_monitor_count();\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Slow-path.\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":1223,"deletions":0,"binary":false,"changes":1223,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_LIGHTWEIGHTSYNCHRONIZER_HPP\n+#define SHARE_RUNTIME_LIGHTWEIGHTSYNCHRONIZER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/objectMonitor.hpp\"\n+#include \"runtime\/synchronizer.hpp\"\n+\n+class ObjectMonitorTable;\n+\n+class LightweightSynchronizer : AllStatic {\n+ private:\n+  static ObjectMonitor* get_or_insert_monitor_from_table(oop object, JavaThread* current, bool* inserted);\n+  static ObjectMonitor* get_or_insert_monitor(oop object, JavaThread* current, ObjectSynchronizer::InflateCause cause);\n+\n+  static ObjectMonitor* add_monitor(JavaThread* current, ObjectMonitor* monitor, oop obj);\n+  static bool remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj);\n+\n+  static void deflate_mark_word(oop object);\n+\n+  static void ensure_lock_stack_space(JavaThread* current);\n+\n+  class CacheSetter;\n+  class LockStackInflateContendedLocks;\n+  class VerifyThreadState;\n+\n+ public:\n+  static void initialize();\n+\n+  static bool needs_resize();\n+  static bool resize_table(JavaThread* current);\n+\n+ private:\n+  static inline bool fast_lock_try_enter(oop obj, LockStack& lock_stack, JavaThread* current);\n+  static bool fast_lock_spin_enter(oop obj, LockStack& lock_stack, JavaThread* current, bool observed_deflation);\n+\n+ public:\n+  static void enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread);\n+  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n+  static void exit(oop object, JavaThread* current);\n+\n+  static ObjectMonitor* inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* inflating_thread, Thread* current);\n+  static ObjectMonitor* inflate_locked_or_imse(oop object, ObjectSynchronizer::InflateCause cause, TRAPS);\n+  static ObjectMonitor* inflate_fast_locked_object(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current);\n+  static ObjectMonitor* inflate_and_enter(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current);\n+\n+  static void deflate_monitor(Thread* current, oop obj, ObjectMonitor* monitor);\n+\n+  static ObjectMonitor* get_monitor_from_table(Thread* current, oop obj);\n+\n+  static bool contains_monitor(Thread* current, ObjectMonitor* monitor);\n+\n+  static bool quick_enter(oop obj, BasicLock* Lock, JavaThread* current);\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_LIGHTWEIGHTSYNCHRONIZER_HPP\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -37,0 +38,1 @@\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -43,0 +45,1 @@\n+#include \"utilities\/sizes.hpp\"\n@@ -117,0 +120,8 @@\n+\n+OMCache::OMCache(JavaThread* jt) : _entries() {\n+  STATIC_ASSERT(std::is_standard_layout<OMCache>::value);\n+  STATIC_ASSERT(std::is_standard_layout<OMCache::OMCacheEntry>::value);\n+  STATIC_ASSERT(offsetof(OMCache, _null_sentinel) == offsetof(OMCache, _entries) +\n+                offsetof(OMCache::OMCacheEntry, _oop) +\n+                OMCache::CAPACITY * in_bytes(oop_to_oop_difference()));\n+}\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class ObjectMonitor;\n@@ -39,0 +40,1 @@\n+class Thread;\n@@ -44,1 +46,1 @@\n-public:\n+ public:\n@@ -46,1 +48,1 @@\n-private:\n+ private:\n@@ -76,1 +78,1 @@\n-public:\n+ public:\n@@ -126,0 +128,25 @@\n+class OMCache {\n+  friend class VMStructs;\n+ public:\n+  static constexpr int CAPACITY = 8;\n+\n+ private:\n+  struct OMCacheEntry {\n+    oop _oop = nullptr;\n+    ObjectMonitor* _monitor = nullptr;\n+  } _entries[CAPACITY];\n+  const oop _null_sentinel = nullptr;\n+\n+ public:\n+  static ByteSize entries_offset() { return byte_offset_of(OMCache, _entries); }\n+  static constexpr ByteSize oop_to_oop_difference() { return in_ByteSize(sizeof(OMCacheEntry)); }\n+  static constexpr ByteSize oop_to_monitor_difference() { return in_ByteSize(sizeof(oop)); }\n+\n+  explicit OMCache(JavaThread* jt);\n+\n+  inline ObjectMonitor* get_monitor(oop o);\n+  inline void set_monitor(ObjectMonitor* monitor);\n+  inline void clear();\n+\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -225,0 +227,50 @@\n+inline void OMCache::set_monitor(ObjectMonitor *monitor) {\n+  const int end = OMCache::CAPACITY - 1;\n+\n+  oop obj = monitor->object_peek();\n+  assert(obj != nullptr, \"must be alive\");\n+  assert(monitor == LightweightSynchronizer::get_monitor_from_table(JavaThread::current(), obj), \"must exist in table\");\n+\n+  OMCacheEntry to_insert = {obj, monitor};\n+\n+  for (int i = 0; i < end; ++i) {\n+    if (_entries[i]._oop == obj ||\n+        _entries[i]._monitor == nullptr ||\n+        _entries[i]._monitor->is_being_async_deflated()) {\n+      \/\/ Use stale slot.\n+      _entries[i] = to_insert;\n+      return;\n+    }\n+    \/\/ Swap with the most recent value.\n+    ::swap(to_insert, _entries[i]);\n+  }\n+  _entries[end] = to_insert;\n+}\n+\n+inline ObjectMonitor* OMCache::get_monitor(oop o) {\n+  for (int i = 0; i < CAPACITY; ++i) {\n+    if (_entries[i]._oop == o) {\n+      assert(_entries[i]._monitor != nullptr, \"monitor must exist\");\n+      if (_entries[i]._monitor->is_being_async_deflated()) {\n+        \/\/ Bad monitor\n+        \/\/ Shift down rest\n+        for (; i < CAPACITY - 1; ++i) {\n+          _entries[i] = _entries[i + 1];\n+        }\n+        \/\/ Clear end\n+        _entries[i] = {};\n+        return nullptr;\n+      }\n+      return _entries[i]._monitor;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+inline void OMCache::clear() {\n+  for (size_t i = 0; i < CAPACITY; ++i) {\n+    \/\/ Clear\n+    _entries[i] = {};\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -56,0 +57,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -249,1 +251,1 @@\n-  _header(markWord::zero()),\n+  _metadata(0),\n@@ -275,4 +277,0 @@\n-oop ObjectMonitor::object_peek() const {\n-  return _object.peek();\n-}\n-\n@@ -300,0 +298,6 @@\n+#define assert_mark_word_consistency()                                         \\\n+  assert(UseObjectMonitorTable || object()->mark() == markWord::encode(this),  \\\n+         \"object mark must match encoded this: mark=\" INTPTR_FORMAT            \\\n+         \", encoded this=\" INTPTR_FORMAT, object()->mark().value(),            \\\n+         markWord::encode(this).value());\n+\n@@ -303,1 +307,17 @@\n-bool ObjectMonitor::enter_for(JavaThread* locking_thread) {\n+bool ObjectMonitor::enter_is_async_deflating() {\n+  if (is_being_async_deflated()) {\n+    if (!UseObjectMonitorTable) {\n+      const oop l_object = object();\n+      if (l_object != nullptr) {\n+        \/\/ Attempt to restore the header\/dmw to the object's header so that\n+        \/\/ we only retry once if the deflater thread happens to be slow.\n+        install_displaced_markword_in_object(l_object);\n+      }\n+    }\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+void ObjectMonitor::enter_for_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark) {\n@@ -308,0 +328,2 @@\n+  assert(contention_mark._monitor == this, \"must be\");\n+  assert(!is_being_async_deflated(), \"must be\");\n@@ -309,2 +331,2 @@\n-  \/\/ Block out deflation as soon as possible.\n-  add_to_contentions(1);\n+\n+  void* prev_owner = try_set_owner_from(nullptr, locking_thread);\n@@ -313,2 +335,0 @@\n-  if (!is_being_async_deflated()) {\n-    void* prev_owner = try_set_owner_from(nullptr, locking_thread);\n@@ -316,25 +336,12 @@\n-    if (prev_owner == nullptr) {\n-      assert(_recursions == 0, \"invariant\");\n-      success = true;\n-    } else if (prev_owner == locking_thread) {\n-      _recursions++;\n-      success = true;\n-    } else if (prev_owner == DEFLATER_MARKER) {\n-      \/\/ Racing with deflation.\n-      prev_owner = try_set_owner_from(DEFLATER_MARKER, locking_thread);\n-      if (prev_owner == DEFLATER_MARKER) {\n-        \/\/ Cancelled deflation. Increment contentions as part of the deflation protocol.\n-        add_to_contentions(1);\n-        success = true;\n-      } else if (prev_owner == nullptr) {\n-        \/\/ At this point we cannot race with deflation as we have both incremented\n-        \/\/ contentions, seen contention > 0 and seen a DEFLATER_MARKER.\n-        \/\/ success will only be false if this races with something other than\n-        \/\/ deflation.\n-        prev_owner = try_set_owner_from(nullptr, locking_thread);\n-        success = prev_owner == nullptr;\n-      }\n-    } else if (LockingMode == LM_LEGACY && locking_thread->is_lock_owned((address)prev_owner)) {\n-      assert(_recursions == 0, \"must be\");\n-      _recursions = 1;\n-      set_owner_from_BasicLock(prev_owner, locking_thread);\n+  if (prev_owner == nullptr) {\n+    assert(_recursions == 0, \"invariant\");\n+    success = true;\n+  } else if (prev_owner == locking_thread) {\n+    _recursions++;\n+    success = true;\n+  } else if (prev_owner == DEFLATER_MARKER) {\n+    \/\/ Racing with deflation.\n+    prev_owner = try_set_owner_from(DEFLATER_MARKER, locking_thread);\n+    if (prev_owner == DEFLATER_MARKER) {\n+      \/\/ Cancelled deflation. Increment contentions as part of the deflation protocol.\n+      add_to_contentions(1);\n@@ -342,0 +349,7 @@\n+    } else if (prev_owner == nullptr) {\n+      \/\/ At this point we cannot race with deflation as we have both incremented\n+      \/\/ contentions, seen contention > 0 and seen a DEFLATER_MARKER.\n+      \/\/ success will only be false if this races with something other than\n+      \/\/ deflation.\n+      prev_owner = try_set_owner_from(nullptr, locking_thread);\n+      success = prev_owner == nullptr;\n@@ -343,13 +357,5 @@\n-    assert(success, \"Failed to enter_for: locking_thread=\" INTPTR_FORMAT\n-           \", this=\" INTPTR_FORMAT \"{owner=\" INTPTR_FORMAT \"}, observed owner: \" INTPTR_FORMAT,\n-           p2i(locking_thread), p2i(this), p2i(owner_raw()), p2i(prev_owner));\n-  } else {\n-    \/\/ Async deflation is in progress and our contentions increment\n-    \/\/ above lost the race to async deflation. Undo the work and\n-    \/\/ force the caller to retry.\n-    const oop l_object = object();\n-    if (l_object != nullptr) {\n-      \/\/ Attempt to restore the header\/dmw to the object's header so that\n-      \/\/ we only retry once if the deflater thread happens to be slow.\n-      install_displaced_markword_in_object(l_object);\n-    }\n+  } else if (LockingMode == LM_LEGACY && locking_thread->is_lock_owned((address)prev_owner)) {\n+    assert(_recursions == 0, \"must be\");\n+    _recursions = 1;\n+    set_owner_from_BasicLock(prev_owner, locking_thread);\n+    success = true;\n@@ -357,0 +363,6 @@\n+  assert(success, \"Failed to enter_for: locking_thread=\" INTPTR_FORMAT\n+          \", this=\" INTPTR_FORMAT \"{owner=\" INTPTR_FORMAT \"}, observed owner: \" INTPTR_FORMAT,\n+          p2i(locking_thread), p2i(this), p2i(owner_raw()), p2i(prev_owner));\n+}\n+\n+bool ObjectMonitor::enter_for(JavaThread* locking_thread) {\n@@ -358,1 +370,2 @@\n-  add_to_contentions(-1);\n+  \/\/ Block out deflation as soon as possible.\n+  ObjectMonitorContentionMark contention_mark(this);\n@@ -360,1 +373,4 @@\n-  assert(!success || owner_raw() == locking_thread, \"must be\");\n+  \/\/ Check for deflation.\n+  if (enter_is_async_deflating()) {\n+    return false;\n+  }\n@@ -362,1 +378,3 @@\n-  return success;\n+  enter_for_with_contention_mark(locking_thread, contention_mark);\n+  assert(owner_raw() == locking_thread, \"must be\");\n+  return true;\n@@ -365,7 +383,4 @@\n-bool ObjectMonitor::enter(JavaThread* current) {\n-  assert(current == JavaThread::current(), \"must be\");\n-  \/\/ The following code is ordered to check the most common cases first\n-  \/\/ and to reduce RTS->RTO cache line upgrades on SPARC and IA32 processors.\n-\n-  void* cur = try_set_owner_from(nullptr, current);\n-  if (cur == nullptr) {\n+bool ObjectMonitor::try_enter(JavaThread* current) {\n+  \/\/ TryLock avoids the CAS\n+  TryLockResult r = TryLock(current);\n+  if (r == TryLockResult::Success) {\n@@ -376,2 +391,1 @@\n-  if (cur == current) {\n-    \/\/ TODO-FIXME: check for integer overflow!  BUGID 6557169.\n+  if (r == TryLockResult::HasOwner && owner() == current) {\n@@ -382,1 +396,2 @@\n-  if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+  void* cur = owner_raw();\n+  if (LockingMode == LM_LEGACY && current->is_lock_owned((address)cur)) {\n@@ -389,0 +404,16 @@\n+  return false;\n+}\n+\n+bool ObjectMonitor::spin_enter(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  \/\/ Check for recursion.\n+  if (try_enter(current)) {\n+    return true;\n+  }\n+\n+  \/\/ Check for deflation.\n+  if (enter_is_async_deflating()) {\n+    return false;\n+  }\n+\n@@ -391,3 +422,1 @@\n-  \/\/ Try one round of spinning *before* enqueueing current\n-  \/\/ and before going through the awkward and expensive state\n-  \/\/ transitions.  The following spin is strictly optional ...\n+  \/\/ Do one round of spinning.\n@@ -399,4 +428,11 @@\n-    assert(object()->mark() == markWord::encode(this),\n-           \"object mark must match encoded this: mark=\" INTPTR_FORMAT\n-           \", encoded this=\" INTPTR_FORMAT, object()->mark().value(),\n-           markWord::encode(this).value());\n+    assert_mark_word_consistency();\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool ObjectMonitor::enter(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  if (spin_enter(current)) {\n@@ -411,13 +447,5 @@\n-  \/\/ Keep track of contention for JVM\/TI and M&M queries.\n-  add_to_contentions(1);\n-  if (is_being_async_deflated()) {\n-    \/\/ Async deflation is in progress and our contentions increment\n-    \/\/ above lost the race to async deflation. Undo the work and\n-    \/\/ force the caller to retry.\n-    const oop l_object = object();\n-    if (l_object != nullptr) {\n-      \/\/ Attempt to restore the header\/dmw to the object's header so that\n-      \/\/ we only retry once if the deflater thread happens to be slow.\n-      install_displaced_markword_in_object(l_object);\n-    }\n-    add_to_contentions(-1);\n+  \/\/ Keep is_being_async_deflated stable across the rest of enter\n+  ObjectMonitorContentionMark contention_mark(this);\n+\n+  \/\/ Check for deflation.\n+  if (enter_is_async_deflating()) {\n@@ -427,0 +455,11 @@\n+  \/\/ At this point this ObjectMonitor cannot be deflated, finish contended enter\n+  enter_with_contention_mark(current, contention_mark);\n+  return true;\n+}\n+\n+void ObjectMonitor::enter_with_contention_mark(JavaThread *current, ObjectMonitorContentionMark &cm) {\n+  assert(current == JavaThread::current(), \"must be\");\n+  assert(owner_raw() != current, \"must be\");\n+  assert(cm._monitor == this, \"must be\");\n+  assert(!is_being_async_deflated(), \"must be\");\n+\n@@ -483,1 +522,0 @@\n-  add_to_contentions(-1);\n@@ -490,1 +528,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_consistency();\n@@ -519,1 +557,0 @@\n-  return true;\n@@ -552,1 +589,1 @@\n-bool ObjectMonitor::deflate_monitor() {\n+bool ObjectMonitor::deflate_monitor(Thread* current) {\n@@ -623,0 +660,1 @@\n+  }\n@@ -624,0 +662,3 @@\n+  if (UseObjectMonitorTable) {\n+    LightweightSynchronizer::deflate_monitor(current, obj, this);\n+  } else if (obj != nullptr) {\n@@ -639,0 +680,1 @@\n+  assert(!UseObjectMonitorTable, \"ObjectMonitorTable has no dmw\");\n@@ -975,0 +1017,1 @@\n+  assert(current->thread_state() != _thread_blocked, \"invariant\");\n@@ -978,3 +1021,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n-\n-  assert(current->thread_state() != _thread_blocked, \"invariant\");\n+  assert_mark_word_consistency();\n@@ -1045,1 +1086,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_consistency();\n@@ -1671,1 +1712,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_consistency();\n@@ -2188,1 +2229,1 @@\n-\/\/   _header = 0x0000000000000001\n+\/\/   _metadata = 0x0000000000000001\n@@ -2217,1 +2258,1 @@\n-  st->print_cr(\"  _header = \" INTPTR_FORMAT, header().value());\n+  st->print_cr(\"  _metadata = \" INTPTR_FORMAT, _metadata);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":133,"deletions":92,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class ObjectMonitorContentionMark;\n@@ -72,1 +73,1 @@\n-\/\/ - The _header field must be at offset 0 because the displaced header\n+\/\/ - The _metadata field must be at offset 0 because the displaced header\n@@ -78,1 +79,1 @@\n-\/\/ - The _header and _owner fields should be separated by enough space\n+\/\/ - The _metadata and _owner fields should be separated by enough space\n@@ -82,1 +83,1 @@\n-\/\/     _header\n+\/\/     _metadata\n@@ -86,0 +87,1 @@\n+\/\/     <optional padding>\n@@ -109,10 +111,9 @@\n-\/\/   - Separating _owner from the <remaining_fields> by enough space to\n-\/\/     avoid false sharing might be profitable. Given\n-\/\/     http:\/\/blogs.oracle.com\/dave\/entry\/cas_and_cache_trivia_invalidate\n-\/\/     we know that the CAS in monitorenter will invalidate the line\n-\/\/     underlying _owner. We want to avoid an L1 data cache miss on that\n-\/\/     same line for monitorexit. Putting these <remaining_fields>:\n-\/\/     _recursions, _EntryList, _cxq, and _succ, all of which may be\n-\/\/     fetched in the inflated unlock path, on a different cache line\n-\/\/     would make them immune to CAS-based invalidation from the _owner\n-\/\/     field.\n+\/\/ - Separating _owner from the <remaining_fields> by enough space to\n+\/\/   avoid false sharing might be profitable. Given that the CAS in\n+\/\/   monitorenter will invalidate the line underlying _owner. We want\n+\/\/   to avoid an L1 data cache miss on that same line for monitorexit.\n+\/\/   Putting these <remaining_fields>:\n+\/\/   _recursions, _EntryList, _cxq, and _succ, all of which may be\n+\/\/   fetched in the inflated unlock path, on a different cache line\n+\/\/   would make them immune to CAS-based invalidation from the _owner\n+\/\/   field.\n@@ -120,3 +121,3 @@\n-\/\/   - The _recursions field should be of type int, or int32_t but not\n-\/\/     intptr_t. There's no reason to use a 64-bit type for this field\n-\/\/     in a 64-bit JVM.\n+\/\/ - The _recursions field should be of type int, or int32_t but not\n+\/\/   intptr_t. There's no reason to use a 64-bit type for this field\n+\/\/   in a 64-bit JVM.\n@@ -134,3 +135,7 @@\n-  \/\/ The sync code expects the header field to be at offset zero (0).\n-  \/\/ Enforced by the assert() in header_addr().\n-  volatile markWord _header;        \/\/ displaced object header word - mark\n+  \/\/ The sync code expects the metadata field to be at offset zero (0).\n+  \/\/ Enforced by the assert() in metadata_addr().\n+  \/\/ * LM_LIGHTWEIGHT with UseObjectMonitorTable:\n+  \/\/ Contains the _object's hashCode.\n+  \/\/ * LM_LEGACY, LM_MONITOR, LM_LIGHTWEIGHT without UseObjectMonitorTable:\n+  \/\/ Contains the displaced object header word - mark\n+  volatile uintptr_t _metadata;     \/\/ metadata\n@@ -138,2 +143,2 @@\n-  \/\/ Separate _header and _owner on different cache lines since both can\n-  \/\/ have busy multi-threaded access. _header and _object are set at initial\n+  \/\/ Separate _metadata and _owner on different cache lines since both can\n+  \/\/ have busy multi-threaded access. _metadata and _object are set at initial\n@@ -141,2 +146,2 @@\n-  \/\/ its cache line with _header.\n-  DEFINE_PAD_MINUS_SIZE(0, OM_CACHE_LINE_SIZE, sizeof(volatile markWord) +\n+  \/\/ its cache line with _metadata.\n+  DEFINE_PAD_MINUS_SIZE(0, OM_CACHE_LINE_SIZE, sizeof(_metadata) +\n@@ -152,2 +157,3 @@\n-  #define DEFLATER_MARKER reinterpret_cast<void*>(2)\n-public:\n+  static const uintptr_t DEFLATER_MARKER_VALUE = 2;\n+  #define DEFLATER_MARKER reinterpret_cast<void*>(DEFLATER_MARKER_VALUE)\n+ public:\n@@ -157,1 +163,1 @@\n-private:\n+ private:\n@@ -184,1 +190,1 @@\n- protected:\n+\n@@ -187,1 +193,0 @@\n- private:\n@@ -216,0 +221,1 @@\n+  static ByteSize metadata_offset()    { return byte_offset_of(ObjectMonitor, _metadata); }\n@@ -236,3 +242,9 @@\n-  markWord           header() const;\n-  volatile markWord* header_addr();\n-  void               set_header(markWord hdr);\n+  uintptr_t           metadata() const;\n+  void                set_metadata(uintptr_t value);\n+  volatile uintptr_t* metadata_addr();\n+\n+  markWord            header() const;\n+  void                set_header(markWord hdr);\n+\n+  intptr_t            hash() const;\n+  void                set_hash(intptr_t hash);\n@@ -309,0 +321,2 @@\n+  bool      object_is_dead() const;\n+  bool      object_refers_to(oop obj) const;\n@@ -331,0 +345,2 @@\n+\n+  bool      enter_is_async_deflating();\n@@ -332,0 +348,1 @@\n+  void      enter_for_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark);\n@@ -334,0 +351,3 @@\n+  bool      try_enter(JavaThread* current);\n+  bool      spin_enter(JavaThread* current);\n+  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark);\n@@ -367,1 +387,2 @@\n-  bool      deflate_monitor();\n+  bool      deflate_monitor(Thread* current);\n+ private:\n@@ -371,0 +392,14 @@\n+\/\/ RAII object to ensure that ObjectMonitor::is_being_async_deflated() is\n+\/\/ stable within the context of this mark.\n+class ObjectMonitorContentionMark : StackObj {\n+  DEBUG_ONLY(friend class ObjectMonitor;)\n+\n+  ObjectMonitor* _monitor;\n+\n+  NONCOPYABLE(ObjectMonitorContentionMark);\n+\n+ public:\n+  explicit ObjectMonitorContentionMark(ObjectMonitor* monitor);\n+  ~ObjectMonitorContentionMark();\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":67,"deletions":32,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/markWord.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -35,0 +37,2 @@\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -52,2 +56,6 @@\n-inline markWord ObjectMonitor::header() const {\n-  return Atomic::load(&_header);\n+inline uintptr_t ObjectMonitor::metadata() const {\n+  return Atomic::load(&_metadata);\n+}\n+\n+inline void ObjectMonitor::set_metadata(uintptr_t value) {\n+  Atomic::store(&_metadata, value);\n@@ -56,2 +64,9 @@\n-inline volatile markWord* ObjectMonitor::header_addr() {\n-  return &_header;\n+inline volatile uintptr_t* ObjectMonitor::metadata_addr() {\n+  STATIC_ASSERT(std::is_standard_layout<ObjectMonitor>::value);\n+  STATIC_ASSERT(offsetof(ObjectMonitor, _metadata) == 0);\n+  return &_metadata;\n+}\n+\n+inline markWord ObjectMonitor::header() const {\n+  assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use header\");\n+  return markWord(metadata());\n@@ -61,1 +76,12 @@\n-  Atomic::store(&_header, hdr);\n+  assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use header\");\n+  set_metadata(hdr.value());\n+}\n+\n+inline intptr_t ObjectMonitor::hash() const {\n+  assert(UseObjectMonitorTable, \"Only used by lightweight locking with OM table\");\n+  return metadata();\n+}\n+\n+inline void ObjectMonitor::set_hash(intptr_t hash) {\n+  assert(UseObjectMonitorTable, \"Only used by lightweight locking with OM table\");\n+  set_metadata(hash);\n@@ -183,0 +209,27 @@\n+inline ObjectMonitorContentionMark::ObjectMonitorContentionMark(ObjectMonitor* monitor)\n+  : _monitor(monitor) {\n+  _monitor->add_to_contentions(1);\n+}\n+\n+inline ObjectMonitorContentionMark::~ObjectMonitorContentionMark() {\n+  _monitor->add_to_contentions(-1);\n+}\n+\n+inline oop ObjectMonitor::object_peek() const {\n+  if (_object.is_null()) {\n+    return nullptr;\n+  }\n+  return _object.peek();\n+}\n+\n+inline bool ObjectMonitor::object_is_dead() const {\n+  return object_peek() == nullptr;\n+}\n+\n+inline bool ObjectMonitor::object_refers_to(oop obj) const {\n+  if (_object.is_null()) {\n+    return false;\n+  }\n+  return _object.peek() == obj;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":58,"deletions":5,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1007,3 +1007,3 @@\n-          THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),\n-                      vmSymbols::throwable_void_signature(),\n-                      &args);\n+          THROW_ARG_NULL(vmSymbols::java_lang_reflect_InvocationTargetException(),\n+                         vmSymbols::throwable_void_signature(),\n+                         &args);\n@@ -1031,3 +1031,3 @@\n-            THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),\n-              vmSymbols::throwable_void_signature(),\n-              &args);\n+            THROW_ARG_NULL(vmSymbols::java_lang_reflect_InvocationTargetException(),\n+                           vmSymbols::throwable_void_signature(),\n+                           &args);\n@@ -1120,3 +1120,3 @@\n-    THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),\n-                vmSymbols::throwable_void_signature(),\n-                &args);\n+    THROW_ARG_NULL(vmSymbols::java_lang_reflect_InvocationTargetException(),\n+                   vmSymbols::throwable_void_signature(),\n+                   &args);\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -734,0 +734,5 @@\n+\n+  \/\/ The oops in the monitor cache are cleared to prevent stale cache entries\n+  \/\/ from keeping dead objects alive. Because these oops are always cleared\n+  \/\/ before safepoint operations they are not visited in JavaThread::oops_do.\n+  _thread->om_clear_monitor_cache();\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"memory\/universe.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -38,0 +38,3 @@\n+#include \"prims\/jvmtiImpl.hpp\"\n+#include \"prims\/jvmtiTagMap.hpp\"\n+#include \"prims\/resolvedMethodTable.hpp\"\n@@ -43,1 +46,1 @@\n-#include \"runtime\/serviceThread.hpp\"\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -46,3 +49,1 @@\n-#include \"prims\/jvmtiImpl.hpp\"\n-#include \"prims\/jvmtiTagMap.hpp\"\n-#include \"prims\/resolvedMethodTable.hpp\"\n+#include \"runtime\/serviceThread.hpp\"\n@@ -97,0 +98,1 @@\n+    bool object_monitor_table_work = false;\n@@ -124,1 +126,2 @@\n-              (oopmap_cache_work = OopMapCache::has_cleanup_work())\n+              (oopmap_cache_work = OopMapCache::has_cleanup_work()) |\n+              (object_monitor_table_work = LightweightSynchronizer::needs_resize())\n@@ -186,0 +189,4 @@\n+\n+    if (object_monitor_table_work) {\n+      LightweightSynchronizer::resize_table(jt);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -72,1 +73,2 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n+#include \"runtime\/timerTrace.hpp\"\n@@ -79,0 +81,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -89,1 +92,3 @@\n-\/\/ Shared stub locations\n+\/\/ Shared runtime stub routines reside in their own unique blob with a\n+\/\/ single entry point\n+\n@@ -96,1 +101,0 @@\n-address             SharedRuntime::_resolve_static_call_entry;\n@@ -103,0 +107,11 @@\n+RuntimeStub*        SharedRuntime::_throw_AbstractMethodError_blob;\n+RuntimeStub*        SharedRuntime::_throw_IncompatibleClassChangeError_blob;\n+RuntimeStub*        SharedRuntime::_throw_NullPointerException_at_call_blob;\n+RuntimeStub*        SharedRuntime::_throw_StackOverflowError_blob;\n+RuntimeStub*        SharedRuntime::_throw_delayed_StackOverflowError_blob;\n+\n+#if INCLUDE_JFR\n+RuntimeStub*        SharedRuntime::_jfr_write_checkpoint_blob = nullptr;\n+RuntimeStub*        SharedRuntime::_jfr_return_lease_blob = nullptr;\n+#endif\n+\n@@ -106,0 +121,7 @@\n+void SharedRuntime::generate_initial_stubs() {\n+  \/\/ Build this early so it's available for the interpreter.\n+  _throw_StackOverflowError_blob =\n+    generate_throw_exception(\"StackOverflowError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));\n+}\n+\n@@ -113,1 +135,16 @@\n-  _resolve_static_call_entry           = _resolve_static_call_blob->entry_point();\n+\n+  _throw_delayed_StackOverflowError_blob =\n+    generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError));\n+\n+  _throw_AbstractMethodError_blob =\n+    generate_throw_exception(\"AbstractMethodError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));\n+\n+  _throw_IncompatibleClassChangeError_blob =\n+    generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));\n+\n+  _throw_NullPointerException_at_call_blob =\n+    generate_throw_exception(\"NullPointerException at call throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));\n@@ -130,0 +167,13 @@\n+#if INCLUDE_JFR\n+\/\/------------------------------generate jfr runtime stubs ------\n+void SharedRuntime::generate_jfr_stubs() {\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_jfr_stubs\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  _jfr_write_checkpoint_blob = generate_jfr_write_checkpoint();\n+  _jfr_return_lease_blob = generate_jfr_return_lease();\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -868,1 +918,1 @@\n-        return StubRoutines::throw_StackOverflowError_entry();\n+        return SharedRuntime::throw_StackOverflowError_entry();\n@@ -894,1 +944,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -915,1 +965,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -926,1 +976,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -932,1 +982,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -1468,1 +1518,1 @@\n-  address res = StubRoutines::throw_AbstractMethodError_entry();\n+  address res = SharedRuntime::throw_AbstractMethodError_entry();\n@@ -1886,1 +1936,1 @@\n-    if (ObjectSynchronizer::quick_enter(obj, current, lock)) {\n+    if (ObjectSynchronizer::quick_enter(obj, lock, current)) {\n@@ -2388,1 +2438,1 @@\n-                                                                StubRoutines::throw_AbstractMethodError_entry(),\n+                                                                SharedRuntime::throw_AbstractMethodError_entry(),\n@@ -2948,0 +2998,2 @@\n+      } else if (UseObjectMonitorTable) {\n+        buf[i] = (intptr_t)lock->object_monitor_cache();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":64,"deletions":12,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-  static address             _resolve_static_call_entry;\n@@ -67,0 +66,11 @@\n+  static RuntimeStub*        _throw_AbstractMethodError_blob;\n+  static RuntimeStub*        _throw_IncompatibleClassChangeError_blob;\n+  static RuntimeStub*        _throw_NullPointerException_at_call_blob;\n+  static RuntimeStub*        _throw_StackOverflowError_blob;\n+  static RuntimeStub*        _throw_delayed_StackOverflowError_blob;\n+\n+#if INCLUDE_JFR\n+  static RuntimeStub*        _jfr_write_checkpoint_blob;\n+  static RuntimeStub*        _jfr_return_lease_blob;\n+#endif\n+\n@@ -76,1 +86,1 @@\n-\n+  static RuntimeStub*   generate_throw_exception(const char* name, address runtime_entry);\n@@ -78,0 +88,1 @@\n+  static void generate_initial_stubs(void);\n@@ -79,0 +90,9 @@\n+#if INCLUDE_JFR\n+  static void generate_jfr_stubs(void);\n+  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+  \/\/ It returns a jobject handle to the event writer.\n+  \/\/ The handle is dereferenced and the return value is the event writer oop.\n+  static RuntimeStub* generate_jfr_write_checkpoint();\n+  \/\/ For c2: call to runtime to return a buffer lease.\n+  static RuntimeStub* generate_jfr_return_lease();\n+#endif\n@@ -244,0 +264,12 @@\n+  \/\/ Implicit exceptions\n+  static address throw_AbstractMethodError_entry()          { return _throw_AbstractMethodError_blob->entry_point(); }\n+  static address throw_IncompatibleClassChangeError_entry() { return _throw_IncompatibleClassChangeError_blob->entry_point(); }\n+  static address throw_NullPointerException_at_call_entry() { return _throw_NullPointerException_at_call_blob->entry_point(); }\n+  static address throw_StackOverflowError_entry()           { return _throw_StackOverflowError_blob->entry_point(); }\n+  static address throw_delayed_StackOverflowError_entry()   { return _throw_delayed_StackOverflowError_blob->entry_point(); }\n+\n+#if INCLUDE_JFR\n+  static address jfr_write_checkpoint() { return _jfr_write_checkpoint_blob->entry_point(); }\n+  static address jfr_return_lease()     { return _jfr_return_lease_blob->entry_point(); }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -64,5 +64,0 @@\n-address StubRoutines::_throw_AbstractMethodError_entry          = nullptr;\n-address StubRoutines::_throw_IncompatibleClassChangeError_entry = nullptr;\n-address StubRoutines::_throw_NullPointerException_at_call_entry = nullptr;\n-address StubRoutines::_throw_StackOverflowError_entry           = nullptr;\n-address StubRoutines::_throw_delayed_StackOverflowError_entry   = nullptr;\n@@ -194,5 +189,0 @@\n-JFR_ONLY(RuntimeStub* StubRoutines::_jfr_write_checkpoint_stub = nullptr;)\n-JFR_ONLY(address StubRoutines::_jfr_write_checkpoint = nullptr;)\n-JFR_ONLY(RuntimeStub* StubRoutines::_jfr_return_lease_stub = nullptr;)\n-JFR_ONLY(address StubRoutines::_jfr_return_lease = nullptr;)\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,28 @@\n-\/\/ points are defined in the platform-specific inner class.\n+\/\/ points are defined in the platform-specific inner class. Most\n+\/\/ routines have a single (main) entry point. However, a few routines\n+\/\/ do provide alternative entry points.\n+\/\/\n+\/\/ Stub routines whose entries are advertised via class StubRoutines\n+\/\/ are generated in batches at well-defined stages during JVM init:\n+\/\/ initial stubs, continuation stubs, compiler stubs, final stubs.\n+\/\/ Each batch is embedded in a single, associated blob (an instance of\n+\/\/ BufferBlob) i.e. the blob to entry relationship is 1-m.\n+\/\/\n+\/\/ Note that this constrasts with the much smaller number of stub\n+\/\/ routines generated via classes SharedRuntime, c1_Runtime1 and\n+\/\/ OptoRuntime. The latter routines are also generated at well-defined\n+\/\/ points during JVM init. However, each stub routine has its own\n+\/\/ unique blob (various subclasses of RuntimeBlob) i.e. the blob to\n+\/\/ entry relationship is 1-1. The difference arises because\n+\/\/ SharedRuntime routines may need to be relocatable or advertise\n+\/\/ properties such as a frame size via their blob.\n+\/\/\n+\/\/ Staging of stub routine generation is needed in order to manage\n+\/\/ init dependencies between 1) stubs and other stubs or 2) stubs and\n+\/\/ other runtime components. For example, some exception throw stubs\n+\/\/ need to be generated before compiler stubs (such as the\n+\/\/ deoptimization stub) so that the latter can invoke the thrwo rotine\n+\/\/ in bail-out code. Likewise, stubs that access objects (such as the\n+\/\/ object array copy stub) need to be created after initialization of\n+\/\/ some GC constants and generation of the GC barrier stubs they might\n+\/\/ need to invoke.\n@@ -52,2 +79,1 @@\n-\/\/    stubRoutines_<os_family>.cpp       stubGenerator_<arch>.cpp\n-\/\/    stubRoutines_<os_arch>.cpp\n+\/\/                                       stubGenerator_<arch>.cpp\n@@ -78,0 +104,2 @@\n+\/\/ 5. ensure the entry is generated in the right blob to satisfy initialization\n+\/\/    dependencies between it and other stubs or runtime components.\n@@ -140,5 +168,0 @@\n-  static address _throw_AbstractMethodError_entry;\n-  static address _throw_IncompatibleClassChangeError_entry;\n-  static address _throw_NullPointerException_at_call_entry;\n-  static address _throw_StackOverflowError_entry;\n-  static address _throw_delayed_StackOverflowError_entry;\n@@ -272,5 +295,0 @@\n-  JFR_ONLY(static RuntimeStub* _jfr_write_checkpoint_stub;)\n-  JFR_ONLY(static address _jfr_write_checkpoint;)\n-  JFR_ONLY(static RuntimeStub* _jfr_return_lease_stub;)\n-  JFR_ONLY(static address _jfr_return_lease;)\n-\n@@ -332,6 +350,0 @@\n-  \/\/ Implicit exceptions\n-  static address throw_AbstractMethodError_entry()         { return _throw_AbstractMethodError_entry; }\n-  static address throw_IncompatibleClassChangeError_entry(){ return _throw_IncompatibleClassChangeError_entry; }\n-  static address throw_NullPointerException_at_call_entry(){ return _throw_NullPointerException_at_call_entry; }\n-  static address throw_StackOverflowError_entry()          { return _throw_StackOverflowError_entry; }\n-  static address throw_delayed_StackOverflowError_entry()  { return _throw_delayed_StackOverflowError_entry; }\n@@ -490,3 +502,0 @@\n-  JFR_ONLY(static address jfr_write_checkpoint() { return _jfr_write_checkpoint; })\n-  JFR_ONLY(static address jfr_return_lease() { return _jfr_return_lease; })\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":31,"deletions":22,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -44,0 +45,1 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -55,1 +57,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -279,0 +281,4 @@\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LightweightSynchronizer::initialize();\n+  }\n@@ -352,1 +358,5 @@\n-    ObjectMonitor* const mon = mark.monitor();\n+    ObjectMonitor* const mon = read_monitor(current, obj, mark);\n+    if (LockingMode == LM_LIGHTWEIGHT && mon == nullptr) {\n+      \/\/ Racing with inflation\/deflation go slow path\n+      return false;\n+    }\n@@ -379,0 +389,7 @@\n+static bool useHeavyMonitors() {\n+#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64) || defined(S390)\n+  return LockingMode == LM_MONITOR;\n+#else\n+  return false;\n+#endif\n+}\n@@ -386,2 +403,1 @@\n-bool ObjectSynchronizer::quick_enter(oop obj, JavaThread* current,\n-                                     BasicLock * lock) {\n+bool ObjectSynchronizer::quick_enter_legacy(oop obj, BasicLock* lock, JavaThread* current) {\n@@ -389,2 +405,0 @@\n-  NoSafepointVerifier nsv;\n-  if (obj == nullptr) return false;       \/\/ Need to throw NPE\n@@ -392,2 +406,2 @@\n-  if (obj->klass()->is_value_based()) {\n-    return false;\n+  if (useHeavyMonitors()) {\n+    return false;  \/\/ Slow path\n@@ -397,10 +411,1 @@\n-    LockStack& lock_stack = current->lock_stack();\n-    if (lock_stack.is_full()) {\n-      \/\/ Always go into runtime if the lock stack is full.\n-      return false;\n-    }\n-    if (lock_stack.try_recursive_enter(obj)) {\n-      \/\/ Recursive lock successful.\n-      current->inc_held_monitor_count();\n-      return true;\n-    }\n+    return LightweightSynchronizer::quick_enter(obj, lock, current);\n@@ -409,0 +414,2 @@\n+  assert(LockingMode == LM_LEGACY, \"legacy mode below\");\n+\n@@ -412,1 +419,2 @@\n-    ObjectMonitor* const m = mark.monitor();\n+\n+    ObjectMonitor* const m = read_monitor(mark);\n@@ -432,12 +440,10 @@\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ This Java Monitor is inflated so obj's header will never be\n-      \/\/ displaced to this thread's BasicLock. Make the displaced header\n-      \/\/ non-null so this BasicLock is not seen as recursive nor as\n-      \/\/ being locked. We do this unconditionally so that this thread's\n-      \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n-      \/\/ performance reasons, stack walkers generally first check for\n-      \/\/ stack-locking in the object's header, the second check is for\n-      \/\/ recursive stack-locking in the displaced header in the BasicLock,\n-      \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n-      lock->set_displaced_header(markWord::unused_mark());\n-    }\n+    \/\/ This Java Monitor is inflated so obj's header will never be\n+    \/\/ displaced to this thread's BasicLock. Make the displaced header\n+    \/\/ non-null so this BasicLock is not seen as recursive nor as\n+    \/\/ being locked. We do this unconditionally so that this thread's\n+    \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n+    \/\/ performance reasons, stack walkers generally first check for\n+    \/\/ stack-locking in the object's header, the second check is for\n+    \/\/ recursive stack-locking in the displaced header in the BasicLock,\n+    \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n+    lock->set_displaced_header(markWord::unused_mark());\n@@ -511,8 +517,0 @@\n-static bool useHeavyMonitors() {\n-#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64) || defined(S390)\n-  return LockingMode == LM_MONITOR;\n-#else\n-  return false;\n-#endif\n-}\n-\n@@ -527,0 +525,5 @@\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    return LightweightSynchronizer::enter_for(obj, lock, locking_thread);\n+  }\n+\n@@ -543,2 +546,1 @@\n-void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n-  assert(current == Thread::current(), \"must be\");\n+void ObjectSynchronizer::enter_legacy(Handle obj, BasicLock* lock, JavaThread* current) {\n@@ -564,0 +566,1 @@\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"Use LightweightSynchronizer\");\n@@ -572,55 +575,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast-locking does not use the 'lock' argument.\n-      LockStack& lock_stack = locking_thread->lock_stack();\n-      if (lock_stack.is_full()) {\n-        \/\/ We unconditionally make room on the lock stack by inflating\n-        \/\/ the least recently locked object on the lock stack.\n-\n-        \/\/ About the choice to inflate least recently locked object.\n-        \/\/ First we must chose to inflate a lock, either some lock on\n-        \/\/ the lock-stack or the lock that is currently being entered\n-        \/\/ (which may or may not be on the lock-stack).\n-        \/\/ Second the best lock to inflate is a lock which is entered\n-        \/\/ in a control flow where there are only a very few locks being\n-        \/\/ used, as the costly part of inflated locking is inflation,\n-        \/\/ not locking. But this property is entirely program dependent.\n-        \/\/ Third inflating the lock currently being entered on when it\n-        \/\/ is not present on the lock-stack will result in a still full\n-        \/\/ lock-stack. This creates a scenario where every deeper nested\n-        \/\/ monitorenter must call into the runtime.\n-        \/\/ The rational here is as follows:\n-        \/\/ Because we cannot (currently) figure out the second, and want\n-        \/\/ to avoid the third, we inflate a lock on the lock-stack.\n-        \/\/ The least recently locked lock is chosen as it is the lock\n-        \/\/ with the longest critical section.\n-\n-        log_info(monitorinflation)(\"LockStack capacity exceeded, inflating.\");\n-        ObjectMonitor* monitor = inflate_for(locking_thread, lock_stack.bottom(), inflate_cause_vm_internal);\n-        assert(monitor->owner() == locking_thread, \"must be owner=\" PTR_FORMAT \" locking_thread=\" PTR_FORMAT \" mark=\" PTR_FORMAT,\n-               p2i(monitor->owner()), p2i(locking_thread), monitor->object()->mark_acquire().value());\n-        assert(!lock_stack.is_full(), \"must have made room here\");\n-      }\n-\n-      markWord mark = obj()->mark_acquire();\n-      while (mark.is_unlocked()) {\n-        \/\/ Retry until a lock state change has been observed. cas_set_mark() may collide with non lock bits modifications.\n-        \/\/ Try to swing into 'fast-locked' state.\n-        assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n-        const markWord locked_mark = mark.set_fast_locked();\n-        const markWord old_mark = obj()->cas_set_mark(locked_mark, mark);\n-        if (old_mark == mark) {\n-          \/\/ Successfully fast-locked, push object to lock-stack and return.\n-          lock_stack.push(obj());\n-          return true;\n-        }\n-        mark = old_mark;\n-      }\n-\n-      if (mark.is_fast_locked() && lock_stack.try_recursive_enter(obj())) {\n-        \/\/ Recursive lock successful.\n-        return true;\n-      }\n-\n-      \/\/ Failed to fast lock.\n-      return false;\n-    } else if (LockingMode == LM_LEGACY) {\n+    if (LockingMode == LM_LEGACY) {\n@@ -659,2 +608,2 @@\n-void ObjectSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n-  current->dec_held_monitor_count();\n+void ObjectSynchronizer::exit_legacy(oop object, BasicLock* lock, JavaThread* current) {\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"Use LightweightSynchronizer\");\n@@ -664,26 +613,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast-locking does not use the 'lock' argument.\n-      LockStack& lock_stack = current->lock_stack();\n-      if (mark.is_fast_locked() && lock_stack.try_recursive_exit(object)) {\n-        \/\/ Recursively unlocked.\n-        return;\n-      }\n-\n-      if (mark.is_fast_locked() && lock_stack.is_recursive(object)) {\n-        \/\/ This lock is recursive but is not at the top of the lock stack so we're\n-        \/\/ doing an unbalanced exit. We have to fall thru to inflation below and\n-        \/\/ let ObjectMonitor::exit() do the unlock.\n-      } else {\n-        while (mark.is_fast_locked()) {\n-          \/\/ Retry until a lock state change has been observed. cas_set_mark() may collide with non lock bits modifications.\n-          const markWord unlocked_mark = mark.set_unlocked();\n-          const markWord old_mark = object->cas_set_mark(unlocked_mark, mark);\n-          if (old_mark == mark) {\n-            size_t recursions = lock_stack.remove(object) - 1;\n-            assert(recursions == 0, \"must not be recursive here\");\n-            return;\n-          }\n-          mark = old_mark;\n-        }\n-      }\n-    } else if (LockingMode == LM_LEGACY) {\n+    if (LockingMode == LM_LEGACY) {\n@@ -711,1 +635,1 @@\n-            ObjectMonitor* m = mark.monitor();\n+            ObjectMonitor* m = read_monitor(mark);\n@@ -755,2 +679,10 @@\n-    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_jni_enter);\n-    if (monitor->enter(current)) {\n+    ObjectMonitor* monitor;\n+    bool entered;\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      entered = LightweightSynchronizer::inflate_and_enter(obj(), inflate_cause_jni_enter, current, current) != nullptr;\n+    } else {\n+      monitor = inflate(current, obj(), inflate_cause_jni_enter);\n+      entered = monitor->enter(current);\n+    }\n+\n+    if (entered) {\n@@ -768,3 +700,8 @@\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n-  ObjectMonitor* monitor = inflate(current, obj, inflate_cause_jni_exit);\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj, inflate_cause_jni_exit, CHECK);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+    \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n+    monitor = inflate(current, obj, inflate_cause_jni_exit);\n+  }\n@@ -803,0 +740,1 @@\n+\n@@ -808,4 +746,10 @@\n-  \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n-  \/\/ field is incremented before ownership is dropped and decremented\n-  \/\/ after ownership is regained.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_wait);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK_0);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n+    \/\/ field is incremented before ownership is dropped and decremented\n+    \/\/ after ownership is regained.\n+    monitor = inflate(current, obj(), inflate_cause_wait);\n+  }\n@@ -828,3 +772,8 @@\n-  ObjectSynchronizer::inflate(THREAD,\n-                              obj(),\n-                              inflate_cause_wait)->wait(millis, false, THREAD);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK);\n+  } else {\n+    monitor = inflate(THREAD, obj(), inflate_cause_wait);\n+  }\n+  monitor->wait(millis, false, THREAD);\n@@ -849,3 +798,9 @@\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped by the calling thread.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_notify);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+    \/\/ dropped by the calling thread.\n+    monitor = inflate(current, obj(), inflate_cause_notify);\n+  }\n@@ -871,3 +826,9 @@\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped by the calling thread.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_notify);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+    \/\/ dropped by the calling thread.\n+    monitor = inflate(current, obj(), inflate_cause_notify);\n+  }\n@@ -971,1 +932,1 @@\n-static inline intptr_t get_next_hash(Thread* current, oop obj) {\n+static intptr_t get_next_hash(Thread* current, oop obj) {\n@@ -1011,0 +972,21 @@\n+static intptr_t install_hash_code(Thread* current, oop obj) {\n+  assert(UseObjectMonitorTable && LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+\n+  markWord mark = obj->mark_acquire();\n+  for (;;) {\n+    intptr_t hash = mark.hash();\n+    if (hash != 0) {\n+      return hash;\n+    }\n+\n+    hash = get_next_hash(current, obj);\n+    const markWord old_mark = mark;\n+    const markWord new_mark = old_mark.copy_set_hash(hash);\n+\n+    mark = obj->cas_set_mark(new_mark, old_mark);\n+    if (old_mark == mark) {\n+      return hash;\n+    }\n+  }\n+}\n+\n@@ -1012,0 +994,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Since the monitor isn't in the object header, the hash can simply be\n+    \/\/ installed in the object header.\n+    return install_hash_code(current, obj);\n+  }\n@@ -1105,1 +1092,1 @@\n-      uintptr_t v = Atomic::cmpxchg((volatile uintptr_t*)monitor->header_addr(), mark.value(), temp.value());\n+      uintptr_t v = Atomic::cmpxchg(monitor->metadata_addr(), mark.value(), temp.value());\n@@ -1117,1 +1104,1 @@\n-      if (monitor->is_being_async_deflated()) {\n+      if (monitor->is_being_async_deflated() && !UseObjectMonitorTable) {\n@@ -1148,1 +1135,15 @@\n-  if (mark.has_monitor()) {\n+  while (LockingMode == LM_LIGHTWEIGHT && mark.has_monitor()) {\n+    ObjectMonitor* monitor = read_monitor(current, obj, mark);\n+    if (monitor != nullptr) {\n+      return monitor->is_entered(current) != 0;\n+    }\n+    \/\/ Racing with inflation\/deflation, retry\n+    mark = obj->mark_acquire();\n+\n+    if (mark.is_fast_locked()) {\n+      \/\/ Some other thread fast_locked, current could not have held the lock\n+      return false;\n+    }\n+  }\n+\n+  if (LockingMode != LM_LIGHTWEIGHT && mark.has_monitor()) {\n@@ -1152,1 +1153,1 @@\n-    ObjectMonitor* monitor = mark.monitor();\n+    ObjectMonitor* monitor = read_monitor(mark);\n@@ -1176,1 +1177,15 @@\n-  if (mark.has_monitor()) {\n+  while (LockingMode == LM_LIGHTWEIGHT && mark.has_monitor()) {\n+    ObjectMonitor* monitor = read_monitor(Thread::current(), obj, mark);\n+    if (monitor != nullptr) {\n+      return Threads::owning_thread_from_monitor(t_list, monitor);\n+    }\n+    \/\/ Racing with inflation\/deflation, retry\n+    mark = obj->mark_acquire();\n+\n+    if (mark.is_fast_locked()) {\n+      \/\/ Some other thread fast_locked\n+      return Threads::owning_thread_from_object(t_list, h_obj());\n+    }\n+  }\n+\n+  if (LockingMode != LM_LIGHTWEIGHT && mark.has_monitor()) {\n@@ -1180,1 +1195,1 @@\n-    ObjectMonitor* monitor = mark.monitor();\n+    ObjectMonitor* monitor = read_monitor(mark);\n@@ -1392,0 +1407,1 @@\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"only inflate through enter\");\n@@ -1394,1 +1410,1 @@\n-    ObjectMonitor* monitor = mark.monitor();\n+    ObjectMonitor* monitor = read_monitor(mark);\n@@ -1404,4 +1420,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT && current->is_Java_thread()) {\n-    return inflate_impl(JavaThread::cast(current), obj, cause);\n-  }\n-  return inflate_impl(nullptr, obj, cause);\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"only inflate through enter\");\n+  return inflate_impl(obj, cause);\n@@ -1412,12 +1426,6 @@\n-  return inflate_impl(thread, obj, cause);\n-}\n-\n-ObjectMonitor* ObjectSynchronizer::inflate_impl(JavaThread* inflating_thread, oop object, const InflateCause cause) {\n-  \/\/ The JavaThread* inflating_thread parameter is only used by LM_LIGHTWEIGHT and requires\n-  \/\/ that the inflating_thread == Thread::current() or is suspended throughout the call by\n-  \/\/ some other mechanism.\n-  \/\/ Even with LM_LIGHTWEIGHT the thread might be nullptr when called from a non\n-  \/\/ JavaThread. (As may still be the case from FastHashCode). However it is only\n-  \/\/ important for the correctness of the LM_LIGHTWEIGHT algorithm that the thread\n-  \/\/ is set when called from ObjectSynchronizer::enter from the owning thread,\n-  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"LM_LIGHTWEIGHT cannot use inflate_for\");\n+  return inflate_impl(obj, cause);\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::inflate_impl(oop object, const InflateCause cause) {\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"LM_LIGHTWEIGHT cannot use inflate_impl\");\n@@ -1430,7 +1438,1 @@\n-    \/\/ *  inflated     - Just return if using stack-locking.\n-    \/\/                   If using fast-locking and the ObjectMonitor owner\n-    \/\/                   is anonymous and the inflating_thread owns the\n-    \/\/                   object lock, then we make the inflating_thread\n-    \/\/                   the ObjectMonitor owner and remove the lock from\n-    \/\/                   the inflating_thread's lock stack.\n-    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  inflated     - Just return it.\n@@ -1447,6 +1449,0 @@\n-      if (LockingMode == LM_LIGHTWEIGHT && inf->is_owner_anonymous() &&\n-          inflating_thread != nullptr && inflating_thread->lock_stack().contains(object)) {\n-        inf->set_owner_from_anonymous(inflating_thread);\n-        size_t removed = inflating_thread->lock_stack().remove(object);\n-        inf->set_recursions(removed - 1);\n-      }\n@@ -1456,65 +1452,9 @@\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ New lightweight locking does not use INFLATING.\n-      \/\/ CASE: inflation in progress - inflating over a stack-lock.\n-      \/\/ Some other thread is converting from stack-locked to inflated.\n-      \/\/ Only that thread can complete inflation -- other threads must wait.\n-      \/\/ The INFLATING value is transient.\n-      \/\/ Currently, we spin\/yield\/park and poll the markword, waiting for inflation to finish.\n-      \/\/ We could always eliminate polling by parking the thread on some auxiliary list.\n-      if (mark == markWord::INFLATING()) {\n-        read_stable_mark(object);\n-        continue;\n-      }\n-    }\n-\n-    \/\/ CASE: fast-locked\n-    \/\/ Could be fast-locked either by the inflating_thread or by some other thread.\n-    \/\/\n-    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_\n-    \/\/ attempting to set the object's mark to the new ObjectMonitor. If\n-    \/\/ the inflating_thread owns the monitor, then we set the ObjectMonitor's\n-    \/\/ owner to the inflating_thread. Otherwise, we set the ObjectMonitor's owner\n-    \/\/ to anonymous. If we lose the race to set the object's mark to the\n-    \/\/ new ObjectMonitor, then we just delete it and loop around again.\n-    \/\/\n-    LogStreamHandle(Trace, monitorinflation) lsh;\n-    if (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked()) {\n-      ObjectMonitor* monitor = new ObjectMonitor(object);\n-      monitor->set_header(mark.set_unlocked());\n-      bool own = inflating_thread != nullptr && inflating_thread->lock_stack().contains(object);\n-      if (own) {\n-        \/\/ Owned by inflating_thread.\n-        monitor->set_owner_from(nullptr, inflating_thread);\n-      } else {\n-        \/\/ Owned by somebody else.\n-        monitor->set_owner_anonymous();\n-      }\n-      markWord monitor_mark = markWord::encode(monitor);\n-      markWord old_mark = object->cas_set_mark(monitor_mark, mark);\n-      if (old_mark == mark) {\n-        \/\/ Success! Return inflated monitor.\n-        if (own) {\n-          size_t removed = inflating_thread->lock_stack().remove(object);\n-          monitor->set_recursions(removed - 1);\n-        }\n-        \/\/ Once the ObjectMonitor is configured and object is associated\n-        \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n-        _in_use_list.add(monitor);\n-\n-        \/\/ Hopefully the performance counters are allocated on distinct\n-        \/\/ cache lines to avoid false sharing on MP systems ...\n-        OM_PERFDATA_OP(Inflations, inc());\n-        if (log_is_enabled(Trace, monitorinflation)) {\n-          ResourceMark rm;\n-          lsh.print_cr(\"inflate(has_locker): object=\" INTPTR_FORMAT \", mark=\"\n-                       INTPTR_FORMAT \", type='%s'\", p2i(object),\n-                       object->mark().value(), object->klass()->external_name());\n-        }\n-        if (event.should_commit()) {\n-          post_monitor_inflate_event(&event, object, cause);\n-        }\n-        return monitor;\n-      } else {\n-        delete monitor;\n-        continue;  \/\/ Interference -- just retry\n-      }\n+    \/\/ CASE: inflation in progress - inflating over a stack-lock.\n+    \/\/ Some other thread is converting from stack-locked to inflated.\n+    \/\/ Only that thread can complete inflation -- other threads must wait.\n+    \/\/ The INFLATING value is transient.\n+    \/\/ Currently, we spin\/yield\/park and poll the markword, waiting for inflation to finish.\n+    \/\/ We could always eliminate polling by parking the thread on some auxiliary list.\n+    if (mark == markWord::INFLATING()) {\n+      read_stable_mark(object);\n+      continue;\n@@ -1534,0 +1474,1 @@\n+    LogStreamHandle(Trace, monitorinflation) lsh;\n@@ -1535,1 +1476,0 @@\n-      assert(LockingMode != LM_LIGHTWEIGHT, \"cannot happen with new lightweight locking\");\n@@ -1667,0 +1607,1 @@\n+  Thread* current = Thread::current();\n@@ -1673,1 +1614,1 @@\n-    if (mid->deflate_monitor()) {\n+    if (mid->deflate_monitor(current)) {\n@@ -1691,0 +1632,5 @@\n+    if (thread->is_Java_thread()) {\n+      \/\/ Clear OM cache\n+      JavaThread* jt = JavaThread::cast(thread);\n+      jt->om_clear_monitor_cache();\n+    }\n@@ -1837,0 +1783,8 @@\n+#ifdef ASSERT\n+    if (UseObjectMonitorTable) {\n+      for (ObjectMonitor* monitor : delete_list) {\n+        assert(!LightweightSynchronizer::contains_monitor(current, monitor), \"Should have been removed\");\n+      }\n+    }\n+#endif\n+\n@@ -2045,1 +1999,2 @@\n-  if (n->header().value() == 0) {\n+\n+  if (n->metadata() == 0) {\n@@ -2047,1 +2002,1 @@\n-                  \"have non-null _header field.\", p2i(n));\n+                  \"have non-null _metadata (header\/hash) field.\", p2i(n));\n@@ -2050,0 +2005,1 @@\n+\n@@ -2051,17 +2007,21 @@\n-  if (obj != nullptr) {\n-    const markWord mark = obj->mark();\n-    if (!mark.has_monitor()) {\n-      out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n-                    \"object does not think it has a monitor: obj=\"\n-                    INTPTR_FORMAT \", mark=\" INTPTR_FORMAT, p2i(n),\n-                    p2i(obj), mark.value());\n-      *error_cnt_p = *error_cnt_p + 1;\n-    }\n-    ObjectMonitor* const obj_mon = mark.monitor();\n-    if (n != obj_mon) {\n-      out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n-                    \"object does not refer to the same monitor: obj=\"\n-                    INTPTR_FORMAT \", mark=\" INTPTR_FORMAT \", obj_mon=\"\n-                    INTPTR_FORMAT, p2i(n), p2i(obj), mark.value(), p2i(obj_mon));\n-      *error_cnt_p = *error_cnt_p + 1;\n-    }\n+  if (obj == nullptr) {\n+    return;\n+  }\n+\n+  const markWord mark = obj->mark();\n+  if (!mark.has_monitor()) {\n+    out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n+                  \"object does not think it has a monitor: obj=\"\n+                  INTPTR_FORMAT \", mark=\" INTPTR_FORMAT, p2i(n),\n+                  p2i(obj), mark.value());\n+    *error_cnt_p = *error_cnt_p + 1;\n+    return;\n+  }\n+\n+  ObjectMonitor* const obj_mon = read_monitor(Thread::current(), obj, mark);\n+  if (n != obj_mon) {\n+    out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n+                  \"object does not refer to the same monitor: obj=\"\n+                  INTPTR_FORMAT \", mark=\" INTPTR_FORMAT \", obj_mon=\"\n+                  INTPTR_FORMAT, p2i(n), p2i(obj), mark.value(), p2i(obj_mon));\n+    *error_cnt_p = *error_cnt_p + 1;\n@@ -2090,1 +2050,1 @@\n-        const markWord mark = monitor->header();\n+        const intptr_t hash = UseObjectMonitorTable ? monitor->hash() : monitor->header().hash();\n@@ -2093,1 +2053,1 @@\n-                   monitor->is_busy(), mark.hash() != 0, monitor->owner() != nullptr,\n+                   monitor->is_busy(), hash != 0, monitor->owner() != nullptr,\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":228,"deletions":268,"binary":false,"changes":496,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -96,2 +97,3 @@\n-  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n-  static void exit(oop obj, BasicLock* lock, JavaThread* current);\n+  static inline void enter(Handle obj, BasicLock* lock, JavaThread* current);\n+  static inline void exit(oop obj, BasicLock* lock, JavaThread* current);\n+\n@@ -109,0 +111,3 @@\n+  static bool quick_enter_legacy(oop obj, BasicLock* Lock, JavaThread* current);\n+  static void enter_legacy(Handle obj, BasicLock* Lock, JavaThread* current);\n+  static void exit_legacy(oop obj, BasicLock* lock, JavaThread* current);\n@@ -121,1 +126,1 @@\n-  static bool quick_enter(oop obj, JavaThread* current, BasicLock* Lock);\n+  static inline bool quick_enter(oop obj, BasicLock* Lock, JavaThread* current);\n@@ -135,1 +140,1 @@\n-  static ObjectMonitor* inflate_impl(JavaThread* thread, oop obj, const InflateCause cause);\n+  static ObjectMonitor* inflate_impl(oop obj, const InflateCause cause);\n@@ -142,0 +147,3 @@\n+  inline static ObjectMonitor* read_monitor(markWord mark);\n+  inline static ObjectMonitor* read_monitor(Thread* current, oop obj, markWord mark);\n+\n@@ -203,0 +211,1 @@\n+  friend class LightweightSynchronizer;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_SYNCHRONIZER_INLINE_HPP\n+#define SHARE_RUNTIME_SYNCHRONIZER_INLINE_HPP\n+\n+#include \"runtime\/synchronizer.hpp\"\n+\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+\n+inline ObjectMonitor* ObjectSynchronizer::read_monitor(markWord mark) {\n+  return mark.monitor();\n+}\n+\n+inline ObjectMonitor* ObjectSynchronizer::read_monitor(Thread* current, oop obj, markWord mark) {\n+  if (!UseObjectMonitorTable) {\n+    return read_monitor(mark);\n+  } else {\n+    return LightweightSynchronizer::get_monitor_from_table(current, obj);\n+  }\n+}\n+\n+inline void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n+  assert(current == Thread::current(), \"must be\");\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LightweightSynchronizer::enter(obj, lock, current);\n+  } else {\n+    enter_legacy(obj, lock, current);\n+  }\n+}\n+\n+inline bool ObjectSynchronizer::quick_enter(oop obj, BasicLock* lock, JavaThread* current) {\n+  assert(current->thread_state() == _thread_in_Java, \"invariant\");\n+  NoSafepointVerifier nsv;\n+  if (obj == nullptr) return false;       \/\/ Need to throw NPE\n+\n+  if (obj->klass()->is_value_based()) {\n+    return false;\n+  }\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    return LightweightSynchronizer::quick_enter(obj, lock, current);\n+  } else {\n+    return quick_enter_legacy(obj, lock, current);\n+  }\n+}\n+\n+inline void ObjectSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n+  current->dec_held_monitor_count();\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LightweightSynchronizer::exit(object, current);\n+  } else {\n+    exit_legacy(object, lock, current);\n+  }\n+}\n+\n+#endif \/\/ SHARE_RUNTIME_SYNCHRONIZER_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -53,1 +53,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -250,3 +250,6 @@\n-          if (mark.has_monitor() &&\n-              ( \/\/ we have marked ourself as pending on this monitor\n-                mark.monitor() == thread()->current_pending_monitor() ||\n+          if (mark.has_monitor()) {\n+            ObjectMonitor* mon = ObjectSynchronizer::read_monitor(current, monitor->owner(), mark);\n+            if (\/\/ if the monitor is null we must be in the process of locking\n+                mon == nullptr ||\n+                \/\/ we have marked ourself as pending on this monitor\n+                mon == thread()->current_pending_monitor() ||\n@@ -254,3 +257,3 @@\n-                !mark.monitor()->is_entered(thread())\n-              )) {\n-            lock_state = \"waiting to lock\";\n+                !mon->is_entered(thread())) {\n+              lock_state = \"waiting to lock\";\n+            }\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -90,1 +90,2 @@\n-  template(JFRCheckpoint)                         \\\n+  template(JFRSafepointClear)                     \\\n+  template(JFRSafepointWrite)                     \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -249,1 +249,0 @@\n-  nonstatic_field(InstanceKlass,               _is_marked_dependent,                          bool)                                  \\\n@@ -781,1 +780,1 @@\n-  volatile_nonstatic_field(ObjectMonitor,      _header,                                       markWord)                              \\\n+  volatile_nonstatic_field(ObjectMonitor,      _metadata,                                     uintptr_t)                             \\\n@@ -785,1 +784,1 @@\n-  volatile_nonstatic_field(BasicLock,          _displaced_header,                             markWord)                              \\\n+  volatile_nonstatic_field(BasicLock,          _metadata,                                     uintptr_t)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,0 +131,16 @@\n+bool ClassLoadingService::get_verbose() {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n+    \/\/ set_verbose looks for a non-exact match for class+load,\n+    \/\/ so look for all tag sets that match class+load*\n+    if (ts->contains(LogTag::_class) &&\n+        ts->contains(LogTag::_load)) {\n+      LogLevelType l = ts->level_for(LogConfiguration::StdoutLog);\n+      if (l != LogLevel::Info && l != LogLevel::Debug && l != LogLevel::Trace) {\n+        return false;\n+      }\n+    }\n+  }\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/classLoadingService.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+  static bool get_verbose() NOT_MANAGEMENT_RETURN_(false);\n@@ -66,1 +67,0 @@\n-  static bool get_verbose() { return log_is_enabled(Info, class, load); }\n","filename":"src\/hotspot\/share\/services\/classLoadingService.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -205,0 +205,15 @@\n+bool MemoryService::get_verbose() {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n+    \/\/ set_verbose only sets gc and not gc*, so check for an exact match\n+    const bool is_gc_exact_match = ts->contains(LogTag::_gc) && ts->ntags() == 1;\n+    if (is_gc_exact_match) {\n+      LogLevelType l = ts->level_for(LogConfiguration::StdoutLog);\n+      if (l == LogLevel::Info || l == LogLevel::Debug || l == LogLevel::Trace) {\n+        return true;\n+      }\n+    }\n+  }\n+\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/memoryService.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,0 @@\n-  static bool get_verbose() { return log_is_enabled(Info, gc); }\n@@ -111,0 +110,1 @@\n+  static bool get_verbose();\n","filename":"src\/hotspot\/share\/services\/memoryService.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -314,0 +314,3 @@\n+#define THROW_HANDLE_NULL(e)                THROW_HANDLE_(e, nullptr)\n+#define THROW_ARG_NULL(name, signature, arg) THROW_ARG_(name, signature, arg, nullptr)\n+\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -31,0 +32,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -42,0 +44,92 @@\n+    static abstract class StringConcatBase {\n+        @Stable\n+        final String[] constants;\n+        final int      length;\n+        final byte     coder;\n+\n+        StringConcatBase(String[] constants) {\n+            int  length = 0;\n+            byte coder  = String.LATIN1;\n+            for (String c : constants) {\n+                length += c.length();\n+                coder  |= c.coder();\n+            }\n+            this.constants = constants;\n+            this.length    = length;\n+            this.coder     = coder;\n+        }\n+    }\n+\n+    static final class Concat1 extends StringConcatBase {\n+        Concat1(String[] constants) {\n+            super(constants);\n+        }\n+\n+        @ForceInline\n+        String concat0(String value) {\n+            int length = stringSize(this.length, value);\n+            byte coder = (byte) (this.coder | value.coder());\n+            byte[] buf = newArray(length << coder);\n+            String prefix = constants[0];\n+            prefix.getBytes(buf, 0, coder);\n+            value.getBytes(buf, prefix.length(), coder);\n+            constants[1].getBytes(buf, prefix.length() + value.length(), coder);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(boolean value) {\n+            int length = stringSize(this.length, value);\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(char value) {\n+            int length = stringSize(this.length, value);\n+            byte coder = (byte) (this.coder | stringCoder(value));\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(int value) {\n+            int length = stringSize(this.length, value);\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(long value) {\n+            int length = stringSize(this.length, value);\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(Object value) {\n+            return concat0(stringOf(value));\n+        }\n+\n+        @ForceInline\n+        String concat(float value) {\n+            return concat0(Float.toString(value));\n+        }\n+\n+        @ForceInline\n+        String concat(double value) {\n+            return concat0(Double.toString(value));\n+        }\n+    }\n@@ -378,0 +472,58 @@\n+    static String stringOf(float value) {\n+        return Float.toString(value);\n+    }\n+\n+    static String stringOf(double value) {\n+        return Double.toString(value);\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, char value) {\n+        return checkOverflow(length + 1);\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, boolean value) {\n+        return checkOverflow(length + (value ? 4 : 5));\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, int value) {\n+        return checkOverflow(length + DecimalDigits.stringSize(value));\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, long value) {\n+        return checkOverflow(length + DecimalDigits.stringSize(value));\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, String value) {\n+        return checkOverflow(length + value.length());\n+    }\n+\n@@ -443,0 +595,191 @@\n+    \/**\n+     * Allocates an uninitialized byte array based on the length and coder\n+     * information, then prepends the given suffix string at the end of the\n+     * byte array before returning it. The calling code must adjust the\n+     * indexCoder so that it's taken the coder of the suffix into account, but\n+     * subtracted the length of the suffix.\n+     *\n+     * @param suffix\n+     * @param indexCoder\n+     * @return the newly allocated byte array\n+     *\/\n+    @ForceInline\n+    static byte[] newArrayWithSuffix(String suffix, int index, byte coder) {\n+        byte[] buf = newArray((index + suffix.length()) << coder);\n+        if (coder == String.LATIN1) {\n+            suffix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            suffix.getBytes(buf, index, String.UTF16);\n+        }\n+        return buf;\n+    }\n+\n+    \/**\n+     * Return the coder for the character.\n+     * @param value character\n+     * @return      coder\n+     *\/\n+    static byte stringCoder(char value) {\n+        return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      boolean value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, boolean value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            if (value) {\n+                index -= 4;\n+                buf[index] = 't';\n+                buf[index + 1] = 'r';\n+                buf[index + 2] = 'u';\n+                buf[index + 3] = 'e';\n+            } else {\n+                index -= 5;\n+                buf[index] = 'f';\n+                buf[index + 1] = 'a';\n+                buf[index + 2] = 'l';\n+                buf[index + 3] = 's';\n+                buf[index + 4] = 'e';\n+            }\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            if (value) {\n+                index -= 4;\n+                StringUTF16.putChar(buf, index, 't');\n+                StringUTF16.putChar(buf, index + 1, 'r');\n+                StringUTF16.putChar(buf, index + 2, 'u');\n+                StringUTF16.putChar(buf, index + 3, 'e');\n+            } else {\n+                index -= 5;\n+                StringUTF16.putChar(buf, index, 'f');\n+                StringUTF16.putChar(buf, index + 1, 'a');\n+                StringUTF16.putChar(buf, index + 2, 'l');\n+                StringUTF16.putChar(buf, index + 3, 's');\n+                StringUTF16.putChar(buf, index + 4, 'e');\n+            }\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      char value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, char value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            buf[--index] = (byte) (value & 0xFF);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            StringUTF16.putChar(buf, --index, value);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      int value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, int value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            index = StringLatin1.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            index = StringUTF16.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      long value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, long value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            index = StringLatin1.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            index = StringUTF16.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      boolean value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, String value, String prefix) {\n+        index -= value.length();\n+        if (coder == String.LATIN1) {\n+            value.getBytes(buf, index, String.LATIN1);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            value.getBytes(buf, index, String.UTF16);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Check for overflow, throw exception on overflow.\n+     *\n+     * @param value\n+     * @return the given parameter value, if valid\n+     *\/\n+    @ForceInline\n+    static int checkOverflow(int value) {\n+        if (value >= 0) {\n+            return value;\n+        }\n+        throw new OutOfMemoryError(\"Overflow: String length out of range\");\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":343,"deletions":0,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -2626,0 +2626,4 @@\n+            public Object stringConcat1(String[] constants) {\n+                return new StringConcatHelper.Concat1(constants);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,16 @@\n- * Models an annotation on a declaration.\n+ * Models an {@code annotation} structure (JVMS {@jvms 4.7.16}) or part of a {@code\n+ * type_annotation} structure (JVMS {@jvms 4.7.20}). This model indicates the\n+ * interface of the annotation and a set of element-value pairs.\n+ * <p>\n+ * This model can reconstruct an annotation, given the location of the modeled structure\n+ * in the class file and the definition of the annotation interface.\n+ * <p>\n+ * Two {@code Annotation} objects should be compared using the {@link\n+ * Object#equals(Object) equals} method.\n+ *\n+ * @apiNote\n+ * For Java programs, the location of the modeled structure indicates the source code\n+ * element or type (JLS {@jls 9.7.4}) on which the reconstructed annotation appears,\n+ * and the annotation interface definition determines whether the reconstructed annotation has\n+ * elements with default values (JLS {@jls 9.6.2}), and whether the reconstructed annotation\n+ * is a container annotation for multiple annotations (JLS {@jls 9.7.5}).\n@@ -44,0 +59,1 @@\n+ * @see TypeAnnotation\n@@ -49,1 +65,0 @@\n- * @sealedGraph\n@@ -54,1 +69,1 @@\n-        permits TypeAnnotation, AnnotationImpl {\n+        permits AnnotationImpl {\n@@ -57,1 +72,2 @@\n-     * {@return the class of the annotation}\n+     * {@return the constant pool entry holding the {@linkplain Class#descriptorString\n+     * descriptor string} of the annotation interface}\n@@ -62,1 +78,1 @@\n-     * {@return the class of the annotation, as a symbolic descriptor}\n+     * {@return the annotation interface, as a symbolic descriptor}\n@@ -69,1 +85,1 @@\n-     * {@return the elements of the annotation}\n+     * {@return the element-value pairs of the annotation}\n@@ -75,2 +91,3 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the constant pool entry holding the descriptor string\n+     *                        of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n@@ -85,2 +102,3 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the constant pool entry holding the descriptor string\n+     *                        of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n@@ -95,2 +113,2 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the descriptor of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n@@ -105,2 +123,2 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the descriptor of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Annotation.java","additions":32,"deletions":14,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -35,1 +35,7 @@\n- * Models a key-value pair of an annotation.\n+ * Models an element-value pair in the {@code element_value_pairs}\n+ * table in the {@code annotation} structure defined in JVMS\n+ * {@jvms 4.7.16} or the {@code type_annotation} structure defined\n+ * in JVMS {@jvms 4.7.20}.\n+ * <p>\n+ * Two {@code AnnotationElement} objects should be compared using the\n+ * {@link Object#equals(Object) equals} method.\n@@ -48,0 +54,6 @@\n+     *\n+     * @apiNote\n+     * In Java source code, by convention, the name of the sole element in a\n+     * single-element annotation interface is {@code value}. (JLS {@jls 9.6.1})\n+     * This is the case for single-element annotations (JLS {@jls 9.7.3}) and\n+     * container annotations for multiple annotations (JLS {@jls 9.6.3}).\n@@ -57,1 +69,1 @@\n-     * {@return an annotation key-value pair}\n+     * {@return an element-value pair}\n@@ -67,1 +79,1 @@\n-     * {@return an annotation key-value pair}\n+     * {@return an element-value pair}\n@@ -77,1 +89,1 @@\n-     * {@return an annotation key-value pair for a class-valued annotation}\n+     * {@return an element-value pair for a class-valued element}\n@@ -80,0 +92,1 @@\n+     * @see AnnotationValue#ofClass(ClassDesc) AnnotationValue::ofClass\n@@ -87,1 +100,1 @@\n-     * {@return an annotation key-value pair for a string-valued annotation}\n+     * {@return an element-value pair for a string-valued element}\n@@ -90,0 +103,1 @@\n+     * @see AnnotationValue#ofString(String) AnnotationValue::ofString\n@@ -97,1 +111,1 @@\n-     * {@return an annotation key-value pair for a long-valued annotation}\n+     * {@return an element-value pair for a long-valued element}\n@@ -100,0 +114,1 @@\n+     * @see AnnotationValue#ofLong(long) AnnotationValue::ofLong\n@@ -107,1 +122,1 @@\n-     * {@return an annotation key-value pair for an int-valued annotation}\n+     * {@return an element-value pair for an int-valued element}\n@@ -110,0 +125,1 @@\n+     * @see AnnotationValue#ofInt(int) AnnotationValue::ofInt\n@@ -117,1 +133,1 @@\n-     * {@return an annotation key-value pair for a char-valued annotation}\n+     * {@return an element-value pair for a char-valued element}\n@@ -120,0 +136,1 @@\n+     * @see AnnotationValue#ofChar(char) AnnotationValue::ofChar\n@@ -127,1 +144,1 @@\n-     * {@return an annotation key-value pair for a short-valued annotation}\n+     * {@return an element-value pair for a short-valued element}\n@@ -130,0 +147,1 @@\n+     * @see AnnotationValue#ofShort(short) AnnotationValue::ofShort\n@@ -137,1 +155,1 @@\n-     * {@return an annotation key-value pair for a byte-valued annotation}\n+     * {@return an element-value pair for a byte-valued element}\n@@ -140,0 +158,1 @@\n+     * @see AnnotationValue#ofByte(byte) AnnotationValue::ofByte\n@@ -142,1 +161,1 @@\n-                                      byte value) {\n+                                    byte value) {\n@@ -147,1 +166,1 @@\n-     * {@return an annotation key-value pair for a boolean-valued annotation}\n+     * {@return an element-value pair for a boolean-valued element}\n@@ -150,0 +169,1 @@\n+     * @see AnnotationValue#ofBoolean(boolean) AnnotationValue::ofBoolean\n@@ -152,1 +172,1 @@\n-                                      boolean value) {\n+                                       boolean value) {\n@@ -157,1 +177,1 @@\n-     * {@return an annotation key-value pair for a double-valued annotation}\n+     * {@return an element-value pair for a double-valued element}\n@@ -160,0 +180,1 @@\n+     * @see AnnotationValue#ofDouble(double) AnnotationValue::ofDouble\n@@ -167,1 +188,1 @@\n-     * {@return an annotation key-value pair for a float-valued annotation}\n+     * {@return an element-value pair for a float-valued element}\n@@ -170,0 +191,1 @@\n+     * @see AnnotationValue#ofFloat(float) AnnotationValue::ofFloat\n@@ -177,1 +199,1 @@\n-     * {@return an annotation key-value pair for an annotation-valued annotation}\n+     * {@return an element-value pair for an annotation-valued element}\n@@ -180,0 +202,1 @@\n+     * @see AnnotationValue#ofAnnotation AnnotationValue::ofAnnotation\n@@ -187,1 +210,1 @@\n-     * {@return an annotation key-value pair for an array-valued annotation}\n+     * {@return an element-value pair for an array-valued element}\n@@ -190,0 +213,1 @@\n+     * @see AnnotationValue#ofArray(AnnotationValue...) AnnotationValue::ofArray\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationElement.java","additions":41,"deletions":17,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -44,1 +44,5 @@\n- * Models the value of a key-value pair of an annotation.\n+ * Models an {@code element_value} structure, or a value of an element-value\n+ * pair of an annotation, as defined in JVMS {@jvms 4.7.16.1}.\n+ * <p>\n+ * Two {@code AnnotationValue} objects should be compared using the {@link\n+ * Object#equals(Object) equals} method.\n@@ -56,2 +60,2 @@\n-     * Models an annotation-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_ANNOTATION}.\n+     * Models an annotation value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_ANNOTATION}.\n@@ -69,2 +73,2 @@\n-     * Models an array-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_ARRAY}.\n+     * Models an array value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_ARRAY}.\n@@ -82,1 +86,3 @@\n-         * which must not be an array type. ({@jls 9.6.1})\n+         * which must not be an array type. (JLS {@jls 9.6.1}) If such elements are\n+         * annotations, they have the same annotation interface; if such elements\n+         * are enum, they belong to the same enum class.\n@@ -88,1 +94,1 @@\n-     * Models a constant-valued element.\n+     * Models a constant value of an element-value pair.\n@@ -94,4 +100,1 @@\n-    sealed interface OfConstant\n-            extends AnnotationValue\n-            permits OfString, OfDouble, OfFloat, OfLong, OfInt, OfShort, OfChar, OfByte,\n-                    OfBoolean, AnnotationImpl.OfConstantImpl {\n+    sealed interface OfConstant extends AnnotationValue {\n@@ -126,2 +129,2 @@\n-     * Models a string-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_STRING}.\n+     * Models a string value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_STRING}.\n@@ -154,2 +157,2 @@\n-     * Models a double-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_DOUBLE}.\n+     * Models a double value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_DOUBLE}.\n@@ -182,2 +185,2 @@\n-     * Models a float-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_FLOAT}.\n+     * Models a float value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_FLOAT}.\n@@ -210,2 +213,2 @@\n-     * Models a long-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_LONG}.\n+     * Models a long value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_LONG}.\n@@ -238,2 +241,2 @@\n-     * Models an int-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_INT}.\n+     * Models an int value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_INT}.\n@@ -266,2 +269,2 @@\n-     * Models a short-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_SHORT}.\n+     * Models a short value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_SHORT}.\n@@ -297,2 +300,2 @@\n-     * Models a char-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_CHAR}.\n+     * Models a char value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_CHAR}.\n@@ -328,2 +331,2 @@\n-     * Models a byte-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_BYTE}.\n+     * Models a byte value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_BYTE}.\n@@ -359,2 +362,2 @@\n-     * Models a boolean-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_BOOLEAN}.\n+     * Models a boolean value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_BOOLEAN}.\n@@ -390,2 +393,2 @@\n-     * Models a class-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_CLASS}.\n+     * Models a class value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_CLASS}.\n@@ -408,2 +411,2 @@\n-     * Models an enum-valued element.\n-     * The {@linkplain #tag tag} of this element is {@value ClassFile#AEV_ENUM}.\n+     * Models an enum value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_ENUM}.\n@@ -429,1 +432,2 @@\n-     * {@return the tag character for this type as per {@jvms 4.7.16.1}}\n+     * {@return the tag character for this value as per JVMS {@jvms 4.7.16.1}}\n+     * The tag characters have a one-to-one mapping to the types of annotation element values.\n@@ -434,1 +438,1 @@\n-     * {@return an annotation element for a enum-valued element}\n+     * {@return an enum value for an element-value pair}\n@@ -444,1 +448,1 @@\n-     * {@return an annotation element for a enum-valued element}\n+     * {@return an enum value for an element-value pair}\n@@ -454,1 +458,1 @@\n-     * {@return an annotation element for a class-valued element}\n+     * {@return a class value for an element-value pair}\n@@ -462,1 +466,1 @@\n-     * {@return an annotation element for a class-valued element}\n+     * {@return a class value for an element-value pair}\n@@ -470,1 +474,1 @@\n-     * {@return an annotation element for a string-valued element}\n+     * {@return a string value for an element-value pair}\n@@ -478,1 +482,1 @@\n-     * {@return an annotation element for a string-valued element}\n+     * {@return a string value for an element-value pair}\n@@ -486,1 +490,1 @@\n-     * {@return an annotation element for a double-valued element}\n+     * {@return a double value for an element-value pair}\n@@ -494,1 +498,1 @@\n-     * {@return an annotation element for a double-valued element}\n+     * {@return a double value for an element-value pair}\n@@ -502,1 +506,1 @@\n-     * {@return an annotation element for a float-valued element}\n+     * {@return a float value for an element-value pair}\n@@ -510,1 +514,1 @@\n-     * {@return an annotation element for a float-valued element}\n+     * {@return a float value for an element-value pair}\n@@ -518,1 +522,1 @@\n-     * {@return an annotation element for a long-valued element}\n+     * {@return a long value for an element-value pair}\n@@ -526,1 +530,1 @@\n-     * {@return an annotation element for a long-valued element}\n+     * {@return a long value for an element-value pair}\n@@ -534,1 +538,1 @@\n-     * {@return an annotation element for an int-valued element}\n+     * {@return an int value for an element-value pair}\n@@ -542,1 +546,1 @@\n-     * {@return an annotation element for an int-valued element}\n+     * {@return an int value for an element-value pair}\n@@ -550,1 +554,1 @@\n-     * {@return an annotation element for a short-valued element}\n+     * {@return a short value for an element-value pair}\n@@ -558,1 +562,1 @@\n-     * {@return an annotation element for a short-valued element}\n+     * {@return a short value for an element-value pair}\n@@ -566,1 +570,1 @@\n-     * {@return an annotation element for a char-valued element}\n+     * {@return a char value for an element-value pair}\n@@ -574,1 +578,1 @@\n-     * {@return an annotation element for a char-valued element}\n+     * {@return a char value for an element-value pair}\n@@ -582,1 +586,1 @@\n-     * {@return an annotation element for a byte-valued element}\n+     * {@return a byte value for an element-value pair}\n@@ -590,1 +594,1 @@\n-     * {@return an annotation element for a byte-valued element}\n+     * {@return a byte value for an element-value pair}\n@@ -598,1 +602,1 @@\n-     * {@return an annotation element for a boolean-valued element}\n+     * {@return a boolean value for an element-value pair}\n@@ -606,1 +610,1 @@\n-     * {@return an annotation element for a boolean-valued element}\n+     * {@return a boolean value for an element-value pair}\n@@ -615,1 +619,1 @@\n-     * {@return an annotation element for an annotation-valued element}\n+     * {@return an annotation value for an element-value pair}\n@@ -623,1 +627,6 @@\n-     * {@return an annotation element for an array-valued element}\n+     * {@return an array value for an element-value pair}\n+     *\n+     * @apiNote\n+     * See {@link AnnotationValue.OfArray#values() values()} for conventions\n+     * on array values derived from Java source code.\n+     *\n@@ -631,1 +640,6 @@\n-     * {@return an annotation element for an array-valued element}\n+     * {@return an array value for an element-value pair}\n+     *\n+     * @apiNote\n+     * See {@link AnnotationValue.OfArray#values() values()} for conventions\n+     * on array values derived from Java source code.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationValue.java","additions":73,"deletions":59,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n- * Models a classfile attribute {@jvms 4.7}.  Many, though not all, subtypes of\n+ * Models a classfile attribute (JVMS {@jvms 4.7}).  Many, though not all, subtypes of\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-        return withField(name, descriptor, fb -> fb.withFlags(flags));\n+        return withField(name, descriptor, Util.buildingFlags(flags));\n@@ -197,1 +197,1 @@\n-        return withField(name, descriptor, fb -> fb.withFlags(flags));\n+        return withField(name, descriptor, Util.buildingFlags(flags));\n@@ -244,1 +244,1 @@\n-        return withMethod(name, descriptor, methodFlags, mb -> mb.withCode(handler));\n+        return withMethod(name, descriptor, methodFlags, Util.buildingCode(handler));\n@@ -279,4 +279,1 @@\n-        return withMethodBody(constantPool().utf8Entry(name),\n-                              constantPool().utf8Entry(descriptor),\n-                              methodFlags,\n-                              handler);\n+        return withMethod(name, descriptor, methodFlags, Util.buildingCode(handler));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassBuilder.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * Models the generic signature of a class file, as defined by {@jvms 4.7.9}.\n+ * Models the generic signature of a class file, as defined by JVMS {@jvms 4.7.9}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassSignature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * Models the generic signature of a method, as defined by {@jvms 4.7.9}.\n+ * Models the generic signature of a method, as defined by JVMS {@jvms 4.7.9}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodSignature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * Describes the opcodes of the JVM instruction set, as described in {@jvms 6.5}.\n+ * Describes the opcodes of the JVM instruction set, as described in JVMS {@jvms 6.5}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Opcode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * Models generic Java type signatures, as defined in {@jvms 4.7.9.1}.\n+ * Models generic Java type signatures, as defined in JVMS {@jvms 4.7.9.1}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Signature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.lang.constant.ClassDesc;\n@@ -33,1 +32,0 @@\n-import java.lang.classfile.constantpool.Utf8Entry;\n@@ -59,1 +57,0 @@\n-import jdk.internal.classfile.impl.TemporaryConstantPool;\n@@ -63,1 +60,11 @@\n- * Models an annotation on a type use, as defined in {@jvms 4.7.19} and {@jvms 4.7.20}.\n+ * Models a {@code type_annotation} structure (JVMS {@jvms 4.7.20}). This model\n+ * indicates the annotated type within a declaration or expression and the part\n+ * of the indicated type that is annotated, in addition to what is {@linkplain\n+ * #annotation() available} in an {@code Annotation}.\n+ * <p>\n+ * This model can reconstruct an annotation on a type or a part of a type, given\n+ * the location of the {@code type_annotation} structure in the class file and\n+ * the definition of the annotation interface.\n+ * <p>\n+ * Two {@code TypeAnnotation} objects should be compared using the {@link\n+ * Object#equals(Object) equals} method.\n@@ -65,0 +72,1 @@\n+ * @see Annotation\n@@ -72,1 +80,0 @@\n-        extends Annotation\n@@ -76,1 +83,1 @@\n-     * The kind of target on which the annotation appears, as defined in {@jvms 4.7.20.1}.\n+     * The kind of target on which the annotation appears, as defined in JVMS {@jvms 4.7.20.1}.\n@@ -173,1 +180,1 @@\n-     * is annotated}\n+     * is annotated} This models the {@code target_type} and {@code target_info} items.\n@@ -183,19 +190,4 @@\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClassUtf8Entry the annotation class\n-     * @param annotationElements the annotation elements\n-     *\/\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             Utf8Entry annotationClassUtf8Entry,\n-                             List<AnnotationElement> annotationElements) {\n-        return new UnboundAttribute.UnboundTypeAnnotation(targetInfo, targetPath,\n-                annotationClassUtf8Entry, annotationElements);\n-    }\n-\n-    \/**\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClass the annotation class\n-     * @param annotationElements the annotation elements\n+     * {@return the annotation applied to the part indicated by {@link #targetPath()}}\n+     * This models the interface of the annotation and the set of element-value pairs,\n+     * the subset of the {@code type_annotation} structure that is identical to the\n+     * {@code annotation} structure.\n@@ -203,19 +195,1 @@\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             ClassDesc annotationClass,\n-                             AnnotationElement... annotationElements) {\n-        return of(targetInfo, targetPath, annotationClass, List.of(annotationElements));\n-    }\n-\n-    \/**\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClass the annotation class\n-     * @param annotationElements the annotation elements\n-     *\/\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             ClassDesc annotationClass,\n-                             List<AnnotationElement> annotationElements) {\n-        return of(targetInfo, targetPath,\n-                TemporaryConstantPool.INSTANCE.utf8Entry(annotationClass.descriptorString()), annotationElements);\n-    }\n+    Annotation annotation();\n@@ -224,1 +198,1 @@\n-     * {@return a type annotation}\n+     * {@return a {@code type_annotation} structure}\n@@ -227,2 +201,1 @@\n-     * @param annotationClassUtf8Entry the annotation class\n-     * @param annotationElements the annotation elements\n+     * @param annotation the annotation\n@@ -231,3 +204,2 @@\n-                             Utf8Entry annotationClassUtf8Entry,\n-                             AnnotationElement... annotationElements) {\n-        return of(targetInfo, targetPath, annotationClassUtf8Entry, List.of(annotationElements));\n+                             Annotation annotation) {\n+        return new UnboundAttribute.UnboundTypeAnnotation(targetInfo, targetPath, annotation);\n@@ -776,1 +748,1 @@\n-     * as defined in {@jvms 4.7.20.2}\n+     * as defined in JVMS {@jvms 4.7.20.2}\n@@ -785,1 +757,1 @@\n-         * Type path kind, as defined in {@jvms 4.7.20.2}\n+         * Type path kind, as defined in JVMS {@jvms 4.7.20.2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeAnnotation.java","additions":26,"deletions":54,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code AnnotationDefault} attribute {@jvms 4.7.22}, which can\n+ * Models the {@code AnnotationDefault} attribute (JVMS {@jvms 4.7.22}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/AnnotationDefaultAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code BootstrapMethods} attribute {@jvms 4.7.23}, which serves as\n+ * Models the {@code BootstrapMethods} attribute (JVMS {@jvms 4.7.23}), which serves as\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/BootstrapMethodsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * Models the {@code Code} attribute {@jvms 4.7.3}, appears on non-native,\n+ * Models the {@code Code} attribute (JVMS {@jvms 4.7.3}), appears on non-native,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/CodeAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code ConstantValue} attribute {@jvms 4.7.2}, which can appear on\n+ * Models the {@code ConstantValue} attribute (JVMS {@jvms 4.7.2}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ConstantValueAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code Deprecated} attribute {@jvms 4.7.15}, which can appear on\n+ * Models the {@code Deprecated} attribute (JVMS {@jvms 4.7.15}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/DeprecatedAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * Models the {@code EnclosingMethod} attribute {@jvms 4.7.7}, which can appear\n+ * Models the {@code EnclosingMethod} attribute (JVMS {@jvms 4.7.7}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/EnclosingMethodAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * Models the {@code Exceptions} attribute {@jvms 4.7.5}, which can appear on\n+ * Models the {@code Exceptions} attribute (JVMS {@jvms 4.7.5}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ExceptionsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code InnerClasses} attribute {@jvms 4.7.6}, which can\n+ * Models the {@code InnerClasses} attribute (JVMS {@jvms 4.7.6}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/InnerClassesAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * Models the {@code LineNumberTable} attribute {@jvms 4.7.12}, which can appear\n+ * Models the {@code LineNumberTable} attribute (JVMS {@jvms 4.7.12}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LineNumberTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * Models the {@code LocalVariableTable} attribute {@jvms 4.7.13}, which can appear\n+ * Models the {@code LocalVariableTable} attribute (JVMS {@jvms 4.7.13}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LocalVariableTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code LocalVariableTypeTable} attribute {@jvms 4.7.14}, which can appear\n+ * Models the {@code LocalVariableTypeTable} attribute (JVMS {@jvms 4.7.14}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LocalVariableTypeTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code MethodParameters} attribute {@jvms 4.7.24}, which can\n+ * Models the {@code MethodParameters} attribute (JVMS {@jvms 4.7.24}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/MethodParametersAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * Models the {@code Module} attribute {@jvms 4.7.25}, which can\n+ * Models the {@code Module} attribute (JVMS {@jvms 4.7.25}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code ModuleMainClass} attribute {@jvms 4.7.27}, which can\n+ * Models the {@code ModuleMainClass} attribute (JVMS {@jvms 4.7.27}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleMainClassAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * Models the {@code ModulePackages} attribute {@jvms 4.7.26}, which can\n+ * Models the {@code ModulePackages} attribute (JVMS {@jvms 4.7.26}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModulePackagesAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code NestHost} attribute {@jvms 4.7.28}, which can\n+ * Models the {@code NestHost} attribute (JVMS {@jvms 4.7.28}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/NestHostAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * Models the {@code NestMembers} attribute {@jvms 4.7.29}, which can\n+ * Models the {@code NestMembers} attribute (JVMS {@jvms 4.7.29}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/NestMembersAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * Models the {@code PermittedSubclasses} attribute {@jvms 4.7.31}, which can\n+ * Models the {@code PermittedSubclasses} attribute (JVMS {@jvms 4.7.31}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/PermittedSubclassesAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code Record} attribute {@jvms 4.7.30}, which can\n+ * Models the {@code Record} attribute (JVMS {@jvms 4.7.30}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RecordAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code RuntimeInvisibleAnnotations} attribute {@jvms 4.7.17}, which\n+ * Models the {@code RuntimeInvisibleAnnotations} attribute (JVMS {@jvms 4.7.17}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * {@jvms 4.7.19}, which can appear on methods. Delivered as a {@link\n+ * (JVMS {@jvms 4.7.19}), which can appear on methods. Delivered as a {@link\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleParameterAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * Models the {@code RuntimeInvisibleTypeAnnotations} attribute {@jvms 4.7.21}, which\n+ * Models the {@code RuntimeInvisibleTypeAnnotations} attribute (JVMS {@jvms 4.7.21}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleTypeAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code RuntimeVisibleAnnotations} attribute {@jvms 4.7.16}, which\n+ * Models the {@code RuntimeVisibleAnnotations} attribute (JVMS {@jvms 4.7.16}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * Models the {@code RuntimeVisibleParameterAnnotations} attribute {@jvms 4.7.18}, which\n+ * Models the {@code RuntimeVisibleParameterAnnotations} attribute (JVMS {@jvms 4.7.18}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleParameterAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * Models the {@code RuntimeVisibleTypeAnnotations} attribute {@jvms 4.7.20}, which\n+ * Models the {@code RuntimeVisibleTypeAnnotations} attribute (JVMS {@jvms 4.7.20}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleTypeAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * Models the {@code Signature} attribute {@jvms 4.7.9}, which\n+ * Models the {@code Signature} attribute (JVMS {@jvms 4.7.9}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SignatureAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code SourceFile} attribute {@jvms 4.7.10}, which\n+ * Models the {@code SourceFile} attribute (JVMS {@jvms 4.7.10}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SourceFileAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * Models stack map frame of {@code StackMapTable} attribute {@jvms 4.7.4}.\n+ * Models stack map frame of {@code StackMapTable} attribute (JVMS {@jvms 4.7.4}).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapFrameInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code StackMapTable} attribute {@jvms 4.7.4}, which can appear\n+ * Models the {@code StackMapTable} attribute (JVMS {@jvms 4.7.4}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code Synthetic} attribute {@jvms 4.7.8}, which can appear on\n+ * Models the {@code Synthetic} attribute (JVMS {@jvms 4.7.8}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SyntheticAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n-     * @param refKind the reference kind of the method handle {@jvms 4.4.8}\n+     * @param refKind the reference kind of the method handle (JVMS {@jvms 4.4.8})\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-     * {@return the reference kind of this method handle {@jvms 4.4.8}}\n+     * {@return the reference kind of this method handle (JVMS {@jvms 4.4.8})}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/MethodHandleEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-     * {@return the {@code count} value of an {@code invokeinterface} instruction, as defined in {@jvms 6.5}\n+     * {@return the {@code count} value of an {@code invokeinterface} instruction, as defined in JVMS {@jvms 6.5}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/InvokeInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import static jdk.internal.constant.ConstantUtils.forPrimitiveType;\n@@ -167,1 +168,1 @@\n-               ? Wrapper.forPrimitiveType(descriptor.charAt(0)).basicClassDescriptor()\n+               ? forPrimitiveType(descriptor, 0)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-    public static final ClassDesc CD_int = new PrimitiveClassDescImpl(\"I\");\n+    public static final ClassDesc CD_int = PrimitiveClassDescImpl.CD_int;\n@@ -246,1 +246,1 @@\n-    public static final ClassDesc CD_long = new PrimitiveClassDescImpl(\"J\");\n+    public static final ClassDesc CD_long = PrimitiveClassDescImpl.CD_long;\n@@ -249,1 +249,1 @@\n-    public static final ClassDesc CD_float = new PrimitiveClassDescImpl(\"F\");\n+    public static final ClassDesc CD_float = PrimitiveClassDescImpl.CD_float;\n@@ -252,1 +252,1 @@\n-    public static final ClassDesc CD_double = new PrimitiveClassDescImpl(\"D\");\n+    public static final ClassDesc CD_double = PrimitiveClassDescImpl.CD_double;\n@@ -255,1 +255,1 @@\n-    public static final ClassDesc CD_short = new PrimitiveClassDescImpl(\"S\");\n+    public static final ClassDesc CD_short = PrimitiveClassDescImpl.CD_short;\n@@ -258,1 +258,1 @@\n-    public static final ClassDesc CD_byte = new PrimitiveClassDescImpl(\"B\");\n+    public static final ClassDesc CD_byte = PrimitiveClassDescImpl.CD_byte;\n@@ -261,1 +261,1 @@\n-    public static final ClassDesc CD_char = new PrimitiveClassDescImpl(\"C\");\n+    public static final ClassDesc CD_char = PrimitiveClassDescImpl.CD_char;\n@@ -264,1 +264,1 @@\n-    public static final ClassDesc CD_boolean = new PrimitiveClassDescImpl(\"Z\");\n+    public static final ClassDesc CD_boolean = PrimitiveClassDescImpl.CD_boolean;\n@@ -267,1 +267,1 @@\n-    public static final ClassDesc CD_void = new PrimitiveClassDescImpl(\"V\");\n+    public static final ClassDesc CD_void = PrimitiveClassDescImpl.CD_void;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.lang.invoke.InnerClassLambdaMetafactory.MethodBody;\n@@ -71,2 +70,0 @@\n-    private static final Consumer<FieldBuilder> STATIC_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_STATIC);\n-    private static final Consumer<FieldBuilder> FINAL_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_FINAL);\n@@ -628,1 +625,1 @@\n-                       .withField(sdFieldName, CD_SPECIES_DATA, STATIC_FIELD_FLAGS);\n+                       .withField(sdFieldName, CD_SPECIES_DATA, ACC_STATIC);\n@@ -712,1 +709,1 @@\n-                        clb.withField(field.name, field.desc, FINAL_FIELD_FLAGS);\n+                        clb.withField(field.name, field.desc, ACC_FINAL);\n@@ -716,2 +713,2 @@\n-                    clb.withMethod(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n-                            new MethodBody(new Consumer<CodeBuilder>() {\n+                    clb.withMethodBody(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n+                            new Consumer<>() {\n@@ -723,1 +720,1 @@\n-                            }));\n+                            });\n@@ -730,2 +727,2 @@\n-                    clb.withMethod(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE,\n-                            new MethodBody(new Consumer<CodeBuilder>() {\n+                    clb.withMethodBody(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE,\n+                            new Consumer<>() {\n@@ -756,1 +753,1 @@\n-                            }));\n+                            });\n@@ -760,2 +757,2 @@\n-                    clb.withMethod(\"make\", methodDesc(ftryType), ACC_STATIC,\n-                            new MethodBody(new Consumer<CodeBuilder>() {\n+                    clb.withMethodBody(\"make\", methodDesc(ftryType), ACC_STATIC,\n+                            new Consumer<>() {\n@@ -776,1 +773,1 @@\n-                            }));\n+                            });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.constant.ConstantUtils;\n@@ -115,1 +116,1 @@\n-        return Wrapper.forPrimitiveType(name.charAt(0)).primitiveType();\n+        return ConstantUtils.forPrimitiveType(name, 0).resolveConstantDesc(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ConstantBootstraps.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,14 +75,0 @@\n-    \/\/ Static builders to avoid lambdas\n-    record FieldFlags(int flags) implements Consumer<FieldBuilder> {\n-        @Override\n-        public void accept(FieldBuilder fb) {\n-            fb.withFlags(flags);\n-        }\n-    };\n-    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n-        @Override\n-        public void accept(MethodBuilder mb) {\n-            mb.withCode(code);\n-        }\n-    };\n-\n@@ -327,1 +313,1 @@\n-                    clb.withField(argNames[i], argDescs[i], new FieldFlags(ACC_PRIVATE | ACC_FINAL));\n+                    clb.withField(argNames[i], argDescs[i], ACC_PRIVATE | ACC_FINAL);\n@@ -337,1 +323,1 @@\n-                clb.withMethod(interfaceMethodName,\n+                clb.withMethodBody(interfaceMethodName,\n@@ -345,1 +331,1 @@\n-                        clb.withMethod(interfaceMethodName,\n+                        clb.withMethodBody(interfaceMethodName,\n@@ -379,1 +365,1 @@\n-        clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, new FieldFlags(ACC_PRIVATE | ACC_STATIC | ACC_FINAL));\n+        clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n@@ -382,1 +368,1 @@\n-        clb.withMethod(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new Consumer<>() {\n@@ -392,1 +378,1 @@\n-        }));\n+        });\n@@ -400,2 +386,2 @@\n-        clb.withMethod(INIT_NAME, constructorTypeDesc, ACC_PRIVATE,\n-                new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(INIT_NAME, constructorTypeDesc, ACC_PRIVATE,\n+                new Consumer<>() {\n@@ -415,1 +401,1 @@\n-                }));\n+                });\n@@ -442,2 +428,2 @@\n-        clb.withMethod(SerializationSupport.NAME_METHOD_WRITE_REPLACE, SerializationSupport.MTD_Object, ACC_PRIVATE | ACC_FINAL,\n-                new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(SerializationSupport.NAME_METHOD_WRITE_REPLACE, SerializationSupport.MTD_Object, ACC_PRIVATE | ACC_FINAL,\n+                new Consumer<>() {\n@@ -471,1 +457,1 @@\n-                }));\n+                });\n@@ -507,2 +493,2 @@\n-    Consumer<MethodBuilder> forwardingMethod(MethodType methodType) {\n-        return new MethodBody(new Consumer<CodeBuilder>() {\n+    Consumer<CodeBuilder> forwardingMethod(MethodType methodType) {\n+        return new Consumer<>() {\n@@ -545,1 +531,1 @@\n-        });\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":15,"deletions":29,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,15 +86,0 @@\n-    \/\/ Static builders to avoid lambdas\n-    private static final Consumer<FieldBuilder> STATIC_FINAL_FIELD = new Consumer<FieldBuilder>() {\n-        @Override\n-        public void accept(FieldBuilder fb) {\n-            fb.withFlags(ACC_STATIC | ACC_FINAL);\n-        }\n-    };\n-\n-    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n-        @Override\n-        public void accept(MethodBuilder mb) {\n-            mb.withCode(code);\n-        }\n-    };\n-\n@@ -331,1 +316,1 @@\n-            clb.withField(p.name, p.desc, STATIC_FINAL_FIELD);\n+            clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n@@ -334,1 +319,1 @@\n-        clb.withMethod(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new Consumer<>() {\n@@ -359,1 +344,1 @@\n-        }));\n+        });\n@@ -1674,1 +1659,1 @@\n-            clb.withMethod(\"dummy\", MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+            clb.withMethodBody(\"dummy\", MTD_void, ACC_STATIC, new Consumer<>() {\n@@ -1681,1 +1666,1 @@\n-            }));\n+            });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -33,0 +34,2 @@\n+import jdk.internal.util.ReferenceKey;\n+import jdk.internal.util.ReferencedKeyMap;\n@@ -36,0 +39,1 @@\n+import java.lang.classfile.Annotation;\n@@ -39,0 +43,1 @@\n+import java.lang.classfile.MethodBuilder;\n@@ -40,0 +45,1 @@\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -41,1 +47,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -44,1 +49,4 @@\n-import java.lang.reflect.AccessFlag;\n+import java.lang.ref.SoftReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n@@ -47,0 +55,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -48,0 +57,1 @@\n+import java.util.function.Supplier;\n@@ -49,1 +59,2 @@\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -110,1 +121,0 @@\n-\n@@ -112,0 +122,1 @@\n+    private static final int FORCE_INLINE_THRESHOLD;\n@@ -115,1 +126,4 @@\n-        HIGH_ARITY_THRESHOLD = highArity != null ? Integer.parseInt(highArity) : 20;\n+        HIGH_ARITY_THRESHOLD = highArity != null ? Integer.parseInt(highArity) : 0;\n+\n+        String inlineThreshold = VM.getSavedProperty(\"java.lang.invoke.StringConcat.inlineThreshold\");\n+        FORCE_INLINE_THRESHOLD = inlineThreshold != null ? Integer.parseInt(inlineThreshold) : 16;\n@@ -374,7 +388,3 @@\n-            if (concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n-                return new ConstantCallSite(\n-                        generateMHInlineCopy(concatType, constantStrings)\n-                                .viewAsType(concatType, true));\n-            } else {\n-                return new ConstantCallSite(\n-                        SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings));\n+            MethodHandle mh = makeSimpleConcat(concatType, constantStrings);\n+            if (mh == null && concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n+                mh = generateMHInlineCopy(concatType, constantStrings);\n@@ -382,0 +392,7 @@\n+\n+            if (mh == null) {\n+                mh = InlineHiddenClassStrategy.generate(lookup, concatType, constantStrings);\n+            }\n+            mh = mh.viewAsType(concatType, true);\n+\n+            return new ConstantCallSite(mh);\n@@ -430,1 +447,1 @@\n-                consts[oCount++] = acc.length() > 0 ? acc.toString() : null;\n+                consts[oCount++] = acc.length() > 0 ? acc.toString() : \"\";\n@@ -446,1 +463,1 @@\n-        consts[oCount] = acc.length() > 0 ? acc.toString() : null;\n+        consts[oCount] = acc.length() > 0 ? acc.toString() : \"\";\n@@ -469,8 +486,1 @@\n-    \/**\n-     * <p>This strategy replicates what StringBuilders are doing: it builds the\n-     * byte[] array on its own and passes that byte[] array to String\n-     * constructor. This strategy requires access to some private APIs in JDK,\n-     * most notably, the private String constructor that accepts byte[] arrays\n-     * without copying.\n-     *\/\n-    private static MethodHandle generateMHInlineCopy(MethodType mt, String[] constants) {\n+    private static MethodHandle makeSimpleConcat(MethodType mt, String[] constants) {\n@@ -487,2 +497,2 @@\n-            if (prefix == null) {\n-                if (suffix == null) {\n+            if (prefix.isEmpty()) {\n+                if (suffix.isEmpty()) {\n@@ -493,1 +503,1 @@\n-            } else if (suffix == null && !mt.hasPrimitives()) {\n+            } else if (suffix.isEmpty() && !mt.hasPrimitives()) {\n@@ -497,3 +507,2 @@\n-        }\n-        if (paramCount == 2 && !mt.hasPrimitives() && suffix == null\n-                && constants[0] == null && constants[1] == null) {\n+        } else if (paramCount == 2 && !mt.hasPrimitives() && suffix.isEmpty()\n+                && constants[0].isEmpty() && constants[1].isEmpty()) {\n@@ -503,0 +512,16 @@\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * <p>This strategy replicates what StringBuilders are doing: it builds the\n+     * byte[] array on its own and passes that byte[] array to String\n+     * constructor. This strategy requires access to some private APIs in JDK,\n+     * most notably, the private String constructor that accepts byte[] arrays\n+     * without copying.\n+     *\/\n+    private static MethodHandle generateMHInlineCopy(MethodType mt, String[] constants) {\n+        int paramCount = mt.parameterCount();\n+        String suffix = constants[paramCount];\n+\n+\n@@ -1046,1 +1071,1 @@\n-     * Bytecode StringBuilder strategy.\n+     * Implement efficient hidden class strategy for String concatenation\n@@ -1048,2 +1073,5 @@\n-     * <p>This strategy emits StringBuilder chains as similar as possible\n-     * to what javac would. No exact sizing of parameters or estimates.\n+     * <p>This strategy replicates based on the bytecode what StringBuilders are doing: it builds the\n+     * byte[] array on its own and passes that byte[] array to String\n+     * constructor. This strategy requires access to some private APIs in JDK,\n+     * most notably, the private String constructor that accepts byte[] arrays\n+     * without copying.\n@@ -1051,3 +1079,4 @@\n-    private static final class SimpleStringBuilderStrategy {\n-        static final String METHOD_NAME = \"concat\";\n-        static final ClassDesc STRING_BUILDER = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringBuilder;\");\n+    private static final class InlineHiddenClassStrategy {\n+        static final String CLASS_NAME   = \"java.lang.String$$StringConcat\";\n+        static final String METHOD_NAME  = \"concat\";\n+\n@@ -1056,10 +1085,62 @@\n-        static final MethodTypeDesc APPEND_BOOLEAN_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_boolean);\n-        static final MethodTypeDesc APPEND_CHAR_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_char);\n-        static final MethodTypeDesc APPEND_DOUBLE_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_double);\n-        static final MethodTypeDesc APPEND_FLOAT_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_float);\n-        static final MethodTypeDesc APPEND_INT_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_int);\n-        static final MethodTypeDesc APPEND_LONG_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_long);\n-        static final MethodTypeDesc APPEND_OBJECT_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_Object);\n-        static final MethodTypeDesc APPEND_STRING_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_String);\n-        static final MethodTypeDesc INT_CONSTRUCTOR_TYPE = MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_int);\n-        static final MethodTypeDesc TO_STRING_TYPE = MethodTypeDesc.of(ConstantDescs.CD_String);\n+        static final MethodHandles.Lookup STR_LOOKUP = new MethodHandles.Lookup(String.class);\n+\n+        static final ClassDesc CD_CONCAT             = ConstantUtils.binaryNameToDesc(CLASS_NAME);\n+        static final ClassDesc CD_StringConcatHelper = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringConcatHelper;\");\n+        static final ClassDesc CD_StringConcatBase   = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringConcatHelper$StringConcatBase;\");\n+        static final ClassDesc CD_Array_byte         = ClassDesc.ofDescriptor(\"[B\");\n+        static final ClassDesc CD_Array_String       = ClassDesc.ofDescriptor(\"[Ljava\/lang\/String;\");\n+\n+        static final MethodTypeDesc MTD_byte_char       = MethodTypeDesc.of(CD_byte, CD_char);\n+        static final MethodTypeDesc MTD_byte            = MethodTypeDesc.of(CD_byte);\n+        static final MethodTypeDesc MTD_int             = MethodTypeDesc.of(CD_int);\n+        static final MethodTypeDesc MTD_int_int_boolean = MethodTypeDesc.of(CD_int, CD_int, CD_boolean);\n+        static final MethodTypeDesc MTD_int_int_char    = MethodTypeDesc.of(CD_int, CD_int, CD_char);\n+        static final MethodTypeDesc MTD_int_int_int     = MethodTypeDesc.of(CD_int, CD_int, CD_int);\n+        static final MethodTypeDesc MTD_int_int_long    = MethodTypeDesc.of(CD_int, CD_int, CD_long);\n+        static final MethodTypeDesc MTD_int_int_String  = MethodTypeDesc.of(CD_int, CD_int, CD_String);\n+        static final MethodTypeDesc MTD_String_float    = MethodTypeDesc.of(CD_String, CD_float);\n+        static final MethodTypeDesc MTD_String_double   = MethodTypeDesc.of(CD_String, CD_double);\n+        static final MethodTypeDesc MTD_String_Object   = MethodTypeDesc.of(CD_String, CD_Object);\n+\n+        static final MethodTypeDesc MTD_INIT             = MethodTypeDesc.of(CD_void, CD_Array_String);\n+        static final MethodTypeDesc MTD_NEW_ARRAY_SUFFIX = MethodTypeDesc.of(CD_Array_byte, CD_String, CD_int, CD_byte);\n+        static final MethodTypeDesc MTD_STRING_INIT      = MethodTypeDesc.of(CD_void, CD_Array_byte, CD_byte);\n+\n+        static final MethodTypeDesc PREPEND_int     = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_Array_byte, CD_int, CD_String);\n+        static final MethodTypeDesc PREPEND_long    = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_Array_byte, CD_long, CD_String);\n+        static final MethodTypeDesc PREPEND_boolean = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_Array_byte, CD_boolean, CD_String);\n+        static final MethodTypeDesc PREPEND_char    = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_Array_byte, CD_char, CD_String);\n+        static final MethodTypeDesc PREPEND_String  = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_Array_byte, CD_String, CD_String);\n+\n+        static final RuntimeVisibleAnnotationsAttribute FORCE_INLINE = RuntimeVisibleAnnotationsAttribute.of(Annotation.of(ClassDesc.ofDescriptor(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\")));\n+\n+        static final MethodType CONSTRUCTOR_METHOD_TYPE        = MethodType.methodType(void.class, String[].class);\n+        static final Consumer<CodeBuilder> CONSTRUCTOR_BUILDER = new Consumer<CodeBuilder>() {\n+            @Override\n+            public void accept(CodeBuilder cb) {\n+                \/*\n+                 * super(constants);\n+                 *\/\n+                int thisSlot      = cb.receiverSlot(),\n+                    constantsSlot = cb.parameterSlot(0);\n+                cb.aload(thisSlot)\n+                  .aload(constantsSlot)\n+                  .invokespecial(CD_StringConcatBase, INIT_NAME, MTD_INIT, false)\n+                  .return_();\n+            }\n+        };\n+\n+        static final ReferencedKeyMap<MethodType, SoftReference<MethodHandlePair>> CACHE =\n+                ReferencedKeyMap.create(true, true,\n+                        new Supplier<>() {\n+                            @Override\n+                            public Map<ReferenceKey<MethodType>, SoftReference<MethodHandlePair>> get() {\n+                                return new ConcurrentHashMap<>(64);\n+                            }\n+                        });\n+\n+        private InlineHiddenClassStrategy() {\n+            \/\/ no instantiation\n+        }\n+\n+        private record MethodHandlePair(MethodHandle constructor, MethodHandle concatenator) { };\n@@ -1068,2 +1149,1 @@\n-         * Ensure a capacity in the initial StringBuilder to accommodate all\n-         * constants plus this factor times the number of arguments.\n+         * The parameter types are normalized into 7 types: int,long,boolean,char,float,double,Object\n@@ -1071,1 +1151,20 @@\n-        static final int ARGUMENT_SIZE_FACTOR = 4;\n+        private static MethodType erasedArgs(MethodType args) {\n+            int parameterCount = args.parameterCount();\n+            var paramTypes = new Class<?>[parameterCount];\n+            boolean changed = false;\n+            for (int i = 0; i < parameterCount; i++) {\n+                Class<?> cl = args.parameterType(i);\n+                \/\/ Use int as the logical type for subword integral types\n+                \/\/ (byte and short). char and boolean require special\n+                \/\/ handling so don't change the logical type of those\n+                if (cl == byte.class || cl == short.class) {\n+                    cl = int.class;\n+                    changed = true;\n+                } else if (cl != Object.class && !cl.isPrimitive()) {\n+                    cl = Object.class;\n+                    changed = true;\n+                }\n+                paramTypes[i] = cl;\n+            }\n+            return changed ? MethodType.methodType(args.returnType(), paramTypes) : args;\n+        }\n@@ -1073,1 +1172,24 @@\n-        static final Set<Lookup.ClassOption> SET_OF_STRONG = Set.of(STRONG);\n+        \/**\n+         * Construct the MethodType of the prepend method, The parameters only support 5 types:\n+         * int\/long\/char\/boolean\/String. Not int\/long\/char\/boolean type, use String type<p>\n+         *\n+         * The following is an example of the generated target code:\n+         * <blockquote><pre>\n+         *  int prepend(int length, byte coder, byte[] buff,  String[] constants\n+         *      int arg0, long arg1, boolean arg2, char arg3, String arg5)\n+         * <\/pre><\/blockquote>\n+         *\/\n+        private static MethodTypeDesc prependArgs(MethodType concatArgs) {\n+            int parameterCount = concatArgs.parameterCount();\n+            var paramTypes = new ClassDesc[parameterCount + 4];\n+            paramTypes[0] = CD_int;          \/\/ length\n+            paramTypes[1] = CD_byte;         \/\/ coder\n+            paramTypes[2] = CD_Array_byte;   \/\/ buff\n+            paramTypes[3] = CD_Array_String; \/\/ constants\n+\n+            for (int i = 0; i < parameterCount; i++) {\n+                var cl = concatArgs.parameterType(i);\n+                paramTypes[i + 4] = needStringOf(cl) ? CD_String : ConstantUtils.classDesc(cl);\n+            }\n+            return MethodTypeDesc.of(CD_int, paramTypes);\n+        }\n@@ -1075,2 +1197,30 @@\n-        private SimpleStringBuilderStrategy() {\n-            \/\/ no instantiation\n+        \/**\n+         * Construct the MethodType of the coder method,\n+         * The first parameter is the initialized coder, Only parameter types that can be UTF16 are added.\n+         *\/\n+        private static MethodTypeDesc coderArgs(MethodType concatArgs) {\n+            int parameterCount = concatArgs.parameterCount();\n+            List<ClassDesc> paramTypes = new ArrayList<>();\n+            paramTypes.add(CD_int); \/\/ init coder\n+            for (int i = 0; i < parameterCount; i++) {\n+                var cl = concatArgs.parameterType(i);\n+                if (maybeUTF16(cl)) {\n+                    paramTypes.add(cl == char.class ? CD_char : CD_String);\n+                }\n+            }\n+            return MethodTypeDesc.of(CD_int, paramTypes);\n+        }\n+\n+        \/**\n+         * Construct the MethodType of the length method,\n+         * The first parameter is the initialized length\n+         *\/\n+        private static MethodTypeDesc lengthArgs(MethodType concatArgs) {\n+            int parameterCount = concatArgs.parameterCount();\n+            var paramTypes = new ClassDesc[parameterCount + 1];\n+            paramTypes[0] = CD_int; \/\/ init long\n+            for (int i = 0; i < parameterCount; i++) {\n+                var cl = concatArgs.parameterType(i);\n+                paramTypes[i + 1] = needStringOf(cl) ? CD_String : ConstantUtils.classDesc(cl);\n+            }\n+            return MethodTypeDesc.of(CD_int, paramTypes);\n@@ -1080,1 +1230,9 @@\n-            String className = getClassName(lookup.lookupClass());\n+            lookup = STR_LOOKUP;\n+            final MethodType concatArgs = erasedArgs(args);\n+\n+            \/\/ 1 argment use built-in method\n+            if (args.parameterCount() == 1) {\n+                Object concat1 = JLA.stringConcat1(constants);\n+                var handle = lookup.findVirtual(concat1.getClass(), METHOD_NAME, concatArgs);\n+                return handle.bindTo(concat1);\n+            }\n@@ -1082,1 +1240,17 @@\n-            byte[] classBytes = ClassFile.of().build(ConstantUtils.binaryNameToDesc(className),\n+            var weakConstructorHandle = CACHE.get(concatArgs);\n+            if (weakConstructorHandle != null) {\n+                MethodHandlePair handlePair = weakConstructorHandle.get();\n+                if (handlePair != null) {\n+                    try {\n+                        var instance = handlePair.constructor.invoke(constants);\n+                        return handlePair.concatenator.bindTo(instance);\n+                    } catch (Throwable e) {\n+                        throw new StringConcatException(\"Exception while utilizing the hidden class\", e);\n+                    }\n+                }\n+            }\n+            MethodTypeDesc lengthArgs  = lengthArgs(concatArgs),\n+                           coderArgs   = parameterMaybeUTF16(concatArgs) ? coderArgs(concatArgs) : null,\n+                           prependArgs = prependArgs(concatArgs);\n+\n+            byte[] classBytes = ClassFile.of().build(CD_CONCAT,\n@@ -1084,0 +1258,2 @@\n+                        final boolean forceInline = concatArgs.parameterCount() < FORCE_INLINE_THRESHOLD;\n+\n@@ -1086,5 +1262,55 @@\n-                            clb.withFlags(AccessFlag.FINAL, AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n-                                .withMethodBody(METHOD_NAME,\n-                                        ConstantUtils.methodTypeDesc(args),\n-                                        ClassFile.ACC_FINAL | ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC,\n-                                        generateMethod(constants, args));\n+                            clb.withSuperclass(CD_StringConcatBase)\n+                                .withFlags(ACC_FINAL | ACC_SUPER | ACC_SYNTHETIC)\n+                                .withMethodBody(INIT_NAME, MTD_INIT, 0, CONSTRUCTOR_BUILDER)\n+                                .withMethod(\"length\",\n+                                        lengthArgs,\n+                                        ACC_STATIC | ACC_PRIVATE,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generateLengthMethod(lengthArgs));\n+                                            }\n+                                        })\n+                                .withMethod(\"prepend\",\n+                                        prependArgs,\n+                                        ACC_STATIC | ACC_PRIVATE,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generatePrependMethod(prependArgs));\n+                                            }\n+                                        })\n+                                .withMethod(METHOD_NAME,\n+                                        ConstantUtils.methodTypeDesc(concatArgs),\n+                                        ACC_FINAL,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generateConcatMethod(\n+                                                        CD_CONCAT,\n+                                                        concatArgs,\n+                                                        lengthArgs,\n+                                                        coderArgs,\n+                                                        prependArgs));\n+                                            }\n+                                        });\n+\n+                            if (coderArgs != null) {\n+                                clb.withMethod(\"coder\",\n+                                        coderArgs,\n+                                        ACC_STATIC | ACC_PRIVATE,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generateCoderMethod(coderArgs));\n+                                            }\n+                                        });\n+                            }\n@@ -1093,5 +1319,8 @@\n-                Lookup hiddenLookup = lookup.makeHiddenClassDefiner(className, classBytes, SET_OF_STRONG, DUMPER)\n-                                            .defineClassAsLookup(true);\n-                Class<?> innerClass = hiddenLookup.lookupClass();\n-                return hiddenLookup.findStatic(innerClass, METHOD_NAME, args);\n-            } catch (Exception e) {\n+                var hiddenClass = lookup.makeHiddenClassDefiner(CLASS_NAME, classBytes, Set.of(), DUMPER)\n+                                        .defineClass(true, null);\n+                var constructor = lookup.findConstructor(hiddenClass, CONSTRUCTOR_METHOD_TYPE);\n+                var concat      = lookup.findVirtual(hiddenClass, METHOD_NAME, concatArgs);\n+                CACHE.put(concatArgs, new SoftReference<>(new MethodHandlePair(constructor, concat)));\n+                var instance = hiddenClass.cast(constructor.invoke(constants));\n+                return concat.bindTo(instance);\n+            } catch (Throwable e) {\n@@ -1102,1 +1331,71 @@\n-        private static Consumer<CodeBuilder> generateMethod(String[] constants, MethodType args) {\n+        \/**\n+         * Generate InlineCopy-based code. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         *  import static java.lang.StringConcatHelper.newArrayWithSuffix;\n+         *  import static java.lang.StringConcatHelper.prepend;\n+         *  import static java.lang.StringConcatHelper.stringCoder;\n+         *  import static java.lang.StringConcatHelper.stringSize;\n+         *\n+         *  class StringConcat extends java.lang.StringConcatHelper.StringConcatBase {\n+         *      \/\/ super class defines\n+         *      \/\/ String[] constants;\n+         *      \/\/ int length;\n+         *      \/\/ byte coder;\n+         *\n+         *      StringConcat(String[] constants) {\n+         *          super(constants);\n+         *      }\n+         *\n+         *      String concat(int arg0, long arg1, boolean arg2, char arg3, String arg4,\n+         *          float arg5, double arg6, Object arg7\n+         *      ) {\n+         *          \/\/ Types other than byte\/short\/int\/long\/boolean\/String require a local variable to store\n+         *          String str4 = stringOf(arg4);\n+         *          String str5 = stringOf(arg5);\n+         *          String str6 = stringOf(arg6);\n+         *          String str7 = stringOf(arg7);\n+         *\n+         *          int coder  = coder(this.coder, arg0, arg1, arg2, arg3, str4, str5, str6, str7);\n+         *          int length = length(this.length, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n+         *          String[] constants = this.constants;\n+         *          byte[] buf = newArrayWithSuffix(constants[paramCount], length. coder);\n+         *\n+         *          prepend(length, coder, buf, constants, arg0, arg1, arg2, arg3, str4, str5, str6, str7);\n+         *\n+         *          return new String(buf, coder);\n+         *      }\n+         *\n+         *      static int length(int length, int arg0, long arg1, boolean arg2, char arg3,\n+         *                       String arg4, String arg5, String arg6, String arg7) {\n+         *          return stringSize(stringSize(stringSize(stringSize(stringSize(stringSize(stringSize(stringSize(\n+         *                      length, arg0), arg1), arg2), arg3), arg4), arg5), arg6), arg7);\n+         *      }\n+         *\n+         *      static int cocder(int coder, char arg3, String str4, String str5, String str6, String str7) {\n+         *          return coder | stringCoder(arg3) | str4.coder() | str5.coder() | str6.coder() | str7.coder();\n+         *      }\n+         *\n+         *      static int prepend(int length, int coder, byte[] buf, String[] constants,\n+         *                     int arg0, long arg1, boolean arg2, char arg3,\n+         *                     String str4, String str5, String str6, String str7) {\n+         *          \/\/ StringConcatHelper.prepend\n+         *          return prepend(prepend(prepend(prepend(\n+         *                  prepend(apppend(prepend(prepend(length,\n+         *                       buf, str7, constant[7]), buf, str6, constant[6]),\n+         *                       buf, str5, constant[5]), buf, str4, constant[4]),\n+         *                       buf, arg3, constant[3]), buf, arg2, constant[2]),\n+         *                       buf, arg1, constant[1]), buf, arg0, constant[0]);\n+         *      }\n+         *  }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        private static Consumer<CodeBuilder> generateConcatMethod(\n+                ClassDesc      concatClass,\n+                MethodType     concatArgs,\n+                MethodTypeDesc lengthArgs,\n+                MethodTypeDesc coderArgs,\n+                MethodTypeDesc prependArgs\n+        ) {\n@@ -1106,7 +1405,35 @@\n-                    cb.new_(STRING_BUILDER);\n-                    cb.dup();\n-\n-                    int len = 0;\n-                    for (String constant : constants) {\n-                        if (constant != null) {\n-                            len += constant.length();\n+                    \/\/ Compute parameter variable slots\n+                    int paramCount    = concatArgs.parameterCount(),\n+                        thisSlot      = cb.receiverSlot(),\n+                        lengthSlot    = cb.allocateLocal(TypeKind.IntType),\n+                        coderSlot     = cb.allocateLocal(TypeKind.ByteType),\n+                        bufSlot       = cb.allocateLocal(TypeKind.ReferenceType),\n+                        constantsSlot = cb.allocateLocal(TypeKind.ReferenceType),\n+                        suffixSlot    = cb.allocateLocal(TypeKind.ReferenceType);\n+\n+                    \/*\n+                     * Types other than int\/long\/char\/boolean require local variables to store the result of stringOf.\n+                     *\n+                     * stringSlots stores the slots of parameters relative to local variables\n+                     *\n+                     * str0 = stringOf(arg0);\n+                     * str1 = stringOf(arg1);\n+                     * ...\n+                     * strN = toString(argN);\n+                     *\/\n+                    int[] stringSlots = new int[paramCount];\n+                    for (int i = 0; i < paramCount; i++) {\n+                        var cl = concatArgs.parameterType(i);\n+                        if (needStringOf(cl)) {\n+                            MethodTypeDesc methodTypeDesc;\n+                            if (cl == float.class) {\n+                                methodTypeDesc = MTD_String_float;\n+                            } else if (cl == double.class) {\n+                                methodTypeDesc = MTD_String_double;\n+                            } else {\n+                                methodTypeDesc = MTD_String_Object;\n+                            }\n+                            stringSlots[i] = cb.allocateLocal(TypeKind.ReferenceType);\n+                            cb.loadLocal(TypeKind.from(cl), cb.parameterSlot(i))\n+                              .invokestatic(CD_StringConcatHelper, \"stringOf\", methodTypeDesc)\n+                              .astore(stringSlots[i]);\n@@ -1115,11 +1442,15 @@\n-                    len += args.parameterCount() * ARGUMENT_SIZE_FACTOR;\n-                    cb.loadConstant(len);\n-                    cb.invokespecial(STRING_BUILDER, \"<init>\", INT_CONSTRUCTOR_TYPE);\n-\n-                    \/\/ At this point, we have a blank StringBuilder on stack, fill it in with .append calls.\n-                    {\n-                        int off = 0;\n-                        for (int c = 0; c < args.parameterCount(); c++) {\n-                            if (constants[c] != null) {\n-                                cb.ldc(constants[c]);\n-                                cb.invokevirtual(STRING_BUILDER, \"append\", APPEND_STRING_TYPE);\n+\n+                    \/*\n+                     * coder = coder(this.coder, arg0, arg1, ... argN);\n+                     *\/\n+                    cb.aload(thisSlot)\n+                      .getfield(concatClass, \"coder\", CD_byte);\n+                    if (coderArgs != null) {\n+                        for (int i = 0; i < paramCount; i++) {\n+                            var cl = concatArgs.parameterType(i);\n+                            if (maybeUTF16(cl)) {\n+                                if (cl == char.class) {\n+                                    cb.loadLocal(TypeKind.CharType, cb.parameterSlot(i));\n+                                } else {\n+                                    cb.aload(stringSlots[i]);\n+                                }\n@@ -1127,6 +1458,0 @@\n-                            Class<?> cl = args.parameterType(c);\n-                            TypeKind kind = TypeKind.from(cl);\n-                            cb.loadLocal(kind, off);\n-                            off += kind.slotSize();\n-                            MethodTypeDesc desc = getSBAppendDesc(cl);\n-                            cb.invokevirtual(STRING_BUILDER, \"append\", desc);\n@@ -1134,3 +1459,62 @@\n-                        if (constants[constants.length - 1] != null) {\n-                            cb.ldc(constants[constants.length - 1]);\n-                            cb.invokevirtual(STRING_BUILDER, \"append\", APPEND_STRING_TYPE);\n+                        cb.invokestatic(concatClass, \"coder\", coderArgs);\n+                    }\n+                    cb.istore(coderSlot);\n+\n+                    \/*\n+                     * length = length(this.length, arg0, arg1, ..., argN);\n+                     *\/\n+                    cb.aload(thisSlot)\n+                      .getfield(concatClass, \"length\", CD_int);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        var cl        = concatArgs.parameterType(i);\n+                        int paramSlot = cb.parameterSlot(i);\n+                        if (needStringOf(cl)) {\n+                            paramSlot = stringSlots[i];\n+                            cl = String.class;\n+                        }\n+                        cb.loadLocal(TypeKind.from(cl), paramSlot);\n+                    }\n+                    cb.invokestatic(concatClass, \"length\", lengthArgs);\n+\n+                    \/*\n+                     * String[] constants = this.constants;\n+                     * suffix  = constants[paranCount];\n+                     * length -= suffix.length();\n+                     *\/\n+                    cb.aload(thisSlot)\n+                      .getfield(concatClass, \"constants\", CD_Array_String)\n+                      .dup()\n+                      .astore(constantsSlot)\n+                      .ldc(paramCount)\n+                      .aaload()\n+                      .dup()\n+                      .astore(suffixSlot)\n+                      .invokevirtual(CD_String, \"length\", MTD_int)\n+                      .isub()\n+                      .istore(lengthSlot);\n+\n+                    \/*\n+                     * Allocate buffer :\n+                     *\n+                     *  buf = newArrayWithSuffix(suffix, length, coder)\n+                     *\/\n+                    cb.aload(suffixSlot)\n+                      .iload(lengthSlot)\n+                      .iload(coderSlot)\n+                      .invokestatic(CD_StringConcatHelper, \"newArrayWithSuffix\", MTD_NEW_ARRAY_SUFFIX)\n+                      .astore(bufSlot);\n+\n+                    \/*\n+                     * prepend(length, coder, buf, constants, ar0, ar1, ..., argN);\n+                     *\/\n+                    cb.iload(lengthSlot)\n+                      .iload(coderSlot)\n+                      .aload(bufSlot)\n+                      .aload(constantsSlot);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        var cl = concatArgs.parameterType(i);\n+                        int paramSlot = cb.parameterSlot(i);\n+                        var kind = TypeKind.from(cl);\n+                        if (needStringOf(cl)) {\n+                            paramSlot = stringSlots[i];\n+                            kind = TypeKind.ReferenceType;\n@@ -1138,0 +1522,1 @@\n+                        cb.loadLocal(kind, paramSlot);\n@@ -1139,0 +1524,12 @@\n+                    cb.invokestatic(concatClass, \"prepend\", prependArgs);\n+\n+                    \/\/ return new String(buf, coder);\n+                    cb.new_(CD_String)\n+                      .dup()\n+                      .aload(bufSlot)\n+                      .iload(coderSlot)\n+                      .invokespecial(CD_String, INIT_NAME, MTD_STRING_INIT)\n+                      .areturn();\n+                }\n+            };\n+        }\n@@ -1140,2 +1537,38 @@\n-                    cb.invokevirtual(STRING_BUILDER, \"toString\", TO_STRING_TYPE);\n-                    cb.areturn();\n+        \/**\n+         * Generate length method. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         * import static java.lang.StringConcatHelper.stringSize;\n+         *\n+         * static int length(int length, int arg0, long arg1, boolean arg2, char arg3,\n+         *                  String arg4, String arg5, String arg6, String arg7) {\n+         *     return stringSize(stringSize(stringSize(length, arg0), arg1), ..., arg7);\n+         * }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        private static Consumer<CodeBuilder> generateLengthMethod(MethodTypeDesc lengthArgs) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    int lengthSlot = cb.parameterSlot(0);\n+                    cb.iload(lengthSlot);\n+                    for (int i = 1; i < lengthArgs.parameterCount(); i++) {\n+                        var cl = lengthArgs.parameterType(i);\n+                        MethodTypeDesc methodTypeDesc;\n+                        if (cl == CD_char) {\n+                            methodTypeDesc = MTD_int_int_char;\n+                        } else if (cl == CD_int) {\n+                            methodTypeDesc = MTD_int_int_int;\n+                        } else if (cl == CD_long) {\n+                            methodTypeDesc = MTD_int_int_long;\n+                        } else if (cl == CD_boolean) {\n+                            methodTypeDesc = MTD_int_int_boolean;\n+                        } else {\n+                            methodTypeDesc = MTD_int_int_String;\n+                        }\n+                        cb.loadLocal(TypeKind.from(cl), cb.parameterSlot(i))\n+                          .invokestatic(CD_StringConcatHelper, \"stringSize\", methodTypeDesc);\n+                    }\n+                    cb.ireturn();\n@@ -1147,3 +1580,11 @@\n-         * The generated class is in the same package as the host class as\n-         * it's the implementation of the string concatenation for the host\n-         * class.\n+         * Generate coder method. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         * import static java.lang.StringConcatHelper.stringCoder;\n+         *\n+         * static int cocder(int coder, char arg3, String str4, String str5, String str6, String str7) {\n+         *     return coder | stringCoder(arg3) | str4.coder() | str5.coder() | str6.coder() | str7.coder();\n+         * }\n+         * <\/pre><\/blockquote>\n@@ -1151,4 +1592,22 @@\n-        private static String getClassName(Class<?> hostClass) {\n-            String name = hostClass.isHidden() ? hostClass.getName().replace('\/', '_')\n-                    : hostClass.getName();\n-            return name + \"$$StringConcat\";\n+        private static Consumer<CodeBuilder> generateCoderMethod(MethodTypeDesc coderArgs) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    \/*\n+                     * return coder | stringCoder(argN) | ... | arg1.coder() | arg0.coder();\n+                     *\/\n+                    int coderSlot = cb.parameterSlot(0);\n+                    cb.iload(coderSlot);\n+                    for (int i = 1; i < coderArgs.parameterCount(); i++) {\n+                        var cl = coderArgs.parameterType(i);\n+                        cb.loadLocal(TypeKind.from(cl), cb.parameterSlot(i));\n+                        if (cl == CD_char) {\n+                            cb.invokestatic(CD_StringConcatHelper, \"stringCoder\", MTD_byte_char);\n+                        } else {\n+                            cb.invokevirtual(CD_String, \"coder\", MTD_byte);\n+                        }\n+                        cb.ior();\n+                    }\n+                    cb.ireturn();\n+                }\n+            };\n@@ -1157,16 +1616,84 @@\n-        private static MethodTypeDesc getSBAppendDesc(Class<?> cl) {\n-            if (cl.isPrimitive()) {\n-                if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {\n-                    return APPEND_INT_TYPE;\n-                } else if (cl == Boolean.TYPE) {\n-                    return APPEND_BOOLEAN_TYPE;\n-                } else if (cl == Character.TYPE) {\n-                    return APPEND_CHAR_TYPE;\n-                } else if (cl == Double.TYPE) {\n-                    return APPEND_DOUBLE_TYPE;\n-                } else if (cl == Float.TYPE) {\n-                    return APPEND_FLOAT_TYPE;\n-                } else if (cl == Long.TYPE) {\n-                    return APPEND_LONG_TYPE;\n-                } else {\n-                    throw new IllegalStateException(\"Unhandled primitive StringBuilder.append: \" + cl);\n+        \/**\n+         * Generate prepend method. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         * import static java.lang.StringConcatHelper.prepend;\n+         *\n+         * static int prepend(int length, int coder, byte[] buf, String[] constants,\n+         *                int arg0, long arg1, boolean arg2, char arg3,\n+         *                String str4, String str5, String str6, String str7) {\n+         *\n+         *     return prepend(prepend(prepend(prepend(\n+         *             prepend(prepend(prepend(prepend(length,\n+         *                  buf, str7, constant[7]), buf, str6, constant[6]),\n+         *                  buf, str5, constant[5]), buf, str4, constant[4]),\n+         *                  buf, arg3, constant[3]), buf, arg2, constant[2]),\n+         *                  buf, arg1, constant[1]), buf, arg0, constant[0]);\n+         * }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        private static Consumer<CodeBuilder> generatePrependMethod(MethodTypeDesc prependArgs) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    \/\/ Compute parameter variable slots\n+                    int lengthSlot    = cb.parameterSlot(0),\n+                        coderSlot     = cb.parameterSlot(1),\n+                        bufSlot       = cb.parameterSlot(2),\n+                        constantsSlot = cb.parameterSlot(3);\n+                    \/*\n+                     * \/\/ StringConcatHelper.prepend\n+                     * return prepend(prepend(prepend(prepend(\n+                     *         prepend(apppend(prepend(prepend(length,\n+                     *              buf, str7, constant[7]), buf, str6, constant[6]),\n+                     *              buf, str5, constant[5]), buf, arg4, constant[4]),\n+                     *              buf, arg3, constant[3]), buf, arg2, constant[2]),\n+                     *              buf, arg1, constant[1]), buf, arg0, constant[0]);\n+                     *\/\n+                    cb.iload(lengthSlot);\n+                    for (int i = prependArgs.parameterCount() - 1; i >= 4; i--) {\n+                        var cl   = prependArgs.parameterType(i);\n+                        var kind = TypeKind.from(cl);\n+\n+                        \/\/ There are only 5 types of parameters: int, long, boolean, char, String\n+                        MethodTypeDesc methodTypeDesc;\n+                        if (cl == CD_int) {\n+                            methodTypeDesc = PREPEND_int;\n+                        } else if (cl == CD_long) {\n+                            methodTypeDesc = PREPEND_long;\n+                        } else if (cl == CD_boolean) {\n+                            methodTypeDesc = PREPEND_boolean;\n+                        } else if (cl == CD_char) {\n+                            methodTypeDesc = PREPEND_char;\n+                        } else {\n+                            kind = TypeKind.ReferenceType;\n+                            methodTypeDesc = PREPEND_String;\n+                        }\n+\n+                        cb.iload(coderSlot)\n+                          .aload(bufSlot)\n+                          .loadLocal(kind, cb.parameterSlot(i))\n+                          .aload(constantsSlot)\n+                          .ldc(i - 4)\n+                          .aaload()\n+                          .invokestatic(CD_StringConcatHelper, \"prepend\", methodTypeDesc);\n+                    }\n+                    cb.ireturn();\n+                }\n+            };\n+        }\n+\n+        static boolean needStringOf(Class<?> cl) {\n+            return cl != int.class && cl != long.class && cl != boolean.class && cl != char.class;\n+        }\n+\n+        static boolean maybeUTF16(Class<?> cl) {\n+            return cl == char.class || !cl.isPrimitive();\n+        }\n+\n+        static boolean parameterMaybeUTF16(MethodType args) {\n+            for (int i = 0; i < args.parameterCount(); i++) {\n+                if (maybeUTF16(args.parameterType(i))) {\n+                    return true;\n@@ -1174,4 +1701,0 @@\n-            } else if (cl == String.class) {\n-                return APPEND_STRING_TYPE;\n-            } else {\n-                return APPEND_OBJECT_TYPE;\n@@ -1179,0 +1702,1 @@\n+            return false;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":643,"deletions":119,"binary":false,"changes":762,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -31,0 +32,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -48,1 +50,1 @@\n-    static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, long.class);\n+    static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, MemoryLayout.class, long.class, long.class);\n@@ -56,1 +58,1 @@\n-        return accessType.accessModeType(MemorySegment.class, $type$.class, long.class);\n+        return accessType.accessModeType(MemorySegment.class, $type$.class, MemoryLayout.class, long.class, long.class);\n@@ -100,1 +102,1 @@\n-    static AbstractMemorySegmentImpl checkReadOnly(Object obb, boolean ro) {\n+    static AbstractMemorySegmentImpl checkSegment(Object obb, Object encl, long base, boolean ro) {\n@@ -102,1 +104,1 @@\n-        oo.checkReadOnly(ro);\n+        oo.checkEnclosingLayout(base, (MemoryLayout)encl, ro);\n@@ -107,1 +109,1 @@\n-    static long offsetNonPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+    static long offsetNonPlain(AbstractMemorySegmentImpl bb, long base, long offset, long alignmentMask) {\n@@ -111,1 +113,1 @@\n-        return offsetPlain(bb, offset);\n+        return offsetPlain(bb, base, offset);\n@@ -115,3 +117,3 @@\n-    static long offsetPlain(AbstractMemorySegmentImpl bb, long offset) {\n-        long base = bb.unsafeGetOffset();\n-        return base + offset;\n+    static long offsetPlain(AbstractMemorySegmentImpl bb, long base, long offset) {\n+        long segment_base = bb.unsafeGetOffset();\n+        return segment_base + base + offset;\n@@ -121,1 +123,1 @@\n-    static $type$ get(VarHandle ob, Object obb, long base) {\n+    static $type$ get(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -123,1 +125,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -127,1 +129,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -134,1 +136,1 @@\n-                offsetPlain(bb, base));\n+                offsetPlain(bb, base, offset));\n@@ -138,1 +140,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -145,1 +147,1 @@\n-    static void set(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void set(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -147,1 +149,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -151,1 +153,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -158,1 +160,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -163,1 +165,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -171,1 +173,1 @@\n-    static $type$ getVolatile(VarHandle ob, Object obb, long base) {\n+    static $type$ getVolatile(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -173,1 +175,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -177,1 +179,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n@@ -181,1 +183,1 @@\n-    static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setVolatile(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -183,1 +185,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -186,1 +188,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -191,1 +193,1 @@\n-    static $type$ getAcquire(VarHandle ob, Object obb, long base) {\n+    static $type$ getAcquire(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -193,1 +195,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -197,1 +199,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n@@ -201,1 +203,1 @@\n-    static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -203,1 +205,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -206,1 +208,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -211,1 +213,1 @@\n-    static $type$ getOpaque(VarHandle ob, Object obb, long base) {\n+    static $type$ getOpaque(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -213,1 +215,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -217,1 +219,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n@@ -221,1 +223,1 @@\n-    static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setOpaque(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -223,1 +225,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -226,1 +228,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -232,1 +234,1 @@\n-    static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean compareAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -234,1 +236,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -237,1 +239,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -242,1 +244,1 @@\n-    static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchange(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -244,1 +246,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -248,1 +250,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -253,1 +255,1 @@\n-    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -255,1 +257,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -259,1 +261,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -264,1 +266,1 @@\n-    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -266,1 +268,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -270,1 +272,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -275,1 +277,1 @@\n-    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -277,1 +279,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -280,1 +282,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -285,1 +287,1 @@\n-    static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -287,1 +289,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -290,1 +292,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -295,1 +297,1 @@\n-    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -297,1 +299,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -300,1 +302,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -305,1 +307,1 @@\n-    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -307,1 +309,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -310,1 +312,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -315,1 +317,1 @@\n-    static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -317,1 +319,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -321,1 +323,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -326,1 +328,1 @@\n-    static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSetAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -328,1 +330,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -332,1 +334,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -337,1 +339,1 @@\n-    static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSetRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -339,1 +341,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -343,1 +345,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -350,1 +352,1 @@\n-    static $type$ getAndAdd(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAdd(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n@@ -352,1 +354,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -356,1 +358,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -359,1 +361,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n@@ -364,1 +366,1 @@\n-    static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAddAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n@@ -366,1 +368,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -370,1 +372,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -373,1 +375,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n@@ -378,1 +380,1 @@\n-    static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAddRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n@@ -380,1 +382,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -384,1 +386,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -387,1 +389,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n@@ -406,1 +408,1 @@\n-    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -408,1 +410,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -412,1 +414,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -415,1 +417,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -420,1 +422,1 @@\n-    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -422,1 +424,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -426,1 +428,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -429,1 +431,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -434,1 +436,1 @@\n-    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -436,1 +438,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -440,1 +442,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -443,1 +445,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -460,1 +462,1 @@\n-    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -462,1 +464,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -466,1 +468,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -469,1 +471,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -474,1 +476,1 @@\n-    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -476,1 +478,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -480,1 +482,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -483,1 +485,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -488,1 +490,1 @@\n-    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -490,1 +492,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -494,1 +496,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -497,1 +499,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -515,1 +517,1 @@\n-    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -517,1 +519,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -521,1 +523,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -524,1 +526,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -529,1 +531,1 @@\n-    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -531,1 +533,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -535,1 +537,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -538,1 +540,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -543,1 +545,1 @@\n-    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -545,1 +547,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -549,1 +551,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -552,1 +554,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":120,"deletions":118,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -157,3 +157,3 @@\n- * specific. In the JDK the default set of root modules contains every module\n- * that is observable on the upgrade module path or among the system modules,\n- * and that exports at least one package without qualification. <\/p>\n+ * specific. In the JDK the default set of root modules contains every module on\n+ * the upgrade module path or among the system modules that exports at least one\n+ * package, without qualification. <\/p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -168,0 +168,8 @@\n+    \/\/ Creates a new root constructor with a custom accessor for serialization hooks.\n+    Constructor<T> newWithAccessor(ConstructorAccessor accessor) {\n+        var res = new Constructor<>(clazz, parameterTypes, exceptionTypes, modifiers, slot,\n+                signature, annotations, parameterAnnotations);\n+        res.constructorAccessor = accessor;\n+        return res;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -176,15 +176,0 @@\n-    \/**\n-     * Make a copy of a leaf method.\n-     *\/\n-    Method leafCopy() {\n-        if (this.root == null)\n-            throw new IllegalArgumentException(\"Can only leafCopy a non-root Method\");\n-\n-        Method res = new Method(clazz, name, parameterTypes, returnType,\n-                exceptionTypes, modifiers, slot, signature,\n-                annotations, parameterAnnotations, annotationDefault);\n-        res.root = root;\n-        res.methodAccessor = methodAccessor;\n-        return res;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import jdk.internal.reflect.MethodAccessor;\n+import jdk.internal.access.JavaLangReflectAccess;\n@@ -34,53 +34,3 @@\n-\n-class ReflectAccess implements jdk.internal.access.JavaLangReflectAccess {\n-    public <T> Constructor<T> newConstructor(Class<T> declaringClass,\n-                                             Class<?>[] parameterTypes,\n-                                             Class<?>[] checkedExceptions,\n-                                             int modifiers,\n-                                             int slot,\n-                                             String signature,\n-                                             byte[] annotations,\n-                                             byte[] parameterAnnotations)\n-    {\n-        return new Constructor<>(declaringClass,\n-                                  parameterTypes,\n-                                  checkedExceptions,\n-                                  modifiers,\n-                                  slot,\n-                                  signature,\n-                                  annotations,\n-                                  parameterAnnotations);\n-    }\n-\n-    public MethodAccessor getMethodAccessor(Method m) {\n-        return m.getMethodAccessor();\n-    }\n-\n-    public void setMethodAccessor(Method m, MethodAccessor accessor) {\n-        m.setMethodAccessor(accessor);\n-    }\n-\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c) {\n-        return c.getConstructorAccessor();\n-    }\n-\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor)\n-    {\n-        c.setConstructorAccessor(accessor);\n-    }\n-\n-    public int getConstructorSlot(Constructor<?> c) {\n-        return c.getSlot();\n-    }\n-\n-    public String getConstructorSignature(Constructor<?> c) {\n-        return c.getSignature();\n-    }\n-\n-    public byte[] getConstructorAnnotations(Constructor<?> c) {\n-        return c.getRawAnnotations();\n-    }\n-\n-    public byte[] getConstructorParameterAnnotations(Constructor<?> c) {\n-        return c.getRawParameterAnnotations();\n+final class ReflectAccess implements JavaLangReflectAccess {\n+    public <T> Constructor<T> newConstructorWithAccessor(Constructor<T> original, ConstructorAccessor accessor) {\n+        return original.newWithAccessor(accessor);\n@@ -108,3 +58,0 @@\n-    public Method      leafCopyMethod(Method arg) {\n-        return arg.leafCopy();\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":5,"deletions":58,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -398,1 +398,1 @@\n-     *          socket is already bound.\n+     *          socket is already bound or is closed.\n@@ -425,0 +425,5 @@\n+     * <p> If this socket is already connected, then this method will attempt to\n+     * connect to the given address. If this connect fails then the state of\n+     * this socket is unknown - it may or may not be connected to the address\n+     * that it was previously connected to.\n+     *\n@@ -464,1 +469,1 @@\n-     *         may be thrown if connect fails, for example, if the\n+     *         if the port is 0 or connect fails, for example, if the\n@@ -487,0 +492,5 @@\n+     * <p> If this socket is already connected, then this method will attempt to\n+     * connect to the given address. If this connect fails then the state of\n+     * this socket is unknown - it may or may not be connected to the address\n+     * that it was previously connected to.\n+     *\n@@ -646,1 +656,1 @@\n-     * @throws     IOException  if an I\/O error occurs.\n+     * @throws     IOException  if an I\/O error occurs, or the socket is closed.\n@@ -705,1 +715,1 @@\n-     * @throws     IOException  if an I\/O error occurs.\n+     * @throws     IOException  if an I\/O error occurs, or the socket is closed.\n@@ -773,1 +783,2 @@\n-     * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -787,1 +798,2 @@\n-     * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -823,2 +835,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -844,2 +856,2 @@\n-     * @throws    SocketException if there is an error in\n-     * the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -881,2 +893,2 @@\n-     * @throws    SocketException if there is an error in\n-     * the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -902,1 +914,2 @@\n-     * @throws    SocketException if there is an error in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -962,2 +975,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -986,3 +999,2 @@\n-     * @throws  SocketException\n-     *          if there is an error in the underlying protocol, such as an UDP\n-     *          error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -1006,2 +1018,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -1052,2 +1064,2 @@\n-     * @throws SocketException if there is an error setting the\n-     * traffic class or type-of-service\n+     * @throws SocketException if there is an error setting the traffic class or type-of-service,\n+     *         or the socket is closed.\n@@ -1077,2 +1089,2 @@\n-     * @throws SocketException if there is an error obtaining the\n-     * traffic class or type-of-service value.\n+     * @throws SocketException if there is an error obtaining the traffic class\n+     *         or type-of-service value, or the socket is closed.\n@@ -1095,0 +1107,3 @@\n+     *\n+     * <p> Once closed, several of the methods defined by this class will throw\n+     * an exception if invoked on the closed socket.\n@@ -1302,1 +1317,1 @@\n-     *         multicasting\n+     *         multicasting, or the socket is closed\n@@ -1346,1 +1361,1 @@\n-     *         is not a multicast address.\n+     *         is not a multicast address, or the socket is closed.\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocket.java","additions":42,"deletions":27,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-     *             while setting the default time-to-live value\n+     *             while setting the default time-to-live value, or the socket is closed.\n@@ -253,1 +253,1 @@\n-     *          default time-to-live value\n+     *          default time-to-live value, or the socket is closed.\n@@ -268,1 +268,1 @@\n-     * while getting the default time-to-live value\n+     *            while getting the default time-to-live value, or the socket is closed.\n@@ -288,1 +288,1 @@\n-     * getting the default time-to-live value\n+     *            getting the default time-to-live value, or the socket is closed.\n@@ -314,1 +314,1 @@\n-     *             or the platform does not support multicasting\n+     *             or the platform does not support multicasting, or the socket is closed.\n@@ -342,1 +342,1 @@\n-     *             or when the address is not a multicast address.\n+     *             or when the address is not a multicast address, or the socket is closed.\n@@ -396,1 +396,1 @@\n-     *             the underlying protocol, such as a TCP error.\n+     *             the underlying protocol, such as a TCP error, or the socket is closed.\n@@ -416,1 +416,1 @@\n-     *             underlying protocol, such as a TCP error.\n+     *             underlying protocol, such as a TCP error, or the socket is closed.\n@@ -437,1 +437,1 @@\n-     * the underlying protocol, such as a TCP error.\n+     *            the underlying protocol, such as a TCP error, or the socket is closed.\n@@ -457,1 +457,1 @@\n-     *         the underlying protocol, such as a TCP error.\n+     *         the underlying protocol, such as a TCP error, or the socket is closed.\n@@ -479,1 +479,2 @@\n-     * @throws     SocketException if an error occurs while setting the value\n+     * @throws     SocketException if an error occurs while setting the value, or\n+     *             the socket is closed.\n@@ -496,1 +497,2 @@\n-     * @throws     SocketException if an error occurs while getting the value\n+     * @throws     SocketException if an error occurs while getting the value, or\n+     *             the socket is closed.\n@@ -537,2 +539,1 @@\n-     * @throws     IOException is raised if an error occurs i.e\n-     *             error while setting ttl.\n+     * @throws     IOException  if an I\/O error occurs, or the socket is closed.\n","filename":"src\/java.base\/share\/classes\/java\/net\/MulticastSocket.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,3 +223,3 @@\n-    private final byte BITARRAYMASK = (byte)0x1;\n-    private final int  BYTEPOWER = 3;\n-    private final int  BYTEMASK = (1 << BYTEPOWER) - 1;\n+    private static final byte BITARRAYMASK = (byte)0x1;\n+    private static final int BYTEPOWER = 3;\n+    private static final int BYTEMASK = (1 << BYTEPOWER) - 1;\n","filename":"src\/java.base\/share\/classes\/java\/text\/MergeCollation.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3024,9 +3024,1 @@\n-    private static class FixedString implements FormatString {\n-        private final String s;\n-        private final int start;\n-        private final int end;\n-        FixedString(String s, int start, int end) {\n-            this.s = s;\n-            this.start = start;\n-            this.end = end;\n-        }\n+    private record FixedString(String s, int start, int end) implements FormatString {\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2808,1 +2808,1 @@\n-     * before the given timeout.\n+     * before the given timeout elapsed.\n@@ -2828,1 +2828,1 @@\n-     * otherwise completed before the given timeout.\n+     * otherwise completed before the given timeout elapsed.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,7 +142,1 @@\n-     * contention. We approach this by defining the Nodes that we need\n-     * anyway as ThreadLocals, and include in them per-thread index\n-     * and related bookkeeping state. (We can safely reuse per-thread\n-     * nodes rather than creating them fresh each time because slots\n-     * alternate between pointing to a node vs null, so cannot\n-     * encounter ABA problems. However, we do need some care in\n-     * resetting them between uses.)\n+     * contention.\n@@ -150,13 +144,22 @@\n-     * Implementing an effective arena requires allocating a bunch of\n-     * space, so we only do so upon detecting contention (except on\n-     * uniprocessors, where they wouldn't help, so aren't used).\n-     * Otherwise, exchanges use the single-slot slotExchange method.\n-     * On contention, not only must the slots be in different\n-     * locations, but the locations must not encounter memory\n-     * contention due to being on the same cache line (or more\n-     * generally, the same coherence unit).  Because, as of this\n-     * writing, there is no way to determine cacheline size, we define\n-     * a value that is enough for common platforms.  Additionally,\n-     * extra care elsewhere is taken to avoid other false\/unintended\n-     * sharing and to enhance locality, including adding padding (via\n-     * @Contended) to Nodes, embedding \"bound\" as an Exchanger field.\n+     * We approach this by defining the Nodes holding references to\n+     * transfered items as ThreadLocals, and include in them\n+     * per-thread index and related bookkeeping state. We can safely\n+     * reuse per-thread nodes rather than creating them fresh each\n+     * time because slots alternate between pointing to a node vs\n+     * null, so cannot encounter ABA problems. However, we must ensure\n+     * that object transfer fields are reset between uses. Given this,\n+     * Participant nodes can be defined as static ThreadLocals. As\n+     * seen for example in class Striped64, using indices established\n+     * in one instance across others usually improves overall\n+     * performance.  Nodes also include a participant-local random\n+     * number generator.\n+     *\n+     * Spreading out contention requires that the memory locations\n+     * used by the arena slots don't share a cache line -- otherwise,\n+     * the arena would have almost no benefit. We arrange this by\n+     * adding another level of indirection: The arena elements point\n+     * to \"Slots\", each of which is padded using @Contended. We only\n+     * create a single Slot on intialization, adding more when\n+     * needed. The per-thread Participant Nodes may also be subject to\n+     * false-sharing contention, but tend to be more scattered in\n+     * memory, so are unpadded, with some occasional performance impact.\n@@ -166,13 +169,6 @@\n-     * while trying to exchange. By nature of the above algorithm, the\n-     * only kinds of collision that reliably indicate contention are\n-     * when two attempted releases collide -- one of two attempted\n-     * offers can legitimately fail to CAS without indicating\n-     * contention by more than one other thread. (Note: it is possible\n-     * but not worthwhile to more precisely detect contention by\n-     * reading slot values after CAS failures.)  When a thread has\n-     * collided at each slot within the current arena bound, it tries\n-     * to expand the arena size by one. We track collisions within\n-     * bounds by using a version (sequence) number on the \"bound\"\n-     * field, and conservatively reset collision counts when a\n-     * participant notices that bound has been updated (in either\n-     * direction).\n+     * while trying to exchange. And shrink it via \"spinouts\" in which\n+     * threads give up waiting at a slot.  By nature of the above\n+     * algorithm, the only kinds of collision that reliably indicate\n+     * contention are when two attempted releases collide -- one of\n+     * two attempted offers can legitimately fail to CAS without\n+     * indicating contention by more than one other thread.\n@@ -180,25 +176,15 @@\n-     * The effective arena size is reduced (when there is more than\n-     * one slot) by giving up on waiting after a while and trying to\n-     * decrement the arena size on expiration. The value of \"a while\"\n-     * is an empirical matter.  We implement by piggybacking on the\n-     * use of spin->yield->block that is essential for reasonable\n-     * waiting performance anyway -- in a busy exchanger, offers are\n-     * usually almost immediately released, in which case context\n-     * switching on multiprocessors is extremely slow\/wasteful.  Arena\n-     * waits just omit the blocking part, and instead cancel. The spin\n-     * count is empirically chosen to be a value that avoids blocking\n-     * 99% of the time under maximum sustained exchange rates on a\n-     * range of test machines. Spins and yields entail some limited\n-     * randomness (using a cheap xorshift) to avoid regular patterns\n-     * that can induce unproductive grow\/shrink cycles. (Using a\n-     * pseudorandom also helps regularize spin cycle duration by\n-     * making branches unpredictable.)  Also, during an offer, a\n-     * waiter can \"know\" that it will be released when its slot has\n-     * changed, but cannot yet proceed until match is set.  In the\n-     * mean time it cannot cancel the offer, so instead spins\/yields.\n-     * Note: It is possible to avoid this secondary check by changing\n-     * the linearization point to be a CAS of the match field (as done\n-     * in one case in the Scott & Scherer DISC paper), which also\n-     * increases asynchrony a bit, at the expense of poorer collision\n-     * detection and inability to always reuse per-thread nodes. So\n-     * the current scheme is typically a better tradeoff.\n+     * Arena size (the value of field \"bound\") is controlled by random\n+     * sampling. On each miss (collision or spinout), a thread chooses\n+     * a new random index within the arena.  Upon the third collision\n+     * with the same current bound, it tries to grow the arena. And\n+     * upon the second spinout, it tries to shrink. The asymmetry in\n+     * part reflects relative costs, and reduces flailing. Because\n+     * they cannot be changed without also changing the sampling\n+     * strategy, these rules are directly incorporated into uses of\n+     * the xchg \"misses\" variable.  The bound field is tagged with\n+     * sequence numbers to reduce stale decisions. Uniform random\n+     * indices are generated using XorShift with enough bits so that\n+     * bias (See Knuth TAoCP vol 2) is negligible for moduli used here\n+     * (at most 256) without requiring rejection tests. Using\n+     * nonuniform randoms with greater weight to higher indices is\n+     * also possible but does not seem worthwhile in practice.\n@@ -206,11 +192,15 @@\n-     * On collisions, indices traverse the arena cyclically in reverse\n-     * order, restarting at the maximum index (which will tend to be\n-     * sparsest) when bounds change. (On expirations, indices instead\n-     * are halved until reaching 0.) It is possible (and has been\n-     * tried) to use randomized, prime-value-stepped, or double-hash\n-     * style traversal instead of simple cyclic traversal to reduce\n-     * bunching.  But empirically, whatever benefits these may have\n-     * don't overcome their added overhead: We are managing operations\n-     * that occur very quickly unless there is sustained contention,\n-     * so simpler\/faster control policies work better than more\n-     * accurate but slower ones.\n+     * These mechanics rely on a reasonable choice of constant SPINS.\n+     * The time cost of SPINS * Thread.onSpinWait() should be at least\n+     * the expected cost of a park\/unpark context switch, and larger\n+     * than that of two failed CASes, but still small enough to avoid\n+     * excessive delays during arena shrinkage.  We also deal with the\n+     * possibility that when an offering thread waits for a release,\n+     * spin-waiting would be useless because the releasing thread is\n+     * descheduled. On multiprocessors, we cannot know this in\n+     * general. But when Virtual Threads are used, method\n+     * ForkJoinWorkerThread.hasKnownQueuedWork serves as a guide to\n+     * whether to spin or immediately block, allowing a context switch\n+     * that may enable a releaser.  Note also that when many threads\n+     * are being run on few cores, enountering enough collisions to\n+     * trigger arena growth is rare, and soon followed by shrinkage,\n+     * so this doesn't require special handling.\n@@ -218,5 +208,5 @@\n-     * Because we use expiration for arena size control, we cannot\n-     * throw TimeoutExceptions in the timed version of the public\n-     * exchange method until the arena size has shrunken to zero (or\n-     * the arena isn't enabled). This may delay response to timeout\n-     * but is still within spec.\n+     * The basic exchange mechanics rely on checks that Node item\n+     * fields are not null, which doesn't work when offered items are\n+     * null. We trap this case by translating nulls to the\n+     * (un-Exchangeable) value of the static Participant\n+     * reference.\n@@ -224,10 +214,8 @@\n-     * Essentially all of the implementation is in methods\n-     * slotExchange and arenaExchange. These have similar overall\n-     * structure, but differ in too many details to combine. The\n-     * slotExchange method uses the single Exchanger field \"slot\"\n-     * rather than arena array elements. However, it still needs\n-     * minimal collision detection to trigger arena construction.\n-     * (The messiest part is making sure interrupt status and\n-     * InterruptedExceptions come out right during transitions when\n-     * both methods may be called. This is done by using null return\n-     * as a sentinel to recheck interrupt status.)\n+     * Essentially all of the implementation is in method xchg.  As is\n+     * too common in this sort of code, most of the logic relies on\n+     * reads of fields that are maintained as local variables so can't\n+     * be nicely factored. It is structured as a main loop with a\n+     * leading volatile read (of field bound), that causes others to\n+     * be freshly read even though declared in plain mode.  We don't\n+     * use compareAndExchange that would otherwise save some re-reads\n+     * because of the need to recheck indices and bounds on failures.\n@@ -235,18 +223,15 @@\n-     * As is too common in this sort of code, methods are monolithic\n-     * because most of the logic relies on reads of fields that are\n-     * maintained as local variables so can't be nicely factored --\n-     * mainly, here, bulky spin->yield->block\/cancel code.  Note that\n-     * field Node.item is not declared as volatile even though it is\n-     * read by releasing threads, because they only do so after CAS\n-     * operations that must precede access, and all uses by the owning\n-     * thread are otherwise acceptably ordered by other operations.\n-     * (Because the actual points of atomicity are slot CASes, it\n-     * would also be legal for the write to Node.match in a release to\n-     * be weaker than a full volatile write. However, this is not done\n-     * because it could allow further postponement of the write,\n-     * delaying progress.)\n-     *\/\n-\n-    \/**\n-     * The index distance (as a shift value) between any two used slots\n-     * in the arena, spacing them out to avoid false sharing.\n+     * Support for optional timeouts in a single method adds further\n+     * complexity. Note that for the sake of arena bounds control,\n+     * time bounds must be ignored during spinouts, which may delay\n+     * TimeoutExceptions (but no more so than would excessive context\n+     * switching that could occur otherwise).  Responses to\n+     * interruption are handled similarly, postponing commitment to\n+     * throw InterruptedException until successfully cancelled.\n+     *\n+     * Design differences from previous releases include:\n+     * * Accommodation of VirtualThreads.\n+     * * Use of Slots vs spaced indices for the arena and static\n+     *   ThreadLocals, avoiding separate arena vs non-arena modes.\n+     * * Use of random sampling for grow\/shrink decisions, with typically\n+     *   faster and more stable adaptation (as was mentioned as a\n+     *   possible improvement in previous version).\n@@ -254,1 +239,0 @@\n-    private static final int ASHIFT = 5;\n@@ -258,3 +242,3 @@\n-     * arena size is MMASK + 1. Must be a power of two minus one, less\n-     * than (1<<(31-ASHIFT)). The cap of 255 (0xff) more than suffices\n-     * for the expected scaling limits of the main algorithms.\n+     * arena size is MMASK + 1. Must be a power of two minus one. The\n+     * cap of 255 (0xff) more than suffices for the expected scaling\n+     * limits of the main algorithms.\n@@ -270,3 +254,0 @@\n-    \/** The number of CPUs, for sizing and spin control *\/\n-    private static final int NCPU = Runtime.getRuntime().availableProcessors();\n-\n@@ -274,10 +255,2 @@\n-     * The maximum slot index of the arena: The number of slots that\n-     * can in principle hold all threads without contention, or at\n-     * most the maximum indexable value.\n-     *\/\n-    static final int FULL = (NCPU >= (MMASK << 1)) ? MMASK : NCPU >>> 1;\n-\n-    \/**\n-     * The bound for spins while waiting for a match. The actual\n-     * number of iterations will on average be about twice this value\n-     * due to randomization. Note: Spinning is disabled when NCPU==1.\n+     * The bound for spins while waiting for a match before either\n+     * blocking or possibly shrinking arena.\n@@ -288,10 +261,1 @@\n-     * Value representing null arguments\/returns from public\n-     * methods. Needed because the API originally didn't disallow null\n-     * arguments, which it should have.\n-     *\/\n-    private static final Object NULL_ITEM = new Object();\n-\n-    \/**\n-     * Sentinel value returned by internal exchange methods upon\n-     * timeout, to avoid need for separate timed versions of these\n-     * methods.\n+     * Padded arena cells to avoid false-sharing memory contention\n@@ -299,1 +263,4 @@\n-    private static final Object TIMED_OUT = new Object();\n+    @jdk.internal.vm.annotation.Contended\n+    static final class Slot {\n+        Node entry;\n+    }\n@@ -303,1 +270,1 @@\n-     * bookkeeping. Padded via @Contended to reduce memory contention.\n+     * bookkeeping.\n@@ -305,1 +272,2 @@\n-    @jdk.internal.vm.annotation.Contended static final class Node {\n+    static final class Node {\n+        long seed;              \/\/ Random seed\n@@ -307,3 +275,0 @@\n-        int bound;              \/\/ Last recorded value of Exchanger.bound\n-        int collides;           \/\/ Number of CAS failures at current bound\n-        int hash;               \/\/ Pseudo-random for spins\n@@ -313,0 +278,4 @@\n+        Node() {\n+            index = -1;         \/\/ initialize on first use\n+            seed = Thread.currentThread().threadId();\n+        }\n@@ -321,1 +290,4 @@\n-     * Per-thread state.\n+     * The participant thread-locals. Because it is impossible to\n+     * exchange, we also use this reference for dealing with null user\n+     * arguments that are translated in and out of this value\n+     * surrounding use.\n@@ -323,1 +295,1 @@\n-    private final Participant participant;\n+    private static final Participant participant = new Participant();\n@@ -326,2 +298,2 @@\n-     * Elimination array; null until enabled (within slotExchange).\n-     * Element accesses use emulation of volatile gets and CAS.\n+     * Elimination array; element accesses use emulation of volatile\n+     * gets and CAS.\n@@ -329,1 +301,1 @@\n-    private volatile Node[] arena;\n+    private final Slot[] arena;\n@@ -332,1 +304,2 @@\n-     * Slot used until contention detected.\n+     * Number of cores, for sizing and spin control. Computed only\n+     * upon construction.\n@@ -334,1 +307,1 @@\n-    private volatile Node slot;\n+    private final int ncpu;\n@@ -337,4 +310,1 @@\n-     * The index of the largest valid arena position, OR'ed with SEQ\n-     * number in high bits, incremented on each update.  The initial\n-     * update from 0 to SEQ is used to ensure that the arena array is\n-     * constructed only once.\n+     * The index of the largest valid arena position.\n@@ -345,1 +315,1 @@\n-     * Exchange function when arenas enabled. See above for explanation.\n+     * Exchange function. See above for explanation.\n@@ -347,5 +317,5 @@\n-     * @param item the (non-null) item to exchange\n-     * @param timed true if the wait is timed\n-     * @param ns if timed, the maximum wait time, else 0L\n-     * @return the other thread's item; or null if interrupted; or\n-     * TIMED_OUT if timed and timed out\n+     * @param x the item to exchange\n+     * @param deadline if zero, untimed, else timeout deadline\n+     * @return the other thread's item\n+     * @throws InterruptedException if interrupted while waiting\n+     * @throws TimeoutException if deadline nonzero and timed out\n@@ -353,2 +323,3 @@\n-    private final Object arenaExchange(Object item, boolean timed, long ns) {\n-        Node[] a = arena;\n+    private final V xchg(V x, long deadline)\n+        throws InterruptedException, TimeoutException {\n+        Slot[] a = arena;\n@@ -356,14 +327,39 @@\n-        Node p = participant.get();\n-        for (int i = p.index;;) {                      \/\/ access slot at i\n-            int b, m, c;\n-            int j = (i << ASHIFT) + ((1 << ASHIFT) - 1);\n-            if (j < 0 || j >= alen)\n-                j = alen - 1;\n-            Node q = (Node)AA.getAcquire(a, j);\n-            if (q != null && AA.compareAndSet(a, j, q, null)) {\n-                Object v = q.item;                     \/\/ release\n-                q.match = item;\n-                Thread w = q.parked;\n-                if (w != null)\n-                    LockSupport.unpark(w);\n-                return v;\n+        Participant ps = participant;\n+        Object item = (x == null) ? ps : x;      \/\/ translate nulls\n+        Node p = ps.get();\n+        int i = p.index;                         \/\/ if < 0, move\n+        int misses = 0;                          \/\/ ++ on collide, -- on spinout\n+        Object offered = null;                   \/\/ for cleanup\n+        Object v = null;\n+        outer: for (;;) {\n+            int b, m; Slot s; Node q;\n+            if ((m = (b = bound) & MMASK) == 0)  \/\/ volatile read\n+                i = 0;\n+            if (i < 0 || i > m || i >= alen || (s = a[i]) == null) {\n+                long r = p.seed;                 \/\/ randomly move\n+                r ^= r << 13; r ^= r >>> 7; r ^= r << 17; \/\/ xorShift\n+                i = p.index = (int)((p.seed = r) % (m + 1));\n+            }\n+            else if ((q = s.entry) != null) {    \/\/ try release\n+                if (ENTRY.compareAndSet(s, q, null)) {\n+                    Thread w;\n+                    v = q.item;\n+                    q.match = item;\n+                    if (i == 0 && (w = q.parked) != null)\n+                        LockSupport.unpark(w);\n+                    break;\n+                }\n+                else {                           \/\/ collision\n+                    int nb;\n+                    i = -1;                      \/\/ move index\n+                    if (b != bound)              \/\/ stale\n+                        misses = 0;\n+                    else if (misses <= 2)        \/\/ continue sampling\n+                        ++misses;\n+                    else if ((nb = (b + 1) & MMASK) < alen) {\n+                        misses = 0;              \/\/ try to grow\n+                        if (BOUND.compareAndSet(this, b, b + 1 + SEQ) &&\n+                            a[i = p.index = nb] == null)\n+                            AA.compareAndSet(a, nb, null, new Slot());\n+                    }\n+                }\n@@ -371,12 +367,15 @@\n-            else if (i <= (m = (b = bound) & MMASK) && q == null) {\n-                p.item = item;                         \/\/ offer\n-                if (AA.compareAndSet(a, j, null, p)) {\n-                    long end = (timed && m == 0) ? System.nanoTime() + ns : 0L;\n-                    Thread t = Thread.currentThread(); \/\/ wait\n-                    for (int h = p.hash, spins = SPINS;;) {\n-                        Object v = p.match;\n-                        if (v != null) {\n-                            MATCH.setRelease(p, null);\n-                            p.item = null;             \/\/ clear for next use\n-                            p.hash = h;\n-                            return v;\n+            else {                               \/\/ try offer\n+                if (offered == null)\n+                    offered = p.item = item;\n+                if (ENTRY.compareAndSet(s, null, p)) {\n+                    boolean tryCancel;           \/\/ true if interrupted\n+                    Thread t = Thread.currentThread();\n+                    if (!(tryCancel = t.isInterrupted()) && ncpu > 1 &&\n+                        (i != 0 ||               \/\/ check for busy VTs\n+                         (!ForkJoinWorkerThread.hasKnownQueuedWork()))) {\n+                        for (int j = SPINS; j > 0; --j) {\n+                            if ((v = p.match) != null) {\n+                                MATCH.set(p, null);\n+                                break outer;     \/\/ spin wait\n+                            }\n+                            Thread.onSpinWait();\n@@ -384,7 +383,5 @@\n-                        else if (spins > 0) {\n-                            h ^= h << 1; h ^= h >>> 3; h ^= h << 10; \/\/ xorshift\n-                            if (h == 0)                \/\/ initialize hash\n-                                h = SPINS | (int)t.threadId();\n-                            else if (h < 0 &&          \/\/ approx 50% true\n-                                     (--spins & ((SPINS >>> 1) - 1)) == 0)\n-                                Thread.yield();        \/\/ two yields per wait\n+                    }\n+                    for (long ns = 1L;;) {       \/\/ block or cancel offer\n+                        if ((v = p.match) != null) {\n+                            MATCH.set(p, null);\n+                            break outer;\n@@ -392,8 +389,6 @@\n-                        else if (AA.getAcquire(a, j) != p)\n-                            spins = SPINS;       \/\/ releaser hasn't set match yet\n-                        else if (!t.isInterrupted() && m == 0 &&\n-                                 (!timed ||\n-                                  (ns = end - System.nanoTime()) > 0L)) {\n-                            p.parked = t;              \/\/ minimize window\n-                            if (AA.getAcquire(a, j) == p) {\n-                                if (ns == 0L)\n+                        if (i == 0 && !tryCancel &&\n+                            (deadline == 0L ||\n+                             ((ns = deadline - System.nanoTime()) > 0L))) {\n+                            p.parked = t;        \/\/ emable unpark and recheck\n+                            if (p.match == null) {\n+                                if (deadline == 0L)\n@@ -403,0 +398,1 @@\n+                                tryCancel = t.isInterrupted();\n@@ -406,7 +402,2 @@\n-                        else if (AA.getAcquire(a, j) == p &&\n-                                 AA.compareAndSet(a, j, p, null)) {\n-                            if (m != 0)                \/\/ try to shrink\n-                                BOUND.compareAndSet(this, b, b + SEQ - 1);\n-                            p.item = null;\n-                            p.hash = h;\n-                            i = p.index >>>= 1;        \/\/ descend\n+                        else if (ENTRY.compareAndSet(s, p, null)) { \/\/ cancel\n+                            offered = p.item = null;\n@@ -414,4 +405,13 @@\n-                                return null;\n-                            if (timed && m == 0 && ns <= 0L)\n-                                return TIMED_OUT;\n-                            break;                     \/\/ expired; restart\n+                                throw new InterruptedException();\n+                            if (deadline != 0L && ns <= 0L)\n+                                throw new TimeoutException();\n+                            i = -1;              \/\/ move and restart\n+                            if (bound != b)\n+                                misses = 0;      \/\/ stale\n+                            else if (misses >= 0)\n+                                --misses;        \/\/ continue sampling\n+                            else if ((b & MMASK) != 0) {\n+                                misses = 0;      \/\/ try to shrink\n+                                BOUND.compareAndSet(this, b, b - 1 + SEQ);\n+                            }\n+                            continue outer;\n@@ -421,91 +421,0 @@\n-                else\n-                    p.item = null;                     \/\/ clear offer\n-            }\n-            else {\n-                if (p.bound != b) {                    \/\/ stale; reset\n-                    p.bound = b;\n-                    p.collides = 0;\n-                    i = (i != m || m == 0) ? m : m - 1;\n-                }\n-                else if ((c = p.collides) < m || m == FULL ||\n-                         !BOUND.compareAndSet(this, b, b + SEQ + 1)) {\n-                    p.collides = c + 1;\n-                    i = (i == 0) ? m : i - 1;          \/\/ cyclically traverse\n-                }\n-                else\n-                    i = m + 1;                         \/\/ grow\n-                p.index = i;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Exchange function used until arenas enabled. See above for explanation.\n-     *\n-     * @param item the item to exchange\n-     * @param timed true if the wait is timed\n-     * @param ns if timed, the maximum wait time, else 0L\n-     * @return the other thread's item; or null if either the arena\n-     * was enabled or the thread was interrupted before completion; or\n-     * TIMED_OUT if timed and timed out\n-     *\/\n-    private final Object slotExchange(Object item, boolean timed, long ns) {\n-        Node p = participant.get();\n-        Thread t = Thread.currentThread();\n-        if (t.isInterrupted()) \/\/ preserve interrupt status so caller can recheck\n-            return null;\n-\n-        for (Node q;;) {\n-            if ((q = slot) != null) {\n-                if (SLOT.compareAndSet(this, q, null)) {\n-                    Object v = q.item;\n-                    q.match = item;\n-                    Thread w = q.parked;\n-                    if (w != null)\n-                        LockSupport.unpark(w);\n-                    return v;\n-                }\n-                \/\/ create arena on contention, but continue until slot null\n-                if (NCPU > 1 && bound == 0 &&\n-                    BOUND.compareAndSet(this, 0, SEQ))\n-                    arena = new Node[(FULL + 2) << ASHIFT];\n-            }\n-            else if (arena != null)\n-                return null; \/\/ caller must reroute to arenaExchange\n-            else {\n-                p.item = item;\n-                if (SLOT.compareAndSet(this, null, p))\n-                    break;\n-                p.item = null;\n-            }\n-        }\n-\n-        \/\/ await release\n-        int h = p.hash;\n-        long end = timed ? System.nanoTime() + ns : 0L;\n-        int spins = (NCPU > 1) ? SPINS : 1;\n-        Object v;\n-        while ((v = p.match) == null) {\n-            if (spins > 0) {\n-                h ^= h << 1; h ^= h >>> 3; h ^= h << 10;\n-                if (h == 0)\n-                    h = SPINS | (int)t.threadId();\n-                else if (h < 0 && (--spins & ((SPINS >>> 1) - 1)) == 0)\n-                    Thread.yield();\n-            }\n-            else if (slot != p)\n-                spins = SPINS;\n-            else if (!t.isInterrupted() && arena == null &&\n-                     (!timed || (ns = end - System.nanoTime()) > 0L)) {\n-                p.parked = t;\n-                if (slot == p) {\n-                    if (ns == 0L)\n-                        LockSupport.park(this);\n-                    else\n-                        LockSupport.parkNanos(this, ns);\n-                }\n-                p.parked = null;\n-            }\n-            else if (SLOT.compareAndSet(this, p, null)) {\n-                v = timed && ns <= 0L && !t.isInterrupted() ? TIMED_OUT : null;\n-                break;\n@@ -514,4 +423,4 @@\n-        MATCH.setRelease(p, null);\n-        p.item = null;\n-        p.hash = h;\n-        return v;\n+        if (offered != null)                     \/\/ cleanup\n+            p.item = null;\n+        @SuppressWarnings(\"unchecked\") V ret = (v == participant) ? null : (V)v;\n+        return ret;\n@@ -524,1 +433,3 @@\n-        participant = new Participant();\n+        int h = (ncpu = Runtime.getRuntime().availableProcessors()) >>> 1;\n+        int size = (h == 0) ? 1 : (h > MMASK) ? MMASK + 1 : h;\n+        (arena = new Slot[size])[0] = new Slot();\n@@ -560,1 +471,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -562,9 +472,5 @@\n-        Object v;\n-        Node[] a;\n-        Object item = (x == null) ? NULL_ITEM : x; \/\/ translate null args\n-        if (((a = arena) != null ||\n-             (v = slotExchange(item, false, 0L)) == null) &&\n-            (Thread.interrupted() || \/\/ disambiguates null return\n-             (v = arenaExchange(item, false, 0L)) == null))\n-            throw new InterruptedException();\n-        return (v == NULL_ITEM) ? null : (V)v;\n+        try {\n+            return xchg(x, 0L);\n+        } catch (TimeoutException cannotHappen) {\n+            return null; \/\/ not reached\n+        }\n@@ -615,1 +521,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -618,11 +523,2 @@\n-        Object v;\n-        Object item = (x == null) ? NULL_ITEM : x;\n-        long ns = unit.toNanos(timeout);\n-        if ((arena != null ||\n-             (v = slotExchange(item, true, ns)) == null) &&\n-            (Thread.interrupted() ||\n-             (v = arenaExchange(item, true, ns)) == null))\n-            throw new InterruptedException();\n-        if (v == TIMED_OUT)\n-            throw new TimeoutException();\n-        return (v == NULL_ITEM) ? null : (V)v;\n+        long d = unit.toNanos(timeout) + System.nanoTime();\n+        return xchg(x, (d == 0L) ? 1L : d); \/\/ avoid zero deadline\n@@ -633,1 +529,0 @@\n-    private static final VarHandle SLOT;\n@@ -635,0 +530,1 @@\n+    private static final VarHandle ENTRY;\n@@ -640,1 +536,0 @@\n-            SLOT = l.findVarHandle(Exchanger.class, \"slot\", Node.class);\n@@ -642,1 +537,2 @@\n-            AA = MethodHandles.arrayElementVarHandle(Node[].class);\n+            ENTRY = l.findVarHandle(Slot.class, \"entry\", Node.class);\n+            AA = MethodHandles.arrayElementVarHandle(Slot[].class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Exchanger.java","additions":223,"deletions":327,"binary":false,"changes":550,"status":"modified"},{"patch":"@@ -673,1 +673,1 @@\n-     * released soon therafter. This is checked by setting the\n+     * released soon thereafter. This is checked by setting the\n@@ -858,1 +858,1 @@\n-     * exceptions is preferred to throwing InterruptedExecptions,\n+     * exceptions is preferred to throwing InterruptedExceptions,\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1075,1 +1075,1 @@\n-     * (possibly exceptionally) before the given timeout and\n+     * (possibly exceptionally) before the given timeout elapsed and\n@@ -1100,1 +1100,1 @@\n-     * (possibly exceptionally) before the given timeout.\n+     * (possibly exceptionally) before the given timeout elapsed.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -205,0 +207,24 @@\n+    \/**\n+     * Returns true if the current task is being executed by a\n+     * ForkJoinWorkerThread that is momentarily known to have one or\n+     * more queued tasks that it could execute immediately. This\n+     * method is approximate and useful only as a heuristic indicator\n+     * within a running task.\n+     *\n+     * @return true if the current task is being executed by a worker\n+     * that has queued work\n+     *\/\n+    static boolean hasKnownQueuedWork() {\n+        ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue q, sq;\n+        ForkJoinPool p; ForkJoinPool.WorkQueue[] qs; int i;\n+        Thread c = JLA.currentCarrierThread();\n+        return ((c instanceof ForkJoinWorkerThread) &&\n+                (p = (wt = (ForkJoinWorkerThread)c).pool) != null &&\n+                (q = wt.workQueue) != null &&\n+                (i = q.source) >= 0 && \/\/ check local and current source queues\n+                (((qs = p.queues) != null && qs.length > i &&\n+                  (sq = qs[i]) != null && sq.top - sq.base > 0) ||\n+                 q.top - q.base > 0));\n+    }\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinWorkerThread.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -429,2 +429,2 @@\n-            if (w.isVirtual())             \/\/ don't spin\n-                spin = false;\n+            if (spin && ForkJoinWorkerThread.hasKnownQueuedWork())\n+                spin = false;              \/\/ don't spin\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/LinkedTransferQueue.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -197,7 +197,10 @@\n-            static final TerminalOp<?, ?> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.REFERENCE, Optional.empty(),\n-                    Optional::isPresent, FindSink.OfRef::new);\n-\n-            static final TerminalOp<?, ?> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.REFERENCE, Optional.empty(),\n-                    Optional::isPresent, FindSink.OfRef::new);\n+            static final TerminalOp<?, ?> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<Optional<Object>> isPresent = Optional::isPresent;\n+                Supplier<TerminalSink<Object, Optional<Object>>> newSink\n+                        = FindSink.OfRef::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.REFERENCE,\n+                        Optional.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.REFERENCE,\n+                        Optional.empty(), isPresent, newSink);\n+            }\n@@ -220,6 +223,10 @@\n-            static final TerminalOp<Integer, OptionalInt> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.INT_VALUE, OptionalInt.empty(),\n-                    OptionalInt::isPresent, FindSink.OfInt::new);\n-            static final TerminalOp<Integer, OptionalInt> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.INT_VALUE, OptionalInt.empty(),\n-                    OptionalInt::isPresent, FindSink.OfInt::new);\n+            static final TerminalOp<Integer, OptionalInt> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<OptionalInt> isPresent = OptionalInt::isPresent;\n+                Supplier<TerminalSink<Integer, OptionalInt>> newSink\n+                        = FindSink.OfInt::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.INT_VALUE,\n+                        OptionalInt.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.INT_VALUE,\n+                        OptionalInt.empty(), isPresent, newSink);\n+            }\n@@ -242,6 +249,10 @@\n-            static final TerminalOp<Long, OptionalLong> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.LONG_VALUE, OptionalLong.empty(),\n-                    OptionalLong::isPresent, FindSink.OfLong::new);\n-            static final TerminalOp<Long, OptionalLong> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.LONG_VALUE, OptionalLong.empty(),\n-                    OptionalLong::isPresent, FindSink.OfLong::new);\n+            static final TerminalOp<Long, OptionalLong> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<OptionalLong> isPresent = OptionalLong::isPresent;\n+                Supplier<TerminalSink<Long, OptionalLong>> newSink\n+                        = FindSink.OfLong::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.LONG_VALUE,\n+                        OptionalLong.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.LONG_VALUE,\n+                        OptionalLong.empty(), isPresent, newSink);\n+            }\n@@ -264,6 +275,10 @@\n-            static final TerminalOp<Double, OptionalDouble> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.DOUBLE_VALUE, OptionalDouble.empty(),\n-                    OptionalDouble::isPresent, FindSink.OfDouble::new);\n-            static final TerminalOp<Double, OptionalDouble> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.DOUBLE_VALUE, OptionalDouble.empty(),\n-                    OptionalDouble::isPresent, FindSink.OfDouble::new);\n+            static final TerminalOp<Double, OptionalDouble> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<OptionalDouble> isPresent = OptionalDouble::isPresent;\n+                Supplier<TerminalSink<Double, OptionalDouble>> newSink\n+                        = FindSink.OfDouble::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.DOUBLE_VALUE,\n+                        OptionalDouble.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.DOUBLE_VALUE,\n+                        OptionalDouble.empty(), isPresent, newSink);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/FindOps.java","additions":40,"deletions":25,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -449,0 +449,2 @@\n+    Object stringConcat1(String[] constants);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,1 @@\n-    internals of java.lang.reflect. *\/\n-\n+    internals of java.lang.reflect. Use as a last resort! *\/\n@@ -35,25 +34,5 @@\n-    \/** Creates a new java.lang.reflect.Constructor. Access checks as\n-      per java.lang.reflect.AccessibleObject are not overridden. *\/\n-    public <T> Constructor<T> newConstructor(Class<T> declaringClass,\n-                                             Class<?>[] parameterTypes,\n-                                             Class<?>[] checkedExceptions,\n-                                             int modifiers,\n-                                             int slot,\n-                                             String signature,\n-                                             byte[] annotations,\n-                                             byte[] parameterAnnotations);\n-\n-    \/** Gets the MethodAccessor object for a java.lang.reflect.Method *\/\n-    public MethodAccessor getMethodAccessor(Method m);\n-\n-    \/** Sets the MethodAccessor object for a java.lang.reflect.Method *\/\n-    public void setMethodAccessor(Method m, MethodAccessor accessor);\n-\n-    \/** Gets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c);\n-\n-    \/** Sets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor);\n+    \/**\n+     * Creates a new root constructor from the original one, with\n+     * a custom accessor. Used by serialization hooks.\n+     *\/\n+    <T> Constructor<T> newConstructorWithAccessor(Constructor<T> original, ConstructorAccessor accessor);\n@@ -64,12 +43,0 @@\n-    \/** Gets the \"slot\" field from a Constructor (used for serialization) *\/\n-    public int getConstructorSlot(Constructor<?> c);\n-\n-    \/** Gets the \"signature\" field from a Constructor (used for serialization) *\/\n-    public String getConstructorSignature(Constructor<?> c);\n-\n-    \/** Gets the \"annotations\" field from a Constructor (used for serialization) *\/\n-    public byte[] getConstructorAnnotations(Constructor<?> c);\n-\n-    \/** Gets the \"parameterAnnotations\" field from a Constructor (used for serialization) *\/\n-    public byte[] getConstructorParameterAnnotations(Constructor<?> c);\n-\n@@ -82,1 +49,0 @@\n-    \/\/\n@@ -85,1 +51,0 @@\n-    \/\/\n@@ -90,3 +55,0 @@\n-    \/** Makes a copy of this non-root a Method *\/\n-    public Method      leafCopyMethod(Method arg);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":7,"deletions":45,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -56,1 +56,7 @@\n-    for this purpose, namely the loss of compile-time checking. *\/\n+    for this purpose, namely the loss of compile-time checking.\n+ * <p><strong>\n+ * Usage of these APIs often means bad encapsulation designs,\n+ * increased complexity and lack of sustainability.\n+ * Use this only as a last resort!\n+ * <\/strong>\n+ *\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -660,1 +660,1 @@\n-            AnnotationReader.writeAnnotations(buf, attr.annotations());\n+            AnnotationReader.writeTypeAnnotations(buf, attr.annotations());\n@@ -717,1 +717,1 @@\n-            AnnotationReader.writeAnnotations(buf, attr.annotations());\n+            AnnotationReader.writeTypeAnnotations(buf, attr.annotations());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -537,9 +537,0 @@\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (o == this) { return true; }\n-            if (o instanceof AbstractNamedEntry ne) {\n-                return tag == ne.tag() && name().equals(ref1());\n-            }\n-            return false;\n-        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-        implements Annotation, Util.Writable {\n+        implements Annotation {\n@@ -40,10 +40,0 @@\n-    @Override\n-    public void writeTo(BufWriterImpl buf) {\n-        buf.writeIndex(className());\n-        buf.writeU2(elements().size());\n-        for (var e : elements) {\n-            buf.writeIndex(e.name());\n-            AnnotationReader.writeAnnotationValue(buf, e.value());\n-        }\n-    }\n-\n@@ -55,8 +45,0 @@\n-        if (!evps.isEmpty())\n-            sb.append(\" [\");\n-        for (AnnotationElement evp : evps) {\n-            sb.append(evp.name().stringValue())\n-                    .append(\"=\")\n-                    .append(evp.value().toString())\n-                    .append(\", \");\n-        }\n@@ -64,2 +46,1 @@\n-            sb.delete(sb.length()-1, sb.length());\n-            sb.append(\"]\");\n+            sb.append(' ').append(evps);\n@@ -73,2 +54,1 @@\n-            implements AnnotationElement, Util.Writable {\n-\n+            implements AnnotationElement {\n@@ -76,3 +56,2 @@\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeIndex(name());\n-            AnnotationReader.writeAnnotationValue(buf, value());\n+        public String toString() {\n+            return name + \"=\" + value;\n@@ -82,10 +61,0 @@\n-    public sealed interface OfConstantImpl extends AnnotationValue.OfConstant, Util.Writable {\n-\n-        @Override\n-        default void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeIndex(constant());\n-        }\n-\n-    }\n-\n@@ -93,2 +62,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfString {\n-\n+            implements AnnotationValue.OfString {\n@@ -107,2 +75,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfDouble {\n-\n+            implements AnnotationValue.OfDouble {\n@@ -121,2 +88,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfFloat {\n-\n+            implements AnnotationValue.OfFloat {\n@@ -135,2 +101,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfLong {\n-\n+            implements AnnotationValue.OfLong {\n@@ -149,2 +114,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfInt {\n-\n+            implements AnnotationValue.OfInt {\n@@ -163,2 +127,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfShort {\n-\n+            implements AnnotationValue.OfShort {\n@@ -177,2 +140,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfChar {\n-\n+            implements AnnotationValue.OfChar {\n@@ -191,2 +153,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfByte {\n-\n+            implements AnnotationValue.OfByte {\n@@ -205,2 +166,1 @@\n-            implements OfConstantImpl, AnnotationValue.OfBoolean {\n-\n+            implements AnnotationValue.OfBoolean {\n@@ -219,2 +179,1 @@\n-            implements AnnotationValue.OfArray, Util.Writable {\n-\n+            implements AnnotationValue.OfArray {\n@@ -229,10 +188,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeU2(values.size());\n-            for (var e : values) {\n-                AnnotationReader.writeAnnotationValue(buf, e);\n-            }\n-        }\n-\n@@ -242,1 +191,1 @@\n-            implements AnnotationValue.OfEnum, Util.Writable {\n+            implements AnnotationValue.OfEnum {\n@@ -247,8 +196,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeIndex(className);\n-            buf.writeIndex(constantName);\n-        }\n-\n@@ -258,1 +199,1 @@\n-            implements AnnotationValue.OfAnnotation, Util.Writable {\n+            implements AnnotationValue.OfAnnotation {\n@@ -263,7 +204,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            AnnotationReader.writeAnnotation(buf, annotation);\n-        }\n-\n@@ -273,1 +207,1 @@\n-            implements AnnotationValue.OfClass, Util.Writable {\n+            implements AnnotationValue.OfClass {\n@@ -278,7 +212,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeIndex(className);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationImpl.java","additions":18,"deletions":91,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -244,4 +244,2 @@\n-        Utf8Entry type = classReader.readEntry(p, Utf8Entry.class);\n-        p += 2;\n-        return TypeAnnotation.of(targetInfo, List.of(typePath), type,\n-                                 readAnnotationElementValuePairs(classReader, p));\n+        var anno = readAnnotation(classReader, p);\n+        return TypeAnnotation.of(targetInfo, List.of(typePath), anno);\n@@ -286,3 +284,7 @@\n-        \/\/ handles annotations and type annotations\n-        \/\/ TODO annotation cleanup later\n-        ((Util.Writable) annotation).writeTo(buf);\n+        buf.writeIndex(annotation.className());\n+        var elements = annotation.elements();\n+        buf.writeU2(elements.size());\n+        for (var e : elements) {\n+            buf.writeIndex(e.name());\n+            AnnotationReader.writeAnnotationValue(buf, e.value());\n+        }\n@@ -291,2 +293,1 @@\n-    public static void writeAnnotations(BufWriter buf, List<? extends Annotation> list) {\n-        \/\/ handles annotations and type annotations\n+    public static void writeAnnotations(BufWriter buf, List<Annotation> list) {\n@@ -300,0 +301,60 @@\n+    private static int labelToBci(LabelContext lr, Label label, TypeAnnotation ta) {\n+        \/\/helper method to avoid NPE\n+        if (lr == null) throw new IllegalArgumentException(\"Illegal targetType '%s' in TypeAnnotation outside of Code attribute\".formatted(ta.targetInfo().targetType()));\n+        return lr.labelToBci(label);\n+    }\n+\n+    public static void writeTypeAnnotation(BufWriterImpl buf, TypeAnnotation ta) {\n+        LabelContext lr = buf.labelContext();\n+        \/\/ target_type\n+        buf.writeU1(ta.targetInfo().targetType().targetTypeValue());\n+\n+        \/\/ target_info\n+        switch (ta.targetInfo()) {\n+            case TypeAnnotation.TypeParameterTarget tpt -> buf.writeU1(tpt.typeParameterIndex());\n+            case TypeAnnotation.SupertypeTarget st -> buf.writeU2(st.supertypeIndex());\n+            case TypeAnnotation.TypeParameterBoundTarget tpbt -> {\n+                buf.writeU1(tpbt.typeParameterIndex());\n+                buf.writeU1(tpbt.boundIndex());\n+            }\n+            case TypeAnnotation.EmptyTarget _ -> {\n+                \/\/ nothing to write\n+            }\n+            case TypeAnnotation.FormalParameterTarget fpt -> buf.writeU1(fpt.formalParameterIndex());\n+            case TypeAnnotation.ThrowsTarget tt -> buf.writeU2(tt.throwsTargetIndex());\n+            case TypeAnnotation.LocalVarTarget lvt -> {\n+                buf.writeU2(lvt.table().size());\n+                for (var e : lvt.table()) {\n+                    int startPc = labelToBci(lr, e.startLabel(), ta);\n+                    buf.writeU2(startPc);\n+                    buf.writeU2(labelToBci(lr, e.endLabel(), ta) - startPc);\n+                    buf.writeU2(e.index());\n+                }\n+            }\n+            case TypeAnnotation.CatchTarget ct -> buf.writeU2(ct.exceptionTableIndex());\n+            case TypeAnnotation.OffsetTarget ot -> buf.writeU2(labelToBci(lr, ot.target(), ta));\n+            case TypeAnnotation.TypeArgumentTarget tat -> {\n+                buf.writeU2(labelToBci(lr, tat.target(), ta));\n+                buf.writeU1(tat.typeArgumentIndex());\n+            }\n+        }\n+\n+        \/\/ target_path\n+        buf.writeU1(ta.targetPath().size());\n+        for (TypeAnnotation.TypePathComponent component : ta.targetPath()) {\n+            buf.writeU1(component.typePathKind().tag());\n+            buf.writeU1(component.typeArgumentIndex());\n+        }\n+\n+        \/\/ annotation data\n+        writeAnnotation(buf, ta.annotation());\n+    }\n+\n+    public static void writeTypeAnnotations(BufWriter buf, List<TypeAnnotation> list) {\n+        var internalBuf = (BufWriterImpl) buf;\n+        internalBuf.writeU2(list.size());\n+        for (var e : list) {\n+            writeTypeAnnotation(internalBuf, e);\n+        }\n+    }\n+\n@@ -301,2 +362,21 @@\n-        \/\/ TODO annotation cleanup later\n-        ((Util.Writable) value).writeTo(buf);\n+        var tag = value.tag();\n+        buf.writeU1(tag);\n+        switch (value.tag()) {\n+            case AEV_BOOLEAN, AEV_BYTE, AEV_CHAR, AEV_DOUBLE, AEV_FLOAT, AEV_INT, AEV_LONG, AEV_SHORT, AEV_STRING ->\n+                    buf.writeIndex(((AnnotationValue.OfConstant) value).constant());\n+            case AEV_CLASS -> buf.writeIndex(((AnnotationValue.OfClass) value).className());\n+            case AEV_ENUM -> {\n+                var enumValue = (AnnotationValue.OfEnum) value;\n+                buf.writeIndex(enumValue.className());\n+                buf.writeIndex(enumValue.constantName());\n+            }\n+            case AEV_ANNOTATION -> writeAnnotation(buf, ((AnnotationValue.OfAnnotation) value).annotation());\n+            case AEV_ARRAY -> {\n+                var array = ((AnnotationValue.OfArray) value).values();\n+                buf.writeU2(array.size());\n+                for (var e : array) {\n+                    writeAnnotationValue(buf, e);\n+                }\n+            }\n+            default -> throw new InternalError(\"Unknown value \" + value);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":91,"deletions":11,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -56,0 +56,8 @@\n+    @SuppressWarnings(\"unchecked\")\n+    <A> A get(AttributeMapper<A> am) {\n+        for (Attribute<?> a : attributes)\n+            if (a.attributeMapper() == am)\n+                return (A)a;\n+        return null;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AttributeHolder.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -176,6 +176,1 @@\n-            builder.withCode(new Consumer<>() {\n-                @Override\n-                public void accept(CodeBuilder cb) {\n-                    forEach(cb);\n-                }\n-            });\n+            builder.withCode(Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -107,6 +107,1 @@\n-            builder.withField(name, desc, new Consumer<>() {\n-                @Override\n-                public void accept(FieldBuilder fieldBuilder) {\n-                    elements.forEach(fieldBuilder);\n-                }\n-            });\n+            builder.withField(name, desc, Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedFieldBuilder.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -208,6 +208,1 @@\n-            builder.withMethod(methodName(), methodType(), methodFlags(), new Consumer<>() {\n-                @Override\n-                public void accept(MethodBuilder mb) {\n-                    forEach(mb);\n-                }\n-            });\n+            builder.withMethod(methodName(), methodType(), methodFlags(), Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedMethodBuilder.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -278,9 +278,1 @@\n-\n-        var bootstrapDesc = desc.bootstrapMethod();\n-        ClassEntry bsOwner = constantPool.classEntry(bootstrapDesc.owner());\n-        NameAndTypeEntry bsNameAndType = constantPool.nameAndTypeEntry(bootstrapDesc.methodName(),\n-                                                               bootstrapDesc.invocationType());\n-        int bsRefKind = bootstrapDesc.refKind();\n-\n-        MemberRefEntry memberRefEntry = toBootstrapMemberRef(constantPool, bsRefKind, bsOwner, bsNameAndType, bootstrapDesc.isOwnerInterface());\n-        MethodHandleEntry methodHandleEntry = constantPool.methodHandleEntry(bsRefKind, memberRefEntry);\n+        MethodHandleEntry methodHandleEntry = handleDescToHandleInfo(constantPool, desc.bootstrapMethod());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -81,0 +82,9 @@\n+    @Override\n+    public ClassBuilder withMethod(String name, MethodTypeDesc descriptor, int flags, Consumer<? super MethodBuilder> handler) {\n+        var mb = new BufferedMethodBuilder(terminal.constantPool, terminal.context,\n+                constantPool().utf8Entry(name), constantPool().utf8Entry(descriptor), flags, null);\n+        mb.mDesc = descriptor;\n+        consumer.accept(mb.run(handler).toModel());\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedClassBuilder.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1041,1 +1041,1 @@\n-                        .with(leaf(\"annotation class\", a.className().stringValue()),\n+                        .with(leaf(\"annotation class\", a.annotation().className().stringValue()),\n@@ -1043,1 +1043,1 @@\n-                        .with(elementValuePairsToTree(a.elements()))));\n+                        .with(elementValuePairsToTree(a.annotation().elements()))));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -404,3 +404,1 @@\n-                a.targetPath(), map(a.classSymbol()),\n-                a.elements().stream().map(el -> AnnotationElement.of(el.name(),\n-                        mapAnnotationValue(el.value()))).toList())).toList();\n+                a.targetPath(), mapAnnotation(a.annotation()))).toList();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -150,6 +150,1 @@\n-                                    new Consumer<CodeBuilder>() {\n-                                        @Override\n-                                        public void accept(CodeBuilder cb) {\n-                                            forEach(cb);\n-                                        }\n-                                    },\n+                                    Util.writingAll(this),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -109,0 +110,7 @@\n+    @Override\n+    public ClassBuilder withMethod(String name, MethodTypeDesc descriptor, int flags, Consumer<? super MethodBuilder> handler) {\n+        var method = new DirectMethodBuilder(constantPool, context, constantPool.utf8Entry(name), constantPool.utf8Entry(descriptor), flags, null);\n+        method.mDesc = descriptor;\n+        return withMethod(method.run(handler));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,6 +102,1 @@\n-            builder.withField(fieldName(), fieldType(), new Consumer<>() {\n-                @Override\n-                public void accept(FieldBuilder fb) {\n-                    FieldImpl.this.forEach(fb);\n-                }\n-            });\n+            builder.withField(fieldName(), fieldType(), Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/FieldImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -139,7 +139,1 @@\n-            builder.withMethod(methodName(), methodType(), methodFlags(),\n-                               new Consumer<>() {\n-                @Override\n-                public void accept(MethodBuilder mb) {\n-                    MethodImpl.this.forEach(mb);\n-                }\n-            });\n+            builder.withMethod(methodName(), methodType(), methodFlags(), Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.Attributes;\n@@ -29,0 +30,2 @@\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n@@ -32,0 +35,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -38,0 +42,1 @@\n+import java.util.stream.Collectors;\n@@ -40,2 +45,0 @@\n-import java.lang.constant.ClassDesc;\n-import java.util.stream.Collectors;\n@@ -50,0 +53,1 @@\n+                dcb.attributes.get(Attributes.stackMapTable()),\n@@ -100,0 +104,1 @@\n+                     StackMapTableAttribute smta,\n@@ -114,1 +119,2 @@\n-        maxStack = stack = rets = 0;\n+        stack = rets = 0;\n+        maxStack = handlers.isEmpty() ? 0 : 1;\n@@ -116,0 +122,11 @@\n+        if (smta != null) {\n+            for (var smfi : smta.entries()) {\n+                int frameStack = smfi.stack().size();\n+                for (var vti : smfi.stack()) {\n+                    if (vti == StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_LONG\n+                     || vti == StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_DOUBLE) frameStack++;\n+                }\n+                if (maxStack < frameStack) maxStack = frameStack;\n+                targets.add(new Target(labelContext.labelToBci(smfi.target()), frameStack));\n+            }\n+        }\n@@ -316,1 +333,1 @@\n-                        addStackSlot(Util.slotSize(mtd.returnType()) - Util.parameterSlots(mtd));\n+                        var delta = Util.slotSize(mtd.returnType()) - Util.parameterSlots(mtd);\n@@ -318,1 +335,1 @@\n-                            addStackSlot(-1);\n+                            delta--;\n@@ -320,0 +337,1 @@\n+                        addStackSlot(delta);\n@@ -322,1 +340,1 @@\n-                        addStackSlot (1 - bcs.getU1(bcs.bci + 3));\n+                        addStackSlot(1 - bcs.getU1(bcs.bci + 3));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.classfile.AnnotationElement;\n@@ -39,1 +38,0 @@\n-import java.lang.classfile.Label;\n@@ -761,52 +759,1 @@\n-                                        Utf8Entry className,\n-                                        List<AnnotationElement> elements) implements TypeAnnotation, Util.Writable {\n-\n-        public UnboundTypeAnnotation(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                                     Utf8Entry className, List<AnnotationElement> elements) {\n-            this.targetInfo = targetInfo;\n-            this.targetPath = List.copyOf(targetPath);\n-            this.className = className;\n-            this.elements = List.copyOf(elements);\n-        }\n-\n-        private int labelToBci(LabelContext lr, Label label) {\n-            \/\/helper method to avoid NPE\n-            if (lr == null) throw new IllegalArgumentException(\"Illegal targetType '%s' in TypeAnnotation outside of Code attribute\".formatted(targetInfo.targetType()));\n-            return lr.labelToBci(label);\n-        }\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            LabelContext lr = buf.labelContext();\n-            \/\/ target_type\n-            buf.writeU1(targetInfo.targetType().targetTypeValue());\n-\n-            \/\/ target_info\n-            switch (targetInfo) {\n-                case TypeParameterTarget tpt -> buf.writeU1(tpt.typeParameterIndex());\n-                case SupertypeTarget st -> buf.writeU2(st.supertypeIndex());\n-                case TypeParameterBoundTarget tpbt -> {\n-                    buf.writeU1(tpbt.typeParameterIndex());\n-                    buf.writeU1(tpbt.boundIndex());\n-                }\n-                case EmptyTarget et -> {\n-                    \/\/ nothing to write\n-                }\n-                case FormalParameterTarget fpt -> buf.writeU1(fpt.formalParameterIndex());\n-                case ThrowsTarget tt -> buf.writeU2(tt.throwsTargetIndex());\n-                case LocalVarTarget lvt -> {\n-                    buf.writeU2(lvt.table().size());\n-                    for (var e : lvt.table()) {\n-                        int startPc = labelToBci(lr, e.startLabel());\n-                        buf.writeU2(startPc);\n-                        buf.writeU2(labelToBci(lr, e.endLabel()) - startPc);\n-                        buf.writeU2(e.index());\n-                    }\n-                }\n-                case CatchTarget ct -> buf.writeU2(ct.exceptionTableIndex());\n-                case OffsetTarget ot -> buf.writeU2(labelToBci(lr, ot.target()));\n-                case TypeArgumentTarget tat -> {\n-                    buf.writeU2(labelToBci(lr, tat.target()));\n-                    buf.writeU1(tat.typeArgumentIndex());\n-                }\n-            }\n+                                        Annotation annotation) implements TypeAnnotation {\n@@ -814,16 +761,2 @@\n-            \/\/ target_path\n-            buf.writeU1(targetPath().size());\n-            for (TypePathComponent component : targetPath()) {\n-                buf.writeU1(component.typePathKind().tag());\n-                buf.writeU1(component.typeArgumentIndex());\n-            }\n-\n-            \/\/ type_index\n-            buf.writeIndex(className);\n-\n-            \/\/ element_value_pairs\n-            buf.writeU2(elements.size());\n-            for (AnnotationElement pair : elements()) {\n-                buf.writeIndex(pair.name());\n-                AnnotationReader.writeAnnotationValue(buf, pair.value());\n-            }\n+        public UnboundTypeAnnotation {\n+            targetPath = List.copyOf(targetPath);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":3,"deletions":70,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.classfile.CodeBuilder;\n@@ -28,0 +29,2 @@\n+import java.lang.classfile.FieldBuilder;\n+import java.lang.classfile.MethodBuilder;\n@@ -66,0 +69,30 @@\n+    public static <T> Consumer<Consumer<T>> writingAll(Iterable<T> container) {\n+        record ForEachConsumer<T>(Iterable<T> container) implements Consumer<Consumer<T>> {\n+            @Override\n+            public void accept(Consumer<T> consumer) {\n+                container.forEach(consumer);\n+            }\n+        }\n+        return new ForEachConsumer<>(container);\n+    }\n+\n+    public static Consumer<MethodBuilder> buildingCode(Consumer<? super CodeBuilder> codeHandler) {\n+        record WithCodeMethodHandler(Consumer<? super CodeBuilder> codeHandler) implements Consumer<MethodBuilder> {\n+            @Override\n+            public void accept(MethodBuilder builder) {\n+                builder.withCode(codeHandler);\n+            }\n+        }\n+        return new WithCodeMethodHandler(codeHandler);\n+    }\n+\n+    public static Consumer<FieldBuilder> buildingFlags(int flags) {\n+        record WithFlagFieldHandler(int flags) implements Consumer<FieldBuilder> {\n+            @Override\n+            public void accept(FieldBuilder builder) {\n+                builder.withFlags(flags);\n+            }\n+        }\n+        return new WithFlagFieldHandler(flags);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -396,1 +396,1 @@\n-            l += 2 + an.targetInfo().size() + 2 * an.targetPath().size() + annotationSize(an);\n+            l += 2 + an.targetInfo().size() + 2 * an.targetPath().size() + annotationSize(an.annotation());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import static jdk.internal.constant.PrimitiveClassDescImpl.*;\n+\n@@ -272,33 +274,13 @@\n-    \/**\n-     * Parses a method descriptor string, and return a list of field descriptor\n-     * strings, return type first, then parameter types\n-     *\n-     * @param descriptor the descriptor string\n-     * @return the list of types\n-     * @throws IllegalArgumentException if the descriptor string is not valid\n-     *\/\n-    public static List<ClassDesc> parseMethodDescriptor(String descriptor) {\n-        int cur = 0, end = descriptor.length();\n-        ArrayList<ClassDesc> ptypes = new ArrayList<>();\n-        ptypes.add(null); \/\/ placeholder for return type\n-\n-        if (cur >= end || descriptor.charAt(cur) != '(')\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-\n-        ++cur;  \/\/ skip '('\n-        while (cur < end && descriptor.charAt(cur) != ')') {\n-            int len = skipOverFieldSignature(descriptor, cur, end, false);\n-            if (len == 0)\n-                throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-            ptypes.add(resolveClassDesc(descriptor, cur, len));\n-            cur += len;\n-        }\n-        if (cur >= end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ++cur;  \/\/ skip ')'\n-\n-        int rLen = skipOverFieldSignature(descriptor, cur, end, true);\n-        if (rLen == 0 || cur + rLen != end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ptypes.set(0, resolveClassDesc(descriptor, cur, rLen));\n-        return ptypes;\n+    public static PrimitiveClassDescImpl forPrimitiveType(String descriptor, int offset) {\n+        return switch (descriptor.charAt(offset)) {\n+            case JVM_SIGNATURE_BYTE    -> CD_byte;\n+            case JVM_SIGNATURE_CHAR    -> CD_char;\n+            case JVM_SIGNATURE_FLOAT   -> CD_float;\n+            case JVM_SIGNATURE_DOUBLE  -> CD_double;\n+            case JVM_SIGNATURE_INT     -> CD_int;\n+            case JVM_SIGNATURE_LONG    -> CD_long;\n+            case JVM_SIGNATURE_SHORT   -> CD_short;\n+            case JVM_SIGNATURE_VOID    -> CD_void;\n+            case JVM_SIGNATURE_BOOLEAN -> CD_boolean;\n+            default -> throw badMethodDescriptor(descriptor);\n+        };\n@@ -307,1 +289,1 @@\n-    private static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n+    static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n@@ -309,1 +291,1 @@\n-            return Wrapper.forPrimitiveType(descriptor.charAt(start)).basicClassDescriptor();\n+            return forPrimitiveType(descriptor, start);\n@@ -311,1 +293,2 @@\n-        \/\/ Pre-verified in parseMethodDescriptor; avoid redundant verification\n+\n+        \/\/ Pre-verified in MethodTypeDescImpl#ofDescriptor; avoid redundant verification\n@@ -315,0 +298,4 @@\n+    static IllegalArgumentException badMethodDescriptor(String descriptor) {\n+        return new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+    }\n+\n@@ -319,2 +306,0 @@\n-    private static final char JVM_SIGNATURE_ENDCLASS = ';';\n-    private static final char JVM_SIGNATURE_ENUM = 'E';\n@@ -323,2 +308,0 @@\n-    private static final char JVM_SIGNATURE_FUNC = '(';\n-    private static final char JVM_SIGNATURE_ENDFUNC = ')';\n@@ -337,1 +320,0 @@\n-     * @param voidOK is void acceptable?\n@@ -341,2 +323,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n-    static int skipOverFieldSignature(String descriptor, int start, int end, boolean voidOK) {\n+    static int skipOverFieldSignature(String descriptor, int start, int end) {\n@@ -345,3 +326,10 @@\n-        while (index < end) {\n-            switch (descriptor.charAt(index)) {\n-                case JVM_SIGNATURE_VOID: if (!voidOK) { return 0; }\n+        if (index < end) {\n+            char ch;\n+            while ((ch = descriptor.charAt(index++)) == JVM_SIGNATURE_ARRAY) {\n+                arrayDim++;\n+            }\n+            if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+                throw maxArrayTypeDescDimensions();\n+            }\n+\n+            switch (ch) {\n@@ -356,1 +344,1 @@\n-                    return index - start + 1;\n+                    return index - start;\n@@ -361,2 +349,2 @@\n-                    while (++index < end) {\n-                        switch (descriptor.charAt(index)) {\n+                    while (index < end) {\n+                        switch (descriptor.charAt(index++)) {\n@@ -365,1 +353,1 @@\n-                                return legal ? index - start + 1 : 0;\n+                                return legal ? index - start : 0;\n@@ -380,10 +368,0 @@\n-                    return 0;\n-                case JVM_SIGNATURE_ARRAY:\n-                    arrayDim++;\n-                    if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-                        throw new IllegalArgumentException(String.format(\"Cannot create an array type descriptor with more than %d dimensions\",\n-                                ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n-                    }\n-                    \/\/ The rest of what's there better be a legal descriptor\n-                    index++;\n-                    voidOK = false;\n@@ -392,1 +370,1 @@\n-                    return 0;\n+                    break;\n@@ -397,0 +375,6 @@\n+\n+    private static IllegalArgumentException maxArrayTypeDescDimensions() {\n+        return new IllegalArgumentException(String.format(\n+                        \"Cannot create an array type descriptor with more than %d dimensions\",\n+                        ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":45,"deletions":61,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -35,0 +37,1 @@\n+import java.util.ArrayList;\n@@ -41,0 +44,6 @@\n+import static jdk.internal.constant.ConstantUtils.badMethodDescriptor;\n+import static jdk.internal.constant.ConstantUtils.resolveClassDesc;\n+import static jdk.internal.constant.ConstantUtils.skipOverFieldSignature;\n+import static jdk.internal.constant.ConstantUtils.EMPTY_CLASSDESC;\n+import static jdk.internal.constant.PrimitiveClassDescImpl.CD_void;\n+\n@@ -94,1 +103,1 @@\n-            return new MethodTypeDescImpl(returnType, ConstantUtils.EMPTY_CLASSDESC);\n+            return new MethodTypeDescImpl(returnType, EMPTY_CLASSDESC);\n@@ -108,8 +117,17 @@\n-        \/\/ Implicit null-check of descriptor\n-        List<ClassDesc> ptypes = ConstantUtils.parseMethodDescriptor(descriptor);\n-        int args = ptypes.size() - 1;\n-        ClassDesc[] paramTypes = args > 0\n-                ? ptypes.subList(1, args + 1).toArray(ConstantUtils.EMPTY_CLASSDESC)\n-                : ConstantUtils.EMPTY_CLASSDESC;\n-\n-        MethodTypeDescImpl result = ofValidated(ptypes.get(0), paramTypes);\n+        int length = descriptor.length();\n+        int rightBracket, retTypeLength;\n+        if (descriptor.charAt(0) != '('\n+                || (rightBracket = (descriptor.charAt(1) == ')' ? 1 : descriptor.lastIndexOf(')'))) <= 0\n+                || (retTypeLength = length - rightBracket - 1) == 0\n+                || (retTypeLength != 1 \/\/ if retTypeLength == 1, check correctness in resolveClassDesc\n+                    && retTypeLength != skipOverFieldSignature(descriptor, rightBracket + 1, length))\n+        ) {\n+            throw badMethodDescriptor(descriptor);\n+        }\n+\n+        var returnType = resolveClassDesc(descriptor, rightBracket + 1, retTypeLength);\n+        if (length == 3 && returnType == CD_void) {\n+            return (MethodTypeDescImpl) ConstantDescs.MTD_void;\n+        }\n+        var paramTypes = paramTypes(descriptor, 1, rightBracket);\n+        var result = new MethodTypeDescImpl(returnType, paramTypes);\n@@ -120,0 +138,71 @@\n+    private static ClassDesc[] paramTypes(String descriptor, int start, int end) {\n+        if (start == end) {\n+            return EMPTY_CLASSDESC;\n+        }\n+\n+        \/*\n+         * If the length of the first 8 parameters is < 256, save them in lengths to avoid ArrayList allocation\n+         * Stop storing for the last parameter (we can compute length), or if too many parameters or too long.\n+         *\/\n+        \/\/ little endian storage - lowest byte is encoded length 0\n+        long packedLengths = 0;\n+        int packedCount = 0;\n+        int cur = start;\n+        while (cur < end) {\n+            int len = skipOverFieldSignature(descriptor, cur, end);\n+            if (len == 0) {\n+                throw badMethodDescriptor(descriptor);\n+            }\n+            cur += len;\n+            if (len > 0xFF || packedCount >= Long.SIZE \/ Byte.SIZE || cur == end) {\n+                \/\/ Cannot or do not have to pack this item, but is already scanned and valid\n+                break;\n+            }\n+            packedLengths = packedLengths | (((long) len) << (Byte.SIZE * packedCount++));\n+        }\n+\n+        \/\/ Invariant: packedCount parameters encoded in packedLengths,\n+        \/\/ And another valid parameter pointed by cur\n+\n+        \/\/ Recover encoded elements\n+        ClassDesc[]     paramTypes    = null;\n+        List<ClassDesc> paramTypeList = null;\n+        if (cur == end) {\n+            paramTypes = new ClassDesc[packedCount + 1];\n+        } else {\n+            paramTypeList = new ArrayList<>(32);\n+        }\n+\n+        int last = start;\n+        for (int i = 0; i < packedCount; i++) {\n+            int len = Byte.toUnsignedInt((byte) (packedLengths >> (Byte.SIZE * i)));\n+            var cd = resolveClassDesc(descriptor, last, len);\n+            if (paramTypes != null) {\n+                paramTypes[i] = cd;\n+            } else {\n+                paramTypeList.add(cd);\n+            }\n+            last += len;\n+        }\n+        var lastCd = resolveClassDesc(descriptor, last, cur - last);\n+\n+        if (paramTypes != null) {\n+            paramTypes[packedCount] = lastCd;\n+            return paramTypes;\n+        }\n+        paramTypeList.add(lastCd);\n+        return buildParamTypes(descriptor, cur, end, paramTypeList);\n+    }\n+\n+    \/\/ slow path\n+    private static ClassDesc[] buildParamTypes(String descriptor, int cur, int end, List<ClassDesc> list) {\n+        while (cur < end) {\n+            int len = skipOverFieldSignature(descriptor, cur, end);\n+            if (len == 0)\n+                throw badMethodDescriptor(descriptor);\n+            list.add(resolveClassDesc(descriptor, cur, len));\n+            cur += len;\n+        }\n+\n+        return list.toArray(EMPTY_CLASSDESC);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":98,"deletions":9,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -43,0 +44,27 @@\n+    \/** {@link ClassDesc} representing the primitive type {@code int} *\/\n+    public static final PrimitiveClassDescImpl CD_int = new PrimitiveClassDescImpl(\"I\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code long} *\/\n+    public static final PrimitiveClassDescImpl CD_long = new PrimitiveClassDescImpl(\"J\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code float} *\/\n+    public static final PrimitiveClassDescImpl CD_float = new PrimitiveClassDescImpl(\"F\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code double} *\/\n+    public static final PrimitiveClassDescImpl CD_double = new PrimitiveClassDescImpl(\"D\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code short} *\/\n+    public static final PrimitiveClassDescImpl CD_short = new PrimitiveClassDescImpl(\"S\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code byte} *\/\n+    public static final PrimitiveClassDescImpl CD_byte = new PrimitiveClassDescImpl(\"B\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code char} *\/\n+    public static final PrimitiveClassDescImpl CD_char = new PrimitiveClassDescImpl(\"C\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code boolean} *\/\n+    public static final PrimitiveClassDescImpl CD_boolean = new PrimitiveClassDescImpl(\"Z\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code void} *\/\n+    public static final PrimitiveClassDescImpl CD_void = new PrimitiveClassDescImpl(\"V\");\n+\n@@ -44,0 +72,1 @@\n+    private @Stable Wrapper lazyWrapper; \/\/ initialized only after this\n@@ -55,1 +84,1 @@\n-    public PrimitiveClassDescImpl(String descriptor) {\n+    private PrimitiveClassDescImpl(String descriptor) {\n@@ -57,3 +86,0 @@\n-        if (descriptor.length() != 1\n-            || \"VIJCSBFDZ\".indexOf(descriptor.charAt(0)) < 0)\n-            throw new IllegalArgumentException(String.format(\"not a valid primitive type descriptor: %s\", descriptor));\n@@ -63,0 +89,7 @@\n+    public Wrapper wrapper() {\n+        var wrapper = this.lazyWrapper;\n+        if (wrapper != null)\n+            return wrapper;\n+        return this.lazyWrapper = Wrapper.forBasicType(descriptorString().charAt(0));\n+    }\n+\n@@ -70,1 +103,1 @@\n-        return Wrapper.forBasicType(descriptorString().charAt(0)).primitiveType();\n+        return wrapper().primitiveType();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/PrimitiveClassDescImpl.java","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen, false);\n+        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen);\n@@ -69,1 +69,1 @@\n-        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length(), false)\n+        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length())\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ReferenceClassDescImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -376,0 +376,10 @@\n+    @ForceInline\n+    public final void checkEnclosingLayout(long offset, MemoryLayout enclosing, boolean readOnly) {\n+        checkAccess(offset, enclosing.byteSize(), readOnly);\n+        if (!isAlignedForElement(offset, enclosing)) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Target offset %d is incompatible with alignment constraint %d (of %s) for segment %s\"\n+                    , offset, enclosing.byteAlignment(), enclosing, this));\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-                    MethodType.methodType(MemorySegment.class, MemorySegment.class, MemoryLayout.class));\n+                    MethodType.methodType(MemorySegment.class, MemorySegment.class));\n@@ -183,2 +183,1 @@\n-        handle = MethodHandles.filterReturnValue(handle,\n-                MethodHandles.insertArguments(MH_SEGMENT_RESIZE, 1, derefLayout));\n+        handle = MethodHandles.filterReturnValue(handle, MH_SEGMENT_RESIZE);\n@@ -188,2 +187,4 @@\n-    private static MemorySegment resizeSegment(MemorySegment segment, MemoryLayout layout) {\n-        return Utils.longToAddress(segment.address(), layout.byteSize(), layout.byteAlignment());\n+    private static MemorySegment resizeSegment(MemorySegment segment) {\n+        \/\/ Avoid adapting for specific target layout. The check for the root layout\n+        \/\/ size and alignment will be inserted by LayoutPath::dereferenceHandle anyway.\n+        return Utils.longToAddress(segment.address(), Long.MAX_VALUE, 1);\n@@ -208,13 +209,9 @@\n-        VarHandle handle = Utils.makeRawSegmentViewVarHandle(valueLayout);\n-        handle = MethodHandles.collectCoordinates(handle, 1, offsetHandle());\n-\n-        \/\/ we only have to check the alignment of the root layout for the first dereference we do,\n-        \/\/ as each dereference checks the alignment of the target address when constructing its segment\n-        \/\/ (see Utils::longToAddress)\n-        if (derefAdapters.length == 0) {\n-            \/\/ insert align check for the root layout on the initial MS + offset\n-            List<Class<?>> coordinateTypes = handle.coordinateTypes();\n-            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ENCL_LAYOUT, 2, rootLayout());\n-            handle = MethodHandles.collectCoordinates(handle, 0, alignCheck);\n-            int[] reorder = IntStream.concat(IntStream.of(0, 1), IntStream.range(0, coordinateTypes.size())).toArray();\n-            handle = MethodHandles.permuteCoordinates(handle, coordinateTypes, reorder);\n+        VarHandle handle = Utils.makeRawSegmentViewVarHandle(valueLayout);              \/\/ (MS, ML, long, long)\n+        handle = MethodHandles.insertCoordinates(handle, 1, rootLayout());          \/\/ (MS, long, long)\n+        if (strides.length > 0) {\n+            MethodHandle offsetAdapter = offsetHandle();\n+            offsetAdapter = MethodHandles.insertArguments(offsetAdapter, 0, 0L);\n+            handle = MethodHandles.collectCoordinates(handle, 2, offsetAdapter);    \/\/ (MS, long)\n+        } else {\n+            \/\/ simpler adaptation\n+            handle = MethodHandles.insertCoordinates(handle, 2, offset);            \/\/ (MS, long)\n@@ -244,0 +241,2 @@\n+        \/\/ note: the below can overflow, depending on 'base'. When constructing var handles\n+        \/\/ through the layout API, this is never the case, as the injected 'base' is always 0.\n@@ -288,6 +287,1 @@\n-        ((AbstractMemorySegmentImpl)segment).checkAccess(offset, enclosing.byteSize(), true);\n-        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(offset, enclosing)) {\n-            throw new IllegalArgumentException(String.format(\n-                    \"Target offset %d is incompatible with alignment constraint %d (of %s) for segment %s\"\n-                    , offset, enclosing.byteAlignment(), enclosing, segment));\n-        }\n+        ((AbstractMemorySegmentImpl)segment).checkEnclosingLayout(offset, enclosing, true);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":18,"deletions":24,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-    private static final MethodHandle LONG_TO_ADDRESS;\n+    private static final MethodHandle LONG_TO_ADDRESS_TARGET;\n+    private static final MethodHandle LONG_TO_ADDRESS_NO_TARGET;\n@@ -77,2 +78,4 @@\n-            LONG_TO_ADDRESS = lookup.findStatic(Utils.class, \"longToAddress\",\n-                    MethodType.methodType(MemorySegment.class, long.class, long.class, long.class));\n+            LONG_TO_ADDRESS_TARGET = lookup.findStatic(Utils.class, \"longToAddress\",\n+                    MethodType.methodType(MemorySegment.class, long.class, AddressLayout.class));\n+            LONG_TO_ADDRESS_NO_TARGET = lookup.findStatic(Utils.class, \"longToAddress\",\n+                    MethodType.methodType(MemorySegment.class, long.class));\n@@ -132,5 +135,4 @@\n-            handle = MethodHandles.filterValue(handle,\n-                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemorySegment.class)),\n-                    MethodHandles.explicitCastArguments(MethodHandles.insertArguments(LONG_TO_ADDRESS, 1,\n-                                    pointeeByteSize(addressLayout), pointeeByteAlign(addressLayout)),\n-                            MethodType.methodType(MemorySegment.class, baseCarrier)));\n+            MethodHandle longToAddressAdapter = addressLayout.targetLayout().isPresent() ?\n+                    MethodHandles.insertArguments(LONG_TO_ADDRESS_TARGET, 1, addressLayout) :\n+                    LONG_TO_ADDRESS_NO_TARGET;\n+            handle = MethodHandles.filterValue(handle, ADDRESS_TO_LONG, longToAddressAdapter);\n@@ -149,0 +151,10 @@\n+    @ForceInline\n+    public static MemorySegment longToAddress(long addr) {\n+        return longToAddress(addr, 0, 1);\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment longToAddress(long addr, AddressLayout layout) {\n+        return longToAddress(addr, pointeeByteSize(layout), pointeeByteAlign(layout));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,35 +182,0 @@\n-    \/** Creates a new java.lang.reflect.Constructor. Access checks as\n-        per java.lang.reflect.AccessibleObject are not overridden. *\/\n-    public Constructor<?> newConstructor(Class<?> declaringClass,\n-                                         Class<?>[] parameterTypes,\n-                                         Class<?>[] checkedExceptions,\n-                                         int modifiers,\n-                                         int slot,\n-                                         String signature,\n-                                         byte[] annotations,\n-                                         byte[] parameterAnnotations)\n-    {\n-        return langReflectAccess.newConstructor(declaringClass,\n-                                                parameterTypes,\n-                                                checkedExceptions,\n-                                                modifiers,\n-                                                slot,\n-                                                signature,\n-                                                annotations,\n-                                                parameterAnnotations);\n-    }\n-\n-    \/** Gets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c) {\n-        return langReflectAccess.getConstructorAccessor(c);\n-    }\n-\n-    \/** Sets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor)\n-    {\n-        langReflectAccess.setConstructorAccessor(c, accessor);\n-    }\n-\n@@ -228,1 +193,2 @@\n-        return langReflectAccess.leafCopyMethod(arg);\n+        Method root = langReflectAccess.getRoot(arg);\n+        return langReflectAccess.copyMethod(root);\n@@ -231,1 +197,0 @@\n-\n@@ -372,9 +337,0 @@\n-\n-        Constructor<?> ctor = newConstructor(constructorToCall.getDeclaringClass(),\n-                                             constructorToCall.getParameterTypes(),\n-                                             constructorToCall.getExceptionTypes(),\n-                                             constructorToCall.getModifiers(),\n-                                             langReflectAccess.getConstructorSlot(constructorToCall),\n-                                             langReflectAccess.getConstructorSignature(constructorToCall),\n-                                             langReflectAccess.getConstructorAnnotations(constructorToCall),\n-                                             langReflectAccess.getConstructorParameterAnnotations(constructorToCall));\n@@ -389,1 +345,1 @@\n-            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, ctor);\n+            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, constructorToCall);\n@@ -391,1 +347,4 @@\n-        setConstructorAccessor(ctor, acc);\n+        \/\/ Unlike other root constructors, this constructor is not copied for mutation\n+        \/\/ but directly mutated, as it is not cached. To cache this constructor,\n+        \/\/ setAccessible call must be done on a copy and return that copy instead.\n+        Constructor<?> ctor = langReflectAccess.newConstructorWithAccessor(constructorToCall, acc);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":8,"deletions":49,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -83,1 +82,5 @@\n-        String value = GetPropertyAction.privilegedGetProperty(key);\n+        \/*\n+         * GetPropertyAction.privilegedGetProperty cannot be used here, Using VM.getSavedProperty to avoid a bootstrap\n+         * circularity issue in the java\/lang\/String\/concat\/WithSecurityManager.java test\n+         *\/\n+        String value = VM.getSavedProperty(key);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ClassFileDumper.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -307,15 +307,0 @@\n-    \/** Return the wrapper that corresponds to the provided basic type char.\n-     *  The basic type char must be for one of the eight primitive types, or void.\n-     *  @throws IllegalArgumentException for unexpected types\n-     *\/\n-    public static Wrapper forPrimitiveType(char basicTypeChar) {\n-        Wrapper w = FROM_CHAR[(basicTypeChar + (basicTypeChar >> 1)) & 0xf];\n-        if (w == null || w.basicTypeChar != basicTypeChar) {\n-            throw basicTypeError(basicTypeChar);\n-        }\n-        if (w == OBJECT) {\n-            throw newIllegalArgumentException(\"not primitive: \" + basicTypeChar);\n-        }\n-        return w;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -686,0 +686,1 @@\n+            long remainingNanos = nanos;\n@@ -691,3 +692,0 @@\n-                    long remainingNanos = (nanos > 0)\n-                            ? nanos - (System.nanoTime() - startNanos)\n-                            : 0;\n@@ -714,1 +712,0 @@\n-                            \/\/ copy bytes to the DatagramPacket, and set length and sender\n@@ -716,0 +713,1 @@\n+                                \/\/ copy bytes to the DatagramPacket, and set length and sender\n@@ -723,0 +721,8 @@\n+                            } else {\n+                                \/\/ need to retry, adjusting timeout if needed\n+                                if (nanos > 0) {\n+                                    remainingNanos = nanos - (System.nanoTime() - startNanos);\n+                                    if (remainingNanos <= 0) {\n+                                        throw new SocketTimeoutException(\"Receive timed out\");\n+                                    }\n+                                }\n@@ -749,0 +755,1 @@\n+        assert nanos >= 0;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -257,0 +257,17 @@\n+#if defined(__linux__) && defined(__arm__)\n+\/**\n+ * Lookup functions with time_t parameter. Try to use 64 bit symbol\n+ * if sizeof(time_t) exceeds 32 bit.\n+ *\/\n+static void* lookup_time_t_function(const char* symbol, const char* symbol64) {\n+    void *func_ptr = NULL;\n+    if (sizeof(time_t) > 4) {\n+        func_ptr = dlsym(RTLD_DEFAULT, symbol64);\n+    }\n+    if (func_ptr == NULL) {\n+        return dlsym(RTLD_DEFAULT, symbol);\n+    }\n+    return func_ptr;\n+}\n+#endif\n+\n@@ -354,0 +371,8 @@\n+#if defined(__linux__) && defined(__arm__)\n+    my_futimesat_func = (futimesat_func*) lookup_time_t_function(\"futimesat\",\n+        \"__futimesat64\");\n+    my_lutimes_func = (lutimes_func*) lookup_time_t_function(\"lutimes\",\n+        \"__lutimes64\");\n+    my_futimens_func = (futimens_func*) lookup_time_t_function(\"futimens\",\n+        \"__futimens64\");\n+#else\n@@ -359,0 +384,1 @@\n+#endif\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,24 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.beans.*;\n-import java.util.*;\n-\n-import javax.swing.*;\n+import java.awt.Adjustable;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseMotionListener;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.BoundedRangeModel;\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.JScrollBar;\n+import javax.swing.LookAndFeel;\n@@ -35,5 +53,13 @@\n-import javax.swing.event.*;\n-import javax.swing.plaf.*;\n-\n-import apple.laf.*;\n-import apple.laf.JRSUIConstants.*;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.ScrollBarUI;\n+\n+import apple.laf.JRSUIStateFactory;\n+import apple.laf.JRSUIConstants.Hit;\n+import apple.laf.JRSUIConstants.NothingToScroll;\n+import apple.laf.JRSUIConstants.Orientation;\n+import apple.laf.JRSUIConstants.ScrollBarHit;\n+import apple.laf.JRSUIConstants.ScrollBarPart;\n+import apple.laf.JRSUIConstants.ShowArrows;\n+import apple.laf.JRSUIConstants.State;\n@@ -41,0 +67,1 @@\n+import apple.laf.JRSUIUtils;\n@@ -530,0 +557,15 @@\n+            Component parent = fScrollBar.getParent();\n+            do {\n+                if (parent instanceof JFrame par) {\n+                    if (!par.isEnabled()) {\n+                        ((Timer)e.getSource()).stop();\n+                        fScrollBar.setValueIsAdjusting(false);\n+                        return;\n+                    }\n+                    break;\n+                } else {\n+                    if (parent != null) {\n+                        parent = parent.getParent();\n+                    }\n+                }\n+            } while (parent != null);\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaScrollBarUI.java","additions":54,"deletions":12,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import javax.swing.event.*;\n+import javax.swing.event.ChangeListener;\n@@ -43,1 +43,1 @@\n- * must greater than or equal to <code>minimum<\/code>, and <code>maximum<\/code>\n+ * must be greater than or equal to <code>minimum<\/code>, and <code>maximum<\/code>\n@@ -231,1 +231,1 @@\n-     * This method sets all of the model's data with a single method call.\n+     * This method sets all the model's data with a single method call.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/BoundedRangeModel.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -730,0 +730,2 @@\n+            \/\/ The above margin has vastly larger horizontal values when\n+            \/\/ compared to other look and feels that don't rely on these values\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicLookAndFeel.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import javax.swing.JFrame;\n@@ -1611,0 +1612,19 @@\n+            \/\/ If frame is disabled and timer is started in mousePressed\n+            \/\/ and mouseReleased is not called, then timer will not be stopped\n+            \/\/ Stop the timer if frame is disabled\n+            Component parent = scrollbar.getParent();\n+            do {\n+                if (parent instanceof JFrame par) {\n+                    if (!par.isEnabled()) {\n+                        ((Timer)e.getSource()).stop();\n+                        buttonListener.handledEvent = false;\n+                        scrollbar.setValueIsAdjusting(false);\n+                        return;\n+                    }\n+                    break;\n+                } else {\n+                    if (parent != null) {\n+                        parent = parent.getParent();\n+                    }\n+                }\n+            } while (parent != null);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicScrollBarUI.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,7 @@\n-import java.awt.*;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Frame;\n+import java.awt.Insets;\n+import java.awt.Toolkit;\n+import java.awt.Window;\n@@ -31,6 +37,0 @@\n-import javax.swing.plaf.*;\n-import javax.swing.*;\n-import javax.swing.plaf.basic.*;\n-import javax.swing.text.DefaultEditorKit;\n-\n-import java.awt.Color;\n@@ -39,1 +39,0 @@\n-\n@@ -42,1 +41,27 @@\n-import sun.awt.*;\n+import javax.swing.ButtonModel;\n+import javax.swing.DefaultButtonModel;\n+import javax.swing.Icon;\n+import javax.swing.ImageIcon;\n+import javax.swing.JComponent;\n+import javax.swing.JDialog;\n+import javax.swing.JFrame;\n+import javax.swing.JRootPane;\n+import javax.swing.JTextField;\n+import javax.swing.JToggleButton;\n+import javax.swing.LayoutStyle;\n+import javax.swing.LookAndFeel;\n+import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.plaf.BorderUIResource;\n+import javax.swing.plaf.ColorUIResource;\n+import javax.swing.plaf.FontUIResource;\n+import javax.swing.plaf.InsetsUIResource;\n+import javax.swing.plaf.UIResource;\n+import javax.swing.plaf.basic.BasicLookAndFeel;\n+import javax.swing.text.DefaultEditorKit;\n+\n+import sun.awt.AppContext;\n+import sun.awt.OSInfo;\n+import sun.awt.SunToolkit;\n@@ -45,2 +70,0 @@\n-import static javax.swing.UIDefaults.LazyValue;\n-\n@@ -50,0 +73,2 @@\n+import static javax.swing.UIDefaults.LazyValue;\n+\n@@ -785,0 +810,2 @@\n+            \/\/ Button default margin is (2, 14, 2, 14), defined in\n+            \/\/ BasicLookAndFeel via \"Button.margin\" UI property.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalLookAndFeel.java","additions":39,"deletions":12,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n@@ -456,0 +458,7 @@\n+\n+        long responseTimeoutMillis = 5000;\n+        if (request.timeout().isPresent()) {\n+            final long timeoutMillis = request.timeout().get().toMillis();\n+            responseTimeoutMillis = Math.min(responseTimeoutMillis, timeoutMillis);\n+        }\n+\n@@ -457,0 +466,1 @@\n+                .completeOnTimeout(null, responseTimeoutMillis, TimeUnit.MILLISECONDS)\n@@ -458,24 +468,39 @@\n-            Log.logResponse(r1::toString);\n-            int rcode = r1.statusCode();\n-            if (rcode == 100) {\n-                Log.logTrace(\"Received 100-Continue: sending body\");\n-                if (debug.on()) debug.log(\"Received 100-Continue for %s\", r1);\n-                CompletableFuture<Response> cf =\n-                        exchImpl.sendBodyAsync()\n-                                .thenCompose(exIm -> exIm.getResponseAsync(parentExecutor));\n-                cf = wrapForUpgrade(cf);\n-                cf = wrapForLog(cf);\n-                return cf;\n-            } else {\n-                Log.logTrace(\"Expectation failed: Received {0}\",\n-                        rcode);\n-                if (debug.on()) debug.log(\"Expect-Continue failed (%d) for: %s\", rcode, r1);\n-                if (upgrading && rcode == 101) {\n-                    IOException failed = new IOException(\n-                            \"Unable to handle 101 while waiting for 100\");\n-                    return MinimalFuture.failedFuture(failed);\n-                }\n-                exchImpl.expectContinueFailed(rcode);\n-                return MinimalFuture.completedFuture(r1);\n-            }\n-        });\n+                    \/\/ The response will only be null if there was a timeout\n+                    \/\/ send body regardless\n+                    if (r1 == null) {\n+                        if (debug.on())\n+                            debug.log(\"Setting ExpectTimeoutRaised and sending request body\");\n+                        exchImpl.setExpectTimeoutRaised();\n+                        CompletableFuture<Response> cf =\n+                                exchImpl.sendBodyAsync()\n+                                        .thenCompose(exIm -> exIm.getResponseAsync(parentExecutor));\n+                        cf = wrapForUpgrade(cf);\n+                        cf = wrapForLog(cf);\n+                        return cf;\n+                    }\n+\n+                    Log.logResponse(r1::toString);\n+                    int rcode = r1.statusCode();\n+                    if (rcode == 100) {\n+                        Log.logTrace(\"Received 100-Continue: sending body\");\n+                        if (debug.on())\n+                            debug.log(\"Received 100-Continue for %s\", r1);\n+                        CompletableFuture<Response> cf =\n+                                exchImpl.sendBodyAsync()\n+                                        .thenCompose(exIm -> exIm.getResponseAsync(parentExecutor));\n+                        cf = wrapForUpgrade(cf);\n+                        cf = wrapForLog(cf);\n+                        return cf;\n+                    } else {\n+                        Log.logTrace(\"Expectation failed: Received {0}\", rcode);\n+                        if (debug.on())\n+                            debug.log(\"Expect-Continue failed (%d) for: %s\", rcode, r1);\n+                        if (upgrading && rcode == 101) {\n+                            IOException failed = new IOException(\n+                                    \"Unable to handle 101 while waiting for 100\");\n+                            return MinimalFuture.failedFuture(failed);\n+                        }\n+                        exchImpl.expectContinueFailed(rcode);\n+                        return MinimalFuture.completedFuture(r1);\n+                    }\n+                });\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":50,"deletions":25,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+    private volatile boolean expectTimeoutRaised;\n+\n@@ -74,0 +76,8 @@\n+    final void setExpectTimeoutRaised() {\n+        expectTimeoutRaised = true;\n+    }\n+\n+    final boolean expectTimeoutRaised() {\n+        return expectTimeoutRaised;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1203,2 +1203,7 @@\n-                \/\/ it will be already completed.\n-                cf = response_cfs.remove(0);\n+                \/\/ it will be already completed, unless the expect continue\n+                \/\/ timeout fired\n+                cf = response_cfs.get(0);\n+                if (cf.isDone()) {\n+                    cf = response_cfs.remove(0);\n+                }\n+\n@@ -1207,1 +1212,2 @@\n-                assert cf.isDone() : \"Removing uncompleted response: could cause code to hang!\";\n+                assert cf.isDone() || request.expectContinue && expectTimeoutRaised()\n+                        : \"Removing uncompleted response: could cause code to hang!\";\n@@ -1242,1 +1248,1 @@\n-                if (!cf.isDone()) {\n+                if (!cf.isDone() && !expectTimeoutRaised()) {\n@@ -1250,0 +1256,8 @@\n+                } else if (expectTimeoutRaised()) {\n+                    Log.logTrace(\"Completing response (streamid={0}): {1}\",\n+                            streamid, cf);\n+                    if (debug.on())\n+                        debug.log(\"Completing responseCF(%d) with response headers\", i);\n+                    \/\/ The Request will be removed in getResponseAsync()\n+                    cf.complete(resp);\n+                    return;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -159,0 +159,10 @@\n+    if (VM.getVM().getCommandLineFlag(\"UseObjectMonitorTable\").getBool()) {\n+      Iterator it = ObjectSynchronizer.objectMonitorIterator();\n+      while (it != null && it.hasNext()) {\n+        ObjectMonitor mon = (ObjectMonitor)it.next();\n+        if (getAddress().equals(mon.object())) {\n+          return mon;\n+        }\n+      }\n+      return null;\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    displacedHeaderField = type.getCIntegerField(\"_displaced_header\");\n+    displacedHeaderField = type.getCIntegerField(\"_metadata\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/BasicLock.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-    sun.jvm.hotspot.types.Field f = type.getField(\"_header\");\n-    headerFieldOffset = f.getOffset();\n+    sun.jvm.hotspot.types.Field f = type.getField(\"_metadata\");\n+    metadataFieldOffset = f.getOffset();\n@@ -68,1 +68,1 @@\n-    return new Mark(addr.addOffsetTo(headerFieldOffset));\n+    return new Mark(addr.addOffsetTo(metadataFieldOffset));\n@@ -117,1 +117,1 @@\n-  private static long          headerFieldOffset;\n+  private static long          metadataFieldOffset;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectMonitor.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+      if (VM.getVM().getCommandLineFlag(\"UseObjectMonitorTable\").getBool()) {\n+        return mark.hash();\n+      }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectSynchronizer.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import jdk.javadoc.internal.html.HtmlId;\n@@ -299,1 +300,1 @@\n-                DocPath filename = getPath(linkInfo);\n+                DocPath fileName = getPath(linkInfo);\n@@ -302,17 +303,3 @@\n-                                filename.fragment(linkInfo.getFragment()),\n-                                label,\n-                                linkInfo.getStyle(),\n-                                title));\n-                        Content spacer = Text.EMPTY;\n-                        if (flags.contains(ElementFlag.PREVIEW)) {\n-                            link.add(HtmlTree.SUP(m_writer.links.createLink(\n-                                    filename.fragment(m_writer.htmlIds.forPreviewSection(previewTarget).name()),\n-                                    m_writer.contents.previewMark)));\n-                            spacer = Entity.NO_BREAK_SPACE;\n-                        }\n-                        if (flags.contains(ElementFlag.RESTRICTED)) {\n-                            link.add(spacer);\n-                            link.add(HtmlTree.SUP(m_writer.links.createLink(\n-                                    filename.fragment(m_writer.htmlIds.forRestrictedSection(restrictedTarget).name()),\n-                                    m_writer.contents.restrictedMark)));\n-                        }\n+                                fileName.fragment(linkInfo.getFragment()),\n+                                label, linkInfo.getStyle(), title));\n+                        addSuperscript(link, flags, fileName, null, previewTarget, restrictedTarget);\n@@ -328,17 +315,1 @@\n-                Content spacer = Text.EMPTY;\n-                if (flags.contains(ElementFlag.PREVIEW)) {\n-                    link.add(HtmlTree.SUP(m_writer.getCrossClassLink(\n-                        typeElement,\n-                        m_writer.htmlIds.forPreviewSection(previewTarget).name(),\n-                        m_writer.contents.previewMark,\n-                        null, false)));\n-                    spacer = Entity.NO_BREAK_SPACE;\n-                }\n-                if (flags.contains(ElementFlag.RESTRICTED)) {\n-                    link.add(spacer);\n-                    link.add(HtmlTree.SUP(m_writer.getCrossClassLink(\n-                            typeElement,\n-                            m_writer.htmlIds.forRestrictedSection(restrictedTarget).name(),\n-                            m_writer.contents.restrictedMark,\n-                            null, false)));\n-                }\n+                addSuperscript(link, flags, null, typeElement, previewTarget, restrictedTarget);\n@@ -350,0 +321,17 @@\n+        addSuperscript(link, flags, null, null, previewTarget, restrictedTarget);\n+        return link;\n+    }\n+\n+    \/**\n+     * Adds PREVIEW and RESTRICTED superscript labels. Depending on the parameter values,\n+     * labels will be formatted as local or external links or plain text.\n+     *\n+     * @param content the content to add to\n+     * @param flags the flags\n+     * @param fileName file name to link to, or null if no local link target\n+     * @param typeElement external type to link to, or null if no external link\n+     * @param previewTarget preview link target element\n+     * @param restrictedTarget restricted link target element\n+     *\/\n+    private void addSuperscript(Content content, Set<ElementFlag> flags, DocPath fileName, TypeElement typeElement,\n+                                Element previewTarget, ExecutableElement restrictedTarget) {\n@@ -352,1 +340,3 @@\n-            link.add(HtmlTree.SUP(m_writer.contents.previewMark));\n+            content.add(HtmlTree.SUP(getSuperscript(fileName, typeElement,\n+                    m_writer.htmlIds.forPreviewSection(previewTarget),\n+                    m_writer.contents.previewMark)));\n@@ -356,2 +346,23 @@\n-            link.add(spacer);\n-            link.add(HtmlTree.SUP(m_writer.contents.restrictedMark));\n+            content.add(spacer);\n+            content.add(HtmlTree.SUP(getSuperscript(fileName, typeElement,\n+                    m_writer.htmlIds.forRestrictedSection(restrictedTarget),\n+                    m_writer.contents.restrictedMark)));\n+        }\n+    }\n+\n+    \/**\n+     * Returns PREVIEW or RESTRICTED superscript as either local or external link or as plain text.\n+     *\n+     * @param fileName local file name to link to, or null if no local link target\n+     * @param typeElement external type to link to, or null if no external link\n+     * @param id the id fragment to link to\n+     * @param label the label content\n+     * @return superscript content\n+     *\/\n+    private Content getSuperscript(DocPath fileName, TypeElement typeElement, HtmlId id, Content label) {\n+        if (fileName != null) {\n+            return m_writer.links.createLink(fileName.fragment(id.name()), label);\n+        } else if (typeElement != null) {\n+            return (m_writer.getCrossClassLink(typeElement, id.name(), label, null, false));\n+        } else {\n+            return label;\n@@ -359,1 +370,0 @@\n-        return link;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkFactory.java","additions":49,"deletions":39,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-    function handleResize(e) {\n+    new ResizeObserver((entries) => {\n@@ -478,3 +478,1 @@\n-    }\n-    window.addEventListener(\"orientationchange\", handleResize);\n-    window.addEventListener(\"resize\", handleResize);\n+    }).observe(document.body);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js.template","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+                    .skipPreview(isPlain)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LinkTaglet.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-        write(annot, true);\n+        write(annot.annotation(), true);\n@@ -104,1 +104,1 @@\n-        write(annot, resolveIndices);\n+        write(annot.annotation(), resolveIndices);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AnnotationWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- uint cache_line_size = VM_Version::L1_data_cache_line_size();\n+  uint cache_line_size = VM_Version::L1_data_cache_line_size();\n@@ -32,9 +32,1 @@\n- if (cache_line_size != 0) {\n-   \/\/ We were able to determine the L1 data cache line size so\n-   \/\/ do some cache line specific sanity checks\n-   EXPECT_EQ((size_t) 0, sizeof (PaddedEnd<ObjectMonitor>) % cache_line_size)\n-        << \"PaddedEnd<ObjectMonitor> size is not a \"\n-        << \"multiple of a cache line which permits false sharing. \"\n-        << \"sizeof(PaddedEnd<ObjectMonitor>) = \"\n-        << sizeof (PaddedEnd<ObjectMonitor>)\n-        << \"; cache_line_size = \" << cache_line_size;\n+  if (cache_line_size != 0) {\n@@ -42,2 +34,10 @@\n-   EXPECT_GE((size_t) in_bytes(ObjectMonitor::owner_offset()), cache_line_size)\n-        << \"the _header and _owner fields are closer \"\n+    EXPECT_EQ(in_bytes(ObjectMonitor::metadata_offset()), 0)\n+        << \"_metadata at a non 0 offset. metadata_offset = \"\n+        << in_bytes(ObjectMonitor::metadata_offset());\n+\n+    EXPECT_GE((size_t) in_bytes(ObjectMonitor::owner_offset()), cache_line_size)\n+        << \"the _metadata and _owner fields are closer \"\n+        << \"than a cache line which permits false sharing.\";\n+\n+    EXPECT_GE((size_t) in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), cache_line_size)\n+        << \"the _owner and _recursions fields are closer \"\n","filename":"test\/hotspot\/gtest\/runtime\/test_objectMonitor.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,5 +32,0 @@\n-vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\/TestDescription.java#id0            8205957 generic-all\n-vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\/TestDescription.java#logging        8205957 generic-all\n-vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java#id0     8205957 generic-all\n-vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java#logging 8205957 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,9 +49,0 @@\n-    public static long lseed = 1;\n-    public static int iseed = 2;\n-    public static short sseed = 3;\n-    public static byte bseed = 4;\n-    public static long lres = lseed;\n-    public static int ires = iseed;\n-    public static short sres = sseed;\n-    public static byte bres = bseed;\n-\n@@ -62,1 +53,1 @@\n-        private static final long data;\n+        private static final long lseed = 1;\n@@ -72,1 +63,0 @@\n-            lres += UNSAFE.getLongUnaligned(BYTES, 1030);\n@@ -74,2 +64,1 @@\n-            UNSAFE.putLongUnaligned(BYTES, 127, lres);\n-            lres += UNSAFE.getLongUnaligned(BYTES, 127);\n+            UNSAFE.putLongUnaligned(BYTES, 127, rawdata+lseed);\n@@ -77,2 +66,1 @@\n-            UNSAFE.putLongUnaligned(BYTES, 1096, lres);\n-            data = UNSAFE.getLongUnaligned(BYTES, 1096);\n+            UNSAFE.putLongUnaligned(BYTES, 1096, rawdata-lseed);\n@@ -87,1 +75,1 @@\n-        private static final int data;\n+        private static final int iseed = 2;\n@@ -96,1 +84,0 @@\n-            ires += UNSAFE.getIntUnaligned(BYTES, 274);\n@@ -98,2 +85,1 @@\n-            UNSAFE.putIntUnaligned(BYTES, 255, ires);\n-            ires += UNSAFE.getIntUnaligned(BYTES, 255);\n+            UNSAFE.putIntUnaligned(BYTES, 255, rawdata + iseed);\n@@ -101,2 +87,1 @@\n-            UNSAFE.putIntUnaligned(BYTES, 528, ires);\n-            data = UNSAFE.getIntUnaligned(BYTES, 528);\n+            UNSAFE.putIntUnaligned(BYTES, 528, rawdata - iseed);\n@@ -111,1 +96,1 @@\n-        private static final short data;\n+        private static final short sseed = 3;\n@@ -120,1 +105,0 @@\n-            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 257));\n@@ -122,2 +106,1 @@\n-            UNSAFE.putShortUnaligned(BYTES, 253, sres);\n-            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 253));\n+            UNSAFE.putShortUnaligned(BYTES, 253, (short) (rawdata + sseed));\n@@ -125,2 +108,1 @@\n-            UNSAFE.putShortUnaligned(BYTES, 272, sres);\n-            data = UNSAFE.getShortUnaligned(BYTES, 272);\n+            UNSAFE.putShortUnaligned(BYTES, 272, (short) (rawdata - sseed));\n@@ -135,1 +117,1 @@\n-        private static final byte data;\n+        private static final byte bseed = 4;\n@@ -144,1 +126,0 @@\n-            bres = (byte) (bres + UNSAFE.getByte(BYTES, 272));\n@@ -146,2 +127,1 @@\n-            UNSAFE.putByte(BYTES, 53, bres);\n-            bres = (byte) (bres + UNSAFE.getByte(BYTES, 53));\n+            UNSAFE.putByte(BYTES, 53, (byte) (rawdata + bseed));\n@@ -149,2 +129,1 @@\n-            UNSAFE.putByte(BYTES, 1027, bres);\n-            data = UNSAFE.getByte(BYTES, 1027);\n+            UNSAFE.putByte(BYTES, 1027, (byte) (rawdata - bseed));\n@@ -157,1 +136,3 @@\n-        Asserts.assertEquals(ta.data, (ta.rawdata + lseed) * 2, \"putUnaligned long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLongUnaligned(ta.BYTES, 1030), ta.rawdata, \"putUnaligned long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLongUnaligned(ta.BYTES, 127), ta.rawdata + ta.lseed, \"putUnaligned long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLongUnaligned(ta.BYTES, 1096), ta.rawdata - ta.lseed, \"putUnaligned long failed!\");\n@@ -160,1 +141,3 @@\n-        Asserts.assertEquals(tb.data, (tb.rawdata + iseed) * 2, \"putUnaligned int failed!\");\n+        Asserts.assertEquals(UNSAFE.getIntUnaligned(tb.BYTES, 274), tb.rawdata, \"putUnaligned int failed!\");\n+        Asserts.assertEquals(UNSAFE.getIntUnaligned(tb.BYTES, 255), tb.rawdata + tb.iseed, \"putUnaligned int failed!\");\n+        Asserts.assertEquals(UNSAFE.getIntUnaligned(tb.BYTES, 528), tb.rawdata - tb.iseed, \"putUnaligned int failed!\");\n@@ -163,1 +146,3 @@\n-        Asserts.assertEquals(tc.data, (short) (((short) (tc.rawdata + sseed)) * 2), \"putUnaligned short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShortUnaligned(tc.BYTES, 257), tc.rawdata, \"putUnaligned short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShortUnaligned(tc.BYTES, 253), (short) (tc.rawdata + tc.sseed), \"putUnaligned short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShortUnaligned(tc.BYTES, 272), (short) (tc.rawdata - tc.sseed), \"putUnaligned short failed!\");\n@@ -166,1 +151,3 @@\n-        Asserts.assertEquals(td.data, (byte) (((byte) (td.rawdata + bseed)) * 2), \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(td.BYTES, 272), td.rawdata, \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(td.BYTES, 53), (byte) (td.rawdata + td.bseed), \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(td.BYTES, 1027), (byte) (td.rawdata - td.bseed), \"put byte failed!\");\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUnalignedAccess.java","additions":24,"deletions":37,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimArrayTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimArrayTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final int[] EMPTY_INTEGER = new int[] { 0 };\n+    static final int[] FULL_INTEGER = new int[] { 42 };\n+\n+    static class Carrier {\n+        @Stable\n+        int[] field;\n+\n+        @ForceInline\n+        public Carrier(int initLevel) {\n+            switch (initLevel) {\n+                case 0:\n+                    \/\/ Do nothing.\n+                    break;\n+                case 1:\n+                    field = EMPTY_INTEGER;\n+                    break;\n+                case 2:\n+                    field = FULL_INTEGER;\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown level\");\n+            }\n+        }\n+\n+        @ForceInline\n+        public void initEmpty() {\n+            field = EMPTY_INTEGER;\n+        }\n+\n+        @ForceInline\n+        public void initFull() {\n+            field = FULL_INTEGER;\n+        }\n+\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(0);\n+    static final Carrier INIT_EMPTY_CARRIER = new Carrier(1);\n+    static final Carrier INIT_FULL_CARRIER = new Carrier(2);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        int[] is = BLANK_CARRIER.field;\n+        if (is != null) {\n+            return is[0];\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testPartialFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        int[] is = INIT_EMPTY_CARRIER.field;\n+        if (is != null) {\n+            return is[0];\n+        }\n+        return 0;\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        int[] is = INIT_FULL_CARRIER.field;\n+        if (is != null) {\n+            return is[0];\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorEmptyInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(2);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodEmptyInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_EMPTY_CARRIER.initEmpty();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodFullInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_FULL_CARRIER.initFull();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimArrayTest.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimFinalTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimFinalTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static class Carrier {\n+        @Stable\n+        final int field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            field = init ? 42 : 0;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for final fields.\n+        return BLANK_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        return INIT_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Single header+final barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Single header+final barrier.\n+        return new Carrier(true);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimFinalTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimPlainTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimPlainTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static class Carrier {\n+        @Stable\n+        int field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = 42;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = 42;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        return BLANK_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        return INIT_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodInit() {\n+        \/\/ Primitive inits have no membars.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimPlainTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimVolatileTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimVolatileTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static class Carrier {\n+        @Stable\n+        volatile int field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = 42;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = 42;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ Barriers expected for volatile fields.\n+        return BLANK_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        return INIT_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Expect only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Volatile barriers expected.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static void testMethodInit() {\n+        \/\/ Volatile barriers expected.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimVolatileTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefArrayTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefArrayTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer[] EMPTY_INTEGER = new Integer[] { null };\n+    static final Integer[] FULL_INTEGER = new Integer[] { 42 };\n+\n+    static class Carrier {\n+        @Stable\n+        Integer[] field;\n+\n+        @ForceInline\n+        public Carrier(int initLevel) {\n+            switch (initLevel) {\n+                case 0:\n+                    \/\/ Do nothing.\n+                    break;\n+                case 1:\n+                    field = EMPTY_INTEGER;\n+                    break;\n+                case 2:\n+                    field = FULL_INTEGER;\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown level\");\n+            }\n+        }\n+\n+        @ForceInline\n+        public void initEmpty() {\n+            field = EMPTY_INTEGER;\n+        }\n+\n+        @ForceInline\n+        public void initFull() {\n+            field = FULL_INTEGER;\n+        }\n+\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(0);\n+    static final Carrier INIT_EMPTY_CARRIER = new Carrier(1);\n+    static final Carrier INIT_FULL_CARRIER = new Carrier(2);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer[] is = BLANK_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testPartialFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer[] is = INIT_EMPTY_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer[] is = INIT_FULL_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorEmptyInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(2);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodEmptyInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_EMPTY_CARRIER.initEmpty();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodFullInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_FULL_CARRIER.initFull();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefArrayTest.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefFinalTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefFinalTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer INTEGER = 42;\n+\n+    static class Carrier {\n+        @Stable\n+        final Integer field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            field = init ? INTEGER : null;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer i = BLANK_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer i = INIT_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorInit() {\n+        \/\/ Only the header+final barrier.\n+        return new Carrier(true);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefFinalTest.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefPlainTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefPlainTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer INTEGER = 42;\n+\n+    static class Carrier {\n+        @Stable\n+        Integer field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = INTEGER;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = INTEGER;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer i = BLANK_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer i = INIT_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefPlainTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefVolatileTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefVolatileTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer INTEGER = 42;\n+\n+    static class Carrier {\n+        @Stable\n+        volatile Integer field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = INTEGER;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = INTEGER;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ Barriers are expected for volatile field.\n+        Integer i = BLANK_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer i = INIT_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Volatile writes, expect more barriers.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static void testMethodInit() {\n+        \/\/ Barriers are expected for volatile fields.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefVolatileTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-* @bug 8299259\n+* @bug 8299259 8336729\n@@ -38,1 +38,1 @@\n-* @bug 8299259\n+* @bug 8299259 8336729\n@@ -46,0 +46,22 @@\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @bug 8336729\n+ * @requires vm.compiler2.enabled\n+ * @summary Test various cases of divisions\/modulo which should not be split through iv phis.\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:LoopUnrollLimit=0 -XX:+StressGCM -XX:StressSeed=3434\n+ *                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivisionThroughPhi::*\n+ *                   compiler.splitif.TestSplitDivisionThroughPhi\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @bug 8336729\n+ * @requires vm.compiler2.enabled\n+ * @summary Test various cases of divisions\/modulo which should not be split through iv phis.\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:LoopUnrollLimit=0 -XX:+StressGCM\n+ *                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivisionThroughPhi::*\n+ *                   compiler.splitif.TestSplitDivisionThroughPhi\n+ *\/\n+\n@@ -64,0 +86,2 @@\n+            testPushDivLThruPhiForOuterLongLoop();\n+            testPushModLThruPhiForOuterLongLoop();\n@@ -81,0 +105,21 @@\n+    \/\/ Fixed with JDK-8336729.\n+    static void testPushDivLThruPhiForOuterLongLoop() {\n+        \/\/ This loop is first transformed into a LongCountedLoop in the first loop opts phase.\n+        \/\/ In the second loop opts phase, the LongCountedLoop is split into an inner and an outer loop. Both get the\n+        \/\/ same iv phi type which is [2..10]. Only the inner loop is transformed into a CountedLoopNode while the outer\n+        \/\/ loop is still a LoopNode. We run into the same problem as described in testPushDivIThruPhi() when splitting\n+        \/\/ the DivL node through the long iv phi of the outer LoopNode.\n+        \/\/ The fix for JDK-8299259 only prevents this splitting for CountedLoopNodes. We now extend it to LoopNodes\n+        \/\/ in general.\n+        for (long i = 10; i > 1; i -= 2) {\n+            lFld = 10 \/ i;\n+        }\n+    }\n+\n+    \/\/ Same as testPushDivLThruPhiForOuterLongLoop() but for ModL.\n+    static void testPushModLThruPhiForOuterLongLoop() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            iFld = 10 % i;\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/splitif\/TestSplitDivisionThroughPhi.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,211 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test id=default\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ShenandoahHumongousThreshold=90 -XX:ShenandoahGCHeuristics=aggressive\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ShenandoahHumongousThreshold=90 -XX:ShenandoahGCHeuristics=aggressive\n- *                   TestHumongousThreshold\n- *\/\n-\n-\/*\n- * @test id=16b\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @requires vm.bits == \"64\"\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\/\n-\n-\/*\n- * @test id=generational\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\/\n-\n-\/*\n- * @test id=generational-16b\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @requires vm.bits == \"64\"\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=generational -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\/\n-\n-import java.util.Random;\n-import jdk.test.lib.Utils;\n-\n-public class TestHumongousThreshold {\n-\n-    static final long TARGET_MB = Long.getLong(\"target\", 20_000); \/\/ 20 Gb allocation\n-\n-    static volatile Object sink;\n-\n-    public static void main(String[] args) throws Exception {\n-        final int min = 0;\n-        final int max = 384 * 1024;\n-        long count = TARGET_MB * 1024 * 1024 \/ (16 + 4 * (min + (max - min) \/ 2));\n-\n-        Random r = Utils.getRandomInstance();\n-        for (long c = 0; c < count; c++) {\n-            sink = new int[min + r.nextInt(max - min)];\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestHumongousThreshold.java","additions":0,"deletions":211,"binary":false,"changes":211,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test that Shenandoah humongous threshold args are checked\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver TestHumongousThresholdArgs\n- *\/\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class TestHumongousThresholdArgs {\n-    public static void main(String[] args) throws Exception {\n-        {\n-            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx128m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    \"-version\");\n-            output.shouldHaveExitValue(0);\n-        }\n-\n-        int[] valid = new int[] {1, 10, 50, 90, 100};\n-        int[] invalid = new int[] {-100, -1, 0, 101, 1000};\n-\n-        for (int v : valid) {\n-            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx128m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    \"-XX:ShenandoahHumongousThreshold=\" + v,\n-                    \"-version\");\n-            output.shouldHaveExitValue(0);\n-        }\n-\n-        for (int v : invalid) {\n-            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx128m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    \"-XX:ShenandoahHumongousThreshold=\" + v,\n-                    \"-version\");\n-            output.shouldHaveExitValue(1);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestHumongousThresholdArgs.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=NormalDeflation\n+ * @summary A collection of small tests using synchronized, wait, notify to try\n+ *          and achieve good cheap coverage of UseObjectMonitorTable.\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+UseObjectMonitorTable\n+ *                   UseObjectMonitorTableTest\n+ *\/\n+\n+\/**\n+ * @test id=ExtremeDeflation\n+ * @summary Run the same tests but with deflation running constantly.\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:GuaranteedAsyncDeflationInterval=1\n+ *                   -XX:+UseObjectMonitorTable\n+ *                   UseObjectMonitorTableTest\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+\n+import java.lang.Runnable;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.Random;\n+import java.util.stream.Stream;\n+\n+public class UseObjectMonitorTableTest {\n+    static final ThreadFactory TF = Executors.defaultThreadFactory();\n+\n+    static class WaitNotifyTest implements Runnable {\n+        static final int ITERATIONS = 10_000;\n+        static final int THREADS = 10;\n+        final WaitNotifySyncChannel startLatchChannel = new WaitNotifySyncChannel();\n+        final WaitNotifySyncChannel endLatchChannel = new WaitNotifySyncChannel();\n+        int count = 0;\n+\n+        static class WaitNotifyCountDownLatch {\n+            int latch;\n+            WaitNotifyCountDownLatch(int count) {\n+                latch = count;\n+            }\n+            synchronized void await() {\n+                while (latch != 0) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        throw new RuntimeException(\"WaitNotifyTest: Unexpected interrupt\", e);\n+                    }\n+                }\n+            }\n+            synchronized void countDown() {\n+                if (latch != 0) {\n+                    latch--;\n+                    if (latch == 0) {\n+                        notifyAll();\n+                    }\n+                }\n+            }\n+        }\n+        static class WaitNotifySyncChannel extends WaitNotifyCountDownLatch {\n+            WaitNotifyCountDownLatch object;\n+            WaitNotifySyncChannel() { super(0); }\n+            synchronized void send(WaitNotifyCountDownLatch object, int count) {\n+                await();\n+                latch = count;\n+                this.object = object;\n+                notifyAll();\n+            }\n+            synchronized WaitNotifyCountDownLatch receive() {\n+                while (latch == 0) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        throw new RuntimeException(\"WaitNotifyTest: Unexpected interrupt\", e);\n+                    }\n+                }\n+                countDown();\n+                return object;\n+            }\n+        }\n+        synchronized int getCount() {\n+            return count;\n+        }\n+        synchronized void increment() {\n+            count++;\n+        }\n+        public void run() {\n+            System.out.println(\"WaitNotifyTest started.\");\n+            for (int t = 0; t < THREADS; t++) {\n+                TF.newThread(() -> {\n+                    for (int i = 0; i < ITERATIONS; i++) {\n+                        startLatchChannel.receive().await();\n+                        increment();\n+                        endLatchChannel.receive().countDown();\n+                    }\n+                }).start();\n+            }\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                WaitNotifyCountDownLatch startLatch = new WaitNotifyCountDownLatch(1);\n+                WaitNotifyCountDownLatch endLatch = new WaitNotifyCountDownLatch(THREADS);\n+                int count = getCount();\n+                if (count != i * THREADS) {\n+                    throw new RuntimeException(\"WaitNotifyTest: Invalid Count \" + count +\n+                                               \" pre-iteration \" + i);\n+                }\n+                startLatchChannel.send(startLatch, 10);\n+                startLatch.countDown();\n+                endLatchChannel.send(endLatch, 10);\n+                endLatch.await();\n+            }\n+            int count = getCount();\n+            if (count != ITERATIONS * THREADS) {\n+                throw new RuntimeException(\"WaitNotifyTest: Invalid Count \" + count);\n+            }\n+            System.out.println(\"WaitNotifyTest passed.\");\n+        }\n+    }\n+\n+    static class RandomDepthTest implements Runnable {\n+        static final int THREADS = 10;\n+        static final int ITERATIONS = 10_000;\n+        static final int MAX_DEPTH = 20;\n+        static final int MAX_RECURSION_COUNT = 10;\n+        static final double RECURSION_CHANCE = .25;\n+        final Random random = Utils.getRandomInstance();\n+        final Locker lockers[] = new Locker[MAX_DEPTH];\n+        final CyclicBarrier syncBarrier = new CyclicBarrier(THREADS + 1);\n+        int count = 0;\n+\n+        class Locker {\n+            final int depth;\n+            Locker(int depth) {\n+                this.depth = depth;\n+            }\n+            synchronized int getCount() {\n+                if (depth == MAX_DEPTH) {\n+                    return count;\n+                }\n+                return lockers[depth].getCount();\n+            }\n+            synchronized void increment(int recursion_count) {\n+                if (recursion_count != MAX_RECURSION_COUNT &&\n+                    random.nextDouble() < RECURSION_CHANCE) {\n+                    this.increment(recursion_count + 1);\n+                    return;\n+                }\n+                if (depth == MAX_DEPTH) {\n+                    count++;\n+                    return;\n+                }\n+                lockers[depth + random.nextInt(MAX_DEPTH - depth)].increment(recursion_count);\n+            }\n+            synchronized Locker create() {\n+                if (depth != MAX_DEPTH) {\n+                    lockers[depth] = (new Locker(depth + 1)).create();\n+                }\n+                return this;\n+            }\n+        }\n+        int getCount() {\n+            return lockers[0].getCount();\n+        }\n+        void increment() {\n+            lockers[random.nextInt(MAX_DEPTH)].increment(0);\n+        }\n+        void create() {\n+            lockers[0] = (new Locker(1)).create();\n+        }\n+        void syncPoint() {\n+            try {\n+                syncBarrier.await();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"RandomDepthTest: Unexpected interrupt\", e);\n+            } catch (BrokenBarrierException e) {\n+                throw new RuntimeException(\"RandomDepthTest: Unexpected broken barrier\", e);\n+            }\n+        }\n+        public void run() {\n+            System.out.println(\"RandomDepthTest started.\");\n+            for (int t = 0; t < THREADS; t++) {\n+                TF.newThread(() -> {\n+                    syncPoint();\n+                    for (int i = 0; i < ITERATIONS; i++) {\n+                        increment();\n+                    }\n+                    syncPoint();\n+                }).start();\n+            }\n+            create();\n+            syncPoint();\n+            syncPoint();\n+            int count = getCount();\n+            if (count != THREADS * ITERATIONS) {\n+                throw new RuntimeException(\"RandomDepthTest: Invalid Count \" + count);\n+            }\n+            System.out.println(\"RandomDepthTest passed.\");\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        Stream.of(\n+            TF.newThread(new WaitNotifyTest()),\n+            TF.newThread(new RandomDepthTest())\n+        ).map(t -> {\n+            t.start();\n+            return t;\n+        }).forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"UseObjectMonitorTableTest: Unexpected interrupt\", e);\n+            }\n+        });\n+\n+        System.out.println(\"UseObjectMonitorTableTest passed.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/UseObjectMonitorTableTest.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8293650\n+ * @requires vm.cds\n+ * @requires vm.bits == 64\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.gc.G1\n+ * @requires vm.gc == null\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/Hello.java\n+ * @run driver TestShenandoahWithCDS\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestShenandoahWithCDS {\n+    public final static String HELLO = \"Hello World\";\n+    static String helloJar;\n+\n+    public static void main(String... args) throws Exception {\n+        helloJar = JarBuilder.build(\"hello\", \"Hello\");\n+\n+        \/\/ Run with the variety of region sizes, and combinations\n+        \/\/ of G1\/Shenandoah at dump\/exec times. \"-1\" means to use G1.\n+        final int[] regionSizes = { -1, 256, 512, 1024, 2048 };\n+\n+        for (int dumpRegionSize : regionSizes) {\n+            for (int execRegionSize : regionSizes) {\n+                test(dumpRegionSize, execRegionSize);\n+            }\n+        }\n+    }\n+\n+    static void test(int dumpRegionSize, int execRegionSize) throws Exception {\n+        String exp = \"-XX:+UnlockExperimentalVMOptions\";\n+        String optDumpGC = (dumpRegionSize != -1) ? \"-XX:+UseShenandoahGC\" : \"-XX:+UseG1GC\";\n+        String optExecGC = (execRegionSize != -1) ? \"-XX:+UseShenandoahGC\" : \"-XX:+UseG1GC\";\n+        String optDumpRegionSize = (dumpRegionSize != -1) ? \"-XX:ShenandoahRegionSize=\" + dumpRegionSize + \"K\" : exp;\n+        String optExecRegionSize = (execRegionSize != -1) ? \"-XX:ShenandoahRegionSize=\" + execRegionSize + \"K\" : exp;\n+        OutputAnalyzer out;\n+\n+        System.out.println(\"0. Dump with \" + optDumpGC + \" and \" + optDumpRegionSize);\n+        out = TestCommon.dump(helloJar,\n+                              new String[] {\"Hello\"},\n+                              exp,\n+                              \"-Xmx1g\",\n+                              optDumpGC,\n+                              optDumpRegionSize,\n+                              \"-Xlog:cds\");\n+        out.shouldContain(\"Dumping shared data to file:\");\n+        out.shouldHaveExitValue(0);\n+\n+        System.out.println(\"1. Exec with \" + optExecGC + \" and \" + optExecRegionSize);\n+        out = TestCommon.exec(helloJar,\n+                              exp,\n+                              \"-Xmx1g\",\n+                              optExecGC,\n+                              optExecRegionSize,\n+                              \"-Xlog:cds\",\n+                              \"Hello\");\n+        out.shouldContain(HELLO);\n+        out.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestShenandoahWithCDS.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -41,1 +41,1 @@\n-        output.shouldContain(\"inflate(has_locker):\");\n+        output.shouldContain(\"inflate:\");\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/MonitorInflationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,8 +50,0 @@\n-\n-\/*\n- * @test id=logging\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:setfmodw001 -XX:TraceJVMTI=ec+,+ioe,+s -Xlog:jvmti=trace:file=vm.%p.log nsk.jvmti.SetFieldModificationWatch.setfmodw001\n- *\/\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -746,0 +746,1 @@\n+jdk\/jfr\/event\/compiler\/TestCodeSweeper.java                     8338127 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -87,0 +87,5 @@\n+\n+            \/\/ Read the first character of output to make sure we've waited until the\n+            \/\/ debuggee is ready. This will be the debug agent's \"Listening...\" message.\n+            char firstChar = (char)is.read();\n+\n@@ -95,2 +100,2 @@\n-            System.out.println(\"Deuggee output:\");\n-            System.out.println(out.getOutput());\n+            System.out.println(\"Debuggee output:\");\n+            System.out.println(firstChar + out.getOutput());\n","filename":"test\/jdk\/com\/sun\/jdi\/DataDumpTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,3 @@\n- * @comment Don't allow -Xcomp or -Xint as they impact memory useage and number of iterations\n- * @requires (vm.compMode == \"Xmixed\")\n+ * @comment Don't allow -Xcomp or -Xint as they impact memory useage and number of iterations.\n+ *          Require compressed oops because not doing so increases memory usage.\n+ * @requires (vm.compMode == \"Xmixed\") & vm.opt.final.UseCompressedOops\n","filename":"test\/jdk\/com\/sun\/jdi\/ThreadMemoryLeakTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+import java.io.File;\n+import java.io.IOException;\n+\n+import javax.imageio.ImageIO;\n@@ -81,0 +85,6 @@\n+                try {\n+                    ImageIO.write(imageAfterChecked, \"png\",\n+                            new File(\"imageAfterChecked.png\"));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n","filename":"test\/jdk\/java\/awt\/Checkbox\/CheckboxCheckerScalingTest.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    private static final int OFFSET = 2;\n+    private static final int OFFSET = 5;\n","filename":"test\/jdk\/java\/awt\/Frame\/MaximizeUndecoratedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.StringBuilder;\n+\n+import java.lang.invoke.*;\n+import java.lang.management.ManagementFactory;\n+\n+\/**\n+ * @test\n+ * @summary Test whether the hidden class unloading of StringConcatFactory works\n+ *\n+ * @requires vm.flagless\n+ * @run main\/othervm -Xmx8M -Xms8M -Xverify:all HiddenClassUnloading\n+ * @run main\/othervm -Xmx8M -Xms8M -Xverify:all -XX:-CompactStrings HiddenClassUnloading\n+ *\/\n+public class HiddenClassUnloading {\n+    public static void main(String[] args) throws Throwable {\n+        var lookup = MethodHandles.lookup();\n+        var types  = new Class<?>[] {\n+                int.class, long.class, double.class, float.class, char.class, boolean.class, String.class,\n+        };\n+\n+        long initUnloadedClassCount = ManagementFactory.getClassLoadingMXBean().getUnloadedClassCount();\n+\n+        for (int i = 0; i < 2000; i++) {\n+            int radix = types.length;\n+            String str = Integer.toString(i, radix);\n+            int length = str.length();\n+            var ptypes = new Class[length];\n+            for (int j = 0; j < length; j++) {\n+                int index = Integer.parseInt(str.substring(j, j + 1), radix);\n+                ptypes[j] = types[index];\n+            }\n+            StringConcatFactory.makeConcatWithConstants(\n+                    lookup,\n+                    \"concat\",\n+                    MethodType.methodType(String.class, ptypes),\n+                    \"\\1\".repeat(length), \/\/ recipe\n+                    new Object[0]\n+            );\n+        }\n+\n+        long unloadedClassCount = ManagementFactory.getClassLoadingMXBean().getUnloadedClassCount();\n+        if (initUnloadedClassCount == unloadedClassCount) {\n+            throw new RuntimeException(\"unloadedClassCount is zero\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/concat\/HiddenClassUnloading.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -72,1 +72,1 @@\n-       int ret = ConstantUtils.skipOverFieldSignature(\"(V)V\", 1, 4, false);\n+       int ret = ConstantUtils.skipOverFieldSignature(\"(V)V\", 1, 4);\n","filename":"test\/jdk\/java\/lang\/constant\/boottest\/java.base\/jdk\/internal\/constant\/ConstantUtilsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import java.nio.file.FileStore;\n@@ -50,0 +51,1 @@\n+import org.testng.SkipException;\n@@ -210,2 +212,7 @@\n-        if (!Files.getFileStore(Paths.get(\".\"))\n-                  .supportsFileAttributeView(PosixFileAttributeView.class)) {\n+        FileStore fs;\n+        try {\n+            fs = Files.getFileStore(Paths.get(\".\"));\n+        } catch (IOException e) {\n+            throw new SkipException(\"WARNING: IOException occurred: \" + e + \", Skipping testDumpDirNotWritable test.\");\n+        }\n+        if (!fs.supportsFileAttributeView(PosixFileAttributeView.class)) {\n@@ -213,6 +220,1 @@\n-            \/\/ We would like to skip the test with a cause with\n-            \/\/     throw new SkipException(\"Posix not supported\");\n-            \/\/ but jtreg will report failure so we just pass the test\n-            \/\/ which we can look at if jtreg changed its behavior\n-            System.out.println(\"WARNING: POSIX is not supported. Skipping testDumpDirNotWritable test.\");\n-            return;\n+            throw new SkipException(\"WARNING: POSIX is not supported. Skipping testDumpDirNotWritable test.\");\n@@ -230,2 +232,1 @@\n-                System.out.println(\"WARNING: The dump directory is writeable. Skipping testDumpDirNotWritable test.\");\n-                return;\n+                throw new SkipException(\"WARNING: The dump directory is writeable. Skipping testDumpDirNotWritable test.\");\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LogGeneratedClassesTest.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8338139\n+ * @summary Basic unit test of ClassLoadingMXBean.set\/isVerbose() when\n+ *          related unified logging is enabled.\n+ *\n+ * @run main\/othervm -Xlog:class+load=trace:file=vm.log TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=debug:file=vm.log TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=info:file=vm.log TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:class+load=trace TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=debug TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=info TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=warning TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=error TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=off TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:class+load*=trace TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=debug TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=warning TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=error TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=off TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=trace TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=debug TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=info TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=warning TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=error TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=off TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:all=trace:file=vm.log TestVerboseClassLoading false\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ClassLoadingMXBean;\n+\n+public class TestVerboseClassLoading {\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassLoadingMXBean mxBean = ManagementFactory.getClassLoadingMXBean();\n+        boolean expected = Boolean.parseBoolean(args[0]);\n+        boolean initial = mxBean.isVerbose();\n+        if (expected != initial) {\n+            throw new Error(\"Initial verbosity setting was unexpectedly \" + initial);\n+        }\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+        mxBean.setVerbose(true);\n+        if (!mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still disabled\");\n+        }\n+        \/\/ Turn off again as a double-check and also to avoid excessive logging\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/management\/ClassLoadingMXBean\/TestVerboseClassLoading.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8338139\n+ * @summary Basic unit test of TestVerboseMemory.set\/isVerbose() when\n+ *          related unified logging is enabled.\n+ *\n+ * @run main\/othervm -Xlog:gc=trace:file=vm.log TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=debug:file=vm.log TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=info:file=vm.log TestVerboseMemory false\n+ *\n+ * @run main\/othervm -Xlog:gc=off TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=error TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=warning TestVerboseMemory false\n+ *\n+ * @run main\/othervm -Xlog:gc=info TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc=trace TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc=debug TestVerboseMemory true\n+ *\n+ * @run main\/othervm -Xlog:gc*=info TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc*=debug TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc*=trace TestVerboseMemory true\n+ *\n+ * @run main\/othervm -Xlog:gc=info,gc+init=off TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc=off,gc+init=info TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc,gc+init TestVerboseMemory true\n+ *\n+ * @run main\/othervm -Xlog:all=trace:file=vm.log TestVerboseMemory false\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+public class TestVerboseMemory {\n+\n+    public static void main(String[] args) throws Exception {\n+        MemoryMXBean mxBean = ManagementFactory.getMemoryMXBean();\n+        boolean expected = Boolean.parseBoolean(args[0]);\n+        boolean initial = mxBean.isVerbose();\n+        if (expected != initial) {\n+            throw new Error(\"Initial verbosity setting was unexpectedly \" + initial);\n+        }\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+        mxBean.setVerbose(true);\n+        if (!mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still disabled\");\n+        }\n+        \/\/ Turn off again as a double-check and also to avoid excessive logging\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/TestVerboseMemory.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,2 +88,2 @@\n-    URI getUri, postUri, hangUri;\n-    URI h2postUri, h2hangUri, h2endStreamUri, h2warmupURI;\n+    URI getUri, postUri, forcePostUri, hangUri;\n+    URI h2postUri, h2forcePostUri, h2hangUri, h2endStreamUri, h2warmupURI;\n@@ -100,0 +100,1 @@\n+                { forcePostUri, 200, false, HTTP_1_1 },\n@@ -102,0 +103,1 @@\n+                { h2forcePostUri, 200, false, HTTP_2 },\n@@ -130,1 +132,1 @@\n-            verifyRequest(expectedStatusCode, resp, exceptionally, testThrowable);\n+            verifyRequest(uri.getPath(), expectedStatusCode, resp, exceptionally, testThrowable);\n@@ -140,0 +142,1 @@\n+        http1TestServer.addHandler(new ForcePostHandler(), \"\/http1\/forcePost\");\n@@ -142,0 +145,1 @@\n+        forcePostUri = URI.create(\"http:\/\/\" + http1TestServer.serverAuthority() + \"\/http1\/forcePost\");\n@@ -152,0 +156,1 @@\n+        http2TestServer.addHandler(new ForcePostHandler().toHttp2Handler(), \"\/http2\/forcePost\");\n@@ -157,0 +162,1 @@\n+        h2forcePostUri = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/forcePost\");\n@@ -160,3 +166,3 @@\n-        out.printf(\"HTTP\/1.1 server listening at: %s\", http1TestServer.serverAuthority());\n-        out.printf(\"HTTP\/1.1 hang server listening at: %s\", hangUri.getRawAuthority());\n-        out.printf(\"HTTP\/2 clear server listening at: %s\", http2TestServer.serverAuthority());\n+        out.printf(\"HTTP\/1.1 server listening at: %s %n\", http1TestServer.serverAuthority());\n+        out.printf(\"HTTP\/1.1 hang server listening at: %s %n\", hangUri.getRawAuthority());\n+        out.printf(\"HTTP\/2 clear server listening at: %s %n\", http2TestServer.serverAuthority());\n@@ -210,0 +216,12 @@\n+    static class ForcePostHandler implements HttpTestHandler {\n+        @Override\n+        public void handle(HttpTestExchange exchange) throws IOException {\n+            try (InputStream is = exchange.getRequestBody()) {\n+                err.println(\"Server reading body inside the force Post\");\n+                is.readAllBytes();\n+                err.println(\"Server send 200 (length=0) in the force post\");\n+                exchange.sendResponseHeaders(200, 0);\n+            }\n+        }\n+    }\n+\n@@ -340,1 +358,4 @@\n-    private void verifyRequest(int expectedStatusCode, HttpResponse<String> resp, boolean exceptionally, Throwable testThrowable) {\n+    private void verifyRequest(String path, int expectedStatusCode, HttpResponse<String> resp, boolean exceptionally, Throwable testThrowable) {\n+        if (!exceptionally) {\n+            err.printf(\"Response code %s received for path %s %n\", resp.statusCode(), path);\n+        }\n@@ -342,1 +363,1 @@\n-            err.println(testThrowable);\n+            err.println(\"Finished exceptionally Test throwable: \" + testThrowable);\n@@ -348,1 +369,1 @@\n-            err.println(\"Request completed successfully\");\n+            err.println(\"Request completed successfully for path \" + path);\n","filename":"test\/jdk\/java\/net\/httpclient\/ExpectContinueTest.java","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import static jdk.test.lib.NetworkConfiguration.isSameInterface;\n@@ -298,2 +299,2 @@\n-        assertTrue(s.getNetworkInterface().equals(ni));\n-        assertTrue(s.getOption(IP_MULTICAST_IF).equals(ni));\n+        assertTrue(isSameInterface(s.getNetworkInterface(), ni));\n+        assertTrue(isSameInterface(s.getOption(IP_MULTICAST_IF), ni));\n@@ -318,2 +319,2 @@\n-        assertTrue(s.getOption(IP_MULTICAST_IF).equals(ni));\n-        assertTrue(s.getNetworkInterface().equals(ni));\n+        assertTrue(isSameInterface(s.getOption(IP_MULTICAST_IF), ni));\n+        assertTrue(isSameInterface(s.getNetworkInterface(), ni));\n@@ -415,1 +416,2 @@\n-        byte[] message = \"hello\".getBytes(\"UTF-8\");\n+        String msg = \"AdaptorMulticasting:  \" + System.nanoTime();\n+        byte[] message = msg.getBytes(\"UTF-8\");\n@@ -424,2 +426,16 @@\n-        p = new DatagramPacket(new byte[1024], 100);\n-        s.receive(p);\n+        while (true) {\n+            p = new DatagramPacket(new byte[1024], 100);\n+            s.receive(p);\n+            if (p.getPort() == s.getLocalPort()) {\n+                String str = new String(p.getData(), p.getOffset(), p.getLength(), \"UTF-8\");\n+                if (Arrays.equals(p.getData(), p.getOffset(), p.getLength(), message, 0, message.length)) {\n+                    System.out.format(\"Got expected message \\\"%s\\\" from %s%n\", str, p.getSocketAddress());\n+                    break;\n+                }\n+                System.out.println(\"Unexpected message received. Expected: \" + msg);\n+                System.out.println(\"Received message doesn't match - skipping: \" + str);\n+            } else {\n+                System.out.println(\"Unexpected message received. Expected message from: \" + s.getLocalAddress());\n+                System.out.println(\"Received message sender doesn't match - skipping: \" + p.getSocketAddress());\n+            }\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/AdaptorMulticasting.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.net.BindException;\n@@ -49,0 +50,1 @@\n+import java.util.function.Predicate;\n@@ -57,0 +59,32 @@\n+    interface RetryableTest<T extends Exception> {\n+        public void runTest() throws T;\n+    }\n+\n+    \/\/ retry the given lambda (RetryableTest) if an exception\n+    \/\/ that satisfies the predicate (retryOn) is caught.\n+    <T extends Exception> void testWithRetry(RetryableTest<T> test,\n+                                             Predicate<Throwable> retryOn,\n+                                             int max) throws T {\n+        for (int i=0; i < max; i++) {\n+            try {\n+                test.runTest();\n+                break;\n+            } catch (Throwable t) {\n+                if (i < max -1 && retryOn.test(t)) {\n+                    System.out.println(\"Got \" + t + \"; will retry\");\n+                } else throw t;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * When calling {@link DatagramChannel#disconnect()} a {@link BindException}\n+     * may occur. In which case we want to retry the test.\n+     *\/\n+    class BindExceptionOnDisconnect extends BindException {\n+        BindExceptionOnDisconnect(BindException x) {\n+            super(x.getMessage());\n+            initCause(x);\n+        }\n+    }\n+\n@@ -64,11 +98,3 @@\n-        try (DatagramChannel dc = DatagramChannel.open()) {\n-            System.out.println(\"Test with default\");\n-            dc.bind(new InetSocketAddress(lb, 0));\n-            test(dc);\n-            test(dc);\n-        }\n-\n-        \/\/ test with IPv6 socket\n-        if (IPSupport.hasIPv6()) {\n-            System.out.println(\"Test with IPv6 socket\");\n-            try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET6)) {\n+        System.out.println(\"Test with default\");\n+        testWithRetry(() -> {\n+            try (DatagramChannel dc = DatagramChannel.open()) {\n@@ -79,0 +105,12 @@\n+        }, BindExceptionOnDisconnect.class::isInstance, 5);\n+\n+        \/\/ test with IPv6 socket\n+        if (IPSupport.hasIPv6()) {\n+            System.out.println(\"Test with IPv6 socket\");\n+            testWithRetry(() -> {\n+                try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET6)) {\n+                    dc.bind(new InetSocketAddress(lb, 0));\n+                    test(dc);\n+                    test(dc);\n+                }\n+            }, BindExceptionOnDisconnect.class::isInstance, 5);\n@@ -84,5 +122,7 @@\n-            try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET)) {\n-                dc.bind(new InetSocketAddress(lb, 0));\n-                test(dc);\n-                test(dc);\n-            }\n+            testWithRetry(() -> {\n+                try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET)) {\n+                    dc.bind(new InetSocketAddress(lb, 0));\n+                    test(dc);\n+                    test(dc);\n+                }\n+            }, BindExceptionOnDisconnect.class::isInstance, 5);\n@@ -92,0 +132,1 @@\n+\n@@ -114,1 +155,5 @@\n-            dc.disconnect();\n+            try {\n+                dc.disconnect();\n+            } catch (BindException x) {\n+                throw new BindExceptionOnDisconnect(x);\n+            }\n@@ -137,1 +182,5 @@\n-        dc.disconnect();\n+        try {\n+            dc.disconnect();\n+        } catch (BindException x) {\n+            throw new BindExceptionOnDisconnect(x);\n+        }\n@@ -171,1 +220,5 @@\n-            dc.disconnect();\n+            try {\n+                dc.disconnect();\n+            } catch (BindException x) {\n+                throw new BindExceptionOnDisconnect(x);\n+            }\n@@ -213,1 +266,5 @@\n-            dc.disconnect();\n+            try {\n+                dc.disconnect();\n+            } catch (BindException x) {\n+                throw new BindExceptionOnDisconnect(x);\n+            }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/AfterDisconnect.java","additions":78,"deletions":21,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform Connect\n@@ -41,0 +43,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -117,0 +121,11 @@\n+                \/\/ When connecting an unbound datagram channel, the underlying\n+                \/\/ socket will first be bound to the wildcard address. On macOS,\n+                \/\/ the system may allocate the same port on which another socket\n+                \/\/ is already bound with a more specific address. This may prevent\n+                \/\/ datagrams directed at the connected socket to reach it.\n+                \/\/ To avoid this, when on macOS, we preemptively bind `dc` to the\n+                \/\/ specific address instead of letting it bind to the wildcard.\n+                if (Platform.isOSX()) {\n+                    dc.bind(new InetSocketAddress(((InetSocketAddress)connectSocketAddress).getAddress(), 0));\n+                    err.println(\"Initiator bound to: \" + connectSocketAddress);\n+                }\n@@ -120,0 +135,1 @@\n+                assert !connectSocketAddress.equals(dc.getLocalAddress());\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Connect.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- *     sender address\n+ *     sender address.\n@@ -66,0 +66,1 @@\n+            System.out.println(\"\\nReader bound to: \" + reader.getLocalAddress());\n@@ -78,0 +79,1 @@\n+            System.out.println(\"\\nSender bound to: \" + sender.getLocalAddress());\n@@ -100,0 +102,5 @@\n+            System.out.println(\"Sender bound to: \" + local);\n+            if (((InetSocketAddress)local).getPort() == remotePort) {\n+                System.out.println(\"testSend: Sender and reader have same port: skipping\");\n+                return;\n+            }\n@@ -108,0 +115,2 @@\n+                System.out.format(\"testSend: reader waiting to receive at: %s%n\",\n+                        reader.getLocalAddress());\n@@ -141,0 +150,5 @@\n+            System.out.println(\"Reader bound to: \" + remote);\n+            if (((InetSocketAddress)local).getPort() == ((InetSocketAddress)remote).getPort()) {\n+                System.out.println(\"testReceive: Sender and reader have same port: skipping\");\n+                return;\n+            }\n@@ -146,0 +160,2 @@\n+                System.out.format(\"testReceive: reader waiting to receive at: %s%n\",\n+                        reader.getLocalAddress());\n@@ -168,1 +184,6 @@\n-            return Optional.ofNullable(NetworkInterface.getByInetAddress(ia));\n+            NetworkInterface nif = NetworkInterface.getByInetAddress(ia);\n+            if (nif != null) {\n+                System.out.format(\"Selecting interface %s[%d]%n\\twith addresses:%n\\t%s%n\",\n+                    nif.getDisplayName(), nif.getIndex(), nif.inetAddresses().toList());\n+            }\n+            return Optional.ofNullable(nif);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/ManySourcesAndTargets.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,1 @@\n+            long elapsed = 0;\n@@ -104,0 +105,1 @@\n+                long start = System.nanoTime();\n@@ -105,0 +107,3 @@\n+                long waited = (System.nanoTime() - start) \/ 1000_000;\n+                elapsed += waited;\n+                buf.clear();\n@@ -110,1 +115,6 @@\n-                        throw new RuntimeException(\"Expected message not received\");\n+                        if (elapsed > 4800) {\n+                            throw new RuntimeException(\"Expected message not received\");\n+                        } else {\n+                            sel.selectedKeys().clear();\n+                            continue;\n+                        }\n@@ -126,2 +136,2 @@\n-                    System.out.format(\"Received message from %s (id=0x%x)\\n\",\n-                            sender, receivedId);\n+                    System.out.format(\"Received message from %s (id=0x%x, length=%s)\\n\",\n+                            sender, receivedId, bytes.length);\n@@ -145,1 +155,0 @@\n-                buf.rewind();\n@@ -163,0 +172,2 @@\n+        System.out.format(\"With interface=%s[%s]%n\\twith bound addresses:%n\\t%s%n\",\n+                nif.getDisplayName(), nif.getIndex(), nif.inetAddresses().toList());\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/MulticastSendReceiveTests.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- *     the channel's socket to be bound to a local address\n+ *     the channel's socket to be bound to a local address.\n+ * @run main\/othervm NotBound\n@@ -34,0 +35,3 @@\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -37,0 +41,2 @@\n+    static final CountDownLatch received = new CountDownLatch(1);\n+\n@@ -40,0 +46,1 @@\n+        System.out.println(\"Bound to: \" + dc.getLocalAddress());\n@@ -54,0 +61,1 @@\n+                    System.out.format(\"receiver bound to: %s%n\", local);\n@@ -55,10 +63,35 @@\n-                    \/\/ send message to channel to wakeup receiver\n-                    DatagramChannel sender = DatagramChannel.open();\n-                    try {\n-                        ByteBuffer bb = ByteBuffer.wrap(\"hello\".getBytes());\n-                        InetAddress lh = InetAddress.getLocalHost();\n-                        SocketAddress target =\n-                            new InetSocketAddress(lh, local.getPort());\n-                        sender.send(bb, target);\n-                    } finally {\n-                        sender.close();\n+                    boolean isAnyLocal = local.getAddress().isAnyLocalAddress();\n+                    int maxAttempts = 5;\n+                    int localPort = 0;\n+                    List<InetAddress> llh = isAnyLocal\n+                            ? List.of(InetAddress.getLocalHost(), InetAddress.getLoopbackAddress())\n+                            : List.of(local.getAddress());\n+                    SocketAddress target = null;\n+                    for (int i = 0 ; i < maxAttempts ; i++) {\n+                        InetAddress lh = llh.get(i % llh.size());\n+                        target = new InetSocketAddress(lh, local.getPort());\n+                        \/\/ send message to channel to wakeup receiver\n+                        try (DatagramChannel sender = DatagramChannel.open()) {\n+                            ByteBuffer bb = ByteBuffer.wrap(\"NotBound: hello\".getBytes());\n+                            sender.send(bb, target);\n+                            System.out.format(\"Woke up receiver: sent datagram to %s from %s%n\",\n+                                    target, sender.getLocalAddress());\n+                            localPort = ((InetSocketAddress)sender.getLocalAddress()).getPort();\n+                        }\n+                        if (received.await(250, TimeUnit.MILLISECONDS)) {\n+                            \/\/ The datagram has been received: no need to continue\n+                            \/\/ sending\n+                            break;\n+                        }\n+                        \/\/ if sender port and destination port were identical, which\n+                        \/\/ could happen on some systems, the receiver might not receive\n+                        \/\/ the datagram. So in that case we try again, bailing out if\n+                        \/\/ we had to retry too many times\n+                        if (localPort == local.getPort()) {\n+                            System.out.println(\"Local port and peer port are identical. Retrying...\");\n+                        } else {\n+                            System.out.println(\"Datagram not received after 250ms. Retrying...\");\n+                        }\n+                    }\n+                    if (localPort == local.getPort()) {\n+                        System.out.println(\"Couldn't find a port to send to \" + target);\n@@ -66,1 +99,0 @@\n-\n@@ -80,4 +112,4 @@\n-            DatagramChannel peer = DatagramChannel.open()\n-                .bind(new InetSocketAddress(0));\n-            int peerPort = ((InetSocketAddress)(peer.getLocalAddress())).getPort();\n-            try {\n+            System.out.println(\"Check that connect() binds the socket\");\n+            try (DatagramChannel peer = DatagramChannel.open()) {\n+                peer.bind(new InetSocketAddress(0));\n+                int peerPort = ((InetSocketAddress)(peer.getLocalAddress())).getPort();\n@@ -86,2 +118,0 @@\n-            } finally {\n-                peer.close();\n@@ -96,1 +126,2 @@\n-            ByteBuffer bb = ByteBuffer.wrap(\"ignore this\".getBytes());\n+            System.out.println(\"Check that send() binds the socket\");\n+            ByteBuffer bb = ByteBuffer.wrap(\"NotBound: ignore this\".getBytes());\n@@ -108,0 +139,1 @@\n+            System.out.println(\"Check that blocking receive() binds the socket\");\n@@ -111,0 +143,1 @@\n+            received.countDown();\n@@ -121,0 +154,1 @@\n+            System.out.println(\"Check that non-blocking receive() binds the socket\");\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/NotBound.java","additions":54,"deletions":20,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,3 @@\n-            System.out.format(\"Send message -> group %s (id=0x%x)\\n\",\n-                    group.getHostAddress(), id);\n+            System.out.format(\"Send message -> group [%s]:%d (id=0x%x) nif:%s[%s]%n\",\n+                    group.getHostAddress(), port, id, nif.getDisplayName(), nif.getIndex());\n+            System.out.format(\"bound address before send: %s%n\", dc.getLocalAddress());\n@@ -77,0 +78,1 @@\n+            System.out.format(\"bound address after send: %s%n\", dc.getLocalAddress());\n@@ -100,0 +102,1 @@\n+            long elapsed = 0;\n@@ -102,0 +105,1 @@\n+                long start = System.nanoTime();\n@@ -103,0 +107,3 @@\n+                long waited = (System.nanoTime() - start) \/ 1000_000;\n+                elapsed += waited;\n+                buf.clear();\n@@ -108,1 +115,7 @@\n-                        throw new RuntimeException(\"Expected message not received\");\n+                        if (elapsed > 4800) {\n+                            throw new RuntimeException(\"Expected message not received\");\n+                        } else {\n+                            sel.selectedKeys().clear();\n+                            \/\/ We haven't waited long enough,\n+                            continue;\n+                        }\n@@ -124,2 +137,2 @@\n-                    System.out.format(\"Received message from %s (id=0x%x)\\n\",\n-                            sender, receivedId);\n+                    System.out.format(\"Received message from %s (id=0x%x, length=%s)\\n\",\n+                            sender, receivedId, bytes.length);\n@@ -143,1 +156,0 @@\n-                buf.rewind();\n@@ -158,0 +170,2 @@\n+        System.out.format(\"With interface=%s[%s]%n\\twith bound addresses:%n\\t%s%n\",\n+                nif.getDisplayName(), nif.getIndex(), nif.inetAddresses().toList());\n@@ -159,4 +173,4 @@\n-        DatagramChannel dc1 = (family == UNSPEC) ?\n-            DatagramChannel.open() : DatagramChannel.open(family);\n-        DatagramChannel dc2 = (family == UNSPEC) ?\n-            DatagramChannel.open() : DatagramChannel.open(family);\n+        try (DatagramChannel dc1 = (family == UNSPEC) ?\n+                DatagramChannel.open() : DatagramChannel.open(family);\n+            DatagramChannel dc2 = (family == UNSPEC) ?\n+                DatagramChannel.open() : DatagramChannel.open(family)) {\n@@ -164,1 +178,0 @@\n-        try {\n@@ -187,1 +200,0 @@\n-            receiveDatagram(dc1, \"dc1\", false, id);\n@@ -189,4 +201,1 @@\n-\n-        } finally {\n-            dc1.close();\n-            dc2.close();\n+            receiveDatagram(dc1, \"dc1\", false, id);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Promiscuous.java","additions":26,"deletions":17,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,6 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ *        jdk.test.lib.Platform\n+ *        ReceiveISA\n+ * @run main\/othervm ReceiveISA\n+ *\n@@ -34,0 +40,3 @@\n+\n+import jdk.test.lib.Platform;\n+\n@@ -47,1 +56,5 @@\n-            dc3.socket().bind((SocketAddress) null); \/\/ bind server to any port\n+            InetAddress lh = InetAddress.getLocalHost();\n+            InetSocketAddress dest = Platform.isOSX()\n+                    ? new InetSocketAddress(lh, 0)\n+                    : null;\n+            dc3.socket().bind(dest); \/\/ bind server to any port\n@@ -50,1 +63,0 @@\n-            InetAddress lh = InetAddress.getLocalHost();\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/ReceiveISA.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-    static final int MAX_TRIES = 3;\n-    static final String GREETINGS_MESSAGE = \"Greetings from SelectWhenRefused!\";\n+    static final int MAX_TRIES = 10;\n+    static final String GREETINGS_MESSAGE = System.nanoTime() + \": Greetings from SelectWhenRefused!\";\n@@ -52,0 +52,1 @@\n+        System.err.println(\"Refuser is: \" + refuser);\n@@ -53,1 +54,29 @@\n-        DatagramChannel dc = DatagramChannel.open().bind(new InetSocketAddress(0));\n+        DatagramChannel dc = null;\n+        for (int i=0; i < MAX_TRIES; i++) {\n+            dc = DatagramChannel.open();\n+            try {\n+                dc.bind(new InetSocketAddress(0));\n+            } catch (Throwable t) {\n+                dc.close();\n+                throw t;\n+            }\n+\n+            \/\/ check the port assigned to dc\n+            if (((InetSocketAddress)dc.getLocalAddress()).getPort() != port) {\n+                \/\/ We got a good port. Do not retry\n+                break;\n+            }\n+\n+            \/\/ We bound to the same port that the refuser is using, This will not\n+            \/\/ work. Retry binding if possible.\n+            if (i < MAX_TRIES - 1) {\n+                \/\/ we will retry...\n+                System.err.format(\"Refuser port has been reused by dc: %s, retrying...%n\",\n+                        dc.getLocalAddress());\n+            } else {\n+                \/\/ that was the last attempt... Skip the test\n+                System.err.format(\"Skipping test: refuser port has been reused by dc: %s%n\",\n+                        dc.getLocalAddress());\n+                return;\n+            }\n+        }\n@@ -55,0 +84,1 @@\n+        assert dc != null;\n@@ -91,1 +121,1 @@\n-            System.out.println(\"Skipping test: refuser port has been reused: \" + e);\n+            System.err.println(\"Skipping test: refuser port has been reused: \" + e);\n@@ -122,1 +152,3 @@\n-            DatagramChannel.open().bind(refuser).close();\n+            try (DatagramChannel dc2 = DatagramChannel.open()) {\n+                dc2.bind(refuser);\n+            }\n@@ -154,1 +186,1 @@\n-                    System.out.format(\"received %s at %s from %s%n\", message, dc.getLocalAddress(), sa);\n+                    System.err.format(\"received %s at %s from %s%n\", message, dc.getLocalAddress(), sa);\n@@ -169,1 +201,3 @@\n-                DatagramChannel.open().bind(refuser).close();\n+                try (DatagramChannel dc2 = DatagramChannel.open()) {\n+                    dc2.bind(refuser);\n+                }\n@@ -172,1 +206,1 @@\n-                System.out.println(\"Got expected PortUnreachableException \" + pue);\n+                System.err.println(\"Got expected PortUnreachableException \" + pue);\n@@ -218,1 +252,1 @@\n-        System.out.format(\"Received %d keys%n\", selectedKeys.size());\n+        System.err.format(\"Received %d keys%n\", selectedKeys.size());\n@@ -222,1 +256,1 @@\n-                System.out.println(\"Invalid or unreadable key: \" + key);\n+                System.err.println(\"Invalid or unreadable key: \" + key);\n@@ -227,1 +261,1 @@\n-                System.out.println(\"Attempting to read datagram from key: \" + key);\n+                System.err.println(\"Attempting to read datagram from key: \" + key);\n@@ -237,1 +271,1 @@\n-                    System.out.format(\"received %s at %s from %s%n\", message, datagramChannel.getLocalAddress(), sa);\n+                    System.err.format(\"received %s at %s from %s%n\", message, datagramChannel.getLocalAddress(), sa);\n@@ -246,1 +280,1 @@\n-                System.out.println(\"Unable to read from datagram \" + io);\n+                System.err.println(\"Unable to read from datagram \" + io);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/SelectWhenRefused.java","additions":47,"deletions":13,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import org.testng.Assert;\n@@ -49,0 +50,1 @@\n+import java.net.SocketAddress;\n@@ -142,1 +144,3 @@\n-                sender.bind(null);\n+                sender.bind(new InetSocketAddress(host, 0));\n+                System.out.format(\"testSendReceiveMaxSize: sender: %s -> receiver: %s%n\",\n+                        sender.getLocalAddress(), receiver.getLocalAddress());\n@@ -153,1 +157,12 @@\n-                receiver.receive(receiveBuf);\n+                SocketAddress src;\n+                int count = 0;\n+                do {\n+                    receiveBuf.clear();\n+                    src = receiver.receive(receiveBuf);\n+                    if (sender.getLocalAddress().equals(src)) break;\n+                    System.out.println(\"step1: received unexpected datagram from: \" + src);\n+                    System.out.println(\"\\texpected: \" + sender.getLocalAddress());\n+                    if (++count > 10) {\n+                        throw new AssertionError(\"too many unexpected messages\");\n+                    }\n+                } while (true);\n@@ -170,1 +185,11 @@\n-                receiver.receive(receiveBuf);\n+                count = 0;\n+                do {\n+                    receiveBuf.clear();\n+                    src = receiver.receive(receiveBuf);\n+                    if (sender.getLocalAddress().equals(src)) break;\n+                    System.out.println(\"step1: received unexpected datagram from: \" + src);\n+                    System.out.println(\"\\texpected: \" + sender.getLocalAddress());\n+                    if (++count > 10) {\n+                        throw new AssertionError(\"too many unexpected messages\");\n+                    }\n+                } while (true);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/SendReceiveMaxSize.java","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform Sender\n+ * @run main Sender\n@@ -39,0 +42,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -49,2 +54,2 @@\n-        Server server = new Server();\n-        Client client = new Client(server.port());\n+        try (Server server = new Server()) {\n+            Client client = new Client(server.port());\n@@ -52,2 +57,2 @@\n-        Thread serverThread = new Thread(server);\n-        serverThread.start();\n+            Thread serverThread = new Thread(server);\n+            serverThread.start();\n@@ -55,2 +60,2 @@\n-        Thread clientThread = new Thread(client);\n-        clientThread.start();\n+            Thread clientThread = new Thread(client);\n+            clientThread.start();\n@@ -58,2 +63,2 @@\n-        serverThread.join();\n-        clientThread.join();\n+            serverThread.join();\n+            clientThread.join();\n@@ -61,2 +66,3 @@\n-        server.throwException();\n-        client.throwException();\n+            server.throwException();\n+            client.throwException();\n+        }\n@@ -67,1 +73,1 @@\n-        Exception e = null;\n+        volatile Exception e = null;\n@@ -79,2 +85,1 @@\n-            try {\n-                DatagramChannel dc = DatagramChannel.open();\n+            try (DatagramChannel dc = DatagramChannel.open()) {\n@@ -87,0 +92,4 @@\n+                if (Platform.isOSX()) {\n+                    \/\/ avoid binding on wildcard on macOS\n+                    dc.bind(new InetSocketAddress(address, 0));\n+                }\n@@ -96,1 +105,1 @@\n-    public static class Server implements Runnable {\n+    public static class Server implements Runnable, AutoCloseable {\n@@ -98,1 +107,1 @@\n-        Exception e = null;\n+        volatile Exception e = null;\n@@ -101,1 +110,5 @@\n-            dc = DatagramChannel.open().bind(new InetSocketAddress(0));\n+            \/\/ avoid binding to wildcard address on macOS\n+            InetSocketAddress lo = Platform.isOSX()\n+                    ? new InetSocketAddress(InetAddress.getLocalHost(), 0)\n+                    : new InetSocketAddress(0);\n+            dc = DatagramChannel.open().bind(lo);\n@@ -152,0 +165,5 @@\n+\n+        @Override\n+        public void close() throws IOException {\n+            dc.close();\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Sender.java","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6318027\n+ * @key headful\n+ * @summary  Verifies BasicScrollBarUI disables timer when enclosing frame is disabled\n+ * @run main DisableFrameFromScrollBar\n+ *\/\n+\n+import java.awt.FlowLayout;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.AdjustmentEvent;\n+import java.awt.event.AdjustmentListener;\n+import java.awt.event.InputEvent;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JScrollBar;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+\n+public class DisableFrameFromScrollBar {\n+\n+    private static JFrame frame;\n+    private static JScrollBar bar;\n+    private static int oldValue;\n+    private static volatile boolean doCheck;\n+    private static volatile boolean isAdjusting;\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported LAF: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void createUI() {\n+        frame = new JFrame(DisableFrameFromScrollBar.class.getName());\n+        bar = new JScrollBar();\n+        bar.getModel().addChangeListener(new DisableChangeListener(frame));\n+        frame.getContentPane().setLayout(new FlowLayout());\n+        frame.add(bar);\n+\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setSize(150, 150);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo laf : UIManager.getInstalledLookAndFeels()) {\n+            System.out.println(\"Testing LAF : \" + laf.getClassName());\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            try {\n+                SwingUtilities.invokeAndWait(() -> {\n+                    setLookAndFeel(laf);\n+                    createUI();\n+                });\n+\n+                robot.waitForIdle();\n+                robot.delay(1000);\n+                Point point = getClickPoint();\n+                robot.mouseMove(point.x, point.y);\n+                robot.waitForIdle();\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+                SwingUtilities.invokeAndWait(() -> {\n+                    oldValue = bar.getValue();\n+                    bar.addAdjustmentListener(new AdjustmentListener() {\n+                        public void adjustmentValueChanged(AdjustmentEvent e) {\n+                            int curValue = e.getValue();\n+                            int extent = bar.getMaximum() - bar.getVisibleAmount();\n+                            if (curValue < extent && curValue != oldValue) {\n+                                oldValue = curValue;\n+                                isAdjusting = true;\n+                            } else {\n+                                doCheck = true;\n+                                isAdjusting = false;\n+                            }\n+                        }\n+                    });\n+                });\n+                do {\n+                    Thread.sleep(200);\n+                } while (isAdjusting && !doCheck);\n+                if (bar.getValue() == (bar.getMaximum() - bar.getVisibleAmount())) {\n+                    throw new RuntimeException(\"ScrollBar didn't disable timer\");\n+                }\n+            } finally {\n+                SwingUtilities.invokeAndWait(() -> {\n+                    if (frame != null) {\n+                       frame.dispose();\n+                    }\n+               });\n+            }\n+        }\n+    }\n+\n+    private static Point getClickPoint() throws Exception {\n+        final Point[] result = new Point[1];\n+\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+\n+            @Override\n+            public void run() {\n+                Point p = bar.getLocationOnScreen();\n+                Rectangle rect = bar.getBounds();\n+                result[0] = new Point((int) (p.x + rect.width \/ 2),\n+                        (int) (p.y + rect.height - 10));\n+            }\n+        });\n+\n+        return result[0];\n+\n+    }\n+\n+    public static class DisableChangeListener implements ChangeListener {\n+        private final JFrame m_frame;\n+        private boolean m_done;\n+\n+        public DisableChangeListener(JFrame p_frame) {\n+            m_frame = p_frame;\n+        }\n+\n+        public void stateChanged(ChangeEvent p_e) {\n+            if (!m_done) {\n+                m_frame.setEnabled(false);\n+                Thread t = new Thread(new Enabler(m_frame));\n+                t.start();\n+                m_done = true;\n+            }\n+        }\n+    }\n+\n+    public static class Enabler implements Runnable {\n+        private JFrame m_frame;\n+\n+        Enabler(JFrame p_frame) {\n+            m_frame = p_frame;\n+        }\n+\n+        public void run() {\n+            try {\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            m_frame.setEnabled(true);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JScrollBar\/DisableFrameFromScrollBar.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -69,1 +69,1 @@\n-                                                  ClassDesc.of(\"Boo\"), List.of()))))))\n+                                                  Annotation.of(ClassDesc.of(\"Boo\"), List.of())))))))\n@@ -104,1 +104,1 @@\n-                                                ClassDesc.of(\"Boo\"), List.of())));\n+                                                Annotation.of(ClassDesc.of(\"Boo\"), List.of()))));\n@@ -119,1 +119,1 @@\n-                                          ClassDesc.of(\"Fee\"), List.of(AnnotationElement.ofBoolean(\"yes\", false)))))\n+                                          Annotation.of(ClassDesc.of(\"Fee\"), List.of(AnnotationElement.ofBoolean(\"yes\", false))))))\n","filename":"test\/jdk\/jdk\/classfile\/ClassPrinterTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304031 8338406\n+ * @summary Testing handling of various constant descriptors in ClassFile API.\n+ * @run junit ConstantDescSymbolsTest\n+ *\/\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.function.Supplier;\n+import java.lang.classfile.ClassFile;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class ConstantDescSymbolsTest {\n+\n+    \/\/ Testing that primitive class descs are encoded properly as loadable constants.\n+    @Test\n+    void testPrimitiveClassDesc() throws Throwable {\n+        ClassDesc ape = ClassDesc.of(\"Ape\");\n+        var lookup = MethodHandles.lookup();\n+        Class<?> a = lookup.defineClass(ClassFile.of().build(ape, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow());\n+            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> {\n+                cob.loadConstant(CD_int);\n+                cob.areturn();\n+            });\n+            clb.withMethodBody(\"get2\", MethodTypeDesc.of(CD_Class), ACC_PUBLIC, cob -> {\n+                Assertions.assertThrows(IllegalArgumentException.class, () -> cob.constantPool().classEntry(CD_long));\n+                var t = cob.constantPool().loadableConstantEntry(CD_long);\n+                cob.ldc(t);\n+                cob.areturn();\n+            });\n+        }));\n+        Supplier<?> t = (Supplier<?>) lookup.findConstructor(a, MethodType.methodType(void.class))\n+                .asType(MethodType.methodType(Supplier.class))\n+                .invokeExact();\n+        assertSame(int.class, t.get());\n+    }\n+\n+    \/\/ Tests that condy symbols with non-static-method bootstraps are using the right lookup descriptor.\n+    @Test\n+    void testConstantDynamicNonStaticBootstrapMethod() throws Throwable {\n+        record CondyBoot(MethodHandles.Lookup lookup, String name, Class<?> type) {}\n+        var bootClass = CondyBoot.class.describeConstable().orElseThrow();\n+        var bootMhDesc = MethodHandleDesc.ofConstructor(bootClass, CD_MethodHandles_Lookup, CD_String, CD_Class);\n+        var condyDesc = DynamicConstantDesc.of(bootMhDesc);\n+\n+        var targetCd = ClassDesc.of(\"Bat\");\n+        var lookup = MethodHandles.lookup();\n+        Class<?> a = lookup.defineClass(ClassFile.of().build(targetCd, clb -> {\n+            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow())\n+                    .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> cob\n+                            .aload(0).invokespecial(CD_Object, INIT_NAME, MTD_void).return_())\n+                    .withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> cob\n+                            .loadConstant(condyDesc).areturn());\n+        }));\n+        @SuppressWarnings(\"unchecked\")\n+        Supplier<CondyBoot> t = (Supplier<CondyBoot>) lookup.findConstructor(a, MethodType.methodType(void.class))\n+                .asType(MethodType.methodType(Supplier.class)).invokeExact();\n+        var cb = t.get();\n+        assertEquals(MethodHandles.Lookup.ORIGINAL, cb.lookup.lookupModes() & MethodHandles.Lookup.ORIGINAL);\n+        assertSame(a, cb.lookup.lookupClass());\n+        assertEquals(DEFAULT_NAME, cb.name);\n+        assertEquals(CondyBoot.class, cb.type);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ConstantDescSymbolsTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8304031\n- * @summary Testing that primitive class descs are encoded properly as loadable constants.\n- * @run junit PrimitiveClassConstantTest\n- *\/\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.function.Supplier;\n-import java.lang.classfile.ClassFile;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import static java.lang.constant.ConstantDescs.CD_Class;\n-import static java.lang.constant.ConstantDescs.CD_Object;\n-import static java.lang.constant.ConstantDescs.CD_int;\n-import static java.lang.constant.ConstantDescs.CD_long;\n-import static java.lang.constant.ConstantDescs.INIT_NAME;\n-import static java.lang.constant.ConstantDescs.MTD_void;\n-import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n-\n-public final class PrimitiveClassConstantTest {\n-\n-    @Test\n-    public void test() throws Throwable {\n-        ClassDesc ape = ClassDesc.of(\"Ape\");\n-        var lookup = MethodHandles.lookup();\n-        Class<?> a = lookup.defineClass(ClassFile.of().build(ape, clb -> {\n-            clb.withSuperclass(CD_Object);\n-            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow());\n-            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n-                cob.aload(0);\n-                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n-                cob.return_();\n-            });\n-            clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> {\n-                cob.loadConstant(CD_int);\n-                cob.areturn();\n-            });\n-            clb.withMethodBody(\"get2\", MethodTypeDesc.of(CD_Class), ACC_PUBLIC, cob -> {\n-                Assertions.assertThrows(IllegalArgumentException.class, () -> cob.constantPool().classEntry(CD_long));\n-                var t = cob.constantPool().loadableConstantEntry(CD_long);\n-                cob.ldc(t);\n-                cob.areturn();\n-            });\n-        }));\n-        Supplier<?> t = (Supplier<?>) lookup.findConstructor(a, MethodType.methodType(void.class))\n-                .asType(MethodType.methodType(Supplier.class))\n-                .invokeExact();\n-        Assertions.assertSame(int.class, t.get());\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/classfile\/PrimitiveClassConstantTest.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8305990 8320222 8320618 8335475\n+ * @bug 8305990 8320222 8320618 8335475 8338623 8338661\n@@ -34,0 +34,2 @@\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n@@ -35,0 +37,4 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -39,0 +45,1 @@\n+import java.util.List;\n@@ -43,1 +50,0 @@\n-import static java.lang.constant.ConstantDescs.MTD_void;\n@@ -47,5 +53,1 @@\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.reflect.AccessFlag;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -344,0 +346,53 @@\n+\n+    private static final MethodTypeDesc MTD_int = MethodTypeDesc.of(CD_int);\n+    private static final MethodTypeDesc MTD_int_String = MethodTypeDesc.of(CD_int, CD_String);\n+\n+    @ParameterizedTest\n+    @EnumSource(ClassFile.StackMapsOption.class)\n+    void testInvocationCounters(ClassFile.StackMapsOption option) {\n+        var cf = ClassFile.of(option);\n+        var cd = ClassDesc.of(\"Test\");\n+        var bytes = cf.build(cd, clb -> clb\n+            .withMethodBody(\"a\", MTD_int_String, ACC_STATIC, cob -> cob\n+                    .aload(0)\n+                    .invokevirtual(CD_String, \"hashCode\", MTD_int)\n+                    .ireturn())\n+            .withMethodBody(\"b\", MTD_int, 0, cob -> cob\n+                    .aload(0)\n+                    .invokevirtual(cd, \"hashCode\", MTD_int)\n+                    .ireturn())\n+        );\n+\n+        var cm = ClassFile.of().parse(bytes);\n+        for (var method : cm.methods()) {\n+            var code = method.findAttribute(Attributes.code()).orElseThrow();\n+            assertEquals(1, code.maxLocals());\n+            assertEquals(1, code.maxStack());\n+        }\n+    }\n+\n+    @Test\n+    void testDeadCodeCountersWithCustomSMTA() {\n+        ClassDesc bar = ClassDesc.of(\"Bar\");\n+        byte[] bytes = ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS).build(bar, clb -> clb\n+                .withMethodBody(\n+                        \"foo\", MethodTypeDesc.of(ConstantDescs.CD_long), ACC_STATIC, cob -> {\n+                            cob.lconst_0().lreturn();\n+                            Label f2 = cob.newBoundLabel();\n+                            cob.lstore(0);\n+                            Label f3 = cob.newBoundLabel();\n+                            cob.lload(0).lreturn().with(\n+                                    StackMapTableAttribute.of(List.of(\n+                                    StackMapFrameInfo.of(f2,\n+                                            List.of(),\n+                                            List.of(StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_LONG)),\n+                                    StackMapFrameInfo.of(f3,\n+                                            List.of(StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_LONG),\n+                                            List.of()))));\n+                        }\n+                ));\n+        assertEmpty(ClassFile.of().verify(bytes));\n+        var code = (CodeAttribute) ClassFile.of().parse(bytes).methods().getFirst().code().orElseThrow();\n+        assertEquals(2, code.maxLocals());\n+        assertEquals(2, code.maxStack());\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":62,"deletions":7,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8336010 8336588\n+ * @bug 8335935 8336588\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -831,1 +831,1 @@\n-                    AnnotationRecord.ofAnnotation(ann));\n+                    AnnotationRecord.ofAnnotation(ann.annotation()));\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/ClassRecord.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,2 +182,1 @@\n-                        ta.classSymbol(),\n-                        ta.elements().stream().map(ae -> AnnotationElement.of(ae.name().stringValue(), transformAnnotationValue(ae.value()))).toList())).toArray(TypeAnnotation[]::new);\n+                        transformAnnotation(ta.annotation()))).toArray(TypeAnnotation[]::new);\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Collections;\n@@ -33,2 +32,1 @@\n-import jdk.jfr.Event;\n-import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.Recording;\n@@ -44,1 +42,1 @@\n- * Test for events: jdk.CodeCacheFull jdk.CompilationFailure\n+ * Test for events: vm\/code_cache\/full vm\/compiler\/failure\n@@ -63,2 +61,0 @@\n-    static class ProvocationEvent extends Event {\n-    }\n@@ -70,2 +66,2 @@\n-    private static final String EVENT_CODE_CACHE_FULL = EventNames.CodeCacheFull;\n-    private static final String EVENT_COMPILATION_FAILURE = EventNames.CompilationFailure;\n+    private static final String pathFull = EventNames.CodeCacheFull;\n+    private static final String pathFailure = EventNames.CompilationFailure;\n@@ -84,24 +80,7 @@\n-        List<RecordedEvent> events = Collections.synchronizedList(new ArrayList<>());\n-        try (RecordingStream rs = new RecordingStream()) {\n-            rs.setReuse(false);\n-            rs.enable(EVENT_CODE_CACHE_FULL);\n-            rs.enable(EVENT_COMPILATION_FAILURE);\n-            rs.onEvent(EVENT_CODE_CACHE_FULL, events::add);\n-            rs.onEvent(EVENT_COMPILATION_FAILURE, events::add);\n-            rs.onEvent(ProvocationEvent.class.getName(), e -> {\n-                if (!events.isEmpty()) {\n-                    rs.close();\n-                    return;\n-                }\n-                \/\/ Retry if CodeCacheFull or CompilationFailure events weren't provoked\n-                try {\n-                    provokeEvents();\n-                } catch (Exception ex) {\n-                    ex.printStackTrace();\n-                    rs.close();\n-                }\n-            });\n-            rs.startAsync();\n-            provokeEvents();\n-            rs.awaitTermination();\n-        }\n+\n+        Recording r = new Recording();\n+        r.enable(pathFull);\n+        r.enable(pathFailure);\n+        r.start();\n+        provokeEvents();\n+        r.stop();\n@@ -111,0 +90,2 @@\n+\n+        List<RecordedEvent> events = Events.fromRecording(r);\n@@ -112,1 +93,1 @@\n-        for (RecordedEvent event : new ArrayList<>(events)) {\n+        for (RecordedEvent event : events) {\n@@ -114,1 +95,1 @@\n-            case EVENT_CODE_CACHE_FULL:\n+            case pathFull:\n@@ -118,1 +99,1 @@\n-            case EVENT_COMPILATION_FAILURE:\n+            case pathFailure:\n@@ -137,2 +118,0 @@\n-        System.out.println(\"provokeEvents()\");\n-        ProvocationEvent provocationEvent = new ProvocationEvent();\n@@ -183,1 +162,0 @@\n-        provocationEvent.commit();\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCodeSweeper.java","additions":16,"deletions":38,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import javax.swing.JApplet;\n@@ -45,2 +44,0 @@\n- *\n- * @author Jeff Dinkins\n@@ -48,1 +45,1 @@\n-public class DemoModule extends JApplet {\n+public class DemoModule extends JPanel {\n@@ -217,5 +214,0 @@\n-    public void init() {\n-        getContentPane().setLayout(new BorderLayout());\n-        getContentPane().add(getDemoPanel(), BorderLayout.CENTER);\n-    }\n-\n@@ -223,1 +215,2 @@\n-}\n\\ No newline at end of file\n+}\n+\n","filename":"test\/jdk\/sanity\/client\/lib\/SwingSet2\/src\/DemoModule.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- *           8331947\n+ *           8331947 8281533\n@@ -159,1 +159,14 @@\n-                    <\/ol>\"\"\");\n+                    <\/ol>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\">Preview feature. Links: <a href=\"CoreRecord.html\" title=\"cla\\\n+                    ss in preview\"><code>CoreRecord<\/code><\/a><sup><a href=\"CoreRecord.html#preview\\\n+                    -preview.CoreRecord\">PREVIEW<\/a><\/sup>, <a href=\"CoreRecord.html\" title=\"class \\\n+                    in preview\"><code>core record<\/code><\/a><sup><a href=\"CoreRecord.html#preview-p\\\n+                    review.CoreRecord\">PREVIEW<\/a><\/sup>,\n+                     <a href=\"CoreRecord.html\" title=\"class in preview\">CoreRecord<\/a>, <a href=\"Co\\\n+                    reRecord.html\" title=\"class in preview\">core record<\/a>.<\/div>\"\"\",\n+                \"\"\"\n+                    <li><a href=\"CoreRecord.html\" title=\"class in preview\"><code>CoreRecord<\/code><\\\n+                    \/a><sup><a href=\"CoreRecord.html#preview-preview.CoreRecord\">PREVIEW<\/a><\/sup><\\\n+                    \/li>\n+                    <li><a href=\"CoreRecord.html\" title=\"class in preview\">core record<\/a><\/li>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPreview\/TestPreview.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+\/**\n+ * Preview feature. Links: {@link CoreRecord}, {@link CoreRecord core record},\n+ * {@linkplain CoreRecord}, {@linkplain CoreRecord core record}.\n+ *\n+ * @see CoreRecord\n+ * @see CoreRecord core record\n+ *\/\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPreview\/api\/preview\/Core.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -606,1 +606,1 @@\n-            boolean matches = checkMatch((Annotation) anno);\n+            boolean matches = checkMatch(anno.annotation());\n@@ -1200,2 +1200,2 @@\n-                    for(Annotation anno : rvattr.annotations()) {\n-                        expected.matchAnnotation(anno);\n+                    for(var anno : rvattr.annotations()) {\n+                        expected.matchAnnotation(anno.annotation());\n","filename":"test\/langtools\/lib\/annotations\/annotations\/classfile\/ClassfileInspector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-            name = annotation.classSymbol().descriptorString();\n+            name = annotation.annotation().classSymbol().descriptorString();\n@@ -230,1 +230,1 @@\n-                annotationValueDebugString(cm, annotation),\n+                annotationValueDebugString(cm, annotation.annotation()),\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/AnonymousClassTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-            tad.annotation = anno.className().stringValue();\n+            tad.annotation = anno.annotation().className().stringValue();\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/ReferenceInfoUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-                    actual.append(ta.className().stringValue() + \" pos: [\" + ta.targetInfo().targetType());\n+                    actual.append(ta.annotation().className().stringValue() + \" pos: [\" + ta.targetInfo().targetType());\n","filename":"test\/langtools\/tools\/javac\/patterns\/Annotations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1618,1 +1618,1 @@\n-        String annotationName = tAnno.classSymbol().displayName();\n+        String annotationName = tAnno.annotation().classSymbol().displayName();\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -324,4 +324,5 @@\n-        String template =\n-            \"FROM %s:%s\\n\" +\n-            \"RUN apt-get install libubsan1\\n\" +\n-            \"COPY \/jdk \/jdk\\n\" +\n+        String template = \"FROM %s:%s\\n\";\n+        if (baseImage.contains(\"ubuntu\") && DockerfileConfig.isUbsan()) {\n+            template += \"RUN apt-get update && apt-get install -y libubsan1\\n\";\n+        }\n+        template = template + \"COPY \/jdk \/jdk\\n\" +\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerTestUtils.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+\n+    public static boolean isUbsan() {\n+        return Boolean.getBoolean(\"jdk.test.docker.image.isUbsan\");\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerfileConfig.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -51,1 +52,2 @@\n-\n+    public Integer integerValue = intValue;\n+    public float floatValue = 156456.36435637F + intValue;\n@@ -53,1 +55,0 @@\n-\n@@ -55,1 +56,0 @@\n-\n@@ -57,1 +57,1 @@\n-\n+    public Boolean booleanValue = Boolean.TRUE;\n@@ -59,1 +59,0 @@\n-\n@@ -62,0 +61,10 @@\n+    @Benchmark\n+    public String concatConstBool() {\n+        return \"string\" + boolValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstBoolean() {\n+        return \"string\" + booleanValue;\n+    }\n+\n@@ -67,0 +76,10 @@\n+    @Benchmark\n+    public String concatConstInteger() {\n+        return \"string\" + integerValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstFloat() {\n+        return \"string\" + floatValue;\n+    }\n+\n@@ -97,0 +116,25 @@\n+    @Benchmark\n+    public String concatConstBoolString() {\n+        return \"string\" + boolValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstBooleanString() {\n+        return \"string\" + booleanValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntString() {\n+        return \"string\" + intValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntegerString() {\n+        return \"string\" + integerValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstFloatString() {\n+        return \"string\" + floatValue + stringValue;\n+    }\n+\n@@ -107,0 +151,30 @@\n+    @Benchmark\n+    public String concatConstStringConst() {\n+        return \"string\" + stringValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntConst() {\n+        return \"string\" + intValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntegerConst() {\n+        return \"string\" + integerValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstFloatConst() {\n+        return \"string\" + floatValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstObjectConst() {\n+        return \"string\" + objectValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstBooleanConst() {\n+        return \"string\" + booleanValue + \"string\";\n+    }\n+\n@@ -117,0 +191,25 @@\n+    @Benchmark\n+    public String concat3String() {\n+        return stringValue + stringValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringBoolString() {\n+        return stringValue + boolValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringBooleanString() {\n+        return stringValue + booleanValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringIntString() {\n+        return stringValue + intValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringIntegerString() {\n+        return stringValue + integerValue + stringValue;\n+    }\n+\n@@ -179,0 +278,9 @@\n+\n+    @Benchmark\n+    public String concat30Mix() {\n+        return f0 + \",\" + f1 + \",\"+ f2 + \",\"+  f3 + \",\"+  f4 + \",\"+  f5 + \",\"+  f6 + \",\"+  f7 + \",\"+  f8 + \",\"+  f9 + \",\"\n+              +f10 + \",\"+f11 + \",\"+f12 + \",\"+ f13 + \",\"+ f14 + \",\"+ f15 + \",\"+ f16 + \",\"+ f17 + \",\"+ f18 + \",\"+ f19 + \",\"\n+              +f20 + \",\"+f21 + \",\"+f22 + \",\" + boolValue + \",\" + booleanValue + \",\" + intValue + \",\" + integerValue\n+              + \",\" + floatValue + \",\" + byteValue + \",\" + objectValue;\n+    }\n+\n@@ -196,0 +304,29 @@\n+    @Benchmark\n+    public String concat13StringConst() {\n+        return f0  + f1  + f2  + f3 + f4\n+             + f5  + f6  + f7  + f8 + f9\n+             +f10 + f11 + f12 + \"\"\"\n+                A really long constant string. Such as a copyright header:\n+                 * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+                 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+                 *\n+                 * This code is free software; you can redistribute it and\/or modify it\n+                 * under the terms of the GNU General Public License version 2 only, as\n+                 * published by the Free Software Foundation.\n+                 *\n+                 * This code is distributed in the hope that it will be useful, but WITHOUT\n+                 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+                 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+                 * version 2 for more details (a copy is included in the LICENSE file that\n+                 * accompanied this code).\n+                 *\n+                 * You should have received a copy of the GNU General Public License version\n+                 * 2 along with this work; if not, write to the Free Software Foundation,\n+                 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+                 *\n+                 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+                 * or visit www.oracle.com if you need additional information or have any\n+                 * questions.\n+                \"\"\";\n+    }\n+\n@@ -198,1 +335,1 @@\n-        return f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + \"\"\"\n+        return f0 + f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8 + f9 + f10 + f11 + f12 + f13 + f14 + f15 + f16 + f17 + f18 + f19 + f20 + f21 + f22 + \"\"\"\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConcat.java","additions":143,"deletions":6,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -47,1 +49,7 @@\n-        String[] selection = new String[] { \"StringLarge\", \"MixedSmall\", \"StringSingle\", \"MixedLarge\" };\n+        String[] selection = {\n+                \"StringLarge\",\n+                \"MixedSmall\",\n+                \"StringSingle\",\n+                \"StringThree\",\n+                \"MixedLarge\"\n+        };\n@@ -53,1 +61,13 @@\n-                case \"StringSingle\" -> new StringSingle().run();\n+                case \"StringSingle\" -> {\n+                    new StringSingle().constInt();\n+                    new StringSingle().constFloat();\n+                    new StringSingle().constString();\n+                    new StringSingle().const2String();\n+                    new StringSingle().constIntString();\n+                    new StringSingle().constFloatString();\n+                    new StringSingle().constBooleanString();\n+                }\n+                case \"StringThree\" -> {\n+                    new StringThree().stringIntString();\n+                    new StringThree().stringIntegerString();\n+                }\n@@ -67,1 +87,7 @@\n-        public String s = \"foo\";\n+        @Param(\"4711\")\n+        public int intValue;\n+        public Integer integerValue = intValue;\n+        public float floatValue = 156456.36435637F + intValue;\n+        public String stringValue = String.valueOf(intValue);\n+        public boolean boolValue = true;\n+        public Boolean booleanValue = Boolean.TRUE;\n@@ -70,2 +96,56 @@\n-        public String run() {\n-            return \"\" + s;\n+        public String constBool() {\n+            return \"string\" + boolValue;\n+        }\n+\n+        @Benchmark\n+        public String constBoolean() {\n+            return \"string\" + booleanValue;\n+        }\n+\n+        @Benchmark\n+        public String constInt() {\n+            return \"string\" + intValue;\n+        }\n+\n+        @Benchmark\n+        public String constInteger() {\n+            return \"string\" + integerValue;\n+        }\n+\n+        @Benchmark\n+        public String constFloat() {\n+            return \"string\" + floatValue;\n+        }\n+\n+        @Benchmark\n+        public String constString() {\n+            return \"string\" + stringValue;\n+        }\n+\n+        public String const2String() {\n+            return \"string\" + stringValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constIntString() {\n+            return \"string\" + intValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constIntegerString() {\n+            return \"string\" + integerValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constFloatString() {\n+            return \"string\" + floatValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constBoolString() {\n+            return \"string\" + boolValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constBooleanString() {\n+            return \"string\" + booleanValue + stringValue;\n@@ -75,0 +155,21 @@\n+    @BenchmarkMode(Mode.SingleShotTime)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    @State(Scope.Thread)\n+    @Fork(value = 40, warmups = 2)\n+    public static class StringThree {\n+\n+        @Param(\"4711\")\n+        public int intValue;\n+        public Integer integerValue = intValue;\n+        public String stringValue = String.valueOf(intValue);\n+\n+        @Benchmark\n+        public String stringIntString() {\n+            return stringValue + intValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String stringIntegerString() {\n+            return stringValue + integerValue + stringValue;\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConcatStartup.java","additions":106,"deletions":5,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -61,0 +61,4 @@\n+            \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/lang\/Object;\",\n+            \"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/String;\",\n+            \"(Ljava\/lang\/Integer;Ljava\/lang\/Integer;)Ljava\/lang\/Integer;\",\n+            \"()Ljava\/lang\/Object;\",\n@@ -64,0 +68,1 @@\n+            \"([III.Z[B..[.[B).\",\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/MethodTypeDescFactories.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -115,7 +115,0 @@\n-\n-    @Benchmark\n-    public void forPrimitiveType(Blackhole bh) throws Throwable {\n-        for (char c : PRIM_TYPES) {\n-            bh.consume(Wrapper.forPrimitiveType(c));\n-        }\n-    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/Wrappers.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    @Param({\"4\"})\n+    @Param({\"4\", \"32\", \"76\", \"128\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/Base64Decode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,0 +63,6 @@\n+    public static void main(String... args) {\n+        FindAny findAny = new FindAny();\n+        findAny.size = 100000;\n+        findAny.seq_invoke();\n+        findAny.par_invoke();\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/FindAny.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -125,0 +125,1 @@\n+                null,\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/CodeAttributeTools.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+    public volatile Object lockObject3Inflated;\n+    public volatile Object lockObject4Inflated;\n@@ -65,0 +67,15 @@\n+        lockObject3Inflated = new Object();\n+        lockObject4Inflated = new Object();\n+\n+        \/\/ Inflate the lock to use an ObjectMonitor\n+        try {\n+          synchronized (lockObject3Inflated) {\n+            lockObject3Inflated.wait(1);\n+          }\n+          synchronized (lockObject4Inflated) {\n+            lockObject4Inflated.wait(1);\n+          }\n+        } catch (InterruptedException e) {\n+          throw new RuntimeException(e);\n+        }\n+\n@@ -71,1 +88,1 @@\n-    public void testSimpleLockUnlock() {\n+    public void testBasicSimpleLockUnlockLocal() {\n@@ -81,0 +98,34 @@\n+    \/** Perform a synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testBasicSimpleLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject1) {\n+                dummyInt1++;\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform a synchronized on a local object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedSimpleLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (localObject) {\n+                dummyInt1++;\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform a synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedSimpleLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n@@ -83,1 +134,1 @@\n-    public void testRecursiveLockUnlock() {\n+    public void testBasicRecursiveLockUnlockLocal() {\n@@ -95,0 +146,13 @@\n+    \/** Perform a recursive synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testBasicRecursiveLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject1) {\n+                synchronized (lockObject1) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n@@ -97,1 +161,1 @@\n-    public void testSerialLockUnlock() {\n+    public void testBasicSerialLockUnlockLocal() {\n@@ -109,0 +173,120 @@\n+  \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testBasicSerialLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject1) {\n+                dummyInt1++;\n+            }\n+            synchronized (lockObject1) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same local object. *\/\n+    @Benchmark\n+    public void testInflatedSerialLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (localObject) {\n+                dummyInt1++;\n+            }\n+            synchronized (localObject) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedSerialLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+            }\n+            synchronized (lockObject3Inflated) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedMultipleSerialLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+            }\n+            synchronized (lockObject4Inflated) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedMultipleRecursiveLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+                synchronized (lockObject4Inflated) {\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+      \/** Perform a recursive-only synchronized on a local object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveOnlyLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        synchronized (localObject) {\n+            for (int i = 0; i < innerCount; i++) {\n+                synchronized (localObject) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Perform a recursive-only synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveOnlyLockUnlock() {\n+        synchronized (lockObject3Inflated) {\n+            for (int i = 0; i < innerCount; i++) {\n+                synchronized (lockObject3Inflated) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Perform a recursive-only synchronized on a local object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (localObject) {\n+                synchronized (localObject) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Perform a recursive-only synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                synchronized (lockObject3Inflated) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/LockUnlock.java","additions":187,"deletions":3,"binary":false,"changes":190,"status":"modified"}]}