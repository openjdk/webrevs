{"files":[{"patch":"@@ -285,2 +285,20 @@\n-  ifneq ($$($1_CLASSPATH), )\n-    $1_FLAGS += -cp $$(call PathList, $$($1_CLASSPATH))\n+  $1_AUGMENTED_CLASSPATH := $$($1_CLASSPATH)\n+  $1_API_TARGET := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_pubapi\n+  $1_API_INTERNAL := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_internalapi\n+\n+  ifeq ($$($1_CREATE_API_DIGEST), true)\n+    $1_API_DIGEST_FLAGS := \\\n+        -Xplugin:\"depend $$($1_API_TARGET)\" \\\n+        \"-XDinternalAPIPath=$$($1_API_INTERNAL)\" \\\n+        \"-XDLOG_LEVEL=$(LOG_LEVEL)\" \\\n+        #\n+\n+    $1_EXTRA_DEPS := $$(BUILDTOOLS_OUTPUTDIR)\/depend\/_the.COMPILE_DEPEND_batch\n+    # including the compilation output on the classpath, so that incremental\n+    # compilations in unnamed module can refer to other classes from the same\n+    # source root, which are not being recompiled in this compilation:\n+    $1_AUGMENTED_CLASSPATH += $$(BUILDTOOLS_OUTPUTDIR)\/depend $$($1_BIN)\n+  endif\n+\n+  ifneq ($$($1_AUGMENTED_CLASSPATH), )\n+    $1_FLAGS += -cp $$(call PathList, $$($1_AUGMENTED_CLASSPATH))\n@@ -414,3 +432,0 @@\n-    $1_API_TARGET := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_pubapi\n-    $1_API_INTERNAL := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_internalapi\n-\n@@ -445,11 +460,0 @@\n-    ifeq ($$($1_CREATE_API_DIGEST), true)\n-      $1_API_DIGEST_FLAGS := \\\n-          -classpath $$(BUILDTOOLS_OUTPUTDIR)\/depend \\\n-          -Xplugin:\"depend $$($1_API_TARGET)\" \\\n-          \"-XDinternalAPIPath=$$($1_API_INTERNAL)\" \\\n-          \"-XDLOG_LEVEL=$(LOG_LEVEL)\" \\\n-          #\n-\n-      $1_EXTRA_DEPS := $$(BUILDTOOLS_OUTPUTDIR)\/depend\/_the.COMPILE_DEPEND_batch\n-    endif\n-\n","filename":"make\/common\/JavaCompilation.gmk","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+    CREATE_API_DIGEST := true, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -295,1 +295,1 @@\n-void Assembler::add(Register d, RegisterOrConstant roc, Register s1) {\n+void Assembler::add(Register d, Register s, RegisterOrConstant roc) {\n@@ -299,1 +299,3 @@\n-    addi(d, s1, (int)c);\n+    addi(d, s, (int)c);\n+  } else {\n+    add(d, s, roc.as_register());\n@@ -301,1 +303,0 @@\n-  else add(d, roc.as_register(), s1);\n@@ -304,1 +305,1 @@\n-void Assembler::subf(Register d, RegisterOrConstant roc, Register s1) {\n+void Assembler::sub(Register d, Register s, RegisterOrConstant roc) {\n@@ -308,1 +309,13 @@\n-    addi(d, s1, (int)-c);\n+    addi(d, s, (int)-c);\n+  } else {\n+    sub(d, s, roc.as_register());\n+  }\n+}\n+\n+void Assembler::xorr(Register d, Register s, RegisterOrConstant roc) {\n+  if (roc.is_constant()) {\n+    intptr_t c = roc.as_constant();\n+    assert(is_uimm(c, 16), \"too big\");\n+    xori(d, s, (int)c);\n+  } else {\n+    xorr(d, s, roc.as_register());\n@@ -310,1 +323,0 @@\n-  else subf(d, roc.as_register(), s1);\n@@ -313,1 +325,1 @@\n-void Assembler::cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1) {\n+void Assembler::cmpw(ConditionRegister d, Register s, RegisterOrConstant roc) {\n@@ -317,1 +329,13 @@\n-    cmpdi(d, s1, (int)c);\n+    cmpwi(d, s, (int)c);\n+  } else {\n+    cmpw(d, s, roc.as_register());\n+  }\n+}\n+\n+void Assembler::cmpd(ConditionRegister d, Register s, RegisterOrConstant roc) {\n+  if (roc.is_constant()) {\n+    intptr_t c = roc.as_constant();\n+    assert(is_simm(c, 16), \"too big\");\n+    cmpdi(d, s, (int)c);\n+  } else {\n+    cmpd(d, s, roc.as_register());\n@@ -319,1 +343,0 @@\n-  else cmpd(d, roc.as_register(), s1);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.cpp","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2515,3 +2515,7 @@\n-  void add( Register d, RegisterOrConstant roc, Register s1);\n-  void subf(Register d, RegisterOrConstant roc, Register s1);\n-  void cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1);\n+  void add( Register d, Register s, RegisterOrConstant roc);\n+  void add( Register d, RegisterOrConstant roc, Register s) { add(d, s, roc); }\n+  void sub( Register d, Register s, RegisterOrConstant roc);\n+  void xorr(Register d, Register s, RegisterOrConstant roc);\n+  void xorr(Register d, RegisterOrConstant roc, Register s) { xorr(d, s, roc); }\n+  void cmpw(ConditionRegister d, Register s, RegisterOrConstant roc);\n+  void cmpd(ConditionRegister d, Register s, RegisterOrConstant roc);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2623,1 +2623,1 @@\n-                noreg, \/*check without ldarx first*\/true);\n+                noreg, nullptr, \/*check without ldarx first*\/true);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -706,1 +706,1 @@\n-                false, success_flag, true);\n+                false, success_flag, nullptr, true);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -338,1 +338,1 @@\n-      __ add(ref_base, ind_or_offs, ref_base);\n+      __ add(ref_base, ref_base, ind_or_offs);\n@@ -346,1 +346,1 @@\n-      __ subf(ref_base, ind_or_offs, ref_base);\n+      __ sub(ref_base, ref_base, ind_or_offs);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1623,1 +1623,1 @@\n-                                       Register compare_value, Register exchange_value,\n+                                       RegisterOrConstant compare_value, Register exchange_value,\n@@ -1637,1 +1637,1 @@\n-    assert_different_registers(tmp1, tmp2, dest_current_value, compare_value, exchange_value, addr_base);\n+    assert_different_registers(tmp1, tmp2, dest_current_value, compare_value.register_or_noreg(), exchange_value, addr_base);\n@@ -1698,1 +1698,1 @@\n-                                     Register compare_value, Register exchange_value,\n+                                     RegisterOrConstant compare_value, Register exchange_value,\n@@ -1700,2 +1700,2 @@\n-                                     int semantics, bool cmpxchgx_hint,\n-                                     Register int_flag_success, bool contention_hint, bool weak, int size) {\n+                                     int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                                     Label* failed_ext, bool contention_hint, bool weak, int size) {\n@@ -1703,1 +1703,2 @@\n-  Label failed;\n+  Label failed_int;\n+  Label& failed = (failed_ext != nullptr) ? *failed_ext : failed_int;\n@@ -1709,1 +1710,1 @@\n-  bool preset_result_reg = (int_flag_success != dest_current_value && int_flag_success != compare_value &&\n+  bool preset_result_reg = (int_flag_success != dest_current_value && int_flag_success != compare_value.register_or_noreg() &&\n@@ -1713,0 +1714,1 @@\n+  assert(int_flag_success == noreg || failed_ext == nullptr, \"cannot have both\");\n@@ -1763,1 +1765,1 @@\n-  bind(failed);\n+  bind(failed_int);\n@@ -1790,4 +1792,5 @@\n-void MacroAssembler::cmpxchgd(ConditionRegister flag,\n-                              Register dest_current_value, RegisterOrConstant compare_value, Register exchange_value,\n-                              Register addr_base, int semantics, bool cmpxchgx_hint,\n-                              Register int_flag_success, Label* failed_ext, bool contention_hint, bool weak) {\n+void MacroAssembler::cmpxchgd(ConditionRegister flag, Register dest_current_value,\n+                              RegisterOrConstant compare_value, Register exchange_value,\n+                              Register addr_base,\n+                              int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                              Label* failed_ext, bool contention_hint, bool weak) {\n@@ -1813,1 +1816,1 @@\n-    cmpd(flag, compare_value, dest_current_value);\n+    cmpd(flag, dest_current_value, compare_value);\n@@ -1826,1 +1829,1 @@\n-  cmpd(flag, compare_value, dest_current_value);\n+  cmpd(flag, dest_current_value, compare_value);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -485,1 +485,1 @@\n-                         Register compare_value, Register exchange_value,\n+                         RegisterOrConstant compare_value, Register exchange_value,\n@@ -488,4 +488,5 @@\n-  void cmpxchg_generic(ConditionRegister flag,\n-                       Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                       Register tmp1, Register tmp2,\n-                       int semantics, bool cmpxchgx_hint, Register int_flag_success, bool contention_hint, bool weak, int size);\n+  void cmpxchg_generic(ConditionRegister flag, Register dest_current_value,\n+                       RegisterOrConstant compare_value, Register exchange_value,\n+                       Register addr_base, Register tmp1, Register tmp2,\n+                       int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                       Label* failed_ext, bool contention_hint, bool weak, int size);\n@@ -531,4 +532,5 @@\n-  void cmpxchgb(ConditionRegister flag,\n-                Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                Register tmp1, Register tmp2, int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, bool contention_hint = false, bool weak = false) {\n+  void cmpxchgb(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base, Register tmp1, Register tmp2,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n@@ -536,1 +538,1 @@\n-                    semantics, cmpxchgx_hint, int_flag_success, contention_hint, weak, 1);\n+                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 1);\n@@ -540,4 +542,5 @@\n-  void cmpxchgh(ConditionRegister flag,\n-                Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                Register tmp1, Register tmp2, int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, bool contention_hint = false, bool weak = false) {\n+  void cmpxchgh(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base, Register tmp1, Register tmp2,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n@@ -545,1 +548,1 @@\n-                    semantics, cmpxchgx_hint, int_flag_success, contention_hint, weak, 2);\n+                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 2);\n@@ -547,4 +550,5 @@\n-  void cmpxchgw(ConditionRegister flag,\n-                Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, bool contention_hint = false, bool weak = false) {\n+  void cmpxchgw(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n@@ -552,1 +556,1 @@\n-                    semantics, cmpxchgx_hint, int_flag_success, contention_hint, weak, 4);\n+                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 4);\n@@ -554,4 +558,5 @@\n-  void cmpxchgd(ConditionRegister flag,\n-                Register dest_current_value, RegisterOrConstant compare_value, Register exchange_value,\n-                Register addr_base, int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, Label* failed = nullptr, bool contention_hint = false, bool weak = false);\n+  void cmpxchgd(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":29,"deletions":24,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -7393,1 +7393,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7412,1 +7412,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7431,1 +7431,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7450,1 +7450,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7468,1 +7468,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7486,1 +7486,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7544,1 +7544,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7558,1 +7558,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7572,1 +7572,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7586,1 +7586,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7600,1 +7600,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7614,1 +7614,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7628,1 +7628,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7642,1 +7642,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7656,1 +7656,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7672,1 +7672,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7686,1 +7686,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7702,1 +7702,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7779,1 +7779,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7793,1 +7793,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7807,1 +7807,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7827,1 +7827,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7847,1 +7847,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7861,1 +7861,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7875,1 +7875,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7895,1 +7895,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7915,1 +7915,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7929,1 +7929,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7949,1 +7949,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7963,1 +7963,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-    __ cmpd(CCR0, R19_method, 0);\n+    __ cmpdi(CCR0, R19_method, 0);\n","filename":"src\/hotspot\/cpu\/ppc\/vtableStubs_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1838,0 +1838,1 @@\n+  INSN(vlseg4e8_v, 0b0000111, 0b000, 0b00000, 0b00, 0b0, g4);\n@@ -1840,0 +1841,1 @@\n+  INSN(vsseg3e8_v, 0b0100111, 0b000, 0b00000, 0b00, 0b0, g3);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-        \/\/ If we patch code we need both a code patching and a loadload\n+        \/\/ If we patch code we need both a cmodx fence and a loadload\n@@ -276,0 +276,1 @@\n+\n@@ -277,4 +278,11 @@\n-        \/\/ Embed an artificial data dependency to order the guard load\n-        \/\/ before the epoch load.\n-        __ srli(ra, t0, 32);\n-        __ orr(t1, t1, ra);\n+        if (!UseZtso) {\n+          \/\/ Embed a synthetic data dependency between the load of the guard and\n+          \/\/ the load of the epoch. This guarantees that these loads occur in\n+          \/\/ order, while allowing other independent instructions to be reordered.\n+          \/\/ Note: This may be slower than using a membar(load|load) (fence r,r).\n+          \/\/ Because processors will not start the second load until the first comes back.\n+          \/\/ This means you can’t overlap the two loads,\n+          \/\/ which is stronger than needed for ordering (stronger than TSO).\n+          __ srli(ra, t0, 32);\n+          __ orr(t1, t1, ra);\n+        }\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -5325,0 +5325,273 @@\n+  \/**\n+   * vector registers:\n+   * input VectorRegister's:  intputV1-V4, for m2 they could be v2, v4, v6, for m1 they could be v2, v4, v6, v8\n+   * index VectorRegister's:  idxV1-V3, for m2 they could be v8, v10, v12, v14, for m1 they could be v10, v12, v14, v16\n+   * output VectorRegister's: outputV1-V4, for m2 they could be v16, v18, v20, v22, for m1 they could be v18, v20, v22\n+   *\n+   * NOTE: each field will occupy a single vector register group\n+   *\/\n+  void base64_vector_decode_round(Register src, Register dst, Register codec,\n+                    Register size, Register stepSrc, Register stepDst, Register failedIdx, Register minusOne,\n+                    VectorRegister inputV1, VectorRegister inputV2, VectorRegister inputV3, VectorRegister inputV4,\n+                    VectorRegister idxV1, VectorRegister idxV2, VectorRegister idxV3, VectorRegister idxV4,\n+                    VectorRegister outputV1, VectorRegister outputV2, VectorRegister outputV3,\n+                    Assembler::LMUL lmul) {\n+    \/\/ set vector register type\/len\n+    __ vsetvli(x0, size, Assembler::e8, lmul, Assembler::ma, Assembler::ta);\n+\n+    \/\/ segmented load src into v registers: mem(src) => vr(4)\n+    __ vlseg4e8_v(inputV1, src);\n+\n+    \/\/ src = src + register_group_len_bytes * 4\n+    __ add(src, src, stepSrc);\n+\n+    \/\/ decoding\n+    \/\/   1. indexed load: vr(4) => vr(4)\n+    __ vluxei8_v(idxV1, codec, inputV1);\n+    __ vluxei8_v(idxV2, codec, inputV2);\n+    __ vluxei8_v(idxV3, codec, inputV3);\n+    __ vluxei8_v(idxV4, codec, inputV4);\n+\n+    \/\/   2. check wrong data\n+    __ vor_vv(outputV1, idxV1, idxV2);\n+    __ vor_vv(outputV2, idxV3, idxV4);\n+    __ vor_vv(outputV1, outputV1, outputV2);\n+    __ vmseq_vi(v0, outputV1, -1);\n+    __ vfirst_m(failedIdx, v0);\n+    Label NoFailure;\n+    __ beq(failedIdx, minusOne, NoFailure);\n+    __ vsetvli(x0, failedIdx, Assembler::e8, lmul, Assembler::mu, Assembler::tu);\n+    __ slli(stepDst, failedIdx, 1);\n+    __ add(stepDst, failedIdx, stepDst);\n+    __ BIND(NoFailure);\n+\n+    \/\/   3. compute the decoded data: vr(4) => vr(3)\n+    __ vsll_vi(idxV1, idxV1, 2);\n+    __ vsrl_vi(outputV1, idxV2, 4);\n+    __ vor_vv(outputV1, outputV1, idxV1);\n+\n+    __ vsll_vi(idxV2, idxV2, 4);\n+    __ vsrl_vi(outputV2, idxV3, 2);\n+    __ vor_vv(outputV2, outputV2, idxV2);\n+\n+    __ vsll_vi(idxV3, idxV3, 6);\n+    __ vor_vv(outputV3, idxV4, idxV3);\n+\n+    \/\/ segmented store encoded data in v registers back to dst: vr(3) => mem(dst)\n+    __ vsseg3e8_v(outputV1, dst);\n+\n+    \/\/ dst = dst + register_group_len_bytes * 3\n+    __ add(dst, dst, stepDst);\n+  }\n+\n+  \/**\n+   * int j.u.Base64.Decoder.decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL, boolean isMIME)\n+   *\n+   *  Input arguments:\n+   *  c_rarg0   - src, source array\n+   *  c_rarg1   - sp, src start offset\n+   *  c_rarg2   - sl, src end offset\n+   *  c_rarg3   - dst, dest array\n+   *  c_rarg4   - dp, dst start offset\n+   *  c_rarg5   - isURL, Base64 or URL character set\n+   *  c_rarg6   - isMIME, Decoding MIME block\n+   *\/\n+  address generate_base64_decodeBlock() {\n+\n+    static const uint8_t fromBase64[256] = {\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u, 255u,  63u,\n+        52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+        15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u, 255u,\n+        255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+        41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    static const uint8_t fromBase64URL[256] = {\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u,\n+        52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+        15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,  63u,\n+        255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+        41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"decodeBlock\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    Register src    = c_rarg0;\n+    Register soff   = c_rarg1;\n+    Register send   = c_rarg2;\n+    Register dst    = c_rarg3;\n+    Register doff   = c_rarg4;\n+    Register isURL  = c_rarg5;\n+    Register isMIME = c_rarg6;\n+\n+    Register codec     = c_rarg7;\n+    Register dstBackup = x31;\n+    Register length    = x28;     \/\/ t3, total length of src data in bytes\n+\n+    Label ProcessData, Exit;\n+    Label ProcessScalar, ScalarLoop;\n+\n+    \/\/ passed in length (send - soff) is guaranteed to be > 4,\n+    \/\/ and in this intrinsic we only process data of length in multiple of 4,\n+    \/\/ it's not guaranteed to be multiple of 4 by java level, so do it explicitly\n+    __ sub(length, send, soff);\n+    __ andi(length, length, -4);\n+    \/\/ real src\/dst to process data\n+    __ add(src, src, soff);\n+    __ add(dst, dst, doff);\n+    \/\/ backup of dst, used to calculate the return value at exit\n+    __ mv(dstBackup, dst);\n+\n+    \/\/ load the codec base address\n+    __ la(codec, ExternalAddress((address) fromBase64));\n+    __ beqz(isURL, ProcessData);\n+    __ la(codec, ExternalAddress((address) fromBase64URL));\n+    __ BIND(ProcessData);\n+\n+    \/\/ vector version\n+    if (UseRVV) {\n+      \/\/ for MIME case, it has a default length limit of 76 which could be\n+      \/\/ different(smaller) from (send - soff), so in MIME case, we go through\n+      \/\/ the scalar code path directly.\n+      __ bnez(isMIME, ScalarLoop);\n+\n+      Label ProcessM1, ProcessM2;\n+\n+      Register failedIdx = soff;\n+      Register stepSrcM1 = send;\n+      Register stepSrcM2 = doff;\n+      Register stepDst   = isURL;\n+      Register size      = x29;   \/\/ t4\n+      Register minusOne  = x30;   \/\/ t5\n+\n+      __ mv(minusOne, -1);\n+      __ mv(size, MaxVectorSize * 2);\n+      __ mv(stepSrcM1, MaxVectorSize * 4);\n+      __ slli(stepSrcM2, stepSrcM1, 1);\n+      __ mv(stepDst, MaxVectorSize * 2 * 3);\n+\n+      __ blt(length, stepSrcM2, ProcessM1);\n+\n+\n+      \/\/ Assembler::m2\n+      __ BIND(ProcessM2);\n+      base64_vector_decode_round(src, dst, codec,\n+                    size, stepSrcM2, stepDst, failedIdx, minusOne,\n+                    v2, v4, v6, v8,      \/\/ inputs\n+                    v10, v12, v14, v16,  \/\/ indexes\n+                    v18, v20, v22,       \/\/ outputs\n+                    Assembler::m2);\n+      __ sub(length, length, stepSrcM2);\n+\n+      \/\/ error check\n+      __ bne(failedIdx, minusOne, Exit);\n+\n+      __ bge(length, stepSrcM2, ProcessM2);\n+\n+\n+      \/\/ Assembler::m1\n+      __ BIND(ProcessM1);\n+      __ blt(length, stepSrcM1, ProcessScalar);\n+\n+      __ srli(size, size, 1);\n+      __ srli(stepDst, stepDst, 1);\n+      base64_vector_decode_round(src, dst, codec,\n+                    size, stepSrcM1, stepDst, failedIdx, minusOne,\n+                    v1, v2, v3, v4,      \/\/ inputs\n+                    v5, v6, v7, v8,      \/\/ indexes\n+                    v9, v10, v11,        \/\/ outputs\n+                    Assembler::m1);\n+      __ sub(length, length, stepSrcM1);\n+\n+      \/\/ error check\n+      __ bne(failedIdx, minusOne, Exit);\n+\n+      __ BIND(ProcessScalar);\n+      __ beqz(length, Exit);\n+    }\n+\n+    \/\/ scalar version\n+    {\n+      Register byte0 = soff, byte1 = send, byte2 = doff, byte3 = isURL;\n+      Register combined32Bits = x29; \/\/ t5\n+\n+      \/\/ encoded:   [byte0[5:0] : byte1[5:0] : byte2[5:0]] : byte3[5:0]] =>\n+      \/\/ plain:     [byte0[5:0]+byte1[5:4] : byte1[3:0]+byte2[5:2] : byte2[1:0]+byte3[5:0]]\n+      __ BIND(ScalarLoop);\n+\n+      \/\/ load 4 bytes encoded src data\n+      __ lbu(byte0, Address(src, 0));\n+      __ lbu(byte1, Address(src, 1));\n+      __ lbu(byte2, Address(src, 2));\n+      __ lbu(byte3, Address(src, 3));\n+      __ addi(src, src, 4);\n+\n+      \/\/ get codec index and decode (ie. load from codec by index)\n+      __ add(byte0, codec, byte0);\n+      __ add(byte1, codec, byte1);\n+      __ lb(byte0, Address(byte0, 0));\n+      __ lb(byte1, Address(byte1, 0));\n+      __ add(byte2, codec, byte2);\n+      __ add(byte3, codec, byte3);\n+      __ lb(byte2, Address(byte2, 0));\n+      __ lb(byte3, Address(byte3, 0));\n+      __ slliw(byte0, byte0, 18);\n+      __ slliw(byte1, byte1, 12);\n+      __ orr(byte0, byte0, byte1);\n+      __ orr(byte0, byte0, byte3);\n+      __ slliw(byte2, byte2, 6);\n+      \/\/ For performance consideration, `combined32Bits` is constructed for 2 purposes at the same time,\n+      \/\/  1. error check below\n+      \/\/  2. decode below\n+      __ orr(combined32Bits, byte0, byte2);\n+\n+      \/\/ error check\n+      __ bltz(combined32Bits, Exit);\n+\n+      \/\/ store 3 bytes decoded data\n+      __ sraiw(byte0, combined32Bits, 16);\n+      __ sraiw(byte1, combined32Bits, 8);\n+      __ sb(byte0, Address(dst, 0));\n+      __ sb(byte1, Address(dst, 1));\n+      __ sb(combined32Bits, Address(dst, 2));\n+\n+      __ sub(length, length, 4);\n+      __ addi(dst, dst, 3);\n+      \/\/ loop back\n+      __ bnez(length, ScalarLoop);\n+    }\n+\n+    __ BIND(Exit);\n+    __ sub(c_rarg0, dst, dstBackup);\n+\n+    __ leave();\n+    __ ret();\n+\n+    return (address) start;\n+  }\n+\n@@ -5983,0 +6256,1 @@\n+      StubRoutines::_base64_decodeBlock = generate_base64_decodeBlock();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":274,"deletions":0,"binary":false,"changes":274,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-  \/*  NB: The default value of UseLinuxPosixThreadCPUClocks may be   *\/ \\\n-  \/* overridden in Arguments::parse_each_vm_init_arg.                *\/ \\\n@@ -44,1 +42,1 @@\n-          \"enable fast Linux Posix clocks where available\")             \\\n+          \"(Deprecated) enable fast Linux Posix clocks where available\") \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-    _snprintf(msg, sizeof(msg), \"%d\\n\", result);\n+    os::snprintf(msg, sizeof(msg), \"%d\\n\", result);\n","filename":"src\/hotspot\/os\/windows\/attachListener_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1779,3 +1779,3 @@\n-    ::_snprintf(ebuf, ebuflen - 1,\n-                \"Can't load %s-bit .dll on a %s-bit platform\",\n-                lib_arch_str, running_arch_str);\n+    os::snprintf(ebuf, ebuflen - 1,\n+                 \"Can't load %s-bit .dll on a %s-bit platform\",\n+                 lib_arch_str, running_arch_str);\n@@ -1784,3 +1784,3 @@\n-    ::_snprintf(ebuf, ebuflen - 1,\n-                \"Can't load this .dll (machine code=0x%x) on a %s-bit platform\",\n-                lib_arch, running_arch_str);\n+    os::snprintf(ebuf, ebuflen - 1,\n+                 \"Can't load this .dll (machine code=0x%x) on a %s-bit platform\",\n+                 lib_arch, running_arch_str);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,1 @@\n-  _snprintf(dirname, nbytes, \"%s\\\\%s_%s\", tmpdir, perfdir, user);\n+  os::snprintf(dirname, nbytes, \"%s\\\\%s_%s\", tmpdir, perfdir, user);\n@@ -458,1 +458,1 @@\n-  _snprintf(name, nbytes, \"%s_%s_%u\", PERFDATA_NAME, user, vmid);\n+  os::snprintf(name, nbytes, \"%s_%s_%u\", PERFDATA_NAME, user, vmid);\n@@ -474,1 +474,1 @@\n-  _snprintf(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n+  os::snprintf(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n","filename":"src\/hotspot\/os\/windows\/perfMemory_windows.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2119,1 +2119,1 @@\n-    assert(!target->can_be_statically_bound() || target == cha_monomorphic_target, \"\");\n+    assert(!target->can_be_statically_bound() || target->equals(cha_monomorphic_target), \"\");\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -784,0 +784,16 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciMethod::equals\n+\/\/\n+\/\/ Returns true if the methods are the same, taking redefined methods\n+\/\/ into account.\n+bool ciMethod::equals(const ciMethod* m) const {\n+  if (this == m) return true;\n+  VM_ENTRY_MARK;\n+  Method* m1 = this->get_Method();\n+  Method* m2 = m->get_Method();\n+  if (m1->is_old()) m1 = m1->get_new_method();\n+  if (m2->is_old()) m2 = m2->get_new_method();\n+  return m1 == m2;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -369,0 +369,2 @@\n+  bool equals(const ciMethod* m) const;\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,1 +264,2 @@\n-  if ((int)strlen(name) > Symbol::max_length()) {\n+  size_t name_len = strlen(name);\n+  if (name_len > static_cast<size_t>(Symbol::max_length())) {\n@@ -266,5 +267,18 @@\n-    \/\/ into the constant pool.\n-    Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n-                       \"Class name exceeds maximum length of %d: %s\",\n-                       Symbol::max_length(),\n-                       name);\n+    \/\/ into the constant pool. If necessary report an abridged name\n+    \/\/ in the exception message.\n+    if (name_len > static_cast<size_t>(MaxStringPrintSize)) {\n+      Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n+                         \"Class name exceeds maximum length of %d: %.*s ... (%zu characters omitted) ... %.*s\",\n+                         Symbol::max_length(),\n+                         MaxStringPrintSize \/ 2,\n+                         name,\n+                         name_len - 2 * (MaxStringPrintSize \/ 2), \/\/ allows for odd value\n+                         MaxStringPrintSize \/ 2,\n+                         name + name_len - MaxStringPrintSize \/ 2);\n+    }\n+    else {\n+      Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n+                         \"Class name exceeds maximum length of %d: %s\",\n+                         Symbol::max_length(),\n+                         name);\n+    }\n@@ -274,1 +288,2 @@\n-  assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false),\n+  assert(UTF8::is_legal_utf8((const unsigned char*)name,\n+                             static_cast<int>(name_len), false),\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -41,0 +42,21 @@\n+\/\/ GCLockerTimingDebugLogger tracks specific timing information for GC lock waits.\n+class GCLockerTimingDebugLogger : public StackObj {\n+  const char* _log_message;\n+  Ticks _start;\n+\n+public:\n+  GCLockerTimingDebugLogger(const char* log_message) : _log_message(log_message) {\n+    assert(_log_message != nullptr, \"GC locker debug message must be set.\");\n+    _start = Ticks::now();\n+  }\n+\n+  ~GCLockerTimingDebugLogger() {\n+    Log(gc, jni) log;\n+    if (log.is_debug()) {\n+      ResourceMark rm; \/\/ JavaThread::name() allocates to convert to UTF8\n+      const Tickspan elapsed_time = Ticks::now() - _start;\n+      log.debug(\"%s Resumed after \" UINT64_FORMAT \"ms. Thread \\\"%s\\\".\", _log_message, elapsed_time.milliseconds(), Thread::current()->name());\n+    }\n+  }\n+};\n+\n@@ -113,5 +135,5 @@\n-  }\n-\n-  \/\/ Wait for _needs_gc  to be cleared\n-  while (needs_gc()) {\n-    ml.wait();\n+    GCLockerTimingDebugLogger logger(\"Thread stalled by JNI critical section.\");\n+    \/\/ Wait for _needs_gc to be cleared\n+    while (needs_gc()) {\n+      ml.wait();\n+    }\n@@ -130,10 +152,14 @@\n-  while (needs_gc()) {\n-    \/\/ There's at least one thread that has not left the critical region (CR)\n-    \/\/ completely. When that last thread (no new threads can enter CR due to the\n-    \/\/ blocking) exits CR, it calls `jni_unlock`, which sets `_needs_gc`\n-    \/\/ to false and wakes up all blocked threads.\n-    \/\/ We would like to assert #threads in CR to be > 0, `_jni_lock_count > 0`\n-    \/\/ in the code, but it's too strong; it's possible that the last thread\n-    \/\/ has called `jni_unlock`, but not yet finished the call, e.g. initiating\n-    \/\/ a GCCause::_gc_locker GC.\n-    ml.wait();\n+  if (needs_gc()) {\n+    log_debug_jni(\"Blocking thread as there is a pending GC request\");\n+    GCLockerTimingDebugLogger logger(\"Thread blocked to enter critical region.\");\n+    while (needs_gc()) {\n+      \/\/ There's at least one thread that has not left the critical region (CR)\n+      \/\/ completely. When that last thread (no new threads can enter CR due to the\n+      \/\/ blocking) exits CR, it calls `jni_unlock`, which sets `_needs_gc`\n+      \/\/ to false and wakes up all blocked threads.\n+      \/\/ We would like to assert #threads in CR to be > 0, `_jni_lock_count > 0`\n+      \/\/ in the code, but it's too strong; it's possible that the last thread\n+      \/\/ has called `jni_unlock`, but not yet finished the call, e.g. initiating\n+      \/\/ a GCCause::_gc_locker GC.\n+      ml.wait();\n+    }\n@@ -151,0 +177,1 @@\n+  log_debug_jni(\"Thread exiting critical region.\");\n@@ -164,1 +191,1 @@\n-      log_debug_jni(\"Performing GC after exiting critical section.\");\n+      log_debug_jni(\"Last thread exiting. Performing GC after exiting critical section.\");\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":43,"deletions":16,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-jboolean JNICALL jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size);\n+void JNICALL jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -29,2 +29,1 @@\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/klass.hpp\"\n@@ -203,1 +202,1 @@\n-  return mark((uintptr_t)sym->identity_hash(), sym, leakp);\n+  return mark(sym->identity_hash(), sym, leakp);\n@@ -239,35 +238,8 @@\n-* hidden classes symbol is the external name +\n-* the address of its InstanceKlass slash appended:\n-*   java.lang.invoke.LambdaForm$BMH\/22626602\n-*\n-* caller needs ResourceMark\n-*\/\n-\n-uintptr_t JfrSymbolTable::hidden_klass_name_hash(const InstanceKlass* ik) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != nullptr, \"invariant\");\n-  return (uintptr_t)mirror->identity_hash();\n-}\n-\n-static const char* create_hidden_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  assert(hash != 0, \"invariant\");\n-  char* hidden_symbol = nullptr;\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != nullptr, \"invariant\");\n-  char hash_buf[40];\n-  os::snprintf_checked(hash_buf, sizeof(hash_buf), \"\/\" UINTX_FORMAT, hash);\n-  const size_t hash_len = strlen(hash_buf);\n-  const size_t result_len = ik->name()->utf8_length();\n-  hidden_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);\n-  ik->name()->as_klass_external_name(hidden_symbol, (int)result_len + 1);\n-  assert(strlen(hidden_symbol) == result_len, \"invariant\");\n-  strcpy(hidden_symbol + result_len, hash_buf);\n-  assert(strlen(hidden_symbol) == result_len + hash_len, \"invariant\");\n-  return hidden_symbol;\n-}\n-\n-bool JfrSymbolTable::is_hidden_klass(const Klass* k) {\n+ * The hidden class symbol is the external name with the\n+ * address of its Klass slash appended.\n+ *\n+ * \"java.lang.invoke.LambdaForm$DMH\/0x0000000037144c00\"\n+ *\n+ * Caller needs ResourceMark.\n+ *\/\n+traceid JfrSymbolTable::mark_hidden_klass_name(const Klass* k, bool leakp) {\n@@ -275,9 +247,3 @@\n-  return k->is_instance_klass() && ((const InstanceKlass*)k)->is_hidden();\n-}\n-\n-traceid JfrSymbolTable::mark_hidden_klass_name(const InstanceKlass* ik, bool leakp) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const uintptr_t hash = hidden_klass_name_hash(ik);\n-  const char* const hidden_symbol = create_hidden_klass_symbol(ik, hash);\n-  return mark(hash, hidden_symbol, leakp);\n+  assert(k->is_hidden(), \"invariant\");\n+  const uintptr_t hash = k->name()->identity_hash();\n+  return mark(hash, k->external_name(), leakp);\n@@ -289,3 +255,2 @@\n-  if (is_hidden_klass(k)) {\n-    assert(k->is_instance_klass(), \"invariant\");\n-    symbol_id = mark_hidden_klass_name((const InstanceKlass*)k, leakp);\n+  if (k->is_hidden()) {\n+    symbol_id = mark_hidden_klass_name(k, leakp);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.cpp","additions":17,"deletions":52,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,1 @@\n+  traceid mark_hidden_klass_name(const Klass* k, bool leakp);\n@@ -109,4 +110,0 @@\n-  traceid mark_hidden_klass_name(const InstanceKlass* k, bool leakp);\n-  bool is_hidden_klass(const Klass* k);\n-  uintptr_t hidden_klass_name_hash(const InstanceKlass* ik);\n-\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size, bool is_class) {\n+void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size) {\n@@ -135,1 +135,2 @@\n-  if (Metaspace::using_class_space() && is_class) {\n+  const bool is_class = Metaspace::using_class_space() && Metaspace::is_in_class_space(ptr);\n+  if (is_class) {\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-  void deallocate(MetaWord* ptr, size_t word_size, bool is_class);\n+  void deallocate(MetaWord* ptr, size_t word_size);\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-      loader_data->metaspace_non_null()->deallocate((MetaWord*)data, size, false);\n+      loader_data->metaspace_non_null()->deallocate((MetaWord*)data, size);\n@@ -71,1 +71,0 @@\n-      bool is_klass = md->is_klass();\n@@ -79,1 +78,1 @@\n-      loader_data->metaspace_non_null()->deallocate((MetaWord*)md, size, is_klass);\n+      loader_data->metaspace_non_null()->deallocate((MetaWord*)md, size);\n","filename":"src\/hotspot\/share\/memory\/metadataFactory.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -541,0 +541,2 @@\n+const void* Metaspace::_class_space_start = nullptr;\n+const void* Metaspace::_class_space_end = nullptr;\n@@ -573,0 +575,2 @@\n+  _class_space_start = rs.base();\n+  _class_space_end = rs.end();\n@@ -982,6 +986,0 @@\n-bool Metaspace::contains(const void* ptr) {\n-  if (MetaspaceShared::is_in_shared_metaspace(ptr)) {\n-    return true;\n-  }\n-  return contains_non_shared(ptr);\n-}\n@@ -989,4 +987,5 @@\n-bool Metaspace::contains_non_shared(const void* ptr) {\n-  if (using_class_space() && VirtualSpaceList::vslist_class()->contains((MetaWord*)ptr)) {\n-     return true;\n-  }\n+\/\/ Returns true if pointer points into one of the metaspace regions, or\n+\/\/ into the class space.\n+bool Metaspace::is_in_shared_metaspace(const void* ptr) {\n+  return MetaspaceShared::is_in_shared_metaspace(ptr);\n+}\n@@ -994,0 +993,2 @@\n+\/\/ Returns true if pointer points into one of the non-class-space metaspace regions.\n+bool Metaspace::is_in_nonclass_metaspace(const void* ptr) {\n@@ -996,0 +997,1 @@\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,4 @@\n+  \/\/ For quick pointer testing: extent of class space; nullptr if no class space.\n+  static const void* _class_space_start;\n+  static const void* _class_space_end;\n+\n@@ -116,2 +120,26 @@\n-  static bool contains(const void* ptr);\n-  static bool contains_non_shared(const void* ptr);\n+  \/\/ Returns true if the pointer points into class space, non-class metaspace, or the\n+  \/\/ metadata portion of the CDS archive.\n+  static bool contains(const void* ptr) {\n+    return is_in_shared_metaspace(ptr) || \/\/ in cds\n+           is_in_class_space(ptr) ||      \/\/ in class space\n+           is_in_nonclass_metaspace(ptr); \/\/ in one of the non-class regions?\n+  }\n+\n+  \/\/ Returns true if the pointer points into class space or into non-class metaspace\n+  static bool contains_non_shared(const void* ptr) {\n+    return is_in_class_space(ptr) ||      \/\/ in class space\n+           is_in_nonclass_metaspace(ptr); \/\/ in one of the non-class regions?\n+  }\n+\n+  \/\/ Returns true if pointer points into the CDS klass region.\n+  static bool is_in_shared_metaspace(const void* ptr);\n+\n+  \/\/ Returns true if pointer points into one of the non-class-space metaspace regions.\n+  static bool is_in_nonclass_metaspace(const void* ptr);\n+\n+  \/\/ Returns true if pointer points into class space, false if it doesn't or if\n+  \/\/ there is no class space. Class space is a contiguous region, which is why\n+  \/\/ two address comparisons are enough.\n+  static inline bool is_in_class_space(const void* ptr) {\n+    return ptr < _class_space_end && ptr >= _class_space_start;\n+  }\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-    f.print_value_on(_st, nullptr);\n+    f.print_value_on(_st);\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1626,17 +1626,0 @@\n-  \/\/ Change ((x & m) u<= m) or ((m & x) u<= m) to always true\n-  \/\/ Same with ((x & m) u< m+1) and ((m & x) u< m+1)\n-  if (cop == Op_CmpU &&\n-      cmp1_op == Op_AndI) {\n-    Node* bound = nullptr;\n-    if (_test._test == BoolTest::le) {\n-      bound = cmp2;\n-    } else if (_test._test == BoolTest::lt &&\n-               cmp2->Opcode() == Op_AddI &&\n-               cmp2->in(2)->find_int_con(0) == 1) {\n-      bound = cmp2->in(1);\n-    }\n-    if (cmp1->in(2) == bound || cmp1->in(1) == bound) {\n-      return ConINode::make(1);\n-    }\n-  }\n-\n@@ -1644,1 +1627,1 @@\n-  \/\/ This is the off-by-one variant of the above\n+  \/\/ This is the off-by-one variant of ((x & m) u<= m)\n@@ -1830,0 +1813,25 @@\n+\/\/ Change ((x & m) u<= m) or ((m & x) u<= m) to always true\n+\/\/ Same with ((x & m) u< m+1) and ((m & x) u< m+1)\n+const Type* BoolNode::Value_cmpu_and_mask(PhaseValues* phase) const {\n+  Node* cmp = in(1);\n+  if (cmp != nullptr && cmp->Opcode() == Op_CmpU) {\n+    Node* cmp1 = cmp->in(1);\n+    Node* cmp2 = cmp->in(2);\n+\n+    if (cmp1->Opcode() == Op_AndI) {\n+      Node* bound = nullptr;\n+      if (_test._test == BoolTest::le) {\n+        bound = cmp2;\n+      } else if (_test._test == BoolTest::lt && cmp2->Opcode() == Op_AddI && cmp2->in(2)->find_int_con(0) == 1) {\n+        bound = cmp2->in(1);\n+      }\n+\n+      if (cmp1->in(2) == bound || cmp1->in(1) == bound) {\n+        return TypeInt::ONE;\n+      }\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n@@ -1833,0 +1841,5 @@\n+  const Type* t = Value_cmpu_and_mask(phase);\n+  if (t != nullptr) {\n+    return t;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":32,"deletions":19,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -350,0 +350,1 @@\n+  const Type* Value_cmpu_and_mask(PhaseValues* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2586,1 +2586,1 @@\n-      current_frame->print_value_on(&st, nullptr);\n+      current_frame->print_value_on(&st);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -509,0 +509,3 @@\n+#ifdef LINUX\n+  { \"UseLinuxPosixThreadCPUClocks\", JDK_Version::jdk(24), JDK_Version::jdk(25), JDK_Version::jdk(26) },\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -880,1 +880,1 @@\n-    f.print_value_on(&ls, nullptr);\n+    f.print_value_on(&ls);\n@@ -889,1 +889,1 @@\n-    DEBUG_ONLY(hf.print_value_on(&ls, nullptr);)\n+    DEBUG_ONLY(hf.print_value_on(&ls);)\n@@ -2030,1 +2030,1 @@\n-    heap_frame.print_value_on(&ls, nullptr);\n+    heap_frame.print_value_on(&ls);\n@@ -2127,1 +2127,1 @@\n-    hf.print_value_on(&ls, nullptr);\n+    hf.print_value_on(&ls);\n@@ -2397,1 +2397,1 @@\n-    _cont.last_frame().print_value_on(&ls, nullptr);\n+    _cont.last_frame().print_value_on(&ls);\n@@ -2409,1 +2409,1 @@\n-    f.print_value_on(&ls, nullptr);\n+    f.print_value_on(&ls);\n@@ -2470,1 +2470,1 @@\n-    frame(sp).print_value_on(&ls, nullptr);\n+    frame(sp).print_value_on(&ls);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -514,1 +514,1 @@\n-void frame::print_value_on(outputStream* st, JavaThread *thread) const {\n+void frame::print_value_on(outputStream* st) const {\n@@ -553,1 +553,1 @@\n-  print_value_on(st,nullptr);\n+  print_value_on(st);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -436,2 +436,2 @@\n-  void print_value() const { print_value_on(tty,nullptr); }\n-  void print_value_on(outputStream* st, JavaThread *thread) const;\n+  void print_value() const { print_value_on(tty); }\n+  void print_value_on(outputStream* st) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1909,1 +1909,1 @@\n-    fst.current()->print_value_on(tty, this);\n+    fst.current()->print_value_on(tty);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -625,1 +625,1 @@\n-  if (WizardMode) _fr.print_value_on(output, nullptr);\n+  if (WizardMode) _fr.print_value_on(output);\n@@ -740,1 +740,1 @@\n-  _fr.print_value_on(output, nullptr);\n+  _fr.print_value_on(output);\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -577,1 +577,3 @@\n-     * Otherwise, the returned method handle throws {@link IndexOutOfBoundsException}.\n+     * Otherwise, the returned method handle throws {@link IndexOutOfBoundsException}. Moreover,\n+     * the value of {@code b} must be such that the computation for {@code offset} does not overflow,\n+     * or the returned method handle throws {@link ArithmeticException}.\n@@ -667,3 +669,4 @@\n-     * {@code P} and {@code P'} are derived, where P contains all the path elements from\n-     * 0 to {@code k - 1} and {@code P'} contains all the path elements from {@code k + 1}\n-     * to {@code m} (if any). Then, the returned var handle is computed as follows:\n+     * {@code P} and {@code Q} are derived, where P contains all the path elements from\n+     * 0 to {@code k - 1} and {@code Q} contains all the path elements from {@code k + 1}\n+     * to {@code m} ({@code Q} could be an empty layout path if {@code k == m}).\n+     * Then, the returned var handle is computed as follows:\n@@ -674,1 +677,1 @@\n-     * VarHandle targetHandle = target.varHandle(P);\n+     * VarHandle targetHandle = target.varHandle(Q);\n@@ -947,1 +950,1 @@\n-         *    <li>if {@code F < 0}, then {@code B = ceilDiv(-(S + 1), -F)}<\/li>\n+         *    <li>if {@code F < 0}, then {@code B = ceilDiv(S + 1, -F)}<\/li>\n@@ -975,2 +978,2 @@\n-         * {@return a path element that dereferences an address layout as its\n-         * {@linkplain AddressLayout#targetLayout() target layout} (where set)}\n+         * {@return a path element that selects the {@linkplain AddressLayout#targetLayout() target layout} of\n+         * an address layout (where set)}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n- *       ptr = z.reinterpret(16, arena, null);                       \/\/ size = 4, scope = arena.scope()\n+ *       ptr = z.reinterpret(16, arena, null);                       \/\/ size = 16, scope = arena.scope()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -655,1 +655,0 @@\n-                val = getNumberValue(number, divisor);\n@@ -657,0 +656,3 @@\n+            roundedNumber = roundedNumber \/ divisor;\n+            decimalFormat.setDigitList(roundedNumber, isNegative, getMaximumFractionDigits());\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -663,2 +665,0 @@\n-                    roundedNumber = roundedNumber \/ divisor;\n-                    decimalFormat.setDigitList(roundedNumber, isNegative, getMaximumFractionDigits());\n@@ -737,1 +737,0 @@\n-                val = getNumberValue(number, divisor);\n@@ -739,0 +738,12 @@\n+            var noFraction = number % divisor == 0;\n+            if (noFraction) {\n+                number = number \/ divisor;\n+                decimalFormat.setDigitList(number, isNegative, 0);\n+            } else {\n+                \/\/ To avoid truncation of fractional part store\n+                \/\/ the value in double and follow double path instead of\n+                \/\/ long path\n+                double dNumber = (double) number \/ divisor;\n+                decimalFormat.setDigitList(dNumber, isNegative, getMaximumFractionDigits());\n+            }\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -744,18 +755,4 @@\n-                    if ((number % divisor == 0)) {\n-                        number = number \/ divisor;\n-                        decimalFormat.setDigitList(number, isNegative, 0);\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, true, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    } else {\n-                        \/\/ To avoid truncation of fractional part store\n-                        \/\/ the value in double and follow double path instead of\n-                        \/\/ long path\n-                        double dNumber = (double) number \/ divisor;\n-                        decimalFormat.setDigitList(dNumber, isNegative, getMaximumFractionDigits());\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, false, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    }\n+                    decimalFormat.subformatNumber(result, delegate,\n+                            isNegative, noFraction, getMaximumIntegerDigits(),\n+                            getMinimumIntegerDigits(), getMaximumFractionDigits(),\n+                            getMinimumFractionDigits());\n@@ -836,1 +833,0 @@\n-                val = getNumberValue(number.doubleValue(), divisor.doubleValue());\n@@ -838,0 +834,3 @@\n+            number = number.divide(new BigDecimal(divisor.toString()), getRoundingMode());\n+            decimalFormat.setDigitList(number, isNegative, getMaximumFractionDigits());\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -843,2 +842,0 @@\n-                    number = number.divide(new BigDecimal(divisor.toString()), getRoundingMode());\n-                    decimalFormat.setDigitList(number, isNegative, getMaximumFractionDigits());\n@@ -907,1 +904,0 @@\n-                val = getNumberValue(number.doubleValue(), divisor.doubleValue());\n@@ -909,0 +905,14 @@\n+            var noFraction = number.mod(new BigInteger(divisor.toString()))\n+                    .compareTo(BigInteger.ZERO) == 0;\n+            if (noFraction) {\n+                number = number.divide(new BigInteger(divisor.toString()));\n+                decimalFormat.setDigitList(number, isNegative, 0);\n+            } else {\n+                \/\/ To avoid truncation of fractional part store the value in\n+                \/\/ BigDecimal and follow BigDecimal path instead of\n+                \/\/ BigInteger path\n+                BigDecimal nDecimal = new BigDecimal(number)\n+                        .divide(new BigDecimal(divisor.toString()), getRoundingMode());\n+                decimalFormat.setDigitList(nDecimal, isNegative, getMaximumFractionDigits());\n+            }\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -914,21 +924,4 @@\n-                    if (number.mod(new BigInteger(divisor.toString()))\n-                            .compareTo(BigInteger.ZERO) == 0) {\n-                        number = number.divide(new BigInteger(divisor.toString()));\n-\n-                        decimalFormat.setDigitList(number, isNegative, 0);\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, true, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    } else {\n-                        \/\/ To avoid truncation of fractional part store the value in\n-                        \/\/ BigDecimal and follow BigDecimal path instead of\n-                        \/\/ BigInteger path\n-                        BigDecimal nDecimal = new BigDecimal(number)\n-                                .divide(new BigDecimal(divisor.toString()), getRoundingMode());\n-                        decimalFormat.setDigitList(nDecimal, isNegative, getMaximumFractionDigits());\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, false, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    }\n+                    decimalFormat.subformatNumber(result, delegate,\n+                        isNegative, noFraction, getMaximumIntegerDigits(),\n+                        getMinimumIntegerDigits(), getMaximumFractionDigits(),\n+                        getMinimumFractionDigits());\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":40,"deletions":47,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -1802,0 +1802,8 @@\n+    \/**\n+     * {@return the {@code DigitList} used by this {@code DecimalFormat} instance}\n+     * Declared as package-private, intended for {@code CompactNumberFormat}.\n+     *\/\n+    DigitList getDigitList() {\n+        return digitList;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1969,0 +1969,8 @@\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Prints the toString result to the given buf, avoiding extra string allocations.\n+     *\/\n+    void formatTo(StringBuilder buf) {\n@@ -1972,1 +1980,0 @@\n-        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDateTime.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1926,1 +1926,4 @@\n-        return dateTime.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var buf = new StringBuilder(29 + offsetStr.length());\n+        dateTime.formatTo(buf);\n+        return buf.append(offsetStr).toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetDateTime.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1401,1 +1401,4 @@\n-        return time.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var buf = new StringBuilder(18 + offsetStr.length());\n+        time.formatTo(buf);\n+        return buf.append(offsetStr).toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetTime.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2217,1 +2217,3 @@\n-        String str = dateTime.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var zoneStr = (String) null;\n+        int length = 29 + offsetStr.length();\n@@ -2219,1 +2221,2 @@\n-            str += '[' + zone.toString() + ']';\n+            zoneStr = zone.toString();\n+            length += zoneStr.length() + 2;\n@@ -2221,1 +2224,7 @@\n-        return str;\n+        var buf = new StringBuilder(length);\n+        dateTime.formatTo(buf);\n+        buf.append(offsetStr);\n+        if (zoneStr != null) {\n+            buf.append('[').append(zoneStr).append(']');\n+        }\n+        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -991,1 +991,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(baseloc, LOCALE_CREATOR);\n+            return LocaleCache.cache(baseloc);\n@@ -994,1 +994,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n+            return LocaleCache.cache(key);\n@@ -998,2 +998,9 @@\n-    private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n-            = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+    private static final class LocaleCache implements Function<Object, Locale> {\n+        private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n+                = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+\n+        private static final Function<Object, Locale> LOCALE_CREATOR = new LocaleCache();\n+\n+        public static Locale cache(Object key) {\n+            return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n+        }\n@@ -1001,1 +1008,0 @@\n-    private static final Function<Object, Locale> LOCALE_CREATOR = new Function<>() {\n@@ -1010,1 +1016,1 @@\n-    };\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -185,0 +185,5 @@\n+    \/**\n+     * Maximum delay is effectively 146 years\n+     *\/\n+    private static final long MAX_NANOS = (Long.MAX_VALUE >>> 1) - 1;\n+\n@@ -528,19 +533,1 @@\n-        return System.nanoTime() +\n-            ((delay < (Long.MAX_VALUE >> 1)) ? delay : overflowFree(delay));\n-    }\n-\n-    \/**\n-     * Constrains the values of all delays in the queue to be within\n-     * Long.MAX_VALUE of each other, to avoid overflow in compareTo.\n-     * This may occur if a task is eligible to be dequeued, but has\n-     * not yet been, while some other task is added with a delay of\n-     * Long.MAX_VALUE.\n-     *\/\n-    private long overflowFree(long delay) {\n-        Delayed head = (Delayed) super.getQueue().peek();\n-        if (head != null) {\n-            long headDelay = head.getDelay(NANOSECONDS);\n-            if (headDelay < 0 && (delay - headDelay < 0))\n-                delay = Long.MAX_VALUE + headDelay;\n-        }\n-        return delay;\n+        return System.nanoTime() + Math.min(delay, MAX_NANOS);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ScheduledThreadPoolExecutor.java","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1033,8 +1033,1 @@\n-    abstract static sealed class PrimitiveEntry<T extends ConstantDesc>\n-            extends AbstractPoolEntry {\n-        protected final T val;\n-\n-        public PrimitiveEntry(ConstantPool constantPool, int tag, int index, T val) {\n-            super(constantPool, tag, index, hash1(tag, val.hashCode()));\n-            this.val = val;\n-        }\n+    public static final class IntegerEntryImpl extends AbstractPoolEntry implements IntegerEntry {\n@@ -1042,16 +1035,1 @@\n-        public T value() {\n-            return val;\n-        }\n-\n-        public ConstantDesc constantValue() {\n-            return value();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"\" + tag() + value();\n-        }\n-    }\n-\n-    public static final class IntegerEntryImpl extends PrimitiveEntry<Integer>\n-            implements IntegerEntry {\n+        private final int val;\n@@ -1060,1 +1038,2 @@\n-            super(cpm, ClassFile.TAG_INTEGER, index, i);\n+            super(cpm, ClassFile.TAG_INTEGER, index, hash1(ClassFile.TAG_INTEGER, Integer.hashCode(i)));\n+            val = i;\n@@ -1076,1 +1055,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n@@ -1089,1 +1073,1 @@\n-    public static final class FloatEntryImpl extends PrimitiveEntry<Float>\n+    public static final class FloatEntryImpl extends AbstractPoolEntry\n@@ -1092,0 +1076,2 @@\n+        private final float val;\n+\n@@ -1093,1 +1079,2 @@\n-            super(cpm, ClassFile.TAG_FLOAT, index, f);\n+            super(cpm, ClassFile.TAG_FLOAT, index, hash1(ClassFile.TAG_FLOAT, Float.hashCode(f)));\n+            val = f;\n@@ -1109,1 +1096,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n@@ -1122,1 +1114,3 @@\n-    public static final class LongEntryImpl extends PrimitiveEntry<Long> implements LongEntry {\n+    public static final class LongEntryImpl extends AbstractPoolEntry implements LongEntry {\n+\n+        private final long val;\n@@ -1125,1 +1119,2 @@\n-            super(cpm, ClassFile.TAG_LONG, index, l);\n+            super(cpm, ClassFile.TAG_LONG, index, hash1(ClassFile.TAG_LONG, Long.hashCode(l)));\n+            val = l;\n@@ -1141,1 +1136,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n@@ -1154,1 +1154,3 @@\n-    public static final class DoubleEntryImpl extends PrimitiveEntry<Double> implements DoubleEntry {\n+    public static final class DoubleEntryImpl extends AbstractPoolEntry implements DoubleEntry {\n+\n+        private final double val;\n@@ -1157,1 +1159,2 @@\n-            super(cpm, ClassFile.TAG_DOUBLE, index, d);\n+            super(cpm, ClassFile.TAG_DOUBLE, index, hash1(ClassFile.TAG_DOUBLE, Double.hashCode(d)));\n+            val = d;\n@@ -1173,1 +1176,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":43,"deletions":35,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -269,2 +269,2 @@\n-    private <T extends ConstantDesc> PoolEntry findPrimitiveEntry(int tag, T val) {\n-        int hash = AbstractPoolEntry.hash1(tag, val.hashCode());\n+    private IntegerEntry findIntEntry(int val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_INTEGER, Integer.hashCode(val));\n@@ -274,4 +274,55 @@\n-            if (e.tag() == tag\n-                && e instanceof AbstractPoolEntry.PrimitiveEntry<?> ce\n-                && ce.value().equals(val))\n-                return e;\n+            if (e.tag() == TAG_INTEGER\n+                    && e instanceof AbstractPoolEntry.IntegerEntryImpl ce\n+                    && ce.intValue() == val)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findIntEntry(val);\n+        }\n+        return null;\n+    }\n+\n+    private LongEntry findLongEntry(long val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_LONG, Long.hashCode(val));\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == TAG_LONG\n+                    && e instanceof AbstractPoolEntry.LongEntryImpl ce\n+                    && ce.longValue() == val)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findLongEntry(val);\n+        }\n+        return null;\n+    }\n+\n+    private FloatEntry findFloatEntry(float val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_FLOAT, Float.hashCode(val));\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == TAG_FLOAT\n+                    && e instanceof AbstractPoolEntry.FloatEntryImpl ce\n+                    && ce.floatValue() == val)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findFloatEntry(val);\n+        }\n+        return null;\n+    }\n+\n+    private DoubleEntry findDoubleEntry(double val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_DOUBLE, Double.hashCode(val));\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == TAG_DOUBLE\n+                    && e instanceof AbstractPoolEntry.DoubleEntryImpl ce\n+                    && ce.doubleValue() == val)\n+                return ce;\n@@ -281,1 +332,1 @@\n-            return findPrimitiveEntry(tag, val);\n+            return findDoubleEntry(val);\n@@ -545,1 +596,1 @@\n-        var e = (IntegerEntry) findPrimitiveEntry(TAG_INTEGER, value);\n+        var e = findIntEntry(value);\n@@ -551,1 +602,1 @@\n-        var e = (FloatEntry) findPrimitiveEntry(TAG_FLOAT, value);\n+        var e = findFloatEntry(value);\n@@ -557,1 +608,1 @@\n-        var e = (LongEntry) findPrimitiveEntry(TAG_LONG, value);\n+        var e = findLongEntry(value);\n@@ -563,1 +614,1 @@\n-        var e = (DoubleEntry) findPrimitiveEntry(TAG_DOUBLE, value);\n+        var e = findDoubleEntry(value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":62,"deletions":11,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    private static final MethodHandle MH_ADD;\n+    private static final MethodHandle MH_ADD_EXACT;\n@@ -84,1 +84,1 @@\n-            MH_ADD = lookup.findStatic(Long.class, \"sum\",\n+            MH_ADD_EXACT = lookup.findStatic(Math.class, \"addExact\",\n@@ -247,1 +247,1 @@\n-        MethodHandle mh = MethodHandles.insertArguments(MH_ADD, 0, offset);\n+        MethodHandle mh = MH_ADD_EXACT;\n@@ -250,3 +250,7 @@\n-            \/\/ (J, ...) -> J to (J, J, ...) -> J\n-            \/\/ i.e. new coord is prefixed. Last coord will correspond to innermost layout\n-            mh = MethodHandles.collectArguments(mh, 0, collector);\n+            \/\/ (J, J, ...) -> J to (J, J, J, ...) -> J\n+            \/\/ 1. the leading argument is the base offset (externally provided).\n+            \/\/ 2. index arguments are added. The last index correspond to the innermost layout.\n+            \/\/ 3. overflow can only occur at the outermost layer, due to the final addition with the base offset.\n+            \/\/ This is because the layout API ensures (by construction) that all offsets generated from layout paths\n+            \/\/ are always < Long.MAX_VALUE.\n+            mh = MethodHandles.collectArguments(mh, 1, collector);\n@@ -254,2 +258,1 @@\n-\n-        return mh;\n+        return MethodHandles.insertArguments(mh, 1, offset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.io.InterruptedIOException;\n@@ -90,18 +89,0 @@\n-\n-        \/\/ This code has been uglified to protect against interrupts.\n-        \/\/ Even if a thread has been interrupted when loading resources,\n-        \/\/ the IO should not abort, so must carefully retry, failing only\n-        \/\/ if the retry leads to some other IO exception.\n-\n-        boolean isInterrupted = Thread.interrupted();\n-        int len;\n-        for (;;) {\n-            try {\n-                len = getContentLength();\n-                break;\n-            } catch (InterruptedIOException iioe) {\n-                Thread.interrupted();\n-                isInterrupted = true;\n-            }\n-        }\n-\n@@ -109,0 +90,1 @@\n+            int len = getContentLength();\n@@ -124,7 +106,1 @@\n-                int cc = 0;\n-                try {\n-                    cc = in.read(b, pos, bytesToRead);\n-                } catch (InterruptedIOException iioe) {\n-                    Thread.interrupted();\n-                    isInterrupted = true;\n-                }\n+                int cc = in.read(b, pos, bytesToRead);\n@@ -146,2 +122,0 @@\n-            } catch (InterruptedIOException iioe) {\n-                isInterrupted = true;\n@@ -149,4 +123,0 @@\n-\n-            if (isInterrupted) {\n-                Thread.currentThread().interrupt();\n-            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/Resource.java","additions":3,"deletions":33,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,0 @@\n-import java.util.zip.ZipEntry;\n@@ -442,1 +441,2 @@\n-            Loader loader;\n+            Loader loader = null;\n+            final URL[] loaderClassPathURLs;\n@@ -447,4 +447,1 @@\n-                URL[] urls = loader.getClassPath();\n-                if (urls != null) {\n-                    push(urls);\n-                }\n+                loaderClassPathURLs = loader.getClassPath();\n@@ -452,1 +449,8 @@\n-                \/\/ Silently ignore for now...\n+                \/\/ log the error and close the unusable loader (if any)\n+                if (DEBUG) {\n+                    System.err.println(\"Failed to construct a loader or construct its\" +\n+                            \" local classpath for \" + url + \", cause:\" + e);\n+                }\n+                if (loader != null) {\n+                    closeQuietly(loader);\n+                }\n@@ -455,3 +459,3 @@\n-                \/\/ Always silently ignore. The context, if there is one, that\n-                \/\/ this URLClassPath was given during construction will never\n-                \/\/ have permission to access the URL.\n+                \/\/ log the error and close the unusable loader (if any).\n+                \/\/ The context, if there is one, that this URLClassPath was\n+                \/\/ given during construction will never have permission to access the URL.\n@@ -461,0 +465,3 @@\n+                if (loader != null) {\n+                    closeQuietly(loader);\n+                }\n@@ -463,0 +470,3 @@\n+            if (loaderClassPathURLs != null) {\n+                push(loaderClassPathURLs);\n+            }\n@@ -470,0 +480,11 @@\n+    \/\/ closes the given loader and ignores any IOException that may occur during close\n+    private static void closeQuietly(final Loader loader) {\n+        try {\n+            loader.close();\n+        } catch (IOException ioe) {\n+            if (DEBUG) {\n+                System.err.println(\"ignoring exception \" + ioe + \" while closing loader \" + loader);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1142,1 +1142,3 @@\n-            NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.math.BigInteger;\n@@ -33,0 +32,1 @@\n+import java.util.Arrays;\n@@ -121,5 +121,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -224,5 +219,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -304,1 +294,1 @@\n-        } catch  (GeneralSecurityException gse) {\n+        } catch (GeneralSecurityException gse) {\n@@ -335,2 +325,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -354,2 +343,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -366,2 +354,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -378,6 +365,2 @@\n-            SessionId newId = new SessionId(true,\n-                hc.sslContext.getSecureRandom());\n-\n-            SecretKey resumptionMasterSecret =\n-                hc.handshakeSession.getResumptionMasterSecret();\n-            if (resumptionMasterSecret == null) {\n+            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n+            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n@@ -385,3 +368,2 @@\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"no resumption secret\");\n+                    SSLLogger.fine(\"No session ticket produced: \" +\n+                            \"session timeout is too long\");\n@@ -393,13 +375,11 @@\n-            \/\/ construct the PSK and handshake message\n-            BigInteger nonce = hc.handshakeSession.incrTicketNonceCounter();\n-            byte[] nonceArr = nonce.toByteArray();\n-            SecretKey psk = derivePreSharedKey(\n-                    hc.negotiatedCipherSuite.hashAlg,\n-                    resumptionMasterSecret, nonceArr);\n-\n-            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n-            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"session timeout\");\n+            \/\/ Send NewSessionTickets to the client based\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                int i = 0;\n+                NewSessionTicketMessage nstm;\n+                while (i < SSLConfiguration.serverNewSessionTicketCount) {\n+                    nstm = generateNST(hc, sessionCache);\n+                    if (nstm == null) {\n+                        break;\n+                    }\n+                    nstm.write(hc.handshakeOutput);\n+                    i++;\n@@ -408,1 +388,28 @@\n-                return null;\n+                hc.handshakeOutput.flush();\n+            }\n+            \/*\n+             * With large NST counts, a client that quickly closes after\n+             * TLS Finished completes can cause SocketExceptions such as:\n+             * Windows servers read-side throwing SocketException:\n+             *   \"An established connection was aborted by the software in\n+             *    your host machine\", which relates to error WSAECONNABORTED.\n+             * A SocketException caused by a \"broken pipe\" has been observed on\n+             * other systems.\n+             * These are very unlikely situations when client and server are on\n+             * different machines.\n+             *\n+             * RFC 8446 does not put requirements when an NST needs to be\n+             * sent, but it should be sent very soon after TLS Finished for\n+             * clients that will quickly resume to create more sessions.\n+             * TLS 1.3 is different from TLS 1.2, there is more data the client\n+             * should be aware of\n+             *\/\n+\n+            \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n+            \/\/\n+            \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n+            \/\/ of this post-handshake message will indicate the FINISHED\n+            \/\/ handshake status.  It is not needed to have a follow-on\n+            \/\/ SSLEngine.wrap() any longer.\n+            if (hc.conContext.needHandshakeFinishedStatus) {\n+                hc.conContext.needHandshakeFinishedStatus = false;\n@@ -411,1 +418,16 @@\n-            NewSessionTicketMessage nstm = null;\n+            \/\/ clean the post handshake context\n+            hc.conContext.finishPostHandshake();\n+\n+            \/\/ The message has been delivered.\n+            return null;\n+        }\n+\n+        private NewSessionTicketMessage generateNST(HandshakeContext hc,\n+            SSLSessionContextImpl sessionCache) throws IOException {\n+\n+            NewSessionTicketMessage nstm;\n+            SessionId newId = new SessionId(true,\n+                hc.sslContext.getSecureRandom());\n+\n+            \/\/ construct the PSK and handshake message\n+            byte[] nonce = hc.handshakeSession.incrTicketNonceCounter();\n@@ -414,2 +436,4 @@\n-                    new SSLSessionImpl(hc.handshakeSession, newId);\n-            sessionCopy.setPreSharedKey(psk);\n+                new SSLSessionImpl(hc.handshakeSession, newId);\n+            sessionCopy.setPreSharedKey(derivePreSharedKey(\n+                hc.negotiatedCipherSuite.hashAlg,\n+                hc.handshakeSession.getResumptionMasterSecret(), nonce));\n@@ -422,1 +446,1 @@\n-                        sessionTimeoutSeconds,\n+                        sessionCache.getSessionTimeout(),\n@@ -424,1 +448,1 @@\n-                        nonceArr,\n+                        nonce,\n@@ -431,2 +455,1 @@\n-                        SSLLogger.fine(\n-                            \"Produced NewSessionTicket stateless \" +\n+                        SSLLogger.fine(\"Produced NewSessionTicket stateless \" +\n@@ -436,0 +459,1 @@\n+                return nstm;\n@@ -441,3 +465,4 @@\n-                nstm = new T13NewSessionTicketMessage(hc, sessionTimeoutSeconds,\n-                        hc.sslContext.getSecureRandom(), nonceArr,\n-                        newId.getId());\n+                nstm = new T13NewSessionTicketMessage(hc,\n+                    sessionCache.getSessionTimeout(),\n+                    hc.sslContext.getSecureRandom(), nonce,\n+                    newId.getId());\n@@ -445,3 +470,2 @@\n-                    SSLLogger.fine(\n-                            \"Produced NewSessionTicket post-handshake message\",\n-                            nstm);\n+                    SSLLogger.fine(\"Produced NewSessionTicket \" +\n+                        \"post-handshake message\", nstm);\n@@ -456,0 +480,1 @@\n+                return nstm;\n@@ -458,15 +483,2 @@\n-            \/\/ Output the handshake message.\n-            if (nstm != null) {\n-                \/\/ should never be null\n-                nstm.write(hc.handshakeOutput);\n-                hc.handshakeOutput.flush();\n-\n-                \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n-                \/\/\n-                \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n-                \/\/ of this post-handshake message will indicate the FINISHED\n-                \/\/ handshake status.  It is not needed to have a follow-on\n-                \/\/ SSLEngine.wrap() any longer.\n-                if (hc.conContext.needHandshakeFinishedStatus) {\n-                    hc.conContext.needHandshakeFinishedStatus = false;\n-                }\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"No NewSessionTicket created\");\n@@ -475,4 +487,0 @@\n-            \/\/ clean the post handshake context\n-            hc.conContext.finishPostHandshake();\n-\n-            \/\/ The message has been delivered.\n@@ -500,2 +508,3 @@\n-            \/\/ Is this session resumable?\n-            if (!shc.handshakeSession.isRejoinable()) {\n+            \/\/ Are new tickets allowed?  If so, is this session resumable?\n+            if (SSLConfiguration.serverNewSessionTicketCount == 0 ||\n+                !shc.handshakeSession.isRejoinable()) {\n@@ -581,1 +590,0 @@\n-                sessionCache.remove(hc.handshakeSession.getSessionId());\n@@ -622,1 +630,6 @@\n-            sessionCache.put(sessionCopy);\n+            sessionCache.put(sessionCopy, sessionCopy.isPSK());\n+\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"MultiNST PSK (Server): \" +\n+                    Utilities.toHexString(Arrays.copyOf(nstm.ticket, 16)));\n+            }\n@@ -629,0 +642,1 @@\n+    \/* TLS 1.2 spec does not specify multiple NST behavior.*\/\n@@ -677,2 +691,1 @@\n-                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" +\n-                        nstm.toString());\n+                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" + nstm);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NewSessionTicket.java","additions":93,"deletions":80,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -702,1 +702,1 @@\n-            sessionCache.remove(chc.resumingSession.getSessionId());\n+            sessionCache.remove(chc.resumingSession.getSessionId(), true);\n@@ -707,0 +707,2 @@\n+                SSLLogger.fine(\n+                    \"MultiNST PSK (Client): \" + Utilities.toHexString(Arrays.copyOf(chc.pskIdentity, 16)));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,0 +124,5 @@\n+    \/\/ Number of NewSessionTickets that will be sent by the server.\n+    static final int serverNewSessionTicketCount;\n+    \/\/ Default for NewSessionTickets\n+    static final int SERVER_NST_DEFAULT = 1;\n+\n@@ -185,1 +190,1 @@\n-                \"jdk.tls.client.maxInboundCertificateChainLength\");\n+            \"jdk.tls.client.maxInboundCertificateChainLength\");\n@@ -194,0 +199,27 @@\n+\n+        \/*\n+         * jdk.tls.server.newSessionTicketCount system property\n+         * Sets the number of NewSessionTickets sent to a TLS 1.3 resumption\n+         * client.  The value must be between 0 and 10.  Default is defined by\n+         * SERVER_NST_DEFAULT.\n+         *\/\n+        Integer nstServerCount = GetIntegerAction.privilegedGetProperty(\n+            \"jdk.tls.server.newSessionTicketCount\");\n+        if (nstServerCount == null || nstServerCount < 0 ||\n+            nstServerCount > 10) {\n+            serverNewSessionTicketCount = SERVER_NST_DEFAULT;\n+            if (nstServerCount != null && SSLLogger.isOn &&\n+                SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount defaults to \" +\n+                        SERVER_NST_DEFAULT + \" as the property was not \" +\n+                        \"between 0 and 10\");\n+            }\n+        } else {\n+            serverNewSessionTicketCount = nstServerCount;\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount set to \" +\n+                        serverNewSessionTicketCount);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -419,5 +419,6 @@\n-        if ((conContext.handshakeContext == null) &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            conContext.handshakeContext == null &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineImpl.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+    private static final int DEFAULT_MAX_QUEUE_SIZE = 10;\n@@ -90,2 +91,0 @@\n-        sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n-        sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -93,0 +92,2 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -95,1 +96,1 @@\n-            \/\/ but doesn't necessarily has to be a true random number.\n+            \/\/ but doesn't necessarily have to be a true random number.\n@@ -98,0 +99,3 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryQueue(cacheLimit, timeout,\n+                DEFAULT_MAX_QUEUE_SIZE);\n@@ -280,0 +284,10 @@\n+        put(s, false);\n+    }\n+\n+    \/**\n+     * Put an entry in the cache\n+     * @param s SSLSessionImpl entry to be stored\n+     * @param canQueue True if multiple entries may exist under one\n+     *                 session entry.\n+     *\/\n+    void put(SSLSessionImpl s, boolean canQueue) {\n@@ -285,1 +299,1 @@\n-                getKey(s.getPeerHost(), s.getPeerPort()), s);\n+                getKey(s.getPeerHost(), s.getPeerPort()), s, canQueue);\n@@ -293,0 +307,3 @@\n+        remove(key, false);\n+    }\n+    void remove(SessionId key, boolean isClient) {\n@@ -296,1 +313,3 @@\n-            sessionHostPortCache.remove(\n+            \/\/ A client keeps the cache entry for queued NST resumption.\n+            if (!isClient) {\n+                sessionHostPortCache.remove(\n@@ -298,0 +317,1 @@\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import java.util.Enumeration;\n@@ -135,1 +134,5 @@\n-    private BigInteger ticketNonceCounter = BigInteger.ONE;\n+    private byte ticketNonceCounter = 1;\n+\n+    \/\/ This boolean is true when a new set of NewSessionTickets are needed after\n+    \/\/ the initial ones sent after the handshake.\n+    boolean updateNST = false;\n@@ -495,1 +498,1 @@\n-                buf.get(b, 0 , i);\n+                buf.get(b, 0, i);\n@@ -504,2 +507,7 @@\n-                this.pskIdentity = new byte[buf.get()];\n-                buf.get(pskIdentity);\n+                i = buf.get();\n+                if (i > 0) {\n+                    this.pskIdentity = new byte[buf.get()];\n+                    buf.get(pskIdentity);\n+                } else {\n+                    this.pskIdentity = null;\n+                }\n@@ -718,4 +726,2 @@\n-    BigInteger incrTicketNonceCounter() {\n-        BigInteger result = ticketNonceCounter;\n-        ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);\n-        return result;\n+    byte[] incrTicketNonceCounter() {\n+        return new byte[] {ticketNonceCounter++};\n@@ -725,1 +731,1 @@\n-        return (ticketNonceCounter.compareTo(BigInteger.ZERO) > 0);\n+        return (ticketNonceCounter > 0);\n@@ -784,0 +790,4 @@\n+    public boolean isPSK() {\n+        return (pskIdentity != null && pskIdentity.length > 0);\n+    }\n+\n@@ -1233,1 +1243,0 @@\n-    boolean updateNST;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1324,1 +1324,0 @@\n-                conContext.conSession.updateNST = false;\n@@ -1559,6 +1558,7 @@\n-        if (!conContext.sslConfig.isClientMode &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                conContext.handshakeContext == null &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            !conContext.sslConfig.isClientMode &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            conContext.handshakeContext == null &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n@@ -1568,0 +1568,1 @@\n+            conContext.conSession.updateNST = false;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import javax.net.ssl.SSLSession;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n@@ -29,1 +32,2 @@\n-import java.lang.ref.*;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -93,0 +97,9 @@\n+    \/**\n+     * Add V to the cache with the option to use a QueueCacheEntry if the\n+     * cache is configured for it.  If the cache is not configured for a queue,\n+     * V will silently add the entry directly.\n+     *\/\n+    public void put(K key, V value, boolean canQueue) {\n+        put(key, value);\n+    }\n+\n@@ -140,0 +153,5 @@\n+    public static <K,V> Cache<K,V> newSoftMemoryQueue(int size, int timeout,\n+        int maxQueueSize) {\n+        return new MemoryCache<>(true, size, timeout, maxQueueSize);\n+    }\n+\n@@ -251,3 +269,1 @@\n-    private static final float LOAD_FACTOR = 0.75f;\n-\n-    \/\/ XXXX\n+    \/\/ Debugging\n@@ -258,0 +274,1 @@\n+    final private int maxQueueSize;\n@@ -266,1 +283,1 @@\n-        this(soft, maxSize, 0);\n+        this(soft, maxSize, 0, 0);\n@@ -270,0 +287,4 @@\n+        this(soft, maxSize, lifetime, 0);\n+    }\n+\n+    public MemoryCache(boolean soft, int maxSize, int lifetime, int qSize) {\n@@ -271,0 +292,1 @@\n+        this.maxQueueSize = qSize;\n@@ -272,1 +294,1 @@\n-        if (soft)\n+        if (soft) {\n@@ -274,1 +296,1 @@\n-        else\n+        } else {\n@@ -276,2 +298,4 @@\n-\n-        cacheMap = new LinkedHashMap<>(1, LOAD_FACTOR, true);\n+        }\n+        \/\/ LinkedHashMap is needed for its access order.  0.75f load factor is\n+        \/\/ default.\n+        cacheMap = new LinkedHashMap<>(1, 0.75f, true);\n@@ -341,0 +365,4 @@\n+                \/\/ If this is a queue, check for some expired entries\n+                if (entry instanceof QueueCacheEntry<K,V> qe) {\n+                    qe.getQueue().removeIf(e -> !e.isValid(time));\n+                }\n@@ -370,1 +398,20 @@\n-    public synchronized void put(K key, V value) {\n+    public void put(K key, V value) {\n+        put(key, value, false);\n+    }\n+\n+    \/**\n+     * This puts an entry into the cacheMap.\n+     *\n+     * If canQueue is true, V will be added using a QueueCacheEntry which\n+     * is added to cacheMap.  If false, V is added to the cacheMap directly.\n+     * The caller must keep a consistent canQueue value, mixing them can\n+     * result in a queue being replaced with a single entry.\n+     *\n+     * This method is synchronized to avoid multiple QueueCacheEntry\n+     * overwriting the same key.\n+     *\n+     * @param key key to the cacheMap\n+     * @param value value to be stored\n+     * @param canQueue can the value be put into a QueueCacheEntry\n+     *\/\n+    public synchronized void put(K key, V value, boolean canQueue) {\n@@ -372,2 +419,2 @@\n-        long expirationTime = (lifetime == 0) ? 0 :\n-                                        System.currentTimeMillis() + lifetime;\n+        long expirationTime =\n+            (lifetime == 0) ? 0 : System.currentTimeMillis() + lifetime;\n@@ -378,4 +425,27 @@\n-        CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n-        if (oldEntry != null) {\n-            oldEntry.invalidate();\n-            return;\n+        if (maxQueueSize == 0 || !canQueue) {\n+            CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n+            if (oldEntry != null) {\n+                oldEntry.invalidate();\n+            }\n+        } else {\n+            CacheEntry<K, V> entry = cacheMap.get(key);\n+            switch (entry) {\n+                case QueueCacheEntry<K, V> qe -> {\n+                    qe.putValue(newEntry);\n+                    if (DEBUG) {\n+                        System.out.println(\"QueueCacheEntry= \" + qe);\n+                        final AtomicInteger i = new AtomicInteger(1);\n+                        qe.queue.stream().forEach(e ->\n+                            System.out.println(i.getAndIncrement() + \"= \" + e));\n+                    }\n+                }\n+                case null, default ->\n+                    cacheMap.put(key, new QueueCacheEntry<>(key, newEntry,\n+                        expirationTime, maxQueueSize));\n+            }\n+\n+            if (DEBUG) {\n+                System.out.println(\"Cache entry added: key=\" +\n+                    key.toString() + \", class=\" +\n+                    (entry != null ? entry.getClass().getName() : null));\n+            }\n@@ -404,2 +474,3 @@\n-        long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n-        if (!entry.isValid(time)) {\n+\n+        if (lifetime > 0 && !entry.isValid(System.currentTimeMillis())) {\n+            cacheMap.remove(key);\n@@ -409,1 +480,0 @@\n-            cacheMap.remove(key);\n@@ -412,0 +482,9 @@\n+\n+        \/\/ If the value is a queue, return a queue entry.\n+        if (entry instanceof QueueCacheEntry<K, V> qe) {\n+            V result = qe.getValue(lifetime);\n+            if (qe.isEmpty()) {\n+                removeImpl(key);\n+            }\n+            return result;\n+        }\n@@ -417,0 +496,4 @@\n+        removeImpl(key);\n+    }\n+\n+    private void removeImpl(Object key) {\n@@ -422,1 +505,0 @@\n-\n@@ -553,3 +635,2 @@\n-    private static class SoftCacheEntry<K,V>\n-            extends SoftReference<V>\n-            implements CacheEntry<K,V> {\n+    private static class SoftCacheEntry<K,V> extends SoftReference<V>\n+        implements CacheEntry<K,V> {\n@@ -592,0 +673,7 @@\n+\n+        @Override\n+        public String toString() {\n+            if (get() instanceof SSLSession se)\n+                return HexFormat.of().formatHex(se.getId());\n+            return super.toString();\n+        }\n@@ -594,1 +682,104 @@\n-}\n+    \/**\n+     * This CacheEntry<K,V> type allows multiple V entries to be stored in\n+     * one key in the cacheMap.\n+     *\n+     * This implementation is need for TLS clients that receive multiple\n+     * PSKs or NewSessionTickets for server resumption.\n+     *\/\n+    private static class QueueCacheEntry<K,V> implements CacheEntry<K,V> {\n+\n+        \/\/ Limit the number of queue entries.\n+        private final int MAXQUEUESIZE;\n+\n+        final boolean DEBUG = false;\n+        private K key;\n+        private long expirationTime;\n+        final Queue<CacheEntry<K,V>> queue = new ConcurrentLinkedQueue<>();\n+\n+        QueueCacheEntry(K key, CacheEntry<K,V> entry, long expirationTime,\n+            int maxSize) {\n+            this.key = key;\n+            this.expirationTime = expirationTime;\n+            this.MAXQUEUESIZE = maxSize;\n+            queue.add(entry);\n+        }\n+\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        public V getValue() {\n+            return getValue(0);\n+        }\n+\n+        public V getValue(long lifetime) {\n+            long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n+            do {\n+                var entry = queue.poll();\n+                if (entry == null) {\n+                    return null;\n+                }\n+                if (entry.isValid(time)) {\n+                    return entry.getValue();\n+                }\n+                entry.invalidate();\n+            } while (!queue.isEmpty());\n+\n+            return null;\n+        }\n+\n+        public long getExpirationTime() {\n+            return expirationTime;\n+        }\n+\n+        public void setExpirationTime(long time) {\n+            expirationTime = time;\n+        }\n+\n+        public void putValue(CacheEntry<K,V> entry) {\n+            if (DEBUG) {\n+                System.out.println(\"Added to queue (size=\" + queue.size() +\n+                    \"): \" + entry.getKey().toString() + \",  \" + entry);\n+            }\n+            \/\/ Update the cache entry's expiration time to the latest entry.\n+            \/\/ The getValue() calls will remove expired tickets.\n+            expirationTime = entry.getExpirationTime();\n+            \/\/ Limit the number of queue entries, removing the oldest.\n+            if (queue.size() >= MAXQUEUESIZE) {\n+                queue.remove();\n+            }\n+            queue.add(entry);\n+        }\n+\n+        public boolean isValid(long currentTime) {\n+            boolean valid = (currentTime <= expirationTime) && !queue.isEmpty();\n+            if (!valid) {\n+                invalidate();\n+            }\n+            return valid;\n+        }\n+\n+        public boolean isValid() {\n+            return isValid(System.currentTimeMillis());\n+        }\n+\n+        public void invalidate() {\n+            clear();\n+            key = null;\n+            expirationTime = -1;\n+        }\n+\n+        public void clear() {\n+            queue.forEach(CacheEntry::invalidate);\n+            queue.clear();\n+        }\n+\n+        public boolean isEmpty() {\n+            return queue.isEmpty();\n+        }\n+\n+        public Queue<CacheEntry<K,V>> getQueue() {\n+            return queue;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Cache.java","additions":216,"deletions":25,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.function.UnaryOperator;\n@@ -94,4 +93,0 @@\n-    \/\/ Interned BaseLocale cache\n-    private static final ReferencedKeySet<BaseLocale> CACHE =\n-            ReferencedKeySet.create(true, ReferencedKeySet.concurrentHashMapSupplier());\n-\n@@ -166,13 +161,3 @@\n-        return CACHE.intern(new BaseLocale(language, script, region, variant),\n-                \/\/ Avoid lambdas since this may be on the bootstrap path in many locales\n-                INTERNER);\n-    }\n-\n-    public static final UnaryOperator<BaseLocale> INTERNER = new UnaryOperator<>() {\n-        @Override\n-        public BaseLocale apply(BaseLocale b) {\n-            return new BaseLocale(\n-                    LocaleUtils.toLowerString(b.language).intern(),\n-                    LocaleUtils.toTitleString(b.script).intern(),\n-                    LocaleUtils.toUpperString(b.region).intern(),\n-                    b.variant.intern());\n+        class InterningCache { \/\/ TODO: StableValue\n+            private static final ReferencedKeySet<BaseLocale> CACHE =\n+                    ReferencedKeySet.create(true, ReferencedKeySet.concurrentHashMapSupplier());\n@@ -180,1 +165,6 @@\n-    };\n+        return InterningCache.CACHE.intern(new BaseLocale(\n+                language.intern(), \/\/ guaranteed to be lower-case\n+                LocaleUtils.toTitleString(script).intern(),\n+                region.intern(), \/\/ guaranteed to be upper-case\n+                variant.intern()));\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-    outputConsumedID = (*env)->GetFieldID(env, cls, \"outputConsumed\", \"I\");\n@@ -54,0 +53,1 @@\n+    outputConsumedID = (*env)->GetFieldID(env, cls, \"outputConsumed\", \"I\");\n","filename":"src\/java.base\/share\/native\/libzip\/Inflater.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -331,1 +331,1 @@\n-        _snprintf(cptr, MAX_PATH, \"\\\"%s\\\" %s\", argv[0], cmdline);\n+        snprintf(cptr, MAX_PATH, \"\\\"%s\\\" %s\", argv[0], cmdline);\n","filename":"src\/java.base\/windows\/native\/libjli\/cmdtoargs.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1061,1 +1061,1 @@\n-                     \"ctrl shift RIGHT\", \"selectNextColumnExtendSelection\",\n+                     \"ctrl shift RIGHT\", \"selectLastColumnExtendSelection\",\n@@ -1069,1 +1069,1 @@\n-                      \"ctrl shift LEFT\", \"selectPreviousColumnExtendSelection\",\n+                      \"ctrl shift LEFT\", \"selectFirstColumnExtendSelection\",\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKLookAndFeel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -397,1 +397,4 @@\n-     * divider is contained in changes. Will create the\n+     * divider is contained in changes.\n+     * If a particular L&amp;F supports this Swing\n+     * \"SplitPane.supportsOneTouchButtons\" property\n+     * it will create the\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSplitPaneDivider.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,5 +29,0 @@\n-#ifdef _MSC_VER\n-# ifndef snprintf\n-#       define snprintf _snprintf\n-# endif\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/splashscreen_impl.c","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-    _snprintf(assertMsg, ASSERT_MSG_SIZE, AssertFmt, expr, file, line, lastError, msgBuffer);\n+    snprintf(assertMsg, ASSERT_MSG_SIZE, AssertFmt, expr, file, line, lastError, msgBuffer);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Debug.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1529,2 +1529,2 @@\n-        ::_snprintf(text, sizeof(text), \"%d of %d\", (int)messageNumber,\n-                                                    (int) messageCount);\n+        ::snprintf(text, sizeof(text), \"%d of %d\", (int)messageNumber,\n+                                                   (int) messageCount);\n","filename":"src\/jdk.accessibility\/windows\/native\/jaccessinspector\/jaccessinspector.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2341,1 +2341,1 @@\n-        private ErrorType(Type originalType, TypeSymbol tsym,\n+        public ErrorType(Type originalType, TypeSymbol tsym,\n@@ -2396,4 +2396,0 @@\n-        public List<Type> allparams()            { return List.nil(); }\n-        @DefinedBy(Api.LANGUAGE_MODEL)\n-        public List<Type> getTypeArguments()     { return List.nil(); }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5084,0 +5084,8 @@\n+        } else if (clazztype.hasTag(ERROR)) {\n+            ErrorType parameterizedErroneous =\n+                    new ErrorType(clazztype.getOriginalType(),\n+                                  clazztype.tsym,\n+                                  clazztype.getMetadata());\n+\n+            parameterizedErroneous.typarams_field = actuals;\n+            owntype = parameterizedErroneous;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import com.sun.tools.javac.parser.VirtualParser.VirtualScanner;\n@@ -5022,0 +5023,1 @@\n+            boolean unclosedParameterList;\n@@ -5024,0 +5026,1 @@\n+                unclosedParameterList = token.pos == endPosTable.errorEndPos;\n@@ -5029,0 +5032,2 @@\n+            } else {\n+                unclosedParameterList = false;\n@@ -5042,0 +5047,1 @@\n+                    accept(SEMI);\n@@ -5044,0 +5050,1 @@\n+                    accept(SEMI, tk -> Errors.Expected2(LBRACE, SEMI));\n@@ -5045,1 +5052,0 @@\n-                accept(SEMI);\n@@ -5048,2 +5054,5 @@\n-                    skip(false, true, false, false);\n-                    if (token.kind == LBRACE) {\n+                    \/\/ look if there is a probable missing opening brace,\n+                    \/\/ and if yes, parse as a block\n+                    boolean parseAsBlock = openingBraceMissing(unclosedParameterList);\n+\n+                    if (parseAsBlock) {\n@@ -5066,0 +5075,78 @@\n+    \/**\n+     * After seeing a method header, and not seeing an opening left brace,\n+     * attempt to estimate if acting as if the left brace was present and\n+     * parsing the upcoming code will get better results than not parsing\n+     * the code as a block.\n+     *\n+     * The estimate is as follows:\n+     * - tokens are skipped until member, statement or identifier is found,\n+     * - then, if there is a left brace, parse as a block,\n+     * - otherwise, if the head was broken, do not parse as a block,\n+     * - otherwise, look at the next token and:\n+     *   - if it definitelly starts a statement, parse as a block,\n+     *   - otherwise, if it is a closing\/right brace, count opening and closing\n+     *     braces in the rest of the file, to see if imaginarily \"adding\" an opening\n+     *     brace would lead to a balanced count - if yes, parse as a block,\n+     *   - otherwise, speculatively parse the following code as a block, and if\n+     *     it contains statements that cannot be members, parse as a block,\n+     *   - otherwise, don't parse as a block.\n+     *\n+     * @param unclosedParameterList whether there was a serious problem in the\n+     *                              parameters list\n+     * @return true if and only if the following code should be parsed as a block.\n+     *\/\n+    private boolean openingBraceMissing(boolean unclosedParameterList) {\n+        skip(false, true, !unclosedParameterList, !unclosedParameterList);\n+\n+        if (token.kind == LBRACE) {\n+            return true;\n+        } else if (unclosedParameterList) {\n+            return false;\n+        } else {\n+            return switch (token.kind) {\n+                \/\/definitelly sees a statement:\n+                case CASE, DEFAULT, IF, FOR, WHILE, DO, TRY, SWITCH,\n+                    RETURN, THROW, BREAK, CONTINUE, ELSE, FINALLY,\n+                    CATCH, THIS, SUPER, NEW -> true;\n+                case RBRACE -> {\n+                    \/\/check if adding an opening brace would balance out\n+                    \/\/the opening and closing braces:\n+                    int braceBalance = 1;\n+                    VirtualScanner virtualScanner = new VirtualScanner(S);\n+\n+                    virtualScanner.nextToken();\n+\n+                    while (virtualScanner.token().kind != TokenKind.EOF) {\n+                        switch (virtualScanner.token().kind) {\n+                            case LBRACE -> braceBalance++;\n+                            case RBRACE -> braceBalance--;\n+                        }\n+                        virtualScanner.nextToken();\n+                    }\n+\n+                    yield braceBalance == 0;\n+                }\n+                default -> {\n+                    \/\/speculatively try to parse as a block, and check\n+                    \/\/if the result would suggest there is a block\n+                    \/\/e.g.: it contains a statement that is not\n+                    \/\/a member declaration\n+                    JavacParser speculative = new VirtualParser(this);\n+                    JCBlock speculativeResult =\n+                            speculative.block();\n+                    if (!speculativeResult.stats.isEmpty()) {\n+                        JCStatement last = speculativeResult.stats.last();\n+                        yield !speculativeResult.stats.stream().allMatch(s -> s.hasTag(VARDEF) ||\n+                                s.hasTag(CLASSDEF) ||\n+                                s.hasTag(BLOCK) ||\n+                                s == last) ||\n+                            !(last instanceof JCExpressionStatement exprStatement &&\n+                            exprStatement.expr.hasTag(ERRONEOUS));\n+                    } else {\n+                        yield false;\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":90,"deletions":3,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-        _snprintf(errorMessage, sizeof(errorMessage), \"Symbol not found: %s\", functionName);\n+        snprintf(errorMessage, sizeof(errorMessage), \"Symbol not found: %s\", functionName);\n","filename":"src\/jdk.crypto.cryptoki\/windows\/native\/libj2pkcs11\/j2secmod_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,6 +36,0 @@\n-\/\/ Disable CRT security warning against _snprintf\n-#pragma warning (disable : 4996)\n-\n-#define snprintf  _snprintf\n-#define vsnprintf _vsnprintf\n-\n","filename":"src\/jdk.hotspot.agent\/share\/native\/libsaproc\/sadis.c","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -481,1 +481,2 @@\n-    Recursively copy doc-file subdirectories\n+    Enables deep copying of 'doc-files' directories. Subdirectories and all\\n\\\n+    contents are recursively copied to the destination\n@@ -518,1 +519,1 @@\n-    Include footer text for each page\n+    This option is no longer supported and reports a warning\n@@ -556,1 +557,1 @@\n-    Exclude any doc-files subdirectories with given name.\\n\\\n+    Exclude any 'doc-files' subdirectories with given name.\\n\\\n@@ -617,1 +618,1 @@\n-    Generate warning about @serial tag\n+    Reports compile-time warnings for missing '@serial' tags\n@@ -632,1 +633,1 @@\n-    Specify single argument custom tags\n+    Specifies a custom tag with a single argument\n@@ -657,1 +658,2 @@\n-    Include file that help link links to\n+    Specifies a file containing the text that will be displayed when the\\n\\\n+    help link in the navigation bar is clicked\n@@ -694,1 +696,2 @@\n-    Allow JavaScript in options and comments\n+    Allow JavaScript in documentation comments, and options\\n\\\n+    whose value is html-code\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -681,1 +681,1 @@\n-         * the {@code --help-extended} option and its aliases.\n+         * the {@code --help-extra} option and its aliases.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    Specifies which members (fields, methods, etc.) will be\\n\\\n+    Specifies which members (fields, methods, or constructors) will be\\n\\\n@@ -90,1 +90,1 @@\n-    Specifies which module's packages will be documented. Possible\\n\\\n+    Specifies which module packages will be documented. Possible\\n\\\n@@ -100,1 +100,1 @@\n-    <value>\n+    (transitive|all)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-        size_t result_len = (size_t)_snprintf(buffer, buflen, \"%s\\\\%s.dll\", path, fname);\n+        size_t result_len = (size_t) snprintf(buffer, buflen, \"%s\\\\%s.dll\", path, fname);\n","filename":"src\/jdk.jdwp.agent\/windows\/native\/libjdwp\/linker_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,5 +37,0 @@\n-\/* Needed on Windows because names seem to be hidden in stdio.h. *\/\n-\n-#define snprintf        _snprintf\n-#define vsnprintf       _vsnprintf\n-\n","filename":"src\/jdk.jdwp.agent\/windows\/native\/libjdwp\/util_md.h","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-                    delegate.combine(Collections.unmodifiableSet(values));\n+                    return delegate.combine(Collections.unmodifiableSet(values));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Control.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    public static final int MAX_LIMIT = 128; \/* 0 MAX means disabled *\/\n-\n+    public static final int MAX_LIMIT = 131072; \/* 0 MAX means disabled *\/\n+    private static final int PRECACHE_THRESHOLD = 128;\n@@ -134,1 +134,1 @@\n-        if (!preCache(s)) {\n+        if (s.length() <= PRECACHE_THRESHOLD && !preCache(s)) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/StringPool.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -439,7 +439,7 @@\n-        _snprintf(fullCounterPath,\n-                  fullCounterPathLen,\n-                  PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n-                  objectName,\n-                  imageName,\n-                  instance,\n-                  counterName);\n+        snprintf(fullCounterPath,\n+                 fullCounterPathLen,\n+                 PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n+                 objectName,\n+                 imageName,\n+                 instance,\n+                 counterName);\n@@ -475,6 +475,6 @@\n-            _snprintf(fullCounterPath,\n-                      fullCounterPathLen,\n-                      OBJECT_WITH_INSTANCES_COUNTER_FMT,\n-                      objectName,\n-                      instance,\n-                      counterName);\n+            snprintf(fullCounterPath,\n+                     fullCounterPathLen,\n+                     OBJECT_WITH_INSTANCES_COUNTER_FMT,\n+                     objectName,\n+                     instance,\n+                     counterName);\n@@ -482,5 +482,5 @@\n-            _snprintf(fullCounterPath,\n-                      fullCounterPathLen,\n-                      OBJECT_COUNTER_FMT,\n-                      objectName,\n-                      counterName);\n+            snprintf(fullCounterPath,\n+                     fullCounterPathLen,\n+                     OBJECT_COUNTER_FMT,\n+                     objectName,\n+                     counterName);\n@@ -722,4 +722,4 @@\n-            _snprintf(fullIDProcessCounterPath,\n-                      MAX_PATH,\n-                      pdhIDProcessCounterFmt,\n-                      index);\n+            snprintf(fullIDProcessCounterPath,\n+                     MAX_PATH,\n+                     pdhIDProcessCounterFmt,\n+                     index);\n@@ -1062,7 +1062,7 @@\n-    _snprintf(pdhIDProcessCounterFmt,\n-              pdhIDProcessCounterFmtLen,\n-              PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n-              pdhLocalizedProcessObject,\n-              pdhProcessImageName,\n-              \"%d\",\n-              pdhLocalizedIDProcessCounter);\n+    snprintf(pdhIDProcessCounterFmt,\n+             pdhIDProcessCounterFmtLen,\n+             PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n+             pdhLocalizedProcessObject,\n+             pdhProcessImageName,\n+             \"%d\",\n+             pdhLocalizedIDProcessCounter);\n","filename":"src\/jdk.management\/windows\/native\/libmanagement_ext\/OperatingSystemImpl.c","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-      FLAG_SET_ERGO(MaxNewSize, 80 * M);\n+      FLAG_SET_ERGO(MaxNewSize, 40 * M);\n@@ -162,0 +162,3 @@\n+\/\/ Tests require at least 128M of MaxHeap\n+\/\/ otherwise ergonomic is different and generation sizes might be changed.\n+\n@@ -166,0 +169,3 @@\n+  if (MaxHeapSize < 128 * M) {\n+      return;\n+  }\n@@ -178,0 +184,3 @@\n+  if (MaxHeapSize < 128 * M) {\n+    return;\n+  }\n@@ -190,2 +199,2 @@\n-  TestGenCollectorPolicy::SetNewSizeCmd setter_large(80 * M);\n-  TestGenCollectorPolicy::CheckYoungInitial checker_large(80 * M);\n+  TestGenCollectorPolicy::SetNewSizeCmd setter_large(40 * M);\n+  TestGenCollectorPolicy::CheckYoungInitial checker_large(40 * M);\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_collectorPolicy.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    cld->metaspace_non_null()->deallocate(p, sz, in_class_space);\n+    cld->metaspace_non_null()->deallocate(p, sz);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspace_misc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+\n+runtime\/interpreter\/LastJsrTest.java 8338924 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-runtime\/interpreter\/LastJsrTest.java 8338924 linux-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.gvn;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Random;\n+\n+\/**\n+ * @test\n+ * @bug 8327381\n+ * @summary Refactor boolean node tautology transformations\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.TestBoolNodeGVN\n+ *\/\n+public class TestBoolNodeGVN {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+        testCorrectness();\n+    }\n+\n+    \/**\n+     * Test changing ((x & m) u<= m) or ((m & x) u<= m) to always true, same with ((x & m) u< m+1) and ((m & x) u< m+1)\n+     * The test is only applicable to x64, aarch64 and riscv64 for having <code>Integer.compareUnsigned<\/code>\n+     * intrinsified.\n+     *\/\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase1(int x, int m) {\n+        return !(Integer.compareUnsigned((x & m), m) > 0); \/\/ assert in inversions to generates the pattern looking for\n+    }\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase2(int x, int m) {\n+        return !(Integer.compareUnsigned((m & x), m) > 0);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase3(int x, int m) {\n+        return Integer.compareUnsigned((x & m), m + 1) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase4(int x, int m) {\n+        return Integer.compareUnsigned((m & x), m + 1) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase1(int x, int m) {\n+        return !(Integer.compareUnsigned((x & m), m - 1) > 0);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase2(int x, int m) {\n+        return !(Integer.compareUnsigned((m & x), m - 1) > 0);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase3(int x, int m) {\n+        return Integer.compareUnsigned((x & m), m + 2) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase4(int x, int m) {\n+        return Integer.compareUnsigned((m & x), m + 2) < 0;\n+    }\n+\n+    private static void testCorrectness() {\n+        int[] values = {\n+                0, 1, 5, 8, 16, 42, 100, new Random().nextInt(0, Integer.MAX_VALUE), Integer.MAX_VALUE\n+        };\n+\n+        for (int x : values) {\n+            for (int m : values) {\n+                if (!testShouldReplaceCpmUCase1(x, m) |\n+                    !testShouldReplaceCpmUCase2(x, m) |\n+                    !testShouldReplaceCpmUCase3(x, m) |\n+                    !testShouldReplaceCpmUCase4(x, m)) {\n+                    throw new RuntimeException(\"Bad result for x = \" + x + \" and m = \" + m + \", expected always true\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBoolNodeGVN.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -442,1 +442,1 @@\n-        beforeMatchingNameRegex(CMP_U, \"CmpU\");\n+        beforeMatchingNameRegex(CMP_U, \"CmpU\\\\b\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,3 @@\n+        if (Platform.isLinux()) {\n+            deprecated.add(new String[] { \"UseLinuxPosixThreadCPUClocks\", \"true\" });\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -119,2 +119,3 @@\n-                                     \"|(java.lang.OutOfMemoryError: Java heap space)\" +\n-                                     \"|(Initial heap size set to a larger value than the maximum heap size))\";\n+                                     \"|(Initial heap size set to a larger value than the maximum heap size)\" +\n+                                     \"|(java.lang.OutOfMemoryError)\" +\n+                                     \"|(Error: A JNI error has occurred, please check your installation and try again))\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestParallelGCWithCDS.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8056900\n+ * @bug 8056900 8338888\n@@ -31,1 +31,1 @@\n- * @run main\/native NoClassDefFoundErrorTest\n+ * @run main\/native\/othervm -Xlog:exceptions=info NoClassDefFoundErrorTest\n@@ -39,0 +39,1 @@\n+    \/\/ Use the specified name\n@@ -41,0 +42,5 @@\n+    \/\/ Use a name longer than a Java string - returns false\n+    \/\/ if native allocation failed.\n+    static native boolean tryCallDefineClass();\n+    static native boolean tryCallFindClass();\n+\n@@ -57,1 +63,1 @@\n-        \/\/ Test JVM_DefineClass() with long name.\n+        System.out.println(\"Test JVM_DefineClass() with long name\");\n@@ -67,1 +73,1 @@\n-        \/\/ Test JNI_DefineClass() with long name.\n+        System.out.println(\"Test JNI_DefineClass() with long name\");\n@@ -77,1 +83,1 @@\n-        \/\/ Test JNI_FindClass() with long name.\n+        System.out.println(\"Test JNI_FindClass() with long name\");\n@@ -80,1 +86,1 @@\n-            throw new RuntimeException(\"DefineClass did not throw expected NoClassDefFoundError\");\n+            throw new RuntimeException(\"FindClass did not throw expected NoClassDefFoundError\");\n@@ -87,1 +93,1 @@\n-        \/\/ Test JNI_FindClass() with null name.\n+        System.out.println(\"Test JNI_FindClass() with null name\");\n@@ -96,0 +102,26 @@\n+\n+        System.out.println(\"Test JNI_DefineClass() with giant name\");\n+        try {\n+            if (tryCallDefineClass()) {\n+                throw new RuntimeException(\"DefineClass did not throw expected NoClassDefFoundError\");\n+            } else {\n+                System.out.println(\"Test skipped due to native allocation failure\");\n+            }\n+        } catch (NoClassDefFoundError e) {\n+            if (!e.getMessage().contains(\"Class name exceeds maximum length of \")) {\n+                throw new RuntimeException(\"Wrong NoClassDefFoundError: \" + e.getMessage());\n+            }\n+        }\n+\n+        System.out.println(\"Test JNI_FindClass() with giant name\");\n+        try {\n+            if (tryCallFindClass()) {\n+                throw new RuntimeException(\"FindClass did not throw expected NoClassDefFoundError\");\n+            } else {\n+                System.out.println(\"Test skipped due to native allocation failure\");\n+            }\n+        } catch (NoClassDefFoundError e) {\n+            if (!e.getMessage().contains(\"Class name exceeds maximum length of \")) {\n+                throw new RuntimeException(\"Wrong NoClassDefFoundError: \" + e.getMessage());\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/NoClassDefFoundError\/NoClassDefFoundErrorTest.java","additions":40,"deletions":8,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,4 @@\n+#include <limits.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n@@ -45,0 +49,31 @@\n+static char* giant_string() {\n+    size_t len = ((size_t)INT_MAX) + 3;\n+    char* c_name = malloc(len * sizeof(char));\n+    if (c_name != NULL) {\n+        memset(c_name, 'Y', len - 1);\n+        c_name[len - 1] = '\\0';\n+    }\n+    return c_name;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NoClassDefFoundErrorTest_tryCallDefineClass(JNIEnv *env, jclass klass) {\n+    char* c_name = giant_string();\n+    if (c_name != NULL) {\n+        (*env)->DefineClass(env, c_name, NULL, NULL, 0);\n+        free(c_name);\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NoClassDefFoundErrorTest_tryCallFindClass(JNIEnv *env, jclass klass) {\n+    char* c_name = giant_string();\n+    if (c_name != NULL) {\n+        jclass cls = (*env)->FindClass(env, c_name);\n+        free(c_name);\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/NoClassDefFoundError\/libNoClassDefFoundErrorTest.c","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java 8005021,8332158 macosx-all,linux-x64\n+java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java 8005021 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+ * @library \/test\/lib\n+ * @build   jdk.test.lib.Platform\n@@ -33,3 +35,8 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.*;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+import jdk.test.lib.Platform;\n@@ -44,0 +51,3 @@\n+        if (Platform.isOnWayland()) {\n+            return;\n+        }\n","filename":"test\/jdk\/java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -122,0 +122,24 @@\n+    static final MemoryLayout A_VALUE = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"b\")\n+                    .withTargetLayout(ValueLayout.JAVA_INT)\n+    );\n+\n+    static final VarHandle a_value = A_VALUE.varHandle(\n+            PathElement.groupElement(\"b\"), PathElement.dereferenceElement());\n+\n+    @Test\n+    public void testDerefValue() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            \/\/ init structs\n+            MemorySegment a = arena.allocate(A);\n+            MemorySegment b = arena.allocate(ValueLayout.JAVA_INT);\n+            \/\/ init struct fields\n+            a.set(ValueLayout.ADDRESS, 0, b);\n+            b.set(ValueLayout.JAVA_INT, 0, 42);\n+            \/\/ dereference\n+            int val = (int) a_value.get(a, 0L);\n+            assertEquals(val, 42);\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -335,0 +335,8 @@\n+    @Test(dataProvider = \"testLayouts\", expectedExceptions = ArithmeticException.class)\n+    public void testOffsetHandleOverflow(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                         long expectedByteOffset) throws Throwable {\n+        MethodHandle byteOffsetHandle = layout.byteOffsetHandle(pathElements);\n+        byteOffsetHandle = byteOffsetHandle.asSpreader(long[].class, indexes.length);\n+        byteOffsetHandle.invoke(Long.MAX_VALUE, indexes);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+\n+import jdk.test.lib.util.JarUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+\/*\n+ * @test\n+ * @bug 8338445\n+ * @summary verify that the jdk.internal.loader.URLClassPath closes the JarFile\n+ *          instances that it no longer uses for loading\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.util.JarUtils\n+ * @comment This test expects MalformedURLException for some specific URLs.\n+ *          We use othervm to prevent interference from other tests which\n+ *          might have installed custom URLStreamHandler(s)\n+ * @run junit\/othervm JarLoaderCloseTest\n+ *\/\n+public class JarLoaderCloseTest {\n+\n+    private static final String RESOURCE_NAME = \"foo-bar.txt\";\n+    private static final String RESOURCE_CONTENT = \"Hello world\";\n+    private static final Path TEST_SCRATCH_DIR = Path.of(\".\");\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        \/\/ create a file which will be added to the JAR file that gets tested\n+        Files.writeString(TEST_SCRATCH_DIR.resolve(RESOURCE_NAME), RESOURCE_CONTENT);\n+    }\n+\n+    \/*\n+     * Creates a JAR file with a manifest which has a Class-Path entry value with malformed URLs.\n+     * Then uses a URLClassLoader backed by the JAR file in its classpath, loads some resource,\n+     * closes the URLClassLoader and then expects that the underlying JAR file can be deleted\n+     * from the filesystem.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"C:\\\\foo\\\\bar\\\\hello\/world.jar lib2.jar\",\n+            \"C:\/hello\/world\/foo.jar\",\n+            \"lib4.jar C:\\\\bar\\\\foo\\\\world\/hello.jar\"\n+    })\n+    public void testMalformedClassPathEntry(final String classPathValue) throws Exception {\n+        final Manifest manifest = createManifestWithClassPath(classPathValue);\n+        final Path jar = Files.createTempFile(TEST_SCRATCH_DIR, \"8338445\", \".jar\");\n+        \/\/ create the JAR file with the given manifest and an arbitrary file\n+        JarUtils.createJarFile(jar, manifest, TEST_SCRATCH_DIR, Path.of(RESOURCE_NAME));\n+        System.out.println(\"created jar at \" + jar + \" with manifest:\");\n+        manifest.write(System.out);\n+        final URL[] urlClassPath = new URL[]{jar.toUri().toURL()};\n+        \/\/ Create a URLClassLoader backed by the JAR file and load a non-existent resource just to\n+        \/\/ exercise the URLClassPath code of loading the jar and parsing the Class-Path entry.\n+        \/\/ Then close the classloader. After the classloader is closed\n+        \/\/ issue a delete on the underlying JAR file on the filesystem. The delete is expected\n+        \/\/ to succeed.\n+        try (final URLClassLoader cl = new URLClassLoader(urlClassPath)) {\n+            try (final InputStream is = cl.getResourceAsStream(\"non-existent.txt\")) {\n+                assertNull(is, \"unexpectedly found a resource in classpath \"\n+                        + Arrays.toString(urlClassPath));\n+            }\n+        }\n+        \/\/ now delete the JAR file and verify the delete worked\n+        Files.delete(jar);\n+        assertFalse(Files.exists(jar), jar + \" exists even after being deleted\");\n+    }\n+\n+    \/*\n+     * Creates a JAR file with a manifest which has a Class-Path entry value with URLs\n+     * that are parsable but point to files that don't exist on the filesystem.\n+     * Then uses a URLClassLoader backed by the JAR file in its classpath, loads some resource,\n+     * closes the URLClassLoader and then expects that the underlying JAR file can be deleted\n+     * from the filesystem.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/home\/me\/hello\/world.jar lib9.jar\",\n+            \"lib10.jar\"\n+    })\n+    public void testParsableClassPathEntry(final String classPathValue) throws Exception {\n+        final Manifest manifest = createManifestWithClassPath(classPathValue);\n+        final Path jar = Files.createTempFile(TEST_SCRATCH_DIR, \"8338445\", \".jar\");\n+        \/\/ create the JAR file with the given manifest and an arbitrary file\n+        JarUtils.createJarFile(jar, manifest, TEST_SCRATCH_DIR, Path.of(RESOURCE_NAME));\n+        System.out.println(\"created jar at \" + jar + \" with manifest:\");\n+        manifest.write(System.out);\n+        final URL[] urlClassPath = new URL[]{jar.toUri().toURL()};\n+        \/\/ Create a URLClassLoader backed by the JAR file and load a resource\n+        \/\/ and verify the resource contents.\n+        \/\/ Then close the classloader. After the classloader is closed\n+        \/\/ issue a delete on the underlying JAR file on the filesystem. The delete is expected\n+        \/\/ to succeed.\n+        try (final URLClassLoader cl = new URLClassLoader(urlClassPath)) {\n+            try (final InputStream is = cl.getResourceAsStream(RESOURCE_NAME)) {\n+                assertNotNull(is, RESOURCE_NAME + \" not located by classloader in classpath \"\n+                        + Arrays.toString(urlClassPath));\n+                final String content = new String(is.readAllBytes(), US_ASCII);\n+                assertEquals(RESOURCE_CONTENT, content, \"unexpected content in \" + RESOURCE_NAME);\n+            }\n+        }\n+        \/\/ now delete the JAR file and verify the delete worked\n+        Files.delete(jar);\n+        assertFalse(Files.exists(jar), jar + \" exists even after being deleted\");\n+    }\n+\n+    private static Manifest createManifestWithClassPath(final String classPathValue) {\n+        final Manifest manifest = new Manifest();\n+        final Attributes mainAttributes = manifest.getMainAttributes();\n+        mainAttributes.putValue(\"Manifest-Version\", \"1.0\");\n+        mainAttributes.putValue(\"Class-Path\", classPathValue);\n+        return manifest;\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/URLClassLoader\/JarLoaderCloseTest.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8177552 8217721 8222756 8295372 8306116 8319990\n+ * @bug 8177552 8217721 8222756 8295372 8306116 8319990 8338690\n@@ -63,0 +63,3 @@\n+    private static final NumberFormat FORMAT_IT_LONG = NumberFormat\n+            .getCompactNumberInstance(Locale.ITALIAN, NumberFormat.Style.LONG);\n+\n@@ -92,0 +95,7 @@\n+\n+    private static final NumberFormat FORMAT_PL_LONG = NumberFormat\n+            .getCompactNumberInstance(Locale.of(\"pl\"), NumberFormat.Style.LONG);\n+\n+    private static final NumberFormat FORMAT_FR_LONG = NumberFormat\n+            .getCompactNumberInstance(Locale.FRENCH, NumberFormat.Style.LONG);\n+\n@@ -362,0 +372,6 @@\n+\n+            \/\/ 8338690\n+            {FORMAT_PL_LONG, 5_000, \"5 tysi\\u0119cy\"},\n+            {FORMAT_PL_LONG, 4_949, \"5 tysi\\u0119cy\"},\n+            {FORMAT_FR_LONG, 1_949, \"2 mille\"},\n+            {FORMAT_IT_LONG, 1_949, \"2 mila\"},\n@@ -469,0 +485,4 @@\n+                \/\/ 8338690\n+                {FORMAT_PL_LONG, \"5 tysi\\u0119cy\", 5_000L, Long.class},\n+                {FORMAT_FR_LONG, \"2 mille\", 2_000L, Long.class},\n+                {FORMAT_IT_LONG, \"2 mila\", 2_000L, Long.class},\n@@ -517,0 +537,4 @@\n+            \/\/ 8338690\n+            {FORMAT_PL_LONG, \"5 tysiące\", 5L},\n+            {FORMAT_FR_LONG, \"2 millier\", 2L},\n+            {FORMAT_IT_LONG, \"2 mille\", 2L},\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestCompactNumber.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 4615343\n- * @summary Check that ZipError is thrown instead of InternalError when\n- * iterating entries of an invalid zip file\n- *\/\n-\n-import java.io.*;\n-import java.util.*;\n-import java.util.zip.*;\n-\n-public class TestZipError {\n-    public static void realMain(String[] args) throws Throwable {\n-        \/\/ Causing a ZipError is hard, especially on non-Windows systems.  See\n-        \/\/ comments below.\n-        String osName = System.getProperty(\"os.name\");\n-        if (!System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n-            return;\n-        }\n-\n-        String fileName = \"error4615343.zip\";\n-        File f = new File(fileName);\n-        f.delete();\n-        ZipOutputStream zos;\n-        ZipEntry ze;\n-\n-        \/\/ Create a zip file with two entries.\n-        zos = new ZipOutputStream(new FileOutputStream(f));\n-        ze = new ZipEntry(\"one\");\n-        zos.putNextEntry(ze);\n-        zos.write(\"hello\".getBytes());\n-        zos.closeEntry();\n-        ze = new ZipEntry(\"two\");\n-        zos.putNextEntry(ze);\n-        zos.write(\"world\".getBytes());\n-        zos.closeEntry();\n-        zos.close();\n-\n-        \/\/ Open the ZipFile.  This will read the zip file's central\n-        \/\/ directory into in-memory data structures.\n-        ZipFile zf = new ZipFile(fileName);\n-\n-        \/\/ Delete the file; of course this does not change the in-memory data\n-        \/\/ structures that represent the central directory!\n-        f.delete();\n-\n-        \/\/ Re-create zip file, with different entries than earlier.  However,\n-        \/\/ recall that we have in-memory information about the central\n-        \/\/ directory of the file at its previous state.\n-        zos = new ZipOutputStream(new FileOutputStream(f));\n-        ze = new ZipEntry(\"uno\");\n-        zos.putNextEntry(ze);\n-        zos.write(\"hola\".getBytes());\n-        zos.closeEntry();\n-        zos.close();\n-\n-        \/\/ Iterate zip file's contents.  On Windows, this will result in a\n-        \/\/ ZipError, because the data in the file differs from the in-memory\n-        \/\/ central directory information we read earlier.\n-        Enumeration<? extends ZipEntry> entries = zf.entries();\n-        try {\n-            while (entries.hasMoreElements()) {\n-                ze = entries.nextElement();\n-                zf.getInputStream(ze).readAllBytes();\n-            }\n-            fail(\"Did not get expected exception\");\n-        } catch (ZipException e) {\n-            pass();\n-        } catch (InternalError e) {\n-            fail(\"Caught InternalError instead of expected ZipError\");\n-        } catch (Throwable t) {\n-            unexpected(t);\n-        } finally {\n-            zf.close();\n-            f.delete();\n-        }\n-    }\n-\n-    \/\/--------------------- Infrastructure ---------------------------\n-    static volatile int passed = 0, failed = 0;\n-    static void pass() {passed++;}\n-    static void fail() {failed++; Thread.dumpStack();}\n-    static void fail(String msg) {System.out.println(msg); fail();}\n-    static void unexpected(Throwable t) {failed++; t.printStackTrace();}\n-    static void check(boolean cond) {if (cond) pass(); else fail();}\n-    static void equal(Object x, Object y) {\n-        if (x == null ? y == null : x.equals(y)) pass();\n-        else fail(x + \" not equal to \" + y);}\n-    public static void main(String[] args) throws Throwable {\n-        try {realMain(args);} catch (Throwable t) {unexpected(t);}\n-        System.out.println(\"\\nPassed = \" + passed + \" failed = \" + failed);\n-        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n-}\n","filename":"test\/jdk\/java\/util\/zip\/TestZipError.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -42,1 +42,2 @@\n-        TLSBase.Client client1 = new TLSBase.Client(true, false);\n+        TLSBase.Client client = new TLSBase.Client(true, false);\n+        client.connect();\n@@ -44,2 +45,3 @@\n-        server.getSession(client1).getSessionContext();\n-        server.done();\n+        \/\/ Close must be called to gather all the exceptions thrown\n+        client.close();\n+        server.close();\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CertMsgCheck.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+        client1.connect();\n@@ -69,0 +70,1 @@\n+        client2.connect();\n@@ -76,1 +78,0 @@\n-        server.done();\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CheckSessionContext.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -32,1 +33,0 @@\n-import java.util.Arrays;\n@@ -35,0 +35,3 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n@@ -42,1 +45,1 @@\n- * Server.done() must be called or the server will never exit and hang the test.\n+ * Server.close() must be called so the server will exit and end threading.\n@@ -55,1 +58,1 @@\n-    static String pathToStores = \"..\/etc\";\n+    static String pathToStores = \"javax\/net\/ssl\/etc\";\n@@ -60,0 +63,3 @@\n+    static final String TESTROOT =\n+        System.getProperty(\"test.root\", \"..\/..\/..\/..\");\n+\n@@ -64,1 +70,1 @@\n-    String name;\n+    public String name;\n@@ -67,6 +73,4 @@\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n+\n+        String keyFilename = TESTROOT +  \"\/\" + pathToStores + \"\/\" + keyStoreFile;\n+        String trustFilename = TESTROOT + \"\/\" + pathToStores + \"\/\" +\n+            trustStoreFile;\n@@ -81,5 +85,4 @@\n-        BufferedReader reader = new BufferedReader(\n-            new InputStreamReader(sock.getInputStream()));\n-        String s = reader.readLine();\n-        System.err.println(\"(read) \" + name + \": \" + s);\n-        return s.getBytes();\n+        BufferedInputStream is = new BufferedInputStream(sock.getInputStream());\n+        byte[] b = is.readNBytes(5);\n+        System.err.println(\"(read) \" + Thread.currentThread().getName() + \": \" + new String(b));\n+        return b;\n@@ -90,5 +93,2 @@\n-        PrintWriter out = new PrintWriter(\n-            new OutputStreamWriter(sock.getOutputStream()));\n-        out.println(new String(data));\n-        out.flush();\n-        System.err.println(\"(write)\" + name + \": \" + new String(data));\n+        sock.getOutputStream().write(data);\n+        System.err.println(\"(write)\" + Thread.currentThread().getName() + \": \" + new String(data));\n@@ -100,1 +100,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") +\n@@ -116,1 +116,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") +\n@@ -153,0 +153,5 @@\n+        ExecutorService threadPool = Executors.newFixedThreadPool(1,\n+            r -> {\n+                Thread t = Executors.defaultThreadFactory().newThread(r);\n+                return t;\n+            });\n@@ -163,0 +168,1 @@\n+                ssock.setReuseAddress(true);\n@@ -165,0 +171,1 @@\n+                System.out.println(\"Server Port: \" + serverPort);\n@@ -174,11 +181,2 @@\n-                        System.err.println(\"Server ready on port \" +\n-                            serverPort);\n-                        SSLSocket c = (SSLSocket)ssock.accept();\n-                        clientMap.put(c.getPort(), c);\n-                        try {\n-                            write(c, read(c));\n-                        } catch (Exception e) {\n-                            System.out.println(\"Caught \" + e.getMessage());\n-                            e.printStackTrace();\n-                            exceptionList.add(e);\n-                        }\n+                        SSLSocket sock = (SSLSocket)ssock.accept();\n+                        threadPool.submit(new ServerThread(sock));\n@@ -189,0 +187,2 @@\n+                } finally {\n+                    threadPool.close();\n@@ -194,3 +194,2 @@\n-        Server() {\n-            this(new ServerBuilder());\n-        }\n+        class ServerThread extends Thread {\n+            SSLSocket sock;\n@@ -198,42 +197,4 @@\n-        \/**\n-         * @param km - true for an empty key manager\n-         * @param tm - true for an empty trust manager\n-         *\/\n-        Server(boolean km, boolean tm) {\n-            super();\n-            name = \"server\";\n-            try {\n-                sslContext = SSLContext.getInstance(\"TLS\");\n-                sslContext.init(TLSBase.getKeyManager(km),\n-                    TLSBase.getTrustManager(tm), null);\n-                fac = sslContext.getServerSocketFactory();\n-                ssock = (SSLServerSocket) fac.createServerSocket(0);\n-                ssock.setNeedClientAuth(true);\n-                serverPort = ssock.getLocalPort();\n-            } catch (Exception e) {\n-                System.err.println(\"Failure during server initialization\");\n-                e.printStackTrace();\n-            }\n-\n-                \/\/ Thread to allow multiple clients to connect\n-                t = new Thread(() -> {\n-                    try {\n-                        while (true) {\n-                            System.err.println(\"Server ready on port \" +\n-                                serverPort);\n-                            SSLSocket c = (SSLSocket)ssock.accept();\n-                            clientMap.put(c.getPort(), c);\n-                            try {\n-                                write(c, read(c));\n-                            } catch (Exception e) {\n-                                System.out.println(\"Caught \" + e.getMessage());\n-                                e.printStackTrace();\n-                                exceptionList.add(e);\n-                            }\n-                        }\n-                    } catch (Exception ex) {\n-                        System.err.println(\"Server Down\");\n-                        ex.printStackTrace();\n-                    }\n-                });\n-                t.start();\n+            ServerThread(SSLSocket s) {\n+                this.sock = s;\n+                System.err.println(\"ServerThread(\"+sock.getPort()+\")\");\n+                clientMap.put(sock.getPort(), sock);\n@@ -242,17 +203,8 @@\n-        \/\/ Exit test to quit the test.  This must be called at the end of the\n-        \/\/ test or the test will never end.\n-        void done() {\n-            try {\n-                t.join(5000);\n-                ssock.close();\n-            } catch (Exception e) {\n-                System.err.println(e.getMessage());\n-                e.printStackTrace();\n-            }\n-        }\n-\n-        \/\/ Read from the client\n-        byte[] read(Client client) throws Exception {\n-            SSLSocket s = clientMap.get(Integer.valueOf(client.getPort()));\n-            if (s == null) {\n-                System.err.println(\"No socket found, port \" + client.getPort());\n+            public void run() {\n+                try {\n+                    write(sock, read(sock));\n+                } catch (Exception e) {\n+                    System.out.println(\"Caught \" + e.getMessage());\n+                    e.printStackTrace();\n+                    exceptionList.add(e);\n+                }\n@@ -260,1 +212,0 @@\n-            return read(s);\n@@ -263,3 +214,2 @@\n-        \/\/ Write to the client\n-        void write(Client client, byte[] data) throws Exception {\n-            write(clientMap.get(client.getPort()), data);\n+        Server() {\n+            this(new ServerBuilder());\n@@ -268,5 +218,7 @@\n-        \/\/ Server writes to the client, then reads from the client.\n-        \/\/ Return true if the read & write data match, false if not.\n-        boolean writeRead(Client client, String s) throws Exception{\n-            write(client, s.getBytes());\n-            return (Arrays.compare(s.getBytes(), client.read()) == 0);\n+        public SSLSession getSession(Client client) throws Exception {\n+            System.err.println(\"getSession(\"+client.getPort()+\")\");\n+            SSLSocket clientSocket = clientMap.get(client.getPort());\n+            if (clientSocket == null) {\n+                throw new Exception(\"Server can't find client socket\");\n+            }\n+            return clientSocket.getSession();\n@@ -275,4 +227,7 @@\n-        \/\/ Get the SSLSession from the server side socket\n-        SSLSession getSession(Client c) {\n-            SSLSocket s = clientMap.get(Integer.valueOf(c.getPort()));\n-            return s.getSession();\n+        void close(Client client) {\n+            try {\n+                System.err.println(\"close(\"+client.getPort()+\")\");\n+                clientMap.remove(client.getPort()).close();\n+            } catch (Exception e) {\n+                ;\n+            }\n@@ -280,5 +235,7 @@\n-\n-        \/\/ Close client socket\n-        void close(Client c) throws IOException {\n-            SSLSocket s = clientMap.get(Integer.valueOf(c.getPort()));\n-            s.close();\n+        void close() throws InterruptedException {\n+            clientMap.values().stream().forEach(s -> {\n+                try {\n+                    s.close();\n+                } catch (IOException e) {}\n+            });\n+            threadPool.awaitTermination(500, TimeUnit.MILLISECONDS);\n@@ -315,1 +272,1 @@\n-     * Client side will establish a connection from the constructor and wait.\n+     * Client side will establish a SSLContext instance.\n@@ -319,1 +276,1 @@\n-        SSLSocket sock;\n+        public SSLSocket socket;\n@@ -333,5 +290,0 @@\n-            connect();\n-        }\n-\n-        \/\/ Connect to server.  Maybe runnable in the future\n-        public SSLSocket connect() {\n@@ -341,7 +293,1 @@\n-                sock = (SSLSocket)sslContext.getSocketFactory().createSocket();\n-                sock.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), serverPort));\n-                System.err.println(\"Client connected using port \" +\n-                        sock.getLocalPort());\n-                name = \"client(\" + sock.toString() + \")\";\n-                write(\"Hello\");\n-                read();\n+                socket = createSocket();\n@@ -351,1 +297,0 @@\n-            return sock;\n@@ -354,3 +299,3 @@\n-        \/\/ Read from the client socket\n-        byte[] read() throws Exception {\n-            return read(sock);\n+        Client(Client cl) {\n+            sslContext = cl.sslContext;\n+            socket = createSocket();\n@@ -359,3 +304,7 @@\n-        \/\/ Write to the client socket\n-        void write(byte[] data) throws Exception {\n-            write(sock, data);\n+        public SSLSocket createSocket() {\n+            try {\n+                return (SSLSocket) sslContext.getSocketFactory().createSocket();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            return null;\n@@ -363,2 +312,12 @@\n-        void write(String s) throws Exception {\n-            write(sock, s.getBytes());\n+\n+        public SSLSocket connect() {\n+            try {\n+                socket.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), serverPort));\n+                System.err.println(\"Client (\" + Thread.currentThread().getName() + \") connected using port \" +\n+                    socket.getLocalPort() + \" to \" + socket.getPort());\n+                writeRead();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+                return null;\n+            }\n+            return socket;\n@@ -367,5 +326,9 @@\n-        \/\/ Client writes to the server, then reads from the server.\n-        \/\/ Return true if the read & write data match, false if not.\n-        boolean writeRead(Server server, String s) throws Exception {\n-            write(s.getBytes());\n-            return (Arrays.compare(s.getBytes(), server.read(this)) == 0);\n+        public SSLSession getSession() {\n+            return socket.getSession();\n+        }\n+        public void close() {\n+            try {\n+                socket.close();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n@@ -374,3 +337,2 @@\n-        \/\/ Get port from the socket\n-        int getPort() {\n-            return sock.getLocalPort();\n+        public int getPort() {\n+            return socket.getLocalPort();\n@@ -379,3 +341,8 @@\n-        \/\/ Close socket\n-        void close() throws IOException {\n-            sock.close();\n+        private SSLSocket writeRead() {\n+            try {\n+                write(socket, \"Hello\".getBytes(StandardCharsets.ISO_8859_1));\n+                read(socket);\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            return socket;\n@@ -383,0 +350,1 @@\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/TLSBase.java","additions":115,"deletions":147,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -0,0 +1,352 @@\n+\/*\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.Raster;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.imageio.ImageIO;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 8338103\n+ * @key headful\n+ * @summary Verifies that the OpenGL pipeline does not create artifacts\n+ * with swing components after window is zoomed to maximum size and then\n+ * resized back to normal. The test case simulates this operation using\n+ * a JButton. A file image of the component will be saved before and after\n+ * the window resize if the test fails. The test passes if both the button\n+ * images are the same.\n+ * @run main\/othervm -Dsun.java2d.opengl=true -Dsun.java2d.opengl.fbobject=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.opengl=true -Dsun.java2d.opengl.fbobject=true SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.opengl=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"windows\")\n+ * @run main\/othervm -Dsun.java2d.d3d=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.d3d=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"linux\")\n+ * @run main\/othervm -Dsun.java2d.xrender=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.xrender=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @run main\/othervm -Dsun.java2d.metal=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.metal=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+public class SwingButtonResizeTestWithOpenGL {\n+    private static Robot robot;\n+    private static CountDownLatch focusGainedLatch;\n+    private JFrame frame;\n+    private JButton button;\n+\n+    public SwingButtonResizeTestWithOpenGL() {\n+\n+        try {\n+            SwingUtilities.invokeAndWait(() -> createGUI());\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Problems creating GUI\");\n+        }\n+    }\n+\n+    private void createGUI() {\n+        frame = new JFrame(\"SwingButtonResizeTestWithOpenGL\");\n+        button = new JButton(\"Button A\");\n+        frame.setLocation(200, 200);\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        button.setPreferredSize(new Dimension(300, 300));\n+        button.addFocusListener(new FocusAdapter() {\n+            public void focusGained(FocusEvent fe) {\n+                focusGainedLatch.countDown();\n+            }\n+        });\n+        frame.getContentPane().setLayout(new FlowLayout());\n+        frame.getContentPane().add(button);\n+        frame.pack();\n+        frame.setVisible(true);\n+        frame.toFront();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        focusGainedLatch = new CountDownLatch(1);\n+        SwingButtonResizeTestWithOpenGL test =\n+                new SwingButtonResizeTestWithOpenGL();\n+        test.runTest();\n+    }\n+\n+    public void runTest() throws Exception {\n+        BufferedImage bimage1;\n+        BufferedImage bimage2;\n+\n+        try {\n+            robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+            robot.setAutoDelay(200);\n+\n+            if (focusGainedLatch.await(3, TimeUnit.SECONDS)) {\n+                System.out.println(\"Button focus gained...\");\n+            } else {\n+                System.out.println(\"Button focus not gained...\");\n+                throw new RuntimeException(\n+                        \"Can't gain focus on button even after waiting \" +\n+                        \"too long..\");\n+            }\n+\n+            System.out.println(\"Getting initial button image..image1\");\n+            bimage1 = getButtonImage();\n+\n+            \/\/ some platforms may not support maximize frame\n+            if (frame.getToolkit().isFrameStateSupported(\n+                    JFrame.MAXIMIZED_BOTH)) {\n+                robot.waitForIdle();\n+                \/\/ maximize frame from normal size\n+                frame.setExtendedState(JFrame.MAXIMIZED_BOTH);\n+                System.out.println(\"Frame is maximized\");\n+                robot.waitForIdle();\n+\n+                if (frame.getToolkit().isFrameStateSupported(JFrame.NORMAL)) {\n+                    System.out.println(\"Frame is back to normal\");\n+                    \/\/ resize from maximum size to normal\n+                    frame.setExtendedState(JFrame.NORMAL);\n+\n+                    \/\/ capture image of JButton after resize\n+                    System.out.println(\n+                            \"Getting image of JButton after resize..image2\");\n+                    bimage2 = getButtonImage();\n+\n+                    \/\/ compare button images from before and after frame resize\n+                    DiffImage di = new DiffImage(bimage1.getWidth(),\n+                                                 bimage1.getHeight());\n+                    System.out.println(\n+                            \"Taking the diff of two images, image1 and image2\");\n+                    if (!di.compare(bimage1, bimage2)) {\n+                        throw new RuntimeException(\n+                                \"Button renderings are different after window \"\n+                                + \"resize, num of Diff Pixels=\"\n+                                + di.getNumDiffPixels());\n+                    } else {\n+                        System.out.println(\"Test passed...\");\n+                    }\n+\n+                } else {\n+                    System.out.println(\n+                            \"Test skipped: JFrame.NORMAL resize is \" +\n+                            \"not supported\");\n+                }\n+\n+            } else {\n+                System.out.println(\n+                        \"Test skipped: JFrame.MAXIMIZED_BOTH resize is \" +\n+                        \"not supported\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> disposeFrame());\n+        }\n+    }\n+\n+    \/\/ Capture button rendering as a BufferedImage\n+    private BufferedImage getButtonImage() {\n+        try {\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            AtomicReference<Point> buttonLocRef = new AtomicReference<>();\n+            SwingUtilities.invokeAndWait(\n+                    () -> buttonLocRef.set(button.getLocationOnScreen()));\n+            Point buttonLoc = buttonLocRef.get();\n+            System.out.println(\"Button loc: \" + buttonLoc);\n+            return robot.createScreenCapture(\n+                    new Rectangle(buttonLoc.x, buttonLoc.y, button.getWidth(),\n+                                  button.getHeight()));\n+        } catch (Exception e) {\n+            throw new RuntimeException(\n+                    \"Problems capturing button image from Robot\", e);\n+        }\n+    }\n+\n+    private void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n+    \/\/ Save BufferedImage to PNG file\n+    private void saveButtonImage(BufferedImage image, File file) {\n+        if (image != null) {\n+            try {\n+                System.out.println(\n+                        \"Saving button image to \" + file.getAbsolutePath());\n+                ImageIO.write(image, \"PNG\", file);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Could not write image file\");\n+            }\n+        } else {\n+            throw new RuntimeException(\"BufferedImage was set to null\");\n+        }\n+    }\n+\n+    private class DiffImage extends BufferedImage {\n+\n+        public boolean diff = false;\n+        public int nDiff = -1;\n+\n+        Color bgColor;\n+\n+        int threshold = 0;\n+\n+        public DiffImage(int w, int h) {\n+            super(w, h, BufferedImage.TYPE_INT_ARGB);\n+            bgColor = Color.LIGHT_GRAY;\n+        }\n+\n+        public int getNumDiffPixels() {\n+            return nDiff;\n+        }\n+\n+        public boolean compare(BufferedImage img1, BufferedImage img2)\n+                throws IOException {\n+\n+            int minx1 = img1.getMinX();\n+            int minx2 = img2.getMinX();\n+            int miny1 = img1.getMinY();\n+            int miny2 = img2.getMinY();\n+\n+            int w1 = img1.getWidth();\n+            int w2 = img2.getWidth();\n+            int h1 = img1.getHeight();\n+            int h2 = img2.getHeight();\n+\n+            if ((minx1 != minx2) || (miny1 != miny2) || (w1 != w2)\n+                || (h1 != h2)) {\n+                \/\/ image sizes are different\n+                throw new RuntimeException(\n+                        \"img1: <\" + minx1 + \",\" + miny1 + \",\" + w1 + \"x\" + h1\n+                        + \">\" + \" img2: \" + minx2 + \",\" + miny2 + \",\" + w2 + \"x\"\n+                        + h2 + \">\" + \" are different sizes\");\n+            }\n+            \/\/ Get the actual data behind the images\n+            Raster ras1 = img1.getData();\n+            Raster ras2 = img2.getData();\n+\n+            ColorModel cm1 = img1.getColorModel();\n+            ColorModel cm2 = img2.getColorModel();\n+\n+            int r1, r2;  \/\/ red\n+            int g1, g2;  \/\/ green\n+            int b1, b2;  \/\/ blue\n+\n+            Object o1 = null;\n+            Object o2 = null;\n+            nDiff = 0;\n+            for (int x = minx1; x < (minx1 + w1); x++) {\n+                for (int y = miny1; y < (miny1 + h1); y++) {\n+                    \/\/ Causes rasters to allocate data\n+                    o1 = ras1.getDataElements(x, y, o1);\n+                    \/\/ and we reuse the data on every loop\n+                    o2 = ras2.getDataElements(x, y, o2);\n+\n+                    r1 = cm1.getRed(o1);\n+                    r2 = cm2.getRed(o2);\n+                    g1 = cm1.getGreen(o1);\n+                    g2 = cm2.getGreen(o2);\n+                    b1 = cm1.getBlue(o1);\n+                    b2 = cm2.getBlue(o2);\n+\n+                    int redAbs = Math.abs(r1 - r2);\n+                    int greenAbs = Math.abs(g1 - g2);\n+                    int blueAbs = Math.abs(b1 - b2);\n+                    if ((redAbs > threshold)\n+                        || (greenAbs > threshold)\n+                        || (blueAbs > threshold)) {\n+                        \/\/ pixel is different\n+                        setDiffPixel(x, y, redAbs, greenAbs, blueAbs);\n+                        nDiff++;\n+                    } else {\n+                        setSamePixel(x, y);\n+                    }\n+\n+                }\n+            }\n+            if (nDiff != 0) {\n+                ImageIO.write(this, \"png\",\n+                              new File(\"diffImage.png\"));\n+                saveButtonImage(img1, new File(\"image1.png\"));\n+                saveButtonImage(img2, new File(\"image2.png\"));\n+            }\n+            return nDiff == 0;\n+        }\n+\n+        void setDiffPixel(int x, int y, int r, int g, int b) {\n+            diff = true;\n+            setPixelValue(x, y, 255, r, g, b);\n+        }\n+\n+        void setSamePixel(int x, int y) {\n+            if (bgColor != null) {\n+                setPixelValue(x, y, 255, bgColor.getRed(),\n+                              bgColor.getGreen(),\n+                              bgColor.getBlue());\n+            } else {\n+                setPixelValue(x, y, 255, Color.black.getRed(),\n+                              Color.black.getGreen(), Color.black.getBlue());\n+            }\n+        }\n+\n+        void setPixelValue(int x, int y, int a, int r, int g, int b) {\n+            \/\/ setRGB uses BufferedImage.TYPE_INT_ARGB format\n+            int pixel =\n+                    ((a & 0xff) << 24) + ((r & 0xff) << 16) + ((g & 0xff) << 8)\n+                    + ((b & 0xff));\n+            setRGB(x, y, pixel);\n+        }\n+\n+    }\n+\n+}\n+\n+\n","filename":"test\/jdk\/javax\/swing\/JButton\/SwingButtonResizeTestWithOpenGL.java","additions":352,"deletions":0,"binary":false,"changes":352,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,11 @@\n- * @author Alexey Ivanov\n+ * @requires os.family != \"linux\"\n+ * @modules java.desktop\/sun.swing\n+ * @run main bug8080628\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8080628\n+ * @key headful\n+ * @summary No mnemonics on Open and Save buttons in JFileChooser.\n+ * @requires os.family == \"linux\"\n@@ -84,0 +94,1 @@\n+                    System.out.println(\"Unsupported L&F: \" + info.getClassName());\n@@ -86,0 +97,1 @@\n+                System.out.println(\"Testing L&F: \" + info.getClassName());\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/8080628\/bug8080628.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JTable;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+\/*\n+ * @test\n+ * @bug 8338041\n+ * @key headful\n+ * @summary Verify that Ctrl Shift RIGHT\/LEFT key extends columns till\n+ * Last\/First Columns in JTable\n+ * @requires (os.family == \"linux\")\n+ * @run main JTableCtrlShiftRightLeftKeyTest\n+ *\/\n+\n+public class JTableCtrlShiftRightLeftKeyTest {\n+    private static JFrame frame;\n+    private static JTable table;\n+    private static volatile Point tableLoc;\n+    private static volatile Rectangle cellRect;\n+    private static volatile int[] selectedColumnAfterKeyPress;\n+    private static Robot robot;\n+    private static final int SELECTED_COLUMN = 2;\n+\n+    public static void main(String[] args) throws Exception {\n+        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\");\n+        robot = new Robot();\n+        robot.setAutoDelay(50);\n+        try {\n+            SwingUtilities.invokeAndWait(JTableCtrlShiftRightLeftKeyTest::createAndShowUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                tableLoc = table.getLocationOnScreen();\n+                cellRect = table.getCellRect(0, SELECTED_COLUMN, true);\n+            });\n+\n+            robot.mouseMove(tableLoc.x + cellRect.x + cellRect.width \/ 2,\n+                    tableLoc.y + cellRect.y + cellRect.height \/ 2);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            testCtrlShift(KeyEvent.VK_RIGHT, SELECTED_COLUMN,\n+                    table.getColumnCount() - 1, \"RIGHT\");\n+\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            testCtrlShift(KeyEvent.VK_LEFT, 0,\n+                    SELECTED_COLUMN, \"LEFT\");\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            System.out.println(\"Test Passed!\");\n+\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void testCtrlShift(int keySelected, int startCellCheck,\n+                                      int endCellCheck, String key) throws Exception {\n+        robot.keyPress(KeyEvent.VK_SHIFT);\n+        robot.keyPress(KeyEvent.VK_CONTROL);\n+        robot.keyPress(keySelected);\n+        robot.keyRelease(keySelected);\n+        robot.keyRelease(KeyEvent.VK_SHIFT);\n+        robot.keyRelease(KeyEvent.VK_CONTROL);\n+        robot.waitForIdle();\n+        robot.delay(100);\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            selectedColumnAfterKeyPress = table.getSelectedColumns();\n+        });\n+\n+        if (selectedColumnAfterKeyPress[0] != startCellCheck ||\n+                selectedColumnAfterKeyPress[selectedColumnAfterKeyPress.length - 1] !=\n+                        endCellCheck) {\n+            System.out.println(\"Selected Columns: \");\n+            for (int columnsSelected : selectedColumnAfterKeyPress) {\n+                System.out.println(columnsSelected);\n+            }\n+            String failureMsg = \"Test Failure. Failed to select cells for Ctrl\" +\n+                    \" Shift \" + key + \" selection\";\n+            throw new RuntimeException(failureMsg);\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        frame = new JFrame(\"Test Ctrl Shift RIGHT\/LEFT Key Press\");\n+        table = new JTable(2, 5);\n+        table.setColumnSelectionAllowed(true);\n+        frame.getContentPane().add(table);\n+\n+        frame.setSize(200, 200);\n+        frame.setLocationRelativeTo(null);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/gtk\/JTableCtrlShiftRightLeftKeyTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,1 @@\n+        assertEquals(2, makeCombineControl());\n@@ -97,0 +98,28 @@\n+    private static int makeCombineControl() throws Exception {\n+        try (Recording r1 = new Recording()) {\n+            r1.enable(HTTPPostEvent.class).with(\"uriFilter\", \"https:\/\/www.example.com\/list\");\n+            r1.start();\n+\n+            try (Recording r2 = new Recording()) {\n+                r2.enable(HTTPPostEvent.class).with(\"uriFilter\", \"https:\/\/www.example.com\/get\");\n+                r2.start();\n+\n+                HTTPPostEvent e1 = new HTTPPostEvent();\n+                e1.uri = \"https:\/\/www.example.com\/list\";\n+                e1.commit();\n+\n+                HTTPPostEvent e2 = new HTTPPostEvent();\n+                e2.uri = \"https:\/\/www.example.com\/get\";\n+                e2.commit();\n+\n+                HTTPPostEvent e3 = new HTTPPostEvent();\n+                e3.uri = \"https:\/\/www.example.com\/put\";\n+                e3.commit();\n+            }\n+\n+            r1.stop();\n+\n+            return Events.fromRecording(r1).size();\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/api\/settings\/TestFilterEvents.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+\n+\/**\n+ * @test\n+ * @summary Verify that duplicate longer strings doesn't take up unneccessary space\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.jvm.TestLongStringsInPool\n+ *\/\n+public class TestLongStringsInPool {\n+    private static class StringEvent extends Event {\n+        String message;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Create two recordings; first has only one large\n+        \/\/ string, second has several occurences of the same\n+        \/\/ string. With long strings (>128 chars) being pooled,\n+        \/\/ the two recording should be roughly the same size.\n+        final int numEvents = 10;\n+        final String longString = generateString();\n+        final int strLen = longString.length();\n+        final StringEvent event = new StringEvent();\n+        event.message = longString;\n+\n+        Recording firstRec = new Recording();\n+        firstRec.start();\n+        \/\/ commit events with empty message (both recordings\n+        \/\/ will have the same number of events)\n+        for (int i = 0; i < numEvents - 1; i++) {\n+            event.message = \"\";\n+            event.commit();\n+        }\n+        \/\/ commit 1 event with a long string\n+        event.message = longString;\n+        event.commit();\n+\n+        firstRec.stop();\n+        Path rec1 = Paths.get(\".\", \"rec1.jfr\");\n+        firstRec.dump(rec1);\n+        firstRec.close();\n+\n+\n+        Recording secondRec = new Recording();\n+        secondRec.start();\n+        \/\/ commit events with the same long string\n+        for (int i = 0; i < numEvents - 1; i++) {\n+          event.message = longString;\n+          event.commit();\n+        }\n+        \/\/ commit 1 event with a long string\n+        event.message = longString;\n+        event.commit();\n+\n+        secondRec.stop();\n+        Path rec2 = Paths.get(\".\", \"rec2.jfr\");\n+        secondRec.dump(rec2);\n+        secondRec.close();\n+\n+        \/\/ the files aren't exactly the same size, but rec2 should\n+        \/\/ not take up space for all strings if they're pooled correctly\n+        long maxAllowedDiff = (numEvents - 1) * strLen;\n+        long diff = Math.abs(Files.size(rec2) - Files.size(rec1));\n+\n+        Asserts.assertTrue(diff <= maxAllowedDiff, \"Size difference between recordings is too large: \"+ diff +\" > \" + maxAllowedDiff);\n+        Asserts.assertFalse(RecordingFile.readAllEvents(rec1).isEmpty(), \"No events found in recording 1\");\n+        Asserts.assertFalse(RecordingFile.readAllEvents(rec2).isEmpty(), \"No events found in recording 2\");\n+        Asserts.assertEquals(RecordingFile.readAllEvents(rec1).size(), RecordingFile.readAllEvents(rec2).size(), \"The recordings don't have the same number of events\");\n+    }\n+\n+    \/**\n+     * Generate a string of 256 chars length.\n+     * @return\n+     *\/\n+    private static String generateString() {\n+        final StringBuilder builder = new StringBuilder();\n+        for (int i = 0; i < 32; i++) {\n+            builder.append(\"abcdefgh\");\n+        }\n+        return builder.toString();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestLongStringsInPool.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies multiple PSKs are used by JSSE\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=1\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=3\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=10\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.2 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+\/**\n+ * This test verifies that multiple NSTs and PSKs are sent by a JSSE server.\n+ * Then JSSE client is able to store them all and resume the connection.  It\n+ * requires specific text in the TLS debugging to verify the success.\n+ *\/\n+\n+public class MultiNSTClient {\n+\n+    static HexFormat hex = HexFormat.of();\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> {\n+                sb.append(a);\n+                sb.append(\" \");\n+            });\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params\n+                );\n+\n+            boolean TLS13 = args[0].contains(\"1.3\");\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTClient\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            System.out.println(\"I'm here\");\n+            boolean pass = true;\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> serverPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                for (int i = 0; i < 2; i++) {\n+                    String svr = serverPSK.getFirst();\n+                    String cli = clientPSK.getFirst();\n+                    if (svr.regionMatches(svr.length() - 16, cli, cli.length() - 16, 16)) {\n+                        System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                    } else {\n+                        System.out.println(\"entry \" + (i + 1) + \" server and client PSK didn't match:\");\n+                        System.out.println(\"  server: \" + svr);\n+                        System.out.println(\"  client: \" + cli);\n+                        pass = false;\n+                    }\n+                }\n+            } catch (RuntimeException e) {\n+                System.out.println(\"No MultiNST PSK found.\");\n+                pass = false;\n+            }\n+\n+            if (TLS13) {\n+                if (!pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            } else {\n+                if (pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Start connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        SSLSession initialSession = initial.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  getNewSession from original client\");\n+        TLSBase.Client resumClient = new TLSBase.Client(initial);\n+        SSLSession resumption = resumClient.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  Second getNewSession from original client\");\n+        TLSBase.Client resumClient2 = new TLSBase.Client(initial);\n+        resumption = resumClient2.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  New client connection\");\n+        TLSBase.Client newConnection = new TLSBase.Client();\n+        SSLSession newSession = newConnection.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(newSession.getId()));\n+        System.out.println(\"session = \" + newSession);\n+        if (initialSession.toString().equalsIgnoreCase(newSession.toString())) {\n+            throw new Exception(\"new session is the same as the initial.\");\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        resumClient.close();\n+        resumClient2.close();\n+        newConnection.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTClient.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies resumption fails with 0 NSTs and session creation off\n+ * @run main\/othervm MultiNSTNoSessionCreation -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=0\n+ * @run main\/othervm MultiNSTNoSessionCreation -Djdk.tls.client.protocols=TLSv1.2 -Djdk.tls.server.newSessionTicketCount=0\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * With no NSTs sent by the server, try to resume the session with\n+ * setEnabledSessionCreation(false).  The test should get an exception and\n+ * fail to connect.\n+ *\/\n+\n+public class MultiNSTNoSessionCreation {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> sb.append(a).append(\" \"));\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params);\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTNoSessionCreation\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            try {\n+                if (output.stderrContains(\n+                    \"(PROTOCOL_VERSION): New session creation is disabled\")) {\n+                    return;\n+                }\n+            } catch (RuntimeException e) {\n+                throw new Exception(\"Error collecting data\", e);\n+            }\n+            throw new Exception(\"Disabled creation msg not found\");\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Initial connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        initial.connect();\n+        System.out.println(\n+            \"------  Resume client w\/ setEnableSessionCreation set to false\");\n+        TLSBase.Client resumClient = new TLSBase.Client(initial);\n+        resumClient.socket.setEnableSessionCreation(false);\n+        resumClient.connect();\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        resumClient.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTNoSessionCreation.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies multiple PSKs are used by TLSv1.3\n+ * @run main\/othervm MultiNSTParallel 10 -Djdk.tls.client.protocols=TLSv1.3\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.ArrayList;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * This test verifies that parallel resumption connections successfully get\n+ * a PSK entry and not initiate a full handshake.\n+ *\n+ * Note:  THe first argument after 'MultiNSTParallel' is the ticket count\n+ * The test will set 'jdk.tls.server.NewSessionTicketCount` to that number and\n+ * will start the same number of resumption client attempts. The ticket count\n+ * must be the same or larger than resumption attempts otherwise the queue runs\n+ * empty and the test will fail.\n+ *\n+ * Because this test runs parallel connections, the thread order finish is not\n+ * guaranteed.  Each client NST id is checked with all server NSTs ids until\n+ * a match is found.  When a match is found, it is removed from the list to\n+ * verify no NST was used more than once.\n+ *\n+ * TLS 1.2 spec does not specify multiple NST behavior.\n+ *\/\n+\n+public class MultiNSTParallel {\n+\n+    static HexFormat hex = HexFormat.of();\n+    final static CountDownLatch wait = new CountDownLatch(1);\n+\n+    static class ClientThread extends Thread {\n+        TLSBase.Client client;\n+\n+        ClientThread(TLSBase.Client c) {\n+            client = c;\n+        }\n+\n+        public void run() {\n+            String name = Thread.currentThread().getName();\n+            SSLSession r;\n+            System.err.println(\"waiting \" + Thread.currentThread().getName());\n+            try {\n+                wait.await();\n+                r = new TLSBase.Client(client).connect().getSession();\n+            } catch (Exception e) {\n+                throw new RuntimeException(name + \": \" +e);\n+            }\n+            StringBuffer sb = new StringBuffer(100);\n+            sb.append(\"(\").append(name).append(\") id = \");\n+            sb.append(hex.formatHex(r.getId()));\n+            sb.append(\"\\n(\").append(name).append(\") session = \").append(r);\n+            if (!client.getSession().toString().equalsIgnoreCase(r.toString())) {\n+                throw new RuntimeException(\"(\" + name +\n+                    \") Resumed session did not match\");\n+            }\n+        }\n+    }\n+\n+    static boolean pass = true;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            int ticketCount = Integer.parseInt(args[0]);\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 1; i < args.length; i++) {\n+                sb.append(\" \").append(args[i]);\n+            }\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" +\n+                    \" -Djdk.tls.server.newSessionTicketCount=\" + ticketCount +\n+                    params);\n+\n+            boolean TLS13 = args[1].contains(\"1.3\");\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTParallel\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> sp = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> serverPSK = new ArrayList<>(sp.stream().toList());\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+\n+                \/\/ Must search all results as order is not guaranteed.\n+                clientPSK.stream().forEach(cli -> {\n+                    for (int i = 0; i < serverPSK.size(); i++) {\n+                        String svr = serverPSK.get(i);\n+                        if (svr.regionMatches(svr.length() - 16, cli,\n+                            cli.length() - 16, 16)) {\n+                            System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                            serverPSK.remove(i);\n+                            return;\n+                        }\n+                    }\n+                    System.out.println(\"client entry (\" + cli.substring(0, 16) +\n+                        \") not found in server list\");\n+                    pass = false;\n+                });\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Error looking at PSK results.\");\n+                throw new Exception(e);\n+            }\n+\n+            if (TLS13) {\n+                if (!pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            } else {\n+                if (pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        int ticketCount = Integer.parseInt(\n+            System.getProperty(\"jdk.tls.server.newSessionTicketCount\"));\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Start connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        SSLSession initialSession = initial.getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  getNewSession from original client\");\n+\n+        ArrayList<Thread> slist = new ArrayList<>(ticketCount);\n+\n+        System.out.println(\"tx \" + ticketCount);\n+        for (int i = 0; ticketCount > i; i++) {\n+            Thread t = new ClientThread(initial);\n+            t.setName(\"Iteration \" + i);\n+            slist.add(t);\n+            t.start();\n+        }\n+\n+        wait.countDown();\n+        for (Thread t : slist) {\n+            t.join(1000);\n+            System.err.println(\"released: \" + t.getName());\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTParallel.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies sequence of used NST entries from the cache queue.\n+ * @run main\/othervm MultiNSTSequence -Djdk.tls.server.newSessionTicketCount=2\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+\/**\n+ * This test verifies that multiple NSTs take the oldest PSK from the\n+ * QueueCacheEntry stored in the TLS Session Cache.\n+ *\n+ * Note: Beyond 9 iterations the PSK id verification code becomes complicated\n+ * with a QueueCacheEntry limit set to retain only the 10 newest entries.\n+ *\n+ * TLS 1.2 spec does not specify multiple NST behavior.\n+ *\/\n+\n+public class MultiNSTSequence {\n+\n+    static HexFormat hex = HexFormat.of();\n+    static final int ITERATIONS = 9;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> sb.append(a).append(\" \"));\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params\n+                              );\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTSequence\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            boolean pass = true;\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> serverPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                int i;\n+                for (i = 0; i < ITERATIONS; i++) {\n+                    String svr = serverPSK.get(i);\n+                    String cli = clientPSK.get(i);\n+                    if (svr.regionMatches(svr.length() - 16, cli, cli.length() - 16, 16)) {\n+                        System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                    } else {\n+                        System.out.println(\"entry \" + (i + 1) + \" server and client PSK didn't match:\");\n+                        System.out.println(\"  server: \" + svr);\n+                        System.out.println(\"  client: \" + cli);\n+                        pass = false;\n+                    }\n+                }\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Server and Client PSK usage order is not\" +\n+                    \" the same.\");\n+                pass = false;\n+            }\n+\n+            if (!pass) {\n+                throw new Exception(\"Test failed: \" + params);\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Initial connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+\n+        SSLSession initialSession = initial.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  Resume client\");\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            SSLSession r = new TLSBase.Client(initial).connect().getSession();\n+            StringBuilder sb = new StringBuilder(100);\n+            sb.append(\"Iteration: \").append(i);\n+            sb.append(\"\\tid = \").append(hex.formatHex(r.getId()));\n+            sb.append(\"\\tsession = \").append(r);\n+            System.out.println(sb);\n+            if (!initialSession.toString().equalsIgnoreCase(r.toString())) {\n+                throw new Exception(\"Resumed session did not match\");\n+            }\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTSequence.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976 8324859\n@@ -2486,0 +2486,531 @@\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion1() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              return true;\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             return true;\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion2() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }                       \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion2: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion3() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion3: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion4() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          }\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion4: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion5() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test(String,\n+                      }\n+                      class T {}\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:38:compiler.err.expected\",\n+                             \"4:1:compiler.err.illegal.start.of.type\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test(String <error>, (ERROR: ) <error>);\n+                     }\n+                     class T {\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion6() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          private Object testMethod(final String arg1 final String arg2) {\n+                              return null;\n+                          }\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:48:compiler.err.expected3\",\n+                             \"3:66:compiler.err.expected\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         private Object testMethod(final String arg1);\n+                         final String arg2;\n+                         {\n+                             return null;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion7() throws IOException {\n+        \/\/after 'default' attribute value, only semicolon (';') is expected,\n+        \/\/not left brace ('{'):\n+        String code = \"\"\"\n+                      package tests;\n+                      public @interface A {\n+                          public String value() default \"\"\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:37:compiler.err.expected\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public @interface A {\n+                         \\n\\\n+                         public String value() default \"\";\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion10() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              String s = \"\";\n+                              return s.isEmpty();\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             String s = \"\";\n+                             return s.isEmpty();\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion11() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          String s = \"\"; \/\/field declaration\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         String s = \"\";\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion12() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              final String s = \"\";\n+                              return s.isEmpty();\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             final String s = \"\";\n+                             return s.isEmpty();\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion13() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          final String s = \"\"; \/\/field declaration?\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         final String s = \"\";\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion14() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              String s = \"\";\n+                              s.length();\n+                              if (true); \/\/force parse as block\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\",\n+                             \"7:5:compiler.err.illegal.start.of.expr\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             String s = \"\";\n+                             s.length();\n+                             if (true) ;\n+                             (ERROR: );\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":532,"deletions":1,"binary":false,"changes":533,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301580 8322159 8333107 8332230\n+ * @bug 8301580 8322159 8333107 8332230 8338678\n@@ -37,0 +37,5 @@\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n@@ -38,0 +43,1 @@\n+import java.util.IdentityHashMap;\n@@ -39,0 +45,1 @@\n+import java.util.Map;\n@@ -40,0 +47,7 @@\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.tools.Diagnostic;\n@@ -237,0 +251,76 @@\n+    @Test\n+    public void testParameterizedErroneousType() throws Exception {\n+        String code = \"\"\"\n+                      public class C {\n+                          Undefined1<Undefined2, Undefined3> variable1;\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .callback(task -> {\n+                    task.addTaskListener(new TaskListener() {\n+                        @Override\n+                        public void finished(TaskEvent e) {\n+                            Trees trees = Trees.instance(task);\n+\n+                            if (e.getKind() == TaskEvent.Kind.ANALYZE) {\n+                                new TreePathScanner<Void, Void>() {\n+                                    @Override\n+                                    public Void visitVariable(VariableTree tree, Void p) {\n+                                        VariableElement var = (VariableElement) trees.getElement(getCurrentPath());\n+\n+                                        trees.printMessage(Diagnostic.Kind.NOTE, type2String(var.asType()), tree, e.getCompilationUnit());\n+\n+                                        return super.visitVariable(tree, p);\n+                                    }\n+                                }.scan(e.getCompilationUnit(), null);\n+                            }\n+                        }\n+                        Map<Element, Integer> identityRename = new IdentityHashMap<>();\n+                        String type2String(TypeMirror type) {\n+                            StringBuilder result = new StringBuilder();\n+\n+                            result.append(type.getKind());\n+                            result.append(\":\");\n+                            result.append(type.toString());\n+\n+                            if (type.getKind() == TypeKind.DECLARED ||\n+                                type.getKind() == TypeKind.ERROR) {\n+                                DeclaredType dt = (DeclaredType) type;\n+                                Element el = task.getTypes().asElement(dt);\n+                                result.append(\":\");\n+                                result.append(el.toString());\n+                                if (!dt.getTypeArguments().isEmpty()) {\n+                                    result.append(dt.getTypeArguments()\n+                                                    .stream()\n+                                                    .map(tm -> type2String(tm))\n+                                                    .collect(Collectors.joining(\", \", \"<\", \">\")));\n+                                }\n+                            } else {\n+                                throw new AssertionError(type.getKind().name());\n+                            }\n+\n+                            return result.toString();\n+                        }\n+                    });\n+                })\n+                .run(Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"C.java:2:5: compiler.err.cant.resolve.location: kindname.class, Undefined1, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:16: compiler.err.cant.resolve.location: kindname.class, Undefined2, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:28: compiler.err.cant.resolve.location: kindname.class, Undefined3, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:40: compiler.note.proc.messager: ERROR:Undefined1<Undefined2,Undefined3>:Undefined1<ERROR:Undefined2:Undefined2, ERROR:Undefined3:Undefined3>\",\n+                \"3 errors\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":91,"deletions":1,"binary":false,"changes":92,"status":"modified"}]}