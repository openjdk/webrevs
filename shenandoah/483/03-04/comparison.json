{"files":[{"patch":"@@ -281,0 +281,12 @@\n+$(eval $(call SetupTarget, hotspot-xcode-project, \\\n+    MAKEFILE := ide\/xcode\/hotspot\/CreateXcodeProject, \\\n+    TARGET := build, \\\n+    DEPS := hotspot compile-commands-hotspot jdk-image, \\\n+))\n+\n+$(eval $(call SetupTarget, open-hotspot-xcode-project, \\\n+    MAKEFILE := ide\/xcode\/hotspot\/CreateXcodeProject, \\\n+    TARGET := open, \\\n+    DEPS := hotspot-xcode-project, \\\n+))\n+\n","filename":"make\/Main.gmk","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -192,0 +192,5 @@\n+define copy-and-chmod-executable\n+\t$(install-file)\n+\t$(CHMOD) a+rx $@\n+endef\n+\n","filename":"make\/common\/FileUtils.gmk","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-    $1 := $$($1_ALL_OBJS_JSON)\n+    $1 := $$($1_ALL_OBJS_JSON) $$($1_LDFLAGS_FILE)\n","filename":"make\/common\/NativeCompilation.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,0 +201,12 @@\n+\n+  # This is for IDE integration purposes only, and is not normally generated\n+  $1_LDFLAGS_FILE := $$(MAKESUPPORT_OUTPUTDIR)\/compile-commands\/$$($1_NAME)-ldflags.txt\n+\n+  $1_ALL_LD_ARGS := $$($1_LDFLAGS) $$($1_EXTRA_LDFLAGS) $$($1_SYSROOT_LDFLAGS) \\\n+      $$($1_LIBS) $$($1_EXTRA_LIBS)\n+\n+  $$($1_LDFLAGS_FILE): $$($1_VARDEPS_FILE)\n+\t$$(call LogInfo, Creating compile commands linker flags output for $$($1_BASENAME))\n+\t$$(call MakeDir, $$(dir $$@))\n+\t$$(ECHO) $$($1_ALL_LD_ARGS) > $$@\n+\n","filename":"make\/common\/native\/Link.gmk","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-    java.datatransfer \\\n@@ -100,1 +99,0 @@\n-    java.logging \\\n@@ -102,3 +100,0 @@\n-    java.management.rmi \\\n-    java.naming \\\n-    java.net.http \\\n@@ -107,2 +102,0 @@\n-    java.scripting \\\n-    java.se \\\n@@ -110,1 +103,0 @@\n-    java.security.sasl \\\n@@ -112,5 +104,0 @@\n-    java.sql \\\n-    java.sql.rowset \\\n-    java.transaction.xa \\\n-    java.xml \\\n-    java.xml.crypto \\\n@@ -118,1 +105,1 @@\n-    jdk.charsets \\\n+    jdk.attach \\\n@@ -120,3 +107,2 @@\n-    jdk.dynalink \\\n-    jdk.httpserver \\\n-    jdk.incubator.vector \\\n+    jdk.crypto.mscapi \\\n+    jdk.hotspot.agent \\\n@@ -125,0 +111,1 @@\n+    jdk.jdi \\\n@@ -126,2 +113,1 @@\n-    jdk.jsobject \\\n-    jdk.localedata \\\n+    jdk.jpackage \\\n@@ -130,3 +116,0 @@\n-    jdk.management.jfr \\\n-    jdk.naming.dns \\\n-    jdk.naming.rmi \\\n@@ -134,1 +117,0 @@\n-    jdk.nio.mapmode \\\n@@ -137,4 +119,0 @@\n-    jdk.security.jgss \\\n-    jdk.unsupported \\\n-    jdk.xml.dom \\\n-    jdk.zipfs \\\n","filename":"make\/conf\/module-loader-map.conf","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-  TOOLS_OUTPUTDIR := $(HOTSPOT_OUTPUTDIR)\/support\/ide_classes\n+  TOOLS_OUTPUTDIR := $(MAKESUPPORT_OUTPUTDIR)\/ide\/visualstudio\n","filename":"make\/ide\/visualstudio\/hotspot\/CreateVSProject.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+#\n+# Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# This must be the first rule\n+default: all\n+\n+include $(SPEC)\n+include MakeBase.gmk\n+include CopyFiles.gmk\n+include Execute.gmk\n+include JavaCompilation.gmk\n+\n+ifeq ($(call isTargetOs, macosx), true)\n+  ##############################################################################\n+  # Build the XcodeProjectMaker java tool.\n+\n+  PROJECT_MAKER_DIR := $(TOPDIR)\/make\/ide\/xcode\/hotspot\n+  TOOLS_OUTPUTDIR := $(MAKESUPPORT_OUTPUTDIR)\/ide\/xcode\n+  IDE_OUTPUTDIR := $(OUTPUTDIR)\/xcode\n+  PROJECT_FILE_NAME := hotspot.xcodeproj\n+\n+  COMPILE_COMMAND_FILE := $(OUTPUTDIR)\/compile_commands.json\n+  LINKER_FLAGS_FILE := $(MAKESUPPORT_OUTPUTDIR)\/compile-commands\/jvm-ldflags.txt\n+\n+  $(eval $(call SetupJavaCompilation, BUILD_PROJECT_CREATOR, \\\n+      TARGET_RELEASE := $(TARGET_RELEASE_BOOTJDK), \\\n+      SRC := $(PROJECT_MAKER_DIR)\/src\/classes, \\\n+      BIN := $(TOOLS_OUTPUTDIR), \\\n+      DISABLED_WARNINGS := rawtypes unchecked serial, \\\n+  ))\n+\n+  TARGETS += $(BUILD_PROJECT_CREATOR)\n+\n+  # Run the XcodeProjectMaker tool\n+  PROJECT_CREATOR_TOOL := $(JAVA_SMALL) -cp $(TOOLS_OUTPUTDIR) XcodeProjectMaker\n+\n+  ifneq ($(findstring $(LOG_LEVEL), debug trace), )\n+    XCODE_PROJ_DEBUG_OPTION := -d\n+  endif\n+\n+  XCODE_PROJ_VARDEPS := $(WORKSPACE_ROOT) $(IDE_OUTPUTDIR) \\\n+      $(PROJECT_MAKER_DIR)\/data $(COMPILE_COMMAND_FILE) $(LINKER_FLAGS_FILE)\n+  XCODE_PROJ_VARDEPS_FILE := $(call DependOnVariable, XCODE_PROJ_VARDEPS, \\\n+    $(TOOLS_OUTPUTDIR)\/xcodeproj.vardeps)\n+\n+  $(eval $(call SetupExecute, build_xcode_project, \\\n+      WARN := Generating Xcode project file, \\\n+      DEPS := $(BUILD_PROJECT_CREATOR) $(COMPILE_COMMAND_FILE) \\\n+          $(LINKER_FLAGS_FILE) $(XCODE_PROJ_VARDEPS_FILE), \\\n+      OUTPUT_DIR := $(TOOLS_OUTPUTDIR), \\\n+      COMMAND := $(PROJECT_CREATOR_TOOL) $(WORKSPACE_ROOT) $(IDE_OUTPUTDIR) \\\n+          $(PROJECT_MAKER_DIR)\/data $(COMPILE_COMMAND_FILE) \\\n+          $(LINKER_FLAGS_FILE) $(XCODE_PROJ_DEBUG_OPTION), \\\n+  ))\n+\n+  TARGETS += $(build_xcode_project)\n+\n+  $(eval $(call SetupCopyFiles, copy_xcode_project, \\\n+      DEST := $(IDE_OUTPUTDIR), \\\n+      FILES := $(PROJECT_MAKER_DIR)\/data\/script_before.sh $(PROJECT_MAKER_DIR)\/data\/script_after.sh , \\\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n+\n+  TARGETS += $(copy_xcode_project)\n+\n+  $(eval $(call SetupExecute, open_xcode_project, \\\n+      INFO := Opening Xcode project file, \\\n+      DEPS := $(build_xcodeproject_TARGET) FORCE, \\\n+      OUTPUT_DIR := $(TOOLS_OUTPUTDIR), \\\n+      COMMAND := open $(IDE_OUTPUTDIR)\/$(PROJECT_FILE_NAME), \\\n+  ))\n+\n+  TARGETS += $(open_xcode_project)\n+\n+  # Always call open without considering dependencies being up to date\n+  FORCE:\n+\n+  build: $(build_xcode_project) $(copy_xcode_project)\n+\n+  open: $(open_xcode_project)\n+\n+  all: $(TARGETS)\n+else\n+  build:\n+  open:\n+  all:\n+\t$(info Xcode projects are only supported on macOS)\n+endif\n+\n+.PHONY: default all build open\n","filename":"make\/ide\/xcode\/hotspot\/CreateXcodeProject.gmk","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Bucket\n+   type = \"4\"\n+   version = \"2.0\">\n+   <Breakpoints>\n+      <BreakpointProxy\n+         BreakpointExtensionID = \"Xcode.Breakpoint.SymbolicBreakpoint\">\n+         <BreakpointContent\n+            shouldBeEnabled = \"Yes\"\n+            ignoreCount = \"0\"\n+            continueAfterRunningActions = \"Yes\"\n+            symbolName = \"load_jimage_library\"\n+            moduleName = \"libjvm.dylib\">\n+            <Actions>\n+               <BreakpointActionProxy\n+                  ActionExtensionID = \"Xcode.BreakpointAction.DebuggerCommand\">\n+                  <ActionContent\n+                     consoleCommand = \"process handle -n true -p true -s false SIGSEGV SIGBUS SIGUSR2\">\n+                  <\/ActionContent>\n+               <\/BreakpointActionProxy>\n+            <\/Actions>\n+            <Locations>\n+               <Location\n+                  shouldBeEnabled = \"Yes\"\n+                  ignoreCount = \"0\"\n+                  continueAfterRunningActions = \"No\"\n+                  symbolName = \"ClassLoader::load_jimage_library()\"\n+                  moduleName = \"libjvm.dylib\"\n+                  usesParentBreakpointCondition = \"Yes\"\n+                  timestampString = \"0\"\n+                  startingColumnNumber = \"0\"\n+                  endingColumnNumber = \"0\"\n+                  startingLineNumber = \"0\"\n+                  endingLineNumber = \"0\"\n+                  offsetFromSymbolStart = \"0\">\n+               <\/Location>\n+            <\/Locations>\n+         <\/BreakpointContent>\n+      <\/BreakpointProxy>\n+   <\/Breakpoints>\n+<\/Bucket>\n","filename":"make\/ide\/xcode\/hotspot\/data\/Breakpoints_v2.xcbkptlist.template","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Scheme\n+   LastUpgradeVersion = \"0900\"\n+   version = \"1.3\">\n+   <BuildAction\n+      parallelizeBuildables = \"YES\"\n+      buildImplicitDependencies = \"YES\">\n+      <BuildActionEntries>\n+         <BuildActionEntry\n+            buildForTesting = \"YES\"\n+            buildForRunning = \"YES\"\n+            buildForProfiling = \"NO\"\n+            buildForArchiving = \"NO\"\n+            buildForAnalyzing = \"YES\">\n+            <BuildableReference\n+               BuildableIdentifier = \"primary\"\n+               BlueprintIdentifier = \"D60000000000000000000000\"\n+               BuildableName = \"libjvm.dylib\"\n+               BlueprintName = \"jvm\"\n+               ReferencedContainer = \"container:hotspot.xcodeproj\">\n+            <\/BuildableReference>\n+         <\/BuildActionEntry>\n+      <\/BuildActionEntries>\n+   <\/BuildAction>\n+   <TestAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\">\n+      <Testables>\n+      <\/Testables>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/TestAction>\n+   <LaunchAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      launchStyle = \"0\"\n+      useCustomWorkingDirectory = \"NO\"\n+      ignoresPersistentStateOnLaunch = \"NO\"\n+      debugDocumentVersioning = \"YES\"\n+      debugServiceExtension = \"internal\"\n+      allowLocationSimulation = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <CommandLineArguments>\n+         <CommandLineArgument\n+            argument = \"-version\"\n+            isEnabled = \"YES\">\n+         <\/CommandLineArgument>\n+      <\/CommandLineArguments>\n+      <EnvironmentVariables>\n+         <EnvironmentVariable\n+            key = \"DYLD_PRINT_ENV\"\n+            value = \"1\"\n+            isEnabled = \"YES\">\n+         <\/EnvironmentVariable>\n+      <\/EnvironmentVariables>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/LaunchAction>\n+   <ProfileAction\n+      buildConfiguration = \"Release\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\"\n+      savedToolIdentifier = \"\"\n+      useCustomWorkingDirectory = \"NO\"\n+      debugDocumentVersioning = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+   <\/ProfileAction>\n+   <AnalyzeAction\n+      buildConfiguration = \"Release\">\n+   <\/AnalyzeAction>\n+   <ArchiveAction\n+      buildConfiguration = \"Release\"\n+      revealArchiveInOrganizer = \"YES\">\n+   <\/ArchiveAction>\n+<\/Scheme>\n","filename":"make\/ide\/xcode\/hotspot\/data\/jvm.xcscheme.template","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,207 @@\n+\/\/ !$*UTF8*$!\n+{\n+\tarchiveVersion = 1;\n+\tclasses = {\n+\t};\n+\tobjectVersion = 48;\n+\tobjects = {\n+\n+\/* Begin PBXBuildFile section *\/\n+TEMPLATE_PBXBUILDFILE\n+\/* End PBXBuildFile section *\/\n+\n+\/* Begin PBXFileReference section *\/\n+\t\tD60000000000000000000003 \/* script_before.sh *\/ = {isa = PBXFileReference; lastKnownFileType = text.script.sh; path = script_before.sh; sourceTree = \"<group>\"; };\n+\t\tD60000000000000000000002 \/* script_after.sh *\/ = {isa = PBXFileReference; lastKnownFileType = text.script.sh; path = script_after.sh; sourceTree = \"<group>\"; };\n+\t\tD60000000000000000000006 \/* libjvm.dylib *\/ = {isa = PBXFileReference; explicitFileType = \"compiled.mach-o.dylib\"; includeInIndex = 0; path = libjvm.dylib; sourceTree = BUILT_PRODUCTS_DIR; };\n+TEMPLATE_PBXFILEREFERENCE\n+\/* End PBXFileReference section *\/\n+\n+\/* Begin PBXGroup section *\/\n+\t\tD60000000000000000000004 \/* scripts *\/ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tD60000000000000000000003 \/* script_before.sh *\/,\n+\t\t\t\tD60000000000000000000002 \/* script_after.sh *\/,\n+\t\t\t);\n+\t\t\tname = scripts;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\tD60000000000000000000005 \/* Products *\/ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tD60000000000000000000006 \/* libjvm.dylib *\/,\n+\t\t\t);\n+\t\t\tname = Products;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\tD60000000000000000000001 = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tD60000000000000000000004 \/* scripts *\/,\n+TEMPLATE_GROUP_GENSRC \/* gensrc *\/,\n+TEMPLATE_GROUP_SRC \/* src *\/,\n+TEMPLATE_GROUP_TEST \/* test *\/,\n+\t\t\t\tD60000000000000000000005 \/* Products *\/,\n+\t\t\t);\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+TEMPLATE_GROUPS\n+\/* End PBXGroup section *\/\n+\n+\/* Begin PBXNativeTarget section *\/\n+\t\tD60000000000000000000000 \/* jvm *\/ = {\n+\t\t\tisa = PBXNativeTarget;\n+\t\t\tbuildConfigurationList = D6000000000000000000000F \/* Build configuration list for PBXNativeTarget \"jvm\" *\/;\n+\t\t\tbuildPhases = (\n+\t\t\t\tD60000000000000000000007 \/* Run script_before *\/,\n+\t\t\t\tD60000000000000000000008 \/* Sources *\/,\n+\t\t\t\tD6000000000000000000000A \/* Run script_after *\/,\n+\t\t\t);\n+\t\t\tbuildRules = (\n+\t\t\t);\n+\t\t\tdependencies = (\n+\t\t\t);\n+\t\t\tname = jvm;\n+\t\t\tproductName = jvm;\n+\t\t\tproductReference = D60000000000000000000006 \/* libjvm.dylib *\/;\n+\t\t\tproductType = \"com.apple.product-type.library.dynamic\";\n+\t\t};\n+\/* End PBXNativeTarget section *\/\n+\n+\/* Begin PBXProject section *\/\n+\t\tD60000000000000000000010 \/* Project object *\/ = {\n+\t\t\tisa = PBXProject;\n+\t\t\tattributes = {\n+\t\t\t\tLastUpgradeCheck = 0900;\n+\t\t\t\tORGANIZATIONNAME = Oracle;\n+\t\t\t\tTargetAttributes = {\n+\t\t\t\t\tD60000000000000000000000 = {\n+\t\t\t\t\t\tCreatedOnToolsVersion = 9.0;\n+\t\t\t\t\t\tProvisioningStyle = Automatic;\n+\t\t\t\t\t};\n+\t\t\t\t};\n+\t\t\t};\n+\t\t\tbuildConfigurationList = D6000000000000000000000E \/* Build configuration list for PBXProject \"jvm\" *\/;\n+\t\t\tcompatibilityVersion = \"Xcode 8.0\";\n+\t\t\tdevelopmentRegion = en;\n+\t\t\thasScannedForEncodings = 0;\n+\t\t\tknownRegions = (\n+\t\t\t\ten,\n+\t\t\t);\n+\t\t\tmainGroup = D60000000000000000000001;\n+\t\t\tproductRefGroup = D60000000000000000000005 \/* Products *\/;\n+\t\t\tprojectDirPath = \"\";\n+\t\t\tprojectRoot = \"\";\n+\t\t\ttargets = (\n+\t\t\t\tD60000000000000000000000 \/* jvm *\/,\n+\t\t\t);\n+\t\t};\n+\/* End PBXProject section *\/\n+\n+\/* Begin PBXShellScriptBuildPhase section *\/\n+\t\tD60000000000000000000007 \/* Run script_before *\/ = {\n+\t\t\tisa = PBXShellScriptBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\tinputPaths = (\n+\t\t\t);\n+\t\t\tname = \"Run script_before\";\n+\t\t\toutputPaths = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t\tshellPath = \/bin\/sh;\n+\t\t\tshellScript = \"cd $PROJECT_DIR;\\ntime .\/script_before.sh;\\n\";\n+\t\t};\n+\t\tD6000000000000000000000A \/* Run script_after *\/ = {\n+\t\t\tisa = PBXShellScriptBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\tinputPaths = (\n+\t\t\t);\n+\t\t\tname = \"Run script_after\";\n+\t\t\toutputPaths = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t\tshellPath = \/bin\/sh;\n+\t\t\tshellScript = \"cd $PROJECT_DIR;\\ntime .\/script_after.sh;\\n\";\n+\t\t};\n+\/* End PBXShellScriptBuildPhase section *\/\n+\n+\/* Begin PBXSourcesBuildPhase section *\/\n+\t\tD60000000000000000000008 \/* Sources *\/ = {\n+\t\t\tisa = PBXSourcesBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+TEMPLATE_PBXSOURCESSBUILDPHASE\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t};\n+\/* End PBXSourcesBuildPhase section *\/\n+\n+\/* Begin XCBuildConfiguration section *\/\n+\t\tD6000000000000000000000B \/* Release *\/ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tALWAYS_SEARCH_USER_PATHS = YES;\n+\t\t\t\tCLANG_CXX_LANGUAGE_STANDARD = \"gnu++14\";\n+\t\t\t\tCODE_SIGN_IDENTITY = \"-\";\n+\t\t\t\tCONFIGURATION_BUILD_DIR = build\/jdk\/lib\/server;\n+\t\t\t\tCONFIGURATION_TEMP_DIR = build;\n+\t\t\t\tCOPY_PHASE_STRIP = NO;\n+\t\t\t\tDEBUG_INFORMATION_FORMAT = \"dwarf-with-dsym\";\n+\t\t\t\tMTL_ENABLE_DEBUG_INFO = NO;\n+\t\t\t\tOBJROOT = build;\n+\t\t\t\tONLY_ACTIVE_ARCH = YES;\n+\t\t\t\tSDKROOT = macosx;\n+\t\t\t};\n+\t\t\tname = Release;\n+\t\t};\n+\t\tD6000000000000000000000D \/* Release *\/ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tCONFIGURATION_BUILD_DIR = \"$(BUILD_DIR)\";\n+\t\t\t\tEXECUTABLE_PREFIX = lib;\n+\t\t\t\tFRAMEWORK_SEARCH_PATHS = (\n+TEMPLATE_FRAMEWORK_SEARCH_PATHS\n+\t\t\t\t);\n+\t\t\t\tOTHER_CFLAGS = (\n+TEMPLATE_OTHER_CFLAGS\n+\t\t\t\t);\n+\t\t\t\tOTHER_LDFLAGS = (\n+TEMPLATE_OTHER_LDFLAGS\n+\t\t\t\t);\n+\t\t\t\tPRODUCT_NAME = \"$(TARGET_NAME)\";\n+\t\t\t\tSKIP_INSTALL = YES;\n+\t\t\t\tSYMROOT = build\/jdk\/lib\/server;\n+\t\t\t\tUSER_HEADER_SEARCH_PATHS = (\n+TEMPLATE_USER_HEADER_SEARCH_PATHS\n+\t\t\t\t);\n+\t\t\t};\n+\t\t\tname = Release;\n+\t\t};\n+\/* End XCBuildConfiguration section *\/\n+\n+\/* Begin XCConfigurationList section *\/\n+\t\tD6000000000000000000000E \/* Build configuration list for PBXProject \"jvm\" *\/ = {\n+\t\t\tisa = XCConfigurationList;\n+\t\t\tbuildConfigurations = (\n+\t\t\t\tD6000000000000000000000B \/* Release *\/,\n+\t\t\t);\n+\t\t\tdefaultConfigurationIsVisible = 0;\n+\t\t\tdefaultConfigurationName = Release;\n+\t\t};\n+\t\tD6000000000000000000000F \/* Build configuration list for PBXNativeTarget \"jvm\" *\/ = {\n+\t\t\tisa = XCConfigurationList;\n+\t\t\tbuildConfigurations = (\n+\t\t\t\tD6000000000000000000000D \/* Release *\/,\n+\t\t\t);\n+\t\t\tdefaultConfigurationIsVisible = 0;\n+\t\t\tdefaultConfigurationName = Release;\n+\t\t};\n+\/* End XCConfigurationList section *\/\n+\t};\n+\trootObject = D60000000000000000000010 \/* Project object *\/;\n+}\n","filename":"make\/ide\/xcode\/hotspot\/data\/project.pbxproj.template","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Scheme\n+   LastUpgradeVersion = \"0900\"\n+   version = \"1.3\">\n+   <BuildAction\n+      parallelizeBuildables = \"YES\"\n+      buildImplicitDependencies = \"YES\">\n+      <BuildActionEntries>\n+         <BuildActionEntry\n+            buildForTesting = \"YES\"\n+            buildForRunning = \" NO\"\n+            buildForProfiling = \"NO\"\n+            buildForArchiving = \"NO\"\n+            buildForAnalyzing = \"NO\">\n+            <BuildableReference\n+               BuildableIdentifier = \"primary\"\n+               BlueprintIdentifier = \"D60000000000000000000000\"\n+               BuildableName = \"libjvm.dylib\"\n+               BlueprintName = \"jvm\"\n+               ReferencedContainer = \"container:hotspot.xcodeproj\">\n+            <\/BuildableReference>\n+         <\/BuildActionEntry>\n+      <\/BuildActionEntries>\n+   <\/BuildAction>\n+   <TestAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\">\n+      <Testables>\n+      <\/Testables>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/TestAction>\n+   <LaunchAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      launchStyle = \"0\"\n+      useCustomWorkingDirectory = \"NO\"\n+      ignoresPersistentStateOnLaunch = \"NO\"\n+      debugDocumentVersioning = \"YES\"\n+      debugServiceExtension = \"internal\"\n+      allowLocationSimulation = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <CommandLineArguments>\n+         <CommandLineArgument\n+            argument = \"-jar TEMPLATE_JDK_PATH\/build\/jdk\/demo\/jfc\/J2Ddemo\/J2Ddemo.jar\"\n+            isEnabled = \"YES\">\n+         <\/CommandLineArgument>\n+      <\/CommandLineArguments>\n+      <EnvironmentVariables>\n+         <EnvironmentVariable\n+            key = \"DYLD_PRINT_ENV\"\n+            value = \"1\"\n+            isEnabled = \"YES\">\n+         <\/EnvironmentVariable>\n+      <\/EnvironmentVariables>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/LaunchAction>\n+   <ProfileAction\n+      buildConfiguration = \"Release\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\"\n+      savedToolIdentifier = \"\"\n+      useCustomWorkingDirectory = \"NO\"\n+      debugDocumentVersioning = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+   <\/ProfileAction>\n+   <AnalyzeAction\n+      buildConfiguration = \"Release\">\n+   <\/AnalyzeAction>\n+   <ArchiveAction\n+      buildConfiguration = \"Release\"\n+      revealArchiveInOrganizer = \"YES\">\n+   <\/ArchiveAction>\n+<\/Scheme>\n","filename":"make\/ide\/xcode\/hotspot\/data\/runJ2Demo.xcscheme.template","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+echo \"running script_after.sh\"\n+\n+readonly JDK_LIB_PATH=\"build\/jdk\/lib\/server\/libjvm.dylib\";\n+\n+if [ ! -f ${JDK_LIB_PATH} ] ; then\n+{\n+    echo \">>>>>>>   Cannot find ${JDK_LIB_PATH}, the build failed!?\";\n+    exit 1;\n+}\n+fi\n","filename":"make\/ide\/xcode\/hotspot\/data\/script_after.sh","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+echo \"running script_before.sh\"\n+\n+readonly JDK_BUILD_PATH=\"..\";\n+readonly JAVAC_LOCATE_PATTERN=\"images\/jdk\/bin\/javac\";\n+readonly HOTSPOT_TOUCH_FILE=\"..\/..\/..\/src\/hotspot\/os\/posix\/jvm_posix.cpp\";\n+\n+echo \">>>>>>> Making a copy of JDK ...\";\n+\n+javac_file_array=( $(find ${JDK_BUILD_PATH} | grep ${JAVAC_LOCATE_PATTERN}) );\n+javac_file=${javac_file_array[0]};\n+if [ -z ${javac_file} ] ; then\n+{\n+  echo \">>>>>>>   ERROR: could not locate ${JAVAC_LOCATE_PATTERN} (did you remember to do \\\"make images\\\"?)\";\n+  exit 1;\n+}\n+fi\n+\n+jdk_build_path=$(dirname $(dirname ${javac_file}));\n+if [ ! -f \"build\/${JAVAC_LOCATE_PATTERN}\" ] ; then\n+{\n+  echo \">>>>>>>   Copying jdk over...\";\n+  rsync -a \"${jdk_build_path}\" \"build\/\";\n+}\n+fi\n+\n+# the following files will be supplied by the Xcode build\n+rm -rf \"build\/jdk\/lib\/server\/libjvm.dylib\";\n+rm -rf \"build\/jdk\/lib\/server\/libjvm.dylib.dSYM\";\n+\n+echo \">>>>>>> DONE\";\n+\n+echo \">>>>>>> Touching ${HOTSPOT_TOUCH_FILE} to force HotspotVM rebuilt\";\n+if [ ! -f ${HOTSPOT_TOUCH_FILE} ] ; then\n+{\n+    echo \">>>>>>>   Cannot find ${HOTSPOT_TOUCH_FILE}\";\n+    exit 1;\n+}\n+fi\n+touch ${HOTSPOT_TOUCH_FILE};\n+\n+echo \">>>>>>> DONE\";\n+\n+echo \">>>>>>> Xcode should be building the HotspotVM now...\";\n","filename":"make\/ide\/xcode\/hotspot\/data\/script_before.sh","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,291 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+public class DiskFile extends LinkedHashMap<Path, DiskFile> implements Comparable<DiskFile> {\n+    \/\/ xcode id ex: D50000000000000000000000\n+    private static long xcodeIdCount = 0xF0000001;\n+    private final Path path;\n+    private final boolean directory;\n+    private final String xcodeId;\n+    private final String xcodeId2;\n+    private Iterable<String> compilerFlags;\n+\n+    public DiskFile(String path, boolean directory) {\n+        this(stringToPath(path), directory);\n+    }\n+\n+    private DiskFile(Path path, boolean directory) {\n+        this.path = path;\n+        this.directory = directory;\n+        this.compilerFlags = null;\n+        this.xcodeId = getNextXcodeId();\n+        this.xcodeId2 = getNextXcodeId();\n+    }\n+\n+    private static Path stringToPath(String string) {\n+        if (string != null) {\n+            return new File(string).toPath();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static Path clipPath(Path path, String clip) {\n+        return clipPath(path.toString(), clip);\n+    }\n+\n+    private static Path clipPath(String path, String clip) {\n+        String subpath = path;\n+        if (path.contains(clip)) {\n+            subpath = clip;\n+        }\n+        int index = path.indexOf(subpath);\n+        return stringToPath(path.substring(index));\n+    }\n+\n+    private String getNextXcodeId() {\n+        String id = \"D5FFFFFF\" + Long.toHexString(xcodeIdCount).toUpperCase(Locale.ROOT);\n+        xcodeIdCount++;\n+\n+        return id;\n+    }\n+\n+    private String getPath() {\n+        return this.path.toString();\n+    }\n+\n+    public boolean isDirectory() {\n+        return this.directory;\n+    }\n+\n+    public void markAsCompiled(List<String> compilerFlags) {\n+        this.compilerFlags = compilerFlags;\n+    }\n+\n+    private boolean isCompiled() {\n+        return (this.compilerFlags != null);\n+    }\n+\n+    public String getXcodeId() {\n+        return this.xcodeId;\n+    }\n+\n+    public String generatePbxSourcesBuildPhase() {\n+        String string = \"\";\n+        if (isCompiled()) {\n+            String fileName = getFileName();\n+            string += String.format(\"        %s \/* %s in Sources *\/,\\n\", this.xcodeId2, fileName);\n+        } else if (isDirectory()) {\n+            for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+                DiskFile file = entry.getValue();\n+                string += file.generatePbxSourcesBuildPhase();\n+            }\n+        }\n+        return string;\n+    }\n+\n+    \/\/ D5FFFFFFFFFFFFFFF0006506 \/* vm_version.cpp in Sources *\/ = {isa = PBXBuildFile; fileRef = D5FFFFFFFFFFFFFFF0006505 \/* vm_version.cpp *\/; settings = {COMPILER_FLAGS = HEREHERE; }; };\n+    public String generatePbxBuildFile() {\n+        String string = \"\";\n+        if (isCompiled()) {\n+            String flagsString = \"\";\n+            for (String flag : this.compilerFlags) {\n+                flagsString += flag.replace(\"\\\"\", \"\\\\\\\\\\\"\") + \" \";\n+            }\n+            String fileName = getFileName();\n+            string += String.format(\"    %s \/* %s in Sources *\/ = {isa = PBXBuildFile; fileRef = %s \/* %s *\/; settings = {COMPILER_FLAGS = \\\"%s\\\"; }; };\\n\", this.xcodeId2, fileName, this.xcodeId, fileName, flagsString);\n+        } else if (isDirectory()) {\n+            for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+                DiskFile file = entry.getValue();\n+                string += file.generatePbxBuildFile();\n+            }\n+        }\n+        return string;\n+    }\n+\n+    public String generatePbxFileReference(String relativePathToRoot) {\n+        String string = \"\";\n+        if (!isDirectory()) {\n+            String fileName = getFileName();\n+            String suffix = getFileNameSuffix();\n+            string += String.format(\"    %s \/* %s *\/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = %s%s; name = %s; path = \\\"%s%s\\\"; sourceTree = \\\"<group>\\\"; };\\n\", this.xcodeId, fileName, fileName, suffix, fileName, relativePathToRoot, getPath());\n+        } else if (isDirectory()) {\n+            for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+                DiskFile file = entry.getValue();\n+                string += file.generatePbxFileReference(relativePathToRoot);\n+            }\n+        }\n+        return string;\n+    }\n+\n+    public String generatePbxGroup() {\n+        String string = String.format(\"    %s \/* %s *\/ = {\\n      isa = PBXGroup;\\n      children = (\\n\", this.xcodeId, getFileName());\n+\n+        Set<DiskFile> sortedSet = new TreeSet<>(values());\n+\n+        for (DiskFile file : sortedSet) {\n+            string += String.format(\"        %s \/* %s *\/,\\n\", file.getXcodeId(), file.getFileName());\n+        }\n+        string += String.format(\"      );\\n      name = %s;\\n      sourceTree = \\\"<group>\\\";\\n    };\\n\", getFileName());\n+\n+        for (DiskFile file : sortedSet) {\n+            if (file.isDirectory()) {\n+                string += file.generatePbxGroup();\n+            }\n+        }\n+\n+        return string;\n+    }\n+\n+    private ArrayList<DiskFile> getFiles(ArrayList<DiskFile> array) {\n+        for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+            DiskFile file = entry.getValue();\n+            if (file.isDirectory()) {\n+                array.add(file);\n+                array = file.getFiles(array);\n+            } else {\n+                array.add(file);\n+            }\n+        }\n+        return array;\n+    }\n+\n+    public ArrayList<DiskFile> getFiles() {\n+        return getFiles(new ArrayList<>());\n+    }\n+\n+    public String getFilePath() {\n+        return this.path.toString();\n+    }\n+\n+    private String getFileName() {\n+        Path fileName = this.path.getFileName();\n+        if (fileName != null) {\n+            return fileName.toString();\n+        } else {\n+            return this.path.toString();\n+        }\n+    }\n+\n+    private String getFileNameNoSuffix() {\n+        String string;\n+        Path fileName = this.path.getFileName();\n+        if (fileName != null) {\n+            string = fileName.toString();\n+            int index = string.indexOf('.');\n+            if (index >= 0) {\n+                string = string.substring(0, index);\n+            }\n+        } else {\n+            string = this.path.toString();\n+        }\n+        return string;\n+    }\n+\n+    private String getFileNameSuffix() {\n+        String fileName = getFileName();\n+        int index = fileName.indexOf('.');\n+        if (index >= 0) {\n+            return fileName.substring(index);\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    public DiskFile getChild(String fileName) {\n+        DiskFile child = null;\n+        for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+            DiskFile file = entry.getValue();\n+            if (file.getFileName().equals(fileName)) {\n+                child = entry.getValue();\n+                break;\n+            } else if (file.isDirectory()) {\n+                child = file.getChild(fileName);\n+                if (child != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        return child;\n+    }\n+\n+    private DiskFile getParent(Path path) {\n+        Path pathParent = path.getParent();\n+        DiskFile parent = get(pathParent);\n+        if (parent == null) {\n+            if (this.path.equals(pathParent)) {\n+                parent = this;\n+            } else {\n+                parent = getParent(pathParent).get(pathParent);\n+            }\n+            parent.putIfAbsent(path, new DiskFile(path, true));\n+        }\n+        return parent;\n+    }\n+\n+    public void addFile(Path path, String clip) {\n+        path = clipPath(path, clip);\n+        DiskFile parent = getParent(path);\n+        parent.put(path, new DiskFile(path, false));\n+    }\n+\n+    public void addDirectory(Path path, String clip) {\n+        path = clipPath(path, clip);\n+        DiskFile parent = getParent(path);\n+        parent.putIfAbsent(path, new DiskFile(path, true));\n+    }\n+\n+    @Override\n+    public int compareTo(DiskFile file) {\n+        \/\/ \".hpp\", then \".inline.hpp\", then \".cpp\"\n+        int equal = getFileNameNoSuffix().compareTo(file.getFileNameNoSuffix());\n+        if (equal == 0) {\n+            String suffix1 = getFileNameSuffix();\n+            String suffix2 = file.getFileNameSuffix();\n+            if (!suffix1.equals(\".inline.hpp\") && !suffix2.equals(\".inline.hpp\")) {\n+                \/\/ .hpp before .cpp\n+                equal = -(getFileNameSuffix().compareTo(file.getFileNameSuffix()));\n+            } else if (suffix1.equals(\".inline.hpp\") && suffix2.equals(\".hpp\")) {\n+                return 1;\n+            } else if (suffix1.equals(\".inline.hpp\") && suffix2.equals(\".cpp\")) {\n+                return -1;\n+            } else if (suffix1.equals(\".hpp\") && suffix2.equals(\".inline.hpp\")) {\n+                return -1;\n+            } else if (suffix1.equals(\".cpp\") && suffix2.equals(\".inline.hpp\")) {\n+                return 1;\n+            }\n+        }\n+        return equal;\n+    }\n+}\n","filename":"make\/ide\/xcode\/hotspot\/src\/classes\/DiskFile.java","additions":291,"deletions":0,"binary":false,"changes":291,"status":"added"},{"patch":"@@ -0,0 +1,754 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystemLoopException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+public final class XcodeProjectMaker {\n+    private static final String JDK_SCRIPT_TOKEN_1 = \"configure\";\n+    private static final String JDK_SCRIPT_TOKEN_2 = \".jcheck\";\n+    private static final String COMPILER_LINE_HEADER = \"-I\";\n+    private static final String COMPILER_IFRAMEWORK = \"-iframework\";\n+    private static final String COMPILER_FFRAMEWORK = \"-F\";\n+    private static final String SRC_HOTSPOT_PATH = \"\/src\/hotspot\";\n+    private static final String TEST_HOTSPOT_PATH = \"\/test\/hotspot\/gtest\";\n+    private static final String ALIAS_JAVA_OLD = \"java_old.sh\";\n+    private static final String ALIAS_JAVA_NEW = \"java_new.sh\";\n+    private static final String JDK_BIN_JAVA = \"\/jdk\/bin\/java\";\n+    private static final String FILE_TOKEN = \"\\\"file\\\": \";\n+    private static final String COMMAND_TOKEN = \"\\\"command\\\": \";\n+    private static final String QUOTE_START_TOKEN = \"'\\\\\\\"\";\n+    private static final String QUOTE_END_TOKEN = \"\\\\\\\"'\";\n+    private static final String VERSION = \"2.0.0\";\n+    private static final String EXCLUDE_PARSE_TOKEN_1 = \"gtest\";\n+    private static final String TEMPLATE_FRAMEWORK_SEARCH_PATHS = \"TEMPLATE_FRAMEWORK_SEARCH_PATHS\";\n+    private static final String TEMPLATE_OTHER_CFLAGS = \"TEMPLATE_OTHER_CFLAGS\";\n+    private static final String TEMPLATE_OTHER_LDFLAGS = \"TEMPLATE_OTHER_LDFLAGS\";\n+    private static final String TEMPLATE_USER_HEADER_SEARCH_PATHS = \"TEMPLATE_USER_HEADER_SEARCH_PATHS\";\n+    private static final String TEMPLATE_GROUP_GENSRC = \"TEMPLATE_GROUP_GENSRC\";\n+    private static final String TEMPLATE_GROUP_SRC = \"TEMPLATE_GROUP_SRC\";\n+    private static final String TEMPLATE_GROUP_TEST = \"TEMPLATE_GROUP_TEST\";\n+    private static final String TEMPLATE_GROUPS = \"TEMPLATE_GROUPS\";\n+    private static final String TEMPLATE_PBXBUILDFILE = \"TEMPLATE_PBXBUILDFILE\";\n+    private static final String TEMPLATE_PBXFILEREFERENCE = \"TEMPLATE_PBXFILEREFERENCE\";\n+    private static final String TEMPLATE_PBXSOURCESSBUILDPHASE = \"TEMPLATE_PBXSOURCESSBUILDPHASE\";\n+    private static final String TEMPLATE_JDK_PATH = \"TEMPLATE_JDK_PATH\";\n+    private static final String HOTSPOT_PBXPROJ = \"hotspot.xcodeproj\";\n+    private static final String PBXPROJ = \"project.pbxproj\";\n+    private static final String XCSAHAREDDATA = \"xcshareddata\";\n+    private static final String XCSCHEMES = \"xcschemes\";\n+    private static final String JVM_XCSCHEME = \"jvm.xcscheme\";\n+    private static final String J2D_XCSCHEME = \"runJ2Demo.xcscheme\";\n+    private static final String XCDEBUGGER = \"xcdebugger\";\n+    private static final String XCBKPTLIST = \"Breakpoints_v2.xcbkptlist\";\n+    private static final String TEMPLATE_PBXPROJ = PBXPROJ + \".template\";\n+    private static final String TEMPLATE_JVM_XCSCHEME = JVM_XCSCHEME + \".template\";\n+    private static final String TEMPLATE_J2D_XCSCHEME = J2D_XCSCHEME + \".template\";\n+    private static final String TEMPLATE_XCBKPTLIST = XCBKPTLIST + \".template\";\n+    private static final String[] EXCLUDE_FILES_PREFIX = {\".\"};\n+    private static final String[] EXCLUDE_FILES_POSTFIX = {\".log\", \".cmdline\"};\n+    private static final String[] COMPILER_FLAGS_INCLUDE = {\"-m\", \"-f\", \"-D\", \"-W\"};\n+    private static final String[] COMPILER_FLAGS_IS = {\"-g\", \"-Os\", \"-0\"};\n+    private static final String[] COMPILER_FLAGS_EXCLUDE = {\"-DTHIS_FILE\", \"-DGTEST_OS_MAC\", \"-mmacosx-version-min\", \"-Werror\"}; \/\/ \"-Werror\" causes Xcode to stop compiling\n+    private static final int EXIT4 = -4;\n+    private static final int EXIT5 = -5;\n+    private static final int EXIT6 = -6;\n+    private static final int EXIT7 = -7;\n+\n+    private final HashMap<String, ArrayList<String>> compiledFiles = new HashMap<>();\n+    private final TreeSet<String> compilerFlags = new TreeSet<>();\n+    private List<String> linkerFlags = List.of();\n+    private final TreeSet<String> headerPaths = new TreeSet<>();\n+    private final boolean debugLog;\n+    private String projectMakerDataPath = null;\n+    private String generatedHotspotPath = null;\n+    private String iframework = null;\n+    private String fframework = null;\n+    private DiskFile rootGensrc = new DiskFile(\"\/\", true);\n+    private DiskFile rootSrc = new DiskFile(\"\/\", true);\n+    private DiskFile rootTest = new DiskFile(\"\/\", true);\n+\n+    public XcodeProjectMaker(boolean debugLog) {\n+        this.debugLog = debugLog;\n+    }\n+\n+    public static void main(String[] args) {\n+        String workspaceRoot = args[0];\n+        String outputDir = args[1];\n+        String pathToProjectMakerData = args[2];\n+        String pathToCompileCommands = args[3];\n+        String pathToLinkerOptionsFile = args[4];\n+        String linkerOptionsString = readFile(pathToLinkerOptionsFile);\n+        boolean debugLog = args.length > 5 && args[5].equals(\"-d\");\n+\n+        File xcodeFolder = new File(outputDir);\n+        xcodeFolder.mkdirs();\n+        String workspaceRootPathFromOutputDir = findRelativePathToWorkspaceRoot(outputDir);\n+\n+        if (debugLog) {\n+            System.out.println();\n+            System.out.println(\"Version \" + VERSION);\n+            System.out.println();\n+            System.out.println(\"       Path to workspace root is \\\"\" + workspaceRoot + \"\\\"\");\n+            System.out.println(\"Path to compile commands file is \\\"\" + pathToCompileCommands + \"\\\"\");\n+            System.out.println(\" Xcode project will be placed in \\\"\" + outputDir + \"\\\"\");\n+            System.out.println();\n+        }\n+\n+        XcodeProjectMaker maker = new XcodeProjectMaker(debugLog);\n+        maker.parseHotspotCompileCommands(pathToCompileCommands);\n+        maker.linkerFlags = List.of(linkerOptionsString.split(\" \"));\n+        maker.projectMakerDataPath = pathToProjectMakerData;\n+\n+        maker.printLogDetails();\n+\n+        maker.prepareFiles(workspaceRoot);\n+        maker.makeXcodeProj(outputDir, workspaceRootPathFromOutputDir);\n+\n+        String pathToBuild = getFileParent(outputDir);\n+        maker.makeAliases(outputDir, pathToBuild);\n+\n+        System.out.println();\n+        System.out.println(\"The Xcode project for hotspot was succesfully created\");\n+        System.out.println(\"It can be found in '\" + outputDir + \"\/\" + HOTSPOT_PBXPROJ + \"'\");\n+        System.out.println();\n+    }\n+\n+    \/\/ find a path to what looks like jdk\n+    private static String findRelativePathToWorkspaceRoot(String root) {\n+        String pathToWorkspaceRoot = null;\n+        String path = root;\n+        boolean found1 = false;\n+        boolean found2 = false;\n+\n+        while (!found1 && !found2) {\n+            File folder = new File(path);\n+            File[] files = folder.listFiles();\n+            for (File file : files) {\n+                String fileName = file.toPath().getFileName().toString();\n+                if (fileName.equals(JDK_SCRIPT_TOKEN_1)) {\n+                    found1 = true;\n+                }\n+                if (fileName.equals(JDK_SCRIPT_TOKEN_2)) {\n+                    found2 = true;\n+                }\n+                if (found1 && found2) {\n+                    break;\n+                }\n+            }\n+\n+            if (!found1 && !found2) {\n+                path = Paths.get(path).getParent().toString();\n+                if (pathToWorkspaceRoot == null) {\n+                    pathToWorkspaceRoot = \"..\";\n+                } else {\n+                    pathToWorkspaceRoot += \"\/..\";\n+                }\n+            }\n+        }\n+        return pathToWorkspaceRoot;\n+    }\n+\n+    private static String readFile(File file) {\n+        return readFile(file.toPath());\n+    }\n+\n+    private static String readFile(String path) {\n+        return readFile(Paths.get(path));\n+    }\n+\n+    private static String readFile(Path path) {\n+        try {\n+            return Files.readString(path);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+\n+    private static void writeFile(File file, String string) {\n+        writeFile(file.toPath(), string);\n+    }\n+\n+    private static void writeFile(Path path, String string) {\n+        try {\n+            Files.writeString(path, string);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            System.exit(EXIT4);\n+        }\n+    }\n+\n+    private static boolean excludeFile(Path path) {\n+        return excludeFile(path.toString());\n+    }\n+\n+    private static boolean excludeFile(String string) {\n+        return excludeFile(string, null);\n+    }\n+\n+    private static boolean excludeFile(String string, String exclude) {\n+        if (exclude != null) {\n+            if (contains(string, exclude)) {\n+                return true;\n+            }\n+        }\n+        for (String excludeFilesPrefix : EXCLUDE_FILES_PREFIX) {\n+            if (string.startsWith(excludeFilesPrefix)) {\n+                return true;\n+            }\n+        }\n+        for (String excludeFilesPostfix : EXCLUDE_FILES_POSTFIX) {\n+            if (string.endsWith(excludeFilesPostfix)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean isExcludeCompilerFlag(String string) {\n+        boolean flag = false;\n+        for (String exclude : COMPILER_FLAGS_EXCLUDE) {\n+            if (string.contains(exclude)) {\n+                flag = true;\n+                break;\n+            }\n+        }\n+        return flag;\n+    }\n+\n+    private static boolean isCompilerFlag(String string) {\n+        boolean flag = false;\n+        for (String include : COMPILER_FLAGS_INCLUDE) {\n+            if (string.startsWith(include)) {\n+                flag = true;\n+                break;\n+            }\n+        }\n+        for (String is : COMPILER_FLAGS_IS) {\n+            if (string.equals(is)) {\n+                flag = true;\n+                break;\n+            }\n+        }\n+        if (isExcludeCompilerFlag(string)) {\n+            flag = false;\n+        }\n+        return flag;\n+    }\n+\n+    private static String strip(String string) {\n+        return string.substring(2, string.length() - 1);\n+    }\n+\n+    private static String strip(String string, String token) {\n+        int start = string.indexOf(token);\n+        int end = start + token.length();\n+        return strip(string.substring(end));\n+    }\n+\n+    private static boolean contains(String string, String token) {\n+        return ((string.length() >= token.length()) && (string.contains(token)));\n+    }\n+\n+    private static String getFileParent(String path) {\n+        return Paths.get(path).getParent().toString();\n+    }\n+\n+    private static String extractPath(String string, String from, String to) {\n+        String result = null;\n+        String[] tokens = string.split(\"\/\");\n+        int i = 0;\n+        for (; i < tokens.length; i++) {\n+            if (tokens[i].equals(from)) {\n+                result = \"\";\n+                break;\n+            }\n+        }\n+        for (; i < tokens.length; i++) {\n+            result += \"\/\" + tokens[i];\n+            if (tokens[i].equals(to)) {\n+                break;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private void extractCommonCompilerFlags() {\n+        \/\/ heuristic, find average count of number of flags used by each compiled file\n+        int countFiles = 0;\n+        int countFlags = 0;\n+\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            countFiles++;\n+            List<String> flags = entry.getValue();\n+            countFlags += flags.size();\n+        }\n+\n+        \/\/ when finding common flags, only consider files with this many flags\n+        int flagCutoff = (countFlags \/ countFiles) \/ 2;\n+\n+        \/\/ collect all flags\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            List<String> flags = entry.getValue();\n+            if (flags.size() > flagCutoff) {\n+                this.compilerFlags.addAll(flags);\n+            }\n+        }\n+\n+        \/\/ find flags to remove\n+        Set<String> removeFlags = new TreeSet<>();\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            List<String> flags = entry.getValue();\n+            if (flags.size() > flagCutoff) {\n+                for (String common : this.compilerFlags) {\n+                    if (!flags.contains(common)) {\n+                        removeFlags.add(common);\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ leave only common flags\n+        for (String flag : removeFlags) {\n+            this.compilerFlags.remove(flag);\n+        }\n+\n+        \/\/ remove common flags from each compiler file, leaving only the unique ones\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            List<String> flags = entry.getValue();\n+            if (flags.size() > flagCutoff) {\n+                for (String common : this.compilerFlags) {\n+                    flags.remove(common);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void extractCompilerFlags(String line) {\n+        boolean verboseCompilerTokens = false;\n+        String file = null;\n+        ArrayList<String> flags = null;\n+\n+        String[] commands = line.split(\",\");\n+        for (String command : commands) {\n+            if (contains(command, FILE_TOKEN)) {\n+                file = strip(command, FILE_TOKEN);\n+                \/\/verbose_compiler_tokens = Contains(file, \"vm_version.cpp\");\n+            } else if (contains(command, COMMAND_TOKEN)) {\n+                String tokens = strip(command, COMMAND_TOKEN);\n+                String[] arguments = tokens.split(\" \");\n+                if (arguments.length >= 3) {\n+                    flags = new ArrayList<>();\n+                    for (int a = 2; a < arguments.length; a++) {\n+                        String argument = arguments[a];\n+                        if (isCompilerFlag(argument)) {\n+                            \/\/ catch argument like -DVMTYPE=\\\"Minimal\\\"\n+                            if (contains(argument, \"\\\\\\\\\\\\\\\"\") && argument.endsWith(\"\\\\\\\\\\\\\\\"\")) {\n+                                \/\/ TODO: more robust fix needed here\n+                                argument = argument.replace(\"\\\\\", \"\");\n+                                argument = argument.replaceFirst(\"\\\"\", \"~.~\"); \/\/ temp token ~.~\n+                                argument = argument.replace(\"\\\"\", \"\\\\\\\"'\");\n+                                argument = argument.replace(\"~.~\", \"'\\\\\\\"\");\n+                            }\n+\n+                            \/\/ argument like -DHOTSPOT_VM_DISTRO='\\\"Java HotSpot(TM)\\\"'\n+                            \/\/ gets split up, so reconstruct as single string\n+                            if (contains(argument, QUOTE_START_TOKEN) && !argument.endsWith(QUOTE_END_TOKEN)) {\n+                                String fullArgument = argument;\n+                                do {\n+                                    ++a;\n+                                    argument = arguments[a];\n+                                    fullArgument = fullArgument + \" \" + argument;\n+                                } while (!argument.endsWith(QUOTE_END_TOKEN));\n+                                argument = fullArgument;\n+                            }\n+                            flags.add(argument);\n+                            if (verboseCompilerTokens) {\n+                                System.out.println(\"    FOUND COMPILER FLAG: \" + argument);\n+                            }\n+                        } else if (argument.startsWith(COMPILER_LINE_HEADER)) {\n+                            this.headerPaths.add(argument.substring(2));\n+                        } else if (argument.equals(COMPILER_IFRAMEWORK)) {\n+                            if (iframework == null) {\n+                                ++a;\n+                                this.iframework = arguments[a]; \/\/ gets the value, so skip it for the next loop\n+                            }\n+                        } else if (argument.equals(COMPILER_FFRAMEWORK)) {\n+                            if (fframework == null) {\n+                                ++a;\n+                                this.fframework = arguments[a]; \/\/ gets the value, so skip it for the next loop\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((file != null) && (flags != null)) {\n+            this.compiledFiles.put(file, flags);\n+        } else {\n+            System.err.println(\" WARNING: extractCompilerFlags returns file:\" + file + \", flags:\" + flags);\n+        }\n+\n+        if (verboseCompilerTokens) {\n+            System.exit(0);\n+        }\n+    }\n+\n+    public void parseHotspotCompileCommands(String path) {\n+        String content = readFile(path);\n+        String[] parts = content.split(\"\\\\{\"); \/\/ }\n+\n+        int found = 0;\n+        for (String line : parts) {\n+            if (!contains(line, EXCLUDE_PARSE_TOKEN_1) && !line.startsWith(\"[\")) {\n+                extractCompilerFlags(line);\n+                found++;\n+            }\n+        }\n+        if (debugLog) {\n+            System.out.println(\"Found total of \" + found + \" files that make up the libjvm.dylib\");\n+        }\n+        extractCommonCompilerFlags();\n+\n+        \/\/ figure out \"gensrc\" folder\n+        \/\/ from: \"\/Users\/gerard\/Desktop\/jdk_test\/jdk10\/build\/macosx-x86_64-normal-server-fastdebug\/hotspot\/variant-server\/gensrc\/adfiles\/ad_x86_clone.cpp\"\n+        \/\/ to:   \"\/build\/macosx-x86_64-normal-server-fastdebug\/hotspot\/variant-server\/gensrc\"\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            String file = entry.getKey();\n+            if (file.contains(\"gensrc\")) {\n+                this.generatedHotspotPath = extractPath(file, \"build\", \"gensrc\");\n+                \/\/generatedHotspotPath = \"\/build\/macosx-x64\/hotspot\/variant-server\/gensrc\";\n+                \/\/generatedHotspotPath = \"\/build\/macosx-x86_64-normal-server-fastdebug\/hotspot\/variant-server\/gensrc\";\n+            }\n+        }\n+    }\n+\n+    \/\/ https:\/\/docs.oracle.com\/javase\/tutorial\/displayCode.html?code=https:\/\/docs.oracle.com\/javase\/tutorial\/essential\/io\/examples\/Copy.java\n+    private DiskFile getHotspotFiles(DiskFile root, String workspaceRoot, String hotspotPath) {\n+        File file = new File(workspaceRoot + \"\/\" + hotspotPath);\n+        if (!file.exists()) {\n+            return null;\n+        }\n+\n+        try {\n+            final Path rootDir = Paths.get(workspaceRoot + hotspotPath);\n+            Files.walkFileTree(rootDir, new HotspotFileVisitor(root, hotspotPath));\n+        } catch (IOException ex) {\n+            System.err.println(\"ex: \" + ex);\n+        }\n+\n+        return root;\n+    }\n+\n+    public void prepareFiles(String workspaceRoot) {\n+        this.rootGensrc = getHotspotFiles(this.rootGensrc, workspaceRoot, this.generatedHotspotPath);\n+        this.rootSrc = getHotspotFiles(this.rootSrc, workspaceRoot, SRC_HOTSPOT_PATH);\n+        this.rootTest = getHotspotFiles(this.rootTest, workspaceRoot, TEST_HOTSPOT_PATH);\n+\n+        \/\/ make a copy of files from the log\n+        Set<String> logFiles = new TreeSet<>(this.compiledFiles.keySet());\n+\n+        int totalMarkedFiles = 0;\n+        DiskFile[] roots = { this.rootGensrc, this.rootSrc };\n+        for (DiskFile root : roots) {\n+            List<DiskFile> diskFiles = root.getFiles();\n+            for (DiskFile diskFile : diskFiles) {\n+                if (!diskFile.isDirectory()) {\n+                    String logFileProcessed = null;\n+                    String diskFilePath = diskFile.getFilePath();\n+                    for (String logFilePath : logFiles) {\n+                        if (contains(logFilePath, diskFilePath)) {\n+                            totalMarkedFiles++;\n+\n+                            logFileProcessed = logFilePath;\n+\n+                            \/\/ mark the file as needing compilation\n+                            diskFile.markAsCompiled(this.compiledFiles.get(logFilePath));\n+\n+                            \/\/ break early if found\n+                            break;\n+                        }\n+                    }\n+                    if (logFileProcessed != null) {\n+                        \/\/ remove the file, so we don't have to search through it again\n+                        logFiles.remove(logFileProcessed);\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (this.compiledFiles.size() != totalMarkedFiles) {\n+            System.err.println(\"\\nError: was expecting to compile \" + this.compiledFiles.size() + \" files, but marked \" + totalMarkedFiles);\n+            for (String file : logFiles) {\n+                System.err.println(\"file: \" + file);\n+            }\n+            System.exit(EXIT5);\n+        }\n+\n+        if (!logFiles.isEmpty()) {\n+            System.err.println(\"\\nError: unprocessed files left over:\");\n+            for (String logFile : logFiles) {\n+                System.err.println(\"  \" + logFile);\n+            }\n+            System.exit(EXIT6);\n+        }\n+    }\n+\n+    public void printLogDetails() {\n+        if (!debugLog) return;\n+\n+        System.out.println(\"\\nFound \" + this.compilerFlags.size() + \" common compiler flags:\");\n+        for (String flag : this.compilerFlags) {\n+            System.out.println(\" \" + flag);\n+        }\n+\n+        System.out.println(\"\\nList of compiled files (each one uses common compiler flags plus extra ones as specified):\");\n+        int count = 1;\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            String file = entry.getKey();\n+            System.out.format(\"%4d: %s\\n\", (count), file);\n+            count++;\n+            List<String> flags = entry.getValue();\n+            for (String flag : flags) {\n+                System.out.println(\"        \" + flag);\n+            }\n+        }\n+\n+        System.out.println(\"\\nFound \" + this.linkerFlags.size() + \" linker flags:\");\n+        for (String flag : this.linkerFlags) {\n+            System.out.println(\" \" + flag);\n+        }\n+\n+        System.out.println(\"\\nFound \" + this.headerPaths.size() + \" header paths:\");\n+        for (String header : this.headerPaths) {\n+            System.out.println(\" \" + header);\n+        }\n+\n+        System.out.println(\"\\nFrameworks:\");\n+        System.out.println(\" -iframework \" + iframework);\n+        System.out.println(\" -f \" + fframework);\n+    }\n+\n+    private String makeProjectPbxproj(String workspaceRootPathFromOutputDir, String string) {\n+        String cFlags = \"\";\n+        for (String flag : this.compilerFlags) {\n+            cFlags += \"          \\\"\" + flag.replace(\"\\\"\", \"\\\\\\\\\\\"\") + \"\\\",\\n\";\n+        }\n+        cFlags = cFlags.substring(0, cFlags.length() - 2);\n+        string = string.replaceFirst(TEMPLATE_OTHER_CFLAGS, cFlags);\n+\n+        String ldFlags = \"\";\n+        for (String flag : this.linkerFlags) {\n+            ldFlags += \"          \\\"\" + flag + \"\\\",\\n\";\n+        }\n+        ldFlags = ldFlags.substring(0, ldFlags.length() - 2);\n+        string = string.replaceFirst(TEMPLATE_OTHER_LDFLAGS, ldFlags);\n+\n+        String headerPaths = \"\";\n+        for (String header : this.headerPaths) {\n+            headerPaths += \"          \\\"\" + header + \"\\\",\\n\";\n+        }\n+        headerPaths = headerPaths.substring(0, headerPaths.length() - 2);\n+        string = string.replaceFirst(TEMPLATE_USER_HEADER_SEARCH_PATHS, headerPaths);\n+\n+        String frameworkPaths = \"\";\n+        if (fframework != null) {\n+            frameworkPaths += \"          \\\"\" + fframework + \"\\\"\\n\";\n+        }\n+        string = string.replaceFirst(TEMPLATE_FRAMEWORK_SEARCH_PATHS, frameworkPaths);\n+\n+        DiskFile gensrcFile = this.rootGensrc.getChild(\"gensrc\");\n+        string = string.replaceFirst(TEMPLATE_GROUP_GENSRC, \"        \" + gensrcFile.getXcodeId());\n+\n+        DiskFile srcFile = this.rootSrc.getChild(\"src\");\n+        string = string.replaceFirst(TEMPLATE_GROUP_SRC, \"        \" + srcFile.getXcodeId());\n+\n+        DiskFile testFile = this.rootTest.getChild(\"test\");\n+        string = string.replaceFirst(TEMPLATE_GROUP_TEST, \"        \" + testFile.getXcodeId());\n+\n+        String gensrcGroups = gensrcFile.generatePbxGroup();\n+        String srcGroups = srcFile.generatePbxGroup();\n+        String testGroups = testFile.generatePbxGroup();\n+        string = string.replaceFirst(TEMPLATE_GROUPS, gensrcGroups + srcGroups + testGroups);\n+\n+        String gensrcFiles = gensrcFile.generatePbxFileReference(workspaceRootPathFromOutputDir);\n+        String srcFiles = srcFile.generatePbxFileReference(workspaceRootPathFromOutputDir);\n+        String testFiles = testFile.generatePbxFileReference(workspaceRootPathFromOutputDir);\n+        string = string.replaceFirst(TEMPLATE_PBXFILEREFERENCE, gensrcFiles + srcFiles + testFiles);\n+\n+        String gensrcCompiled = gensrcFile.generatePbxBuildFile();\n+        String compiled = srcFile.generatePbxBuildFile();\n+        string = string.replaceFirst(TEMPLATE_PBXBUILDFILE, gensrcCompiled + compiled);\n+\n+        String gensrcBuilt = gensrcFile.generatePbxSourcesBuildPhase();\n+        String built = srcFile.generatePbxSourcesBuildPhase();\n+        string = string.replaceFirst(TEMPLATE_PBXSOURCESSBUILDPHASE, gensrcBuilt + built);\n+\n+        return string;\n+    }\n+\n+    private String makeTemplateXcscheme(String outputDir, String string) {\n+        string = string.replaceAll(TEMPLATE_JDK_PATH, outputDir);\n+\n+        return string;\n+    }\n+\n+    public void makeXcodeProj(String outputDir, String workspaceRootPathFromOutputDir) {\n+    \/*\n+     jvm.xcodeproj                     <-- folder\n+       project.pbxproj                 <-- file\n+       xcshareddata                    <-- folder\n+         xcschemes                     <-- folder\n+           jvm.xcscheme                <-- file\n+         xcdebugger                    <-- folder\n+           Breakpoints_v2.xcbkptlist   <-- file\n+     *\/\n+        File xcodeDir = new File(outputDir);\n+        File jvmXcodeprojDir = new File(xcodeDir, HOTSPOT_PBXPROJ);\n+        File projectPbxprojFile = new File(jvmXcodeprojDir, PBXPROJ);\n+        File xcshareddataDir = new File(jvmXcodeprojDir, XCSAHAREDDATA);\n+        File xcschemesDir = new File(xcshareddataDir, XCSCHEMES);\n+        File jvmXcschemeFile = new File(xcschemesDir, JVM_XCSCHEME);\n+        File j2DemoXcschemeFile = new File(xcschemesDir, J2D_XCSCHEME);\n+        File xcdebuggerDir = new File(xcshareddataDir, XCDEBUGGER);\n+        File jBreakpointsV2XcbkptlistFile = new File(xcdebuggerDir, XCBKPTLIST);\n+\n+        if (xcodeDir.exists()) {\n+            xcodeDir.delete();\n+        }\n+\n+        jvmXcodeprojDir.mkdirs();\n+        xcshareddataDir.mkdirs();\n+        xcschemesDir.mkdirs();\n+        xcdebuggerDir.mkdirs();\n+\n+        File dataDir = new File(projectMakerDataPath);\n+        File templateProjectPbxprojFile = new File(dataDir, TEMPLATE_PBXPROJ);\n+        File templateJvmXcschemeFile = new File(dataDir, TEMPLATE_JVM_XCSCHEME);\n+        File templateJ2DemoXcschemeFile = new File(dataDir, TEMPLATE_J2D_XCSCHEME);\n+        File templateJBreakpointsV2XcbkptlistFile = new File(dataDir, TEMPLATE_XCBKPTLIST);\n+\n+        String projectPbxprojString = readFile(templateProjectPbxprojFile);\n+        String jvmXcschemeString = readFile(templateJvmXcschemeFile);\n+        String j2DemoXcschemeString = readFile(templateJ2DemoXcschemeFile);\n+        String jBreakpointsV2XcbkptlistString = readFile(templateJBreakpointsV2XcbkptlistFile);\n+\n+        writeFile(projectPbxprojFile, makeProjectPbxproj(workspaceRootPathFromOutputDir, projectPbxprojString));\n+        writeFile(jvmXcschemeFile, makeTemplateXcscheme(outputDir, jvmXcschemeString));\n+        writeFile(j2DemoXcschemeFile, makeTemplateXcscheme(outputDir, j2DemoXcschemeString));\n+        writeFile(jBreakpointsV2XcbkptlistFile, jBreakpointsV2XcbkptlistString);\n+    }\n+\n+    public void makeAliases(String outputDir, String pathToBuild) {\n+        File xcodeDir = new File(outputDir);\n+        File jdkOldSh = new File(xcodeDir, ALIAS_JAVA_OLD);\n+        File jdkNewSh = new File(xcodeDir, ALIAS_JAVA_NEW);\n+\n+        writeFile(jdkOldSh, \"#!\/bin\/bash\\n\" + pathToBuild + JDK_BIN_JAVA + \" $@\");\n+        writeFile(jdkNewSh, \"#!\/bin\/bash\\n\" + outputDir + \"\/build\" + JDK_BIN_JAVA + \" $@\");\n+\n+        try {\n+            Set<PosixFilePermission> permissions = new HashSet<>();\n+            permissions.add(PosixFilePermission.OWNER_READ);\n+            permissions.add(PosixFilePermission.OWNER_WRITE);\n+            permissions.add(PosixFilePermission.OWNER_EXECUTE);\n+            permissions.add(PosixFilePermission.GROUP_READ);\n+            permissions.add(PosixFilePermission.OTHERS_READ);\n+            Files.setPosixFilePermissions(jdkOldSh.toPath(), permissions);\n+            Files.setPosixFilePermissions(jdkNewSh.toPath(), permissions);\n+        } catch (IOException ex) {\n+            System.err.println(\"Warning: unable to change file permissions\");\n+            System.err.println(ex);\n+        }\n+    }\n+\n+    private static class HotspotFileVisitor implements FileVisitor<Path> {\n+        private final DiskFile root;\n+        private final String hotspotPath;\n+\n+        public HotspotFileVisitor(DiskFile root, String hotspotPath) {\n+            this.root = root;\n+            this.hotspotPath = hotspotPath;\n+        }\n+\n+        @Override\n+        public FileVisitResult preVisitDirectory(Path path, BasicFileAttributes attrs) {\n+            if (excludeFile(path)) {\n+                return FileVisitResult.SKIP_SUBTREE;\n+            } else {\n+                \/\/ consider folders based on their names\n+                Path file = path.getFileName();\n+                if (!excludeFile(file)) {\n+                    root.addDirectory(path, hotspotPath);\n+                    return FileVisitResult.CONTINUE;\n+                } else {\n+                    \/\/ skip folders with names beginning with \".\", etc\n+                    return FileVisitResult.SKIP_SUBTREE;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n+            Path file = path.getFileName();\n+            if (!excludeFile(file)) {\n+                \/\/System.err.println(path.toString());\n+                root.addFile(path, hotspotPath);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        @Override\n+        public FileVisitResult postVisitDirectory(Path path, IOException exc) {\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFileFailed(Path path, IOException exc) {\n+            if (exc instanceof FileSystemLoopException) {\n+                System.err.println(\"cycle detected: \" + path);\n+            } else {\n+                System.err.format(\"Unable to process: %s: %s\\n\", path, exc);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+    }\n+}\n","filename":"make\/ide\/xcode\/hotspot\/src\/classes\/XcodeProjectMaker.java","additions":754,"deletions":0,"binary":false,"changes":754,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,5 +54,0 @@\n-  define copy-and-chmod\n-\t$(install-file)\n-\t$(CHMOD) a+rx $@\n-  endef\n-\n@@ -61,1 +56,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_MSVCR, \\\n+  $(eval $(call SetupCopyFiles, COPY_MSVCR, \\\n@@ -64,1 +59,2 @@\n-      MACRO := copy-and-chmod))\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n@@ -66,1 +62,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_VCRUNTIME_1, \\\n+  $(eval $(call SetupCopyFiles, COPY_VCRUNTIME_1, \\\n@@ -69,1 +65,2 @@\n-      MACRO := copy-and-chmod))\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n@@ -71,1 +68,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_MSVCP, \\\n+  $(eval $(call SetupCopyFiles, COPY_MSVCP, \\\n@@ -74,1 +71,2 @@\n-      MACRO := copy-and-chmod))\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n@@ -83,1 +81,1 @@\n-        MACRO := copy-and-chmod, \\\n+        MACRO := copy-and-chmod-executable, \\\n","filename":"make\/modules\/java.base\/Copy.gmk","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    DISABLED_WARNINGS := try deprecation rawtypes unchecked serial cast removal preview dangling-doc-comments, \\\n+    DISABLED_WARNINGS := try deprecation rawtypes unchecked serial cast removal preview restricted dangling-doc-comments, \\\n","filename":"make\/test\/BuildTestLib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/images\/About.jpg","binary":true,"status":"modified"},{"patch":"@@ -2905,1 +2905,5 @@\n-    bne(CCR0, inflated);\n+    if (!UseObjectMonitorTable) {\n+      bne(CCR0, inflated);\n+    } else {\n+      bne(CCR0, push_and_slow);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -6289,0 +6289,1 @@\n+    NearLabel push_and_slow_path;\n@@ -6318,1 +6319,5 @@\n-    z_brnaz(inflated);\n+    if (!UseObjectMonitorTable) {\n+      z_brnaz(inflated);\n+    } else {\n+      z_brnaz(push_and_slow_path);\n+    }\n@@ -6337,0 +6342,1 @@\n+    bind(push_and_slow_path);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -115,4 +115,5 @@\n-  \/\/ The minimum region size of all collectors that are supported by CDS.\n-  \/\/ G1 heap region size can never be smaller than 1M.\n-  \/\/ Shenandoah heap region size can never be smaller than 256K.\n-  static constexpr int MIN_GC_REGION_ALIGNMENT = 256 * K;\n+  \/\/ The minimum region size of all collectors that are supported by CDS in\n+  \/\/ ArchiveHeapLoader::can_map() mode. Currently only G1 is supported. G1's region size\n+  \/\/ depends on -Xmx, but can never be smaller than 1 * M.\n+  \/\/ (TODO: Perhaps change to 256K to be compatible with Shenandoah)\n+  static constexpr int MIN_GC_REGION_ALIGNMENT = 1 * M;\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  do_klass(IllegalCallerException_klass,                java_lang_IllegalCallerException                      ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -245,0 +245,2 @@\n+    case vmIntrinsics::_Continuation_pin:\n+    case vmIntrinsics::_Continuation_unpin:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -603,0 +603,2 @@\n+  do_intrinsic(_Continuation_pin,          jdk_internal_vm_Continuation, pin_name, void_method_signature, F_SN)         \\\n+  do_intrinsic(_Continuation_unpin,        jdk_internal_vm_Continuation, unpin_name, void_method_signature, F_SN)       \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,0 +206,1 @@\n+  template(java_lang_IllegalCallerException,          \"java\/lang\/IllegalCallerException\")         \\\n@@ -409,0 +410,2 @@\n+  template(pin_name,                                  \"pin\")                                      \\\n+  template(unpin_name,                                \"unpin\")                                    \\\n@@ -589,1 +592,1 @@\n-  template(classloader_string_long_signature,         \"(Ljava\/lang\/ClassLoader;Ljava\/lang\/String;)J\")             \\\n+  template(classloader_class_string_string_long_signature,         \"(Ljava\/lang\/ClassLoader;Ljava\/lang\/Class;Ljava\/lang\/String;Ljava\/lang\/String;)J\")             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -736,6 +736,0 @@\n-      \/\/ Verify before arming for concurrent processing.\n-      \/\/ Otherwise, verification can trigger stack processing.\n-      if (ShenandoahVerify) {\n-        heap->verifier()->verify_during_evacuation();\n-      }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -363,5 +363,0 @@\n-\n-    if(ShenandoahVerify) {\n-      heap->verifier()->verify_during_evacuation();\n-    }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -351,1 +351,1 @@\n-    assert(is_in(obj), \"Otherwise shouldn't return true below\");\n+    assert(is_in_reserved(obj), \"Otherwise shouldn't return true below\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -829,8 +829,0 @@\n-      case _verify_gcstate_evacuation:\n-        enabled = true;\n-        expected = ShenandoahHeap::EVACUATION;\n-        if (!_heap->is_stw_gc_in_progress()) {\n-          \/\/ Only concurrent GC sets this.\n-          expected |= ShenandoahHeap::WEAK_ROOTS;\n-        }\n-        break;\n@@ -1121,14 +1113,0 @@\n-void ShenandoahVerifier::verify_during_evacuation() {\n-  verify_at_safepoint(\n-          \"During Evacuation\",\n-          _verify_remembered_disable, \/\/ do not verify remembered set\n-          _verify_forwarded_allow,    \/\/ some forwarded references are allowed\n-          _verify_marked_disable,     \/\/ walk only roots\n-          _verify_cset_disable,       \/\/ some cset references are not forwarded yet\n-          _verify_liveness_disable,   \/\/ liveness data might be already stale after pre-evacs\n-          _verify_regions_disable,    \/\/ trash regions not yet recycled\n-          _verify_size_disable,       \/\/ we don't know how much of promote-in-place work has been completed\n-          _verify_gcstate_evacuation  \/\/ evacuation is in progress\n-  );\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -173,3 +173,0 @@\n-    \/\/ Evacuation is in progress, some objects are forwarded\n-    _verify_gcstate_evacuation,\n-\n@@ -218,1 +215,0 @@\n-  void verify_during_evacuation();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -233,2 +233,2 @@\n-static bool should_clear_soft_references(GCCause::Cause cause) {\n-  \/\/ Clear soft references if implied by the GC cause\n+static bool should_clear_all_soft_references(GCCause::Cause cause) {\n+  \/\/ Clear all soft references if implied by the GC cause\n@@ -262,1 +262,1 @@\n-  \/\/ Clear soft references if threads are stalled waiting for an old collection\n+  \/\/ Clear all soft references if threads are stalled waiting for an old collection\n@@ -267,1 +267,1 @@\n-  \/\/ Don't clear\n+  \/\/ Don't clear all soft references\n@@ -305,5 +305,9 @@\n-  \/\/ It is important that when soft references are cleared, we also pre-clean the young\n-  \/\/ generation, as we might otherwise throw premature OOM. Therefore, all causes that\n-  \/\/ trigger soft ref cleaning must also trigger pre-cleaning of young gen. If allocations\n-  \/\/ stalled when checking for soft ref cleaning, then since we hold the driver locker all\n-  \/\/ the way until we check for young gen pre-cleaning, we can be certain that we should\n+  \/\/ We clear all soft references as a last-ditch effort to collect memory\n+  \/\/ before throwing an OOM. Therefore it is important that when the GC policy\n+  \/\/ is to clear all soft references, that we also pre-clean the young\n+  \/\/ generation, as we might otherwise throw premature OOM.\n+  \/\/\n+  \/\/ Therefore, all causes that trigger all soft ref clearing must also trigger\n+  \/\/ pre-cleaning of young gen. If allocations stalled when checking for all\n+  \/\/ soft ref clearing, then since we hold the driver locker all the way until\n+  \/\/ we check for young gen pre-cleaning, we can be certain that we should\n@@ -311,1 +315,1 @@\n-  assert(!should_clear_soft_references(cause), \"Clearing soft references without pre-cleaning young gen\");\n+  assert(!should_clear_all_soft_references(cause), \"Clearing all soft references without pre-cleaning young gen\");\n@@ -398,0 +402,4 @@\n+\n+    \/\/ Set up soft reference policy\n+    const bool clear_all = should_clear_all_soft_references(request.cause());\n+    ZGeneration::old()->set_soft_reference_policy(clear_all);\n@@ -447,2 +455,3 @@\n-static void handle_alloc_stalling_for_old(bool cleared_soft_refs) {\n-  ZHeap::heap()->handle_alloc_stalling_for_old(cleared_soft_refs);\n+static void handle_alloc_stalling_for_old() {\n+  const bool cleared_all = ZGeneration::old()->uses_clear_all_soft_reference_policy();\n+  ZHeap::heap()->handle_alloc_stalling_for_old(cleared_all);\n@@ -451,2 +460,2 @@\n-void ZDriverMajor::handle_alloc_stalls(bool cleared_soft_refs) const {\n-  handle_alloc_stalling_for_old(cleared_soft_refs);\n+void ZDriverMajor::handle_alloc_stalls() const {\n+  handle_alloc_stalling_for_old();\n@@ -467,4 +476,0 @@\n-    \/\/ Set up soft reference policy\n-    const bool clear_soft_refs = should_clear_soft_references(request.cause());\n-    ZGeneration::old()->set_soft_reference_policy(clear_soft_refs);\n-\n@@ -480,1 +485,1 @@\n-    handle_alloc_stalls(clear_soft_refs);\n+    handle_alloc_stalls();\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":24,"deletions":19,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-  void handle_alloc_stalls(bool cleared_soft_refs) const;\n+  void handle_alloc_stalls() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1289,0 +1289,4 @@\n+bool ZGenerationOld::uses_clear_all_soft_reference_policy() const {\n+  return _reference_processor.uses_clear_all_soft_reference_policy();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -312,0 +312,1 @@\n+  bool uses_clear_all_soft_reference_policy() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-inline void ZHeap::handle_alloc_stalling_for_old(bool cleared_soft_refs) {\n-  _page_allocator.handle_alloc_stalling_for_old(cleared_soft_refs);\n+inline void ZHeap::handle_alloc_stalling_for_old(bool cleared_all_soft_refs) {\n+  _page_allocator.handle_alloc_stalling_for_old(cleared_all_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -988,1 +988,1 @@\n-void ZPageAllocator::handle_alloc_stalling_for_old(bool cleared_soft_refs) {\n+void ZPageAllocator::handle_alloc_stalling_for_old(bool cleared_all_soft_refs) {\n@@ -990,1 +990,1 @@\n-  if (cleared_soft_refs) {\n+  if (cleared_all_soft_refs) {\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-    _clear_all_soft_refs(false),\n+    _uses_clear_all_soft_reference_policy(false),\n@@ -124,1 +124,1 @@\n-void ZReferenceProcessor::set_soft_reference_policy(bool clear) {\n+void ZReferenceProcessor::set_soft_reference_policy(bool clear_all_soft_references) {\n@@ -128,1 +128,1 @@\n-  _clear_all_soft_refs = clear;\n+  _uses_clear_all_soft_reference_policy = clear_all_soft_references;\n@@ -130,1 +130,1 @@\n-  if (clear) {\n+  if (clear_all_soft_references) {\n@@ -139,0 +139,4 @@\n+bool ZReferenceProcessor::uses_clear_all_soft_reference_policy() const {\n+  return _uses_clear_all_soft_reference_policy;\n+}\n+\n@@ -443,1 +447,1 @@\n-  if (_clear_all_soft_refs) {\n+  if (_uses_clear_all_soft_reference_policy) {\n","filename":"src\/hotspot\/share\/gc\/z\/zReferenceProcessor.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  bool                 _clear_all_soft_refs;\n+  bool                 _uses_clear_all_soft_reference_policy;\n@@ -72,1 +72,3 @@\n-  void set_soft_reference_policy(bool clear);\n+  void set_soft_reference_policy(bool clear_all_soft_references);\n+  bool uses_clear_all_soft_reference_policy() const;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zReferenceProcessor.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -194,0 +194,4 @@\n+  if (!initialize(THREAD)) {\n+    log_error(jfr, system)(\"JfrUpcall could not be initialized.\");\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -52,0 +53,1 @@\n+static int pin_offset = invalid_offset;\n@@ -101,0 +103,7 @@\n+\n+  const char pin_name[] = \"pinVirtualThread\";\n+  Symbol* const pin_sym = SymbolTable::new_symbol(valid_name);\n+  assert(pin_sym != nullptr, \"invariant\");\n+  assert(invalid_offset == pin_offset, \"invariant\");\n+  JfrJavaSupport::compute_field_offset(pin_offset, klass, pin_sym, vmSymbols::bool_signature());\n+  assert(pin_offset != invalid_offset, \"invariant\");\n@@ -222,0 +231,5 @@\n+static inline bool pin_virtual(const JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  return JfrThreadLocal::is_vthread(jt) && VMContinuations;\n+}\n+\n@@ -228,1 +242,1 @@\n-  static const char signature[] = \"(JJJZZ)V\";\n+  static const char signature[] = \"(JJJZZZ)V\";\n@@ -237,0 +251,1 @@\n+  args.push_int(pin_virtual(THREAD) ? (jint)JNI_TRUE : (jint)JNI_FALSE);\n@@ -252,0 +267,1 @@\n+      writer->long_field_put(thread_id_offset, current_tid);\n@@ -254,1 +270,3 @@\n-      writer->long_field_put(thread_id_offset, current_tid);\n+      if (!excluded) {\n+        writer->bool_field_put(pin_offset, pin_virtual(jt));\n+      }\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -713,2 +713,4 @@\n-    if (!THREAD->has_last_Java_frame()) {\n-        JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"Cannot call getJObjectValue without Java frame anchor\"));\n+    \/\/ Ensure that current JNI handle scope is not the top-most JNIHandleBlock as handles\n+    \/\/ in that scope are only released when the thread exits.\n+    if (!THREAD->has_last_Java_frame() && THREAD->active_handles()->pop_frame_link() == nullptr) {\n+        JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"Cannot call getJObjectValue without Java frame anchor or a pushed JNI handle block\"));\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -247,0 +248,1 @@\n+  nonstatic_field(JavaThread,                  _cont_entry,                                   ContinuationEntry*)                    \\\n@@ -251,0 +253,1 @@\n+  nonstatic_field(ContinuationEntry,           _pin_count,                                    uint32_t)                              \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -439,3 +439,0 @@\n-        assert(!fellThrough, \"should not happen\");\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n-        break;\n@@ -444,1 +441,4 @@\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n+        \/\/ If this is the last bytecode, there is no successor to mark\n+        if (bci + Bytecodes::length_for(bytecode) < method()->code_size()) {\n+          bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n+        }\n@@ -505,1 +505,4 @@\n-            reachable_basicblock(this, bci + Bytecodes::length_for(bytecode), &change);\n+            \/\/ If this is the last bytecode, there is no successor to mark\n+            if (bci + Bytecodes::length_for(bytecode) < method()->code_size()) {\n+              reachable_basicblock(this, bci + Bytecodes::length_for(bytecode), &change);\n+            }\n@@ -589,3 +592,0 @@\n-\n-\n-\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-\/\/    [ptr             | 10]  monitor            inflated lock (header is swapped out)\n+\/\/    [ptr             | 10]  monitor            inflated lock (header is swapped out, UseObjectMonitorTable == false)\n+\/\/    [header          | 10]  monitor            inflated lock (UseObjectMonitorTable == true)\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -734,0 +734,2 @@\n+  case vmIntrinsics::_Continuation_pin:\n+  case vmIntrinsics::_Continuation_unpin:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -485,0 +485,3 @@\n+  case vmIntrinsics::_Continuation_pin:          return inline_native_Continuation_pinning(false);\n+  case vmIntrinsics::_Continuation_unpin:        return inline_native_Continuation_pinning(true);\n+\n@@ -3233,0 +3236,1 @@\n+ * bool pinVirtualThread;\n@@ -3237,0 +3241,1 @@\n+ *   pinVirtualThread = VMContinuations;\n@@ -3248,0 +3253,1 @@\n+ *   pinVirtualThread = false;\n@@ -3253,1 +3259,1 @@\n- *   setField(event_writer, \"threadID\", tid);\n+ *   setField(event_writer, \"pinVirtualThread\", pinVirtualThread);\n@@ -3255,0 +3261,1 @@\n+ *   setField(event_writer, \"threadID\", tid);\n@@ -3325,0 +3332,4 @@\n+  \/\/ Continuation support determines if a virtual thread should be pinned.\n+  Node* global_addr = makecon(TypeRawPtr::make((address)&VMContinuations));\n+  Node* continuation_support = make_load(control(), global_addr, TypeInt::BOOL, T_BOOLEAN, MemNode::unordered);\n+\n@@ -3415,0 +3426,2 @@\n+  PhiNode* pinVirtualThread = new PhiNode(vthread_compare_rgn, TypeInt::BOOL);\n+  record_for_igvn(pinVirtualThread);\n@@ -3427,0 +3440,2 @@\n+  pinVirtualThread->init_req(_true_path, _gvn.transform(continuation_support));\n+  pinVirtualThread->init_req(_false_path, _gvn.intcon(0));\n@@ -3450,0 +3465,3 @@\n+  \/\/ Get the field offset to, conditionally, store an updated pinVirtualThread value later.\n+  Node* const event_writer_pin_field = field_address_from_object(event_writer, \"pinVirtualThread\", \"Z\", false);\n+  const TypePtr* event_writer_pin_field_type = _gvn.type(event_writer_pin_field)->isa_ptr();\n@@ -3470,0 +3488,3 @@\n+  \/\/ Store the pin state to the event writer.\n+  store_to_memory(tid_is_not_equal, event_writer_pin_field, _gvn.transform(pinVirtualThread), T_BOOLEAN, event_writer_pin_field_type, MemNode::unordered);\n+\n@@ -3718,0 +3739,87 @@\n+\/\/------------------------inline_native_Continuation_pin and unpin-----------\n+\n+\/\/ Shared implementation routine for both pin and unpin.\n+bool LibraryCallKit::inline_native_Continuation_pinning(bool unpin) {\n+  enum { _true_path = 1, _false_path = 2, PATH_LIMIT };\n+\n+  \/\/ Save input memory.\n+  Node* input_memory_state = reset_memory();\n+  set_all_memory(input_memory_state);\n+\n+  \/\/ TLS\n+  Node* tls_ptr = _gvn.transform(new ThreadLocalNode());\n+  Node* last_continuation_offset = basic_plus_adr(top(), tls_ptr, in_bytes(JavaThread::cont_entry_offset()));\n+  Node* last_continuation = make_load(control(), last_continuation_offset, last_continuation_offset->get_ptr_type(), T_ADDRESS, MemNode::unordered);\n+\n+  \/\/ Null check the last continuation object.\n+  Node* continuation_cmp_null = _gvn.transform(new CmpPNode(last_continuation, null()));\n+  Node* test_continuation_not_equal_null = _gvn.transform(new BoolNode(continuation_cmp_null, BoolTest::ne));\n+  IfNode* iff_continuation_not_equal_null = create_and_map_if(control(), test_continuation_not_equal_null, PROB_MAX, COUNT_UNKNOWN);\n+\n+  \/\/ False path, last continuation is null.\n+  Node* continuation_is_null = _gvn.transform(new IfFalseNode(iff_continuation_not_equal_null));\n+\n+  \/\/ True path, last continuation is not null.\n+  Node* continuation_is_not_null = _gvn.transform(new IfTrueNode(iff_continuation_not_equal_null));\n+\n+  set_control(continuation_is_not_null);\n+\n+  \/\/ Load the pin count from the last continuation.\n+  Node* pin_count_offset = basic_plus_adr(top(), last_continuation, in_bytes(ContinuationEntry::pin_count_offset()));\n+  Node* pin_count = make_load(control(), pin_count_offset, TypeInt::INT, T_INT, MemNode::unordered);\n+\n+  \/\/ The loaded pin count is compared against a context specific rhs for over\/underflow detection.\n+  Node* pin_count_rhs;\n+  if (unpin) {\n+    pin_count_rhs = _gvn.intcon(0);\n+  } else {\n+    pin_count_rhs = _gvn.intcon(UINT32_MAX);\n+  }\n+  Node* pin_count_cmp = _gvn.transform(new CmpUNode(_gvn.transform(pin_count), pin_count_rhs));\n+  Node* test_pin_count_over_underflow = _gvn.transform(new BoolNode(pin_count_cmp, BoolTest::eq));\n+  IfNode* iff_pin_count_over_underflow = create_and_map_if(control(), test_pin_count_over_underflow, PROB_MIN, COUNT_UNKNOWN);\n+\n+  \/\/ False branch, no pin count over\/underflow. Increment or decrement pin count and store back.\n+  Node* valid_pin_count = _gvn.transform(new IfFalseNode(iff_pin_count_over_underflow));\n+  set_control(valid_pin_count);\n+\n+  Node* next_pin_count;\n+  if (unpin) {\n+    next_pin_count = _gvn.transform(new SubINode(pin_count, _gvn.intcon(1)));\n+  } else {\n+    next_pin_count = _gvn.transform(new AddINode(pin_count, _gvn.intcon(1)));\n+  }\n+\n+  Node* updated_pin_count_memory = store_to_memory(control(), pin_count_offset, next_pin_count, T_INT, Compile::AliasIdxRaw, MemNode::unordered);\n+\n+  \/\/ True branch, pin count over\/underflow.\n+  Node* pin_count_over_underflow = _gvn.transform(new IfTrueNode(iff_pin_count_over_underflow));\n+  {\n+    \/\/ Trap (but not deoptimize (Action_none)) and continue in the interpreter\n+    \/\/ which will throw IllegalStateException for pin count over\/underflow.\n+    PreserveJVMState pjvms(this);\n+    set_control(pin_count_over_underflow);\n+    set_all_memory(input_memory_state);\n+    uncommon_trap_exact(Deoptimization::Reason_intrinsic,\n+                        Deoptimization::Action_none);\n+    assert(stopped(), \"invariant\");\n+  }\n+\n+  \/\/ Result of top level CFG and Memory.\n+  RegionNode* result_rgn = new RegionNode(PATH_LIMIT);\n+  record_for_igvn(result_rgn);\n+  PhiNode* result_mem = new PhiNode(result_rgn, Type::MEMORY, TypePtr::BOTTOM);\n+  record_for_igvn(result_mem);\n+\n+  result_rgn->init_req(_true_path, _gvn.transform(valid_pin_count));\n+  result_rgn->init_req(_false_path, _gvn.transform(continuation_is_null));\n+  result_mem->init_req(_true_path, _gvn.transform(updated_pin_count_memory));\n+  result_mem->init_req(_false_path, _gvn.transform(input_memory_state));\n+\n+  \/\/ Set output state.\n+  set_control(_gvn.transform(result_rgn));\n+  set_all_memory(_gvn.transform(result_mem));\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":109,"deletions":1,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -244,0 +244,1 @@\n+  bool inline_native_Continuation_pinning(bool unpin);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1072,1 +1072,1 @@\n-            assert(get_loop(lca)->_nest < n_loop->_nest || lca->in(0)->is_NeverBranch(), \"must not be moved into inner loop\");\n+            assert(get_loop(lca)->_nest < n_loop->_nest || get_loop(lca)->_head->as_Loop()->is_in_infinite_subgraph(), \"must not be moved into inner loop\");\n@@ -1275,3 +1275,1 @@\n-    if (loop->is_member(get_loop(dom)) ||\n-        \/\/ NeverBranch nodes are not assigned to the loop when constructed\n-        (dom->is_NeverBranch() && loop->is_member(get_loop(dom->in(0))))) {\n+    if (loop->is_member(get_loop(dom))) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -430,3 +431,9 @@\n-bool MemNode::all_controls_dominate(Node* dom, Node* sub) {\n-  if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top())\n-    return false; \/\/ Conservative answer for dead code\n+\/\/ Returns 'DomResult::Dominate' if all control inputs of 'dom'\n+\/\/ dominate 'sub', 'DomResult::NotDominate' if not,\n+\/\/ and 'DomResult::EncounteredDeadCode' if we can't decide due to\n+\/\/ dead code, but at the end of IGVN, we know the definite result\n+\/\/ once the dead code is cleaned up.\n+Node::DomResult MemNode::maybe_all_controls_dominate(Node* dom, Node* sub) {\n+  if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top()) {\n+    return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+  }\n@@ -436,2 +443,3 @@\n-  if (dom == nullptr || dom->is_top())\n-    return false; \/\/ Conservative answer for dead code\n+  if (dom == nullptr || dom->is_top()) {\n+    return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+  }\n@@ -442,1 +450,1 @@\n-    return false;\n+    return DomResult::NotDominate;\n@@ -445,2 +453,3 @@\n-  if (dom->is_Con() || dom->is_Start() || dom->is_Root() || dom == sub)\n-    return true;\n+  if (dom->is_Con() || dom->is_Start() || dom->is_Root() || dom == sub) {\n+    return DomResult::Dominate;\n+  }\n@@ -460,2 +469,3 @@\n-  if (sub == nullptr || sub->is_top())\n-    return false; \/\/ Conservative answer for dead code\n+  if (sub == nullptr || sub->is_top()) {\n+    return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+  }\n@@ -465,2 +475,3 @@\n-  if (sub == dom)\n-    return true;\n+  if (sub == dom) {\n+    return DomResult::Dominate;\n+  }\n@@ -468,2 +479,3 @@\n-  if (sub->is_Start() || sub->is_Root())\n-    return false;\n+  if (sub->is_Start() || sub->is_Root()) {\n+    return DomResult::NotDominate;\n+  }\n@@ -483,2 +495,3 @@\n-      if (n == orig_sub)\n-        return false; \/\/ One of dom's inputs dominated by sub.\n+      if (n == orig_sub) {\n+        return DomResult::NotDominate; \/\/ One of dom's inputs dominated by sub.\n+      }\n@@ -488,2 +501,3 @@\n-        if (n == nullptr || n->is_top())\n-          return false; \/\/ Conservative answer for dead code\n+        if (n == nullptr || n->is_top()) {\n+          return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+        }\n@@ -495,1 +509,2 @@\n-        if (n->dominates(sub, nlist))\n+        DomResult dom_result = n->dominates(sub, nlist);\n+        if (dom_result == DomResult::Dominate) {\n@@ -497,2 +512,3 @@\n-        else\n-          return false;\n+        } else {\n+          return dom_result;\n+        }\n@@ -503,2 +519,3 @@\n-          if (m->is_top())\n-            return false; \/\/ Conservative answer for dead code\n+          if (m->is_top()) {\n+            return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+          }\n@@ -511,1 +528,1 @@\n-          if (m == nullptr || m->is_top())\n+          if (m == nullptr || m->is_top()) {\n@@ -513,0 +530,1 @@\n+          }\n@@ -517,1 +535,1 @@\n-    return only_dominating_controls;\n+    return only_dominating_controls ? DomResult::Dominate : DomResult::NotDominate;\n@@ -729,1 +747,1 @@\n-      if (st_alloc == nullptr)\n+      if (st_alloc == nullptr) {\n@@ -731,0 +749,1 @@\n+      }\n@@ -733,1 +752,1 @@\n-      if (alloc == st_alloc)\n+      if (alloc == st_alloc) {\n@@ -735,1 +754,1 @@\n-      else if (alloc != nullptr)\n+      } else if (alloc != nullptr) {\n@@ -737,1 +756,1 @@\n-      else if (all_controls_dominate(this, st_alloc))\n+      } else if (all_controls_dominate(this, st_alloc)) {\n@@ -739,0 +758,1 @@\n+      }\n@@ -1569,1 +1589,1 @@\n-    if (!MemNode::all_controls_dominate(mem, base->in(0)))\n+    if (!MemNode::all_controls_dominate(mem, base->in(0))) {\n@@ -1571,0 +1591,1 @@\n+    }\n@@ -1661,0 +1682,1 @@\n+  DomResult dom_result = DomResult::Dominate;\n@@ -1665,2 +1687,2 @@\n-    if (!MemNode::all_controls_dominate(address, region))\n-      return nullptr;\n+    \/\/ We will check `dom_result` later.\n+    dom_result = MemNode::maybe_all_controls_dominate(address, region);\n@@ -1671,2 +1693,2 @@\n-    if (!MemNode::all_controls_dominate(mem, region))\n-      return nullptr;\n+    \/\/ We will check `dom_result` later.\n+    dom_result = MemNode::maybe_all_controls_dominate(mem, region);\n@@ -1675,1 +1697,2 @@\n-    if (MemNode::all_controls_dominate(mem, base->in(0))) {\n+    dom_result = MemNode::maybe_all_controls_dominate(mem, base->in(0));\n+    if (dom_result == DomResult::Dominate) {\n@@ -1677,2 +1700,0 @@\n-    } else if (MemNode::all_controls_dominate(address, mem->in(0))) {\n-      region = mem->in(0);\n@@ -1680,1 +1701,5 @@\n-      return nullptr; \/\/ complex graph\n+      dom_result = MemNode::maybe_all_controls_dominate(address, mem->in(0));\n+      if (dom_result == DomResult::Dominate) {\n+        region = mem->in(0);\n+      }\n+      \/\/ Otherwise we encountered a complex graph.\n@@ -1687,0 +1712,11 @@\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+  if (dom_result != DomResult::Dominate) {\n+    if (dom_result == DomResult::EncounteredDeadCode) {\n+      \/\/ There is some dead code which eventually will be removed in IGVN.\n+      \/\/ Once this is the case, we get an unambiguous dominance result.\n+      \/\/ Push the node to the worklist again until the dead code is removed.\n+      igvn->_worklist.push(this);\n+    }\n+    return nullptr;\n+  }\n+\n@@ -1689,1 +1725,0 @@\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n@@ -4574,1 +4609,1 @@\n-      if (!MemNode::all_controls_dominate(n, this))\n+      if (!MemNode::all_controls_dominate(n, this)) {\n@@ -4576,0 +4611,1 @@\n+      }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":76,"deletions":40,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -108,2 +109,6 @@\n-  \/\/ This one should probably be a phase-specific function:\n-  static bool all_controls_dominate(Node* dom, Node* sub);\n+  \/\/ The following two should probably be phase-specific functions:\n+  static DomResult maybe_all_controls_dominate(Node* dom, Node* sub);\n+  static bool all_controls_dominate(Node* dom, Node* sub) {\n+    DomResult dom_result = maybe_all_controls_dominate(dom, sub);\n+    return dom_result == DomResult::Dominate;\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -1252,1 +1253,1 @@\n-bool Node::dominates(Node* sub, Node_List &nlist) {\n+Node::DomResult Node::dominates(Node* sub, Node_List &nlist) {\n@@ -1272,1 +1273,4 @@\n-    if (sub->is_top())  break; \/\/ Conservative answer for dead code.\n+    if (sub->is_top()) {\n+      \/\/ Conservative answer for dead code.\n+      return DomResult::EncounteredDeadCode;\n+    }\n@@ -1277,1 +1281,1 @@\n-        return true;\n+        return DomResult::Dominate;\n@@ -1291,1 +1295,1 @@\n-      return met_dom;\n+      return met_dom ? DomResult::Dominate : DomResult::NotDominate;\n@@ -1322,1 +1326,1 @@\n-            return false;\n+            return DomResult::NotDominate;\n@@ -1365,2 +1369,1 @@\n-  \/\/ Conservative answer for dead code.\n-  return false;\n+  return DomResult::NotDominate;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -1110,0 +1111,6 @@\n+  \/\/ Results of the dominance analysis.\n+  enum class DomResult {\n+    NotDominate,         \/\/ 'this' node does not dominate 'sub'.\n+    Dominate,            \/\/ 'this' node dominates or is equal to 'sub'.\n+    EncounteredDeadCode  \/\/ Result is undefined due to encountering dead code.\n+  };\n@@ -1111,1 +1118,1 @@\n-  bool dominates(Node* sub, Node_List &nlist);\n+  DomResult dominates(Node* sub, Node_List &nlist);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -276,1 +276,9 @@\n-  Handle name_arg = java_lang_String::create_from_str(jni_name, CHECK_NULL);\n+  Handle jni_class(THREAD, method->method_holder()->java_mirror());\n+  Handle jni_name_arg = java_lang_String::create_from_str(jni_name, CHECK_NULL);\n+  Handle java_name_arg = java_lang_String::create_from_str(method->name()->as_C_string(), CHECK_NULL);\n+\n+  JavaCallArguments args;\n+  args.push_oop(loader);\n+  args.push_oop(jni_class);\n+  args.push_oop(jni_name_arg);\n+  args.push_oop(java_name_arg);\n@@ -282,4 +290,2 @@\n-                         vmSymbols::classloader_string_long_signature(),\n-                         \/\/ Arguments\n-                         loader,\n-                         name_arg,\n+                         vmSymbols::classloader_class_string_string_long_signature(),\n+                         &args,\n@@ -412,0 +418,8 @@\n+  if (THREAD->has_pending_exception()) {\n+    oop exception = THREAD->pending_exception();\n+    if (exception->is_a(vmClasses::IllegalCallerException_klass())) {\n+      \/\/ we already have a pending exception from the restricted method check, just return\n+      return nullptr;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -308,0 +308,2 @@\n+#define ILLEGAL_NATIVE_ACCESS \"illegal.native.access\"\n+#define ILLEGAL_NATIVE_ACCESS_LEN 21\n@@ -329,0 +331,1 @@\n+        matches_property_suffix(property_suffix, ILLEGAL_NATIVE_ACCESS, ILLEGAL_NATIVE_ACCESS_LEN) ||\n@@ -2246,0 +2249,4 @@\n+    } else if (match_option(option, \"--illegal-native-access=\", &tail)) {\n+      if (!create_module_property(\"jdk.module.illegal.native.access\", tail, InternalProperty)) {\n+        return JNI_ENOMEM;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  friend class JVMCIVMStructs;\n@@ -81,1 +82,1 @@\n-  uint _pin_count;\n+  uint32_t _pin_count;\n@@ -111,1 +112,1 @@\n-    if (_pin_count == UINT_MAX) return false;\n+    if (_pin_count == UINT32_MAX) return false;\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -154,1 +154,3 @@\n-void ExceptionsEventLog::log(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {\n+void ExceptionsEventLog::log(Thread* thread, Handle h_exception,\n+                             const char* message, const char* file, int line,\n+                             int message_length_limit) {\n@@ -166,1 +168,5 @@\n-  st.print(\"%s%s> (\" PTR_FORMAT \") \\n\"\n+  if (message != nullptr) {\n+    int len = message_length_limit > 0 ? message_length_limit : (int)strlen(message);\n+    st.print(\": %.*s\", len, message);\n+  }\n+  st.print(\"> (\" PTR_FORMAT \") \\n\"\n@@ -168,1 +174,0 @@\n-           message ? \": \" : \"\", message ? message : \"\",\n","filename":"src\/hotspot\/share\/utilities\/events.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -210,1 +210,3 @@\n-  void log(Thread* thread, Handle h_exception, const char* message, const char* file, int line);\n+  \/\/ Message length limit of zero means no limit.\n+  void log(Thread* thread, Handle h_exception, const char* message,\n+           const char* file, int line, int message_length_limit = 0);\n@@ -278,1 +280,1 @@\n-  static void log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line);\n+  static void log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line, int message_length_limit = 0);\n@@ -348,1 +350,3 @@\n-inline void Events::log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {\n+inline void Events::log_exception(Thread* thread, Handle h_exception,\n+                                  const char* message, const char* file,\n+                                  int line, int message_length_limit) {\n@@ -350,1 +354,1 @@\n-    _exceptions->log(thread, h_exception, message, file, line);\n+    _exceptions->log(thread, h_exception, message, file, line, message_length_limit);\n","filename":"src\/hotspot\/share\/utilities\/events.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-  Events::log_exception(thread, h_exception, message, file, line);\n+  Events::log_exception(thread, h_exception, message, file, line, MAX_LEN);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2445,1 +2445,1 @@\n-    \/*\n+    \/**\n@@ -2447,0 +2447,17 @@\n+     * @param loader the class loader used to look up the native library symbol\n+     * @param clazz the class in which the native method is declared\n+     * @param entryName the native method's mangled name (this is the name used for the native lookup)\n+     * @param javaName the native method's declared name\n+     *\/\n+    static long findNative(ClassLoader loader, Class<?> clazz, String entryName, String javaName) {\n+        long addr = findNativeInternal(loader, entryName);\n+        if (addr != 0 && loader != null) {\n+            Reflection.ensureNativeAccess(clazz, clazz, javaName, true);\n+        }\n+        return addr;\n+    }\n+\n+    \/*\n+     * This is also called by SymbolLookup::loaderLookup. In that case, we need\n+     * to avoid a restricted check, as that check has already been performed when\n+     * obtaining the lookup.\n@@ -2448,1 +2465,1 @@\n-    static long findNative(ClassLoader loader, String entryName) {\n+    static long findNativeInternal(ClassLoader loader, String entryName) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import jdk.internal.misc.VM;\n@@ -66,0 +67,1 @@\n+import jdk.internal.module.ModuleBootstrap.IllegalNativeAccess;\n@@ -303,1 +305,1 @@\n-    void ensureNativeAccess(Class<?> owner, String methodName, Class<?> currentClass) {\n+    void ensureNativeAccess(Class<?> owner, String methodName, Class<?> currentClass, boolean jni) {\n@@ -306,3 +308,10 @@\n-        if (!EnableNativeAccess.isNativeAccessEnabled(target)) {\n-            if (ModuleBootstrap.hasEnableNativeAccessFlag()) {\n-                throw new IllegalCallerException(\"Illegal native access from: \" + this);\n+        ModuleBootstrap.IllegalNativeAccess illegalNativeAccess = ModuleBootstrap.illegalNativeAccess();\n+        if (illegalNativeAccess != ModuleBootstrap.IllegalNativeAccess.ALLOW &&\n+                !EnableNativeAccess.isNativeAccessEnabled(target)) {\n+            String mod = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n+            if (currentClass != null) {\n+                \/\/ try to extract location of the current class (e.g. jar or folder)\n+                URL url = System.codeSource(currentClass);\n+                if (url != null) {\n+                    mod += \" (\" + url + \")\";\n+                }\n@@ -310,1 +319,3 @@\n-            if (EnableNativeAccess.trySetEnableNativeAccess(target)) {\n+            if (illegalNativeAccess == ModuleBootstrap.IllegalNativeAccess.DENY) {\n+                throw new IllegalCallerException(\"Illegal native access from \" + mod);\n+            } else if (EnableNativeAccess.trySetEnableNativeAccess(target)) {\n@@ -314,1 +325,0 @@\n-                String mod = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n@@ -317,6 +327,15 @@\n-                System.err.printf(\"\"\"\n-                        WARNING: A restricted method in %s has been called\n-                        WARNING: %s has been called by %s in %s\n-                        WARNING: Use --enable-native-access=%s to avoid a warning for callers in this module\n-                        WARNING: Restricted methods will be blocked in a future release unless native access is enabled\n-                        %n\"\"\", cls, mtd, caller, mod, modflag);\n+                if (jni) {\n+                    VM.initialErr().printf(\"\"\"\n+                            WARNING: A native method in %s has been bound\n+                            WARNING: %s is declared in %s\n+                            WARNING: Use --enable-native-access=%s to avoid a warning for native methods declared in this module\n+                            WARNING: Restricted methods will be blocked in a future release unless native access is enabled\n+                            %n\"\"\", cls, mtd, mod, modflag);\n+                } else {\n+                    VM.initialErr().printf(\"\"\"\n+                            WARNING: A restricted method in %s has been called\n+                            WARNING: %s has been called by %s in %s\n+                            WARNING: Use --enable-native-access=%s to avoid a warning for callers in this module\n+                            WARNING: Restricted methods will be blocked in a future release unless native access is enabled\n+                            %n\"\"\", cls, mtd, caller, mod, modflag);\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":31,"deletions":12,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-                \"enableNativeAccess\");\n+                \"enableNativeAccess\", false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ModuleLayer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import jdk.internal.javac.Restricted;\n@@ -831,0 +832,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -837,0 +840,1 @@\n+    @Restricted\n@@ -838,1 +842,3 @@\n-        load0(Reflection.getCallerClass(), filename);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, Runtime.class, \"load\", false);\n+        load0(caller, filename);\n@@ -897,0 +903,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -902,0 +910,1 @@\n+    @Restricted\n@@ -903,1 +912,3 @@\n-        loadLibrary0(Reflection.getCallerClass(), libname);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, Runtime.class, \"loadLibrary\", false);\n+        loadLibrary0(caller, libname);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Runtime.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.javac.Restricted;\n@@ -358,1 +359,1 @@\n-    private static URL codeSource(Class<?> clazz) {\n+    static URL codeSource(Class<?> clazz) {\n@@ -2020,0 +2021,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -2026,0 +2029,1 @@\n+    @Restricted\n@@ -2027,1 +2031,3 @@\n-        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, System.class, \"load\", false);\n+        Runtime.getRuntime().load0(caller, filename);\n@@ -2058,0 +2064,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -2064,0 +2072,1 @@\n+    @Restricted\n@@ -2065,1 +2074,3 @@\n-        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, System.class, \"loadLibrary\", false);\n+        Runtime.getRuntime().loadLibrary0(caller, libname);\n@@ -2542,2 +2553,2 @@\n-            public void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass) {\n-                m.ensureNativeAccess(owner, methodName, currentClass);\n+            public void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass, boolean jni) {\n+                m.ensureNativeAccess(owner, methodName, currentClass, jni);\n@@ -2648,1 +2659,1 @@\n-                return ClassLoader.findNative(loader, entry);\n+                return ClassLoader.findNativeInternal(loader, entry);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-public interface AttributeMapper<A> {\n+public interface AttributeMapper<A extends Attribute<A>> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AttributeMapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n- * java.lang.Object)} method for mapping back to the classfile format.  It also\n+ * java.lang.classfile.Attribute)} method for mapping back to the classfile format.  It also\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -616,1 +616,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -687,1 +687,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -736,1 +736,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -295,1 +295,1 @@\n-                SymbolLookup.class, \"libraryLookup\");\n+                SymbolLookup.class, \"libraryLookup\", false);\n@@ -322,1 +322,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -329,1 +329,1 @@\n-                SymbolLookup.class, \"libraryLookup\");\n+                SymbolLookup.class, \"libraryLookup\", false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -168,4 +168,5 @@\n- * the special value {@code ALL-UNNAMED} can be used). If this option is specified,\n- * access to restricted methods are only granted to the modules listed by that option.\n- * If this option is not specified, access to restricted methods is enabled for all\n- * modules, but access to restricted methods will result in runtime warnings.\n+ * the special value {@code ALL-UNNAMED} can be used). Access to restricted methods\n+ * from modules not listed by that option is deemed <em>illegal<\/em>. Clients can\n+ * control how access to restricted methods is handled, using the command line\n+ * option {@code --illegal-native-access}. If this option is not specified,\n+ * illegal access to restricted methods will result in runtime warnings.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -1088,26 +1090,26 @@\n-        static final ClassDesc CD_StringConcatHelper = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringConcatHelper;\");\n-        static final ClassDesc CD_StringConcatBase   = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringConcatHelper$StringConcatBase;\");\n-        static final ClassDesc CD_Array_byte         = ClassDesc.ofDescriptor(\"[B\");\n-        static final ClassDesc CD_Array_String       = ClassDesc.ofDescriptor(\"[Ljava\/lang\/String;\");\n-\n-        static final MethodTypeDesc MTD_byte_char       = MethodTypeDesc.of(CD_byte, CD_char);\n-        static final MethodTypeDesc MTD_byte            = MethodTypeDesc.of(CD_byte);\n-        static final MethodTypeDesc MTD_int             = MethodTypeDesc.of(CD_int);\n-        static final MethodTypeDesc MTD_int_int_boolean = MethodTypeDesc.of(CD_int, CD_int, CD_boolean);\n-        static final MethodTypeDesc MTD_int_int_char    = MethodTypeDesc.of(CD_int, CD_int, CD_char);\n-        static final MethodTypeDesc MTD_int_int_int     = MethodTypeDesc.of(CD_int, CD_int, CD_int);\n-        static final MethodTypeDesc MTD_int_int_long    = MethodTypeDesc.of(CD_int, CD_int, CD_long);\n-        static final MethodTypeDesc MTD_int_int_String  = MethodTypeDesc.of(CD_int, CD_int, CD_String);\n-        static final MethodTypeDesc MTD_String_float    = MethodTypeDesc.of(CD_String, CD_float);\n-        static final MethodTypeDesc MTD_String_double   = MethodTypeDesc.of(CD_String, CD_double);\n-        static final MethodTypeDesc MTD_String_Object   = MethodTypeDesc.of(CD_String, CD_Object);\n-\n-        static final MethodTypeDesc MTD_INIT             = MethodTypeDesc.of(CD_void, CD_Array_String);\n-        static final MethodTypeDesc MTD_NEW_ARRAY_SUFFIX = MethodTypeDesc.of(CD_Array_byte, CD_String, CD_int, CD_byte);\n-        static final MethodTypeDesc MTD_STRING_INIT      = MethodTypeDesc.of(CD_void, CD_Array_byte, CD_byte);\n-\n-        static final MethodTypeDesc PREPEND_int     = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_Array_byte, CD_int, CD_String);\n-        static final MethodTypeDesc PREPEND_long    = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_Array_byte, CD_long, CD_String);\n-        static final MethodTypeDesc PREPEND_boolean = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_Array_byte, CD_boolean, CD_String);\n-        static final MethodTypeDesc PREPEND_char    = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_Array_byte, CD_char, CD_String);\n-        static final MethodTypeDesc PREPEND_String  = MethodTypeDesc.of(CD_int, CD_int, CD_byte, CD_Array_byte, CD_String, CD_String);\n+        static final ClassDesc CD_StringConcatHelper = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper;\");\n+        static final ClassDesc CD_StringConcatBase   = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper$StringConcatBase;\");\n+        static final ClassDesc CD_Array_byte         = ReferenceClassDescImpl.ofValidated(\"[B\");\n+        static final ClassDesc CD_Array_String       = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/String;\");\n+\n+        static final MethodTypeDesc MTD_byte_char       = MethodTypeDescImpl.ofValidated(CD_byte, CD_char);\n+        static final MethodTypeDesc MTD_byte            = MethodTypeDescImpl.ofValidated(CD_byte);\n+        static final MethodTypeDesc MTD_int             = MethodTypeDescImpl.ofValidated(CD_int);\n+        static final MethodTypeDesc MTD_int_int_boolean = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_boolean);\n+        static final MethodTypeDesc MTD_int_int_char    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_char);\n+        static final MethodTypeDesc MTD_int_int_int     = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_int);\n+        static final MethodTypeDesc MTD_int_int_long    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_long);\n+        static final MethodTypeDesc MTD_int_int_String  = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_String);\n+        static final MethodTypeDesc MTD_String_float    = MethodTypeDescImpl.ofValidated(CD_String, CD_float);\n+        static final MethodTypeDesc MTD_String_double   = MethodTypeDescImpl.ofValidated(CD_String, CD_double);\n+        static final MethodTypeDesc MTD_String_Object   = MethodTypeDescImpl.ofValidated(CD_String, CD_Object);\n+\n+        static final MethodTypeDesc MTD_INIT             = MethodTypeDescImpl.ofValidated(CD_void, CD_Array_String);\n+        static final MethodTypeDesc MTD_NEW_ARRAY_SUFFIX = MethodTypeDescImpl.ofValidated(CD_Array_byte, CD_String, CD_int, CD_byte);\n+        static final MethodTypeDesc MTD_STRING_INIT      = MethodTypeDescImpl.ofValidated(CD_void, CD_Array_byte, CD_byte);\n+\n+        static final MethodTypeDesc PREPEND_int     = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_int, CD_String);\n+        static final MethodTypeDesc PREPEND_long    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_long, CD_String);\n+        static final MethodTypeDesc PREPEND_boolean = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_boolean, CD_String);\n+        static final MethodTypeDesc PREPEND_char    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_char, CD_String);\n+        static final MethodTypeDesc PREPEND_String  = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_String, CD_String);\n@@ -1169,1 +1171,1 @@\n-            return changed ? MethodType.methodType(args.returnType(), paramTypes) : args;\n+            return changed ? MethodType.methodType(args.returnType(), paramTypes, true) : args;\n@@ -1194,1 +1196,1 @@\n-            return MethodTypeDesc.of(CD_int, paramTypes);\n+            return MethodTypeDescImpl.ofValidated(CD_int, paramTypes);\n@@ -1198,2 +1200,2 @@\n-         * Construct the MethodType of the coder method,\n-         * The first parameter is the initialized coder, Only parameter types that can be UTF16 are added.\n+         * Construct the MethodType of the coder method. The first parameter is the initialized coder.\n+         * Only parameter types which can be UTF16 are added. Returns null if no such parameter exists.\n@@ -1201,1 +1203,1 @@\n-        private static MethodTypeDesc coderArgs(MethodType concatArgs) {\n+        private static MethodTypeDesc coderArgsIfMaybeUTF16(MethodType concatArgs) {\n@@ -1203,2 +1205,2 @@\n-            List<ClassDesc> paramTypes = new ArrayList<>();\n-            paramTypes.add(CD_int); \/\/ init coder\n+\n+            int maybeUTF16Count = 0;\n@@ -1206,0 +1208,12 @@\n+                if (maybeUTF16(concatArgs.parameterType(i))) {\n+                    maybeUTF16Count++;\n+                }\n+            }\n+\n+            if (maybeUTF16Count == 0) {\n+                return null;\n+            }\n+\n+            var paramTypes = new ClassDesc[maybeUTF16Count + 1];\n+            paramTypes[0] = CD_int; \/\/ init coder\n+            for (int i = 0, paramIndex = 1; i < parameterCount; i++) {\n@@ -1208,1 +1222,1 @@\n-                    paramTypes.add(cl == char.class ? CD_char : CD_String);\n+                    paramTypes[paramIndex++] = cl == char.class ? CD_char : CD_String;\n@@ -1211,1 +1225,1 @@\n-            return MethodTypeDesc.of(CD_int, paramTypes);\n+            return MethodTypeDescImpl.ofValidated(CD_int, paramTypes);\n@@ -1226,1 +1240,1 @@\n-            return MethodTypeDesc.of(CD_int, paramTypes);\n+            return MethodTypeDescImpl.ofValidated(CD_int, paramTypes);\n@@ -1253,1 +1267,1 @@\n-                           coderArgs   = parameterMaybeUTF16(concatArgs) ? coderArgs(concatArgs) : null,\n+                           coderArgs   = coderArgsIfMaybeUTF16(concatArgs),\n@@ -1481,1 +1495,1 @@\n-                     * suffix  = constants[paranCount];\n+                     * suffix  = constants[paramCount];\n@@ -1695,9 +1709,0 @@\n-\n-        static boolean parameterMaybeUTF16(MethodType args) {\n-            for (int i = 0; i < args.parameterCount(); i++) {\n-                if (maybeUTF16(args.parameterType(i))) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":52,"deletions":47,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import java.util.stream.Stream;\n+\n@@ -53,0 +53,1 @@\n+import jdk.internal.constant.MethodTypeDescImpl;\n@@ -84,0 +85,2 @@\n+    private static final ClassDesc CD_BiPredicate = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/function\/BiPredicate;\");\n+    private static final ClassDesc CD_Objects = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n@@ -85,1 +88,11 @@\n-    private static final MethodType TYPES_SWITCH_TYPE = MethodType.methodType(int.class,\n+    private static final MethodTypeDesc CHECK_INDEX_DESCRIPTOR =\n+            MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int, ConstantDescs.CD_int, ConstantDescs.CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH_EXTRA = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int,\n+            CD_BiPredicate,\n+            ConstantDescs.CD_List);\n+    private static final MethodType MT_TYPE_SWITCH_EXTRA = MethodType.methodType(int.class,\n@@ -90,7 +103,3 @@\n-\n-    private static final MethodTypeDesc TYPES_SWITCH_DESCRIPTOR =\n-            MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;ILjava\/util\/function\/BiPredicate;Ljava\/util\/List;)I\");\n-    private static final MethodTypeDesc CHECK_INDEX_DESCRIPTOR =\n-            MethodTypeDesc.ofDescriptor(\"(II)I\");\n-\n-    private static final ClassDesc CD_Objects = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n+    private static final MethodType MT_TYPE_SWITCH = MethodType.methodType(int.class,\n+            Object.class,\n+            int.class);\n@@ -183,1 +192,1 @@\n-\n+        target = target.asType(invocationType);\n@@ -275,1 +284,0 @@\n-        requireNonNull(labels);\n@@ -277,1 +285,1 @@\n-        labels = labels.clone();\n+        labels = labels.clone(); \/\/ implicit null check\n@@ -304,1 +312,0 @@\n-\n@@ -437,0 +444,27 @@\n+    \/**\n+     * Check if the labelConstants can be converted statically to bytecode, or\n+     * whether we'll need to compute and pass in extra information at the call site.\n+     *\/\n+    private static boolean needsExtraInfo(Class<?> selectorType, Object[] labelConstants) {\n+        for (int idx = labelConstants.length - 1; idx >= 0; idx--) {\n+            Object currentLabel = labelConstants[idx];\n+            if (currentLabel instanceof Class<?> classLabel) {\n+                \/\/ No extra info needed for exact matches or primitives\n+                if (unconditionalExactnessCheck(selectorType, classLabel) || classLabel.isPrimitive()) {\n+                    continue;\n+                }\n+                \/\/ Hidden classes - or arrays thereof - can't be nominally\n+                \/\/ represented. Passed in as arguments.\n+                while (classLabel.isArray()) {\n+                    classLabel = classLabel.getComponentType();\n+                }\n+                if (classLabel.isHidden()) {\n+                    return true;\n+                }\n+            } else if (currentLabel instanceof EnumDesc<?>) {\n+                \/\/ EnumDescs labels needs late binding\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n@@ -470,3 +504,4 @@\n-            record Element(Label target, Label next, Object caseLabel) { }\n-            List<Element> cases = new ArrayList<>();\n-            List<SwitchCase> switchCases = new ArrayList<>();\n+            Label[] caseTargets = new Label[labelConstants.length];\n+            Label[] caseNext = new Label[labelConstants.length];\n+            Object[] caseLabels = new Object[labelConstants.length];\n+            SwitchCase[] switchCases = new SwitchCase[labelConstants.length];\n@@ -481,1 +516,1 @@\n-                    next = cases.getLast().next();\n+                    next = caseNext[idx + 1];\n@@ -483,1 +518,1 @@\n-                    next = cases.getLast().target();\n+                    next = caseTargets[idx + 1];\n@@ -486,2 +521,4 @@\n-                cases.add(new Element(target, next, currentLabel));\n-                switchCases.add(SwitchCase.of(idx, target));\n+                caseTargets[idx] = target;\n+                caseNext[idx] = next;\n+                caseLabels[idx] = currentLabel;\n+                switchCases[idx] = SwitchCase.of(idx, target);\n@@ -489,8 +526,6 @@\n-            cases = cases.reversed();\n-            switchCases = switchCases.reversed();\n-            cb.tableswitch(0, labelConstants.length - 1, dflt, switchCases);\n-            for (int idx = 0; idx < cases.size(); idx++) {\n-                Element element = cases.get(idx);\n-                Label next = element.next();\n-                cb.labelBinding(element.target());\n-                if (element.caseLabel() instanceof Class<?> classLabel) {\n+            cb.tableswitch(0, labelConstants.length - 1, dflt, Arrays.asList(switchCases));\n+            for (int idx = 0; idx < labelConstants.length; idx++) {\n+                Label next = caseNext[idx];\n+                Object caseLabel = caseLabels[idx];\n+                cb.labelBinding(caseTargets[idx]);\n+                if (caseLabel instanceof Class<?> classLabel) {\n@@ -580,1 +615,1 @@\n-                } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n+                } else if (caseLabel instanceof EnumDesc<?> enumLabel) {\n@@ -590,1 +625,1 @@\n-                    cb.invokeinterface(referenceClassDesc(BiPredicate.class),\n+                    cb.invokeinterface(CD_BiPredicate,\n@@ -596,1 +631,1 @@\n-                } else if (element.caseLabel() instanceof String stringLabel) {\n+                } else if (caseLabel instanceof String stringLabel) {\n@@ -604,1 +639,1 @@\n-                } else if (element.caseLabel() instanceof Integer integerLabel) {\n+                } else if (caseLabel instanceof Integer integerLabel) {\n@@ -629,5 +664,5 @@\n-                } else if ((element.caseLabel() instanceof Long ||\n-                        element.caseLabel() instanceof Float ||\n-                        element.caseLabel() instanceof Double ||\n-                        element.caseLabel() instanceof Boolean)) {\n-                    if (element.caseLabel() instanceof Boolean c) {\n+                } else if ((caseLabel instanceof Long ||\n+                        caseLabel instanceof Float ||\n+                        caseLabel instanceof Double ||\n+                        caseLabel instanceof Boolean)) {\n+                    if (caseLabel instanceof Boolean c) {\n@@ -636,1 +671,1 @@\n-                        cb.loadConstant((ConstantDesc) element.caseLabel());\n+                        cb.loadConstant((ConstantDesc) caseLabel);\n@@ -638,1 +673,1 @@\n-                    var caseLabelWrapper = Wrapper.forWrapperType(element.caseLabel().getClass());\n+                    var caseLabelWrapper = Wrapper.forWrapperType(caseLabel.getClass());\n@@ -651,1 +686,1 @@\n-                            element.caseLabel().getClass());\n+                            caseLabel.getClass());\n@@ -657,1 +692,1 @@\n-            cb.loadConstant(cases.size());\n+            cb.loadConstant(labelConstants.length);\n@@ -666,2 +701,3 @@\n-        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n-        List<Class<?>> extraClassLabels = new ArrayList<>();\n+        boolean addExtraInfo = needsExtraInfo(selectorType, labelConstants);\n+        List<EnumDesc<?>> enumDescs = addExtraInfo ? new ArrayList<>() : null;\n+        List<Class<?>> extraClassLabels = addExtraInfo ? new ArrayList<>() : null;\n@@ -673,1 +709,1 @@\n-                                       TYPES_SWITCH_DESCRIPTOR,\n+                                       addExtraInfo ? MTD_TYPE_SWITCH_EXTRA : MTD_TYPE_SWITCH,\n@@ -684,7 +720,5 @@\n-                                                        TYPES_SWITCH_TYPE);\n-            typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(new EnumDesc<?>[0])),\n-                                                       List.copyOf(extraClassLabels));\n-            typeSwitch = MethodHandles.explicitCastArguments(typeSwitch,\n-                                                             MethodType.methodType(int.class,\n-                                                                                   selectorType,\n-                                                                                   int.class));\n+                                                        addExtraInfo ? MT_TYPE_SWITCH_EXTRA : MT_TYPE_SWITCH);\n+            if (addExtraInfo) {\n+                typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(new EnumDesc<?>[0])),\n+                        List.copyOf(extraClassLabels));\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":85,"deletions":51,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -284,4 +284,8 @@\n-     * Ensure that the given module has native access. If not, warn or\n-     * throw exception depending on the configuration.\n-     *\/\n-    void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass);\n+     * Ensure that the given module has native access. If not, warn or throw exception depending on the configuration.\n+     * @param m the module in which native access occurred\n+     * @param owner the owner of the restricted method being called (or the JNI method being bound)\n+     * @param methodName the name of the restricted method being called (or the JNI method being bound)\n+     * @param currentClass the class calling the restricted method (for JNI, this is the same as {@code owner})\n+     * @param jni {@code true}, if this event is related to a JNI method being bound\n+     *\/\n+    void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass, boolean jni);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    <A> A get(AttributeMapper<A> am) {\n+    <A extends Attribute<A>> A get(AttributeMapper<A> am) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AttributeHolder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-                filled.add((Attribute<?>) Objects.requireNonNull(mapper.readAttribute(enclosing, reader, p)));\n+                filled.add(Objects.requireNonNull(mapper.readAttribute(enclosing, reader, p)));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,11 +86,22 @@\n-            switch (o) {\n-                case StackMapsOption oo -> smo = oo;\n-                case DebugElementsOption oo -> deo = oo;\n-                case LineNumbersOption oo -> lno = oo;\n-                case AttributesProcessingOption oo -> apo = oo;\n-                case ConstantPoolSharingOption oo -> cpso = oo;\n-                case ShortJumpsOption oo -> sjo = oo;\n-                case DeadCodeOption oo -> dco = oo;\n-                case DeadLabelsOption oo -> dlo = oo;\n-                case ClassHierarchyResolverOption oo -> chro = oo;\n-                case AttributeMapperOption oo -> amo = oo;\n+            if (o instanceof StackMapsOption oo) {\n+                smo = oo;\n+            } else if (o instanceof DebugElementsOption oo) {\n+                deo = oo;\n+            } else if (o instanceof LineNumbersOption oo) {\n+                lno = oo;\n+            } else if (o instanceof AttributesProcessingOption oo) {\n+                apo = oo;\n+            } else if (o instanceof ConstantPoolSharingOption oo) {\n+                cpso = oo;\n+            } else if (o instanceof ShortJumpsOption oo) {\n+                sjo = oo;\n+            } else if (o instanceof DeadCodeOption oo) {\n+                dco = oo;\n+            } else if (o instanceof DeadLabelsOption oo) {\n+                dlo = oo;\n+            } else if (o instanceof ClassHierarchyResolverOption oo) {\n+                chro = oo;\n+            } else if (o instanceof AttributeMapperOption oo) {\n+                amo = oo;\n+            } else { \/\/ null or unknown Option type\n+                throw new IllegalArgumentException(\"Invalid option: \" + o);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileImpl.java","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -164,2 +164,2 @@\n-        switch (vti) {\n-            case SimpleVerificationTypeInfo svti ->\n+        switch (vti.tag()) {\n+            case VT_TOP, VT_INTEGER, VT_FLOAT, VT_DOUBLE, VT_LONG, VT_NULL, VT_UNINITIALIZED_THIS ->\n@@ -167,4 +167,5 @@\n-            case ObjectVerificationTypeInfo ovti ->\n-                bw.writeIndex(ovti.className());\n-            case UninitializedVerificationTypeInfo uvti ->\n-                bw.writeU2(bw.labelContext().labelToBci(uvti.newTarget()));\n+            case VT_OBJECT ->\n+                bw.writeIndex(((ObjectVerificationTypeInfo)vti).className());\n+            case VT_UNINITIALIZED ->\n+                bw.writeU2(bw.labelContext().labelToBci(((UninitializedVerificationTypeInfo)vti).newTarget()));\n+            default -> throw new IllegalArgumentException(\"Invalid verification type tag: \" + vti.tag());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-    private static <T> void writeAttribute(BufWriterImpl writer, Attribute<?> attr) {\n+    private static <T extends Attribute<T>> void writeAttribute(BufWriterImpl writer, Attribute<?> attr) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-        Reflection.ensureNativeAccess(callerClass, MemorySegment.class, \"reinterpret\");\n+        Reflection.ensureNativeAccess(callerClass, MemorySegment.class, \"reinterpret\", false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\");\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\", false);\n@@ -91,1 +91,1 @@\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\");\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\", false);\n@@ -118,1 +118,1 @@\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"upcallStub\");\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"upcallStub\", false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-            Reflection.ensureNativeAccess(Reflection.getCallerClass(), AddressLayout.class, \"withTargetLayout\");\n+            Reflection.ensureNativeAccess(Reflection.getCallerClass(), AddressLayout.class, \"withTargetLayout\", false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+                    @SuppressWarnings(\"restricted\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/NativeImageBuffer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -790,1 +790,0 @@\n-    private static final boolean HAS_ENABLE_NATIVE_ACCESS_FLAG;\n@@ -793,0 +792,1 @@\n+    private static final IllegalNativeAccess ILLEGAL_NATIVE_ACCESS;\n@@ -794,2 +794,8 @@\n-    public static boolean hasEnableNativeAccessFlag() {\n-        return HAS_ENABLE_NATIVE_ACCESS_FLAG;\n+    public enum IllegalNativeAccess {\n+        ALLOW,\n+        WARN,\n+        DENY\n+    }\n+\n+    public static IllegalNativeAccess illegalNativeAccess() {\n+        return ILLEGAL_NATIVE_ACCESS;\n@@ -799,0 +805,1 @@\n+        ILLEGAL_NATIVE_ACCESS = addIllegalNativeAccess();\n@@ -800,1 +807,0 @@\n-        HAS_ENABLE_NATIVE_ACCESS_FLAG = !USER_NATIVE_ACCESS_MODULES.isEmpty();\n@@ -850,0 +856,21 @@\n+    \/**\n+     * Process the --illegal-native-access option (and its default).\n+     *\/\n+    private static IllegalNativeAccess addIllegalNativeAccess() {\n+        String value = getAndRemoveProperty(\"jdk.module.illegal.native.access\");\n+        \/\/ don't use a switch: bootstrapping issues!\n+        if (value == null) {\n+            return IllegalNativeAccess.WARN; \/\/ default\n+        } else if (value.equals(\"deny\")) {\n+            return IllegalNativeAccess.DENY;\n+        } else if (value.equals(\"allow\")) {\n+            return IllegalNativeAccess.ALLOW;\n+        } else if (value.equals(\"warn\")) {\n+            return IllegalNativeAccess.WARN;\n+        } else {\n+            fail(\"Value specified to --illegal-native-access not recognized:\"\n+                    + \" '\" + value + \"'\");\n+            return null;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-    public static void ensureNativeAccess(Class<?> currentClass, Class<?> owner, String methodName) {\n+    public static void ensureNativeAccess(Class<?> currentClass, Class<?> owner, String methodName, boolean jni) {\n@@ -122,1 +122,4 @@\n-        Holder.JLA.ensureNativeAccess(module, owner, methodName, currentClass);\n+        if (module != null) {\n+            \/\/ not in init phase\n+            Holder.JLA.ensureNativeAccess(module, owner, methodName, currentClass, jni);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -430,0 +430,1 @@\n+    @IntrinsicCandidate\n@@ -437,0 +438,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -259,1 +259,2 @@\n-        jdk.internal.vm.ci;\n+        jdk.internal.vm.ci,\n+        jdk.jfr;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+\\    --illegal-native-access=<value>\\n\\\n+\\                  allow or deny access to code and data outside the Java runtime\\n\\\n+\\                  by code in modules for which native access is not explicitly enabled.\\n\\\n+\\                  <value> is one of \"deny\", \"warn\" or \"allow\". The default value is \"warn\".\\n\\\n+\\                  This option will be removed in a future release.\\n\\\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -555,8 +555,32 @@\n-Methods that provide native access are restricted, and by default their\n-use causes warnings.\n-This option allows code in the specified modules to use restricted\n-methods without warnings.\n-\\f[I]module\\f[R] can be \\f[V]ALL-UNNAMED\\f[R] to indicate code on the\n-class path.\n-When this option is present, any use of restricted methods by code\n-outside the specified modules causes an\n+Native access can occur as a result of calling a method that is either\n+\\f[B]restricted\\f[R] [https:\/\/openjdk.org\/jeps\/454#Safety], or\n+\\f[V]native\\f[R].\n+This option allows code in the specified modules to perform native\n+access.\n+Native access occurring in a module that has not been explicitly enabled\n+is deemed \\f[I]illegal\\f[R].\n+.RS\n+.PP\n+\\f[I]module\\f[R] can be a module name, or \\f[V]ALL-UNNAMED\\f[R] to\n+indicate code on the class path.\n+.RE\n+.TP\n+-\\f[V]--illegal-native-access=\\f[R]\\f[I]parameter\\f[R]\n+This option specifies a mode for how illegal native access is handled:\n+.RS\n+.RS\n+.PP\n+\\f[B]Note:\\f[R] This option will be removed in a future release.\n+.RE\n+.IP \\[bu] 2\n+\\f[V]allow\\f[R]: This mode allows illegal native access in all modules,\n+without any warings.\n+.IP \\[bu] 2\n+\\f[V]warn\\f[R]: This mode is identical to \\f[V]allow\\f[R] except that a\n+warning message is issued for the first illegal native access found in a\n+module.\n+This mode is the default for the current JDK but will change in a future\n+release.\n+.IP \\[bu] 2\n+\\f[V]deny\\f[R]: This mode disables illegal native access.\n+That is, any illegal native access causes an\n@@ -564,0 +588,6 @@\n+This mode will become the default in a future release.\n+.PP\n+To verify that your application is ready for a future version of the\n+JDK, run it with \\f[V]--illegal-native-access=deny\\f[R] along with any\n+necessary \\f[V]--enable-native-access\\f[R] options.\n+.RE\n","filename":"src\/java.base\/share\/man\/java.1","additions":38,"deletions":8,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-    private long st_dev;    \/\/ ID of device\n-    private long st_ino;    \/\/ Inode number\n+    private final long st_dev;    \/\/ ID of device\n+    private final long st_ino;    \/\/ Inode number\n@@ -39,1 +39,4 @@\n-    private FileKey() { }\n+    private FileKey(long st_dev, long st_ino) {\n+        this.st_dev = st_dev;\n+        this.st_ino = st_ino;\n+    }\n@@ -42,3 +45,3 @@\n-        FileKey fk = new FileKey();\n-        fk.init(fd);\n-        return fk;\n+        long finfo[] = new long[2];\n+        init(fd, finfo);\n+        return new FileKey(finfo[0], finfo[1]);\n@@ -62,2 +65,2 @@\n-    private native void init(FileDescriptor fd) throws IOException;\n-    private static native void initIDs();\n+    private static native void init(FileDescriptor fd, long[] finfo)\n+        throws IOException;\n@@ -66,1 +69,1 @@\n-        initIDs();\n+        IOUtil.load();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileKey.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -33,12 +33,0 @@\n-static jfieldID key_st_dev;    \/* id for FileKey.st_dev *\/\n-static jfieldID key_st_ino;    \/* id for FileKey.st_ino *\/\n-\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileKey_initIDs(JNIEnv *env, jclass clazz)\n-{\n-    CHECK_NULL(key_st_dev = (*env)->GetFieldID(env, clazz, \"st_dev\", \"J\"));\n-    CHECK_NULL(key_st_ino = (*env)->GetFieldID(env, clazz, \"st_ino\", \"J\"));\n-}\n-\n-\n@@ -46,1 +34,2 @@\n-Java_sun_nio_ch_FileKey_init(JNIEnv *env, jobject this, jobject fdo)\n+Java_sun_nio_ch_FileKey_init(JNIEnv* env, jclass clazz, jobject fdo,\n+    jlongArray finfo)\n@@ -50,0 +39,1 @@\n+    jlong deviceAndInode[2];\n@@ -51,1 +41,2 @@\n-    RESTARTABLE(fstat(fdval(env, fdo), &fbuf), res);\n+    int fd = fdval(env, fdo);\n+    RESTARTABLE(fstat(fd, &fbuf), res);\n@@ -55,2 +46,3 @@\n-        (*env)->SetLongField(env, this, key_st_dev, (jlong)fbuf.st_dev);\n-        (*env)->SetLongField(env, this, key_st_ino, (jlong)fbuf.st_ino);\n+        deviceAndInode[0] = (jlong)fbuf.st_dev;\n+        deviceAndInode[1] = (jlong)fbuf.st_ino;\n+        (*env)->SetLongArrayRegion(env, finfo, 0, 2, deviceAndInode);\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileKey.c","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -136,3 +136,4 @@\n-#ifndef STATX_ALL\n-#define STATX_ALL (STATX_BTIME | STATX_BASIC_STATS)\n-#endif\n+\/\/\n+\/\/ STATX_ALL is deprecated; use a different name to avoid confusion.\n+\/\/\n+#define LOCAL_STATX_ALL (STATX_BASIC_STATS | STATX_BTIME)\n@@ -622,2 +623,13 @@\n-    (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec, (jlong)buf->stx_btime.tv_sec);\n-    (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec, (jlong)buf->stx_btime.tv_nsec);\n+    if ((buf->stx_mask & STATX_BTIME) != 0) {\n+        \/\/  Birth time was filled in so use it\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec,\n+                             (jlong)buf->stx_btime.tv_sec);\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec,\n+                             (jlong)buf->stx_btime.tv_nsec);\n+    } else {\n+        \/\/  Birth time was not filled in: fall back to last modification time\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec,\n+                             (jlong)buf->stx_mtime.tv_sec);\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec,\n+                             (jlong)buf->stx_mtime.tv_nsec);\n+    }\n@@ -677,1 +689,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n@@ -709,1 +721,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n@@ -740,1 +752,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n@@ -773,1 +785,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -36,3 +36,3 @@\n-    private int dwVolumeSerialNumber;\n-    private int nFileIndexHigh;\n-    private int nFileIndexLow;\n+    private final int dwVolumeSerialNumber;\n+    private final int nFileIndexHigh;\n+    private final int nFileIndexLow;\n@@ -40,1 +40,6 @@\n-    private FileKey() { }\n+    private FileKey(int dwVolumeSerialNumber, int nFileIndexHigh,\n+        int nFileIndexLow) {\n+        this.dwVolumeSerialNumber = dwVolumeSerialNumber;\n+        this.nFileIndexHigh = nFileIndexHigh;\n+        this.nFileIndexLow = nFileIndexLow;\n+    }\n@@ -43,3 +48,3 @@\n-        FileKey fk = new FileKey();\n-        fk.init(fd);\n-        return fk;\n+        int finfo[] = new int[3];\n+        init(fd, finfo);\n+        return new FileKey(finfo[0], finfo[1], finfo[2]);\n@@ -63,2 +68,2 @@\n-    private native void init(FileDescriptor fd) throws IOException;\n-    private static native void initIDs();\n+    private static native void init(FileDescriptor fd, int[] finfo)\n+        throws IOException;\n@@ -68,1 +73,0 @@\n-        initIDs();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/FileKey.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,14 +33,0 @@\n-static jfieldID key_volumeSN;    \/* id for FileKey.dwVolumeSerialNumber *\/\n-static jfieldID key_indexHigh;   \/* id for FileKey.nFileIndexHigh *\/\n-static jfieldID key_indexLow;    \/* id for FileKey.nFileIndexLow *\/\n-\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileKey_initIDs(JNIEnv *env, jclass clazz)\n-{\n-    CHECK_NULL(key_volumeSN = (*env)->GetFieldID(env, clazz, \"dwVolumeSerialNumber\", \"I\"));\n-    CHECK_NULL(key_indexHigh = (*env)->GetFieldID(env, clazz, \"nFileIndexHigh\", \"I\"));\n-    CHECK_NULL(key_indexLow = (*env)->GetFieldID(env, clazz, \"nFileIndexLow\", \"I\"));\n-}\n-\n-\n@@ -48,1 +34,1 @@\n-Java_sun_nio_ch_FileKey_init(JNIEnv *env, jobject this, jobject fdo)\n+Java_sun_nio_ch_FileKey_init(JNIEnv *env, jclass clazz, jobject fdo, jintArray finfo)\n@@ -50,1 +36,1 @@\n-    HANDLE fileHandle = (HANDLE)(handleval(env, fdo));\n+    HANDLE fileHandle = (HANDLE)handleval(env, fdo);\n@@ -53,0 +39,1 @@\n+    jint info[3];\n@@ -56,3 +43,4 @@\n-        (*env)->SetIntField(env, this, key_volumeSN, fileInfo.dwVolumeSerialNumber);\n-        (*env)->SetIntField(env, this, key_indexHigh, fileInfo.nFileIndexHigh);\n-        (*env)->SetIntField(env, this, key_indexLow, fileInfo.nFileIndexLow);\n+        info[0] = (jint)fileInfo.dwVolumeSerialNumber;\n+        info[1] = (jint)fileInfo.nFileIndexHigh;\n+        info[2] = (jint)fileInfo.nFileIndexLow;\n+        (*env)->SetIntArrayRegion(env, finfo, 0, 3, info);\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileKey.c","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import javax.tools.JavaFileManager;\n@@ -31,1 +30,0 @@\n-import javax.lang.model.element.TypeElement;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Filer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-import java.util.Collections;\n-import java.util.Set;\n-import java.util.HashSet;\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-import java.lang.annotation.AnnotationTypeMismatchException;\n-import java.lang.annotation.IncompleteAnnotationException;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Element.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/VariableElement.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-import javax.lang.model.util.Types;\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/TypeVariable.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import javax.lang.model.element.*;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/TypeVisitor.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractAnnotationValueVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,3 +32,0 @@\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.ElementVisitor;\n-import javax.lang.model.element.RecordComponentElement;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractElementVisitorPreview.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import javax.lang.model.type.*;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitor9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner14.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner7.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.util.List;\n-import java.util.ArrayList;\n@@ -35,2 +33,0 @@\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScannerPreview.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleAnnotationValueVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor7.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,3 +32,0 @@\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.ElementVisitor;\n-import javax.lang.model.element.RecordComponentElement;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitorPreview.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import javax.lang.model.type.TypeVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.type.TypeVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor7.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import javax.lang.model.type.IntersectionType;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/TypeKindVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.lang.annotation.Annotation;\n-import java.lang.annotation.AnnotationTypeMismatchException;\n-import java.lang.annotation.IncompleteAnnotationException;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Types.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,2 +64,0 @@\n-    private static final Object FLAVOR_MAP_KEY = new Object();\n-\n","filename":"src\/java.datatransfer\/share\/classes\/java\/awt\/datatransfer\/SystemFlavorMap.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/eio\/FileManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaFileView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -391,1 +391,3 @@\n-            \"ctrl shift DOWN\", \"selectLastRowExtendSelection\"\n+            \"ctrl shift DOWN\", \"selectLastRowExtendSelection\",\n+            \"ctrl shift RIGHT\", \"selectLastColumnExtendSelection\",\n+            \"ctrl shift LEFT\", \"selectFirstColumnExtendSelection\"\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaKeyBindings.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaLookAndFeel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaMenuBarUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaNativeResources.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/ScreenMenu.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/awt\/PlatformGraphicsInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CAccessibility.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/LWCToolkit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGImageReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGImageWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/Platform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/SplashScreen.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1378,1 +1378,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Toolkit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/event\/NativeLibLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/ColorModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/NativeLibLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/ImagingLib.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/JPEGImageDecoder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/NativeLibLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontManagerNativeLibrary.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/Disposer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMS.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/CUPSPrinter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/PlatformGraphicsInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WToolkit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/windows\/classes\/sun\/print\/PrintServiceLookupProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/java.instrument\/share\/classes\/sun\/instrument\/InstrumentationImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1023,1 +1023,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/ManagementFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.prefs\/macosx\/classes\/java\/util\/prefs\/MacOSXPreferencesFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.prefs\/unix\/classes\/java\/util\/prefs\/FileSystemPreferences.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.prefs\/windows\/classes\/java\/util\/prefs\/WindowsPreferences.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/GC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/wrapper\/SunNativeProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -527,1 +527,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/Credentials.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/SCDynamicStoreConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.smartcardio\/unix\/classes\/sun\/security\/smartcardio\/PlatformPCSC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.smartcardio\/windows\/classes\/sun\/security\/smartcardio\/PlatformPCSC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.accessibility\/windows\/classes\/com\/sun\/java\/accessibility\/internal\/AccessBridge.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/aix\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/macosx\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/AttachProviderImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -465,12 +465,0 @@\n-class name java\/nio\/HeapByteBuffer\n-method name hashCode descriptor ()I flags 1\n-\n-class name java\/nio\/HeapByteBufferR\n-method name hashCode descriptor ()I flags 1\n-\n-class name java\/nio\/HeapCharBuffer\n-method name hashCode descriptor ()I flags 1\n-\n-class name java\/nio\/HeapCharBufferR\n-method name hashCode descriptor ()I flags 1\n-\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.base-N.sym.txt","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/SunMSCAPI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdDebuggerLocal.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/LinuxDebuggerLocal.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgDebuggerLocal.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+    @SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jdi\/windows\/classes\/com\/sun\/tools\/jdi\/SharedMemoryTransportService.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.vm.Continuation;\n@@ -74,9 +75,35 @@\n-    \/* synchronized because of writing the string to the JVM. *\/\n-    private static synchronized long storeString(String s) {\n-        Long lsid = cache.get(s);\n-        long internalSid;\n-        if (lsid != null) {\n-            internalSid = lsid.longValue();\n-            if (isCurrentGeneration(internalSid)) {\n-                \/\/ Someone already updated the cache.\n-                return externalSid(internalSid);\n+    \/* Explicitly pin a virtual thread before acquiring the string pool monitor\n+     * because migrating the EventWriter onto another carrier thread is impossible.\n+     *\/\n+    private static long storeString(String s, boolean pinVirtualThread) {\n+        if (pinVirtualThread) {\n+            assert(Thread.currentThread().isVirtual());\n+            Continuation.pin();\n+        }\n+        try {\n+            \/* synchronized because of writing the string to the JVM. *\/\n+            synchronized (StringPool.class) {\n+                Long lsid = cache.get(s);\n+                long internalSid;\n+                if (lsid != null) {\n+                    internalSid = lsid.longValue();\n+                    if (isCurrentGeneration(internalSid)) {\n+                        \/\/ Someone already updated the cache.\n+                        return externalSid(internalSid);\n+                    }\n+                    internalSid = updateInternalSid(internalSid);\n+                } else {\n+                    \/\/ Not yet added or the cache was cleared.\n+                    internalSid = nextInternalSid();\n+                    currentSizeUTF16 += s.length();\n+                }\n+                long extSid = externalSid(internalSid);\n+                \/\/ Write the string to the JVM before publishing to the cache.\n+                JVM.addStringConstant(extSid, s);\n+                cache.put(s, internalSid);\n+                return extSid;\n+            }\n+        } finally {\n+            if (pinVirtualThread) {\n+                assert(Thread.currentThread().isVirtual());\n+                Continuation.unpin();\n@@ -84,5 +111,0 @@\n-            internalSid = updateInternalSid(internalSid);\n-        } else {\n-            \/\/ Not yet added or the cache was cleared.\n-            internalSid = nextInternalSid();\n-            currentSizeUTF16 += s.length();\n@@ -90,5 +112,0 @@\n-        long extSid = externalSid(internalSid);\n-        \/\/ Write the string to the JVM before publishing to the cache.\n-        JVM.addStringConstant(extSid, s);\n-        cache.put(s, internalSid);\n-        return extSid;\n@@ -98,1 +115,1 @@\n-    private static long ensureCurrentGeneration(String s, Long lsid) {\n+    private static long ensureCurrentGeneration(String s, Long lsid, boolean pinVirtualThread) {\n@@ -100,1 +117,1 @@\n-        return isCurrentGeneration(internalSid) ? externalSid(internalSid) : storeString(s);\n+        return isCurrentGeneration(internalSid) ? externalSid(internalSid) : storeString(s, pinVirtualThread);\n@@ -112,1 +129,1 @@\n-    public static long addString(String s) {\n+    public static long addString(String s, boolean pinVirtualThread) {\n@@ -115,1 +132,1 @@\n-            return ensureCurrentGeneration(s, lsid);\n+            return ensureCurrentGeneration(s, lsid, pinVirtualThread);\n@@ -123,1 +140,1 @@\n-            reset();\n+            reset(pinVirtualThread);\n@@ -125,1 +142,1 @@\n-        return storeString(s);\n+        return storeString(s, pinVirtualThread);\n@@ -146,3 +163,16 @@\n-    private static synchronized void reset() {\n-        cache.clear();\n-        currentSizeUTF16 = 0;\n+    private static void reset(boolean pinVirtualThread) {\n+        if (pinVirtualThread) {\n+            assert(Thread.currentThread().isVirtual());\n+            Continuation.pin();\n+        }\n+        try {\n+            synchronized (StringPool.class) {\n+                cache.clear();\n+                currentSizeUTF16 = 0;\n+            }\n+        } finally {\n+            if (pinVirtualThread) {\n+                assert(Thread.currentThread().isVirtual());\n+                Continuation.unpin();\n+            }\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/StringPool.java","additions":59,"deletions":29,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+    private boolean pinVirtualThread;\n@@ -147,1 +148,1 @@\n-            long l = StringPool.addString(s);\n+            long l = StringPool.addString(s, pinVirtualThread);\n@@ -299,1 +300,1 @@\n-    private EventWriter(long startPos, long maxPos, long threadID, boolean valid, boolean excluded) {\n+    private EventWriter(long startPos, long maxPos, long threadID, boolean valid, boolean pinVirtualThread, boolean excluded) {\n@@ -304,0 +305,1 @@\n+        this.pinVirtualThread = pinVirtualThread;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventWriter.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/ExecutableRebrander.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExeBundler.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WindowsRegistry.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.management.agent\/unix\/classes\/jdk\/internal\/agent\/FileSystemImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.management.agent\/windows\/classes\/jdk\/internal\/agent\/FileSystemImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/Flag.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/PlatformMBeanProviderImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/aix\/classes\/jdk\/net\/AIXSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/linux\/classes\/jdk\/net\/LinuxSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/macosx\/classes\/jdk\/net\/MacOSXSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/windows\/classes\/jdk\/net\/WindowsSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1097,1 +1097,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpNet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-\n+    @SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/module\/NTSystem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    @SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/module\/UnixSystem.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+runtime\/interpreter\/LastJsrTest.java 8338924 linux-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2024 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests.scalarReplacement;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8333334\n+ * @summary Tests that dead barrier control flows do not affect the scalar replacement.\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.gc.G1\n+ * @run driver compiler.c2.irTests.scalarReplacement.ScalarReplacementWithGCBarrierTests\n+ *\/\n+public class ScalarReplacementWithGCBarrierTests {\n+    static class List {\n+        public Node head;\n+\n+        public void push(int value) {\n+            Node n = new Node();\n+            n.value = value;\n+            n.next = head;\n+            head = n;\n+        }\n+\n+        @ForceInline\n+        public Iter iter() {\n+            Iter iter = new Iter();\n+            iter.list = this;\n+            iter.n = head;\n+            iter.sum = 0;\n+            return iter;\n+        }\n+    }\n+\n+    static class Node {\n+        public int value;\n+        public Node next;\n+    }\n+\n+    static class Iter {\n+        public List list;\n+        public Node n;\n+        public Integer sum;\n+\n+        @ForceInline\n+        public boolean next() {\n+            int lastSum = sum;\n+            while (sum - lastSum < 1000) {\n+                while (n != null && n.value < 30) n = n.next;\n+                if (n == null) return false;\n+                sum += n.value;\n+                n = n.next;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private static final int SIZE = 1000;\n+\n+    public static void main(String[] args) {\n+        \/\/ Must use G1 GC to ensure there is a pre-barrier\n+        \/\/ before the first field write.\n+        TestFramework.runWithFlags(\"-XX:+UseG1GC\");\n+    }\n+\n+    @Run(test = \"testScalarReplacementWithGCBarrier\")\n+    private void runner() {\n+        List list = new List();\n+        for (int i = 0; i < SIZE; i++) {\n+            list.push(i);\n+        }\n+        testScalarReplacementWithGCBarrier(list);\n+    }\n+\n+    \/\/ Allocation of `Iter iter` should be eliminated by scalar replacement, and\n+    \/\/ the allocation of `Integer sum` can not be eliminated, so there should be\n+    \/\/ 1 allocation after allocations and locks elimination.\n+    \/\/\n+    \/\/ Before the patch of JDK-8333334, both allocations of `Iter` and `Integer`\n+    \/\/ could not be eliminated.\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.ALLOC, \"1\" })\n+    @IR(phase = { CompilePhase.INCREMENTAL_BOXING_INLINE }, counts = { IRNode.ALLOC, \"2\" })\n+    @IR(phase = { CompilePhase.ITER_GVN_AFTER_ELIMINATION }, counts = { IRNode.ALLOC, \"1\" })\n+    private int testScalarReplacementWithGCBarrier(List list) {\n+        Iter iter = list.iter();\n+        while (true) {\n+            while (iter.next()) {}\n+            if (list.head == null) break;\n+            list.head = list.head.next;\n+            iter.n = list.head;\n+        }\n+        return iter.sum;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/ScalarReplacementWithGCBarrierTests.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336830\n+ * @summary C2: assert(get_loop(lca)->_nest < n_loop->_nest || lca->in(0)->is_NeverBranch()) failed: must not be moved into inner loop\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:CompileCommand=compileonly,TestSunkNodeInInfiniteLoop::* -Xcomp TestSunkNodeInInfiniteLoop\n+ *\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+\n+public class TestSunkNodeInInfiniteLoop {\n+    public static void main(String[] args) throws InterruptedException {\n+        byte[] a = new byte[1];\n+        Thread thread = new Thread(() -> test(a));\n+        thread.setDaemon(true);\n+        thread.start();\n+        Thread.sleep(Utils.adjustTimeout(4000));\n+    }\n+\n+    static void test(byte[] a) {\n+        \/\/ L0:\n+        while(true) {\n+            int i1 = a.length;\n+            \/\/ L3:\n+            while(true) {\n+                int i2 = 0;\n+                if ((i1--) <= 0) { break; \/* ifle L0 *\/}\n+                a[i2++] = -1;\n+                \/\/ goto L3\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestSunkNodeInInfiniteLoop.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -147,1 +147,1 @@\n- * @run main\/othervm\/timeout=300 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=240 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSieveObjects.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class LastJsr\n+{\n+    public static Method test:\"()V\"\n+    stack 100 locals 100\n+    {\n+        return;\n+    LABEL:\n+        nop;\n+        jsr LABEL; \/\/ bci=2. Compute bci + length(jsr) -> bci = 5 accessed, out of bounds.\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/LastJsr.jasm","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class LastJsrReachable\n+{\n+    public static Method test:\"()V\"\n+    stack 100 locals 100\n+    {\n+        goto LB2;\n+    LABEL:\n+        return;\n+    LB2:\n+        nop;\n+        jsr LABEL;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/LastJsrReachable.jasm","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335664\n+ * @summary Ensure a program that ends with a JSR does not crash\n+ * @library \/test\/lib\n+ * @compile LastJsr.jasm\n+ * @compile LastJsrReachable.jasm\n+ * @run main\/othervm LastJsrTest\n+ *\/\n+\n+public class LastJsrTest {\n+    public static void main(String[] args) {\n+        LastJsr.test();\n+        LastJsrReachable.test();\n+        System.out.println(\"PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/LastJsrTest.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -52,0 +52,1 @@\n+                                                                 \"--enable-native-access=ALL-UNNAMED\",\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestCheckedReleaseArrayElements.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,1 +91,5 @@\n-            RestrictedMethod.of(ModuleLayer.Controller.class, \"enableNativeAccess\", ModuleLayer.Controller.class, Module.class)\n+            RestrictedMethod.of(ModuleLayer.Controller.class, \"enableNativeAccess\", ModuleLayer.Controller.class, Module.class),\n+            RestrictedMethod.of(System.class, \"load\", void.class, String.class),\n+            RestrictedMethod.of(System.class, \"loadLibrary\", void.class, String.class),\n+            RestrictedMethod.of(Runtime.class, \"load\", void.class, String.class),\n+            RestrictedMethod.of(Runtime.class, \"loadLibrary\", void.class, String.class)\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+ *        panama_jni_load_module\/*\n+ *        panama_jni_def_module\/*\n+ *        panama_jni_use_module\/*\n+ *\n@@ -65,1 +69,0 @@\n-                { \"panama_enable_native_access_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--enable-native-access=ALL-UNNAMED\"} },\n@@ -70,1 +73,1 @@\n-                { \"panama_comma_separated_enable_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--enable-native-access=java.base,ALL-UNNAMED\"} },\n+                { \"panama_comma_separated_enable_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--enable-native-access=panama_jni_load_module,panama_jni_def_module,ALL-UNNAMED\"} },\n@@ -75,1 +78,6 @@\n-                { \"panama_enable_native_access_warn_jni\", PANAMA_JNI, successWithWarning(\"ALL-UNNAMED\"), new String[]{} },\n+                { \"panama_enable_native_access_warn_jni\", PANAMA_JNI, successWithWarnings(\"panama_jni_load_module\", \"panama_jni_def_module\", \"ALL-UNNAMED\"), new String[]{} },\n+\n+                { \"panama_enable_native_access_allow\", PANAMA_MAIN, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n+                { \"panama_enable_native_access_allow_reflection\", PANAMA_REFLECTION, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n+                { \"panama_enable_native_access_allow_invoke\", PANAMA_INVOKE, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n+                { \"panama_enable_native_access_allow_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n@@ -79,0 +87,1 @@\n+                { \"panama_allow_unnamed_module_native_access\", UNNAMED, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n@@ -134,1 +143,1 @@\n-        run(\"panama_enable_native_access_warn_unknown_module\", PANAMA_MAIN,\n+        run(\"panama_deny_bad_unknown_module\", PANAMA_MAIN,\n@@ -136,2 +145,2 @@\n-                \"--enable-native-access=BAD\");\n-        run(\"panama_no_all_module_path_blanket_native_access\", PANAMA_MAIN,\n+                \"--illegal-native-access=deny\", \"--enable-native-access=BAD\");\n+        run(\"panama_deny_bad_all_module_path_module\", PANAMA_MAIN,\n@@ -139,1 +148,27 @@\n-                \"--enable-native-access=ALL-MODULE-PATH\" );\n+                \"--illegal-native-access=deny\", \"--enable-native-access=ALL-MODULE-PATH\" );\n+        run(\"panama_deny_no_module_main\", PANAMA_MAIN,\n+                failWithError(\"module panama_module\"),\n+                \"--illegal-native-access=deny\");\n+        run(\"panama_deny_no_module_invoke\", PANAMA_INVOKE,\n+                failWithError(\"module panama_module\"),\n+                \"--illegal-native-access=deny\");\n+        run(\"panama_deny_no_module_reflection\", PANAMA_REFLECTION,\n+                failWithError(\"module panama_module\"),\n+                \"--illegal-native-access=deny\");\n+        run(\"panama_deny_no_module_jni\", PANAMA_JNI,\n+                failWithError(\"module panama_jni_load_module\"),\n+                \"--illegal-native-access=deny\");\n+    }\n+\n+    public void testDetailedWarningMessage() throws Exception {\n+        run(\"panama_enable_native_access_warn_jni\", PANAMA_JNI,\n+                success()\n+                        \/\/ call to System::loadLibrary from panama_jni_load_module\n+                        .expect(\"WARNING: A restricted method in java.lang.System has been called\")\n+                        .expect(\"WARNING: java.lang.System::loadLibrary has been called by org.openjdk.jni.PanamaMainJNI in module panama_jni_load_module\")\n+                        \/\/ JNI native method binding in panama_jni_def_module\n+                        .expect(\"WARNING: A native method in org.openjdk.jni.def.PanamaJNIDef has been bound\")\n+                        .expect(\"WARNING: org.openjdk.jni.def.PanamaJNIDef::nativeLinker0 is declared in module panama_jni_def_module\")\n+                        \/\/ upcall to Linker::downcallHandle from JNI code\n+                        .expect(\"WARNING: A restricted method in java.lang.foreign.Linker has been called\")\n+                        .expect(\"WARNING: java.lang.foreign.Linker::downcallHandle has been called by code in an unnamed module\"));\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccess.java","additions":42,"deletions":7,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-    static final String PANAMA_JNI_CLS = \"org.openjdk.foreigntest.PanamaMainJNI\";\n-    static final String PANAMA_JNI = \"panama_module\/\" + PANAMA_JNI_CLS;\n+    static final String PANAMA_JNI_CLS = \"org.openjdk.jni.PanamaMainJNI\";\n+    static final String PANAMA_JNI = \"panama_jni_load_module\/\" + PANAMA_JNI_CLS;\n@@ -102,0 +102,8 @@\n+    static Result successWithWarnings(String... moduleNames) {\n+        Result result = success();\n+        for (String moduleName : moduleNames) {\n+            result = result.expect(\"WARNING\").expect(\"--enable-native-access=\" + moduleName);\n+        }\n+        return result;\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessBase.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        String errMsg = \"Illegal native access from: module panama_module\";\n+        String errMsg = \"Illegal native access from module panama_module\";\n@@ -76,0 +76,1 @@\n+        list.add(\"--illegal-native-access=deny\");\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessDynamic.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module panama_jni_def_module {\n+    exports org.openjdk.jni.def;\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_def_module\/module-info.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jni.def;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+\n+public class PanamaJNIDef {\n+\n+    public static native void nativeLinker0(Linker linker, FunctionDescriptor desc, Linker.Option[] options);\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_def_module\/org\/openjdk\/jni\/def\/PanamaJNIDef.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -50,1 +50,1 @@\n-    Java_org_openjdk_foreigntest_PanamaMainJNI_nativeLinker0(JNIEnv *env, jclass cls, jobject linker, jobject desc, jobjectArray opts) {\n+    Java_org_openjdk_jni_def_PanamaJNIDef_nativeLinker0(JNIEnv *env, jclass cls, jobject linker, jobject desc, jobjectArray opts) {\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_def_module\/org\/openjdk\/jni\/def\/libLinkerInvokerModule.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/libLinkerInvokerModule.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module panama_jni_load_module {\n+    exports org.openjdk.jni;\n+    requires panama_jni_use_module;\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_load_module\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jni;\n+\n+import org.openjdk.jni.use.PanamaJNIUse;\n+\n+public class PanamaMainJNI {\n+\n+    public static void main(String[] args) {\n+        System.loadLibrary(\"LinkerInvokerModule\");\n+        PanamaJNIUse.run();\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_load_module\/org\/openjdk\/jni\/PanamaMainJNI.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module panama_jni_use_module {\n+    exports org.openjdk.jni.use;\n+    requires panama_jni_def_module;\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_use_module\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jni.use;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+\n+import org.openjdk.jni.def.PanamaJNIDef;\n+\n+public class PanamaJNIUse {\n+    public static void run() {\n+        testDirectAccessCLinker();\n+    }\n+\n+    public static void testDirectAccessCLinker() {\n+        System.out.println(\"Trying to get downcall handle\");\n+        PanamaJNIDef.nativeLinker0(Linker.nativeLinker(), FunctionDescriptor.ofVoid(), new Linker.Option[0]);\n+        System.out.println(\"Got downcall handle\");\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_use_module\/org\/openjdk\/jni\/use\/PanamaJNIUse.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -1,23 +0,0 @@\n-package org.openjdk.foreigntest;\n-\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-\n-public class PanamaMainJNI {\n-\n-    static {\n-        System.loadLibrary(\"LinkerInvokerModule\");\n-    }\n-\n-    public static void main(String[] args) {\n-        testDirectAccessCLinker();\n-    }\n-\n-    public static void testDirectAccessCLinker() {\n-        System.out.println(\"Trying to get downcall handle\");\n-        nativeLinker0(Linker.nativeLinker(), FunctionDescriptor.ofVoid(), new Linker.Option[0]);\n-        System.out.println(\"Got downcall handle\");\n-    }\n-\n-    static native void nativeLinker0(Linker linker, FunctionDescriptor desc, Linker.Option[] options);\n-}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainJNI.java","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm --enable-native-access=invoker_module\n+ * @run testng\/othervm --illegal-native-access=deny --enable-native-access=invoker_module\n","filename":"test\/jdk\/java\/foreign\/handles\/Driver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+        addDefaultMapping(Runtime.class, Runtime.getRuntime());\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,0 +74,12 @@\n+                    { MethodHandles.lookup().findStatic(System.class, \"load\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"System::load\" },\n+                    { MethodHandles.lookup().findStatic(System.class, \"loadLibrary\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"System::loadLibrary\" },\n+                    { MethodHandles.lookup().findVirtual(Runtime.class, \"load\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"Runtime::load\" },\n+                    { MethodHandles.lookup().findVirtual(Runtime.class, \"loadLibrary\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"Runtime::loadLibrary\" }\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n@@ -55,0 +57,1 @@\n+        private InetAddress listenInterface = InetAddress.getLoopbackAddress();\n@@ -60,0 +63,9 @@\n+        public InetAddress getListenInterface() {\n+            return listenInterface;\n+        }\n+\n+        public Builder setListenInterface(InetAddress listenInterface) {\n+            this.listenInterface = listenInterface;\n+            return this;\n+        }\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/interop\/AbstractServer.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import java.net.InetAddress;\n@@ -56,1 +57,2 @@\n-                = (SSLServerSocket) serverFactory.createServerSocket(builder.getPort());\n+                = (SSLServerSocket) serverFactory.createServerSocket(builder.getPort(),\n+                    0, builder.getListenInterface());\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/interop\/JdkServer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @bug 4112270 8264102\n+ * @bug 4112270 8264102 8329756\n@@ -181,1 +181,1 @@\n-                 and verifying each key combinations against the spec defined.\n+                 and verify each key combination against the spec defined.\n@@ -273,1 +273,1 @@\n-                FN+Up Arrow\/FN+Down Arrow - Deselect current selection;\n+                fn+Up\/Down Arrow - Deselect current selection;\n@@ -276,4 +276,1 @@\n-                Control-FN+Up Arrow\/FN+Down Arrow - Deselect current selection;\n-                                                    move focus and view to\n-                                                    first\/last cell in current row\n-                F2 - Allows editing in a cell containing information without\n+                fn - Allows editing in a cell containing information without\n@@ -283,2 +280,1 @@\n-                Ctrl+A, Ctrl+\/ - Select All\n-                Ctrl+\\\\ - Deselect all\n+                Cmd+A - Select All\n@@ -287,4 +283,3 @@\n-                FN-Shift Up\/Down Arrow -  Extend selection to top\/bottom of column\n-                Shift-PageUp\/PageDown - Extend selection up\/down one view and scroll\n-                                        table\n-                                \"\"\";\n+                Ctrl-Shift Up\/Down Arrow -  Extend selection to top\/bottom of row\n+                Ctrl-Shift Left\/Right Arrow -  Extend selection to first\/last of column\n+                \"\"\";\n","filename":"test\/jdk\/javax\/swing\/JTable\/KeyBoardNavigation.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.threading;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ThreadFactory;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedThread;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8338417\n+ * @summary Tests pinning of virtual threads when the JFR string pool monitor is contended.\n+ * @key jfr\n+ * @requires vm.hasJFR & vm.continuations\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.threading.TestStringPoolVirtualThreadPinning\n+ *\/\n+public class TestStringPoolVirtualThreadPinning {\n+\n+    private static final int VIRTUAL_THREAD_COUNT = 100_000;\n+    private static final int STARTER_THREADS = 10;\n+\n+    @Name(\"test.Tester\")\n+    private static class TestEvent extends Event {\n+        private String eventString = Thread.currentThread().getName();\n+    }\n+\n+    \/*\n+     * During event commit, the thread is in a critical section because it has loaded a carrier thread local event writer object.\n+     * For virtual threads, a contended monitor, such as a synchronized block, is a point where a thread could become unmounted.\n+     * A monitor guards the JFR string pool, but because of the event writer, remounting a virtual thread onto another carrier is impossible.\n+     *\n+     * The test provokes JFR string pool monitor contention to exercise explicit pin constructs to ensure the pinning of virtual threads.\n+    *\/\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+\n+            ThreadFactory factory = Thread.ofVirtual().factory();\n+            CompletableFuture<?>[] c = new CompletableFuture[STARTER_THREADS];\n+            for (int j = 0; j < STARTER_THREADS; j++) {\n+                c[j] = CompletableFuture.runAsync(() -> {\n+                    for (int i = 0; i < VIRTUAL_THREAD_COUNT \/ STARTER_THREADS; i++) {\n+                        try {\n+                            Thread vt = factory.newThread(TestStringPoolVirtualThreadPinning::emitEvent);\n+                            \/\/ For an event field string to be placed in the JFR string pool, it must exceed 16 characters.\n+                            \/\/ We use the virtual thread name as the event field string so we can verify the result as a 1-1 mapping.\n+                            vt.setName(\"VirtualTestThread-\" + i);\n+                            vt.start();\n+                            vt.join();\n+                        } catch (InterruptedException ie) {\n+                            ie.printStackTrace();\n+                        }\n+                    }\n+                });\n+            }\n+            for (int j = 0; j < STARTER_THREADS; j++) {\n+                c[j].get();\n+            }\n+\n+            r.stop();\n+            Path p = Utils.createTempFile(\"test\", \".jfr\");\n+            r.dump(p);\n+            List<RecordedEvent> events = RecordingFile.readAllEvents(p);\n+            Asserts.assertEquals(events.size(), VIRTUAL_THREAD_COUNT, \"Expected \" + VIRTUAL_THREAD_COUNT + \" events\");\n+            for (RecordedEvent e : events) {\n+                RecordedThread t = e.getThread();\n+                Asserts.assertNotNull(t);\n+                Asserts.assertTrue(t.isVirtual());\n+                Asserts.assertEquals(e.getString(\"eventString\"), t.getJavaName());\n+            }\n+        }\n+    }\n+\n+    private static void emitEvent() {\n+        TestEvent t = new TestEvent();\n+        t.commit();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestStringPoolVirtualThreadPinning.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,2 +130,2 @@\n-            if (nif.getName().contains(\"awdl\")) {\n-                return false; \/\/ exclude awdl\n+            if (nif.getName().contains(\"awdl\") || nif.getName().contains(\"docker\")) {\n+                return false; \/\/ exclude awdl or docker\n@@ -148,0 +148,7 @@\n+\n+        if (Platform.isLinux()) {\n+            String dName = nif.getDisplayName();\n+            if (dName != null && dName.contains(\"docker\")) {\n+                return false;\n+            }\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/NetworkConfiguration.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -38,0 +39,1 @@\n+import java.util.Enumeration;\n@@ -130,0 +132,15 @@\n+    @Benchmark\n+    public int testConcurrentHashMapIterators() {\n+        ConcurrentHashMap<Integer, Integer> map = (ConcurrentHashMap<Integer, Integer>) staticMap;\n+        int sum = 0;\n+        Enumeration it = map.elements();\n+        while (it.hasMoreElements()) {\n+            sum += (int) it.nextElement();\n+        }\n+        it = map.keys();\n+        while (it.hasMoreElements()) {\n+            sum += (int) it.nextElement();\n+        }\n+        return sum;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/concurrent\/Maps.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}