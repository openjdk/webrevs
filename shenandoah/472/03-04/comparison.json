{"files":[{"patch":"@@ -577,43 +577,0 @@\n-bool ShenandoahRegionChunkIterator::has_next() const {\n-  return _index < _total_chunks;\n-}\n-\n-bool ShenandoahRegionChunkIterator::next(struct ShenandoahRegionChunk *assignment) {\n-  if (_index >= _total_chunks) {\n-    return false;\n-  }\n-  size_t new_index = Atomic::add(&_index, (size_t) 1, memory_order_relaxed);\n-  if (new_index > _total_chunks) {\n-    \/\/ First worker that hits new_index == _total_chunks continues, other\n-    \/\/ contending workers return false.\n-    return false;\n-  }\n-  \/\/ convert to zero-based indexing\n-  new_index--;\n-  assert(new_index < _total_chunks, \"Error\");\n-\n-  \/\/ Find the group number for the assigned chunk index\n-  size_t group_no;\n-  for (group_no = 0; new_index >= _group_entries[group_no]; group_no++)\n-    ;\n-  assert(group_no < _num_groups, \"Cannot have group no greater or equal to _num_groups\");\n-\n-  \/\/ All size computations measured in HeapWord\n-  size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n-  size_t group_region_index = _region_index[group_no];\n-  size_t group_region_offset = _group_offset[group_no];\n-\n-  size_t index_within_group = (group_no == 0)? new_index: new_index - _group_entries[group_no - 1];\n-  size_t group_chunk_size = _group_chunk_size[group_no];\n-  size_t offset_of_this_chunk = group_region_offset + index_within_group * group_chunk_size;\n-  size_t regions_spanned_by_chunk_offset = offset_of_this_chunk \/ region_size_words;\n-  size_t offset_within_region = offset_of_this_chunk % region_size_words;\n-\n-  size_t region_index = group_region_index + regions_spanned_by_chunk_offset;\n-\n-  assignment->_r = _heap->get_region(region_index);\n-  assignment->_chunk_offset = offset_within_region;\n-  assignment->_chunk_size = group_chunk_size;\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -999,1 +999,1 @@\n-  bool next(struct ShenandoahRegionChunk *assignment);\n+  inline bool next(struct ShenandoahRegionChunk *assignment);\n@@ -1003,1 +1003,1 @@\n-  bool has_next() const;\n+  inline bool has_next() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -378,0 +378,44 @@\n+\n+inline bool ShenandoahRegionChunkIterator::has_next() const {\n+  return _index < _total_chunks;\n+}\n+\n+inline bool ShenandoahRegionChunkIterator::next(struct ShenandoahRegionChunk *assignment) {\n+  if (_index >= _total_chunks) {\n+    return false;\n+  }\n+  size_t new_index = Atomic::add(&_index, (size_t) 1, memory_order_relaxed);\n+  if (new_index > _total_chunks) {\n+    \/\/ First worker that hits new_index == _total_chunks continues, other\n+    \/\/ contending workers return false.\n+    return false;\n+  }\n+  \/\/ convert to zero-based indexing\n+  new_index--;\n+  assert(new_index < _total_chunks, \"Error\");\n+\n+  \/\/ Find the group number for the assigned chunk index\n+  size_t group_no;\n+  for (group_no = 0; new_index >= _group_entries[group_no]; group_no++)\n+    ;\n+  assert(group_no < _num_groups, \"Cannot have group no greater or equal to _num_groups\");\n+\n+  \/\/ All size computations measured in HeapWord\n+  size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n+  size_t group_region_index = _region_index[group_no];\n+  size_t group_region_offset = _group_offset[group_no];\n+\n+  size_t index_within_group = (group_no == 0)? new_index: new_index - _group_entries[group_no - 1];\n+  size_t group_chunk_size = _group_chunk_size[group_no];\n+  size_t offset_of_this_chunk = group_region_offset + index_within_group * group_chunk_size;\n+  size_t regions_spanned_by_chunk_offset = offset_of_this_chunk \/ region_size_words;\n+  size_t offset_within_region = offset_of_this_chunk % region_size_words;\n+\n+  size_t region_index = group_region_index + regions_spanned_by_chunk_offset;\n+\n+  assignment->_r = _heap->get_region(region_index);\n+  assignment->_chunk_offset = offset_within_region;\n+  assignment->_chunk_size = group_chunk_size;\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"}]}