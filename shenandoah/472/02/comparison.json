{"files":[{"patch":"@@ -92,1 +92,1 @@\n-  RememberedScanner* _scanner;\n+  ShenandoahScanRemembered* _scanner;\n@@ -94,1 +94,1 @@\n-  ShenandoahMergeWriteTable(RememberedScanner* scanner) : _scanner(scanner) {}\n+  ShenandoahMergeWriteTable(ShenandoahScanRemembered* scanner) : _scanner(scanner) {}\n@@ -108,1 +108,1 @@\n-  RememberedScanner* _scanner;\n+  ShenandoahScanRemembered* _scanner;\n@@ -110,1 +110,1 @@\n-  ShenandoahCopyWriteCardTableToRead(RememberedScanner* scanner) : _scanner(scanner) {}\n+  ShenandoahCopyWriteCardTableToRead(ShenandoahScanRemembered* scanner) : _scanner(scanner) {}\n@@ -853,1 +853,1 @@\n-    RememberedScanner* scanner = heap->old_generation()->card_scan();\n+    ShenandoahScanRemembered* scanner = heap->old_generation()->card_scan();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-  RememberedScanner* const scanner = old_gen->card_scan();\n+  ShenandoahScanRemembered* const scanner = old_gen->card_scan();\n@@ -273,1 +273,1 @@\n-  RememberedScanner* const scanner = old_gen->card_scan();\n+  ShenandoahScanRemembered* const scanner = old_gen->card_scan();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -860,1 +860,1 @@\n-      RememberedScanner* scanner = _heap->old_generation()->card_scan();\n+      ShenandoahScanRemembered* scanner = _heap->old_generation()->card_scan();\n@@ -953,1 +953,1 @@\n-                      CardTable::card_size_in_words() * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+                      CardTable::card_size_in_words() * ShenandoahCardCluster::CardsPerCluster;\n@@ -982,1 +982,1 @@\n-    RememberedScanner* card_scan = old_generation()->card_scan();\n+    ShenandoahScanRemembered* card_scan = old_generation()->card_scan();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -526,1 +526,1 @@\n-  RememberedScanner* scanner = heap->old_generation()->card_scan();\n+  ShenandoahScanRemembered* scanner = heap->old_generation()->card_scan();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-    _card_scan = new ShenandoahScanRemembered<ShenandoahDirectCardMarkRememberedSet>(rs);\n+    _card_scan = new ShenandoahScanRemembered(rs);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-  RememberedScanner* _card_scan;\n+  ShenandoahScanRemembered* _card_scan;\n@@ -183,1 +183,1 @@\n-  RememberedScanner* card_scan() { return _card_scan; }\n+  ShenandoahScanRemembered* card_scan() { return _card_scan; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,585 @@\n+size_t ShenandoahDirectCardMarkRememberedSet::last_valid_index() const {\n+  return _card_table->last_valid_index();\n+}\n+\n+size_t ShenandoahDirectCardMarkRememberedSet::total_cards() const {\n+  return _total_card_count;\n+}\n+\n+size_t ShenandoahDirectCardMarkRememberedSet::card_index_for_addr(HeapWord *p) const {\n+  return _card_table->index_for(p);\n+}\n+\n+HeapWord* ShenandoahDirectCardMarkRememberedSet::addr_for_card_index(size_t card_index) const {\n+  return _whole_heap_base + CardTable::card_size_in_words() * card_index;\n+}\n+\n+bool ShenandoahDirectCardMarkRememberedSet::is_write_card_dirty(size_t card_index) const {\n+  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n+  return (bp[0] == CardTable::dirty_card_val());\n+}\n+\n+bool ShenandoahDirectCardMarkRememberedSet::is_card_dirty(size_t card_index) const {\n+  CardValue* bp = &(_card_table->read_byte_map())[card_index];\n+  return (bp[0] == CardTable::dirty_card_val());\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_card_as_dirty(size_t card_index) {\n+  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n+  bp[0] = CardTable::dirty_card_val();\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_range_as_dirty(size_t card_index, size_t num_cards) {\n+  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n+  while (num_cards-- > 0) {\n+    *bp++ = CardTable::dirty_card_val();\n+  }\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(size_t card_index) {\n+  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n+  bp[0] = CardTable::clean_card_val();\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_range_as_clean(size_t card_index, size_t num_cards) {\n+  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n+  while (num_cards-- > 0) {\n+    *bp++ = CardTable::clean_card_val();\n+  }\n+}\n+\n+bool ShenandoahDirectCardMarkRememberedSet::is_card_dirty(HeapWord *p) const {\n+  size_t index = card_index_for_addr(p);\n+  CardValue* bp = &(_card_table->read_byte_map())[index];\n+  return (bp[0] == CardTable::dirty_card_val());\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_card_as_dirty(HeapWord *p) {\n+  size_t index = card_index_for_addr(p);\n+  CardValue* bp = &(_card_table->write_byte_map())[index];\n+  bp[0] = CardTable::dirty_card_val();\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_range_as_dirty(HeapWord *p, size_t num_heap_words) {\n+  CardValue* bp = &(_card_table->write_byte_map_base())[uintptr_t(p) >> _card_shift];\n+  CardValue* end_bp = &(_card_table->write_byte_map_base())[uintptr_t(p + num_heap_words) >> _card_shift];\n+  \/\/ If (p + num_heap_words) is not aligned on card boundary, we also need to dirty last card.\n+  if (((unsigned long long) (p + num_heap_words)) & (CardTable::card_size() - 1)) {\n+    end_bp++;\n+  }\n+  while (bp < end_bp) {\n+    *bp++ = CardTable::dirty_card_val();\n+  }\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(HeapWord *p) {\n+  size_t index = card_index_for_addr(p);\n+  CardValue* bp = &(_card_table->write_byte_map())[index];\n+  bp[0] = CardTable::clean_card_val();\n+}\n+\n+void ShenandoahDirectCardMarkRememberedSet::mark_range_as_clean(HeapWord *p, size_t num_heap_words) {\n+  CardValue* bp = &(_card_table->write_byte_map_base())[uintptr_t(p) >> _card_shift];\n+  CardValue* end_bp = &(_card_table->write_byte_map_base())[uintptr_t(p + num_heap_words) >> _card_shift];\n+  \/\/ If (p + num_heap_words) is not aligned on card boundary, we also need to clean last card.\n+  if (((unsigned long long) (p + num_heap_words)) & (CardTable::card_size() - 1)) {\n+    end_bp++;\n+  }\n+  while (bp < end_bp) {\n+    *bp++ = CardTable::clean_card_val();\n+  }\n+}\n+\n+size_t ShenandoahDirectCardMarkRememberedSet::cluster_count() const {\n+  return _cluster_count;\n+}\n+\n+\/\/ No lock required because arguments align with card boundaries.\n+void ShenandoahCardCluster::reset_object_range(HeapWord* from, HeapWord* to) {\n+  assert(((((unsigned long long) from) & (CardTable::card_size() - 1)) == 0) &&\n+         ((((unsigned long long) to) & (CardTable::card_size() - 1)) == 0),\n+         \"reset_object_range bounds must align with card boundaries\");\n+  size_t card_at_start = _rs->card_index_for_addr(from);\n+  size_t num_cards = (to - from) \/ CardTable::card_size_in_words();\n+\n+  for (size_t i = 0; i < num_cards; i++) {\n+    object_starts[card_at_start + i].short_word = 0;\n+  }\n+}\n+\n+\/\/ Assume only one thread at a time registers objects pertaining to\n+\/\/ each card-table entry's range of memory.\n+void ShenandoahCardCluster::register_object(HeapWord* address) {\n+  shenandoah_assert_heaplocked();\n+\n+  register_object_without_lock(address);\n+}\n+\n+void ShenandoahCardCluster::register_object_without_lock(HeapWord* address) {\n+  size_t card_at_start = _rs->card_index_for_addr(address);\n+  HeapWord *card_start_address = _rs->addr_for_card_index(card_at_start);\n+  uint8_t offset_in_card = address - card_start_address;\n+\n+  if (!starts_object(card_at_start)) {\n+    set_starts_object_bit(card_at_start);\n+    set_first_start(card_at_start, offset_in_card);\n+    set_last_start(card_at_start, offset_in_card);\n+  } else {\n+    if (offset_in_card < get_first_start(card_at_start))\n+      set_first_start(card_at_start, offset_in_card);\n+    if (offset_in_card > get_last_start(card_at_start))\n+      set_last_start(card_at_start, offset_in_card);\n+  }\n+}\n+\n+void ShenandoahCardCluster::coalesce_objects(HeapWord* address, size_t length_in_words) {\n+\n+  size_t card_at_start = _rs->card_index_for_addr(address);\n+  HeapWord *card_start_address = _rs->addr_for_card_index(card_at_start);\n+  size_t card_at_end = card_at_start + ((address + length_in_words) - card_start_address) \/ CardTable::card_size_in_words();\n+\n+  if (card_at_start == card_at_end) {\n+    \/\/ There are no changes to the get_first_start array.  Either get_first_start(card_at_start) returns this coalesced object,\n+    \/\/ or it returns an object that precedes the coalesced object.\n+    if (card_start_address + get_last_start(card_at_start) < address + length_in_words) {\n+      uint8_t coalesced_offset = static_cast<uint8_t>(address - card_start_address);\n+      \/\/ The object that used to be the last object starting within this card is being subsumed within the coalesced\n+      \/\/ object.  Since we always coalesce entire objects, this condition only occurs if the last object ends before or at\n+      \/\/ the end of the card's memory range and there is no object following this object.  In this case, adjust last_start\n+      \/\/ to represent the start of the coalesced range.\n+      set_last_start(card_at_start, coalesced_offset);\n+    }\n+    \/\/ Else, no changes to last_starts information.  Either get_last_start(card_at_start) returns the object that immediately\n+    \/\/ follows the coalesced object, or it returns an object that follows the object immediately following the coalesced object.\n+  } else {\n+    uint8_t coalesced_offset = static_cast<uint8_t>(address - card_start_address);\n+    if (get_last_start(card_at_start) > coalesced_offset) {\n+      \/\/ Existing last start is being coalesced, create new last start\n+      set_last_start(card_at_start, coalesced_offset);\n+    }\n+    \/\/ otherwise, get_last_start(card_at_start) must equal coalesced_offset\n+\n+    \/\/ All the cards between first and last get cleared.\n+    for (size_t i = card_at_start + 1; i < card_at_end; i++) {\n+      clear_starts_object_bit(i);\n+    }\n+\n+    uint8_t follow_offset = static_cast<uint8_t>((address + length_in_words) - _rs->addr_for_card_index(card_at_end));\n+    if (starts_object(card_at_end) && (get_first_start(card_at_end) < follow_offset)) {\n+      \/\/ It may be that after coalescing within this last card's memory range, the last card\n+      \/\/ no longer holds an object.\n+      if (get_last_start(card_at_end) >= follow_offset) {\n+        set_first_start(card_at_end, follow_offset);\n+      } else {\n+        \/\/ last_start is being coalesced so this card no longer has any objects.\n+        clear_starts_object_bit(card_at_end);\n+      }\n+    }\n+    \/\/ else\n+    \/\/  card_at_end did not have an object, so it still does not have an object, or\n+    \/\/  card_at_end had an object that starts after the coalesced object, so no changes required for card_at_end\n+\n+  }\n+}\n+\n+\n+size_t ShenandoahCardCluster::get_first_start(size_t card_index) const {\n+  assert(starts_object(card_index), \"Can't get first start because no object starts here\");\n+  return object_starts[card_index].offsets.first & FirstStartBits;\n+}\n+\n+size_t ShenandoahCardCluster::get_last_start(size_t card_index) const {\n+  assert(starts_object(card_index), \"Can't get last start because no object starts here\");\n+  return object_starts[card_index].offsets.last;\n+}\n+\n+\/\/ Given a card_index, return the starting address of the first block in the heap\n+\/\/ that straddles into this card. If this card is co-initial with an object, then\n+\/\/ this would return the first address of the range that this card covers, which is\n+\/\/ where the card's first object also begins.\n+\/\/ TODO: collect some stats for the size of walks backward over cards.\n+\/\/ For larger objects, a logarithmic BOT such as used by G1 might make the\n+\/\/ backwards walk potentially faster.\n+HeapWord* ShenandoahCardCluster::block_start(const size_t card_index) const {\n+\n+  HeapWord* left = _rs->addr_for_card_index(card_index);\n+\n+#ifdef ASSERT\n+  assert(ShenandoahHeap::heap()->mode()->is_generational(), \"Do not use in non-generational mode\");\n+  ShenandoahHeapRegion* region = ShenandoahHeap::heap()->heap_region_containing(left);\n+  assert(region->is_old(), \"Do not use for young regions\");\n+  \/\/ For HumongousRegion:s it's more efficient to jump directly to the\n+  \/\/ start region.\n+  assert(!region->is_humongous(), \"Use region->humongous_start_region() instead\");\n+#endif\n+  if (starts_object(card_index) && get_first_start(card_index) == 0) {\n+    \/\/ This card contains a co-initial object; a fortiori, it covers\n+    \/\/ also the case of a card being the first in a region.\n+    assert(oopDesc::is_oop(cast_to_oop(left)), \"Should be an object\");\n+    return left;\n+  }\n+\n+  HeapWord* p = nullptr;\n+  oop obj = cast_to_oop(p);\n+  ssize_t cur_index = (ssize_t)card_index;\n+  assert(cur_index >= 0, \"Overflow\");\n+  assert(cur_index > 0, \"Should have returned above\");\n+  \/\/ Walk backwards over the cards...\n+  while (--cur_index > 0 && !starts_object(cur_index)) {\n+   \/\/ ... to the one that starts the object\n+  }\n+  \/\/ cur_index should start an object: we should not have walked\n+  \/\/ past the left end of the region.\n+  assert(cur_index >= 0 && (cur_index <= (ssize_t)card_index), \"Error\");\n+  assert(region->bottom() <= _rs->addr_for_card_index(cur_index),\n+         \"Fell off the bottom of containing region\");\n+  assert(starts_object(cur_index), \"Error\");\n+  size_t offset = get_last_start(cur_index);\n+  \/\/ can avoid call via card size arithmetic below instead\n+  p = _rs->addr_for_card_index(cur_index) + offset;\n+  \/\/ Recall that we already dealt with the co-initial object case above\n+  assert(p < left, \"obj should start before left\");\n+  \/\/ While it is safe to ask an object its size in the loop that\n+  \/\/ follows, the (ifdef'd out) loop should never be needed.\n+  \/\/ 1. we ask this question only for regions in the old generation\n+  \/\/ 2. there is no direct allocation ever by mutators in old generation\n+  \/\/    regions. Only GC will ever allocate in old regions, and then\n+  \/\/    too only during promotion\/evacuation phases. Thus there is no danger\n+  \/\/    of races between reading from and writing to the object start array,\n+  \/\/    or of asking partially initialized objects their size (in the loop below).\n+  \/\/ 3. only GC asks this question during phases when it is not concurrently\n+  \/\/    evacuating\/promoting, viz. during concurrent root scanning (before\n+  \/\/    the evacuation phase) and during concurrent update refs (after the\n+  \/\/    evacuation phase) of young collections. This is never called\n+  \/\/    during old or global collections.\n+  \/\/ 4. Every allocation under TAMS updates the object start array.\n+  NOT_PRODUCT(obj = cast_to_oop(p);)\n+  assert(oopDesc::is_oop(obj), \"Should be an object\");\n+#define WALK_FORWARD_IN_BLOCK_START false\n+  while (WALK_FORWARD_IN_BLOCK_START && p + obj->size() < left) {\n+    p += obj->size();\n+  }\n+#undef WALK_FORWARD_IN_BLOCK_START \/\/ false\n+  assert(p + obj->size() > left, \"obj should end after left\");\n+  return p;\n+}\n+\n+size_t ShenandoahScanRemembered::last_valid_index() {\n+  return _rs->last_valid_index();\n+}\n+\n+size_t ShenandoahScanRemembered::total_cards() {\n+  return _rs->total_cards();\n+}\n+\n+size_t ShenandoahScanRemembered::card_index_for_addr(HeapWord *p) {\n+  return _rs->card_index_for_addr(p);\n+}\n+\n+HeapWord* ShenandoahScanRemembered::addr_for_card_index(size_t card_index) {\n+  return _rs->addr_for_card_index(card_index);\n+}\n+\n+bool ShenandoahScanRemembered::is_card_dirty(size_t card_index) {\n+  return _rs->is_card_dirty(card_index);\n+}\n+\n+bool ShenandoahScanRemembered::is_write_card_dirty(size_t card_index) {\n+  return _rs->is_write_card_dirty(card_index);\n+}\n+\n+void ShenandoahScanRemembered::mark_card_as_dirty(size_t card_index) {\n+  _rs->mark_card_as_dirty(card_index);\n+}\n+\n+void ShenandoahScanRemembered::mark_range_as_dirty(size_t card_index, size_t num_cards) {\n+  _rs->mark_range_as_dirty(card_index, num_cards);\n+}\n+\n+void ShenandoahScanRemembered::mark_card_as_clean(size_t card_index) {\n+  _rs->mark_card_as_clean(card_index);\n+}\n+\n+void ShenandoahScanRemembered::mark_range_as_clean(size_t card_index, size_t num_cards) {\n+  _rs->mark_range_as_clean(card_index, num_cards);\n+}\n+\n+bool ShenandoahScanRemembered::is_card_dirty(HeapWord *p) {\n+  return _rs->is_card_dirty(p);\n+}\n+\n+void ShenandoahScanRemembered::mark_card_as_dirty(HeapWord *p) {\n+  _rs->mark_card_as_dirty(p);\n+}\n+\n+void ShenandoahScanRemembered::mark_range_as_dirty(HeapWord *p, size_t num_heap_words) {\n+  _rs->mark_range_as_dirty(p, num_heap_words);\n+}\n+\n+void ShenandoahScanRemembered::mark_card_as_clean(HeapWord *p) {\n+  _rs->mark_card_as_clean(p);\n+}\n+\n+void ShenandoahScanRemembered:: mark_range_as_clean(HeapWord *p, size_t num_heap_words) {\n+  _rs->mark_range_as_clean(p, num_heap_words);\n+}\n+\n+size_t ShenandoahScanRemembered::cluster_count() {\n+  return _rs->cluster_count();\n+}\n+\n+void ShenandoahScanRemembered::reset_object_range(HeapWord *from, HeapWord *to) {\n+  _scc->reset_object_range(from, to);\n+}\n+\n+void ShenandoahScanRemembered::register_object(HeapWord *addr) {\n+  _scc->register_object(addr);\n+}\n+\n+void ShenandoahScanRemembered::register_object_without_lock(HeapWord *addr) {\n+  _scc->register_object_without_lock(addr);\n+}\n+\n+bool ShenandoahScanRemembered::verify_registration(HeapWord* address, ShenandoahMarkingContext* ctx) {\n+\n+  size_t index = card_index_for_addr(address);\n+  if (!_scc->starts_object(index)) {\n+    return false;\n+  }\n+  HeapWord* base_addr = addr_for_card_index(index);\n+  size_t offset = _scc->get_first_start(index);\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+\n+  \/\/ Verify that I can find this object within its enclosing card by scanning forward from first_start.\n+  while (base_addr + offset < address) {\n+    oop obj = cast_to_oop(base_addr + offset);\n+    if (!ctx || ctx->is_marked(obj)) {\n+      offset += obj->size();\n+    } else {\n+      \/\/ If this object is not live, don't trust its size(); all objects above tams are live.\n+      ShenandoahHeapRegion* r = heap->heap_region_containing(obj);\n+      HeapWord* tams = ctx->top_at_mark_start(r);\n+      offset = ctx->get_next_marked_addr(base_addr + offset, tams) - base_addr;\n+    }\n+  }\n+  if (base_addr + offset != address){\n+    return false;\n+  }\n+\n+  \/\/ At this point, offset represents object whose registration we are verifying.  We know that at least this object resides\n+  \/\/ within this card's memory.\n+\n+  \/\/ Make sure that last_offset is properly set for the enclosing card, but we can't verify this for\n+  \/\/ candidate collection-set regions during mixed evacuations, so disable this check in general\n+  \/\/ during mixed evacuations.\n+\n+  ShenandoahHeapRegion* r = heap->heap_region_containing(base_addr + offset);\n+  size_t max_offset = r->top() - base_addr;\n+  if (max_offset > CardTable::card_size_in_words()) {\n+    max_offset = CardTable::card_size_in_words();\n+  }\n+  size_t prev_offset;\n+  if (!ctx) {\n+    do {\n+      oop obj = cast_to_oop(base_addr + offset);\n+      prev_offset = offset;\n+      offset += obj->size();\n+    } while (offset < max_offset);\n+    if (_scc->get_last_start(index) != prev_offset) {\n+      return false;\n+    }\n+\n+    \/\/ base + offset represents address of first object that starts on following card, if there is one.\n+\n+    \/\/ Notes: base_addr is addr_for_card_index(index)\n+    \/\/        base_addr + offset is end of the object we are verifying\n+    \/\/        cannot use card_index_for_addr(base_addr + offset) because it asserts arg < end of whole heap\n+    size_t end_card_index = index + offset \/ CardTable::card_size_in_words();\n+\n+    if (end_card_index > index && end_card_index <= _rs->last_valid_index()) {\n+      \/\/ If there is a following object registered on the next card, it should begin where this object ends.\n+      if (_scc->starts_object(end_card_index) &&\n+          ((addr_for_card_index(end_card_index) + _scc->get_first_start(end_card_index)) != (base_addr + offset))) {\n+        return false;\n+      }\n+    }\n+\n+    \/\/ Assure that no other objects are registered \"inside\" of this one.\n+    for (index++; index < end_card_index; index++) {\n+      if (_scc->starts_object(index)) {\n+        return false;\n+      }\n+    }\n+  } else {\n+    \/\/ This is a mixed evacuation or a global collect: rely on mark bits to identify which objects need to be properly registered\n+    assert(!ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress(), \"Cannot rely on mark context here.\");\n+    \/\/ If the object reaching or spanning the end of this card's memory is marked, then last_offset for this card\n+    \/\/ should represent this object.  Otherwise, last_offset is a don't care.\n+    ShenandoahHeapRegion* region = heap->heap_region_containing(base_addr + offset);\n+    HeapWord* tams = ctx->top_at_mark_start(region);\n+    oop last_obj = nullptr;\n+    do {\n+      oop obj = cast_to_oop(base_addr + offset);\n+      if (ctx->is_marked(obj)) {\n+        prev_offset = offset;\n+        offset += obj->size();\n+        last_obj = obj;\n+      } else {\n+        offset = ctx->get_next_marked_addr(base_addr + offset, tams) - base_addr;\n+        \/\/ If there are no marked objects remaining in this region, offset equals tams - base_addr.  If this offset is\n+        \/\/ greater than max_offset, we will immediately exit this loop.  Otherwise, the next iteration of the loop will\n+        \/\/ treat the object at offset as marked and live (because address >= tams) and we will continue iterating object\n+        \/\/ by consulting the size() fields of each.\n+      }\n+    } while (offset < max_offset);\n+    if (last_obj != nullptr && prev_offset + last_obj->size() >= max_offset) {\n+      \/\/ last marked object extends beyond end of card\n+      if (_scc->get_last_start(index) != prev_offset) {\n+        return false;\n+      }\n+      \/\/ otherwise, the value of _scc->get_last_start(index) is a don't care because it represents a dead object and we\n+      \/\/ cannot verify its context\n+    }\n+  }\n+  return true;\n+}\n+\n+void ShenandoahScanRemembered::coalesce_objects(HeapWord *addr, size_t length_in_words) {\n+  _scc->coalesce_objects(addr, length_in_words);\n+}\n+\n+void ShenandoahScanRemembered::mark_range_as_empty(HeapWord *addr, size_t length_in_words) {\n+  _rs->mark_range_as_clean(addr, length_in_words);\n+  _scc->clear_objects_in_range(addr, length_in_words);\n+}\n+\n+size_t ShenandoahScanRemembered::cluster_for_addr(HeapWordImpl **addr) {\n+  size_t card_index = _rs->card_index_for_addr(addr);\n+  size_t result = card_index \/ ShenandoahCardCluster::CardsPerCluster;\n+  return result;\n+}\n+\n+HeapWord* ShenandoahScanRemembered::addr_for_cluster(size_t cluster_no) {\n+  size_t card_index = cluster_no * ShenandoahCardCluster::CardsPerCluster;\n+  return addr_for_card_index(card_index);\n+}\n+\n+\/\/ This is used only for debug verification so don't worry about making the scan parallel.\n+void ShenandoahScanRemembered::roots_do(OopIterateClosure* cl) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  bool old_bitmap_stable = heap->old_generation()->is_mark_complete();\n+  log_info(gc, remset)(\"Scan remembered set using bitmap: %s\", BOOL_TO_STR(old_bitmap_stable));\n+  for (size_t i = 0, n = heap->num_regions(); i < n; ++i) {\n+    ShenandoahHeapRegion* region = heap->get_region(i);\n+    if (region->is_old() && region->is_active() && !region->is_cset()) {\n+      HeapWord* start_of_range = region->bottom();\n+      HeapWord* end_of_range = region->top();\n+      size_t start_cluster_no = cluster_for_addr(start_of_range);\n+      size_t num_heapwords = end_of_range - start_of_range;\n+      unsigned int cluster_size = CardTable::card_size_in_words() * ShenandoahCardCluster::CardsPerCluster;\n+      size_t num_clusters = (size_t) ((num_heapwords - 1 + cluster_size) \/ cluster_size);\n+\n+      \/\/ Remembered set scanner\n+      if (region->is_humongous()) {\n+        process_humongous_clusters(region->humongous_start_region(), start_cluster_no, num_clusters, end_of_range, cl,\n+                                   false \/* use_write_table *\/);\n+      } else {\n+        process_clusters(start_cluster_no, num_clusters, end_of_range, cl,\n+                         false \/* use_write_table *\/, 0 \/* fake worker id *\/);\n+      }\n+    }\n+  }\n+}\n+\n+#ifndef PRODUCT\n+\/\/ Log given card stats\n+void ShenandoahScanRemembered::log_card_stats(HdrSeq* stats) {\n+  for (int i = 0; i < MAX_CARD_STAT_TYPE; i++) {\n+    log_info(gc, remset)(\"%18s: [ %8.2f %8.2f %8.2f %8.2f %8.2f ]\",\n+      _card_stats_name[i],\n+      stats[i].percentile(0), stats[i].percentile(25),\n+      stats[i].percentile(50), stats[i].percentile(75),\n+      stats[i].maximum());\n+  }\n+}\n+\n+\/\/ Log card stats for all nworkers for a specific phase t\n+void ShenandoahScanRemembered::log_card_stats(uint nworkers, CardStatLogType t) {\n+  assert(ShenandoahEnableCardStats, \"Do not call\");\n+  HdrSeq* sum_stats = card_stats_for_phase(t);\n+  log_info(gc, remset)(\"%s\", _card_stat_log_type[t]);\n+  for (uint i = 0; i < nworkers; i++) {\n+    log_worker_card_stats(i, sum_stats);\n+  }\n+\n+  \/\/ Every so often, log the cumulative global stats\n+  if (++_card_stats_log_counter[t] >= ShenandoahCardStatsLogInterval) {\n+    _card_stats_log_counter[t] = 0;\n+    log_info(gc, remset)(\"Cumulative stats\");\n+    log_card_stats(sum_stats);\n+  }\n+}\n+\n+\/\/ Log card stats for given worker_id, & clear them after merging into given cumulative stats\n+void ShenandoahScanRemembered::log_worker_card_stats(uint worker_id, HdrSeq* sum_stats) {\n+  assert(ShenandoahEnableCardStats, \"Do not call\");\n+\n+  HdrSeq* worker_card_stats = card_stats(worker_id);\n+  log_info(gc, remset)(\"Worker %u Card Stats: \", worker_id);\n+  log_card_stats(worker_card_stats);\n+  \/\/ Merge worker stats into the cumulative stats & clear worker stats\n+  merge_worker_card_stats_cumulative(worker_card_stats, sum_stats);\n+}\n+\n+void ShenandoahScanRemembered::merge_worker_card_stats_cumulative(\n+  HdrSeq* worker_stats, HdrSeq* sum_stats) {\n+  for (int i = 0; i < MAX_CARD_STAT_TYPE; i++) {\n+    sum_stats[i].add(worker_stats[i]);\n+    worker_stats[i].clear();\n+  }\n+}\n+#endif\n+\n+bool ShenandoahRegionChunkIterator::has_next() const {\n+  return _index < _total_chunks;\n+}\n+\n+bool ShenandoahRegionChunkIterator::next(struct ShenandoahRegionChunk *assignment) {\n+  if (_index >= _total_chunks) {\n+    return false;\n+  }\n+  size_t new_index = Atomic::add(&_index, (size_t) 1, memory_order_relaxed);\n+  if (new_index > _total_chunks) {\n+    \/\/ First worker that hits new_index == _total_chunks continues, other\n+    \/\/ contending workers return false.\n+    return false;\n+  }\n+  \/\/ convert to zero-based indexing\n+  new_index--;\n+  assert(new_index < _total_chunks, \"Error\");\n+\n+  \/\/ Find the group number for the assigned chunk index\n+  size_t group_no;\n+  for (group_no = 0; new_index >= _group_entries[group_no]; group_no++)\n+    ;\n+  assert(group_no < _num_groups, \"Cannot have group no greater or equal to _num_groups\");\n+\n+  \/\/ All size computations measured in HeapWord\n+  size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n+  size_t group_region_index = _region_index[group_no];\n+  size_t group_region_offset = _group_offset[group_no];\n+\n+  size_t index_within_group = (group_no == 0)? new_index: new_index - _group_entries[group_no - 1];\n+  size_t group_chunk_size = _group_chunk_size[group_no];\n+  size_t offset_of_this_chunk = group_region_offset + index_within_group * group_chunk_size;\n+  size_t regions_spanned_by_chunk_offset = offset_of_this_chunk \/ region_size_words;\n+  size_t offset_within_region = offset_of_this_chunk % region_size_words;\n+\n+  size_t region_index = group_region_index + regions_spanned_by_chunk_offset;\n+\n+  assignment->_r = _heap->get_region(region_index);\n+  assignment->_chunk_offset = offset_within_region;\n+  assignment->_chunk_size = group_chunk_size;\n+  return true;\n+}\n+\n@@ -41,1 +626,1 @@\n-  RememberedScanner*          const _scanner;\n+  ShenandoahScanRemembered*   const _scanner;\n@@ -75,1 +660,1 @@\n-  _cluster_count = total_card_count \/ ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+  _cluster_count = total_card_count \/ ShenandoahCardCluster::CardsPerCluster;\n@@ -83,1 +668,1 @@\n-  assert(total_card_count % ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster == 0, \"Invalid card count.\");\n+  assert(total_card_count % ShenandoahCardCluster::CardsPerCluster == 0, \"Invalid card count.\");\n@@ -165,1 +750,1 @@\n-  RememberedScanner* scanner = heap->old_generation()->card_scan();\n+  ShenandoahScanRemembered* scanner = heap->old_generation()->card_scan();\n@@ -177,1 +762,1 @@\n-        CardTable::card_size_in_words() * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+        CardTable::card_size_in_words() * ShenandoahCardCluster::CardsPerCluster;\n@@ -342,1 +927,1 @@\n-  size_t expected_chunk_size_words = _clusters_in_smallest_chunk * CardTable::card_size_in_words() * ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+  size_t expected_chunk_size_words = _clusters_in_smallest_chunk * CardTable::card_size_in_words() * ShenandoahCardCluster::CardsPerCluster;\n@@ -415,1 +1000,1 @@\n-  RememberedScanner* scanner = heap->old_generation()->card_scan();\n+  ShenandoahScanRemembered* scanner = heap->old_generation()->card_scan();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":592,"deletions":7,"binary":false,"changes":599,"status":"modified"},{"patch":"@@ -103,3 +103,1 @@\n-\/\/  Let rs represent the relevant RememberedSet implementation\n-\/\/    (an instance of ShenandoahDirectCardMarkRememberedSet or an instance\n-\/\/     of a to-be-implemented ShenandoahBufferWithSATBRememberedSet)\n+\/\/  Let rs represent the ShenandoahDirectCardMarkRememberedSet\n@@ -228,1 +226,4 @@\n-  inline const CardValue* get_card_table_byte_map(bool write_table) const;\n+  inline const CardValue* get_card_table_byte_map(bool use_write_table) const {\n+    return use_write_table ? _card_table->write_byte_map() : _card_table->read_byte_map();\n+  }\n+\n@@ -347,1 +348,1 @@\n-\/\/ RememberedSet, plus it supports register_object() and lookup_object().\n+\/\/ DirectCardMarkRememberedSet, plus it supports register_object() and lookup_object().\n@@ -354,4 +355,0 @@\n-\/\/ The RememberedSet template parameter is intended to represent either\n-\/\/     ShenandoahDirectCardMarkRememberedSet, or a to-be-implemented\n-\/\/     ShenandoahBufferWithSATBRememberedSet.\n-template<typename RememberedSet>\n@@ -361,1 +358,1 @@\n-  RememberedSet *_rs;\n+  ShenandoahDirectCardMarkRememberedSet* _rs;\n@@ -413,1 +410,1 @@\n-  ShenandoahCardCluster(RememberedSet *rs) {\n+  ShenandoahCardCluster(ShenandoahDirectCardMarkRememberedSet *rs) {\n@@ -687,1 +684,0 @@\n-template<typename RememberedSet>\n@@ -691,2 +687,2 @@\n-  RememberedSet* _rs;\n-  ShenandoahCardCluster<RememberedSet>* _scc;\n+  ShenandoahDirectCardMarkRememberedSet* _rs;\n+  ShenandoahCardCluster* _scc;\n@@ -718,16 +714,1 @@\n-  \/\/ How to instantiate this object?\n-  \/\/   ShenandoahDirectCardMarkRememberedSet *rs =\n-  \/\/       new ShenandoahDirectCardMarkRememberedSet();\n-  \/\/   scr = new\n-  \/\/     ShenandoahScanRememberd<ShenandoahDirectCardMarkRememberedSet>(rs);\n-  \/\/\n-  \/\/ or, after the planned implementation of\n-  \/\/ ShenandoahBufferWithSATBRememberedSet has been completed:\n-  \/\/\n-  \/\/   ShenandoahBufferWithSATBRememberedSet *rs =\n-  \/\/       new ShenandoahBufferWithSATBRememberedSet();\n-  \/\/   scr = new\n-  \/\/     ShenandoahScanRememberd<ShenandoahBufferWithSATBRememberedSet>(rs);\n-\n-\n-  ShenandoahScanRemembered(RememberedSet *rs) {\n+  ShenandoahScanRemembered(ShenandoahDirectCardMarkRememberedSet *rs) {\n@@ -735,1 +716,1 @@\n-    _scc = new ShenandoahCardCluster<RememberedSet>(rs);\n+    _scc = new ShenandoahCardCluster(rs);\n@@ -800,1 +781,1 @@\n-  bool is_write_card_dirty(size_t card_index) { return _rs->is_write_card_dirty(card_index); }\n+  bool is_write_card_dirty(size_t card_index);\n@@ -874,2 +855,0 @@\n-  \/\/ All template expansions require methods to be defined in the inline.hpp file, but larger\n-  \/\/ such methods need not be declared as inline.\n@@ -881,1 +860,1 @@\n-  inline void process_humongous_clusters(ShenandoahHeapRegion* r, size_t first_cluster, size_t count,\n+  void process_humongous_clusters(ShenandoahHeapRegion* r, size_t first_cluster, size_t count,\n@@ -885,1 +864,1 @@\n-  inline void process_region_slice(ShenandoahHeapRegion* region, size_t offset, size_t clusters, HeapWord* end_of_range,\n+  void process_region_slice(ShenandoahHeapRegion* region, size_t offset, size_t clusters, HeapWord* end_of_range,\n@@ -918,1 +897,1 @@\n-  inline void log_card_stats(HdrSeq* stats) PRODUCT_RETURN;\n+  void log_card_stats(HdrSeq* stats) PRODUCT_RETURN;\n@@ -954,2 +933,1 @@\n-  \/\/ This is computed from CardTable::card_size_in_words() *\n-  \/\/      ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+  \/\/ This is computed from CardTable::card_size_in_words() * ShenandoahCardCluster::CardsPerCluster;\n@@ -958,1 +936,1 @@\n-             ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n+             ShenandoahCardCluster::CardsPerCluster;\n@@ -1021,1 +999,1 @@\n-  inline bool next(struct ShenandoahRegionChunk *assignment);\n+  bool next(struct ShenandoahRegionChunk *assignment);\n@@ -1025,1 +1003,1 @@\n-  inline bool has_next() const;\n+  bool has_next() const;\n@@ -1028,1 +1006,0 @@\n-typedef ShenandoahScanRemembered<ShenandoahDirectCardMarkRememberedSet> RememberedScanner;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.hpp","additions":20,"deletions":43,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -41,500 +41,0 @@\n-inline size_t\n-ShenandoahDirectCardMarkRememberedSet::last_valid_index() const {\n-  return _card_table->last_valid_index();\n-}\n-\n-inline size_t\n-ShenandoahDirectCardMarkRememberedSet::total_cards() const {\n-  return _total_card_count;\n-}\n-\n-inline size_t\n-ShenandoahDirectCardMarkRememberedSet::card_index_for_addr(HeapWord *p) const {\n-  return _card_table->index_for(p);\n-}\n-\n-inline HeapWord*\n-ShenandoahDirectCardMarkRememberedSet::addr_for_card_index(size_t card_index) const {\n-  return _whole_heap_base + CardTable::card_size_in_words() * card_index;\n-}\n-\n-inline const CardValue*\n-ShenandoahDirectCardMarkRememberedSet::get_card_table_byte_map(bool use_write_table) const {\n-  return use_write_table ?\n-           _card_table->write_byte_map()\n-           : _card_table->read_byte_map();\n-}\n-\n-inline bool\n-ShenandoahDirectCardMarkRememberedSet::is_write_card_dirty(size_t card_index) const {\n-  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n-  return (bp[0] == CardTable::dirty_card_val());\n-}\n-\n-inline bool\n-ShenandoahDirectCardMarkRememberedSet::is_card_dirty(size_t card_index) const {\n-  CardValue* bp = &(_card_table->read_byte_map())[card_index];\n-  return (bp[0] == CardTable::dirty_card_val());\n-}\n-\n-inline void\n-ShenandoahDirectCardMarkRememberedSet::mark_card_as_dirty(size_t card_index) {\n-  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n-  bp[0] = CardTable::dirty_card_val();\n-}\n-\n-inline void\n-ShenandoahDirectCardMarkRememberedSet::mark_range_as_dirty(size_t card_index, size_t num_cards) {\n-  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n-  while (num_cards-- > 0) {\n-    *bp++ = CardTable::dirty_card_val();\n-  }\n-}\n-\n-inline void\n-ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(size_t card_index) {\n-  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n-  bp[0] = CardTable::clean_card_val();\n-}\n-\n-inline void\n-ShenandoahDirectCardMarkRememberedSet::mark_range_as_clean(size_t card_index, size_t num_cards) {\n-  CardValue* bp = &(_card_table->write_byte_map())[card_index];\n-  while (num_cards-- > 0) {\n-    *bp++ = CardTable::clean_card_val();\n-  }\n-}\n-\n-inline bool\n-ShenandoahDirectCardMarkRememberedSet::is_card_dirty(HeapWord *p) const {\n-  size_t index = card_index_for_addr(p);\n-  CardValue* bp = &(_card_table->read_byte_map())[index];\n-  return (bp[0] == CardTable::dirty_card_val());\n-}\n-\n-inline void\n-ShenandoahDirectCardMarkRememberedSet::mark_card_as_dirty(HeapWord *p) {\n-  size_t index = card_index_for_addr(p);\n-  CardValue* bp = &(_card_table->write_byte_map())[index];\n-  bp[0] = CardTable::dirty_card_val();\n-}\n-\n-inline void\n-ShenandoahDirectCardMarkRememberedSet::mark_range_as_dirty(HeapWord *p, size_t num_heap_words) {\n-  CardValue* bp = &(_card_table->write_byte_map_base())[uintptr_t(p) >> _card_shift];\n-  CardValue* end_bp = &(_card_table->write_byte_map_base())[uintptr_t(p + num_heap_words) >> _card_shift];\n-  \/\/ If (p + num_heap_words) is not aligned on card boundary, we also need to dirty last card.\n-  if (((unsigned long long) (p + num_heap_words)) & (CardTable::card_size() - 1)) {\n-    end_bp++;\n-  }\n-  while (bp < end_bp) {\n-    *bp++ = CardTable::dirty_card_val();\n-  }\n-}\n-\n-inline void\n-ShenandoahDirectCardMarkRememberedSet::mark_card_as_clean(HeapWord *p) {\n-  size_t index = card_index_for_addr(p);\n-  CardValue* bp = &(_card_table->write_byte_map())[index];\n-  bp[0] = CardTable::clean_card_val();\n-}\n-\n-inline void\n-ShenandoahDirectCardMarkRememberedSet::mark_range_as_clean(HeapWord *p, size_t num_heap_words) {\n-  CardValue* bp = &(_card_table->write_byte_map_base())[uintptr_t(p) >> _card_shift];\n-  CardValue* end_bp = &(_card_table->write_byte_map_base())[uintptr_t(p + num_heap_words) >> _card_shift];\n-  \/\/ If (p + num_heap_words) is not aligned on card boundary, we also need to clean last card.\n-  if (((unsigned long long) (p + num_heap_words)) & (CardTable::card_size() - 1)) {\n-    end_bp++;\n-  }\n-  while (bp < end_bp) {\n-    *bp++ = CardTable::clean_card_val();\n-  }\n-}\n-\n-inline size_t\n-ShenandoahDirectCardMarkRememberedSet::cluster_count() const {\n-  return _cluster_count;\n-}\n-\n-\/\/ No lock required because arguments align with card boundaries.\n-template<typename RememberedSet>\n-inline void\n-ShenandoahCardCluster<RememberedSet>::reset_object_range(HeapWord* from, HeapWord* to) {\n-  assert(((((unsigned long long) from) & (CardTable::card_size() - 1)) == 0) &&\n-         ((((unsigned long long) to) & (CardTable::card_size() - 1)) == 0),\n-         \"reset_object_range bounds must align with card boundaries\");\n-  size_t card_at_start = _rs->card_index_for_addr(from);\n-  size_t num_cards = (to - from) \/ CardTable::card_size_in_words();\n-\n-  for (size_t i = 0; i < num_cards; i++) {\n-    object_starts[card_at_start + i].short_word = 0;\n-  }\n-}\n-\n-\/\/ Assume only one thread at a time registers objects pertaining to\n-\/\/ each card-table entry's range of memory.\n-template<typename RememberedSet>\n-inline void\n-ShenandoahCardCluster<RememberedSet>::register_object(HeapWord* address) {\n-  shenandoah_assert_heaplocked();\n-\n-  register_object_without_lock(address);\n-}\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahCardCluster<RememberedSet>::register_object_without_lock(HeapWord* address) {\n-  size_t card_at_start = _rs->card_index_for_addr(address);\n-  HeapWord *card_start_address = _rs->addr_for_card_index(card_at_start);\n-  uint8_t offset_in_card = address - card_start_address;\n-\n-  if (!starts_object(card_at_start)) {\n-    set_starts_object_bit(card_at_start);\n-    set_first_start(card_at_start, offset_in_card);\n-    set_last_start(card_at_start, offset_in_card);\n-  } else {\n-    if (offset_in_card < get_first_start(card_at_start))\n-      set_first_start(card_at_start, offset_in_card);\n-    if (offset_in_card > get_last_start(card_at_start))\n-      set_last_start(card_at_start, offset_in_card);\n-  }\n-}\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahCardCluster<RememberedSet>::coalesce_objects(HeapWord* address, size_t length_in_words) {\n-\n-  size_t card_at_start = _rs->card_index_for_addr(address);\n-  HeapWord *card_start_address = _rs->addr_for_card_index(card_at_start);\n-  size_t card_at_end = card_at_start + ((address + length_in_words) - card_start_address) \/ CardTable::card_size_in_words();\n-\n-  if (card_at_start == card_at_end) {\n-    \/\/ There are no changes to the get_first_start array.  Either get_first_start(card_at_start) returns this coalesced object,\n-    \/\/ or it returns an object that precedes the coalesced object.\n-    if (card_start_address + get_last_start(card_at_start) < address + length_in_words) {\n-      uint8_t coalesced_offset = static_cast<uint8_t>(address - card_start_address);\n-      \/\/ The object that used to be the last object starting within this card is being subsumed within the coalesced\n-      \/\/ object.  Since we always coalesce entire objects, this condition only occurs if the last object ends before or at\n-      \/\/ the end of the card's memory range and there is no object following this object.  In this case, adjust last_start\n-      \/\/ to represent the start of the coalesced range.\n-      set_last_start(card_at_start, coalesced_offset);\n-    }\n-    \/\/ Else, no changes to last_starts information.  Either get_last_start(card_at_start) returns the object that immediately\n-    \/\/ follows the coalesced object, or it returns an object that follows the object immediately following the coalesced object.\n-  } else {\n-    uint8_t coalesced_offset = static_cast<uint8_t>(address - card_start_address);\n-    if (get_last_start(card_at_start) > coalesced_offset) {\n-      \/\/ Existing last start is being coalesced, create new last start\n-      set_last_start(card_at_start, coalesced_offset);\n-    }\n-    \/\/ otherwise, get_last_start(card_at_start) must equal coalesced_offset\n-\n-    \/\/ All the cards between first and last get cleared.\n-    for (size_t i = card_at_start + 1; i < card_at_end; i++) {\n-      clear_starts_object_bit(i);\n-    }\n-\n-    uint8_t follow_offset = static_cast<uint8_t>((address + length_in_words) - _rs->addr_for_card_index(card_at_end));\n-    if (starts_object(card_at_end) && (get_first_start(card_at_end) < follow_offset)) {\n-      \/\/ It may be that after coalescing within this last card's memory range, the last card\n-      \/\/ no longer holds an object.\n-      if (get_last_start(card_at_end) >= follow_offset) {\n-        set_first_start(card_at_end, follow_offset);\n-      } else {\n-        \/\/ last_start is being coalesced so this card no longer has any objects.\n-        clear_starts_object_bit(card_at_end);\n-      }\n-    }\n-    \/\/ else\n-    \/\/  card_at_end did not have an object, so it still does not have an object, or\n-    \/\/  card_at_end had an object that starts after the coalesced object, so no changes required for card_at_end\n-\n-  }\n-}\n-\n-\n-template<typename RememberedSet>\n-inline size_t\n-ShenandoahCardCluster<RememberedSet>::get_first_start(size_t card_index) const {\n-  assert(starts_object(card_index), \"Can't get first start because no object starts here\");\n-  return object_starts[card_index].offsets.first & FirstStartBits;\n-}\n-\n-template<typename RememberedSet>\n-inline size_t\n-ShenandoahCardCluster<RememberedSet>::get_last_start(size_t card_index) const {\n-  assert(starts_object(card_index), \"Can't get last start because no object starts here\");\n-  return object_starts[card_index].offsets.last;\n-}\n-\n-\/\/ Given a card_index, return the starting address of the first block in the heap\n-\/\/ that straddles into this card. If this card is co-initial with an object, then\n-\/\/ this would return the first address of the range that this card covers, which is\n-\/\/ where the card's first object also begins.\n-\/\/ TODO: collect some stats for the size of walks backward over cards.\n-\/\/ For larger objects, a logarithmic BOT such as used by G1 might make the\n-\/\/ backwards walk potentially faster.\n-template<typename RememberedSet>\n-HeapWord*\n-ShenandoahCardCluster<RememberedSet>::block_start(const size_t card_index) const {\n-\n-  HeapWord* left = _rs->addr_for_card_index(card_index);\n-\n-#ifdef ASSERT\n-  assert(ShenandoahHeap::heap()->mode()->is_generational(), \"Do not use in non-generational mode\");\n-  ShenandoahHeapRegion* region = ShenandoahHeap::heap()->heap_region_containing(left);\n-  assert(region->is_old(), \"Do not use for young regions\");\n-  \/\/ For HumongousRegion:s it's more efficient to jump directly to the\n-  \/\/ start region.\n-  assert(!region->is_humongous(), \"Use region->humongous_start_region() instead\");\n-#endif\n-  if (starts_object(card_index) && get_first_start(card_index) == 0) {\n-    \/\/ This card contains a co-initial object; a fortiori, it covers\n-    \/\/ also the case of a card being the first in a region.\n-    assert(oopDesc::is_oop(cast_to_oop(left)), \"Should be an object\");\n-    return left;\n-  }\n-\n-  HeapWord* p = nullptr;\n-  oop obj = cast_to_oop(p);\n-  ssize_t cur_index = (ssize_t)card_index;\n-  assert(cur_index >= 0, \"Overflow\");\n-  assert(cur_index > 0, \"Should have returned above\");\n-  \/\/ Walk backwards over the cards...\n-  while (--cur_index > 0 && !starts_object(cur_index)) {\n-   \/\/ ... to the one that starts the object\n-  }\n-  \/\/ cur_index should start an object: we should not have walked\n-  \/\/ past the left end of the region.\n-  assert(cur_index >= 0 && (cur_index <= (ssize_t)card_index), \"Error\");\n-  assert(region->bottom() <= _rs->addr_for_card_index(cur_index),\n-         \"Fell off the bottom of containing region\");\n-  assert(starts_object(cur_index), \"Error\");\n-  size_t offset = get_last_start(cur_index);\n-  \/\/ can avoid call via card size arithmetic below instead\n-  p = _rs->addr_for_card_index(cur_index) + offset;\n-  \/\/ Recall that we already dealt with the co-initial object case above\n-  assert(p < left, \"obj should start before left\");\n-  \/\/ While it is safe to ask an object its size in the loop that\n-  \/\/ follows, the (ifdef'd out) loop should never be needed.\n-  \/\/ 1. we ask this question only for regions in the old generation\n-  \/\/ 2. there is no direct allocation ever by mutators in old generation\n-  \/\/    regions. Only GC will ever allocate in old regions, and then\n-  \/\/    too only during promotion\/evacuation phases. Thus there is no danger\n-  \/\/    of races between reading from and writing to the object start array,\n-  \/\/    or of asking partially initialized objects their size (in the loop below).\n-  \/\/ 3. only GC asks this question during phases when it is not concurrently\n-  \/\/    evacuating\/promoting, viz. during concurrent root scanning (before\n-  \/\/    the evacuation phase) and during concurrent update refs (after the\n-  \/\/    evacuation phase) of young collections. This is never called\n-  \/\/    during old or global collections.\n-  \/\/ 4. Every allocation under TAMS updates the object start array.\n-  NOT_PRODUCT(obj = cast_to_oop(p);)\n-  assert(oopDesc::is_oop(obj), \"Should be an object\");\n-#define WALK_FORWARD_IN_BLOCK_START false\n-  while (WALK_FORWARD_IN_BLOCK_START && p + obj->size() < left) {\n-    p += obj->size();\n-  }\n-#undef WALK_FORWARD_IN_BLOCK_START \/\/ false\n-  assert(p + obj->size() > left, \"obj should end after left\");\n-  return p;\n-}\n-\n-template<typename RememberedSet>\n-inline size_t\n-ShenandoahScanRemembered<RememberedSet>::last_valid_index() { return _rs->last_valid_index(); }\n-\n-template<typename RememberedSet>\n-inline size_t\n-ShenandoahScanRemembered<RememberedSet>::total_cards() { return _rs->total_cards(); }\n-\n-template<typename RememberedSet>\n-inline size_t\n-ShenandoahScanRemembered<RememberedSet>::card_index_for_addr(HeapWord *p) { return _rs->card_index_for_addr(p); }\n-\n-template<typename RememberedSet>\n-inline HeapWord *\n-ShenandoahScanRemembered<RememberedSet>::addr_for_card_index(size_t card_index) { return _rs->addr_for_card_index(card_index); }\n-\n-template<typename RememberedSet>\n-inline bool\n-ShenandoahScanRemembered<RememberedSet>::is_card_dirty(size_t card_index) { return _rs->is_card_dirty(card_index); }\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::mark_card_as_dirty(size_t card_index) { _rs->mark_card_as_dirty(card_index); }\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::mark_range_as_dirty(size_t card_index, size_t num_cards) { _rs->mark_range_as_dirty(card_index, num_cards); }\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::mark_card_as_clean(size_t card_index) { _rs->mark_card_as_clean(card_index); }\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::mark_range_as_clean(size_t card_index, size_t num_cards) { _rs->mark_range_as_clean(card_index, num_cards); }\n-\n-template<typename RememberedSet>\n-inline bool\n-ShenandoahScanRemembered<RememberedSet>::is_card_dirty(HeapWord *p) { return _rs->is_card_dirty(p); }\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::mark_card_as_dirty(HeapWord *p) { _rs->mark_card_as_dirty(p); }\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::mark_range_as_dirty(HeapWord *p, size_t num_heap_words) { _rs->mark_range_as_dirty(p, num_heap_words); }\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::mark_card_as_clean(HeapWord *p) { _rs->mark_card_as_clean(p); }\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>:: mark_range_as_clean(HeapWord *p, size_t num_heap_words) { _rs->mark_range_as_clean(p, num_heap_words); }\n-\n-template<typename RememberedSet>\n-inline size_t\n-ShenandoahScanRemembered<RememberedSet>::cluster_count() { return _rs->cluster_count(); }\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::reset_object_range(HeapWord *from, HeapWord *to) {\n-  _scc->reset_object_range(from, to);\n-}\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::register_object(HeapWord *addr) {\n-  _scc->register_object(addr);\n-}\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::register_object_without_lock(HeapWord *addr) {\n-  _scc->register_object_without_lock(addr);\n-}\n-\n-template <typename RememberedSet>\n-inline bool\n-ShenandoahScanRemembered<RememberedSet>::verify_registration(HeapWord* address, ShenandoahMarkingContext* ctx) {\n-\n-  size_t index = card_index_for_addr(address);\n-  if (!_scc->starts_object(index)) {\n-    return false;\n-  }\n-  HeapWord* base_addr = addr_for_card_index(index);\n-  size_t offset = _scc->get_first_start(index);\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-\n-  \/\/ Verify that I can find this object within its enclosing card by scanning forward from first_start.\n-  while (base_addr + offset < address) {\n-    oop obj = cast_to_oop(base_addr + offset);\n-    if (!ctx || ctx->is_marked(obj)) {\n-      offset += obj->size();\n-    } else {\n-      \/\/ If this object is not live, don't trust its size(); all objects above tams are live.\n-      ShenandoahHeapRegion* r = heap->heap_region_containing(obj);\n-      HeapWord* tams = ctx->top_at_mark_start(r);\n-      offset = ctx->get_next_marked_addr(base_addr + offset, tams) - base_addr;\n-    }\n-  }\n-  if (base_addr + offset != address){\n-    return false;\n-  }\n-\n-  \/\/ At this point, offset represents object whose registration we are verifying.  We know that at least this object resides\n-  \/\/ within this card's memory.\n-\n-  \/\/ Make sure that last_offset is properly set for the enclosing card, but we can't verify this for\n-  \/\/ candidate collection-set regions during mixed evacuations, so disable this check in general\n-  \/\/ during mixed evacuations.\n-\n-  ShenandoahHeapRegion* r = heap->heap_region_containing(base_addr + offset);\n-  size_t max_offset = r->top() - base_addr;\n-  if (max_offset > CardTable::card_size_in_words()) {\n-    max_offset = CardTable::card_size_in_words();\n-  }\n-  size_t prev_offset;\n-  if (!ctx) {\n-    do {\n-      oop obj = cast_to_oop(base_addr + offset);\n-      prev_offset = offset;\n-      offset += obj->size();\n-    } while (offset < max_offset);\n-    if (_scc->get_last_start(index) != prev_offset) {\n-      return false;\n-    }\n-\n-    \/\/ base + offset represents address of first object that starts on following card, if there is one.\n-\n-    \/\/ Notes: base_addr is addr_for_card_index(index)\n-    \/\/        base_addr + offset is end of the object we are verifying\n-    \/\/        cannot use card_index_for_addr(base_addr + offset) because it asserts arg < end of whole heap\n-    size_t end_card_index = index + offset \/ CardTable::card_size_in_words();\n-\n-    if (end_card_index > index && end_card_index <= _rs->last_valid_index()) {\n-      \/\/ If there is a following object registered on the next card, it should begin where this object ends.\n-      if (_scc->starts_object(end_card_index) &&\n-          ((addr_for_card_index(end_card_index) + _scc->get_first_start(end_card_index)) != (base_addr + offset))) {\n-        return false;\n-      }\n-    }\n-\n-    \/\/ Assure that no other objects are registered \"inside\" of this one.\n-    for (index++; index < end_card_index; index++) {\n-      if (_scc->starts_object(index)) {\n-        return false;\n-      }\n-    }\n-  } else {\n-    \/\/ This is a mixed evacuation or a global collect: rely on mark bits to identify which objects need to be properly registered\n-    assert(!ShenandoahHeap::heap()->is_concurrent_old_mark_in_progress(), \"Cannot rely on mark context here.\");\n-    \/\/ If the object reaching or spanning the end of this card's memory is marked, then last_offset for this card\n-    \/\/ should represent this object.  Otherwise, last_offset is a don't care.\n-    ShenandoahHeapRegion* region = heap->heap_region_containing(base_addr + offset);\n-    HeapWord* tams = ctx->top_at_mark_start(region);\n-    oop last_obj = nullptr;\n-    do {\n-      oop obj = cast_to_oop(base_addr + offset);\n-      if (ctx->is_marked(obj)) {\n-        prev_offset = offset;\n-        offset += obj->size();\n-        last_obj = obj;\n-      } else {\n-        offset = ctx->get_next_marked_addr(base_addr + offset, tams) - base_addr;\n-        \/\/ If there are no marked objects remaining in this region, offset equals tams - base_addr.  If this offset is\n-        \/\/ greater than max_offset, we will immediately exit this loop.  Otherwise, the next iteration of the loop will\n-        \/\/ treat the object at offset as marked and live (because address >= tams) and we will continue iterating object\n-        \/\/ by consulting the size() fields of each.\n-      }\n-    } while (offset < max_offset);\n-    if (last_obj != nullptr && prev_offset + last_obj->size() >= max_offset) {\n-      \/\/ last marked object extends beyond end of card\n-      if (_scc->get_last_start(index) != prev_offset) {\n-        return false;\n-      }\n-      \/\/ otherwise, the value of _scc->get_last_start(index) is a don't care because it represents a dead object and we\n-      \/\/ cannot verify its context\n-    }\n-  }\n-  return true;\n-}\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::coalesce_objects(HeapWord *addr, size_t length_in_words) {\n-  _scc->coalesce_objects(addr, length_in_words);\n-}\n-\n-template<typename RememberedSet>\n-inline void\n-ShenandoahScanRemembered<RememberedSet>::mark_range_as_empty(HeapWord *addr, size_t length_in_words) {\n-  _rs->mark_range_as_clean(addr, length_in_words);\n-  _scc->clear_objects_in_range(addr, length_in_words);\n-}\n-\n@@ -549,1 +49,0 @@\n-template<typename RememberedSet>\n@@ -551,1 +50,1 @@\n-void ShenandoahScanRemembered<RememberedSet>::process_clusters(size_t first_cluster, size_t count, HeapWord* end_of_range,\n+void ShenandoahScanRemembered::process_clusters(size_t first_cluster, size_t count, HeapWord* end_of_range,\n@@ -564,1 +63,1 @@\n-  const size_t start_card_index = first_cluster * ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n+  const size_t start_card_index = first_cluster * ShenandoahCardCluster::CardsPerCluster;\n@@ -567,1 +66,1 @@\n-  HeapWord* end_addr = MIN2(end_of_range, (HeapWord*)start_addr + (count * ShenandoahCardCluster<RememberedSet>::CardsPerCluster\n+  HeapWord* end_addr = MIN2(end_of_range, (HeapWord*)start_addr + (count * ShenandoahCardCluster::CardsPerCluster\n@@ -798,1 +297,0 @@\n-template<typename RememberedSet>\n@@ -801,1 +299,1 @@\n-ShenandoahScanRemembered<RememberedSet>::process_humongous_clusters(ShenandoahHeapRegion* r, size_t first_cluster, size_t count,\n+ShenandoahScanRemembered::process_humongous_clusters(ShenandoahHeapRegion* r, size_t first_cluster, size_t count,\n@@ -810,1 +308,1 @@\n-  size_t first_card_index = first_cluster * ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n+  size_t first_card_index = first_cluster * ShenandoahCardCluster::CardsPerCluster;\n@@ -812,1 +310,1 @@\n-  size_t spanned_words = count * ShenandoahCardCluster<RememberedSet>::CardsPerCluster * CardTable::card_size_in_words();\n+  size_t spanned_words = count * ShenandoahCardCluster::CardsPerCluster * CardTable::card_size_in_words();\n@@ -818,1 +316,0 @@\n-template<typename RememberedSet>\n@@ -821,1 +318,1 @@\n-ShenandoahScanRemembered<RememberedSet>::process_region_slice(ShenandoahHeapRegion *region, size_t start_offset, size_t clusters,\n+ShenandoahScanRemembered::process_region_slice(ShenandoahHeapRegion *region, size_t start_offset, size_t clusters,\n@@ -881,140 +378,0 @@\n-template<typename RememberedSet>\n-inline size_t\n-ShenandoahScanRemembered<RememberedSet>::cluster_for_addr(HeapWordImpl **addr) {\n-  size_t card_index = _rs->card_index_for_addr(addr);\n-  size_t result = card_index \/ ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n-  return result;\n-}\n-\n-template<typename RememberedSet>\n-inline HeapWord*\n-ShenandoahScanRemembered<RememberedSet>::addr_for_cluster(size_t cluster_no) {\n-  size_t card_index = cluster_no * ShenandoahCardCluster<RememberedSet>::CardsPerCluster;\n-  return addr_for_card_index(card_index);\n-}\n-\n-\/\/ This is used only for debug verification so don't worry about making the scan parallel.\n-template<typename RememberedSet>\n-void ShenandoahScanRemembered<RememberedSet>::roots_do(OopIterateClosure* cl) {\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  bool old_bitmap_stable = heap->old_generation()->is_mark_complete();\n-  log_info(gc, remset)(\"Scan remembered set using bitmap: %s\", BOOL_TO_STR(old_bitmap_stable));\n-  for (size_t i = 0, n = heap->num_regions(); i < n; ++i) {\n-    ShenandoahHeapRegion* region = heap->get_region(i);\n-    if (region->is_old() && region->is_active() && !region->is_cset()) {\n-      HeapWord* start_of_range = region->bottom();\n-      HeapWord* end_of_range = region->top();\n-      size_t start_cluster_no = cluster_for_addr(start_of_range);\n-      size_t num_heapwords = end_of_range - start_of_range;\n-      unsigned int cluster_size = CardTable::card_size_in_words() *\n-                                  ShenandoahCardCluster<ShenandoahDirectCardMarkRememberedSet>::CardsPerCluster;\n-      size_t num_clusters = (size_t) ((num_heapwords - 1 + cluster_size) \/ cluster_size);\n-\n-      \/\/ Remembered set scanner\n-      if (region->is_humongous()) {\n-        process_humongous_clusters(region->humongous_start_region(), start_cluster_no, num_clusters, end_of_range, cl,\n-                                   false \/* use_write_table *\/);\n-      } else {\n-        process_clusters(start_cluster_no, num_clusters, end_of_range, cl,\n-                         false \/* use_write_table *\/, 0 \/* fake worker id *\/);\n-      }\n-    }\n-  }\n-}\n-\n-#ifndef PRODUCT\n-\/\/ Log given card stats\n-template<typename RememberedSet>\n-inline void ShenandoahScanRemembered<RememberedSet>::log_card_stats(HdrSeq* stats) {\n-  for (int i = 0; i < MAX_CARD_STAT_TYPE; i++) {\n-    log_info(gc, remset)(\"%18s: [ %8.2f %8.2f %8.2f %8.2f %8.2f ]\",\n-      _card_stats_name[i],\n-      stats[i].percentile(0), stats[i].percentile(25),\n-      stats[i].percentile(50), stats[i].percentile(75),\n-      stats[i].maximum());\n-  }\n-}\n-\n-\/\/ Log card stats for all nworkers for a specific phase t\n-template<typename RememberedSet>\n-void ShenandoahScanRemembered<RememberedSet>::log_card_stats(uint nworkers, CardStatLogType t) {\n-  assert(ShenandoahEnableCardStats, \"Do not call\");\n-  HdrSeq* sum_stats = card_stats_for_phase(t);\n-  log_info(gc, remset)(\"%s\", _card_stat_log_type[t]);\n-  for (uint i = 0; i < nworkers; i++) {\n-    log_worker_card_stats(i, sum_stats);\n-  }\n-\n-  \/\/ Every so often, log the cumulative global stats\n-  if (++_card_stats_log_counter[t] >= ShenandoahCardStatsLogInterval) {\n-    _card_stats_log_counter[t] = 0;\n-    log_info(gc, remset)(\"Cumulative stats\");\n-    log_card_stats(sum_stats);\n-  }\n-}\n-\n-\/\/ Log card stats for given worker_id, & clear them after merging into given cumulative stats\n-template<typename RememberedSet>\n-void ShenandoahScanRemembered<RememberedSet>::log_worker_card_stats(uint worker_id, HdrSeq* sum_stats) {\n-  assert(ShenandoahEnableCardStats, \"Do not call\");\n-\n-  HdrSeq* worker_card_stats = card_stats(worker_id);\n-  log_info(gc, remset)(\"Worker %u Card Stats: \", worker_id);\n-  log_card_stats(worker_card_stats);\n-  \/\/ Merge worker stats into the cumulative stats & clear worker stats\n-  merge_worker_card_stats_cumulative(worker_card_stats, sum_stats);\n-}\n-\n-template<typename RememberedSet>\n-void ShenandoahScanRemembered<RememberedSet>::merge_worker_card_stats_cumulative(\n-  HdrSeq* worker_stats, HdrSeq* sum_stats) {\n-  for (int i = 0; i < MAX_CARD_STAT_TYPE; i++) {\n-    sum_stats[i].add(worker_stats[i]);\n-    worker_stats[i].clear();\n-  }\n-}\n-#endif\n-\n-inline bool ShenandoahRegionChunkIterator::has_next() const {\n-  return _index < _total_chunks;\n-}\n-\n-inline bool ShenandoahRegionChunkIterator::next(struct ShenandoahRegionChunk *assignment) {\n-  if (_index >= _total_chunks) {\n-    return false;\n-  }\n-  size_t new_index = Atomic::add(&_index, (size_t) 1, memory_order_relaxed);\n-  if (new_index > _total_chunks) {\n-    \/\/ First worker that hits new_index == _total_chunks continues, other\n-    \/\/ contending workers return false.\n-    return false;\n-  }\n-  \/\/ convert to zero-based indexing\n-  new_index--;\n-  assert(new_index < _total_chunks, \"Error\");\n-\n-  \/\/ Find the group number for the assigned chunk index\n-  size_t group_no;\n-  for (group_no = 0; new_index >= _group_entries[group_no]; group_no++)\n-    ;\n-  assert(group_no < _num_groups, \"Cannot have group no greater or equal to _num_groups\");\n-\n-  \/\/ All size computations measured in HeapWord\n-  size_t region_size_words = ShenandoahHeapRegion::region_size_words();\n-  size_t group_region_index = _region_index[group_no];\n-  size_t group_region_offset = _group_offset[group_no];\n-\n-  size_t index_within_group = (group_no == 0)? new_index: new_index - _group_entries[group_no - 1];\n-  size_t group_chunk_size = _group_chunk_size[group_no];\n-  size_t offset_of_this_chunk = group_region_offset + index_within_group * group_chunk_size;\n-  size_t regions_spanned_by_chunk_offset = offset_of_this_chunk \/ region_size_words;\n-  size_t offset_within_region = offset_of_this_chunk % region_size_words;\n-\n-  size_t region_index = group_region_index + regions_spanned_by_chunk_offset;\n-\n-  assignment->_r = _heap->get_region(region_index);\n-  assignment->_chunk_offset = offset_within_region;\n-  assignment->_chunk_size = group_chunk_size;\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":7,"deletions":650,"binary":false,"changes":657,"status":"modified"},{"patch":"@@ -1281,1 +1281,1 @@\n-  RememberedScanner*          const _scanner;\n+  ShenandoahScanRemembered*   const _scanner;\n@@ -1314,1 +1314,1 @@\n-  RememberedScanner* scanner = ShenandoahGenerationalHeap::heap()->old_generation()->card_scan();\n+  ShenandoahScanRemembered* scanner = ShenandoahGenerationalHeap::heap()->old_generation()->card_scan();\n@@ -1371,1 +1371,1 @@\n-  RememberedScanner* scanner = ShenandoahGenerationalHeap::heap()->old_generation()->card_scan();\n+  ShenandoahScanRemembered* scanner = ShenandoahGenerationalHeap::heap()->old_generation()->card_scan();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}