{"files":[{"patch":"@@ -1502,3 +1502,1 @@\n-  https:\/\/httpredir.debian.org\/debian\/<\/code><\/pre>\n-<p>If the target architecture is <code>riscv64<\/code>, the path should\n-be <code>debian-ports<\/code> instead of <code>debian<\/code>.<\/p><\/li>\n+  https:\/\/httpredir.debian.org\/debian\/<\/code><\/pre><\/li>\n","filename":"doc\/building.html","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1319,3 +1319,0 @@\n-  If the target architecture is `riscv64`, the path should be `debian-ports`\n-  instead of `debian`.\n-\n","filename":"doc\/building.md","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-    LIBS_unix := -ljava -ljvm $(LIBZ_LIBS), \\\n+    LIBS_unix := $(LIBZ_LIBS), \\\n","filename":"make\/modules\/java.instrument\/Lib.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-  uint stk_args = 0; \/\/ inc by 2 each time\n+  uint stk_args = 0;\n@@ -325,0 +325,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -326,1 +327,1 @@\n-        stk_args += 2;\n+        stk_args += 1;\n@@ -343,0 +344,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -351,0 +353,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -352,1 +355,1 @@\n-        stk_args += 2;\n+        stk_args += 1;\n@@ -360,0 +363,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -370,1 +374,1 @@\n-  return align_up(stk_args, 2);\n+  return stk_args;\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3606,5 +3606,3 @@\n-  \/\/ make sure klass is initialized & doesn't have finalizer\n-  \/\/ make sure klass is fully initialized\n-  __ ldrb(rscratch1, Address(r4, InstanceKlass::init_state_offset()));\n-  __ cmp(rscratch1, (u1)InstanceKlass::fully_initialized);\n-  __ br(Assembler::NE, slow_case);\n+  \/\/ make sure klass is initialized\n+  assert(VM_Version::supports_fast_class_init_checks(), \"Optimization requires support for fast class initialization checks\");\n+  __ clinit_barrier(r4, rscratch1, nullptr \/*L_fast_path*\/, &slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -168,0 +168,1 @@\n+  \/\/ Aarch64 supports fast class initialization checks\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -444,1 +444,0 @@\n-  if (slot & 1) slot++;\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -737,1 +737,1 @@\n-  return align_up(stk, 2);\n+  return stk;\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-  \/\/ PPC64 supports fast class initialization checks for static methods.\n+  \/\/ PPC64 supports fast class initialization checks\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4483,0 +4483,51 @@\n+\n+\/\/ java.lang.Math.round(float a)\n+\/\/ Returns the closest int to the argument, with ties rounding to positive infinity.\n+void MacroAssembler::java_round_float(Register dst, FloatRegister src, FloatRegister ftmp) {\n+  \/\/ this instructions calling sequence provides performance improvement on all tested devices;\n+  \/\/ don't change it without re-verification\n+  Label done;\n+  mv(t0, jint_cast(0.5f));\n+  fmv_w_x(ftmp, t0);\n+\n+  \/\/ dst = 0 if NaN\n+  feq_s(t0, src, src); \/\/ replacing fclass with feq as performance optimization\n+  mv(dst, zr);\n+  beqz(t0, done);\n+\n+  \/\/ dst = (src + 0.5f) rounded down towards negative infinity\n+  \/\/   Adding 0.5f to some floats exceeds the precision limits for a float and rounding takes place.\n+  \/\/   RDN is required for fadd_s, RNE gives incorrect results:\n+  \/\/     --------------------------------------------------------------------\n+  \/\/     fadd.s rne (src + 0.5f): src = 8388609.000000  ftmp = 8388610.000000\n+  \/\/     fcvt.w.s rdn: ftmp = 8388610.000000 dst = 8388610\n+  \/\/     --------------------------------------------------------------------\n+  \/\/     fadd.s rdn (src + 0.5f): src = 8388609.000000  ftmp = 8388609.000000\n+  \/\/     fcvt.w.s rdn: ftmp = 8388609.000000 dst = 8388609\n+  \/\/     --------------------------------------------------------------------\n+  fadd_s(ftmp, src, ftmp, RoundingMode::rdn);\n+  fcvt_w_s(dst, ftmp, RoundingMode::rdn);\n+\n+  bind(done);\n+}\n+\n+\/\/ java.lang.Math.round(double a)\n+\/\/ Returns the closest long to the argument, with ties rounding to positive infinity.\n+void MacroAssembler::java_round_double(Register dst, FloatRegister src, FloatRegister ftmp) {\n+  \/\/ this instructions calling sequence provides performance improvement on all tested devices;\n+  \/\/ don't change it without re-verification\n+  Label done;\n+  mv(t0, julong_cast(0.5));\n+  fmv_d_x(ftmp, t0);\n+\n+  \/\/ dst = 0 if NaN\n+  feq_d(t0, src, src); \/\/ replacing fclass with feq as performance optimization\n+  mv(dst, zr);\n+  beqz(t0, done);\n+\n+  \/\/ dst = (src + 0.5) rounded down towards negative infinity\n+  fadd_d(ftmp, src, ftmp, RoundingMode::rdn); \/\/ RDN is required here otherwise some inputs produce incorrect results\n+  fcvt_l_d(dst, ftmp, RoundingMode::rdn);\n+\n+  bind(done);\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1268,0 +1268,3 @@\n+  void java_round_float(Register dst, FloatRegister src, FloatRegister ftmp);\n+  void java_round_double(Register dst, FloatRegister src, FloatRegister ftmp);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -8420,0 +8420,28 @@\n+instruct round_double_reg(iRegLNoSp dst, fRegD src, fRegD ftmp) %{\n+  match(Set dst (RoundD src));\n+\n+  ins_cost(XFER_COST + BRANCH_COST);\n+  effect(TEMP ftmp);\n+  format %{ \"java_round_double $dst, $src\\t#@round_double_reg\" %}\n+\n+  ins_encode %{\n+    __ java_round_double($dst$$Register, as_FloatRegister($src$$reg), as_FloatRegister($ftmp$$reg));\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct round_float_reg(iRegINoSp dst, fRegF src, fRegF ftmp) %{\n+  match(Set dst (RoundF src));\n+\n+  ins_cost(XFER_COST + BRANCH_COST);\n+  effect(TEMP ftmp);\n+  format %{ \"java_round_float $dst, $src\\t#@round_float_reg\" %}\n+\n+  ins_encode %{\n+    __ java_round_float($dst$$Register, as_FloatRegister($src$$reg), as_FloatRegister($ftmp$$reg));\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-  uint stk_args = 0; \/\/ inc by 2 each time\n+  uint stk_args = 0;\n@@ -281,0 +281,1 @@\n+          stk_args = align_up(stk_args, 2);\n@@ -282,1 +283,1 @@\n-          stk_args += 2;\n+          stk_args += 1;\n@@ -298,0 +299,1 @@\n+          stk_args = align_up(stk_args, 2);\n@@ -306,0 +308,1 @@\n+          stk_args = align_up(stk_args, 2);\n@@ -307,1 +310,1 @@\n-          stk_args += 2;\n+          stk_args += 1;\n@@ -315,0 +318,1 @@\n+          stk_args = align_up(stk_args, 2);\n@@ -324,1 +328,1 @@\n-  return align_up(stk_args, 2);\n+  return stk_args;\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -758,1 +758,1 @@\n-  return align_up(stk, 2);\n+  return stk;\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -413,1 +413,1 @@\n-  \/\/ s390 supports fast class initialization checks for static methods.\n+  \/\/ s390 supports fast class initialization checks\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -892,2 +892,2 @@\n-    assert((which == call32_operand || which == imm_operand) && is_64bit ||\n-           which == narrow_oop_operand && !is_64bit,\n+    assert(((which == call32_operand || which == imm_operand) && is_64bit) ||\n+           (which == narrow_oop_operand && !is_64bit),\n@@ -7238,1 +7238,1 @@\n-  assert(VM_Version::supports_avx() && (vector_len == 0) ||\n+  assert((VM_Version::supports_avx() && (vector_len == 0)) ||\n@@ -7246,1 +7246,1 @@\n-  assert(VM_Version::supports_avx() && (vector_len == 0) ||\n+  assert((VM_Version::supports_avx() && (vector_len == 0)) ||\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -5226,2 +5226,2 @@\n-  assert(vec_enc == AVX_128bit && VM_Version::supports_avx() ||\n-         vec_enc == AVX_256bit && (VM_Version::supports_avx2() || type2aelembytes(bt) >= 4), \"\");\n+  assert((vec_enc == AVX_128bit && VM_Version::supports_avx()) ||\n+         (vec_enc == AVX_256bit && (VM_Version::supports_avx2() || type2aelembytes(bt) >= 4)), \"\");\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,1 +184,1 @@\n-  assert(!ret || ret && cb() == other.cb() && _deopt_state == other._deopt_state, \"inconsistent construction\");\n+  assert(!ret || (ret && cb() == other.cb() && _deopt_state == other._deopt_state), \"inconsistent construction\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,2 +114,2 @@\n-        op == 0x0F && (branch[1] & 0xF0) == 0x80 \/* jcc *\/ ||\n-        op == 0xC7 && branch[1] == 0xF8 \/* xbegin *\/,\n+        (op == 0x0F && (branch[1] & 0xF0) == 0x80) \/* jcc *\/ ||\n+        (op == 0xC7 && branch[1] == 0xF8) \/* xbegin *\/,\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -531,2 +531,1 @@\n-  \/\/ return value can be odd number of VMRegImpl stack slots make multiple of 2\n-  return align_up(stack, 2);\n+  return stack;\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -501,1 +501,1 @@\n-  uint stk_args = 0; \/\/ inc by 2 each time\n+  uint stk_args = 0;\n@@ -513,0 +513,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -514,1 +515,1 @@\n-        stk_args += 2;\n+        stk_args += 1;\n@@ -531,0 +532,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -539,0 +541,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -540,1 +543,1 @@\n-        stk_args += 2;\n+        stk_args += 1;\n@@ -548,0 +551,1 @@\n+        stk_args = align_up(stk_args, 2);\n@@ -558,1 +562,1 @@\n-  return align_up(stk_args, 2);\n+  return stk_args;\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2321,1 +2321,1 @@\n-  const Address  dp_mem(rbp, 6 * wordSize);  \/\/ length is on stack on Win64\n+  const Address dp_mem(rbp, 6 * wordSize);  \/\/ length is on stack on Win64\n@@ -2543,0 +2543,1 @@\n+    __ addq(length, start_offset);\n@@ -2547,0 +2548,1 @@\n+    __ subq(length, start_offset);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4051,2 +4051,5 @@\n-  \/\/ make sure klass is initialized & doesn't have finalizer\n-  \/\/ make sure klass is fully initialized\n+  \/\/ make sure klass is initialized\n+#ifdef _LP64\n+  assert(VM_Version::supports_fast_class_init_checks(), \"must support fast class initialization checks\");\n+  __ clinit_barrier(rcx, r15_thread, nullptr \/*L_fast_path*\/, &slow_case);\n+#else\n@@ -4055,0 +4058,1 @@\n+#endif\n@@ -4056,0 +4060,1 @@\n+  \/\/ make sure klass doesn't have finalizer\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1181,1 +1181,1 @@\n-  if (supports_sha() LP64_ONLY(|| supports_avx2() && supports_bmi2())) {\n+  if (supports_sha() LP64_ONLY(|| (supports_avx2() && supports_bmi2()))) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -759,1 +759,1 @@\n-  \/\/ x86_64 supports fast class initialization checks for static methods.\n+  \/\/ x86_64 supports fast class initialization checks\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2535,2 +2535,2 @@\n-         (src_lo & 1) == 0 && (src_lo + 1) == src_hi &&\n-         (dst_lo & 1) == 0 && (dst_lo + 1) == dst_hi,\n+         ((src_lo & 1) == 0 && (src_lo + 1) == src_hi &&\n+          (dst_lo & 1) == 0 && (dst_lo + 1) == dst_hi),\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -11145,1 +11145,1 @@\n-  predicate( UseSSE==1 || UseSSE>=2 && !UseXmmI2F );\n+  predicate( UseSSE==1 || ( UseSSE>=2 && !UseXmmI2F ));\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2115,5 +2115,0 @@\n-bool os::can_execute_large_page_memory() {\n-  \/\/ Does not matter, we do not support huge pages.\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1790,5 +1790,0 @@\n-bool os::can_execute_large_page_memory() {\n-  \/\/ Does not matter, we do not support huge pages.\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2015, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024 SAP SE. All rights reserved.\n@@ -2100,1 +2100,0 @@\n-  \"\/etc\/SuSE-release\",\n@@ -2108,0 +2107,1 @@\n+  \"\/etc\/SuSE-release\", \/\/ Deprecated in favor of os-release since SuSE 12\n@@ -4081,4 +4081,0 @@\n-bool os::can_execute_large_page_memory() {\n-  return UseTransparentHugePages;\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3439,4 +3439,0 @@\n-bool os::can_execute_large_page_memory() {\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-static uint totalInstructionNodes = 0;\n@@ -497,1 +496,0 @@\n-  totalInstructionNodes += Instruction::number_of_instructions();\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  intptr_t out_preserve = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs);\n+  intptr_t out_preserve = align_up(SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs), 2);\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1346,1 +1346,1 @@\n-  assert(k == nullptr || k->is_klass() && k->is_array_klass(), \"should be array klass\");\n+  assert(k == nullptr || (k->is_klass() && k->is_array_klass()), \"should be array klass\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n@@ -40,1 +40,0 @@\n-class StringTable;\n@@ -42,1 +41,0 @@\n-class StringTableCreateEntry;\n@@ -44,1 +42,1 @@\n-class StringTable : public CHeapObj<mtSymbol>{\n+class StringTable : AllStatic {\n@@ -46,1 +44,0 @@\n-  friend class Symbol;\n@@ -48,1 +45,0 @@\n-  friend class StringTableCreateEntry;\n","filename":"src\/hotspot\/share\/classfile\/stringTable.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -358,10 +358,2 @@\n-  if (os::can_execute_large_page_memory()) {\n-    if (InitialCodeCacheSize < ReservedCodeCacheSize) {\n-      \/\/ Make sure that the page size allows for an incremental commit of the reserved space\n-      min_pages = MAX2(min_pages, (size_t)8);\n-    }\n-    return aligned ? os::page_size_for_region_aligned(ReservedCodeCacheSize, min_pages) :\n-                     os::page_size_for_region_unaligned(ReservedCodeCacheSize, min_pages);\n-  } else {\n-    return os::vm_page_size();\n-  }\n+  return aligned ? os::page_size_for_region_aligned(ReservedCodeCacheSize, min_pages) :\n+                   os::page_size_for_region_unaligned(ReservedCodeCacheSize, min_pages);\n@@ -1174,1 +1166,5 @@\n-    ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize, page_size(false, 8));\n+\n+    \/\/ If InitialCodeCacheSize is equal to ReservedCodeCacheSize, then it's more likely\n+    \/\/ users want to use the largest available page.\n+    const size_t min_pages = (InitialCodeCacheSize == ReservedCodeCacheSize) ? 1 : 8;\n+    ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize, page_size(false, min_pages));\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3022,1 +3022,1 @@\n-      intptr_t out_preserve = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs);\n+      SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-G1ConcurrentRefineThreadControl::G1ConcurrentRefineThreadControl() :\n+G1ConcurrentRefineThreadControl::G1ConcurrentRefineThreadControl(uint max_num_threads) :\n@@ -63,2 +63,1 @@\n-  _threads(nullptr),\n-  _max_num_threads(0)\n+  _threads(max_num_threads)\n@@ -68,13 +67,12 @@\n-  if (_threads != nullptr) {\n-    for (uint i = 0; i < _max_num_threads; i++) {\n-      G1ConcurrentRefineThread* t = _threads[i];\n-      if (t == nullptr) {\n-#ifdef ASSERT\n-        for (uint j = i + 1; j < _max_num_threads; ++j) {\n-          assert(_threads[j] == nullptr, \"invariant\");\n-        }\n-#endif \/\/ ASSERT\n-        break;\n-      } else {\n-        delete t;\n-      }\n+  while (_threads.is_nonempty()) {\n+    delete _threads.pop();\n+  }\n+}\n+\n+bool G1ConcurrentRefineThreadControl::ensure_threads_created(uint worker_id, bool initializing) {\n+  assert(worker_id < max_num_threads(), \"precondition\");\n+\n+  while ((uint)_threads.length() <= worker_id) {\n+    G1ConcurrentRefineThread* rt = create_refinement_thread(_threads.length(), initializing);\n+    if (rt == nullptr) {\n+      return false;\n@@ -82,1 +80,1 @@\n-    FREE_C_HEAP_ARRAY(G1ConcurrentRefineThread*, _threads);\n+    _threads.push(rt);\n@@ -84,0 +82,2 @@\n+\n+  return true;\n@@ -86,1 +86,1 @@\n-jint G1ConcurrentRefineThreadControl::initialize(G1ConcurrentRefine* cr, uint max_num_threads) {\n+jint G1ConcurrentRefineThreadControl::initialize(G1ConcurrentRefine* cr) {\n@@ -89,4 +89,0 @@\n-  _max_num_threads = max_num_threads;\n-\n-  if (max_num_threads > 0) {\n-    _threads = NEW_C_HEAP_ARRAY(G1ConcurrentRefineThread*, max_num_threads, mtGC);\n@@ -94,2 +90,3 @@\n-    _threads[0] = create_refinement_thread(0, true);\n-    if (_threads[0] == nullptr) {\n+  if (max_num_threads() > 0) {\n+    _threads.push(create_refinement_thread(0, true));\n+    if (_threads.at(0) == nullptr) {\n@@ -100,11 +97,4 @@\n-    if (UseDynamicNumberOfGCThreads) {\n-      for (uint i = 1; i < max_num_threads; ++i) {\n-        _threads[i] = nullptr;\n-      }\n-    } else {\n-      for (uint i = 1; i < max_num_threads; ++i) {\n-        _threads[i] = create_refinement_thread(i, true);\n-        if (_threads[i] == nullptr) {\n-          vm_shutdown_during_initialization(\"Could not allocate refinement threads.\");\n-          return JNI_ENOMEM;\n-        }\n+    if (!UseDynamicNumberOfGCThreads) {\n+      if (!ensure_threads_created(max_num_threads() - 1, true)) {\n+        vm_shutdown_during_initialization(\"Could not allocate refinement threads\");\n+        return JNI_ENOMEM;\n@@ -120,2 +110,1 @@\n-  assert(_threads != nullptr, \"No threads\");\n-  assert(Thread::current() == _threads[0], \"Not primary thread\");\n+  assert(Thread::current() == _threads.at(0), \"Not primary thread\");\n@@ -126,8 +115,3 @@\n-  assert(worker_id < _max_num_threads, \"precondition\");\n-  G1ConcurrentRefineThread* thread_to_activate = _threads[worker_id];\n-  if (thread_to_activate == nullptr) {\n-    thread_to_activate = create_refinement_thread(worker_id, false);\n-    if (thread_to_activate == nullptr) {\n-      return false;\n-    }\n-    _threads[worker_id] = thread_to_activate;\n+  if (ensure_threads_created(worker_id, false)) {\n+    _threads.at(worker_id)->activate();\n+    return true;\n@@ -135,2 +119,2 @@\n-  thread_to_activate->activate();\n-  return true;\n+\n+  return false;\n@@ -140,4 +124,2 @@\n-  for (uint i = 0; i < _max_num_threads; i++) {\n-    if (_threads[i] != nullptr) {\n-      tc->do_thread(_threads[i]);\n-    }\n+  for (G1ConcurrentRefineThread* t : _threads) {\n+    tc->do_thread(t);\n@@ -148,4 +130,2 @@\n-  for (uint i = 0; i < _max_num_threads; i++) {\n-    if (_threads[i] != nullptr) {\n-      _threads[i]->stop();\n-    }\n+  for (G1ConcurrentRefineThread* t : _threads) {\n+    t->stop();\n@@ -173,1 +153,1 @@\n-  _thread_control(),\n+  _thread_control(G1ConcRefinementThreads),\n@@ -178,1 +158,1 @@\n-  return _thread_control.initialize(this, G1ConcRefinementThreads);\n+  return _thread_control.initialize(this);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":37,"deletions":57,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -46,2 +47,1 @@\n-  G1ConcurrentRefineThread** _threads;\n-  uint _max_num_threads;\n+  GrowableArrayCHeap<G1ConcurrentRefineThread*, mtGC> _threads;\n@@ -53,0 +53,2 @@\n+  bool ensure_threads_created(uint worker_id, bool initializing);\n+\n@@ -56,1 +58,1 @@\n-  G1ConcurrentRefineThreadControl();\n+  G1ConcurrentRefineThreadControl(uint max_num_threads);\n@@ -59,1 +61,1 @@\n-  jint initialize(G1ConcurrentRefine* cr, uint max_num_threads);\n+  jint initialize(G1ConcurrentRefine* cr);\n@@ -63,1 +65,1 @@\n-  uint max_num_threads() const { return _max_num_threads; }\n+  uint max_num_threads() const { return _threads.capacity(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -187,2 +187,0 @@\n-  using MutableSpace::capacity_in_words;\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -876,11 +876,0 @@\n-size_t PSAdaptiveSizePolicy::eden_increment(size_t cur_eden,\n-                                            uint percent_change) {\n-  size_t eden_heap_delta;\n-  eden_heap_delta = cur_eden \/ 100 * percent_change;\n-  return eden_heap_delta;\n-}\n-\n-size_t PSAdaptiveSizePolicy::eden_increment(size_t cur_eden) {\n-  return eden_increment(cur_eden, YoungGenerationSizeIncrement);\n-}\n-\n@@ -899,17 +888,0 @@\n-size_t PSAdaptiveSizePolicy::eden_decrement(size_t cur_eden) {\n-  size_t eden_heap_delta = eden_increment(cur_eden) \/\n-    AdaptiveSizeDecrementScaleFactor;\n-  return eden_heap_delta;\n-}\n-\n-size_t PSAdaptiveSizePolicy::promo_increment(size_t cur_promo,\n-                                             uint percent_change) {\n-  size_t promo_heap_delta;\n-  promo_heap_delta = cur_promo \/ 100 * percent_change;\n-  return promo_heap_delta;\n-}\n-\n-size_t PSAdaptiveSizePolicy::promo_increment(size_t cur_promo) {\n-  return promo_increment(cur_promo, TenuredGenerationSizeIncrement);\n-}\n-\n@@ -928,6 +900,0 @@\n-size_t PSAdaptiveSizePolicy::promo_decrement(size_t cur_promo) {\n-  size_t promo_heap_delta = promo_increment(cur_promo);\n-  promo_heap_delta = promo_heap_delta \/ AdaptiveSizeDecrementScaleFactor;\n-  return promo_heap_delta;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.cpp","additions":0,"deletions":34,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -138,2 +138,0 @@\n-  virtual size_t eden_increment(size_t cur_eden, uint percent_change);\n-  virtual size_t eden_decrement(size_t cur_eden);\n@@ -144,2 +142,0 @@\n-  virtual size_t promo_increment(size_t cur_promo, uint percent_change);\n-  virtual size_t promo_decrement(size_t cur_promo);\n@@ -176,3 +172,0 @@\n-  virtual size_t eden_increment(size_t cur_eden);\n-  virtual size_t promo_increment(size_t cur_promo);\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,3 +50,3 @@\n-  template <typename T> void do_oop_nv(T* p)      { _compaction_manager->mark_and_push(p); }\n-  virtual void do_oop(oop* p)                     { do_oop_nv(p); }\n-  virtual void do_oop(narrowOop* p)               { do_oop_nv(p); }\n+  template <typename T> void do_oop_work(T* p)      { _compaction_manager->mark_and_push(p); }\n+  virtual void do_oop(oop* p)                     { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p)               { do_oop_work(p); }\n@@ -63,3 +63,3 @@\n-  template <typename T> void do_oop_nv(T* p)      { _compaction_manager->mark_and_push(p); }\n-  virtual void do_oop(oop* p)                     { do_oop_nv(p); }\n-  virtual void do_oop(narrowOop* p)               { do_oop_nv(p); }\n+  template <typename T> void do_oop_work(T* p)      { _compaction_manager->mark_and_push(p); }\n+  virtual void do_oop(oop* p)                     { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p)               { do_oop_work(p); }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -133,3 +133,3 @@\n-  template <typename T> void do_oop_nv(T* p) { PSParallelCompact::adjust_pointer(p, _cm); }\n-  virtual void do_oop(oop* p)                { do_oop_nv(p); }\n-  virtual void do_oop(narrowOop* p)          { do_oop_nv(p); }\n+  template <typename T> void do_oop_work(T* p) { PSParallelCompact::adjust_pointer(p, _cm); }\n+  virtual void do_oop(oop* p)                { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p)          { do_oop_work(p); }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  template <typename T> void do_oop_nv(T* p) {\n+  template <typename T> void do_oop_work(T* p) {\n@@ -104,2 +104,2 @@\n-  virtual void do_oop(oop* p)       { do_oop_nv(p); }\n-  virtual void do_oop(narrowOop* p) { do_oop_nv(p); }\n+  virtual void do_oop(oop* p)       { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,1 +116,1 @@\n-         reserved_low_addr() == nullptr && reserved_high_addr() == nullptr,\n+         (reserved_low_addr() == nullptr && reserved_high_addr() == nullptr),\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVirtualspace.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -266,6 +266,6 @@\n-  virtual size_t eden_increment(size_t cur_eden);\n-  virtual size_t eden_increment(size_t cur_eden, uint percent_change);\n-  virtual size_t eden_decrement(size_t cur_eden);\n-  virtual size_t promo_increment(size_t cur_eden);\n-  virtual size_t promo_increment(size_t cur_eden, uint percent_change);\n-  virtual size_t promo_decrement(size_t cur_eden);\n+  size_t eden_increment(size_t cur_eden);\n+  size_t eden_increment(size_t cur_eden, uint percent_change);\n+  size_t eden_decrement(size_t cur_eden);\n+  size_t promo_increment(size_t cur_eden);\n+  size_t promo_increment(size_t cur_eden, uint percent_change);\n+  size_t promo_decrement(size_t cur_eden);\n","filename":"src\/hotspot\/share\/gc\/shared\/adaptiveSizePolicy.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2420,1 +2420,1 @@\n-void ShenandoahHeap::set_gc_state_all_threads() {\n+void ShenandoahHeap::propagate_gc_state_to_java_threads() {\n@@ -2431,1 +2431,1 @@\n-void ShenandoahHeap::set_gc_state_mask(uint mask, bool value) {\n+void ShenandoahHeap::set_gc_state(uint mask, bool value) {\n@@ -2452,1 +2452,1 @@\n-  set_gc_state_mask(mask, in_progress);\n+  set_gc_state(mask, in_progress);\n@@ -2468,1 +2468,1 @@\n-    set_gc_state_mask(OLD_MARKING, in_progress);\n+    set_gc_state(OLD_MARKING, in_progress);\n@@ -2470,1 +2470,1 @@\n-    set_gc_state_mask(MARKING | OLD_MARKING, in_progress);\n+    set_gc_state(MARKING | OLD_MARKING, in_progress);\n@@ -2501,1 +2501,1 @@\n-  set_gc_state_mask(EVACUATION, in_progress);\n+  set_gc_state(EVACUATION, in_progress);\n@@ -2513,1 +2513,1 @@\n-  set_gc_state_mask(WEAK_ROOTS, cond);\n+  set_gc_state(WEAK_ROOTS, cond);\n@@ -2652,1 +2652,1 @@\n-  set_gc_state_mask(HAS_FORWARDED, cond);\n+  set_gc_state(HAS_FORWARDED, cond);\n@@ -2692,1 +2692,1 @@\n-  set_gc_state_mask(UPDATEREFS, in_progress);\n+  set_gc_state(UPDATEREFS, in_progress);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -357,0 +357,3 @@\n+  \/\/ This updates the singlular, global gc state. This must happen on a safepoint.\n+  void set_gc_state(uint mask, bool value);\n+\n@@ -388,2 +391,0 @@\n-  void set_gc_state_mask(uint mask, bool value);\n-\n@@ -392,2 +393,8 @@\n-  void set_gc_state_all_threads();\n-  bool has_gc_state_changed() { return _gc_state_changed; }\n+\n+  \/\/ This copies the global gc state into a thread local variable for java threads.\n+  \/\/ It is primarily intended to support quick access at barriers.\n+  void propagate_gc_state_to_java_threads();\n+\n+  \/\/ This is public to support assertions that the state hasn't been changed off of\n+  \/\/ a safepoint and that any changes were propagated to java threads after the safepoint.\n+  bool has_gc_state_changed() const { return _gc_state_changed; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+    assert(thread->is_Java_thread(), \"GC state is only synchronized to java threads\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  ShenandoahHeap::heap()->set_gc_state_all_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n@@ -72,1 +72,1 @@\n-  ShenandoahHeap::heap()->set_gc_state_all_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n@@ -78,1 +78,1 @@\n-  ShenandoahHeap::heap()->set_gc_state_all_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n@@ -84,1 +84,1 @@\n-  ShenandoahHeap::heap()->set_gc_state_all_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n@@ -90,1 +90,1 @@\n-  ShenandoahHeap::heap()->set_gc_state_all_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n@@ -96,1 +96,1 @@\n-  ShenandoahHeap::heap()->set_gc_state_all_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n@@ -102,1 +102,1 @@\n-  ShenandoahHeap::heap()->set_gc_state_all_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -783,1 +783,1 @@\n-  ShenandoahHeap::heap()->set_gc_state_all_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -252,1 +252,1 @@\n-  \/\/ Reset marking information and mark roots\n+  \/\/ Reset marking information\n","filename":"src\/hotspot\/share\/gc\/x\/xHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -864,1 +864,1 @@\n-  \/\/ Reset marking information and mark roots\n+  \/\/ Reset marking information\n@@ -1216,1 +1216,1 @@\n-  \/\/ Reset marking information and mark roots\n+  \/\/ Reset marking information\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -539,1 +539,1 @@\n-              this_size < has_size && *fp == '\\0', \/\/ last field can be short\n+              (this_size < has_size && *fp == '\\0'), \/\/ last field can be short\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -118,0 +118,7 @@\n+    \/*\n+     * Pointer to JvmtiExport::_should_notify_object_alloc.\n+     * Exposed as an int* instead of an address so the\n+     * underlying type is part of the JVMCIVMStructs definition.\n+     *\/\n+    static int* _should_notify_object_alloc;\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -133,0 +134,2 @@\n+int* CompilerToVM::Data::_should_notify_object_alloc;\n+\n@@ -199,0 +202,2 @@\n+  _should_notify_object_alloc = &JvmtiExport::_should_notify_object_alloc;\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -125,0 +125,2 @@\n+  static_field(CompilerToVM::Data,             _should_notify_object_alloc,            int*)                                         \\\n+                                                                                                                                     \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -542,1 +542,1 @@\n-    assert(offset == 0 || offset >= second_part && offset <= operands->length(), \"oob (3)\");\n+    assert(offset == 0 || (offset >= second_part && offset <= operands->length()), \"oob (3)\");\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -329,1 +329,1 @@\n-  assert(is_native() && bcp == code_base() || contains(bcp) || VMError::is_error_reported(),\n+  assert((is_native() && bcp == code_base()) || contains(bcp) || VMError::is_error_reported(),\n@@ -363,1 +363,1 @@\n-  assert(is_native() && bcp == code_base() || contains(bcp), \"bcp doesn't belong to this method\");\n+  assert((is_native() && bcp == code_base()) || contains(bcp), \"bcp doesn't belong to this method\");\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -398,1 +398,2 @@\n-  int num_stack_arg_slots() const { return constMethod()->num_stack_arg_slots(); }\n+  int num_stack_arg_slots(bool rounded = true) const {\n+    return rounded ? align_up(constMethod()->num_stack_arg_slots(), 2) : constMethod()->num_stack_arg_slots(); }\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-  inline BitMap::idx_t bit_index_for(intptr_t* p) const;\n+  inline BitMap::idx_t bit_index_for(address p) const;\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-inline BitMap::idx_t stackChunkOopDesc::bit_index_for(intptr_t* p) const {\n+inline BitMap::idx_t stackChunkOopDesc::bit_index_for(address p) const {\n@@ -265,0 +265,1 @@\n+  assert(is_aligned(p, alignof(OopT)), \"should be aligned: \" PTR_FORMAT, p2i(p));\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -980,2 +980,2 @@\n-    assert(is_CallStaticJava()  && cg->is_mh_late_inline() ||\n-           is_CallDynamicJava() && cg->is_virtual_late_inline(), \"mismatch\");\n+    assert((is_CallStaticJava()  && cg->is_mh_late_inline()) ||\n+           (is_CallDynamicJava() && cg->is_virtual_late_inline()), \"mismatch\");\n@@ -1641,2 +1641,2 @@\n-             length_type->is_con() && narrow_length_type->is_con() &&\n-                (narrow_length_type->_hi <= length_type->_lo) ||\n+             (length_type->is_con() && narrow_length_type->is_con() &&\n+              (narrow_length_type->_hi <= length_type->_lo)) ||\n@@ -1655,2 +1655,1 @@\n-        length = new CastIINode(length, narrow_length_type);\n-        length->set_req(TypeFunc::Control, init->proj_out_or_null(TypeFunc::Control));\n+        length = new CastIINode(init->proj_out_or_null(TypeFunc::Control), length, narrow_length_type);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -126,41 +126,1 @@\n-Node* ConstraintCastNode::make_cast(int opcode, Node* c, Node* n, const Type* t, DependencyType dependency,\n-                                    const TypeTuple* extra_types) {\n-  switch(opcode) {\n-  case Op_CastII: {\n-    Node* cast = new CastIINode(n, t, dependency, false, extra_types);\n-    cast->set_req(0, c);\n-    return cast;\n-  }\n-  case Op_CastLL: {\n-    Node* cast = new CastLLNode(n, t, dependency, extra_types);\n-    cast->set_req(0, c);\n-    return cast;\n-  }\n-  case Op_CastPP: {\n-    Node* cast = new CastPPNode(n, t, dependency, extra_types);\n-    cast->set_req(0, c);\n-    return cast;\n-  }\n-  case Op_CastFF: {\n-    Node* cast = new CastFFNode(n, t, dependency, extra_types);\n-    cast->set_req(0, c);\n-    return cast;\n-  }\n-  case Op_CastDD: {\n-    Node* cast = new CastDDNode(n, t, dependency, extra_types);\n-    cast->set_req(0, c);\n-    return cast;\n-  }\n-  case Op_CastVV: {\n-    Node* cast = new CastVVNode(n, t, dependency, extra_types);\n-    cast->set_req(0, c);\n-    return cast;\n-  }\n-  case Op_CheckCastPP: return new CheckCastPPNode(c, n, t, dependency, extra_types);\n-  default:\n-    fatal(\"Bad opcode %d\", opcode);\n-  }\n-  return nullptr;\n-}\n-\n-Node* ConstraintCastNode::make(Node* c, Node *n, const Type *t, DependencyType dependency, BasicType bt) {\n+Node* ConstraintCastNode::make_cast_for_basic_type(Node* c, Node* n, const Type* t, DependencyType dependency, BasicType bt) {\n@@ -168,6 +128,4 @@\n-  case T_INT: {\n-    return make_cast(Op_CastII, c, n, t, dependency, nullptr);\n-  }\n-  case T_LONG: {\n-    return make_cast(Op_CastLL, c, n, t, dependency, nullptr);\n-  }\n+  case T_INT:\n+    return new CastIINode(c, n, t, dependency);\n+  case T_LONG:\n+    return new CastLLNode(c, n, t, dependency);\n@@ -270,1 +228,1 @@\n-  Node* n = ConstraintCastNode::make(control, parent, type, dependency, bt);\n+  Node* n = ConstraintCastNode::make_cast_for_basic_type(control, parent, type, dependency, bt);\n@@ -490,1 +448,0 @@\n-  Node* cast= nullptr;\n@@ -492,1 +449,1 @@\n-    cast = make_cast(Op_CastII, c, in, type, dependency, types);\n+    return new CastIINode(c, in, type, dependency, false, types);\n@@ -494,1 +451,1 @@\n-    cast = make_cast(Op_CastLL, c, in, type, dependency, types);\n+    return new CastLLNode(c, in, type, dependency, types);\n@@ -496,1 +453,1 @@\n-    cast = make_cast(Op_CastFF, c, in, type, dependency, types);\n+    return new CastFFNode(c, in, type, dependency, types);\n@@ -498,1 +455,1 @@\n-    cast = make_cast(Op_CastDD, c, in, type, dependency, types);\n+    return new CastDDNode(c, in, type, dependency, types);\n@@ -500,1 +457,1 @@\n-    cast = make_cast(Op_CastVV, c, in, type, dependency, types);\n+    return new CastVVNode(c, in, type, dependency, types);\n@@ -502,1 +459,1 @@\n-    cast = make_cast(Op_CastPP, c, in, type, dependency, types);\n+    return new CastPPNode(c, in, type, dependency, types);\n@@ -504,1 +461,1 @@\n-  return cast;\n+  fatal(\"unreachable. Invalid cast type.\");\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":13,"deletions":56,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  ConstraintCastNode(Node* n, const Type* t, ConstraintCastNode::DependencyType dependency,\n+  ConstraintCastNode(Node* ctrl, Node* n, const Type* t, ConstraintCastNode::DependencyType dependency,\n@@ -61,0 +61,1 @@\n+    init_req(0, ctrl);\n@@ -71,2 +72,1 @@\n-  static Node* make_cast(int opcode, Node* c, Node* n, const Type* t, DependencyType dependency, const TypeTuple* extra_types);\n-  static Node* make(Node* c, Node *n, const Type *t, DependencyType dependency, BasicType bt);\n+  static Node* make_cast_for_basic_type(Node* c, Node* n, const Type* t, DependencyType dependency, BasicType bt);\n@@ -105,1 +105,1 @@\n-    : ConstraintCastNode(n, t, dependency, types), _range_check_dependency(range_check_dependency) {\n+    : ConstraintCastNode(nullptr, n, t, dependency, types), _range_check_dependency(range_check_dependency) {\n@@ -108,2 +108,2 @@\n-  CastIINode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false)\n-    : ConstraintCastNode(n, t, dependency, nullptr), _range_check_dependency(range_check_dependency) {\n+  CastIINode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, bool range_check_dependency = false, const TypeTuple* types = nullptr)\n+    : ConstraintCastNode(ctrl, n, t, dependency, types), _range_check_dependency(range_check_dependency) {\n@@ -111,1 +111,0 @@\n-    init_req(0, ctrl);\n@@ -134,7 +133,2 @@\n-  CastLLNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency)\n-    : ConstraintCastNode(n, t, dependency, nullptr) {\n-    init_class_id(Class_CastLL);\n-    init_req(0, ctrl);\n-  }\n-  CastLLNode(Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n-          : ConstraintCastNode(n, t, dependency, types) {\n+  CastLLNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+          : ConstraintCastNode(ctrl, n, t, dependency, types) {\n@@ -152,2 +146,2 @@\n-  CastFFNode(Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n-          : ConstraintCastNode(n, t, dependency, types) {\n+  CastFFNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+          : ConstraintCastNode(ctrl, n, t, dependency, types) {\n@@ -162,2 +156,2 @@\n-  CastDDNode(Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n-          : ConstraintCastNode(n, t, dependency, types) {\n+  CastDDNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+          : ConstraintCastNode(ctrl, n, t, dependency, types) {\n@@ -172,2 +166,2 @@\n-  CastVVNode(Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n-          : ConstraintCastNode(n, t, dependency, types) {\n+  CastVVNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+          : ConstraintCastNode(ctrl, n, t, dependency, types) {\n@@ -185,2 +179,2 @@\n-  CastPPNode (Node *n, const Type *t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n-    : ConstraintCastNode(n, t, dependency, types) {\n+  CastPPNode (Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+    : ConstraintCastNode(ctrl, n, t, dependency, types) {\n@@ -196,2 +190,2 @@\n-  CheckCastPPNode(Node *c, Node *n, const Type *t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n-    : ConstraintCastNode(n, t, dependency, types) {\n+  CheckCastPPNode(Node* ctrl, Node* n, const Type* t, DependencyType dependency = RegularDependency, const TypeTuple* types = nullptr)\n+    : ConstraintCastNode(ctrl, n, t, dependency, types) {\n@@ -199,1 +193,0 @@\n-    init_req(0, c);\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":18,"deletions":25,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2151,2 +2151,1 @@\n-          cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, ConstraintCastNode::StrongDependency,\n-                                               extra_types);\n+          cast = new CastPPNode(r, uin, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n@@ -2162,2 +2161,1 @@\n-            cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, TypePtr::NOTNULL,\n-                                                 ConstraintCastNode::StrongDependency, extra_types);\n+            cast = new CastPPNode(r, uin, TypePtr::NOTNULL, ConstraintCastNode::StrongDependency, extra_types);\n@@ -2175,2 +2173,1 @@\n-            cast = ConstraintCastNode::make_cast(Op_CheckCastPP, r, n, phi_type, ConstraintCastNode::StrongDependency,\n-                                                 extra_types);\n+            cast = new CheckCastPPNode(r, uin, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n@@ -2179,2 +2176,1 @@\n-            cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, ConstraintCastNode::StrongDependency,\n-                                                 extra_types);\n+            cast = new CastPPNode(r, uin, phi_type, ConstraintCastNode::StrongDependency, extra_types);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -166,2 +166,2 @@\n-      assert(_is_vector && (_num_regs == RegMask::SlotsPerVecA) ||\n-             _is_predicate && (_num_regs == RegMask::SlotsPerRegVectMask), \"unexpected scalable reg\");\n+      assert((_is_vector && (_num_regs == RegMask::SlotsPerVecA)) ||\n+             (_is_predicate && (_num_regs == RegMask::SlotsPerRegVectMask)), \"unexpected scalable reg\");\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -3143,2 +3143,2 @@\n-            n->is_Load() && (n->as_Load()->bottom_type()->isa_oopptr() ||\n-                             LoadNode::is_immutable_value(n->in(MemNode::Address))),\n+            (n->is_Load() && (n->as_Load()->bottom_type()->isa_oopptr() ||\n+                              LoadNode::is_immutable_value(n->in(MemNode::Address)))),\n@@ -4474,1 +4474,0 @@\n-    value = new CastIINode(value, itype, carry_dependency ? ConstraintCastNode::StrongDependency : ConstraintCastNode::RegularDependency, true \/* range check dependency *\/);\n@@ -4479,1 +4478,1 @@\n-    value->set_req(0, ctrl);\n+    value = new CastIINode(ctrl, value, itype, carry_dependency ? ConstraintCastNode::StrongDependency : ConstraintCastNode::RegularDependency, true \/* range check dependency *\/);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1124,1 +1124,1 @@\n-         (n_ptn != nullptr) && (n_ptn->ideal_node() != nullptr),\n+         ((n_ptn != nullptr) && (n_ptn->ideal_node() != nullptr)),\n@@ -3859,1 +3859,1 @@\n-                 tn_t != nullptr && !tinst->maybe_java_subtype_of(tn_t),\n+                 (tn_t != nullptr && !tinst->maybe_java_subtype_of(tn_t)),\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1442,2 +1442,1 @@\n-  Node *cast = new CastPPNode(obj,t_not_null);\n-  cast->init_req(0, control());\n+  Node* cast = new CastPPNode(control(), obj,t_not_null);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,2 +153,3 @@\n-  assert(!is_decoden || (val->in(0) == nullptr) && val->is_Mach() &&\n-         (val->as_Mach()->ideal_Opcode() == Op_DecodeN), \"sanity\");\n+  assert(!is_decoden ||\n+         ((val->in(0) == nullptr) && val->is_Mach() &&\n+          (val->as_Mach()->ideal_Opcode() == Op_DecodeN)), \"sanity\");\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -876,2 +876,1 @@\n-    Node* ccast = new CastIINode(index, TypeInt::POS);\n-    ccast->set_req(0, control());\n+    Node* ccast = new CastIINode(control(), index, TypeInt::POS);\n@@ -1144,1 +1143,3 @@\n-  Node* casted_length = ConstraintCastNode::make(control(), length, TypeInteger::make(0, upper_bound, Type::WidenMax, bt), ConstraintCastNode::RegularDependency, bt);\n+  Node* casted_length = ConstraintCastNode::make_cast_for_basic_type(\n+      control(), length, TypeInteger::make(0, upper_bound, Type::WidenMax, bt),\n+      ConstraintCastNode::RegularDependency, bt);\n@@ -1172,1 +1173,3 @@\n-  Node* result = ConstraintCastNode::make(control(), index, TypeInteger::make(0, upper_bound, Type::WidenMax, bt), ConstraintCastNode::RegularDependency, bt);\n+  Node* result = ConstraintCastNode::make_cast_for_basic_type(\n+      control(), index, TypeInteger::make(0, upper_bound, Type::WidenMax, bt),\n+      ConstraintCastNode::RegularDependency, bt);\n@@ -4315,2 +4318,1 @@\n-      Node* cast = new CastPPNode(klass_node, akls);\n-      cast->init_req(0, control());\n+      Node* cast = new CastPPNode(control(), klass_node, akls);\n@@ -5943,2 +5945,1 @@\n-       Node *cast = new CastPPNode(z, TypePtr::NOTNULL);\n-       cast->init_req(0, control());\n+       Node* cast = new CastPPNode(control(), z, TypePtr::NOTNULL);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -800,1 +800,2 @@\n-  if ((stride > 0) == (scale > 0) == upper) {\n+  \/\/ same signs and upper, or different signs and not upper.\n+  if (((stride > 0) == (scale > 0)) == upper) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1287,2 +1287,1 @@\n-  Node* castii = new CastIINode(incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n-  castii->set_req(0, ctrl);\n+  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n@@ -3164,1 +3163,1 @@\n-  main_limit = new CastIINode(main_limit, TypeInt::make(upward ? min_jint : orig_limit_t->_lo,\n+  main_limit = new CastIINode(pre_ctrl, main_limit, TypeInt::make(upward ? min_jint : orig_limit_t->_lo,\n@@ -3166,1 +3165,0 @@\n-  main_limit->init_req(0, pre_ctrl);\n@@ -3425,1 +3423,4 @@\n-  Node* cast_ii = ConstraintCastNode::make(cl->in(LoopNode::EntryControl), exact_limit, phase->_igvn.type(exact_limit), ConstraintCastNode::UnconditionalDependency, T_INT);\n+  Node* cast_ii = ConstraintCastNode::make_cast_for_basic_type(\n+      cl->in(LoopNode::EntryControl), exact_limit,\n+      phase->_igvn.type(exact_limit),\n+      ConstraintCastNode::UnconditionalDependency, T_INT);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -4958,1 +4958,1 @@\n-         alias_idx == Compile::AliasIdxBot && !Compile::current()->do_aliasing(),\n+         (alias_idx == Compile::AliasIdxBot && !Compile::current()->do_aliasing()),\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -791,1 +791,1 @@\n-           _oop_alias_idx == Compile::AliasIdxBot && !Compile::current()->do_aliasing(),\n+           (_oop_alias_idx == Compile::AliasIdxBot && !Compile::current()->do_aliasing()),\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -451,1 +451,1 @@\n-    assert( i == 0 && this == n ||\n+    assert( (i == 0 && this == n) ||\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1733,1 +1733,1 @@\n-        ccast = new CastIINode(val, tboth);\n+        ccast = new CastIINode(control(), val, tboth);\n@@ -1736,1 +1736,1 @@\n-        ccast = new CastPPNode(val, tboth);\n+        ccast = new CastPPNode(control(), val, tboth);\n@@ -1767,1 +1767,0 @@\n-    ccast->set_req(0, control());\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-    vec_field_ld = gvn.transform(new CastPPNode(vec_field_ld, payload_type));\n+    vec_field_ld = gvn.transform(new CastPPNode(nullptr, vec_field_ld, payload_type));\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  int slots = SharedRuntime::java_calling_convention(signature, vm_regs, num_args);\n+  int slots = align_up(SharedRuntime::java_calling_convention(signature, vm_regs, num_args), 2);\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3936,2 +3936,0 @@\n-#else\n-  fatal(\"Should only be called with JVMTI enabled\");\n@@ -3953,2 +3951,0 @@\n-#else\n-  fatal(\"Should only be called with JVMTI enabled\");\n@@ -3972,2 +3968,0 @@\n-#else\n-  fatal(\"Should only be called with JVMTI enabled\");\n@@ -3991,2 +3985,0 @@\n-#else\n-  fatal(\"Should only be called with JVMTI enabled\");\n@@ -4006,2 +3998,0 @@\n-#else\n-  fatal(\"Should only be called with JVMTI enabled\");\n@@ -4022,2 +4012,0 @@\n-#else\n-  fatal(\"Should only be called with JVMTI enabled\");\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1778,1 +1778,1 @@\n-  void clear_bitmap_bits(intptr_t* start, int range);\n+  void clear_bitmap_bits(address start, address end);\n@@ -2169,1 +2169,4 @@\n-void ThawBase::clear_bitmap_bits(intptr_t* start, int range) {\n+void ThawBase::clear_bitmap_bits(address start, address end) {\n+  assert(is_aligned(start, wordSize), \"should be aligned: \" PTR_FORMAT, p2i(start));\n+  assert(is_aligned(end, VMRegImpl::stack_slot_size), \"should be aligned: \" PTR_FORMAT, p2i(end));\n+\n@@ -2171,2 +2174,8 @@\n-  \/\/ or they will keep objects that are otherwise unreachable alive\n-  log_develop_trace(continuations)(\"clearing bitmap for \" INTPTR_FORMAT \" - \" INTPTR_FORMAT, p2i(start), p2i(start+range));\n+  \/\/ or they will keep objects that are otherwise unreachable alive.\n+\n+  \/\/ Align `end` if UseCompressedOops is not set to avoid UB when calculating the bit index, since\n+  \/\/ `end` could be at an odd number of stack slots from `start`, i.e might not be oop aligned.\n+  \/\/ If that's the case the bit range corresponding to the last stack slot should not have bits set\n+  \/\/ anyways and we assert that before returning.\n+  address effective_end = UseCompressedOops ? end : align_down(end, wordSize);\n+  log_develop_trace(continuations)(\"clearing bitmap for \" INTPTR_FORMAT \" - \" INTPTR_FORMAT, p2i(start), p2i(effective_end));\n@@ -2174,2 +2183,2 @@\n-  chunk->bitmap().clear_range(chunk->bit_index_for(start),\n-                              chunk->bit_index_for(start+range));\n+  chunk->bitmap().clear_range(chunk->bit_index_for(start), chunk->bit_index_for(effective_end));\n+  assert(chunk->bitmap().count_one_bits(chunk->bit_index_for(effective_end), chunk->bit_index_for(end)) == 0, \"bits should not be set\");\n@@ -2228,1 +2237,3 @@\n-    clear_bitmap_bits(heap_frame_bottom - locals, locals);\n+    address start = (address)(heap_frame_bottom - locals);\n+    address end = (address)heap_frame_bottom;\n+    clear_bitmap_bits(start, end);\n@@ -2301,1 +2312,4 @@\n-    clear_bitmap_bits(heap_frame_top + ContinuationHelper::CompiledFrame::size(hf) + frame::metadata_words_at_top, added_argsize);\n+    address start = (address)(heap_frame_top + ContinuationHelper::CompiledFrame::size(hf) + frame::metadata_words_at_top);\n+    int stack_args_slots = f.cb()->as_compiled_method()->method()->num_stack_arg_slots(false \/* rounded *\/);\n+    int argsize_in_bytes = stack_args_slots * VMRegImpl::stack_slot_size;\n+    clear_bitmap_bits(start, start + argsize_in_bytes);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1442,1 +1442,1 @@\n-      assert(stack_arg_slots ==  m->num_stack_arg_slots(), \"\");\n+      assert(stack_arg_slots ==  m->num_stack_arg_slots(false \/* rounded *\/), \"\");\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -534,1 +534,0 @@\n-  static bool   can_execute_large_page_memory();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2007,1 +2007,1 @@\n-  int comp_args_on_stack = java_calling_convention(sig_bt, regs_without_member_name, total_args_passed - 1);\n+  java_calling_convention(sig_bt, regs_without_member_name, total_args_passed - 1);\n@@ -3105,1 +3105,1 @@\n-      int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n+      SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -181,1 +181,0 @@\n-  _stack_arg_slots = align_up(_stack_arg_slots, 2);\n@@ -238,1 +237,0 @@\n-#if defined(PPC64) || defined(S390)\n@@ -242,0 +240,4 @@\n+#if defined(PPC64) || defined(S390)\n+      _stack_arg_slots += 1;\n+#else\n+      _stack_arg_slots = align_up(_stack_arg_slots, 2);\n@@ -243,0 +245,1 @@\n+#endif \/\/ defined(PPC64) || defined(S390)\n@@ -245,1 +248,0 @@\n-#endif \/\/ defined(PPC64) || defined(S390)\n@@ -253,2 +255,1 @@\n-      PPC64_ONLY(_stack_arg_slots = align_up(_stack_arg_slots, 2));\n-      S390_ONLY(_stack_arg_slots = align_up(_stack_arg_slots, 2));\n+      _stack_arg_slots = align_up(_stack_arg_slots, 2);\n@@ -259,1 +260,0 @@\n-#if defined(PPC64) || defined(S390)\n@@ -263,0 +263,4 @@\n+#if defined(PPC64) || defined(S390)\n+      _stack_arg_slots += 1;\n+#else\n+      _stack_arg_slots = align_up(_stack_arg_slots, 2);\n@@ -264,0 +268,1 @@\n+#endif \/\/ defined(PPC64) || defined(S390)\n@@ -266,1 +271,0 @@\n-#endif \/\/ defined(PPC64) || defined(S390)\n@@ -271,2 +275,1 @@\n-      PPC64_ONLY(_stack_arg_slots = align_up(_stack_arg_slots, 2));\n-      S390_ONLY(_stack_arg_slots = align_up(_stack_arg_slots, 2));\n+      _stack_arg_slots = align_up(_stack_arg_slots, 2);\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -74,5 +74,0 @@\n-  bool is_stopped() const {\n-    assert(_lock->is_locked(), \"Must be\");\n-    return _stop;\n-  }\n-\n@@ -218,2 +213,0 @@\n-    \/\/ Don't pull lock during error reporting\n-    Mutex* const lock = VMError::is_error_reported() ? nullptr : _lock;\n@@ -224,1 +217,2 @@\n-      MutexLocker ml(lock, Mutex::_no_safepoint_check_flag);\n+      \/\/ Don't pull lock during error reporting\n+      ConditionalMutexLocker ml(_lock, !VMError::is_error_reported(), Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/runtime\/trimNativeHeap.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -246,0 +246,9 @@\n+#ifdef MUSL_LIBC\n+    \/\/ This code is used by Unsafe and may hit the next page after truncation of mapped memory.\n+    \/\/ Therefore, we use volatile to prevent compilers from replacing the loop by memset which\n+    \/\/ may not trigger SIGBUS as needed (observed on Alpine Linux x86_64)\n+    jbyte fill = value;\n+    for (uintptr_t off = 0; off < size; off += sizeof(jbyte)) {\n+      *(volatile jbyte*)(dst + off) = fill;\n+    }\n+#else\n@@ -247,0 +256,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/copy.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -344,4 +344,4 @@\n-    unsigned char res = b0 | b0 - 1 |\n-                        b1 | b1 - 1 |\n-                        b2 | b2 - 1 |\n-                        b3 | b3 - 1;\n+    unsigned char res = b0 | (b0 - 1) |\n+                        b1 | (b1 - 1) |\n+                        b2 | (b2 - 1) |\n+                        b3 | (b3 - 1);\n","filename":"src\/hotspot\/share\/utilities\/utf8.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-        return;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ISO10126Padding.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-        return;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PKCS5Padding.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -646,3 +646,7 @@\n-                \/\/ Prevent poisoning and leaking of buf\n-                byte[] buffer = Arrays.copyOfRange(getBufIfOpen(), pos, count);\n-                out.write(buffer);\n+                if (isTrusted(out)) {\n+                    out.write(getBufIfOpen(), pos, avail);\n+                } else {\n+                    \/\/ Prevent poisoning and leaking of buf\n+                    byte[] buffer = Arrays.copyOfRange(getBufIfOpen(), pos, count);\n+                    out.write(buffer);\n+                }\n@@ -661,0 +665,18 @@\n+    \/**\n+     * Returns true if this class satisfies the following conditions:\n+     * <ul>\n+     * <li>does not retain a reference to the {@code byte[]}<\/li>\n+     * <li>does not leak a reference to the {@code byte[]} to non-trusted classes<\/li>\n+     * <li>does not modify the contents of the {@code byte[]}<\/li>\n+     * <li>{@code write()} method does not read the contents outside of the offset\/length bounds<\/li>\n+     * <\/ul>\n+     *\n+     * @return true if this class is trusted\n+     *\/\n+    private static boolean isTrusted(OutputStream os) {\n+        var clazz = os.getClass();\n+        return clazz == ByteArrayOutputStream.class\n+                || clazz == FileOutputStream.class\n+                || clazz == PipedOutputStream.class;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/BufferedInputStream.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-     * Constructs a new identity hash map containing the keys-value mappings\n+     * Constructs a new identity hash map containing the key-value mappings\n","filename":"src\/java.base\/share\/classes\/java\/util\/IdentityHashMap.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,0 +192,4 @@\n+    private static IllegalArgumentException outOfBoundsError(IndexOutOfBoundsException cause) {\n+        return new IllegalArgumentException(\"Reading beyond classfile bounds\", cause);\n+    }\n+\n@@ -194,1 +198,5 @@\n-        return buffer[p] & 0xFF;\n+        try {\n+            return buffer[p] & 0xFF;\n+        } catch (IndexOutOfBoundsException e) {\n+            throw outOfBoundsError(e);\n+        }\n@@ -199,3 +207,7 @@\n-        int b1 = buffer[p] & 0xFF;\n-        int b2 = buffer[p + 1] & 0xFF;\n-        return (b1 << 8) + b2;\n+        try {\n+            int b1 = buffer[p] & 0xFF;\n+            int b2 = buffer[p + 1] & 0xFF;\n+            return (b1 << 8) + b2;\n+        } catch (IndexOutOfBoundsException e) {\n+            throw outOfBoundsError(e);\n+        }\n@@ -206,1 +218,5 @@\n-        return buffer[p];\n+        try {\n+            return buffer[p];\n+        } catch (IndexOutOfBoundsException e) {\n+            throw outOfBoundsError(e);\n+        }\n@@ -211,3 +227,7 @@\n-        int b1 = buffer[p];\n-        int b2 = buffer[p + 1] & 0xFF;\n-        return (b1 << 8) + b2;\n+        try {\n+            int b1 = buffer[p];\n+            int b2 = buffer[p + 1] & 0xFF;\n+            return (b1 << 8) + b2;\n+        } catch (IndexOutOfBoundsException e) {\n+            throw outOfBoundsError(e);\n+        }\n@@ -218,5 +238,9 @@\n-        int ch1 = buffer[p] & 0xFF;\n-        int ch2 = buffer[p + 1] & 0xFF;\n-        int ch3 = buffer[p + 2] & 0xFF;\n-        int ch4 = buffer[p + 3] & 0xFF;\n-        return (ch1 << 24) + (ch2 << 16) + (ch3 << 8) + ch4;\n+        try {\n+            int ch1 = buffer[p] & 0xFF;\n+            int ch2 = buffer[p + 1] & 0xFF;\n+            int ch3 = buffer[p + 2] & 0xFF;\n+            int ch4 = buffer[p + 3] & 0xFF;\n+            return (ch1 << 24) + (ch2 << 16) + (ch3 << 8) + ch4;\n+        } catch (IndexOutOfBoundsException e) {\n+            throw outOfBoundsError(e);\n+        }\n@@ -227,4 +251,8 @@\n-        return ((long) buffer[p + 0] << 56) + ((long) (buffer[p + 1] & 255) << 48) +\n-               ((long) (buffer[p + 2] & 255) << 40) + ((long) (buffer[p + 3] & 255) << 32) +\n-               ((long) (buffer[p + 4] & 255) << 24) + ((buffer[p + 5] & 255) << 16) + ((buffer[p + 6] & 255) << 8) +\n-               (buffer[p + 7] & 255);\n+        try {\n+            return ((long) buffer[p + 0] << 56) + ((long) (buffer[p + 1] & 255) << 48) +\n+                   ((long) (buffer[p + 2] & 255) << 40) + ((long) (buffer[p + 3] & 255) << 32) +\n+                   ((long) (buffer[p + 4] & 255) << 24) + ((buffer[p + 5] & 255) << 16) + ((buffer[p + 6] & 255) << 8) +\n+                   (buffer[p + 7] & 255);\n+        } catch (IndexOutOfBoundsException e) {\n+            throw outOfBoundsError(e);\n+        }\n@@ -245,1 +273,5 @@\n-        return Arrays.copyOfRange(buffer, p, p + len);\n+        try {\n+            return Arrays.copyOfRange(buffer, p, p + len);\n+        } catch (IndexOutOfBoundsException e) {\n+            throw outOfBoundsError(e);\n+        }\n@@ -250,1 +282,5 @@\n-        buf.writeBytes(buffer, p, len);\n+        try {\n+            buf.writeBytes(buffer, p, len);\n+        } catch (IndexOutOfBoundsException e) {\n+            throw outOfBoundsError(e);\n+        }\n@@ -449,3 +485,7 @@\n-        return Arrays.equals(((BufWriterImpl) bufWriter).elems,\n-                             bufWriterOffset, bufWriterOffset + length,\n-                             buffer, classReaderOffset, classReaderOffset + length);\n+        try {\n+            return Arrays.equals(((BufWriterImpl) bufWriter).elems,\n+                                 bufWriterOffset, bufWriterOffset + length,\n+                                 buffer, classReaderOffset, classReaderOffset + length);\n+        } catch (IndexOutOfBoundsException e) {\n+            throw outOfBoundsError(e);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":63,"deletions":23,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,7 +47,12 @@\n-        List<TypeParam> typeParamTypes = parseParamTypes();\n-        RefTypeSig superclass = referenceTypeSig();\n-        ArrayList<RefTypeSig> superinterfaces = null;\n-        while (sigp < sig.length()) {\n-            if (superinterfaces == null)\n-                superinterfaces = new ArrayList<>();\n-            superinterfaces.add(referenceTypeSig());\n+        try {\n+            List<TypeParam> typeParamTypes = parseParamTypes();\n+            RefTypeSig superclass = referenceTypeSig();\n+            ArrayList<RefTypeSig> superinterfaces = null;\n+            while (sigp < sig.length()) {\n+                if (superinterfaces == null)\n+                    superinterfaces = new ArrayList<>();\n+                superinterfaces.add(referenceTypeSig());\n+            }\n+            return new ClassSignatureImpl(typeParamTypes, superclass, null2Empty(superinterfaces));\n+        } catch (IndexOutOfBoundsException e) {\n+            throw error(\"Not a valid class signature\");\n@@ -55,1 +60,0 @@\n-        return new ClassSignatureImpl(typeParamTypes, superclass, null2Empty(superinterfaces));\n@@ -61,13 +65,10 @@\n-        List<TypeParam> typeParamTypes = parseParamTypes();\n-        assert sig.charAt(sigp) == '(';\n-        sigp++;\n-        ArrayList<Signature> paramTypes = null;\n-        while (sig.charAt(sigp) != ')') {\n-            if (paramTypes == null)\n-                 paramTypes = new ArrayList<>();\n-            paramTypes.add(typeSig());\n-        }\n-        sigp++;\n-        Signature returnType = typeSig();\n-        ArrayList<ThrowableSig> throwsTypes = null;\n-        while (sigp < sig.length() && sig.charAt(sigp) == '^') {\n+        try {\n+            List<TypeParam> typeParamTypes = parseParamTypes();\n+            if (sig.charAt(sigp) != '(') throw error(\"Expected ( at possition %d of signature\".formatted(sigp));\n+            sigp++;\n+            ArrayList<Signature> paramTypes = null;\n+            while (sig.charAt(sigp) != ')') {\n+                if (paramTypes == null)\n+                     paramTypes = new ArrayList<>();\n+                paramTypes.add(typeSig());\n+            }\n@@ -75,7 +76,16 @@\n-            if (throwsTypes == null)\n-                throwsTypes = new ArrayList<>();\n-            var t = typeSig();\n-            if (t instanceof ThrowableSig ts)\n-                throwsTypes.add(ts);\n-            else\n-                throw new IllegalArgumentException(\"not a valid type signature: \" + sig);\n+            Signature returnType = typeSig();\n+            ArrayList<ThrowableSig> throwsTypes = null;\n+            while (sigp < sig.length()) {\n+                if (sig.charAt(sigp) != '^') throw error(\"Expected ^ at possition %d of signature\".formatted(sigp));\n+                sigp++;\n+                if (throwsTypes == null)\n+                    throwsTypes = new ArrayList<>();\n+                var t = referenceTypeSig();\n+                if (t instanceof ThrowableSig ts)\n+                    throwsTypes.add(ts);\n+                else\n+                    throw error(\"Not a valid throwable signature %s in\".formatted(t.signatureString()));\n+            }\n+            return new MethodSignatureImpl(typeParamTypes, null2Empty(throwsTypes), returnType, null2Empty(paramTypes));\n+        } catch (IndexOutOfBoundsException e) {\n+            throw error(\"Not a valid method signature\");\n@@ -83,1 +93,0 @@\n-        return new MethodSignatureImpl(typeParamTypes, null2Empty(throwsTypes), returnType, null2Empty(paramTypes));\n@@ -89,1 +98,7 @@\n-        return typeSig();\n+        try {\n+            var s = typeSig();\n+            if (sigp == signature.length())\n+                return s;\n+        } catch (IndexOutOfBoundsException e) {\n+        }\n+        throw error(\"Not a valid type signature\");\n@@ -160,1 +175,1 @@\n-        throw new IllegalArgumentException(\"not a valid type signature: \" + sig);\n+        throw error(\"Unexpected character %c at possition %d of signature\".formatted(c, sigp - 1));\n@@ -295,0 +310,4 @@\n+\n+    private IllegalArgumentException error(String message) {\n+        return new IllegalArgumentException(\"%s: %s\".formatted(message, sig));\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":51,"deletions":32,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-                        java.util.Arrays.fill(passwd, ' ');\n+                        Arrays.fill(passwd, ' ');\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsoleImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,1 +172,1 @@\n-     * {@return a set of types in {@code elements}}\n+     * {@return a set of classes and interfaces in {@code elements}}\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+typedef HTHEME(__stdcall *PFNOPENTHEMEDATA)(HWND hwnd, LPCWSTR pszClassList);\n@@ -93,0 +94,1 @@\n+static PFNOPENTHEMEDATA OpenThemeDataFunc = NULL;\n@@ -112,0 +114,1 @@\n+constexpr unsigned int defaultDPI = 96;\n@@ -113,1 +116,2 @@\n-BOOL InitThemes() {\n+\n+static BOOL InitThemes() {\n@@ -119,0 +123,2 @@\n+        OpenThemeDataFunc = (PFNOPENTHEMEDATA)GetProcAddress(hModThemes,\n+                                                         \"OpenThemeData\");\n@@ -155,1 +161,1 @@\n-        if(OpenThemeDataForDpiFunc\n+        if((OpenThemeDataForDpiFunc || OpenThemeDataFunc)\n@@ -176,4 +182,6 @@\n-              constexpr unsigned int defaultDPI = 96;\n-              HTHEME hTheme = OpenThemeDataForDpiFunc (\n-                              AwtToolkit::GetInstance().GetHWnd(),\n-                              L\"Button\", defaultDPI);\n+              HTHEME hTheme = OpenThemeDataForDpiFunc\n+                              ? OpenThemeDataForDpiFunc(AwtToolkit::GetInstance().GetHWnd(),\n+                                                        L\"Button\", defaultDPI)\n+                              : OpenThemeDataFunc(AwtToolkit::GetInstance().GetHWnd(),\n+                                                  L\"Button\");\n+\n@@ -249,0 +257,1 @@\n+\n@@ -251,3 +260,4 @@\n-    HTHEME htheme = OpenThemeDataForDpiFunc(\n-                    AwtToolkit::GetInstance().GetHWnd(),\n-                    str, dpi);\n+    HTHEME htheme = OpenThemeDataForDpiFunc\n+                    ? OpenThemeDataForDpiFunc(AwtToolkit::GetInstance().GetHWnd(), str, dpi)\n+                    : OpenThemeDataFunc(AwtToolkit::GetInstance().GetHWnd(), str);\n+\n@@ -433,2 +443,0 @@\n-    rect.bottom = rectBottom;\n-    rect.right = rectRight;\n@@ -436,0 +444,7 @@\n+    if (OpenThemeDataForDpiFunc) {\n+        rect.bottom = rectBottom;\n+        rect.right = rectRight;\n+    } else {\n+        rect.bottom = h;\n+        rect.right = w;\n+    }\n@@ -458,0 +473,22 @@\n+static void rescale(SIZE *size) {\n+    static int dpiX = -1;\n+    static int dpiY = -1;\n+\n+    if (dpiX == -1 || dpiY == -1) {\n+        HWND hWnd = ::GetDesktopWindow();\n+        HDC hDC = ::GetDC(hWnd);\n+        dpiX = ::GetDeviceCaps(hDC, LOGPIXELSX);\n+        dpiY = ::GetDeviceCaps(hDC, LOGPIXELSY);\n+        ::ReleaseDC(hWnd, hDC);\n+    }\n+\n+    if (dpiX !=0 && dpiX != defaultDPI) {\n+        float invScaleX = (float) defaultDPI \/ dpiX;\n+        size->cx = (int) round(size->cx * invScaleX);\n+    }\n+    if (dpiY != 0 && dpiY != defaultDPI) {\n+        float invScaleY = (float) defaultDPI \/ dpiY;\n+        size->cy = (int) round(size->cy * invScaleY);\n+    }\n+}\n+\n@@ -749,0 +786,4 @@\n+            if (!OpenThemeDataForDpiFunc) {\n+                rescale(&size);\n+            }\n+\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/ThemeReader.cpp","additions":52,"deletions":11,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -545,1 +545,1 @@\n-            Timestamp stamp = new Timestamp(instant.getEpochSecond() * MILLIS_PER_SECOND);\n+            Timestamp stamp = new Timestamp(Math.multiplyExact(instant.getEpochSecond(), MILLIS_PER_SECOND));\n","filename":"src\/java.sql\/share\/classes\/java\/sql\/Timestamp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-          \"Message: \"+msg);\n+          \"Message: \"+msg, th);\n","filename":"src\/java.xml\/share\/classes\/javax\/xml\/stream\/XMLStreamException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-        MethodSymbol sym = (MethodSymbol)TreeInfo.symbolFor(invoke.meth);\n+        Symbol sym = TreeInfo.symbolFor(invoke.meth);\n@@ -533,1 +533,1 @@\n-    private void invoke(JCTree site, MethodSymbol sym, List<JCExpression> args, RefSet<?> receiverRefs) {\n+    private void invoke(JCTree site, Symbol sym, List<JCExpression> args, RefSet<?> receiverRefs) {\n@@ -813,0 +813,4 @@\n+        if (tree.type.isErroneous()) {\n+            \/\/error recovery - ignore erroneous member references\n+            return ;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-.\\\" Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,0 +167,17 @@\n+\\f[V]Compiler.CodeHeap_Analytics\\f[R] [\\f[I]function\\f[R]] [\\f[I]granularity\\f[R]]\n+Print CodeHeap analytics\n+.RS\n+.PP\n+Impact: Low: Depends on code heap size and content.\n+Holds CodeCache_lock during analysis step, usually sub-second duration.\n+.PP\n+\\f[I]arguments\\f[R]:\n+.PP\n+\\f[I]function\\f[R]: (Optional) Function to be performed (aggregate,\n+UsedSpace, FreeSpace, MethodCount, MethodSpace, MethodAge, MethodNames,\n+discard (STRING, all)\n+.PP\n+\\f[I]granularity\\f[R]: (Optional) Detail level - smaller value -> more\n+detail (INT, 4096)\n+.RE\n+.TP\n@@ -181,2 +198,2 @@\n-\\f[V]Compiler.perfmap\\f[R] [\\f[I]arguments\\f[R]] (Linux only)\n-Write map file for Linux perf tool.\n+\\f[V]Compiler.directives_add\\f[R] \\f[I]arguments\\f[R]\n+Adds compiler directives from a file.\n@@ -188,3 +205,0 @@\n-.IP \\[bu] 2\n-\\f[V]filename\\f[R]: (Optional) Name of the map file (STRING, no default\n-value)\n@@ -192,4 +206,2 @@\n-If \\f[V]filename\\f[R] is not specified, a default file name is chosen\n-using the pid of the target JVM process.\n-For example, if the pid is \\f[V]12345\\f[R], then the default\n-\\f[V]filename\\f[R] will be \\f[V]\/tmp\/perf-12345.map\\f[R].\n+\\f[I]filename\\f[R]: The name of the directives file (STRING, no default\n+value)\n@@ -198,2 +210,2 @@\n-\\f[V]Compiler.queue\\f[R]\n-Prints methods queued for compilation.\n+\\f[V]Compiler.directives_clear\\f[R]\n+Remove all compiler directives.\n@@ -205,2 +217,2 @@\n-\\f[V]Compiler.directives_add *filename* *arguments*\\f[R]\n-Adds compiler directives from a file.\n+\\f[V]Compiler.directives_print\\f[R]\n+Prints all active compiler directives.\n@@ -210,5 +222,0 @@\n-.PP\n-\\f[I]arguments\\f[R]:\n-.PP\n-\\f[I]filename\\f[R]: The name of the directives file (STRING, no default\n-value)\n@@ -217,2 +224,2 @@\n-\\f[V]Compiler.directives_clear\\f[R]\n-Remove all compiler directives.\n+\\f[V]Compiler.directives_remove\\f[R]\n+Remove latest added compiler directive.\n@@ -224,2 +231,20 @@\n-\\f[V]Compiler.directives_print\\f[R]\n-Prints all active compiler directives.\n+\\f[V]Compiler.memory\\f[R] [\\f[I]options\\f[R]]\n+Print compilation footprint\n+.RS\n+.PP\n+Impact: Medium: Pause time depends on number of compiled methods\n+.PP\n+\\f[B]Note:\\f[R]\n+.PP\n+The \\f[I]options\\f[R] must be specified using either \\f[I]key\\f[R] or\n+\\f[I]key\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R] syntax.\n+.PP\n+\\f[I]options\\f[R]:\n+.IP \\[bu] 2\n+\\f[V]-H\\f[R]: (Optional) Human readable format (BOOLEAN, false)\n+.IP \\[bu] 2\n+\\f[V]-s\\f[R]: (Optional) Minimum memory size (MEMORY SIZE, 0)\n+.RE\n+.TP\n+\\f[V]Compiler.perfmap\\f[R] [\\f[I]arguments\\f[R]] (Linux only)\n+Write map file for Linux perf tool.\n@@ -229,0 +254,5 @@\n+.PP\n+\\f[I]arguments\\f[R]:\n+.PP\n+\\f[I]filename\\f[R]: (Optional) The name of the map file (STRING, no\n+default value)\n@@ -231,2 +261,2 @@\n-\\f[V]Compiler.directives_remove\\f[R]\n-Remove latest added compiler directive.\n+\\f[V]Compiler.queue\\f[R]\n+Prints methods queued for compilation.\n@@ -294,0 +324,6 @@\n+.IP \\[bu] 2\n+\\f[V]-parallel\\f[R]: (Optional) Number of parallel threads to use for\n+heap dump.\n+The VM will try to use the specified number of threads, but might use\n+fewer.\n+(INT, 1)\n@@ -357,0 +393,5 @@\n+\\f[V]dumppath\\f[R]: (Optional) Path to the location where a recording\n+file is written in case the VM runs into a critical error, such as a\n+system crash.\n+(STRING, The default location is the current directory)\n+.IP \\[bu] 2\n@@ -654,1 +695,1 @@\n-Signals the JVM to do a data-dump request for JVMTI.\n+Signal the JVM to do a data-dump request for JVMTI.\n@@ -770,0 +811,35 @@\n+\\f[V]System.dump_map\\f[R] [\\f[I]options\\f[R]] (Linux only)\n+Dumps an annotated process memory map to an output file.\n+.RS\n+.PP\n+Impact: Low\n+.PP\n+\\f[B]Note:\\f[R]\n+.PP\n+The following \\f[I]options\\f[R] must be specified using either\n+\\f[I]key\\f[R] or \\f[I]key\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R] syntax.\n+.PP\n+\\f[I]options\\f[R]:\n+.IP \\[bu] 2\n+\\f[V]-H\\f[R]: (Optional) Human readable format (BOOLEAN, false)\n+.IP \\[bu] 2\n+\\f[V]-F\\f[R]: (Optional) File path (STRING,\n+\\[dq]vm_memory_map_.txt\\[dq])\n+.RE\n+.TP\n+\\f[V]System.map\\f[R] [\\f[I]options\\f[R]] (Linux only)\n+Prints an annotated process memory map of the VM process.\n+.RS\n+.PP\n+Impact: Low\n+.PP\n+\\f[B]Note:\\f[R]\n+.PP\n+The following \\f[I]options\\f[R] must be specified using either\n+\\f[I]key\\f[R] or \\f[I]key\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R] syntax.\n+.PP\n+\\f[I]options\\f[R]:\n+.IP \\[bu] 2\n+\\f[V]-H\\f[R]: (Optional) Human readable format (BOOLEAN, false)\n+.RE\n+.TP\n@@ -771,1 +847,3 @@\n-Prints information about native heap usage through malloc_info(3).\n+Attempts to output information regarding native heap usage through\n+malloc_info(3).\n+If unsuccessful outputs \\[dq]Error: \\[dq] and a reason.\n@@ -784,0 +862,25 @@\n+\\f[V]Thread.dump_to_file\\f[R] [\\f[I]options\\f[R]] \\f[I]filepath\\f[R]\n+Dump threads, with stack traces, to a file in plain text or JSON format.\n+.RS\n+.PP\n+Impact: Medium: Depends on the number of threads.\n+.PP\n+\\f[B]Note:\\f[R]\n+.PP\n+The following \\f[I]options\\f[R] must be specified using either\n+\\f[I]key\\f[R] or \\f[I]key\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R] syntax.\n+.PP\n+\\f[I]options\\f[R]:\n+.IP \\[bu] 2\n+\\f[V]-overwrite\\f[R]: (Optional) May overwrite existing file (BOOLEAN,\n+false)\n+.IP \\[bu] 2\n+\\f[V]-format\\f[R]: (Optional) Output format (\\[dq]plain\\[dq] or\n+\\[dq]json\\[dq]) (STRING, plain)\n+.PP\n+\\f[I]arguments\\f[R]:\n+.IP \\[bu] 2\n+\\f[V]filepath\\f[R]: The file path to the output file (STRING, no default\n+value)\n+.RE\n+.TP\n@@ -805,1 +908,1 @@\n-Dumps a static or dynamic shared archive that includes all currently\n+Dump a static or dynamic shared archive that includes all currently\n@@ -831,2 +934,6 @@\n-\\f[V]VM.classloaders\\f[R] [\\f[I]options\\f[R]]\n-Prints classloader hierarchy.\n+\\f[V]VM.class_hierarchy\\f[R] [\\f[I]options\\f[R]] [\\f[I]arguments\\f[R]]\n+Print a list of all loaded classes, indented to show the class\n+hierarchy.\n+The name of each class is followed by the ClassLoaderData* of its\n+ClassLoader, or \\[dq]null\\[dq] if it is loaded by the bootstrap class\n+loader.\n@@ -835,2 +942,3 @@\n-Impact: Medium --- Depends on number of class loaders and classes\n-loaded.\n+Impact: Medium --- depends on the number of loaded classes.\n+.PP\n+\\f[B]Note:\\f[R]\n@@ -843,1 +951,1 @@\n-\\f[V]show-classes\\f[R]: (Optional) Print loaded classes.\n+\\f[V]-i\\f[R]: (Optional) Inherited interfaces should be printed.\n@@ -846,1 +954,3 @@\n-\\f[V]verbose\\f[R]: (Optional) Print detailed information.\n+\\f[V]-s\\f[R]: (Optional) If a classname is specified, print its\n+subclasses in addition to its superclasses.\n+Without this option only the superclasses will be printed.\n@@ -848,0 +958,2 @@\n+.PP\n+\\f[I]arguments\\f[R]:\n@@ -849,3 +961,24 @@\n-\\f[V]fold\\f[R]: (Optional) Show loaders of the same name and class as\n-one.\n-(BOOLEAN, true)\n+\\f[I]classname\\f[R]: (Optional) The name of the class whose hierarchy\n+should be printed.\n+If not specified, all class hierarchies are printed.\n+(STRING, no default value)\n+.RE\n+.TP\n+\\f[V]VM.classes\\f[R] [\\f[I]options\\f[R]]\n+Print all loaded classes\n+.RS\n+.PP\n+Impact: Medium: Depends on number of loaded classes.\n+.PP\n+The following \\f[I]options\\f[R] must be specified using either\n+\\f[I]key\\f[R] or \\f[I]key\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R] syntax.\n+.PP\n+\\f[I]options\\f[R]:\n+.IP \\[bu] 2\n+\\f[V]-verbose\\f[R]: (Optional) Dump the detailed content of a Java\n+class.\n+Some classes are annotated with flags: \\f[V]F\\f[R] = has, or inherits, a\n+non-empty finalize method, \\f[V]f\\f[R] = has final method, \\f[V]W\\f[R] =\n+methods rewritten, \\f[V]C\\f[R] = marked with \\f[V]\\[at]Contended\\f[R]\n+annotation, \\f[V]R\\f[R] = has been redefined, \\f[V]S\\f[R] = is shared\n+class (BOOLEAN, false)\n@@ -855,1 +988,1 @@\n-Prints statistics about all ClassLoaders.\n+Print statistics about all ClassLoaders.\n@@ -861,6 +994,2 @@\n-\\f[V]VM.class_hierarchy\\f[R] [\\f[I]options\\f[R]] [\\f[I]arguments\\f[R]]\n-Prints a list of all loaded classes, indented to show the class\n-hierarchy.\n-The name of each class is followed by the ClassLoaderData* of its\n-ClassLoader, or \\[dq]null\\[dq] if it is loaded by the bootstrap class\n-loader.\n+\\f[V]VM.classloaders\\f[R] [\\f[I]options\\f[R]]\n+Prints classloader hierarchy.\n@@ -869,3 +998,2 @@\n-Impact: Medium --- depends on the number of loaded classes.\n-.PP\n-\\f[B]Note:\\f[R]\n+Impact: Medium --- Depends on number of class loaders and classes\n+loaded.\n@@ -878,1 +1006,1 @@\n-\\f[V]-i\\f[R]: (Optional) Inherited interfaces should be printed.\n+\\f[V]show-classes\\f[R]: (Optional) Print loaded classes.\n@@ -881,3 +1009,1 @@\n-\\f[V]-s\\f[R]: (Optional) If a classname is specified, print its\n-subclasses in addition to its superclasses.\n-Without this option only the superclasses will be printed.\n+\\f[V]verbose\\f[R]: (Optional) Print detailed information.\n@@ -885,2 +1011,0 @@\n-.PP\n-\\f[I]arguments\\f[R]:\n@@ -888,4 +1012,3 @@\n-\\f[I]classname\\f[R]: (Optional) The name of the class whose hierarchy\n-should be printed.\n-If not specified, all class hierarchies are printed.\n-(STRING, no default value)\n+\\f[V]fold\\f[R]: (Optional) Show loaders of the same name and class as\n+one.\n+(BOOLEAN, true)\n@@ -895,1 +1018,1 @@\n-Prints the command line used to start this VM instance.\n+Print the command line used to start this VM instance.\n@@ -902,1 +1025,1 @@\n-Prints the loaded dynamic libraries.\n+Print loaded dynamic libraries.\n@@ -931,0 +1054,17 @@\n+\\f[V]VM.flags\\f[R] [\\f[I]options\\f[R]]\n+Print the VM flag options and their current values.\n+.RS\n+.PP\n+Impact: Low\n+.PP\n+\\f[B]Note:\\f[R]\n+.PP\n+The following \\f[I]options\\f[R] must be specified using either\n+\\f[I]key\\f[R] or \\f[I]key\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R] syntax.\n+.PP\n+\\f[I]options\\f[R]:\n+.IP \\[bu] 2\n+\\f[V]-all\\f[R]: (Optional) Prints all flags supported by the VM\n+(BOOLEAN, false).\n+.RE\n+.TP\n@@ -932,1 +1072,1 @@\n-Prints information about the JVM environment and status.\n+Print information about the JVM environment and status.\n@@ -977,17 +1117,0 @@\n-\\f[V]VM.flags\\f[R] [\\f[I]options\\f[R]]\n-Prints the VM flag options and their current values.\n-.RS\n-.PP\n-Impact: Low\n-.PP\n-\\f[B]Note:\\f[R]\n-.PP\n-The following \\f[I]options\\f[R] must be specified using either\n-\\f[I]key\\f[R] or \\f[I]key\\f[R]\\f[V]=\\f[R]\\f[I]value\\f[R] syntax.\n-.PP\n-\\f[I]options\\f[R]:\n-.IP \\[bu] 2\n-\\f[V]-all\\f[R]: (Optional) Prints all flags supported by the VM\n-(BOOLEAN, false).\n-.RE\n-.TP\n@@ -1028,0 +1151,4 @@\n+\\f[V]chunkfreelist\\f[R]: (Optional) Shows details about global chunk\n+free lists (ChunkManager).\n+(BOOLEAN, false)\n+.IP \\[bu] 2\n@@ -1035,1 +1162,1 @@\n-Prints native memory usage\n+Print native memory usage\n@@ -1077,8 +1204,0 @@\n-\\f[V]VM.print_touched_methods\\f[R]\n-Prints all methods that have ever been touched during the lifetime of\n-this JVM.\n-.RS\n-.PP\n-Impact: Medium --- depends on Java content.\n-.RE\n-.TP\n@@ -1086,1 +1205,1 @@\n-Sets the VM flag option by using the provided value.\n+Sets VM flag option using the provided value.\n@@ -1101,1 +1220,1 @@\n-Dumps the string table.\n+Dump string table.\n@@ -1118,1 +1237,1 @@\n-Dumps the symbol table.\n+Dump symbol table.\n@@ -1134,0 +1253,7 @@\n+\\f[V]VM.system_properties\\f[R]\n+Print system properties.\n+.RS\n+.PP\n+Impact: Low\n+.RE\n+.TP\n@@ -1151,7 +1277,0 @@\n-\\f[V]VM.system_properties\\f[R]\n-Prints the system properties.\n-.RS\n-.PP\n-Impact: Low\n-.RE\n-.TP\n@@ -1159,1 +1278,1 @@\n-Prints the VM uptime.\n+Print VM uptime.\n@@ -1176,1 +1295,1 @@\n-Prints JVM version information.\n+Print JVM version information.\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":217,"deletions":98,"binary":false,"changes":315,"status":"modified"},{"patch":"@@ -66,5 +66,1 @@\n-                Batch batch = task.getBatch();\n-                \/\/ If new task, or period has changed, find new batch\n-                if (batch == null) {\n-                    batch = findBatch(task.getPeriod());\n-                }\n+                Batch batch = findBatch(task.getPeriod(), task.getBatch());\n@@ -92,1 +88,1 @@\n-    private Batch findBatch(long period) {\n+    private Batch findBatch(long period, Batch oldBatch) {\n@@ -105,1 +101,1 @@\n-        Batch batch = new Batch(period);\n+        Batch batch = oldBatch != null ? oldBatch : new Batch(period);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/BatchManager.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2576,1 +2576,4 @@\n-                    throw new ZipException(\"invalid loc \" + pos + \" for entry reading\");\n+                    throw new ZipException(\"invalid LOC \" + pos + \" for entry reading\");\n+                }\n+                if (LOCSIG(buf) != LOCSIG) {\n+                    throw new ZipException(\"invalid LOC header (bad signature)\");\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,2 +75,0 @@\n-compiler\/codecache\/CheckLargePages.java 8319795 linux-x64\n-\n@@ -88,0 +86,5 @@\n+gc\/TestAllocHumongousFragment.java#adaptive 8298781 generic-all\n+gc\/TestAllocHumongousFragment.java#aggressive 8298781 generic-all\n+gc\/TestAllocHumongousFragment.java#iu-aggressive 8298781 generic-all\n+gc\/TestAllocHumongousFragment.java#g1 8298781 generic-all\n+gc\/TestAllocHumongousFragment.java#static 8298781 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-        OutputAnalyzer out = ProcessTools.executeTestJvm(\"-XX:CompileThresholdScaling=\" + value, \"--version\");\n+        OutputAnalyzer out = ProcessTools.executeTestJava(\"-XX:CompileThresholdScaling=\" + value, \"--version\");\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestCompileThresholdScaling.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        OutputAnalyzer oa = ProcessTools.executeTestJvm(options);\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(options);\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestPrintC1Statistics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJvm(\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestDriver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-            CLIENT_VM_AVAILABLE = ProcessTools.executeTestJvm(CLIENT_VM_OPTION, VERSION_OPTION)\n+            CLIENT_VM_AVAILABLE = ProcessTools.executeTestJava(CLIENT_VM_OPTION, VERSION_OPTION)\n@@ -110,1 +110,1 @@\n-            SERVER_VM_AVAILABLE = ProcessTools.executeTestJvm(SERVER_VM_OPTION, VERSION_OPTION)\n+            SERVER_VM_AVAILABLE = ProcessTools.executeTestJava(SERVER_VM_OPTION, VERSION_OPTION)\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/CiReplayBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,3 @@\n-    private final static WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private final static long LP_1G = 1024 * 1024 * 1024;\n+    private final static boolean LARGE_PAGES_ENABLED;\n+    private final static long LARGE_PAGE_SIZE;\n@@ -49,0 +51,65 @@\n+    static {\n+        WhiteBox whiteBox = WhiteBox.getWhiteBox();\n+        LARGE_PAGES_ENABLED = whiteBox.getBooleanVMFlag(\"UseLargePages\");\n+        LARGE_PAGE_SIZE = (whiteBox.getBooleanVMFlag(\"UseLargePages\")) ? whiteBox.getVMLargePageSize() : 0;\n+    }\n+\n+    private static boolean isLargePageSizeEqual(long size) {\n+        return LARGE_PAGE_SIZE == size;\n+    }\n+\n+    private static void testSegmented2GbCodeCacheWith1GbPage() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                \"-XX:+UseLargePages\",\n+                \"-XX:+SegmentedCodeCache\",\n+                \"-XX:InitialCodeCacheSize=2g\",\n+                \"-XX:ReservedCodeCacheSize=2g\",\n+                \"-XX:LargePageSizeInBytes=1g\",\n+                \"-Xlog:pagesize=info\",\n+                \"-version\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldMatch(\"Code cache size too small for \\\\S* pages\\\\. Reverting to smaller page size \\\\((\\\\S*)\\\\)\\\\.\");\n+        out.shouldHaveExitValue(0);\n+        \/\/ Parse page sizes to find next biggest page\n+        String sizes = out.firstMatch(\"Usable page sizes:([^.]+)\", 1);\n+        List<Long> sizeList = Arrays.stream(sizes.trim().split(\"\\\\s*,\\\\s*\")).map(CheckLargePages::parseMemoryString)\n+                .sorted().toList();\n+        final int smallerPageSizeIndex = sizeList.indexOf(LARGE_PAGE_SIZE) - 1;\n+        Asserts.assertGreaterThanOrEqual(smallerPageSizeIndex, 0);\n+        final long smallerPageSize = sizeList.get(smallerPageSizeIndex);\n+        \/\/ Retrieve reverted page size from code cache warning\n+        String revertedSizeString = out.firstMatch(\n+                \"Code cache size too small for (\\\\S*) pages. Reverting to smaller page size \\\\((\\\\S*)\\\\)\\\\.\", 2);\n+        Asserts.assertEquals(parseMemoryString(revertedSizeString), smallerPageSize);\n+    }\n+\n+    private static void testDefaultCodeCacheWith1GbLargePages() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                \"-XX:+UseLargePages\",\n+                \"-XX:LargePageSizeInBytes=1g\",\n+                \"-XX:+PrintCodeCache\",\n+                \"-version\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(0);\n+        out.shouldContain(\"CodeHeap 'non-nmethods'\");\n+        out.shouldContain(\"CodeHeap 'profiled nmethods'\");\n+        out.shouldContain(\"CodeHeap 'non-profiled nmethods'\");\n+    }\n+\n+    private static void testNonSegmented1GbCodeCacheWith1GbLargePages() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                \"-XX:+UseLargePages\",\n+                \"-XX:LargePageSizeInBytes=1g\",\n+                \"-XX:ReservedCodeCacheSize=1g\",\n+                \"-XX:InitialCodeCacheSize=1g\",\n+                \"-XX:+PrintCodeCache\",\n+                \"-Xlog:pagesize=info\",\n+                \"-version\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(0);\n+        out.shouldNotContain(\"CodeHeap 'non-nmethods'\");\n+        out.shouldNotContain(\"CodeHeap 'profiled nmethods'\");\n+        out.shouldNotContain(\"CodeHeap 'non-profiled nmethods'\");\n+        out.shouldContain(\"UseLargePages=1, UseTransparentHugePages=0\");\n+        out.shouldMatch(\"CodeCache:  min=1[gG] max=1[gG] base=[^ ]+ size=1[gG] page_size=1[gG]\");\n+    }\n@@ -50,23 +117,4 @@\n-        final boolean largePages = WHITE_BOX.getBooleanVMFlag(\"UseLargePages\");\n-        final long largePageSize = WHITE_BOX.getVMLargePageSize();\n-        if (largePages && (largePageSize == 1024 * 1024 * 1024)) {\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n-                    \"-XX:+UseLargePages\",\n-                    \"-XX:+SegmentedCodeCache\",\n-                    \"-XX:InitialCodeCacheSize=2g\",\n-                    \"-XX:ReservedCodeCacheSize=2g\",\n-                    \"-XX:LargePageSizeInBytes=1g\",\n-                    \"-Xlog:pagesize=info\",\n-                    \"-version\");\n-            OutputAnalyzer out = new OutputAnalyzer(pb.start());\n-            out.shouldMatch(\"Code cache size too small for \\\\S* pages\\\\. Reverting to smaller page size \\\\((\\\\S*)\\\\)\\\\.\");\n-            out.shouldHaveExitValue(0);\n-            \/\/ Parse page sizes to find next biggest page\n-            String sizes = out.firstMatch(\"Usable page sizes:([^.]+)\", 1);\n-            List<Long> sizeList = Arrays.stream(sizes.trim().split(\"\\\\s*,\\\\s*\")).map(CheckLargePages::parseMemoryString).sorted().toList();\n-            final int smallerPageSizeIndex = sizeList.indexOf(largePageSize) - 1;\n-            Asserts.assertGreaterThanOrEqual(smallerPageSizeIndex, 0);\n-            final long smallerPageSize = sizeList.get(smallerPageSizeIndex);\n-            \/\/ Retrieve reverted page size from code cache warning\n-            String revertedSizeString = out.firstMatch(\"Code cache size too small for (\\\\S*) pages. Reverting to smaller page size \\\\((\\\\S*)\\\\)\\\\.\", 2);\n-            Asserts.assertEquals(parseMemoryString(revertedSizeString), smallerPageSize);\n+        if (isLargePageSizeEqual(LP_1G)) {\n+            testSegmented2GbCodeCacheWith1GbPage();\n+            testDefaultCodeCacheWith1GbLargePages();\n+            testNonSegmented1GbCodeCacheWith1GbLargePages();\n@@ -74,2 +122,2 @@\n-            System.out.println(\"1GB large pages not supported: UseLargePages=\" + largePages +\n-                    (largePages ? \", largePageSize=\" + largePageSize : \"\") + \". Skipping\");\n+            System.out.println(\"1GB large pages not supported: UseLargePages=\" + LARGE_PAGES_ENABLED +\n+                    (LARGE_PAGES_ENABLED ? \", largePageSize=\" + LARGE_PAGE_SIZE : \"\") + \". Skipping\");\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckLargePages.java","additions":74,"deletions":26,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(\"-Xmx64m\", \"-XX:CompileCommand=\" + option, \"-version\");\n+        OutputAnalyzer output = ProcessTools.executeTestJava(\"-Xmx64m\", \"-XX:CompileCommand=\" + option, \"-version\");\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/commands\/MemLimitTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=MemStat,*.*\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:CompileCommand=MemStat,*.*\", \"-version\")\n@@ -46,1 +46,1 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=MemStat,*.*,collect\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:CompileCommand=MemStat,*.*,collect\", \"-version\")\n@@ -51,1 +51,1 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=MemStat,*.*,print\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:CompileCommand=MemStat,*.*,print\", \"-version\")\n@@ -56,1 +56,1 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=MemStat,*.*,invalid\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:CompileCommand=MemStat,*.*,invalid\", \"-version\")\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/commands\/MemStatTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=option,package\/class,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:CompileCommand=option,package\/class,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n@@ -46,1 +46,1 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=option,*,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:CompileCommand=option,*,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n@@ -54,1 +54,1 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=option,*.ccstrlist,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:CompileCommand=option,*.ccstrlist,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n@@ -60,1 +60,1 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=option,*.*,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:CompileCommand=option,*.*,ccstrlist,ControlIntrinsic,+_getClass\", \"-version\")\n@@ -65,1 +65,1 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=option,class,PrintIntrinsics\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:CompileCommand=option,class,PrintIntrinsics\", \"-version\")\n@@ -71,1 +71,1 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=option,class.PrintIntrinsics,PrintIntrinsics\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:CompileCommand=option,class.PrintIntrinsics,PrintIntrinsics\", \"-version\")\n@@ -78,1 +78,1 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=dontinline,*::dontinline_*\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:CompileCommand=dontinline,*::dontinline_*\", \"-version\")\n@@ -83,1 +83,1 @@\n-        ProcessTools.executeTestJvm(\"-XX:CompileCommand=dontinline,*.dontinline\", \"-version\")\n+        ProcessTools.executeTestJava(\"-XX:CompileCommand=dontinline,*.dontinline\", \"-version\")\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/commands\/OptionTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-            output = ProcessTools.executeTestJvm(\n+            output = ProcessTools.executeTestJava(\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/parser\/HugeDirectiveUtil.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-            output = ProcessTools.executeTestJvm(cmds);\n+            output = ProcessTools.executeTestJava(cmds);\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/Executor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJvm(\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n@@ -106,1 +106,1 @@\n-            OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJvm(\n+            OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n@@ -135,1 +135,1 @@\n-            OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJvm(\n+            OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n@@ -161,1 +161,1 @@\n-        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJvm(\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n@@ -183,1 +183,1 @@\n-        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJvm(\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n","filename":"test\/hotspot\/jtreg\/compiler\/cpuflags\/TestAESIntrinsicsOnSupportedConfig.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJvm(\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n@@ -92,1 +92,1 @@\n-        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJvm(\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n","filename":"test\/hotspot\/jtreg\/compiler\/cpuflags\/TestAESIntrinsicsOnUnsupportedConfig.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-            OutputAnalyzer oa = ProcessTools.executeTestJvm(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+            OutputAnalyzer oa = ProcessTools.executeTestJava(\"-XX:+IgnoreUnrecognizedVMOptions\",\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestMembarDependencies.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import java.util.HexFormat;\n@@ -53,0 +54,2 @@\n+import static java.lang.String.format;\n+\n@@ -72,0 +75,2 @@\n+        length_checks();\n+\n@@ -305,0 +310,114 @@\n+\n+    static final int POSITIONS = 30_000;\n+    static final int BASE_LENGTH = 256;\n+    static final HexFormat HEX_FORMAT = HexFormat.of().withUpperCase().withDelimiter(\" \");\n+\n+    static int[] plainOffsets = new int[POSITIONS + 1];\n+    static byte[] plainBytes;\n+    static int[] base64Offsets = new int[POSITIONS + 1];\n+    static byte[] base64Bytes;\n+\n+    static {\n+        \/\/ Set up ByteBuffer with characters to be encoded\n+        int plainLength = 0;\n+        for (int i = 0; i < plainOffsets.length; i++) {\n+            plainOffsets[i] = plainLength;\n+            int positionLength = (BASE_LENGTH + i) % 2048;\n+            plainLength += positionLength;\n+        }\n+        \/\/ Put one of each possible byte value into ByteBuffer\n+        plainBytes = new byte[plainLength];\n+        for (int i = 0; i < plainBytes.length; i++) {\n+            plainBytes[i] = (byte) i;\n+        }\n+\n+        \/\/ Grab various slices of the ByteBuffer and encode them\n+        ByteBuffer plainBuffer = ByteBuffer.wrap(plainBytes);\n+        int base64Length = 0;\n+        for (int i = 0; i < POSITIONS; i++) {\n+            base64Offsets[i] = base64Length;\n+            int offset = plainOffsets[i];\n+            int length = plainOffsets[i + 1] - offset;\n+            ByteBuffer plainSlice = plainBuffer.slice(offset, length);\n+            base64Length += Base64.getEncoder().encode(plainSlice).remaining();\n+        }\n+\n+        \/\/ Decode the slices created above and ensure lengths match\n+        base64Offsets[base64Offsets.length - 1] = base64Length;\n+        base64Bytes = new byte[base64Length];\n+        for (int i = 0; i < POSITIONS; i++) {\n+            int plainOffset = plainOffsets[i];\n+            ByteBuffer plainSlice = plainBuffer.slice(plainOffset, plainOffsets[i + 1] - plainOffset);\n+            ByteBuffer encodedBytes = Base64.getEncoder().encode(plainSlice);\n+            int base64Offset = base64Offsets[i];\n+            int expectedLength = base64Offsets[i + 1] - base64Offset;\n+            if (expectedLength != encodedBytes.remaining()) {\n+                throw new IllegalStateException(format(\"Unexpected length: %s <> %s\", encodedBytes.remaining(), expectedLength));\n+            }\n+            encodedBytes.get(base64Bytes, base64Offset, expectedLength);\n+        }\n+    }\n+\n+    public static void length_checks() {\n+        decodeAndCheck();\n+        encodeDecode();\n+        System.out.println(\"Test complete, no invalid decodes detected\");\n+    }\n+\n+    \/\/ Use ByteBuffer to cause decode() to use the base + offset form of decode\n+    \/\/ Checks for bug reported in JDK-8321599 where padding characters appear\n+    \/\/ within the beginning of the ByteBuffer *before* the offset.  This caused\n+    \/\/ the decoded string length to be off by 1 or 2 bytes.\n+    static void decodeAndCheck() {\n+        for (int i = 0; i < POSITIONS; i++) {\n+            ByteBuffer encodedBytes = base64BytesAtPosition(i);\n+            ByteBuffer decodedBytes = Base64.getDecoder().decode(encodedBytes);\n+\n+            if (!decodedBytes.equals(plainBytesAtPosition(i))) {\n+                String base64String = base64StringAtPosition(i);\n+                String plainHexString = plainHexStringAtPosition(i);\n+                String decodedHexString = HEX_FORMAT.formatHex(decodedBytes.array(), decodedBytes.arrayOffset() + decodedBytes.position(), decodedBytes.arrayOffset() + decodedBytes.limit());\n+                throw new IllegalStateException(format(\"Mismatch for %s\\n\\nExpected:\\n%s\\n\\nActual:\\n%s\", base64String, plainHexString, decodedHexString));\n+            }\n+        }\n+    }\n+\n+    \/\/ Encode strings of lengths 1-1K, decode, and ensure length and contents correct.\n+    \/\/ This checks that padding characters are properly handled by decode.\n+    static void encodeDecode() {\n+        String allAs = \"A(=)\".repeat(128);\n+        for (int i = 1; i <= 512; i++) {\n+            String encStr = Base64.getEncoder().encodeToString(allAs.substring(0, i).getBytes());\n+            String decStr = new String(Base64.getDecoder().decode(encStr));\n+\n+            if ((decStr.length() != allAs.substring(0, i).length()) ||\n+                (!Objects.equals(decStr, allAs.substring(0, i)))\n+               ) {\n+                throw new IllegalStateException(format(\"Mismatch: Expected: %s\\n          Actual: %s\\n\", allAs.substring(0, i), decStr));\n+            }\n+        }\n+    }\n+\n+    static ByteBuffer plainBytesAtPosition(int position) {\n+        int offset = plainOffsets[position];\n+        int length = plainOffsets[position + 1] - offset;\n+        return ByteBuffer.wrap(plainBytes, offset, length);\n+    }\n+\n+    static String plainHexStringAtPosition(int position) {\n+        int offset = plainOffsets[position];\n+        int length = plainOffsets[position + 1] - offset;\n+        return HEX_FORMAT.formatHex(plainBytes, offset, offset + length);\n+    }\n+\n+    static String base64StringAtPosition(int position) {\n+        int offset = base64Offsets[position];\n+        int length = base64Offsets[position + 1] - offset;\n+        return new String(base64Bytes, offset, length, StandardCharsets.UTF_8);\n+    }\n+\n+    static ByteBuffer base64BytesAtPosition(int position) {\n+        int offset = base64Offsets[position];\n+        int length = base64Offsets[position + 1] - offset;\n+        return ByteBuffer.wrap(base64Bytes, offset, length);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/base64\/TestBase64.java","additions":120,"deletions":1,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJvm(vmOpts);\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(vmOpts);\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/bmi\/BMITestRunner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-            oa = ProcessTools.executeTestJvm(cmds);\n+            oa = ProcessTools.executeTestJava(cmds);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/FlagVMProcess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-            \/\/ Use executeProcess instead of executeTestJvm as we have already added the JTreg VM and\n+            \/\/ Use executeProcess instead of executeTestJava as we have already added the JTreg VM and\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMProcess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,3 +62,4 @@\n-            oa = ProcessTools.executeTestJvm(\"-XX:+UnlockDiagnosticVMOptions\", \"-Xbootclasspath\/a:.\",\n-                                             \"-XX:\" + (enabled ? \"+\" : \"-\") + \"UseCountedLoopSafepoints\",\n-                                             \"-XX:+WhiteBoxAPI\",\n+            oa = ProcessTools.executeTestJava(\n+                    \"-XX:+UnlockDiagnosticVMOptions\", \"-Xbootclasspath\/a:.\",\n+                    \"-XX:\" + (enabled ? \"+\" : \"-\") + \"UseCountedLoopSafepoints\",\n+                    \"-XX:+WhiteBoxAPI\",\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/UseCountedLoopSafepointsTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        ProcessTools.executeTestJvm(\"-XX:+UnlockDiagnosticVMOptions\",\n+        ProcessTools.executeTestJava(\"-XX:+UnlockDiagnosticVMOptions\",\n@@ -57,1 +57,1 @@\n-        ProcessTools.executeTestJvm(\"-XX:+UnlockDiagnosticVMOptions\",\n+        ProcessTools.executeTestJava(\"-XX:+UnlockDiagnosticVMOptions\",\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/CheckLoopStripMining.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        OutputAnalyzer oa = ProcessTools.executeTestJvm(options);\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(options);\n","filename":"test\/hotspot\/jtreg\/compiler\/oracle\/PrintIdealPhaseTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-        OutputAnalyzer oa = ProcessTools.executeTestJvm(options);\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(options);\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandMemLimit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        OutputAnalyzer oa = ProcessTools.executeTestJvm(options);\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(options);\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandPrintCompilation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        OutputAnalyzer oa = ProcessTools.executeTestJvm(options);\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(options);\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandPrintMemStat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        OutputAnalyzer oa = ProcessTools.executeTestJvm(options);\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(options);\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/PrintCompilation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-        OutputAnalyzer outputC1 = ProcessTools.executeTestJvm(c1Args)\n+        OutputAnalyzer outputC1 = ProcessTools.executeTestJava(c1Args)\n@@ -273,1 +273,1 @@\n-        OutputAnalyzer outputC2 = ProcessTools.executeTestJvm(c2Args)\n+        OutputAnalyzer outputC2 = ProcessTools.executeTestJava(c2Args)\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/TestConstantsInError.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,2 +40,2 @@\n-        ProcessTools.executeTestJvm(\"--add-modules=jdk.incubator.vector\", \"-XX:+UnlockExperimentalVMOptions\",\n-                                    \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n+        ProcessTools.executeTestJava(\"--add-modules=jdk.incubator.vector\", \"-XX:+UnlockExperimentalVMOptions\",\n+                                     \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -45,2 +45,2 @@\n-        ProcessTools.executeTestJvm(\"--add-modules=jdk.incubator.vector\", \"-XX:+UnlockExperimentalVMOptions\",\n-                                    \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n+        ProcessTools.executeTestJava(\"--add-modules=jdk.incubator.vector\", \"-XX:+UnlockExperimentalVMOptions\",\n+                                     \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -50,2 +50,2 @@\n-        ProcessTools.executeTestJvm(\"--add-modules=jdk.incubator.vector\", \"-XX:+UnlockExperimentalVMOptions\",\n-                                    \"-XX:-EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n+        ProcessTools.executeTestJava(\"--add-modules=jdk.incubator.vector\", \"-XX:+UnlockExperimentalVMOptions\",\n+                                     \"-XX:-EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -56,2 +56,2 @@\n-        ProcessTools.executeTestJvm(\"--add-modules=jdk.incubator.vector\", \"-XX:+UnlockExperimentalVMOptions\",\n-                                    \"-XX:-EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n+        ProcessTools.executeTestJava(\"--add-modules=jdk.incubator.vector\", \"-XX:+UnlockExperimentalVMOptions\",\n+                                     \"-XX:-EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -61,2 +61,2 @@\n-        ProcessTools.executeTestJvm(\"--add-modules=jdk.incubator.vector\", \"-XX:+UnlockExperimentalVMOptions\",\n-                                    \"-XX:-EnableVectorSupport\", \"-Xlog:compilation\", \"-version\")\n+        ProcessTools.executeTestJava(\"--add-modules=jdk.incubator.vector\", \"-XX:+UnlockExperimentalVMOptions\",\n+                                     \"-XX:-EnableVectorSupport\", \"-Xlog:compilation\", \"-version\")\n@@ -68,2 +68,2 @@\n-        ProcessTools.executeTestJvm(\"--add-modules=jdk.incubator.vector\", \"-XX:+UnlockExperimentalVMOptions\",\n-                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n+        ProcessTools.executeTestJava(\"--add-modules=jdk.incubator.vector\", \"-XX:+UnlockExperimentalVMOptions\",\n+                                     \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorReboxing\", \"-Xlog:compilation\", \"-version\")\n@@ -75,2 +75,2 @@\n-        ProcessTools.executeTestJvm(\"--add-modules=jdk.incubator.vector\", \"-XX:+UnlockExperimentalVMOptions\",\n-                                    \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n+        ProcessTools.executeTestJava(\"--add-modules=jdk.incubator.vector\", \"-XX:+UnlockExperimentalVMOptions\",\n+                                     \"-XX:-EnableVectorSupport\", \"-XX:+EnableVectorAggressiveReboxing\", \"-Xlog:compilation\", \"-version\")\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorErgonomics.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-        ProcessTools.executeTestJvm(\"-Xms\" + Xms, \"-Xmx\" + Xmx,\n-                                    \"-XX:+PrintFlagsFinal\", \"-version\")\n+        ProcessTools.executeTestJava(\"-Xms\" + Xms, \"-Xmx\" + Xmx,\n+                                     \"-XX:+PrintFlagsFinal\", \"-version\")\n@@ -51,3 +51,3 @@\n-        ProcessTools.executeTestJvm(\"-Xms\" + Xms, \"-Xmx\" + Xmx,\n-                                    \"-XX:SoftMaxHeapSize=\" + Xms,\n-                                    \"-XX:+PrintFlagsFinal\", \"-version\")\n+        ProcessTools.executeTestJava(\"-Xms\" + Xms, \"-Xmx\" + Xmx,\n+                                     \"-XX:SoftMaxHeapSize=\" + Xms,\n+                                     \"-XX:+PrintFlagsFinal\", \"-version\")\n@@ -58,3 +58,3 @@\n-        ProcessTools.executeTestJvm(\"-Xms\" + Xms, \"-Xmx\" + Xmx,\n-                                    \"-XX:SoftMaxHeapSize=\" + betweenXmsAndXmx,\n-                                    \"-XX:+PrintFlagsFinal\", \"-version\")\n+        ProcessTools.executeTestJava(\"-Xms\" + Xms, \"-Xmx\" + Xmx,\n+                                     \"-XX:SoftMaxHeapSize=\" + betweenXmsAndXmx,\n+                                     \"-XX:+PrintFlagsFinal\", \"-version\")\n@@ -65,3 +65,3 @@\n-        ProcessTools.executeTestJvm(\"-Xms\" + Xms, \"-Xmx\" + Xmx,\n-                                    \"-XX:SoftMaxHeapSize=\" + Xmx,\n-                                    \"-XX:+PrintFlagsFinal\", \"-version\")\n+        ProcessTools.executeTestJava(\"-Xms\" + Xms, \"-Xmx\" + Xmx,\n+                                     \"-XX:SoftMaxHeapSize=\" + Xmx,\n+                                     \"-XX:+PrintFlagsFinal\", \"-version\")\n@@ -72,3 +72,3 @@\n-        ProcessTools.executeTestJvm(\"-Xms\" + Xms, \"-Xmx\" + Xmx,\n-                                    \"-XX:SoftMaxHeapSize=\" + greaterThanXmx,\n-                                    \"-XX:+PrintFlagsFinal\", \"-version\")\n+        ProcessTools.executeTestJava(\"-Xms\" + Xms, \"-Xmx\" + Xmx,\n+                                     \"-XX:SoftMaxHeapSize=\" + greaterThanXmx,\n+                                     \"-XX:+PrintFlagsFinal\", \"-version\")\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestSoftMaxHeapSizeFlag.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-        OutputAnalyzer out = ProcessTools.executeTestJvm(options);\n+        OutputAnalyzer out = ProcessTools.executeTestJava(options);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/ihop\/TestIHOPErgo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-        OutputAnalyzer out = ProcessTools.executeTestJvm(options);\n+        OutputAnalyzer out = ProcessTools.executeTestJava(options);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/ihop\/TestIHOPStatic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        OutputAnalyzer out = ProcessTools.executeTestJvm(options);\n+        OutputAnalyzer out = ProcessTools.executeTestJava(options);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/logging\/TestG1LoggingFailure.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-        OutputAnalyzer out = ProcessTools.executeTestJvm(testOptions);\n+        OutputAnalyzer out = ProcessTools.executeTestJava(testOptions);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/plab\/TestPLABEvacuationFailure.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-            OutputAnalyzer out = ProcessTools.executeTestJvm(options);\n+            OutputAnalyzer out = ProcessTools.executeTestJava(options);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/plab\/TestPLABPromotion.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-            OutputAnalyzer out = ProcessTools.executeTestJvm(options);\n+            OutputAnalyzer out = ProcessTools.executeTestJava(options);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/plab\/TestPLABResize.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(finalArgs);\n+        OutputAnalyzer output = ProcessTools.executeTestJava(finalArgs);\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/gclocker\/TestExcessGCLockerCollections.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,9 +88,9 @@\n-        ProcessTools.executeTestJvm(\"-XX:+UseZGC\",\n-                                    \"-XX:-ZGenerational\",\n-                                    \"-XX:-ZProactive\",\n-                                    \"-Xms128M\",\n-                                    \"-Xmx128M\",\n-                                    \"-XX:ParallelGCThreads=1\",\n-                                    \"-XX:ConcGCThreads=1\",\n-                                    \"-Xlog:gc,gc+start\",\n-                                    Test.class.getName())\n+        ProcessTools.executeTestJava(\"-XX:+UseZGC\",\n+                                     \"-XX:-ZGenerational\",\n+                                     \"-XX:-ZProactive\",\n+                                     \"-Xms128M\",\n+                                     \"-Xmx128M\",\n+                                     \"-XX:ParallelGCThreads=1\",\n+                                     \"-XX:ConcGCThreads=1\",\n+                                     \"-Xlog:gc,gc+start\",\n+                                     Test.class.getName())\n","filename":"test\/hotspot\/jtreg\/gc\/x\/TestHighUsage.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(\n-                \/\/ executeTestJvm doesn't seem to forward 'java.library.path'\n+        OutputAnalyzer output = ProcessTools.executeTestJava(\n+                \/\/ executeTestJava doesn't seem to forward 'java.library.path'\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/UncaughtNativeExceptionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,5 +49,5 @@\n-            ProcessTools.executeTestJvm(\"-Dsun.boot.library.path=\" + tooLongPath,\n-                                        \"TestSunBootLibraryPath\",\n-                                        \"'Do-Nothing'\")\n-                                        .shouldNotHaveExitValue(0)\n-                                        .stdoutShouldContain(expectedErrorMessage);\n+            ProcessTools.executeTestJava(\"-Dsun.boot.library.path=\" + tooLongPath,\n+                                         \"TestSunBootLibraryPath\",\n+                                         \"'Do-Nothing'\")\n+                                         .shouldNotHaveExitValue(0)\n+                                         .stdoutShouldContain(expectedErrorMessage);\n","filename":"test\/hotspot\/jtreg\/runtime\/LoadLibrary\/TestSunBootLibraryPath.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(options);\n+        OutputAnalyzer output = ProcessTools.executeTestJava(options);\n","filename":"test\/hotspot\/jtreg\/runtime\/Shutdown\/ShutdownTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        ProcessTools.executeTestJvm(\"-Dsun.boot.library.path=\" + syspaths,\n+        ProcessTools.executeTestJava(\"-Dsun.boot.library.path=\" + syspaths,\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/FindClass\/FindClassFromBoot.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,4 +46,4 @@\n-            ProcessTools.executeTestJvm(\"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n-                                        \"-Xcheck:jni\",\n-                                        \"-XX:-CreateCoredumpOnCrash\",\n-                                        \"FindClassUtf8\")\n+            ProcessTools.executeTestJava(\"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n+                                         \"-Xcheck:jni\",\n+                                         \"-XX:-CreateCoredumpOnCrash\",\n+                                         \"FindClassUtf8\")\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/FindClassUtf8\/FindClassUtf8.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(jlp, main);\n+        OutputAnalyzer output = ProcessTools.executeTestJava(jlp, main);\n@@ -70,1 +70,1 @@\n-        output = ProcessTools.executeTestJvm(jlp, main, \"doExit\");\n+        output = ProcessTools.executeTestJava(jlp, main, \"doExit\");\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/atExit\/TestAtExit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -208,3 +208,3 @@\n-        checkOuputForCorrectWarnings(ProcessTools.executeTestJvm(\"-Xcheck:jni\",\n-                                                                 \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n-                                                                 \"TestCheckedJniExceptionCheck\"));\n+        checkOuputForCorrectWarnings(ProcessTools.executeTestJava(\"-Xcheck:jni\",\n+                                                                  \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n+                                                                  \"TestCheckedJniExceptionCheck\"));\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestCheckedJniExceptionCheck.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-            \/\/ Uses executeProcess() instead of executeTestJvm() to avoid passing options\n+            \/\/ Uses executeProcess() instead of executeTestJava() to avoid passing options\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestCheckedReleaseArrayElements.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,3 +54,3 @@\n-            ProcessTools.executeTestJvm(\"-Xcheck:jni\",\n-                                        \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n-                                        \"TestNativeStack$Main\");\n+            ProcessTools.executeTestJava(\"-Xcheck:jni\",\n+                                         \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n+                                         \"TestNativeStack$Main\");\n@@ -63,4 +63,4 @@\n-        oa = ProcessTools.executeTestJvm(\"-XX:-CreateCoredumpOnCrash\",\n-                                         \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n-                                         \"TestNativeStack$Main\",\n-                                         \"error\");\n+        oa = ProcessTools.executeTestJava(\"-XX:-CreateCoredumpOnCrash\",\n+                                          \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n+                                          \"TestNativeStack$Main\",\n+                                          \"error\");\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/nativeStack\/TestNativeStack.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -68,2 +68,2 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(\"-Djava.library.path=\" + libp,\n-                                                            Tester.class.getName());\n+        OutputAnalyzer output = ProcessTools.executeTestJava(\"-Djava.library.path=\" + libp,\n+                                                             Tester.class.getName());\n@@ -75,4 +75,4 @@\n-        output = ProcessTools.executeTestJvm(\"-Djava.library.path=\" + libp,\n-                                             \"-Xbootclasspath\/a:\" + cp,\n-                                             \"-Dsun.boot.library.path=\" + libp,\n-                                             Tester.class.getName());\n+        output = ProcessTools.executeTestJava(\"-Djava.library.path=\" + libp,\n+                                              \"-Xbootclasspath\/a:\" + cp,\n+                                              \"-Dsun.boot.library.path=\" + libp,\n+                                              Tester.class.getName());\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/registerNativesWarning\/TestRegisterNativesWarning.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-        this.thpEligible = Integer.parseInt(thpEligible) == 1;\n+        this.thpEligible = thpEligible == null ? false : (Integer.parseInt(thpEligible) == 1);\n@@ -368,3 +368,3 @@\n-        \/\/ When the THP policy is 'always' instead of 'madvise, the vmFlagHG property is false.\n-        \/\/ Check the THPeligible property instead.\n-        isTHP = !vmFlagHT && this.thpEligible;\n+        \/\/ When the THP policy is 'always' instead of 'madvise, the vmFlagHG property is false,\n+        \/\/ therefore also check thpEligible. If this is still causing problems in the future,\n+        \/\/ we might have to check the AnonHugePages field.\n@@ -372,2 +372,1 @@\n-        \/\/ vmFlagHG should imply isTHP\n-        assert !vmFlagHG || isTHP;\n+        isTHP = vmFlagHG || this.thpEligible;\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTracePageSizes.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(subargs);\n+        OutputAnalyzer output = ProcessTools.executeTestJava(subargs);\n","filename":"test\/hotspot\/jtreg\/runtime\/stringtable\/StringTableCleaningTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-            ProcessTools.executeTestJvm(flag)\n+            ProcessTools.executeTestJava(flag)\n","filename":"test\/hotspot\/jtreg\/sanity\/BasicVMTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-        OutputAnalyzer oa = ProcessTools.executeTestJvm(\"-javaagent:\" +\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(\"-javaagent:\" +\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/TestLambdaFormRetransformation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(\n+        OutputAnalyzer output = ProcessTools.executeTestJava(\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/TestRedefineWithUnresolvedClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -34,0 +35,1 @@\n+ * @library \/test\/lib\n@@ -38,1 +40,0 @@\n-import java.util.concurrent.CountDownLatch;\n@@ -42,0 +43,1 @@\n+import jdk.test.lib.thread.VThreadPinner;\n@@ -78,1 +80,1 @@\n-        var latch = new CountDownLatch(1);\n+        var started = new AtomicBoolean();\n@@ -81,1 +83,1 @@\n-            latch.countDown();\n+            started.set(true);\n@@ -90,1 +92,1 @@\n-            latch.await();\n+            awaitTrue(started);\n@@ -110,1 +112,1 @@\n-        var latch = new CountDownLatch(1);\n+        var started = new AtomicBoolean();\n@@ -113,1 +115,1 @@\n-            latch.countDown();\n+            started.set(true);\n@@ -120,1 +122,1 @@\n-                latch.await();\n+                awaitTrue(started);\n@@ -140,1 +142,1 @@\n-        var latch = new CountDownLatch(1);\n+        var started = new AtomicBoolean();\n@@ -144,1 +146,1 @@\n-                latch.countDown();\n+                started.set(true);\n@@ -151,2 +153,2 @@\n-            \/\/ wait for thread to own monitor\n-            latch.await();\n+            \/\/ wait for thread to start execution\n+            awaitTrue(started);\n@@ -182,1 +184,1 @@\n-        var latch = new CountDownLatch(1);\n+        var started = new AtomicBoolean();\n@@ -186,1 +188,1 @@\n-                latch.countDown();\n+                started.set(true);\n@@ -193,2 +195,2 @@\n-            \/\/ wait for thread to own monitor\n-            latch.await();\n+            \/\/ wait for thread to start execution\n+            awaitTrue(started);\n@@ -224,1 +226,1 @@\n-        var latch = new CountDownLatch(1);\n+        var started = new AtomicBoolean();\n@@ -227,1 +229,1 @@\n-            latch.countDown();\n+            started.set(true);\n@@ -234,1 +236,1 @@\n-            latch.await();\n+            awaitTrue(started);\n@@ -254,1 +256,1 @@\n-        var latch = new CountDownLatch(1);\n+        var started = new AtomicBoolean();\n@@ -257,1 +259,1 @@\n-            latch.countDown();\n+            started.set(true);\n@@ -264,1 +266,1 @@\n-            latch.await();\n+            awaitTrue(started);\n@@ -284,2 +286,1 @@\n-        var latch = new CountDownLatch(1);\n-        Object lock = new Object();\n+        var started = new AtomicBoolean();\n@@ -288,2 +289,2 @@\n-            synchronized (lock) {\n-                latch.countDown();\n+            VThreadPinner.runPinned(() -> {\n+                started.set(true);\n@@ -293,1 +294,1 @@\n-            }\n+            });\n@@ -296,2 +297,2 @@\n-            \/\/ wait for thread to own monitor\n-            latch.await();\n+            \/\/ wait for thread to start execution\n+            awaitTrue(started);\n@@ -317,2 +318,1 @@\n-        var latch = new CountDownLatch(1);\n-        Object lock = new Object();\n+        var started = new AtomicBoolean();\n@@ -321,2 +321,2 @@\n-            synchronized (lock) {\n-                latch.countDown();\n+            VThreadPinner.runPinned(() -> {\n+                started.set(true);\n@@ -326,1 +326,1 @@\n-            }\n+            });\n@@ -329,2 +329,2 @@\n-            \/\/ wait for thread to own monitor\n-            latch.await();\n+            \/\/ wait for thread to start execution\n+            awaitTrue(started);\n@@ -345,0 +345,9 @@\n+    \/**\n+     * Waits for the boolean value to become true.\n+     *\/\n+    private static void awaitTrue(AtomicBoolean ref) throws Exception {\n+        while (!ref.get()) {\n+            Thread.sleep(20);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetThreadState\/GetThreadStateTest.java","additions":44,"deletions":35,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        OutputAnalyzer oa = ProcessTools.executeTestJvm(\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Agent_OnUnload\/agentonunload001\/TestDriver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        OutputAnalyzer oa = ProcessTools.executeTestJvm(\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(\n@@ -47,1 +47,1 @@\n-        oa = ProcessTools.executeTestJvm(\n+        oa = ProcessTools.executeTestJava(\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/general_functions\/GF08\/gf08t.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-        OutputAnalyzer oa = ProcessTools.executeTestJvm(\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/multienv\/MA02\/ma02t001\/TestDriver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package stream.XMLStreamExceptionTest;\n+\n+import java.io.IOException;\n+\n+import javax.xml.stream.Location;\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Listeners;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/javax\/xml\/jaxp\/libs \/javax\/xml\/jaxp\/unittest\n+ * @run testng\/othervm -DrunSecMngr=true -Djava.security.manager=allow stream.XMLStreamExceptionTest.ExceptionCauseTest\n+ * @run testng\/othervm stream.XMLStreamExceptionTest.ExceptionCauseTest\n+ * @summary Test XMLStreamException constructor initializes chained exception\n+ *\/\n+@Listeners({jaxp.library.BasePolicy.class})\n+public class ExceptionCauseTest {\n+\n+    @Test\n+    public void testExceptionCause() {\n+\n+        \/\/ Create exception with cause\n+        Throwable cause = new Throwable(\"cause\");\n+        Location location = new Location() {\n+            public int getLineNumber() { return 0; }\n+            public int getColumnNumber() { return 0; }\n+            public int getCharacterOffset() { return 0; }\n+            public String getPublicId() { return null; }\n+            public String getSystemId() { return null; }\n+        };\n+        XMLStreamException e = new XMLStreamException(\"message\", location, cause);\n+\n+        \/\/ Verify cause\n+        Assert.assertSame(e.getCause(), cause, \"XMLStreamException has the wrong cause\");\n+    }\n+}\n","filename":"test\/jaxp\/javax\/xml\/jaxp\/unittest\/stream\/XMLStreamExceptionTest\/ExceptionCauseTest.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(\"-agentpath:\/badAgent\/agent\", \"-version\");\n+        OutputAnalyzer output = ProcessTools.executeTestJava(\"-agentpath:\/badAgent\/agent\", \"-version\");\n","filename":"test\/jdk\/com\/sun\/jdi\/BadAgentPath.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(\"-classpath\",\n+        OutputAnalyzer output = ProcessTools.executeTestJava(\"-classpath\",\n","filename":"test\/jdk\/com\/sun\/jdi\/DoubleAgentTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(\n+        OutputAnalyzer output = ProcessTools.executeTestJava(\n@@ -59,1 +59,1 @@\n-        output = ProcessTools.executeTestJvm(\n+        output = ProcessTools.executeTestJava(\n","filename":"test\/jdk\/com\/sun\/jdi\/OnJcmdTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(\"-classpath\",\n+        OutputAnalyzer output = ProcessTools.executeTestJava(\"-classpath\",\n","filename":"test\/jdk\/com\/sun\/jdi\/SuspendNoFlagTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(args);\n+        OutputAnalyzer output = ProcessTools.executeTestJava(args);\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/BasicTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(args);\n+        OutputAnalyzer output = ProcessTools.executeTestJava(args);\n@@ -101,1 +101,1 @@\n-        output = ProcessTools.executeTestJvm(args);\n+        output = ProcessTools.executeTestJava(args);\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/PermissionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(args);\n+        OutputAnalyzer output = ProcessTools.executeTestJava(args);\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/ProviderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(args);\n+        OutputAnalyzer output = ProcessTools.executeTestJava(args);\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/TempDirTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8320971\n+ * @summary Verify BufferedInputStream.buf is used directly by\n+ *          BufferedInputStream.implTransferTo() only when its OutputStream\n+ *          parameter is trusted\n+ * @key randomness\n+ * @run main\/othervm --add-opens=java.base\/java.io=ALL-UNNAMED TransferToTrusted\n+ *\/\n+public class TransferToTrusted {\n+\n+    private static final Random RND = new Random(System.nanoTime());\n+\n+    private static final class UntrustedOutputStream extends OutputStream {\n+\n+        UntrustedOutputStream() {\n+            super();\n+        }\n+\n+        @Override\n+        public void write(byte[] b, int off, int len) {\n+            Objects.checkFromIndexSize(off, len, b.length);\n+            byte[] tmp = new byte[len];\n+            RND.nextBytes(tmp);\n+            System.arraycopy(tmp, 0, b, off, len);\n+        }\n+\n+        @Override\n+        public void write(int b) throws IOException {\n+            write(new byte[]{(byte) b});\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        final int length = 128;\n+        byte[] buf = new byte[length];\n+        RND.nextBytes(buf);\n+\n+        var outputStreams = new OutputStream[]{\n+                new ByteArrayOutputStream(),\n+                new FileOutputStream(File.createTempFile(TransferToTrusted.class.getName(), null)),\n+                new PipedOutputStream(new PipedInputStream(length)),\n+                new UntrustedOutputStream()\n+        };\n+\n+        for (var out : outputStreams) {\n+            System.err.println(\"out: \" + out.getClass().getName());\n+\n+            var bis = new BufferedInputStream(new ByteArrayInputStream(buf.clone()));\n+            try (out; bis) {\n+                bis.read();\/\/need this to fill the BIS.buf in\n+                bis.transferTo(out);\n+                var internalBuffer = bis.getClass().getDeclaredField(\"buf\");\n+                internalBuffer.setAccessible(true);\n+                if (!Arrays.equals(buf, Arrays.copyOf((byte[]) internalBuffer.get(bis), length))) {\n+                    throw new RuntimeException(\"Internal buffer was modified\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/BufferedInputStream\/TransferToTrusted.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -127,1 +127,1 @@\n-       ProcessTools.executeTestJvm(options).shouldContain(WARNING)\n+       ProcessTools.executeTestJava(options).shouldContain(WARNING)\n@@ -134,1 +134,1 @@\n-        ProcessTools.executeTestJvm(options).shouldNotContain(WARNING)\n+        ProcessTools.executeTestJava(options).shouldNotContain(WARNING)\n@@ -141,1 +141,1 @@\n-        OutputAnalyzer originalOutput = ProcessTools.executeTestJvm(options);\n+        OutputAnalyzer originalOutput = ProcessTools.executeTestJava(options);\n","filename":"test\/jdk\/java\/io\/File\/TempDirDoesNotExist.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        ProcessTools.executeTestJvm(\"-Djava.security.manager\",\n+        ProcessTools.executeTestJava(\"-Djava.security.manager\",\n","filename":"test\/jdk\/java\/io\/FilePermission\/MergeName.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        ProcessTools.executeTestJvm(cmds.toArray(new String[cmds.size()]))\n+        ProcessTools.executeTestJava(cmds.toArray(new String[cmds.size()]))\n","filename":"test\/jdk\/java\/io\/FilePermission\/ReadFileOnPath.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-        String out = ProcessTools.executeTestJvm(safeArgs).getOutput();\n+        String out = ProcessTools.executeTestJava(safeArgs).getOutput();\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/securityManager\/ClassLoaderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-        ProcessTools.executeTestJvm(testCommand).shouldHaveExitValue(0);\n+        ProcessTools.executeTestJava(testCommand).shouldHaveExitValue(0);\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/shutdown\/ShutdownHooks.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    static final long DURATION_IN_NANOS = Duration.ofMinutes(2).toNanos();\n+    static final long DURATION_IN_NANOS = Duration.ofMinutes(1).toNanos();\n","filename":"test\/jdk\/java\/lang\/ScopedValue\/StressStackOverflow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import java.util.concurrent.CountDownLatch;\n@@ -58,0 +57,2 @@\n+            var vthreadRef = new AtomicReference<Thread>();\n+\n@@ -60,1 +61,5 @@\n-                    carrierRef.set(Thread.currentThread());\n+                    Thread carrier = Thread.currentThread();\n+                    carrierRef.set(carrier);\n+                    Thread vthread = vthreadRef.get();\n+\n+                    System.err.format(\"%s run task (%s) ...%n\", carrier, vthread);\n@@ -62,0 +67,1 @@\n+                    System.err.format(\"%s task done (%s)%n\", carrier, vthread);\n@@ -66,1 +72,1 @@\n-            var latch = new CountDownLatch(1);\n+            var started = new AtomicBoolean();\n@@ -69,2 +75,2 @@\n-            Thread vthread = builder.start(() -> {\n-                latch.countDown();\n+            Thread vthread = builder.unstarted(() -> {\n+                started.set(true);\n@@ -75,3 +81,2 @@\n-\n-            \/\/ wait for virtual thread to execute\n-            latch.await();\n+            vthreadRef.set(vthread);\n+            vthread.start();\n@@ -80,1 +85,8 @@\n-                long carrierId = carrierRef.get().threadId();\n+                \/\/ wait for virtual thread to start\n+                while (!started.get()) {\n+                    Thread.sleep(10);\n+                }\n+\n+                Thread carrier = carrierRef.get();\n+\n+                long carrierId = carrier.threadId();\n@@ -85,5 +97,7 @@\n-                assertTrue(ti.getThreadState() == Thread.State.WAITING);\n-                assertEquals(vthread.getClass().getName(), ti.getLockInfo().getClassName());\n-                assertTrue(ti.getLockInfo().getIdentityHashCode() == System.identityHashCode(vthread));\n-                assertTrue(ti.getLockOwnerId() == vthreadId);\n-\n+                Thread.State state = ti.getThreadState();\n+                LockInfo lockInfo = ti.getLockInfo();\n+                assertEquals(Thread.State.WAITING, state);\n+                assertNotNull(lockInfo);\n+                assertEquals(vthread.getClass().getName(), lockInfo.getClassName());\n+                assertEquals(System.identityHashCode(vthread), lockInfo.getIdentityHashCode());\n+                assertEquals(vthreadId, ti.getLockOwnerId());\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CarrierThreadWaits.java","additions":28,"deletions":14,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import java.nio.channels.ClosedSelectorException;\n-import java.nio.channels.Selector;\n@@ -35,0 +33,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -40,1 +39,0 @@\n-        try (Selector sel = Selector.open()) {\n@@ -42,5 +40,5 @@\n-            \/\/ start thread1 and wait for it to park\n-            Thread thread1 = Thread.startVirtualThread(LockSupport::park);\n-            while (thread1.getState() != Thread.State.WAITING) {\n-                Thread.sleep(20);\n-            }\n+        \/\/ start thread1 and wait for it to park\n+        Thread thread1 = Thread.startVirtualThread(LockSupport::park);\n+        while (thread1.getState() != Thread.State.WAITING) {\n+            Thread.sleep(20);\n+        }\n@@ -48,13 +46,14 @@\n-            \/\/ start thread2 to pin the carrier thread\n-            CountDownLatch latch = new CountDownLatch(1);\n-            Thread thread2 = Thread.startVirtualThread(() -> {\n-                latch.countDown();\n-                try {\n-                    sel.select();\n-                } catch (ClosedSelectorException e) {\n-                    \/\/ expected\n-                } catch (IOException ioe) {\n-                    ioe.printStackTrace();\n-                }\n-            });\n-            latch.await();   \/\/ wait for thread2 to run\n+        \/\/ start thread2 to pin the carrier thread\n+        var started = new AtomicBoolean();\n+        var done = new AtomicBoolean();\n+        Thread thread2 = Thread.startVirtualThread(() -> {\n+            started.set(true);\n+            while (!done.get()) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread2 to start\n+            while (!started.get()) {\n+                Thread.sleep(10);\n+            }\n@@ -76,0 +75,4 @@\n+        } finally {\n+            done.set(true);\n+            thread2.join();\n+            thread1.join();\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/GetStackTraceWhenRunnable.java","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n- * @run junit\/othervm JfrEvents\n+ * @library \/test\/lib\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED JfrEvents\n@@ -34,1 +35,0 @@\n-import java.time.Duration;\n@@ -42,0 +42,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -44,0 +45,1 @@\n+import java.util.function.Consumer;\n@@ -45,0 +47,1 @@\n+import java.util.stream.Stream;\n@@ -51,0 +54,2 @@\n+import jdk.test.lib.thread.VThreadPinner;\n+import jdk.test.lib.thread.VThreadRunner.ThrowingRunnable;\n@@ -52,0 +57,3 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -55,1 +63,0 @@\n-    private static final Object lock = new Object();\n@@ -88,0 +95,49 @@\n+    \/**\n+     * Arguments for testVirtualThreadPinned to test jdk.VirtualThreadPinned event.\n+     *   [0] label\/description\n+     *   [1] the operation to park\/wait\n+     *   [2] the Thread.State when parked\/waiting\n+     *   [3] the action to unpark\/notify the thread\n+     *\/\n+    static Stream<Arguments> pinnedCases() {\n+        Object lock = new Object();\n+\n+        \/\/ park with native frame on stack\n+        var finish1 = new AtomicBoolean();\n+        var parkWhenPinned = Arguments.of(\n+            \"LockSupport.park when pinned\",\n+            (ThrowingRunnable<Exception>) () -> {\n+                VThreadPinner.runPinned(() -> {\n+                    while (!finish1.get()) {\n+                        LockSupport.park();\n+                    }\n+                });\n+            },\n+            Thread.State.WAITING,\n+                (Consumer<Thread>) t -> {\n+                    finish1.set(true);\n+                    LockSupport.unpark(t);\n+                }\n+        );\n+\n+        \/\/ timed park with native frame on stack\n+        var finish2 = new AtomicBoolean();\n+        var timedParkWhenPinned = Arguments.of(\n+            \"LockSupport.parkNanos when pinned\",\n+            (ThrowingRunnable<Exception>) () -> {\n+                VThreadPinner.runPinned(() -> {\n+                    while (!finish2.get()) {\n+                        LockSupport.parkNanos(Long.MAX_VALUE);\n+                    }\n+                });\n+            },\n+            Thread.State.TIMED_WAITING,\n+            (Consumer<Thread>) t -> {\n+                finish2.set(true);\n+                LockSupport.unpark(t);\n+            }\n+        );\n+\n+        return Stream.of(parkWhenPinned, timedParkWhenPinned);\n+    }\n+\n@@ -91,6 +147,6 @@\n-    @Test\n-    void testVirtualThreadPinned() throws Exception {\n-        Runnable[] parkers = new Runnable[] {\n-            () -> LockSupport.park(),\n-            () -> LockSupport.parkNanos(Duration.ofDays(1).toNanos())\n-        };\n+    @ParameterizedTest\n+    @MethodSource(\"pinnedCases\")\n+    void testVirtualThreadPinned(String label,\n+                                 ThrowingRunnable<Exception> parker,\n+                                 Thread.State expectedState,\n+                                 Consumer<Thread> unparker) throws Exception {\n@@ -102,16 +158,3 @@\n-            try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n-                for (Runnable parker : parkers) {\n-                    \/\/ execute parking task in virtual thread\n-                    var threadRef = new AtomicReference<Thread>();\n-                    executor.submit(() -> {\n-                        threadRef.set(Thread.currentThread());\n-                        synchronized (lock) {\n-                            parker.run();   \/\/ should pin carrier\n-                        }\n-                    });\n-\n-                    \/\/ wait for the task to start and the virtual thread to park\n-                    Thread thread;\n-                    while ((thread = threadRef.get()) == null) {\n-                        Thread.sleep(10);\n-                    }\n+            try {\n+                var exception = new AtomicReference<Throwable>();\n+                var thread = Thread.ofVirtual().start(() -> {\n@@ -119,7 +162,12 @@\n-                        Thread.State state = thread.getState();\n-                        while (state != Thread.State.WAITING && state != Thread.State.TIMED_WAITING) {\n-                            Thread.sleep(10);\n-                            state = thread.getState();\n-                        }\n-                    } finally {\n-                        LockSupport.unpark(thread);\n+                        parker.run();\n+                    } catch (Throwable e) {\n+                        exception.set(e);\n+                    }\n+                });\n+                try {\n+                    \/\/ wait for thread to park\/wait\n+                    Thread.State state = thread.getState();\n+                    while (state != expectedState) {\n+                        assertTrue(state != Thread.State.TERMINATED, thread.toString());\n+                        Thread.sleep(10);\n+                        state = thread.getState();\n@@ -127,0 +175,4 @@\n+                } finally {\n+                    unparker.accept(thread);\n+                    thread.join();\n+                    assertNull(exception.get());\n@@ -135,1 +187,1 @@\n-            \/\/ should have a pinned event for each park\n+            \/\/ should have at least one pinned event\n@@ -137,1 +189,1 @@\n-            assertEquals(parkers.length, pinnedCount);\n+            assertTrue(pinnedCount >= 1, \"Expected one or more events\");\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/JfrEvents.java","additions":86,"deletions":34,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test virtual threads using Object.wait\/notifyAll\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run junit MonitorWaitNotify\n+ *\/\n+\n+import java.util.concurrent.Semaphore;\n+\n+import jdk.test.lib.thread.VThreadRunner;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class MonitorWaitNotify {\n+\n+    \/**\n+     * Test virtual thread waits, notified by platform thread.\n+     *\/\n+    @Test\n+    void testWaitNotify1() throws Exception {\n+        var lock = new Object();\n+        var ready = new Semaphore(0);\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                ready.release();\n+                try {\n+                    lock.wait();\n+                } catch (InterruptedException e) { }\n+            }\n+        });\n+        \/\/ thread invokes notify\n+        ready.acquire();\n+        synchronized (lock) {\n+            lock.notifyAll();\n+        }\n+        thread.join();\n+    }\n+\n+    \/**\n+     * Test platform thread waits, notified by virtual thread.\n+     *\/\n+    @Test\n+    void testWaitNotify2() throws Exception {\n+        var lock = new Object();\n+        var ready = new Semaphore(0);\n+        var thread = Thread.ofVirtual().start(() -> {\n+            ready.acquireUninterruptibly();\n+            synchronized (lock) {\n+                lock.notifyAll();\n+            }\n+        });\n+        synchronized (lock) {\n+            ready.release();\n+            lock.wait();\n+        }\n+        thread.join();\n+    }\n+\n+    \/**\n+     * Test virtual thread waits, notified by another virtual thread.\n+     *\/\n+    @Test\n+    void testWaitNotify3() throws Exception {\n+        \/\/ need at least two carrier threads due to pinning\n+        int previousParallelism = VThreadRunner.ensureParallelism(2);\n+        try {\n+            var lock = new Object();\n+            var ready = new Semaphore(0);\n+            var thread1 = Thread.ofVirtual().start(() -> {\n+                synchronized (lock) {\n+                    ready.release();\n+                    try {\n+                        lock.wait();\n+                    } catch (InterruptedException e) { }\n+                }\n+            });\n+            var thread2 = Thread.ofVirtual().start(() -> {\n+                ready.acquireUninterruptibly();\n+                synchronized (lock) {\n+                    lock.notifyAll();\n+                }\n+            });\n+            thread1.join();\n+            thread2.join();\n+        } finally {\n+            \/\/ restore\n+            VThreadRunner.setParallelism(previousParallelism);\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupt status set when calling Object.wait.\n+     *\/\n+    @Test\n+    void testWaitNotify4() throws Exception {\n+        VThreadRunner.run(() -> {\n+            Thread t = Thread.currentThread();\n+            t.interrupt();\n+            Object lock = new Object();\n+            synchronized (lock) {\n+                try {\n+                    lock.wait();\n+                    fail();\n+                } catch (InterruptedException e) {\n+                    \/\/ interrupt status should be cleared\n+                    assertFalse(t.isInterrupted());\n+                }\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test interrupt when blocked in Object.wait.\n+     *\/\n+    @Test\n+    void testWaitNotify5() throws Exception {\n+        VThreadRunner.run(() -> {\n+            Thread t = Thread.currentThread();\n+            scheduleInterrupt(t, 1000);\n+            Object lock = new Object();\n+            synchronized (lock) {\n+                try {\n+                    lock.wait();\n+                    fail();\n+                } catch (InterruptedException e) {\n+                    \/\/ interrupt status should be cleared\n+                    assertFalse(t.isInterrupted());\n+                }\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Schedule a thread to be interrupted after a delay.\n+     *\/\n+    private static void scheduleInterrupt(Thread thread, long delay) {\n+        Runnable interruptTask = () -> {\n+            try {\n+                Thread.sleep(delay);\n+                thread.interrupt();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        };\n+        new Thread(interruptTask).start();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorWaitNotify.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary Test stack traces in exceptions and stack frames waslked by the StackWalker\n+ * @summary Test stack traces in exceptions and stack frames walked by the StackWalker\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/StackTraces.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run junit ThreadAPI\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED ThreadAPI\n@@ -38,1 +38,2 @@\n- * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations ThreadAPI\n+ * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations\n+ *     --enable-native-access=ALL-UNNAMED ThreadAPI\n@@ -64,0 +65,1 @@\n+import jdk.test.lib.thread.VThreadPinner;\n@@ -700,1 +702,1 @@\n-            synchronized (lock) {\n+            VThreadPinner.runPinned(() -> {\n@@ -704,1 +706,1 @@\n-            }\n+            });\n@@ -1081,1 +1083,1 @@\n-     * Test Thread.yield releases thread when not pinned.\n+     * Test Thread.yield releases carrier thread.\n@@ -1109,1 +1111,1 @@\n-     * Test Thread.yield when thread is pinned.\n+     * Test Thread.yield when thread is pinned by native frame.\n@@ -1124,1 +1126,1 @@\n-                synchronized (lock) {\n+                VThreadPinner.runPinned(() -> {\n@@ -1127,1 +1129,1 @@\n-                }\n+                });\n@@ -1137,1 +1139,1 @@\n-     * Test that Thread.yield does not consume the thread's parking permit.\n+     * Test Thread.yield does not consume the thread's parking permit.\n@@ -1150,1 +1152,1 @@\n-     * Test that Thread.yield does not make available the thread's parking permit.\n+     * Test Thread.yield does not make available the thread's parking permit.\n@@ -1351,1 +1353,1 @@\n-        VThreadRunner.run(() -> {\n+        VThreadPinner.runPinned(() -> {\n@@ -1353,3 +1355,1 @@\n-            synchronized (lock) {\n-                Thread.sleep(1000);\n-            }\n+            Thread.sleep(1000);\n@@ -1369,1 +1369,1 @@\n-                synchronized (lock) {\n+                VThreadPinner.runPinned(() -> {\n@@ -1371,1 +1371,1 @@\n-                }\n+                });\n@@ -1389,1 +1389,1 @@\n-                synchronized (lock) {\n+                VThreadPinner.runPinned(() -> {\n@@ -1391,1 +1391,1 @@\n-                }\n+                });\n@@ -1524,2 +1524,1 @@\n-        var exception = new AtomicReference<Throwable>();\n-        Thread.UncaughtExceptionHandler handler = (thread, exc) -> exception.set(exc);\n+        var handler = new CapturingUHE();\n@@ -1534,1 +1533,2 @@\n-        assertTrue(exception.get() instanceof FooException);\n+        assertInstanceOf(FooException.class, handler.exception());\n+        assertEquals(thread, handler.thread());\n@@ -1544,2 +1544,1 @@\n-        var exception = new AtomicReference<Throwable>();\n-        Thread.UncaughtExceptionHandler handler = (thread, exc) -> exception.set(exc);\n+        var handler = new CapturingUHE();\n@@ -1556,1 +1555,1 @@\n-            Thread.setDefaultUncaughtExceptionHandler(savedHandler);\n+            Thread.setDefaultUncaughtExceptionHandler(savedHandler);  \/\/ restore\n@@ -1558,1 +1557,2 @@\n-        assertTrue(exception.get() instanceof FooException);\n+        assertInstanceOf(FooException.class, handler.exception());\n+        assertEquals(thread, handler.thread());\n@@ -1563,1 +1563,1 @@\n-     * Test no UncaughtExceptionHandler set.\n+     * Test Thread and default UncaughtExceptionHandler set.\n@@ -1568,4 +1568,20 @@\n-        Thread thread = Thread.ofVirtual().start(() -> {\n-            throw new FooException();\n-        });\n-        thread.join();\n+        var defaultHandler = new CapturingUHE();\n+        var threadHandler = new CapturingUHE();\n+        Thread.UncaughtExceptionHandler savedHandler = Thread.getDefaultUncaughtExceptionHandler();\n+        Thread.setDefaultUncaughtExceptionHandler(defaultHandler);\n+        Thread thread;\n+        try {\n+            thread = Thread.ofVirtual().start(() -> {\n+                Thread me = Thread.currentThread();\n+                assertTrue(me.getUncaughtExceptionHandler() == me.getThreadGroup());\n+                me.setUncaughtExceptionHandler(threadHandler);\n+                assertTrue(me.getUncaughtExceptionHandler() == threadHandler);\n+                throw new FooException();\n+            });\n+            thread.join();\n+        } finally {\n+            Thread.setDefaultUncaughtExceptionHandler(savedHandler);  \/\/ restore\n+        }\n+        assertInstanceOf(FooException.class, threadHandler.exception());\n+        assertNull(defaultHandler.exception());\n+        assertEquals(thread, threadHandler.thread());\n@@ -1575,0 +1591,19 @@\n+    \/**\n+     * Test no Thread or default UncaughtExceptionHandler set.\n+     *\/\n+    @Test\n+    void testUncaughtExceptionHandler4() throws Exception {\n+        Thread.UncaughtExceptionHandler savedHandler = Thread.getDefaultUncaughtExceptionHandler();\n+        Thread.setDefaultUncaughtExceptionHandler(null);\n+        try {\n+            class FooException extends RuntimeException { }\n+            Thread thread = Thread.ofVirtual().start(() -> {\n+                throw new FooException();\n+            });\n+            thread.join();\n+            assertNull(thread.getUncaughtExceptionHandler());\n+        } finally {\n+            Thread.setDefaultUncaughtExceptionHandler(savedHandler);\n+        }\n+    }\n+\n@@ -2009,1 +2044,1 @@\n-     * Test Thread::getStackTrace on terminated thread.\n+     * Test Thread::getStackTrace on timed-parked thread.\n@@ -2013,0 +2048,66 @@\n+        var thread = Thread.ofVirtual().start(() -> {\n+            LockSupport.parkNanos(Long.MAX_VALUE);\n+        });\n+        await(thread, Thread.State.TIMED_WAITING);\n+        try {\n+            StackTraceElement[] stack = thread.getStackTrace();\n+            assertTrue(contains(stack, \"LockSupport.parkNanos\"));\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Thread::getStackTrace on parked thread that is pinned.\n+     *\/\n+    @Test\n+    void testGetStackTrace7() throws Exception {\n+        AtomicBoolean done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            VThreadPinner.runPinned(() -> {\n+                while (!done.get()) {\n+                    LockSupport.park();\n+                }\n+            });\n+        });\n+        await(thread, Thread.State.WAITING);\n+        try {\n+            StackTraceElement[] stack = thread.getStackTrace();\n+            assertTrue(contains(stack, \"LockSupport.park\"));\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Thread::getStackTrace on timed-parked thread that is pinned.\n+     *\/\n+    @Test\n+    void testGetStackTrace8() throws Exception {\n+        AtomicBoolean done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            VThreadPinner.runPinned(() -> {\n+                while (!done.get()) {\n+                    LockSupport.parkNanos(Long.MAX_VALUE);\n+                }\n+            });\n+        });\n+        await(thread, Thread.State.TIMED_WAITING);\n+        try {\n+            StackTraceElement[] stack = thread.getStackTrace();\n+            assertTrue(contains(stack, \"LockSupport.parkNanos\"));\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Thread::getStackTrace on terminated thread.\n+     *\/\n+    @Test\n+    void testGetStackTrace9() throws Exception {\n@@ -2179,1 +2280,1 @@\n-            assertTrue(n == 0);\n+            assertFalse(Arrays.stream(threads, 0, n).anyMatch(Thread::isVirtual));\n@@ -2292,0 +2393,27 @@\n+    \/**\n+     * Thread.UncaughtExceptionHandler that captures the first exception thrown.\n+     *\/\n+    private static class CapturingUHE implements Thread.UncaughtExceptionHandler {\n+        Thread thread;\n+        Throwable exception;\n+        @Override\n+        public void uncaughtException(Thread t, Throwable e) {\n+            synchronized (this) {\n+                if (thread == null) {\n+                    this.thread = t;\n+                    this.exception = e;\n+                }\n+            }\n+        }\n+        Thread thread() {\n+            synchronized (this) {\n+                return thread;\n+            }\n+        }\n+        Throwable exception() {\n+            synchronized (this) {\n+                return exception;\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":160,"deletions":32,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -29,1 +30,1 @@\n- * @run junit VirtualThreadPinnedEventThrows\n+ * @run junit\/othervm --enable-native-access=ALL-UNNAMED VirtualThreadPinnedEventThrows\n@@ -34,0 +35,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -37,0 +39,1 @@\n+import jdk.test.lib.thread.VThreadPinner;\n@@ -85,1 +88,13 @@\n-        Object lock = new Object();\n+        var exception = new AtomicReference<Throwable>();\n+        var done = new AtomicBoolean();\n+        Thread thread = Thread.startVirtualThread(() -> {\n+            try {\n+                VThreadPinner.runPinned(() -> {\n+                    while (!done.get()) {\n+                        LockSupport.park();\n+                    }\n+                });\n+            } catch (Throwable e) {\n+                exception.set(e);\n+            }\n+        });\n@@ -87,8 +102,0 @@\n-            var completed = new AtomicBoolean();\n-            Thread thread = Thread.startVirtualThread(() -> {\n-                synchronized (lock) {\n-                    LockSupport.park();\n-                    completed.set(true);\n-                }\n-            });\n-\n@@ -101,2 +108,2 @@\n-\n-            \/\/ unpark and check that thread completed without exception\n+        } finally {\n+            done.set(true);\n@@ -105,3 +112,0 @@\n-            assertTrue(completed.get());\n-        } finally {\n-            Reference.reachabilityFence(lock);\n@@ -109,0 +113,1 @@\n+        assertNull(exception.get());\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/VirtualThreadPinnedEventThrows.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1,163 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Test virtual threads using Object.wait\/notifyAll\n- * @library \/test\/lib\n- * @run junit WaitNotify\n- *\/\n-\n-import java.util.concurrent.Semaphore;\n-\n-import jdk.test.lib.thread.VThreadRunner;\n-import org.junit.jupiter.api.Test;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class WaitNotify {\n-\n-    \/**\n-     * Test virtual thread waits, notified by platform thread.\n-     *\/\n-    @Test\n-    void testWaitNotify1() throws Exception {\n-        var lock = new Object();\n-        var ready = new Semaphore(0);\n-        var thread = Thread.ofVirtual().start(() -> {\n-            synchronized (lock) {\n-                ready.release();\n-                try {\n-                    lock.wait();\n-                } catch (InterruptedException e) { }\n-            }\n-        });\n-        \/\/ thread invokes notify\n-        ready.acquire();\n-        synchronized (lock) {\n-            lock.notifyAll();\n-        }\n-        thread.join();\n-    }\n-\n-    \/**\n-     * Test platform thread waits, notified by virtual thread.\n-     *\/\n-    @Test\n-    void testWaitNotify2() throws Exception {\n-        var lock = new Object();\n-        var ready = new Semaphore(0);\n-        var thread = Thread.ofVirtual().start(() -> {\n-            ready.acquireUninterruptibly();\n-            synchronized (lock) {\n-                lock.notifyAll();\n-            }\n-        });\n-        synchronized (lock) {\n-            ready.release();\n-            lock.wait();\n-        }\n-        thread.join();\n-    }\n-\n-    \/**\n-     * Test virtual thread waits, notified by another virtual thread.\n-     *\/\n-    @Test\n-    void testWaitNotify3() throws Exception {\n-        var lock = new Object();\n-        var ready = new Semaphore(0);\n-        var thread1 = Thread.ofVirtual().start(() -> {\n-            synchronized (lock) {\n-                ready.release();\n-                try {\n-                    lock.wait();\n-                } catch (InterruptedException e) { }\n-            }\n-        });\n-        var thread2 = Thread.ofVirtual().start(() -> {\n-            ready.acquireUninterruptibly();\n-            synchronized (lock) {\n-                lock.notifyAll();\n-            }\n-        });\n-        thread1.join();\n-        thread2.join();\n-    }\n-\n-    \/**\n-     * Test interrupt status set when calling Object.wait.\n-     *\/\n-    @Test\n-    void testWaitNotify4() throws Exception {\n-        VThreadRunner.run(() -> {\n-            Thread t = Thread.currentThread();\n-            t.interrupt();\n-            Object lock = new Object();\n-            synchronized (lock) {\n-                try {\n-                    lock.wait();\n-                    fail();\n-                } catch (InterruptedException e) {\n-                    \/\/ interrupt status should be cleared\n-                    assertFalse(t.isInterrupted());\n-                }\n-            }\n-        });\n-    }\n-\n-    \/**\n-     * Test interrupt when blocked in Object.wait.\n-     *\/\n-    @Test\n-    void testWaitNotify5() throws Exception {\n-        VThreadRunner.run(() -> {\n-            Thread t = Thread.currentThread();\n-            scheduleInterrupt(t, 1000);\n-            Object lock = new Object();\n-            synchronized (lock) {\n-                try {\n-                    lock.wait();\n-                    fail();\n-                } catch (InterruptedException e) {\n-                    \/\/ interrupt status should be cleared\n-                    assertFalse(t.isInterrupted());\n-                }\n-            }\n-        });\n-    }\n-\n-    \/**\n-     * Schedule a thread to be interrupted after a delay.\n-     *\/\n-    private static void scheduleInterrupt(Thread thread, long delay) {\n-        Runnable interruptTask = () -> {\n-            try {\n-                Thread.sleep(delay);\n-                thread.interrupt();\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-            }\n-        };\n-        new Thread(interruptTask).start();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/WaitNotify.java","additions":0,"deletions":163,"binary":false,"changes":163,"status":"deleted"},{"patch":"@@ -28,1 +28,2 @@\n- * @run main PinALot 500000\n+ * @library \/test\/lib\n+ * @run main\/othervm --enable-native-access=ALL-UNNAMED PinALot 500000\n@@ -34,1 +35,2 @@\n- * @run main\/othervm\/timeout=300 PinALot 200000\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=300 --enable-native-access=ALL-UNNAMED PinALot 200000\n@@ -42,1 +44,1 @@\n-public class PinALot {\n+import jdk.test.lib.thread.VThreadPinner;\n@@ -44,1 +46,1 @@\n-    static final Object lock = new Object();\n+public class PinALot {\n@@ -56,1 +58,1 @@\n-            synchronized (lock) {\n+            VThreadPinner.runPinned(() -> {\n@@ -60,1 +62,1 @@\n-            }\n+            });\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/PinALot.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm\/timeout=300 -Xmx1g Skynet\n+ * @run main\/othervm\/timeout=300 -Xmx1500m Skynet\n@@ -38,1 +38,1 @@\n- *     -XX:+ZVerifyOops -XX:ZCollectionInterval=0.01 -Xmx1g Skynet\n+ *     -XX:+ZVerifyOops -XX:ZCollectionInterval=0.01 -Xmx1500m Skynet\n@@ -47,1 +47,1 @@\n- *     -XX:+ZVerifyOops -XX:ZCollectionInterval=0.01 -Xmx1g Skynet\n+ *     -XX:+ZVerifyOops -XX:ZCollectionInterval=0.01 -Xmx1500m Skynet\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/Skynet.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -414,1 +414,0 @@\n-            long start = System.currentTimeMillis();\n@@ -416,1 +415,0 @@\n-            long duration = System.currentTimeMillis() - start;\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/SelectWithConsumer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-            ProcessTools.executeTestJvm(cmd).shouldHaveExitValue(0);\n+            ProcessTools.executeTestJava(cmd).shouldHaveExitValue(0);\n","filename":"test\/jdk\/java\/security\/Policy\/ExtensiblePolicy\/ExtensiblePolicyWithJarTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-        ProcessTools.executeTestJvm(cmd).shouldHaveExitValue(0);\n+        ProcessTools.executeTestJava(cmd).shouldHaveExitValue(0);\n@@ -134,1 +134,1 @@\n-        ProcessTools.executeTestJvm(cmd).shouldHaveExitValue(0);\n+        ProcessTools.executeTestJava(cmd).shouldHaveExitValue(0);\n@@ -144,1 +144,1 @@\n-        ProcessTools.executeTestJvm(cmd).shouldHaveExitValue(0);\n+        ProcessTools.executeTestJava(cmd).shouldHaveExitValue(0);\n","filename":"test\/jdk\/java\/security\/Policy\/SignedJar\/SignedJarTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n-        String out = ProcessTools.executeTestJvm(safeArgs).getOutput();\n+        String out = ProcessTools.executeTestJava(safeArgs).getOutput();\n","filename":"test\/jdk\/java\/security\/Provider\/SecurityProviderModularTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-        ProcessTools.executeTestJvm(\"-classpath\",\n+        ProcessTools.executeTestJava(\"-classpath\",\n@@ -90,1 +90,1 @@\n-        ProcessTools.executeTestJvm(\"-classpath\",\n+        ProcessTools.executeTestJava(\"-classpath\",\n","filename":"test\/jdk\/java\/security\/Security\/signedfirst\/DynStatic.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-            OutputAnalyzer out = ProcessTools.executeTestJvm(testRun);\n+            OutputAnalyzer out = ProcessTools.executeTestJava(testRun);\n","filename":"test\/jdk\/java\/security\/SignedJar\/spi-calendar-provider\/TestSPISigned.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -645,0 +645,25 @@\n+    @Test\n+    public void test53() {\n+        \/\/ The latest Instant that can be converted to a Timestamp.\n+        Instant instant1 = Instant.ofEpochSecond(Long.MAX_VALUE \/ 1000, 999_999_999);\n+        assertEquals(Timestamp.from(instant1).toInstant(), instant1);\n+\n+        \/\/ One nanosecond more, and converting it gets an overflow.\n+        Instant instant2 = instant1.plusNanos(1);\n+        expectThrows(IllegalArgumentException.class, () -> Timestamp.from(instant2));\n+\n+        \/\/ The earliest Instant that can be converted to a Timestamp.\n+        Instant instant3 = Instant.ofEpochSecond(Long.MIN_VALUE \/ 1000, 0);\n+        assertEquals(Timestamp.from(instant3).toInstant(), instant3);\n+\n+        \/\/ One nanosecond less, and converting it gets an overflow.\n+        Instant instant4 = instant3.minusNanos(1);\n+        expectThrows(IllegalArgumentException.class, () -> Timestamp.from(instant4));\n+\n+        \/\/ The latest possible Instant will certainly overflow.\n+        expectThrows(IllegalArgumentException.class, () -> Timestamp.from(Instant.MAX));\n+\n+        \/\/ The earliest possible Instant will certainly overflow.\n+        expectThrows(IllegalArgumentException.class, () -> Timestamp.from(Instant.MIN));\n+    }\n+\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/TimestampTests.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-        int exitStatus = ProcessTools.executeTestJvm(params).getExitValue();\n+        int exitStatus = ProcessTools.executeTestJava(params).getExitValue();\n@@ -129,1 +129,1 @@\n-        \/\/ We don't use executeTestJvm() because we want to point to separate JDK java path\n+        \/\/ We don't use executeTestJava() because we want to point to separate JDK java path\n","filename":"test\/jdk\/java\/util\/Currency\/PropertiesTestRun.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        ProcessTools.executeTestJvm(\"-Djava.locale.useOldISOCodes=true\", \"UseOldISOCodesTest$Runner\")\n+        ProcessTools.executeTestJava(\"-Djava.locale.useOldISOCodes=true\", \"UseOldISOCodesTest$Runner\")\n","filename":"test\/jdk\/java\/util\/Locale\/UseOldISOCodesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        ProcessTools.executeTestJvm(\"-Djava.util.prefs.userRoot=.\", testName)\n+        ProcessTools.executeTestJava(\"-Djava.util.prefs.userRoot=.\", testName)\n","filename":"test\/jdk\/java\/util\/prefs\/CheckUserPrefsStorage.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-        OutputAnalyzer a = ProcessTools.executeTestJvm(\"-jar\", zipFile.getName());\n+        OutputAnalyzer a = ProcessTools.executeTestJava(\"-jar\", zipFile.getName());\n","filename":"test\/jdk\/java\/util\/zip\/EntryCount64k.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4244499 4532049 4700978 4820807 4980042\n+ * @bug 4244499 4532049 4700978 4820807 4980042 7009069 8322802\n@@ -29,0 +29,1 @@\n+ * @run junit ZipCoding\n@@ -31,0 +32,4 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -33,0 +38,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -34,0 +41,1 @@\n+import java.util.stream.Stream;\n@@ -36,0 +44,2 @@\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -38,1 +48,15 @@\n-    public static void main(String[] args) throws Exception {\n+    \/\/ The data to write to ZIP entries in this test\n+    private static byte[] ENTRY_DATA = \"German Umlaut \\u00fc in entry data\"\n+            .getBytes(StandardCharsets.ISO_8859_1);\n+\n+    \/**\n+     * Provide arguments used for parameterized tests\n+     * @return a stream of argument lists\n+     *\/\n+    public static Stream<Arguments> charsetsAndNames() {\n+        \/\/ Arguments are: Write charset, read charset, entry name, comment\n+        return Stream.of(\n+                \/\/ MS code page 932 for the Japanese language\n+                Arguments.of(\"MS932\", \"MS932\",\n+                        \"\\u4e00\\u4e01\",\n+                        \"\\uff67\\uff68\\uff69\\uff6a\\uff6b\\uff6c\"),\n@@ -40,2 +64,4 @@\n-        test(\"MS932\",\n-             \"\\u4e00\\u4e01\", \"\\uff67\\uff68\\uff69\\uff6a\\uff6b\\uff6c\");\n+                \/\/ Code page for the IBM PC\n+                Arguments.of(\"ibm437\", \"ibm437\",\n+                        \"\\u00e4\\u00fc\",\n+                        \"German Umlaut \\u00fc in comment\"),\n@@ -43,2 +69,4 @@\n-        test(\"ibm437\",\n-             \"\\u00e4\\u00fc\", \"German Umlaut \\u00fc in comment\");\n+                \/\/ UTF-8 with Japanese characters\n+                Arguments.of(\"utf-8\", \"utf-8\",\n+                        \"\\u4e00\\u4e01\",\n+                        \"\\uff67\\uff68\\uff69\\uff6a\\uff6b\\uff6c\"),\n@@ -46,2 +74,4 @@\n-        test(\"utf-8\",\n-             \"\\u4e00\\u4e01\", \"\\uff67\\uff68\\uff69\\uff6a\\uff6b\\uff6c\");\n+                \/\/ UTF-8 with characters in the Latin1 range\n+                Arguments.of(\"utf-8\", \"utf-8\",\n+                        \"\\u00e4\\u00fc\",\n+                        \"German Umlaut \\u00fc in comment\"),\n@@ -49,2 +79,4 @@\n-        test(\"utf-8\",\n-             \"\\u00e4\\u00fc\", \"German Umlaut \\u00fc in comment\");\n+                \/\/ UTF-8 with surrogate pairs\n+                Arguments.of(\"utf-8\", \"utf-8\",\n+                        \"Surrogate\\ud801\\udc01\",\n+                        \"Surrogates \\ud800\\udc00 in comment\"),\n@@ -52,2 +84,2 @@\n-        test(\"utf-8\",\n-             \"Surrogate\\ud801\\udc01\", \"Surrogates \\ud800\\udc00 in comment\");\n+                \/\/ ZipOutputStream sets the 'Language encoding flag' when writing using UTF-8\n+                \/\/ UTF-8 should be used for decoding, regardless of the opening charset\n@@ -55,0 +87,14 @@\n+                \/\/ UTF-8 with Japanese characters, opened with MS932\n+                Arguments.of(\"utf-8\", \"MS932\",\n+                        \"\\u4e00\\u4e01\",\n+                        \"\\uff67\\uff68\\uff69\\uff6a\\uff6b\\uff6c\"),\n+\n+                \/\/ UTF-8 with characters in latin1 range, opened with iso-8859-1\n+                Arguments.of(\"utf-8\", \"iso-8859-1\",\n+                        \"\\u00e4\\u00fc\",\n+                        \"German Umlaut \\u00fc in comment\"),\n+                \/\/ UTF-8 with surrogate pairs, opened with MS932\n+                Arguments.of(\"utf-8\", \"MS932\",\n+                        \"Surrogate\\ud801\\udc01\",\n+                        \"Surrogates \\ud800\\udc00 in comment\")\n+        );\n@@ -57,5 +103,23 @@\n-    static void testZipInputStream(InputStream is, Charset cs,\n-                                   String name, String comment, byte[] bb)\n-        throws Exception\n-    {\n-        try (ZipInputStream zis = new ZipInputStream(is, cs)) {\n+    \/**\n+     * Verify that ZipInputStream decodes entry names and comments\n+     * using the charset provided to its constructor, or that it decodes\n+     * using UTF-8 when the 'Language encoding flag' is set\n+     *\n+     * @param writeCharset the charset to use for ZipOutputStream when producing the ZIP\n+     * @param readCharset the charset to use when opening the ZipInputStream\n+     * @param name the entry name\n+     * @param comment the entry comment (not read by ZipInputStream)\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsetsAndNames\")\n+    public void testZipInputStream(String writeCharset,\n+                                   String readCharset,\n+                                   String name,\n+                                   String comment) throws IOException {\n+\n+        byte[] zip = createZIP(writeCharset, name, comment);\n+\n+        try (InputStream in = new ByteArrayInputStream(zip);\n+             ZipInputStream zis = new ZipInputStream(in, Charset.forName(readCharset))) {\n@@ -63,8 +127,5 @@\n-            if (e == null || ! name.equals(e.getName()))\n-                throw new RuntimeException(\"ZipIS name doesn't match!\");\n-            byte[] bBuf = new byte[bb.length << 1];\n-            int n = zis.read(bBuf, 0, bBuf.length);\n-            if (n != bb.length ||\n-                !Arrays.equals(bb, Arrays.copyOf(bBuf, n))) {\n-                throw new RuntimeException(\"ZipIS content doesn't match!\");\n-            }\n+            assertNotNull(e);\n+            assertEquals(name, e.getName(),\n+                    \"ZipInputStream.getNextEntry() returned unexpected entry name\");\n+            assertNull(e.getComment()); \/\/ No comment in the LOC header\n+            assertArrayEquals(ENTRY_DATA, zis.readAllBytes(), \"Unexpected ZIP entry data\");\n@@ -74,5 +135,26 @@\n-    static void testZipFile(File f, Charset cs,\n-                            String name, String comment, byte[] bb)\n-        throws Exception\n-    {\n-        try (ZipFile zf = new ZipFile(f, cs)) {\n+    \/**\n+     * Verify that ZipFile decodes entry names and comments\n+     * using the charset provided to its constructor, or that it decodes\n+     * using UTF-8 when the 'Language encoding flag' is set\n+     *\n+     * @param writeCharset the charset to use for ZipOutputStream when producing the ZIP\n+     * @param readCharset the charset to use when opening the ZipFile\n+     * @param name the name of the entry\n+     * @param comment the comment of the entry\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsetsAndNames\")\n+    public void testZipFile(String writeCharset,\n+                            String readCharset,\n+                            String name,\n+                            String comment) throws IOException {\n+\n+        byte[] zip = createZIP(writeCharset, name, comment);\n+\n+        Path f = Path.of(\"zfcoding.zip\");\n+        Files.write(f, zip);\n+\n+        try (ZipFile zf = new ZipFile(f.toFile(), Charset.forName(readCharset))) {\n+            \/\/ Test using ZipFile.entries\n@@ -81,15 +163,14 @@\n-            if (! name.equals(e.getName()) ||\n-                ! comment.equals(e.getComment()))\n-                throw new RuntimeException(\"ZipFile: name\/comment doesn't match!\");\n-            InputStream is = zf.getInputStream(e);\n-            if (is == null)\n-                throw new RuntimeException(\"ZipFile: getIS failed!\");\n-            byte[] bBuf = new byte[bb.length << 1];\n-            int n = 0;\n-            int nn =0;\n-            while ((nn = is.read(bBuf, n, bBuf.length-n)) != -1) {\n-                n += nn;\n-            }\n-            if (n != bb.length ||\n-                !Arrays.equals(bb, Arrays.copyOf(bBuf, n))) {\n-                throw new RuntimeException(\"ZipFile content doesn't match!\");\n+            assertNotNull(e);\n+            assertEquals(name, e.getName(), \"ZipFile.entries() returned unexpected entry name\");\n+            assertEquals(comment, e.getComment(), \"ZipFile.entries() returned unexpected entry comment\");\n+\n+            \/\/ Test using ZipFile.getEntry\n+            e = zf.getEntry(name);\n+            assertNotNull(e,\n+                    String.format(\"Entry lookup failed on ZIP encoded with %s and opened with %s\",\n+                            writeCharset, readCharset));\n+            assertEquals(name, e.getName(), \"ZipFile.getEntry() returned unexpected entry name\");\n+            assertEquals(comment, e.getComment(), \"ZipFile.getEntry() returned unexpected entry comment\");\n+            try (InputStream is = zf.getInputStream(e)) {\n+                assertNotNull(is);\n+                assertArrayEquals(ENTRY_DATA, is.readAllBytes(), \"Unexpected ZIP entry data\");\n@@ -98,0 +179,2 @@\n+\n+        Files.deleteIfExists(f);\n@@ -100,5 +183,14 @@\n-    static void test(String csn, String name, String comment)\n-        throws Exception\n-    {\n-        byte[] bb = \"This is the content of the zipfile\".getBytes(\"ISO-8859-1\");\n-        Charset cs = Charset.forName(csn);\n+    \/**\n+     * Create a ZIP file containing an entry with the given name\n+     * and comment, encoded using the given charset.\n+     * Note that if the charset is UTF-8, ZipOutputStream will\n+     * set the 'Language encoding flag' for the entry.\n+     *\n+     * @param charset the charset passed to the ZipOutputStream constructor\n+     * @param name the name of the entry to add\n+     * @param comment the comment of the entry to add\n+     * @return a byte array containing the ZIP file\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    private byte[] createZIP(String charset, String name, String comment) throws IOException {\n@@ -106,1 +198,1 @@\n-        try (ZipOutputStream zos = new ZipOutputStream(baos, cs)) {\n+        try (ZipOutputStream zos = new ZipOutputStream(baos, Charset.forName(charset))) {\n@@ -110,1 +202,1 @@\n-            zos.write(bb, 0, bb.length);\n+            zos.write(ENTRY_DATA);\n@@ -113,19 +205,1 @@\n-        ByteArrayInputStream bis = new ByteArrayInputStream(baos.toByteArray());\n-        testZipInputStream(bis, cs, name, comment, bb);\n-\n-        if (\"utf-8\".equals(csn)) {\n-            \/\/ USE_UTF8 should be set\n-            bis.reset();\n-            testZipInputStream(bis, Charset.forName(\"MS932\"), name, comment, bb);\n-        }\n-\n-        File f = new File(new File(System.getProperty(\"test.dir\", \".\")),\n-                          \"zfcoding.zip\");\n-        try (FileOutputStream fos = new FileOutputStream(f)) {\n-            baos.writeTo(fos);\n-        }\n-        testZipFile(f, cs, name, comment, bb);\n-        if (\"utf-8\".equals(csn)) {\n-            testZipFile(f, Charset.forName(\"MS932\"), name, comment, bb);\n-        }\n-        f.delete();\n+        return baos.toByteArray();\n","filename":"test\/jdk\/java\/util\/zip\/ZipCoding.java","additions":146,"deletions":72,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        String tmpFile = ProcessTools.executeTestJvm(DeleteTempJar.class.getName())\n+        String tmpFile = ProcessTools.executeTestJava(DeleteTempJar.class.getName())\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/DeleteTempJarTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-        OutputAnalyzer out = ProcessTools.executeTestJvm(safeArgs);\n+        OutputAnalyzer out = ProcessTools.executeTestJava(safeArgs);\n","filename":"test\/jdk\/javax\/security\/auth\/login\/modules\/JaasModularClientTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-        OutputAnalyzer out = ProcessTools.executeTestJvm(safeArgs);\n+        OutputAnalyzer out = ProcessTools.executeTestJava(safeArgs);\n","filename":"test\/jdk\/javax\/security\/auth\/login\/modules\/JaasModularDefaultHandlerTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/DE1.gif","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/DI1.gif","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/DS1.gif","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/PR1.gif","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/RO1.gif","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/RS1.gif","binary":true,"status":"deleted"},{"filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/SE1.gif","binary":true,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,8 +24,4 @@\n-\/* @test\n-   @bug 5049549 7132413\n-   @summary Tests that the proper icon is used for different states.\n-   @library ..\/..\/regtesthelpers\n-   @build Blocker\n-   @run main\/manual bug5049549\n-*\/\n-\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics;\n+import java.awt.image.BufferedImage;\n@@ -42,0 +38,8 @@\n+\/*\n+ * @test\n+ * @bug 5049549 7132413\n+ * @summary Tests that the proper icon is used for different states.\n+ * @library ..\/..\/regtesthelpers\n+ * @build Blocker\n+ * @run main\/manual bug5049549\n+ *\/\n@@ -44,7 +48,7 @@\n-    private static ImageIcon DE = new ImageIcon(bug5049549.class.getResource(\"DE1.gif\"));\n-    private static ImageIcon DI = new ImageIcon(bug5049549.class.getResource(\"DI1.gif\"));\n-    private static ImageIcon DS = new ImageIcon(bug5049549.class.getResource(\"DS1.gif\"));\n-    private static ImageIcon RO = new ImageIcon(bug5049549.class.getResource(\"RO1.gif\"));\n-    private static ImageIcon RS = new ImageIcon(bug5049549.class.getResource(\"RS1.gif\"));\n-    private static ImageIcon SE = new ImageIcon(bug5049549.class.getResource(\"SE1.gif\"));\n-    private static ImageIcon PR = new ImageIcon(bug5049549.class.getResource(\"PR1.gif\"));\n+    private static final Icon DE = generateImage(\"DE\");\n+    private static final Icon DI = generateImage(\"DI\");\n+    private static final Icon DS = generateImage(\"DS\");\n+    private static final Icon RO = generateImage(\"RO\");\n+    private static final Icon RS = generateImage(\"RS\");\n+    private static final Icon SE = generateImage(\"SE\");\n+    private static final Icon PR = generateImage(\"PR\");\n@@ -52,1 +56,15 @@\n-    private static Blocker blocker = new Blocker();\n+    private static final Blocker blocker = new Blocker();\n+\n+    private static Icon generateImage(String str) {\n+        BufferedImage img = new BufferedImage(40, 30,\n+                BufferedImage.TYPE_INT_RGB);\n+        Graphics g = img.createGraphics();\n+        g.setColor(Color.WHITE);\n+        g.fillRect(0, 0, img.getWidth(), img.getHeight());\n+        g.setColor(Color.RED);\n+        Font font = new Font(Font.SANS_SERIF, Font.BOLD, 22);\n+        g.setFont(font);\n+        g.drawString(str, 5, 25);\n+        g.dispose();\n+        return new ImageIcon(img);\n+    }\n","filename":"test\/jdk\/javax\/swing\/AbstractButton\/5049549\/bug5049549.java","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8320360\n@@ -88,0 +89,6 @@\n+\n+    @Test\n+    void testReadingOutOfBounds() {\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().parse(new byte[]{(byte)0xCA, (byte)0xFE, (byte)0xBA, (byte)0xBE}), \"reading magic only\");\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().parse(new byte[]{(byte)0xCA, (byte)0xFE, (byte)0xBA, (byte)0xBE, 0, 0, 0, 0, 0, 2}), \"reading invalid CP size\");\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/LimitsTest.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @bug 8321540\n@@ -49,0 +50,1 @@\n+import org.junit.jupiter.api.Assertions;\n@@ -51,0 +53,2 @@\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n@@ -189,0 +193,75 @@\n+\n+    @Test\n+    void testBadTypeSignatures() {\n+        \"\"\"\n+        LObject\n+        LObject;B\n+        LIterable<LFoo>\n+        LIterable<<\n+        TBar\n+        TBar<LFoo;>\n+        B<LFoo;>\n+        B<LFoo;>;V\n+        X\n+        [LObject\n+        [LIterable<LFoo>\n+        [LIterable<<\n+        [TBar\n+        [TBar<LFoo;>\n+        [B<LFoo;>\n+        [X\n+        LSet<+Kind<**>;>;\n+        LSet<?Kind<*>;>;\n+        ()V\n+        \"\"\".lines().forEach(assertThrows(Signature::parseFrom));\n+    }\n+\n+    @Test\n+    void testBadClassSignatures() {\n+        \"\"\"\n+        Ljava\/lang\/Object;Ljava\/lang\/Iterable<LFoo;>\n+        LObject\n+        LObject;B\n+        LIterable<LFoo>\n+        LIterable<<\n+        TBar\n+        TBar<LFoo;>\n+        B<LFoo;>\n+        B<LFoo;>;V\n+        X\n+        LFoo<TK;>.It;L\n+        <K+LObject;>LFoo<TK;;>;LFoo<TK;>;LBar;\n+        <K:LObject;>>LFoo<TK;>;\n+        <K:LObject;>LFoo<+>;\n+        ()V\n+        \"\"\".lines().forEach(assertThrows(ClassSignature::parseFrom));\n+    }\n+\n+    @Test\n+    void testBadMethodSignatures() {\n+        \"\"\"\n+        LObject;\n+        B\n+        ()V^\n+        ()V^B\n+        ()V^X\n+        (LObject;)\n+        (LObject)V\n+        ()LIterable<LFoo>\n+        ()LIterable<<\n+        ()TBar\n+        ()TBar;B\n+        (TBar<LFoo;>)V\n+        (B<LFoo;>)V\n+        (X)\n+        ()X\n+        ()VB\n+        ()LSet<+Kind<**>;>;\n+        (LSet<?Kind<*>;>;)V\n+        <T::LA>()V\n+        \"\"\".lines().forEach(assertThrows(MethodSignature::parseFrom));\n+    }\n+\n+    private Consumer<String> assertThrows(Function<String, ?> parser) {\n+        return s -> Assertions.assertThrows(IllegalArgumentException.class, () -> parser.apply(s), s);\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":80,"deletions":1,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -47,3 +47,3 @@\n-            ProcessTools.executeTestJvm(\"--add-exports\", \"java.base\/jdk.internal.ref=ALL-UNNAMED\",\n-                                        \"ExitOnThrow\",\n-                                        \"-executeCleaner\")\n+            ProcessTools.executeTestJava(\"--add-exports\", \"java.base\/jdk.internal.ref=ALL-UNNAMED\",\n+                                         \"ExitOnThrow\",\n+                                         \"-executeCleaner\")\n","filename":"test\/jdk\/jdk\/internal\/ref\/Cleaner\/ExitOnThrow.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-            OutputAnalyzer oa = ProcessTools.executeTestJvm(c);\n+            OutputAnalyzer oa = ProcessTools.executeTestJava(c);\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/security\/TestStreamingRemote.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -286,1 +286,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(args);\n+        OutputAnalyzer output = ProcessTools.executeTestJava(args);\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestInstrumentation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        OutputAnalyzer output = ProcessTools.executeTestJvm(arguments);\n+        OutputAnalyzer output = ProcessTools.executeTestJava(arguments);\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdPreserveRepository.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8316141\n+ * @bug 8316141 8321802\n@@ -290,0 +290,10 @@\n+    \/*\n+     * A ZipException is thrown when a LOC header has an unexpected signature\n+     *\/\n+    @Test\n+    public void invalidLOCSignature() throws IOException {\n+        int existingSignature = buffer.getInt(locpos);\n+        buffer.putInt(locpos, existingSignature +1);\n+        assertZipException(\".*bad signature.*\");\n+    }\n+\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/CorruptedZipFilesTest.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-        ProcessTools.executeTestJvm(testCommand).shouldHaveExitValue(0);\n+        ProcessTools.executeTestJava(testCommand).shouldHaveExitValue(0);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Config\/ReadConfInUTF16Env.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-            OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJvm(\n+            OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n","filename":"test\/jdk\/sun\/security\/ssl\/CertPathRestrictions\/TLSRestrictions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-            OutputAnalyzer output = ProcessTools.executeTestJvm(\n+            OutputAnalyzer output = ProcessTools.executeTestJava(\n","filename":"test\/jdk\/sun\/security\/ssl\/EngineArgs\/DebugReportsOneExtraByte.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-            \/\/ is passed to the test via ProcessTools::executeTestJvm.\n+            \/\/ is passed to the test via ProcessTools::executeTestJava.\n@@ -74,1 +74,1 @@\n-                var output = ProcessTools.executeTestJvm(\n+                var output = ProcessTools.executeTestJava(\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLLogger\/LoggingFormatConsistency.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-            \/\/ is passed to the test via ProcessTools::executeTestJvm.\n+            \/\/ is passed to the test via ProcessTools::executeTestJava.\n@@ -70,1 +70,1 @@\n-            OutputAnalyzer output = ProcessTools.executeTestJvm(jvmArgs);\n+            OutputAnalyzer output = ProcessTools.executeTestJava(jvmArgs);\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/IgnorableExceptionMessages.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-        ProcessTools.executeTestJvm(cmd)\n+        ProcessTools.executeTestJava(cmd)\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/multiRelease\/MVJarSigningTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-        OutputAnalyzer out = ProcessTools.executeTestJvm(\n+        OutputAnalyzer out = ProcessTools.executeTestJava(\n","filename":"test\/jdk\/sun\/security\/util\/Resources\/early\/EarlyResources.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301580\n+ * @bug 8301580 8322159\n@@ -90,0 +90,37 @@\n+    @Test\n+    public void testX() throws Exception {\n+        String code = \"\"\"\n+                      public class C {\n+                          public C() {\n+                              Undefined.method();\n+                              undefined1();\n+                              Runnable r = this::undefined2;\n+                              overridable(this); \/\/to verify ThisEscapeAnalyzer has been run\n+                          }\n+                          public void overridable(C c) {}\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\", \"-XDdev\",\n+                         \"-XDshould-stop.at=FLOW\", \"-Xlint:this-escape\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .run(Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"C.java:3:9: compiler.err.cant.resolve.location: kindname.variable, Undefined, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:4:9: compiler.err.cant.resolve.location.args: kindname.method, undefined1, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:5:22: compiler.err.invalid.mref: kindname.method, (compiler.misc.cant.resolve.location.args: kindname.method, undefined2, , , (compiler.misc.location: kindname.class, C, null))\",\n+                \"C.java:6:20: compiler.warn.possible.this.escape\",\n+                \"3 errors\",\n+                \"1 warning\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        ProcessTools.executeTestJvm(cmdLineArgs).shouldHaveExitValue(0);\n+        ProcessTools.executeTestJava(cmdLineArgs).shouldHaveExitValue(0);\n@@ -146,1 +146,1 @@\n-                oa = ProcessTools.executeTestJvm(cmdLine);\n+                oa = ProcessTools.executeTestJava(cmdLine);\n","filename":"test\/lib-test\/jdk\/test\/lib\/RandomGeneratorTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Unit test for ProcessTools.executeLimitedTestJava()\n+ * @library \/test\/lib\n+ * @run main\/othervm -Dtest.java.opts=-XX:MaxMetaspaceSize=123456789 ProcessToolsExecuteLimitedTestJavaTest\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class ProcessToolsExecuteLimitedTestJavaTest {\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 0) {\n+            \/\/ Do nothing. Just let the JVM log its output.\n+        } else {\n+            \/\/ In comparison to executeTestJava, executeLimitedTestJava should not add the\n+            \/\/ -Dtest.java.opts flags. Check that it doesn't.\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+PrintFlagsFinal\", \"-version\");\n+            output.stdoutShouldNotMatch(\".*MaxMetaspaceSize.* = 123456789.*\");\n+        }\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/process\/ProcessToolsExecuteLimitedTestJavaTest.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -111,0 +111,8 @@\n+    \/**\n+     * Delegate waitFor to the OutputBuffer. This ensures that\n+     * the progress and timestamps are logged correctly.\n+     *\/\n+    public void waitFor() {\n+        buffer.waitFor();\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputAnalyzer.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,6 @@\n+  \/**\n+   * Waits for a process to finish, if there is one assocated with\n+   * this OutputBuffer.\n+   *\/\n+  public void waitFor();\n+\n@@ -70,0 +76,7 @@\n+\n+\n+  \/**\n+   * Returns the exit value\n+   *\n+   * @return exit value\n+   *\/\n@@ -139,11 +152,1 @@\n-    public String getStdout() {\n-      return outTask.get();\n-    }\n-\n-    @Override\n-    public String getStderr() {\n-      return errTask.get();\n-    }\n-\n-    @Override\n-    public int getExitValue() {\n+    public void waitFor() {\n@@ -151,1 +154,2 @@\n-        return exitValue;\n+        \/\/ Already waited for this process\n+        return;\n@@ -153,0 +157,1 @@\n+\n@@ -160,1 +165,0 @@\n-              return exitValue;\n@@ -172,0 +176,16 @@\n+    @Override\n+    public String getStdout() {\n+      return outTask.get();\n+    }\n+\n+    @Override\n+    public String getStderr() {\n+      return errTask.get();\n+    }\n+\n+    @Override\n+    public int getExitValue() {\n+      waitFor();\n+      return exitValue;\n+    }\n+\n@@ -189,0 +209,5 @@\n+    @Override\n+    public void waitFor() {\n+      \/\/ Nothing to do since this buffer is not associated with a Process.\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputBuffer.java","additions":38,"deletions":13,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -611,1 +611,2 @@\n-     * Executes a test jvm process, waits for it to finish and returns\n+     * Executes a process using the java launcher from the jdk to\n+     * be tested, waits for it to finish and returns\n@@ -618,1 +619,1 @@\n-     * @param cmds User specified arguments.\n+     * @param command User specified arguments.\n@@ -621,2 +622,2 @@\n-    public static OutputAnalyzer executeTestJvm(List<String> cmds) throws Exception {\n-        return executeTestJvm(cmds.toArray(String[]::new));\n+    public static OutputAnalyzer executeTestJava(List<String> command) throws Exception {\n+        return executeTestJava(command.toArray(String[]::new));\n@@ -626,1 +627,2 @@\n-     * Executes a test jvm process, waits for it to finish and returns\n+     * Executes a process using the java launcher from the jdk to\n+     * be tested, waits for it to finish and returns\n@@ -633,1 +635,1 @@\n-     * @param cmds User specified arguments.\n+     * @param command User specified arguments.\n@@ -636,2 +638,2 @@\n-    public static OutputAnalyzer executeTestJvm(String... cmds) throws Exception {\n-        ProcessBuilder pb = createTestJavaProcessBuilder(cmds);\n+    public static OutputAnalyzer executeTestJava(String... command) throws Exception {\n+        ProcessBuilder pb = createTestJavaProcessBuilder(command);\n@@ -642,1 +644,9 @@\n-     * @param cmds User specified arguments.\n+     * Executes a process using the java launcher from the jdk to\n+     * be tested, waits for it to finish and returns\n+     * the process output.\n+     *\n+     * <p>The process is created using runtime flags set up by:\n+     * {@link #createLimitedTestJavaProcessBuilder(String...)}. The\n+     * jvm process will have exited before this method returns.\n+     *\n+     * @param command User specified arguments.\n@@ -644,1 +654,0 @@\n-     * @see #executeTestJvm(String...)\n@@ -646,2 +655,19 @@\n-    public static OutputAnalyzer executeTestJava(String... cmds) throws Exception {\n-        return executeTestJvm(cmds);\n+    public static OutputAnalyzer executeLimitedTestJava(List<String> command) throws Exception {\n+        return executeLimitedTestJava(command.toArray(String[]::new));\n+    }\n+\n+    \/**\n+     * Executes a process using the java launcher from the jdk to\n+     * be tested, waits for it to finish and returns\n+     * the process output.\n+     *\n+     * <p>The process is created using runtime flags set up by:\n+     * {@link #createLimitedTestJavaProcessBuilder(String...)}. The\n+     * jvm process will have exited before this method returns.\n+     *\n+     * @param command User specified arguments.\n+     * @return The output from the process.\n+     *\/\n+    public static OutputAnalyzer executeLimitedTestJava(String... command) throws Exception {\n+        ProcessBuilder pb = createLimitedTestJavaProcessBuilder(command);\n+        return executeProcess(pb);\n@@ -700,1 +726,4 @@\n-            p.waitFor();\n+\n+            \/\/ Wait for the process to finish. Call through the output\n+            \/\/ analyzer to get correct logging and timestamps.\n+            output.waitFor();\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":42,"deletions":13,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.thread;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicReference;\n+import jdk.test.lib.thread.VThreadRunner.ThrowingRunnable;\n+\n+\/**\n+ * Helper class to allow tests run a task in a virtual thread while pinning its carrier.\n+ *\n+ * It defines the {@code runPinned} method to run a task with a native frame on the stack.\n+ *\/\n+public class VThreadPinner {\n+    private static final Path JAVA_LIBRARY_PATH = Path.of(System.getProperty(\"java.library.path\"));\n+    private static final Path LIB_PATH = JAVA_LIBRARY_PATH.resolve(System.mapLibraryName(\"VThreadPinner\"));\n+\n+    \/\/ method handle to call the native function\n+    private static final MethodHandle INVOKER = invoker();\n+\n+    \/\/ function pointer to call\n+    private static final MemorySegment UPCALL_STUB = upcallStub();\n+\n+    \/**\n+     * Thread local with the task to run.\n+     *\/\n+    private static final ThreadLocal<TaskRunner> TASK_RUNNER = new ThreadLocal<>();\n+\n+    \/**\n+     * Runs a task, capturing any exception or error thrown.\n+     *\/\n+    private static class TaskRunner implements Runnable {\n+        private final ThrowingRunnable<?> task;\n+        private Throwable throwable;\n+\n+        TaskRunner(ThrowingRunnable<?> task) {\n+            this.task = task;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                task.run();\n+            } catch (Throwable ex) {\n+                throwable = ex;\n+            }\n+        }\n+\n+        Throwable exception() {\n+            return throwable;\n+        }\n+    }\n+\n+    \/**\n+     * Called by the native function to run the task stashed in the thread local. The\n+     * task runs with the native frame on the stack.\n+     *\/\n+    private static void callback() {\n+        TASK_RUNNER.get().run();\n+    }\n+\n+    \/**\n+     * Runs the given task on a virtual thread pinned to its carrier. If called from a\n+     * virtual thread then it invokes the task directly.\n+     *\/\n+    public static <X extends Throwable> void runPinned(ThrowingRunnable<X> task) throws X {\n+        if (!Thread.currentThread().isVirtual()) {\n+            VThreadRunner.run(() -> runPinned(task));\n+            return;\n+        }\n+        var runner = new TaskRunner(task);\n+        TASK_RUNNER.set(runner);\n+        try {\n+            INVOKER.invoke(UPCALL_STUB);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            TASK_RUNNER.remove();\n+        }\n+        Throwable ex = runner.exception();\n+        if (ex != null) {\n+            if (ex instanceof RuntimeException e)\n+                throw e;\n+            if (ex instanceof Error e)\n+                throw e;\n+            throw (X) ex;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a method handle to the native function void call(void *(*f)(void *)).\n+     *\/\n+    @SuppressWarnings(\"restricted\")\n+    private static MethodHandle invoker() {\n+        Linker abi = Linker.nativeLinker();\n+        try {\n+            SymbolLookup lib = SymbolLookup.libraryLookup(LIB_PATH, Arena.global());\n+            MemorySegment symbol = lib.find(\"call\").orElseThrow();\n+            FunctionDescriptor desc = FunctionDescriptor.ofVoid(ValueLayout.ADDRESS);\n+            return abi.downcallHandle(symbol, desc);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns an upcall stub to use as a function pointer to invoke the callback method.\n+     *\/\n+    @SuppressWarnings(\"restricted\")\n+    private static MemorySegment upcallStub() {\n+        Linker abi = Linker.nativeLinker();\n+        try {\n+            MethodHandle callback = MethodHandles.lookup()\n+                    .findStatic(VThreadPinner.class, \"callback\", MethodType.methodType(void.class));\n+            return abi.upcallStub(callback, FunctionDescriptor.ofVoid(), Arena.global());\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/thread\/VThreadPinner.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n- * Helper class to support tests running tasks a in virtual thread.\n+ * Helper class to support tests running tasks in a virtual thread.\n@@ -44,2 +44,1 @@\n-     * Represents a task that does not return a result but may throw\n-     * an exception.\n+     * Represents a task that does not return a result but may throw an exception.\n@@ -48,5 +47,2 @@\n-    public interface ThrowingRunnable {\n-        \/**\n-         * Runs this operation.\n-         *\/\n-        void run() throws Exception;\n+    public interface ThrowingRunnable<X extends Throwable> {\n+        void run() throws X;\n@@ -58,1 +54,0 @@\n-     * If the task throws an Error then it is wrapped in an RuntimeException.\n@@ -63,1 +58,1 @@\n-     * @throws Exception the exception thrown by the task\n+     * @throws X the exception thrown by the task\n@@ -65,5 +60,5 @@\n-    public static void run(String name,\n-                           int characteristics,\n-                           ThrowingRunnable task) throws Exception {\n-        AtomicReference<Exception> exc = new AtomicReference<>();\n-        Runnable target =  () -> {\n+    public static <X extends Throwable> void run(String name,\n+                                                 int characteristics,\n+                                                 ThrowingRunnable<X> task) throws X {\n+        var throwableRef = new AtomicReference<Throwable>();\n+        Runnable target = () -> {\n@@ -72,4 +67,2 @@\n-            } catch (Error e) {\n-                exc.set(new RuntimeException(e));\n-            } catch (Exception e) {\n-                exc.set(e);\n+            } catch (Throwable ex) {\n+                throwableRef.set(ex);\n@@ -87,4 +80,6 @@\n-        while (thread.join(Duration.ofSeconds(10)) == false) {\n-            System.out.println(\"-- \" + thread + \" --\");\n-            for (StackTraceElement e : thread.getStackTrace()) {\n-                System.out.println(\"  \" + e);\n+        try {\n+            while (thread.join(Duration.ofSeconds(10)) == false) {\n+                System.out.println(\"-- \" + thread + \" --\");\n+                for (StackTraceElement e : thread.getStackTrace()) {\n+                    System.out.println(\"  \" + e);\n+                }\n@@ -92,0 +87,2 @@\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n@@ -94,3 +91,7 @@\n-        Exception e = exc.get();\n-        if (e != null) {\n-            throw e;\n+        Throwable ex = throwableRef.get();\n+        if (ex != null) {\n+            if (ex instanceof RuntimeException e)\n+                throw e;\n+            if (ex instanceof Error e)\n+                throw e;\n+            throw (X) ex;\n@@ -103,1 +104,0 @@\n-     * If the task throws an Error then it is wrapped in an RuntimeException.\n@@ -107,1 +107,1 @@\n-     * @throws Exception the exception thrown by the task\n+     * @throws X the exception thrown by the task\n@@ -109,1 +109,1 @@\n-    public static void run(String name, ThrowingRunnable task) throws Exception {\n+    public static <X extends Throwable> void run(String name, ThrowingRunnable<X> task) throws X {\n@@ -116,1 +116,0 @@\n-     * If the task throws an Error then it is wrapped in an RuntimeException.\n@@ -120,1 +119,1 @@\n-     * @throws Exception the exception thrown by the task\n+     * @throws X the exception thrown by the task\n@@ -122,1 +121,1 @@\n-    public static void run(int characteristics, ThrowingRunnable task) throws Exception {\n+    public static <X extends Throwable> void run(int characteristics, ThrowingRunnable<X> task) throws X {\n@@ -129,1 +128,0 @@\n-     * If the task throws an Error then it is wrapped in an RuntimeException.\n@@ -132,1 +130,1 @@\n-     * @throws Exception the exception thrown by the task\n+     * @throws X the exception thrown by the task\n@@ -134,1 +132,1 @@\n-    public static void run(ThrowingRunnable task) throws Exception {\n+    public static <X extends Throwable> void run(ThrowingRunnable<X> task) throws X {\n","filename":"test\/lib\/jdk\/test\/lib\/thread\/VThreadRunner.java","additions":33,"deletions":35,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+\/*\n+ * Call a function with the given function pointer.\n+ *\/\n+EXPORT void call(void *(*f)(void)) {\n+    (*f)();\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/thread\/libVThreadPinner.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,2 @@\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\n+                KeyManagerFactory.getDefaultAlgorithm());\n@@ -86,2 +87,2 @@\n-        TrustManagerFactory tmf =\n-                TrustManagerFactory.getInstance(\"SunX509\");\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\n+                TrustManagerFactory.getDefaultAlgorithm());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/SSLHandshake.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,1 @@\n-        KeyStore result = KeyStore.getInstance(\"JKS\");\n+        KeyStore result = KeyStore.getInstance(KeyStore.getDefaultType());\n@@ -123,1 +123,1 @@\n-                        TestCertificates.SERVER_CERT.getBytes(StandardCharsets.ISO_8859_1)));\n+                        SERVER_CERT.getBytes(StandardCharsets.ISO_8859_1)));\n@@ -138,1 +138,1 @@\n-        KeyStore result = KeyStore.getInstance(\"JKS\");\n+        KeyStore result = KeyStore.getInstance(KeyStore.getDefaultType());\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/TestCertificates.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}