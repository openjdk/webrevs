{"files":[{"patch":"@@ -221,1 +221,9 @@\n-    return new ShenandoahGenerationalHeap(new ShenandoahCollectorPolicy());\n+    ShenandoahGenerationalHeap* heap = new ShenandoahGenerationalHeap(new ShenandoahCollectorPolicy());\n+    CollectedHeap* result = heap;\n+    size_t MaxTLABSizeWords = ShenandoahHeapRegion::max_tlab_size_words();\n+    size_t min_plab_size = align_up(PLAB::min_size(), CardTable::card_size_in_words());\n+    size_t max_plab_size = (ShenandoahMaxEvacLABRatio > 0)?\n+      align_down(MIN2(MaxTLABSizeWords, PLAB::min_size() * ShenandoahMaxEvacLABRatio), CardTable::card_size_in_words()):\n+      align_down(MaxTLABSizeWords, CardTable::card_size_in_words());\n+    heap->initialize_plab_min_max(min_plab_size, max_plab_size);\n+    return result;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,0 +34,4 @@\n+private:\n+  size_t _min_plab_size;\n+  size_t _max_plab_size;\n+\n@@ -39,0 +43,4 @@\n+  void initialize_plab_min_max(size_t min, size_t max) { _min_plab_size = min; _max_plab_size = max; }\n+  inline size_t plab_min_size() { return _min_plab_size; }\n+  inline size_t plab_max_size() { return _max_plab_size; }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -300,1 +301,1 @@\n-                              align_up(num_committed_regions, _bitmap_regions_per_slice) \/ _bitmap_regions_per_slice;\n+    align_up(num_committed_regions, _bitmap_regions_per_slice) \/ _bitmap_regions_per_slice;\n@@ -1099,1 +1100,0 @@\n-  size_t min_size = MAX2(size, PLAB::min_size());\n@@ -1101,1 +1101,8 @@\n-  \/\/ Figure out size of new PLAB, looking back at heuristics. Expand aggressively.\n+  assert(mode()->is_generational(), \"PLABs only relevant to generational GC\");\n+  ShenandoahGenerationalHeap* generational_heap = (ShenandoahGenerationalHeap*) this;\n+  size_t plab_min_size = generational_heap->plab_min_size();\n+  size_t min_size = MAX2(size, plab_min_size);\n+\n+  \/\/ Figure out size of new PLAB, looking back at heuristics. Expand aggressively.  PLABs must align on size\n+  \/\/ of card table in order to avoid the need for synchronization when registering newly allocated objects within\n+  \/\/ the card table.\n@@ -1104,1 +1111,1 @@\n-    cur_size = PLAB::min_size();\n+    cur_size = plab_min_size;\n@@ -1108,11 +1115,3 @@\n-  \/\/ available evacuation buidget between the many threads that are coordinating in the evacuation effort.\n-  if (ShenandoahMaxEvacLABRatio > 0) {\n-    future_size = MIN2(future_size, PLAB::min_size() * ShenandoahMaxEvacLABRatio);\n-  }\n-  future_size = MIN2(future_size, PLAB::max_size());\n-  future_size = MAX2(future_size, PLAB::min_size());\n-\n-  size_t unalignment = future_size % CardTable::card_size_in_words();\n-  if (unalignment != 0) {\n-    future_size = future_size - unalignment + CardTable::card_size_in_words();\n-  }\n+  \/\/ available evacuation budget between the many threads that are coordinating in the evacuation effort.\n+  future_size = MIN2(future_size, generational_heap->plab_max_size());\n+  assert (future_size % CardTable::card_size_in_words() == 0, \"Should align by design\");\n@@ -1154,1 +1153,1 @@\n-    assert (size <= actual_size, \"allocation should fit\");\n+    \/\/ Since the allocated PLAB may have been down-sized for alignment, plab->allocate(size) below may still fail.\n@@ -1168,0 +1167,3 @@\n+    assert (actual_size % CardTable::card_size_in_words() == 0,\n+            \"actual size \" SIZE_FORMAT_X \" should be aligned on card size \" SIZE_FORMAT_X,\n+            actual_size, (size_t) CardTable::card_size_in_words());\n@@ -1376,5 +1378,5 @@\n-  \/\/ Align requested sizes to card sized multiples\n-  size_t words_in_card = CardTable::card_size_in_words();\n-  size_t align_mask = ~(words_in_card - 1);\n-  min_size = (min_size + words_in_card - 1) & align_mask;\n-  word_size = (word_size + words_in_card - 1) & align_mask;\n+  \/\/ Align requested sizes to card-sized multiples.  Align down so that we don't violate max size of TLAB.\n+  min_size = align_down(min_size, CardTable::card_size_in_words());\n+  word_size = align_down(word_size, CardTable::card_size_in_words());\n+  assert(word_size >= min_size, \"Requested PLAB is too small\");\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -94,0 +94,4 @@\n+gc\/shenandoah\/TestHumongousThreshold.java#default 8327000 macosx-aarch64\n+gc\/shenandoah\/TestHumongousThreshold.java#16b 8327000 macosx-aarch64\n+gc\/shenandoah\/TestHumongousThreshold.java#generational 8327000 macosx-aarch64\n+gc\/shenandoah\/TestHumongousThreshold.java#generational-16b 8327000 macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}