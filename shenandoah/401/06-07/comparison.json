{"files":[{"patch":"@@ -220,3 +220,4 @@\n-  if (strcmp(ShenandoahGCMode, \"generational\") == 0) {\n-    ShenandoahGenerationalHeap* heap = new ShenandoahGenerationalHeap(new ShenandoahCollectorPolicy());\n-    CollectedHeap* result = heap;\n+  if (strcmp(ShenandoahGCMode, \"generational\") != 0) {\n+    \/\/ Not generational\n+    return new ShenandoahHeap(new ShenandoahCollectorPolicy());\n+  } else {\n@@ -228,2 +229,1 @@\n-    heap->initialize_plab_min_max(min_plab_size, max_plab_size);\n-    return result;\n+    return new ShenandoahGenerationalHeap(new ShenandoahCollectorPolicy(), min_plab_size, max_plab_size);\n@@ -231,1 +231,0 @@\n-  return new ShenandoahHeap(new ShenandoahCollectorPolicy());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-ShenandoahGenerationalHeap::ShenandoahGenerationalHeap(ShenandoahCollectorPolicy* policy) :\n+ShenandoahGenerationalHeap::ShenandoahGenerationalHeap(ShenandoahCollectorPolicy* policy, size_t min_plab, size_t max_plab) :\n@@ -80,0 +80,2 @@\n+  _min_plab_size(min_plab),\n+  _max_plab_size(max_plab),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-  size_t _min_plab_size;\n-  size_t _max_plab_size;\n+  const size_t _min_plab_size;\n+  const size_t _max_plab_size;\n@@ -39,1 +39,1 @@\n-  explicit ShenandoahGenerationalHeap(ShenandoahCollectorPolicy* policy);\n+  explicit ShenandoahGenerationalHeap(ShenandoahCollectorPolicy* policy, size_t min_plab, size_t max_plab);\n@@ -43,3 +43,2 @@\n-  void initialize_plab_min_max(size_t min, size_t max) { _min_plab_size = min; _max_plab_size = max; }\n-  inline size_t plab_min_size() { return _min_plab_size; }\n-  inline size_t plab_max_size() { return _max_plab_size; }\n+  inline size_t plab_min_size() const { return _min_plab_size; }\n+  inline size_t plab_max_size() const { return _max_plab_size; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1103,7 +1103,2 @@\n-  size_t plab_min_size = generational_heap->plab_min_size();\n-  size_t min_size;\n-  if (size > plab_min_size) {\n-    min_size = align_up(size, CardTable::card_size_in_words());\n-  } else {\n-    min_size = plab_min_size;\n-  }\n+  const size_t plab_min_size = generational_heap->plab_min_size();\n+  const size_t min_size = (size > plab_min_size)? align_up(size, CardTable::card_size_in_words()): plab_min_size;\n@@ -1118,7 +1113,6 @@\n-  size_t future_size = cur_size * 2;\n-  \/\/ Limit growth of PLABs to ShenandoahMaxEvacLABRatio * the minimum size.  This enables more equitable distribution of\n-  \/\/ available evacuation budget between the many threads that are coordinating in the evacuation effort.\n-  future_size = MIN2(future_size, generational_heap->plab_max_size());\n-  assert(is_aligned(future_size, CardTable::card_size_in_words()),\n-         \"Align by design, future_size: \" SIZE_FORMAT \", card_size: \" SIZE_FORMAT \", max_size: \" SIZE_FORMAT,\n-         future_size, (size_t) CardTable::card_size_in_words(), generational_heap->plab_max_size());\n+\n+  \/\/ Limit growth of PLABs to the smaller of ShenandoahMaxEvacLABRatio * the minimum size and ShenandoahHumongousThreshold.\n+  \/\/ This minimum value is represented by generational_heap->plab_max_size().  Enforcing this limit enables more equitable\n+  \/\/ distribution of available evacuation budget between the many threads that are coordinating in the evacuation effort.\n+  size_t future_size = MIN2(cur_size * 2, generational_heap->plab_max_size());\n+  assert(is_aligned(future_size, CardTable::card_size_in_words()), \"Align by design\");\n@@ -1211,2 +1205,2 @@\n-  size_t original_waste = plab->waste();\n-  HeapWord* top = plab->top();\n+  const size_t original_waste = plab->waste();\n+  HeapWord* const top = plab->top();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -354,2 +354,5 @@\n-  \/\/ Allocation (return nullptr if full)\n-  inline HeapWord* allocate_aligned(size_t word_size, ShenandoahAllocRequest &req, size_t alignment_in_words);\n+  \/\/ If next available memory is not aligned on address that is multiple of alignment, fill the empty space\n+  \/\/ so that returned object is aligned on an address that is a multiple of alignment_in_bytes.  Requested\n+  \/\/ size is in words.  It is assumed that this->is_old().  A pad object is allocated, filled, and registered\n+  \/\/ if necessary to assure the new allocation is properly aligned.  Return nullptr if memory is not available.\n+  inline HeapWord* allocate_aligned(size_t word_size, ShenandoahAllocRequest &req, size_t alignment_in_bytes);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,4 +35,0 @@\n-\/\/ If next available memory is not aligned on address that is multiple of alignment, fill the empty space\n-\/\/ so that returned object is aligned on an address that is a multiple of alignment_in_words.  Requested\n-\/\/ size is in words.  It is assumed that this->is_old().  A pad object is allocated, filled, and registered\n-\/\/ if necessary to assure the new allocation is properly aligned.\n@@ -44,0 +40,1 @@\n+  assert(is_aligned(alignment_in_bytes, HeapWordSize), \"Expect hea word alignment\");\n@@ -46,1 +43,0 @@\n-  size_t addr_as_int = (uintptr_t) orig_top;\n@@ -54,5 +50,3 @@\n-  if (pad_words > 0) {\n-    if (pad_words < ShenandoahHeap::min_fill_size()) {\n-      pad_words += alignment_in_words;\n-      aligned_obj += alignment_in_words;\n-    }\n+  if ((pad_words > 0) && (pad_words < ShenandoahHeap::min_fill_size())) {\n+    pad_words += alignment_in_words;\n+    aligned_obj += alignment_in_words;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"}]}