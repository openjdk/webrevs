{"files":[{"patch":"@@ -1103,1 +1103,0 @@\n-  size = align_up(size, CardTable::card_size_in_words());\n@@ -1105,1 +1104,6 @@\n-  size_t min_size = MAX2(size, plab_min_size);\n+  size_t min_size;\n+  if (size > plab_min_size) {\n+    min_size = align_up(size, CardTable::card_size_in_words());\n+  } else {\n+    min_size = plab_min_size;\n+  }\n@@ -1207,1 +1211,1 @@\n-  size_t waste = plab->waste();\n+  size_t original_waste = plab->waste();\n@@ -1210,1 +1214,1 @@\n-  if (top != nullptr && plab->waste() > waste && is_in_old(top)) {\n+  if (top != nullptr && plab->waste() > original_waste && is_in_old(top)) {\n@@ -1215,1 +1219,1 @@\n-                  plab->waste() - waste, p2i(top));\n+                  plab->waste() - original_waste, p2i(top));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  size_t alignment_in_words = alignment_in_bytes \/ HeapWordSize;\n@@ -48,2 +49,2 @@\n-  \/\/ unalignment_bytes is the amount by which current top() exceeds the desired alignment point.  We subtract this amount\n-  \/\/ from alignment_in_bytes to determine padding required to next alignment point.\n+  \/\/ unalignment_words is the amount by which current top() exceeds the desired alignment point.  We subtract this amount\n+  \/\/ from alignment_in_words to determine padding required to next alignment point.\n@@ -51,8 +52,3 @@\n-  \/\/ top is HeapWord-aligned so unalignment_bytes is a multiple of HeapWordSize\n-  size_t unalignment_bytes = addr_as_int % alignment_in_bytes;\n-  size_t unalignment_words = unalignment_bytes \/ HeapWordSize;\n-\n-  size_t pad_words;\n-  HeapWord* aligned_obj;\n-  if (unalignment_words > 0) {\n-    pad_words = (alignment_in_bytes \/ HeapWordSize) - unalignment_words;\n+  HeapWord* aligned_obj = (HeapWord*) align_up(orig_top, alignment_in_bytes);\n+  size_t pad_words = aligned_obj - orig_top;\n+  if (pad_words > 0) {\n@@ -60,1 +56,2 @@\n-      pad_words += (alignment_in_bytes \/ HeapWordSize);\n+      pad_words += alignment_in_words;\n+      aligned_obj += alignment_in_words;\n@@ -62,4 +59,0 @@\n-    aligned_obj = orig_top + pad_words;\n-  } else {\n-    pad_words = 0;\n-    aligned_obj = orig_top;\n@@ -69,0 +62,1 @@\n+    \/\/ Shrink size to fit within available space and align it\n@@ -70,8 +64,1 @@\n-    \/\/ Force size to align on multiple of alignment_in_bytes\n-    size_t byte_size = size * HeapWordSize;\n-    size_t excess_bytes = byte_size % alignment_in_bytes;\n-    \/\/ Note: excess_bytes is a multiple of HeapWordSize because it is the difference of HeapWord-aligned end\n-    \/\/       and proposed HeapWord-aligned object address.\n-    if (excess_bytes > 0) {\n-      size -= excess_bytes \/ HeapWordSize;\n-    }\n+    size = align_down(size, alignment_in_words);\n@@ -81,1 +68,1 @@\n-  assert ((size * HeapWordSize) % alignment_in_bytes == 0, \"Size must be multiple of alignment constraint\");\n+  assert (is_aligned(size, alignment_in_words), \"Size must be multiple of alignment constraint\");\n@@ -83,1 +70,1 @@\n-    \/\/ Even if req.min_size() is not a multiple of card size, we know that size is.\n+    \/\/ Even if req.min_size() may not be a multiple of card size, we know that size is.\n@@ -102,0 +89,1 @@\n+    \/\/ The aligned size that fits in this region is smaller than min_size, so don't align top and don't allocate.  Return failure.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":13,"deletions":25,"binary":false,"changes":38,"status":"modified"}]}