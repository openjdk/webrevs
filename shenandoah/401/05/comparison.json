{"files":[{"patch":"@@ -221,1 +221,9 @@\n-    return new ShenandoahGenerationalHeap(new ShenandoahCollectorPolicy());\n+    ShenandoahGenerationalHeap* heap = new ShenandoahGenerationalHeap(new ShenandoahCollectorPolicy());\n+    CollectedHeap* result = heap;\n+    size_t MaxTLABSizeWords = ShenandoahHeapRegion::max_tlab_size_words();\n+    size_t min_plab_size = align_up(PLAB::min_size(), CardTable::card_size_in_words());\n+    size_t max_plab_size = (ShenandoahMaxEvacLABRatio > 0)?\n+      align_down(MIN2(MaxTLABSizeWords, PLAB::min_size() * ShenandoahMaxEvacLABRatio), CardTable::card_size_in_words()):\n+      align_down(MaxTLABSizeWords, CardTable::card_size_in_words());\n+    heap->initialize_plab_min_max(min_plab_size, max_plab_size);\n+    return result;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -701,1 +701,1 @@\n-  assert(size % CardTable::card_size_in_words() == 0, \"size must be multiple of card table size, was \" SIZE_FORMAT, size);\n+  assert(is_aligned(size, CardTable::card_size_in_words()), \"Align by design\");\n@@ -707,1 +707,1 @@\n-  assert(((uintptr_t) result) % CardTable::card_size_in_words() == 0, \"PLAB start must align with card boundary\");\n+  assert(is_aligned(result, CardTable::card_size_in_words()), \"Align by design\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,4 @@\n+private:\n+  size_t _min_plab_size;\n+  size_t _max_plab_size;\n+\n@@ -39,0 +43,4 @@\n+  void initialize_plab_min_max(size_t min, size_t max) { _min_plab_size = min; _max_plab_size = max; }\n+  inline size_t plab_min_size() { return _min_plab_size; }\n+  inline size_t plab_max_size() { return _max_plab_size; }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -300,1 +301,1 @@\n-                              align_up(num_committed_regions, _bitmap_regions_per_slice) \/ _bitmap_regions_per_slice;\n+    align_up(num_committed_regions, _bitmap_regions_per_slice) \/ _bitmap_regions_per_slice;\n@@ -1099,1 +1100,0 @@\n-  size_t min_size = MAX2(size, PLAB::min_size());\n@@ -1101,1 +1101,13 @@\n-  \/\/ Figure out size of new PLAB, looking back at heuristics. Expand aggressively.\n+  assert(mode()->is_generational(), \"PLABs only relevant to generational GC\");\n+  ShenandoahGenerationalHeap* generational_heap = (ShenandoahGenerationalHeap*) this;\n+  size_t plab_min_size = generational_heap->plab_min_size();\n+  size_t min_size;\n+  if (size > plab_min_size) {\n+    min_size = align_up(size, CardTable::card_size_in_words());\n+  } else {\n+    min_size = plab_min_size;\n+  }\n+\n+  \/\/ Figure out size of new PLAB, looking back at heuristics. Expand aggressively.  PLABs must align on size\n+  \/\/ of card table in order to avoid the need for synchronization when registering newly allocated objects within\n+  \/\/ the card table.\n@@ -1104,1 +1116,1 @@\n-    cur_size = PLAB::min_size();\n+    cur_size = plab_min_size;\n@@ -1108,11 +1120,5 @@\n-  \/\/ available evacuation buidget between the many threads that are coordinating in the evacuation effort.\n-  if (ShenandoahMaxEvacLABRatio > 0) {\n-    future_size = MIN2(future_size, PLAB::min_size() * ShenandoahMaxEvacLABRatio);\n-  }\n-  future_size = MIN2(future_size, PLAB::max_size());\n-  future_size = MAX2(future_size, PLAB::min_size());\n-\n-  size_t unalignment = future_size % CardTable::card_size_in_words();\n-  if (unalignment != 0) {\n-    future_size = future_size - unalignment + CardTable::card_size_in_words();\n-  }\n+  \/\/ available evacuation budget between the many threads that are coordinating in the evacuation effort.\n+  future_size = MIN2(future_size, generational_heap->plab_max_size());\n+  assert(is_aligned(future_size, CardTable::card_size_in_words()),\n+         \"Align by design, future_size: \" SIZE_FORMAT \", card_size: \" SIZE_FORMAT \", max_size: \" SIZE_FORMAT,\n+         future_size, (size_t) CardTable::card_size_in_words(), generational_heap->plab_max_size());\n@@ -1133,1 +1139,1 @@\n-  if (plab->words_remaining() < PLAB::min_size()) {\n+  if (plab->words_remaining() < plab_min_size) {\n@@ -1154,1 +1160,1 @@\n-    assert (size <= actual_size, \"allocation should fit\");\n+    \/\/ Since the allocated PLAB may have been down-sized for alignment, plab->allocate(size) below may still fail.\n@@ -1168,0 +1174,1 @@\n+    assert(is_aligned(actual_size, CardTable::card_size_in_words()), \"Align by design\");\n@@ -1204,1 +1211,1 @@\n-  size_t waste = plab->waste();\n+  size_t original_waste = plab->waste();\n@@ -1206,0 +1213,3 @@\n+\n+  \/\/ plab->retire() overwrites unused memory between plab->top() and plab->hard_end() with a dummy object to make memory parsable.\n+  \/\/ It adds the size of this unused memory, in words, to plab->waste().\n@@ -1207,3 +1217,2 @@\n-  if (top != nullptr && plab->waste() > waste && is_in_old(top)) {\n-    \/\/ If retiring the plab created a filler object, then we\n-    \/\/ need to register it with our card scanner so it can\n+  if (top != nullptr && plab->waste() > original_waste && is_in_old(top)) {\n+    \/\/ If retiring the plab created a filler object, then we need to register it with our card scanner so it can\n@@ -1212,1 +1221,1 @@\n-                  plab->waste() - waste, p2i(top));\n+                  plab->waste() - original_waste, p2i(top));\n@@ -1373,8 +1382,8 @@\n-HeapWord* ShenandoahHeap::allocate_new_plab(size_t min_size,\n-                                            size_t word_size,\n-                                            size_t* actual_size) {\n-  \/\/ Align requested sizes to card sized multiples\n-  size_t words_in_card = CardTable::card_size_in_words();\n-  size_t align_mask = ~(words_in_card - 1);\n-  min_size = (min_size + words_in_card - 1) & align_mask;\n-  word_size = (word_size + words_in_card - 1) & align_mask;\n+HeapWord* ShenandoahHeap::allocate_new_plab(size_t min_size, size_t word_size, size_t* actual_size) {\n+  \/\/ Align requested sizes to card-sized multiples.  Align down so that we don't violate max size of TLAB.\n+  assert(is_aligned(min_size, CardTable::card_size_in_words()),\n+         \"Align by design, min_size: \" SIZE_FORMAT \", card_size: \" SIZE_FORMAT,\n+         min_size, (size_t) CardTable::card_size_in_words());\n+  assert(is_aligned(word_size, CardTable::card_size_in_words()), \"Align by design\");\n+  assert(word_size >= min_size, \"Requested PLAB is too small\");\n+\n@@ -1390,0 +1399,1 @@\n+  assert(is_aligned(res, CardTable::card_size_in_words()), \"Align by design\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":40,"deletions":30,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  size_t alignment_in_words = alignment_in_bytes \/ HeapWordSize;\n@@ -48,2 +49,2 @@\n-  \/\/ unalignment_bytes is the amount by which current top() exceeds the desired alignment point.  We subtract this amount\n-  \/\/ from alignment_in_bytes to determine padding required to next alignment point.\n+  \/\/ unalignment_words is the amount by which current top() exceeds the desired alignment point.  We subtract this amount\n+  \/\/ from alignment_in_words to determine padding required to next alignment point.\n@@ -51,8 +52,3 @@\n-  \/\/ top is HeapWord-aligned so unalignment_bytes is a multiple of HeapWordSize\n-  size_t unalignment_bytes = addr_as_int % alignment_in_bytes;\n-  size_t unalignment_words = unalignment_bytes \/ HeapWordSize;\n-\n-  size_t pad_words;\n-  HeapWord* aligned_obj;\n-  if (unalignment_words > 0) {\n-    pad_words = (alignment_in_bytes \/ HeapWordSize) - unalignment_words;\n+  HeapWord* aligned_obj = (HeapWord*) align_up(orig_top, alignment_in_bytes);\n+  size_t pad_words = aligned_obj - orig_top;\n+  if (pad_words > 0) {\n@@ -60,1 +56,2 @@\n-      pad_words += (alignment_in_bytes \/ HeapWordSize);\n+      pad_words += alignment_in_words;\n+      aligned_obj += alignment_in_words;\n@@ -62,4 +59,0 @@\n-    aligned_obj = orig_top + pad_words;\n-  } else {\n-    pad_words = 0;\n-    aligned_obj = orig_top;\n@@ -69,0 +62,1 @@\n+    \/\/ Shrink size to fit within available space and align it\n@@ -70,8 +64,1 @@\n-    \/\/ Force size to align on multiple of alignment_in_bytes\n-    size_t byte_size = size * HeapWordSize;\n-    size_t excess_bytes = byte_size % alignment_in_bytes;\n-    \/\/ Note: excess_bytes is a multiple of HeapWordSize because it is the difference of HeapWord-aligned end\n-    \/\/       and proposed HeapWord-aligned object address.\n-    if (excess_bytes > 0) {\n-      size -= excess_bytes \/ HeapWordSize;\n-    }\n+    size = align_down(size, alignment_in_words);\n@@ -81,1 +68,1 @@\n-  assert ((size * HeapWordSize) % alignment_in_bytes == 0, \"Size must be multiple of alignment constraint\");\n+  assert (is_aligned(size, alignment_in_words), \"Size must be multiple of alignment constraint\");\n@@ -83,1 +70,1 @@\n-    \/\/ Even if req.min_size() is not a multiple of card size, we know that size is.\n+    \/\/ Even if req.min_size() may not be a multiple of card size, we know that size is.\n@@ -102,0 +89,1 @@\n+    \/\/ The aligned size that fits in this region is smaller than min_size, so don't align top and don't allocate.  Return failure.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":13,"deletions":25,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -94,0 +94,4 @@\n+gc\/shenandoah\/TestHumongousThreshold.java#default 8327000 generic-all\n+gc\/shenandoah\/TestHumongousThreshold.java#16b 8327000 generic-all\n+gc\/shenandoah\/TestHumongousThreshold.java#generational 8327000 generic-all\n+gc\/shenandoah\/TestHumongousThreshold.java#generational-16b 8327000 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}