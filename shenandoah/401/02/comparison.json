{"files":[{"patch":"@@ -221,1 +221,9 @@\n-    return new ShenandoahGenerationalHeap(new ShenandoahCollectorPolicy());\n+    ShenandoahGenerationalHeap* heap = new ShenandoahGenerationalHeap(new ShenandoahCollectorPolicy());\n+    CollectedHeap* result = heap;\n+    size_t MaxTLABSizeWords = ShenandoahHeapRegion::max_tlab_size_words();\n+    size_t min_plab_size = align_up(PLAB::min_size(), CardTable::card_size_in_words());\n+    size_t max_plab_size = (ShenandoahMaxEvacLABRatio > 0)?\n+      align_down(MIN2(MaxTLABSizeWords, PLAB::min_size() * ShenandoahMaxEvacLABRatio), CardTable::card_size_in_words()):\n+      align_down(MaxTLABSizeWords, CardTable::card_size_in_words());\n+    heap->initialize_plab_min_max(min_plab_size, max_plab_size);\n+    return result;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -701,1 +701,1 @@\n-  assert(size % CardTable::card_size_in_words() == 0, \"size must be multiple of card table size, was \" SIZE_FORMAT, size);\n+  assert(is_aligned(size, CardTable::card_size_in_words()), \"Align by design\");\n@@ -707,1 +707,1 @@\n-  assert(((uintptr_t) result) % CardTable::card_size_in_words() == 0, \"PLAB start must align with card boundary\");\n+  assert(is_aligned(result, CardTable::card_size_in_words()), \"Align by design\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,4 @@\n+private:\n+  size_t _min_plab_size;\n+  size_t _max_plab_size;\n+\n@@ -39,0 +43,4 @@\n+  void initialize_plab_min_max(size_t min, size_t max) { _min_plab_size = min; _max_plab_size = max; }\n+  inline size_t plab_min_size() { return _min_plab_size; }\n+  inline size_t plab_max_size() { return _max_plab_size; }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -300,1 +301,1 @@\n-                              align_up(num_committed_regions, _bitmap_regions_per_slice) \/ _bitmap_regions_per_slice;\n+    align_up(num_committed_regions, _bitmap_regions_per_slice) \/ _bitmap_regions_per_slice;\n@@ -1099,1 +1100,0 @@\n-  size_t min_size = MAX2(size, PLAB::min_size());\n@@ -1101,1 +1101,8 @@\n-  \/\/ Figure out size of new PLAB, looking back at heuristics. Expand aggressively.\n+  assert(mode()->is_generational(), \"PLABs only relevant to generational GC\");\n+  ShenandoahGenerationalHeap* generational_heap = (ShenandoahGenerationalHeap*) this;\n+  size_t plab_min_size = generational_heap->plab_min_size();\n+  size_t min_size = MAX2(size, plab_min_size);\n+\n+  \/\/ Figure out size of new PLAB, looking back at heuristics. Expand aggressively.  PLABs must align on size\n+  \/\/ of card table in order to avoid the need for synchronization when registering newly allocated objects within\n+  \/\/ the card table.\n@@ -1104,1 +1111,1 @@\n-    cur_size = PLAB::min_size();\n+    cur_size = plab_min_size;\n@@ -1108,11 +1115,3 @@\n-  \/\/ available evacuation buidget between the many threads that are coordinating in the evacuation effort.\n-  if (ShenandoahMaxEvacLABRatio > 0) {\n-    future_size = MIN2(future_size, PLAB::min_size() * ShenandoahMaxEvacLABRatio);\n-  }\n-  future_size = MIN2(future_size, PLAB::max_size());\n-  future_size = MAX2(future_size, PLAB::min_size());\n-\n-  size_t unalignment = future_size % CardTable::card_size_in_words();\n-  if (unalignment != 0) {\n-    future_size = future_size - unalignment + CardTable::card_size_in_words();\n-  }\n+  \/\/ available evacuation budget between the many threads that are coordinating in the evacuation effort.\n+  future_size = MIN2(future_size, generational_heap->plab_max_size());\n+  assert(is_aligned(future_size, CardTable::card_size_in_words()), \"Should align by design\");\n@@ -1154,1 +1153,1 @@\n-    assert (size <= actual_size, \"allocation should fit\");\n+    \/\/ Since the allocated PLAB may have been down-sized for alignment, plab->allocate(size) below may still fail.\n@@ -1168,0 +1167,1 @@\n+    assert(is_aligned(actual_size, CardTable::card_size_in_words()), \"Align by design\");\n@@ -1373,8 +1373,6 @@\n-HeapWord* ShenandoahHeap::allocate_new_plab(size_t min_size,\n-                                            size_t word_size,\n-                                            size_t* actual_size) {\n-  \/\/ Align requested sizes to card sized multiples\n-  size_t words_in_card = CardTable::card_size_in_words();\n-  size_t align_mask = ~(words_in_card - 1);\n-  min_size = (min_size + words_in_card - 1) & align_mask;\n-  word_size = (word_size + words_in_card - 1) & align_mask;\n+HeapWord* ShenandoahHeap::allocate_new_plab(size_t min_size, size_t word_size, size_t* actual_size) {\n+  \/\/ Align requested sizes to card-sized multiples.  Align down so that we don't violate max size of TLAB.\n+  assert(is_aligned(min_size, CardTable::card_size_in_words()), \"Align by design\");\n+  assert(is_aligned(word_size, CardTable::card_size_in_words()), \"Align by design\");\n+  assert(word_size >= min_size, \"Requested PLAB is too small\");\n+\n@@ -1390,0 +1388,1 @@\n+  assert(is_aligned(res, CardTable::card_size_in_words()), \"Align by design\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":23,"deletions":24,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -94,0 +94,4 @@\n+gc\/shenandoah\/TestHumongousThreshold.java#default 8327000 generic-all\n+gc\/shenandoah\/TestHumongousThreshold.java#16b 8327000 generic-all\n+gc\/shenandoah\/TestHumongousThreshold.java#generational 8327000 generic-all\n+gc\/shenandoah\/TestHumongousThreshold.java#generational-16b 8327000 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}