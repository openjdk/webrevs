{"files":[{"patch":"@@ -220,2 +220,10 @@\n-  if (strcmp(ShenandoahGCMode, \"generational\") == 0) {\n-    return new ShenandoahGenerationalHeap(new ShenandoahCollectorPolicy());\n+  if (strcmp(ShenandoahGCMode, \"generational\") != 0) {\n+    \/\/ Not generational\n+    return new ShenandoahHeap(new ShenandoahCollectorPolicy());\n+  } else {\n+    size_t MaxTLABSizeWords = ShenandoahHeapRegion::max_tlab_size_words();\n+    size_t min_plab_size = align_up(PLAB::min_size(), CardTable::card_size_in_words());\n+    size_t max_plab_size = (ShenandoahMaxEvacLABRatio > 0)?\n+      align_down(MIN2(MaxTLABSizeWords, PLAB::min_size() * ShenandoahMaxEvacLABRatio), CardTable::card_size_in_words()):\n+      align_down(MaxTLABSizeWords, CardTable::card_size_in_words());\n+    return new ShenandoahGenerationalHeap(new ShenandoahCollectorPolicy(), min_plab_size, max_plab_size);\n@@ -223,1 +231,0 @@\n-  return new ShenandoahHeap(new ShenandoahCollectorPolicy());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -701,1 +701,1 @@\n-  assert(size % CardTable::card_size_in_words() == 0, \"size must be multiple of card table size, was \" SIZE_FORMAT, size);\n+  assert(is_aligned(size, CardTable::card_size_in_words()), \"Align by design\");\n@@ -707,1 +707,1 @@\n-  assert(((uintptr_t) result) % CardTable::card_size_in_words() == 0, \"PLAB start must align with card boundary\");\n+  assert(is_aligned(result, CardTable::card_size_in_words()), \"Align by design\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-ShenandoahGenerationalHeap::ShenandoahGenerationalHeap(ShenandoahCollectorPolicy* policy) :\n+ShenandoahGenerationalHeap::ShenandoahGenerationalHeap(ShenandoahCollectorPolicy* policy, size_t min_plab, size_t max_plab) :\n@@ -80,0 +80,2 @@\n+  _min_plab_size(min_plab),\n+  _max_plab_size(max_plab),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,4 @@\n+private:\n+  const size_t _min_plab_size;\n+  const size_t _max_plab_size;\n+\n@@ -35,1 +39,1 @@\n-  explicit ShenandoahGenerationalHeap(ShenandoahCollectorPolicy* policy);\n+  explicit ShenandoahGenerationalHeap(ShenandoahCollectorPolicy* policy, size_t min_plab, size_t max_plab);\n@@ -39,0 +43,3 @@\n+  inline size_t plab_min_size() const { return _min_plab_size; }\n+  inline size_t plab_max_size() const { return _max_plab_size; }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -300,1 +301,1 @@\n-                              align_up(num_committed_regions, _bitmap_regions_per_slice) \/ _bitmap_regions_per_slice;\n+    align_up(num_committed_regions, _bitmap_regions_per_slice) \/ _bitmap_regions_per_slice;\n@@ -1099,1 +1100,0 @@\n-  size_t min_size = MAX2(size, PLAB::min_size());\n@@ -1101,1 +1101,8 @@\n-  \/\/ Figure out size of new PLAB, looking back at heuristics. Expand aggressively.\n+  assert(mode()->is_generational(), \"PLABs only relevant to generational GC\");\n+  ShenandoahGenerationalHeap* generational_heap = (ShenandoahGenerationalHeap*) this;\n+  const size_t plab_min_size = generational_heap->plab_min_size();\n+  const size_t min_size = (size > plab_min_size)? align_up(size, CardTable::card_size_in_words()): plab_min_size;\n+\n+  \/\/ Figure out size of new PLAB, looking back at heuristics. Expand aggressively.  PLABs must align on size\n+  \/\/ of card table in order to avoid the need for synchronization when registering newly allocated objects within\n+  \/\/ the card table.\n@@ -1104,7 +1111,1 @@\n-    cur_size = PLAB::min_size();\n-  }\n-  size_t future_size = cur_size * 2;\n-  \/\/ Limit growth of PLABs to ShenandoahMaxEvacLABRatio * the minimum size.  This enables more equitable distribution of\n-  \/\/ available evacuation buidget between the many threads that are coordinating in the evacuation effort.\n-  if (ShenandoahMaxEvacLABRatio > 0) {\n-    future_size = MIN2(future_size, PLAB::min_size() * ShenandoahMaxEvacLABRatio);\n+    cur_size = plab_min_size;\n@@ -1112,2 +1113,0 @@\n-  future_size = MIN2(future_size, PLAB::max_size());\n-  future_size = MAX2(future_size, PLAB::min_size());\n@@ -1115,4 +1114,5 @@\n-  size_t unalignment = future_size % CardTable::card_size_in_words();\n-  if (unalignment != 0) {\n-    future_size = future_size - unalignment + CardTable::card_size_in_words();\n-  }\n+  \/\/ Limit growth of PLABs to the smaller of ShenandoahMaxEvacLABRatio * the minimum size and ShenandoahHumongousThreshold.\n+  \/\/ This minimum value is represented by generational_heap->plab_max_size().  Enforcing this limit enables more equitable\n+  \/\/ distribution of available evacuation budget between the many threads that are coordinating in the evacuation effort.\n+  size_t future_size = MIN2(cur_size * 2, generational_heap->plab_max_size());\n+  assert(is_aligned(future_size, CardTable::card_size_in_words()), \"Align by design\");\n@@ -1133,1 +1133,1 @@\n-  if (plab->words_remaining() < PLAB::min_size()) {\n+  if (plab->words_remaining() < plab_min_size) {\n@@ -1145,1 +1145,1 @@\n-      if (min_size == PLAB::min_size()) {\n+      if (min_size == plab_min_size) {\n@@ -1154,1 +1154,1 @@\n-    assert (size <= actual_size, \"allocation should fit\");\n+    \/\/ Since the allocated PLAB may have been down-sized for alignment, plab->allocate(size) below may still fail.\n@@ -1168,0 +1168,1 @@\n+    assert(is_aligned(actual_size, CardTable::card_size_in_words()), \"Align by design\");\n@@ -1204,2 +1205,5 @@\n-  size_t waste = plab->waste();\n-  HeapWord* top = plab->top();\n+  const size_t original_waste = plab->waste();\n+  HeapWord* const top = plab->top();\n+\n+  \/\/ plab->retire() overwrites unused memory between plab->top() and plab->hard_end() with a dummy object to make memory parsable.\n+  \/\/ It adds the size of this unused memory, in words, to plab->waste().\n@@ -1207,3 +1211,2 @@\n-  if (top != nullptr && plab->waste() > waste && is_in_old(top)) {\n-    \/\/ If retiring the plab created a filler object, then we\n-    \/\/ need to register it with our card scanner so it can\n+  if (top != nullptr && plab->waste() > original_waste && is_in_old(top)) {\n+    \/\/ If retiring the plab created a filler object, then we need to register it with our card scanner so it can\n@@ -1212,1 +1215,1 @@\n-                  plab->waste() - waste, p2i(top));\n+                  plab->waste() - original_waste, p2i(top));\n@@ -1373,8 +1376,8 @@\n-HeapWord* ShenandoahHeap::allocate_new_plab(size_t min_size,\n-                                            size_t word_size,\n-                                            size_t* actual_size) {\n-  \/\/ Align requested sizes to card sized multiples\n-  size_t words_in_card = CardTable::card_size_in_words();\n-  size_t align_mask = ~(words_in_card - 1);\n-  min_size = (min_size + words_in_card - 1) & align_mask;\n-  word_size = (word_size + words_in_card - 1) & align_mask;\n+HeapWord* ShenandoahHeap::allocate_new_plab(size_t min_size, size_t word_size, size_t* actual_size) {\n+  \/\/ Align requested sizes to card-sized multiples.  Align down so that we don't violate max size of TLAB.\n+  assert(is_aligned(min_size, CardTable::card_size_in_words()),\n+         \"Align by design, min_size: \" SIZE_FORMAT \", card_size: \" SIZE_FORMAT,\n+         min_size, (size_t) CardTable::card_size_in_words());\n+  assert(is_aligned(word_size, CardTable::card_size_in_words()), \"Align by design\");\n+  assert(word_size >= min_size, \"Requested PLAB is too small\");\n+\n@@ -1390,0 +1393,1 @@\n+  assert(is_aligned(res, CardTable::card_size_in_words()), \"Align by design\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":37,"deletions":33,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -420,1 +420,2 @@\n-               ShenandoahThreadLocalData::set_plab_size(thread, PLAB::min_size());\n+               size_t plab_min_size = ((ShenandoahGenerationalHeap*) this)->plab_min_size();\n+               ShenandoahThreadLocalData::set_plab_size(thread, plab_min_size);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -354,2 +354,5 @@\n-  \/\/ Allocation (return nullptr if full)\n-  inline HeapWord* allocate_aligned(size_t word_size, ShenandoahAllocRequest &req, size_t alignment_in_words);\n+  \/\/ If next available memory is not aligned on address that is multiple of alignment, fill the empty space\n+  \/\/ so that returned object is aligned on an address that is a multiple of alignment_in_bytes.  Requested\n+  \/\/ size is in words.  It is assumed that this->is_old().  A pad object is allocated, filled, and registered\n+  \/\/ if necessary to assure the new allocation is properly aligned.  Return nullptr if memory is not available.\n+  inline HeapWord* allocate_aligned(size_t word_size, ShenandoahAllocRequest &req, size_t alignment_in_bytes);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,4 +35,0 @@\n-\/\/ If next available memory is not aligned on address that is multiple of alignment, fill the empty space\n-\/\/ so that returned object is aligned on an address that is a multiple of alignment_in_words.  Requested\n-\/\/ size is in words.  It is assumed that this->is_old().  A pad object is allocated, filled, and registered\n-\/\/ if necessary to assure the new allocation is properly aligned.\n@@ -44,0 +40,1 @@\n+  assert(is_aligned(alignment_in_bytes, HeapWordSize), \"Expect hea word alignment\");\n@@ -46,1 +43,1 @@\n-  size_t addr_as_int = (uintptr_t) orig_top;\n+  size_t alignment_in_words = alignment_in_bytes \/ HeapWordSize;\n@@ -48,2 +45,2 @@\n-  \/\/ unalignment_bytes is the amount by which current top() exceeds the desired alignment point.  We subtract this amount\n-  \/\/ from alignment_in_bytes to determine padding required to next alignment point.\n+  \/\/ unalignment_words is the amount by which current top() exceeds the desired alignment point.  We subtract this amount\n+  \/\/ from alignment_in_words to determine padding required to next alignment point.\n@@ -51,15 +48,5 @@\n-  \/\/ top is HeapWord-aligned so unalignment_bytes is a multiple of HeapWordSize\n-  size_t unalignment_bytes = addr_as_int % alignment_in_bytes;\n-  size_t unalignment_words = unalignment_bytes \/ HeapWordSize;\n-\n-  size_t pad_words;\n-  HeapWord* aligned_obj;\n-  if (unalignment_words > 0) {\n-    pad_words = (alignment_in_bytes \/ HeapWordSize) - unalignment_words;\n-    if (pad_words < ShenandoahHeap::min_fill_size()) {\n-      pad_words += (alignment_in_bytes \/ HeapWordSize);\n-    }\n-    aligned_obj = orig_top + pad_words;\n-  } else {\n-    pad_words = 0;\n-    aligned_obj = orig_top;\n+  HeapWord* aligned_obj = (HeapWord*) align_up(orig_top, alignment_in_bytes);\n+  size_t pad_words = aligned_obj - orig_top;\n+  if ((pad_words > 0) && (pad_words < ShenandoahHeap::min_fill_size())) {\n+    pad_words += alignment_in_words;\n+    aligned_obj += alignment_in_words;\n@@ -69,0 +56,1 @@\n+    \/\/ Shrink size to fit within available space and align it\n@@ -70,8 +58,1 @@\n-    \/\/ Force size to align on multiple of alignment_in_bytes\n-    size_t byte_size = size * HeapWordSize;\n-    size_t excess_bytes = byte_size % alignment_in_bytes;\n-    \/\/ Note: excess_bytes is a multiple of HeapWordSize because it is the difference of HeapWord-aligned end\n-    \/\/       and proposed HeapWord-aligned object address.\n-    if (excess_bytes > 0) {\n-      size -= excess_bytes \/ HeapWordSize;\n-    }\n+    size = align_down(size, alignment_in_words);\n@@ -81,1 +62,1 @@\n-  assert ((size * HeapWordSize) % alignment_in_bytes == 0, \"Size must be multiple of alignment constraint\");\n+  assert (is_aligned(size, alignment_in_words), \"Size must be multiple of alignment constraint\");\n@@ -83,1 +64,1 @@\n-    \/\/ Even if req.min_size() is not a multiple of card size, we know that size is.\n+    \/\/ Even if req.min_size() may not be a multiple of card size, we know that size is.\n@@ -102,0 +83,1 @@\n+    \/\/ The aligned size that fits in this region is smaller than min_size, so don't align top and don't allocate.  Return failure.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":14,"deletions":32,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -36,0 +37,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -110,1 +112,4 @@\n-    data(thread)->_plab = new PLAB(PLAB::min_size());\n+\n+    \/\/ In theory, plabs are only need if heap->mode()->is_generational().  However, some threads are apparently\n+    \/\/ instantiated before we are able to answer that question.\n+    data(thread)->_plab = new PLAB(align_up(PLAB::min_size(), CardTable::card_size_in_words()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -94,0 +94,4 @@\n+gc\/shenandoah\/TestHumongousThreshold.java#default 8327000 generic-all\n+gc\/shenandoah\/TestHumongousThreshold.java#16b 8327000 generic-all\n+gc\/shenandoah\/TestHumongousThreshold.java#generational 8327000 generic-all\n+gc\/shenandoah\/TestHumongousThreshold.java#generational-16b 8327000 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}