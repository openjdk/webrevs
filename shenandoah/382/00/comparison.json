{"files":[{"patch":"@@ -65,1 +65,1 @@\n-  _requested_gc_cause(GCCause::_no_cause_specified),\n+  _requested_gc_cause(GCCause::_no_gc),\n@@ -99,1 +99,0 @@\n-  GCCause::Cause default_cause = GCCause::_shenandoah_concurrent_gc;\n@@ -121,4 +120,4 @@\n-    bool is_gc_requested = _gc_requested.is_set();\n-    GCCause::Cause requested_gc_cause = _requested_gc_cause;\n-    bool explicit_gc_requested = is_gc_requested && is_explicit_gc(requested_gc_cause);\n-    bool implicit_gc_requested = is_gc_requested && is_implicit_gc(requested_gc_cause);\n+    GCCause::Cause cause = Atomic::xchg(&_requested_gc_cause, GCCause::_no_gc);\n+\n+    bool explicit_gc_requested = is_explicit_gc(cause);\n+    bool implicit_gc_requested = is_implicit_gc(cause);\n@@ -134,1 +133,0 @@\n-    GCCause::Cause cause = GCCause::_last_gc_cause;\n@@ -178,1 +176,0 @@\n-      cause = requested_gc_cause;\n@@ -194,1 +191,0 @@\n-      cause = requested_gc_cause;\n@@ -213,1 +209,1 @@\n-      if (_requested_gc_cause == GCCause::_shenandoah_concurrent_gc) {\n+      if (cause == GCCause::_shenandoah_concurrent_gc) {\n@@ -223,0 +219,1 @@\n+\n@@ -224,1 +221,0 @@\n-        cause = GCCause::_shenandoah_concurrent_gc;\n@@ -237,6 +233,0 @@\n-\n-        \/\/ Don't want to spin in this loop and start a cycle every time, so\n-        \/\/ clear requested gc cause. This creates a race with callers of the\n-        \/\/ blocking 'request_gc' method, but there it loops and resets the\n-        \/\/ '_requested_gc_cause' until a full cycle is completed.\n-        _requested_gc_cause = GCCause::_no_gc;\n@@ -257,6 +247,0 @@\n-    \/\/ Blow all soft references on this cycle, if handling allocation failure,\n-    \/\/ either implicit or explicit GC request, or we are requested to do so unconditionally.\n-    if (generation == select_global_generation() && (alloc_failure_pending || implicit_gc_requested || explicit_gc_requested || ShenandoahAlwaysClearSoftRefs)) {\n-      heap->soft_ref_policy()->set_should_clear_all_soft_refs(true);\n-    }\n-\n@@ -264,1 +248,1 @@\n-    assert (!gc_requested || cause != GCCause::_last_gc_cause, \"GC cause should be set\");\n+    assert (!gc_requested || cause != GCCause::_no_gc, \"GC cause should be set\");\n@@ -267,0 +251,6 @@\n+      \/\/ Blow away all soft references on this cycle, if handling allocation failure,\n+      \/\/ either implicit or explicit GC request, or we are requested to do so unconditionally.\n+      if (generation == select_global_generation() && (alloc_failure_pending || implicit_gc_requested || explicit_gc_requested || ShenandoahAlwaysClearSoftRefs)) {\n+        heap->soft_ref_policy()->set_should_clear_all_soft_refs(true);\n+      }\n+\n@@ -372,1 +362,1 @@\n-      \/\/ Allow allocators to know we have seen this much regions\n+      \/\/ Allow pacer to know we have seen this many allocations\n@@ -398,2 +388,2 @@\n-    \/\/ Don't wait around if there was an allocation failure - start the next cycle immediately.\n-    if (!is_alloc_failure_gc()) {\n+    \/\/ Don't wait if there was an allocation failure or another request was made mid-cycle.\n+    if (!is_alloc_failure_gc() && _requested_gc_cause == GCCause::_no_gc) {\n@@ -868,1 +858,1 @@\n-  if (_preemption_requested.is_set() || _gc_requested.is_set() || ShenandoahHeap::heap()->cancelled_gc()) {\n+  if (_preemption_requested.is_set() || _requested_gc_cause != GCCause::_no_gc || ShenandoahHeap::heap()->cancelled_gc()) {\n@@ -872,1 +862,1 @@\n-                          BOOL_TO_STR(_gc_requested.is_set()),\n+                          GCCause::to_string(_requested_gc_cause),\n@@ -878,1 +868,6 @@\n-    _requested_gc_cause = GCCause::_shenandoah_concurrent_gc;\n+    GCCause::Cause existing = Atomic::cmpxchg(&_requested_gc_cause, GCCause::_no_gc, GCCause::_shenandoah_concurrent_gc);\n+    if (existing != GCCause::_no_gc) {\n+      log_debug(gc, thread)(\"Reject request for concurrent gc because another gc is pending: %s\", GCCause::to_string(existing));\n+      return false;\n+    }\n+\n@@ -890,1 +885,0 @@\n-    log_info(gc)(\"Preempting old generation mark to allow %s GC\", shenandoah_generation_name(generation));\n@@ -892,2 +886,7 @@\n-    _requested_gc_cause = GCCause::_shenandoah_concurrent_gc;\n-    _requested_generation = generation;\n+    GCCause::Cause existing = Atomic::cmpxchg(&_requested_gc_cause, GCCause::_no_gc, GCCause::_shenandoah_concurrent_gc);\n+    if (existing != GCCause::_no_gc) {\n+      log_debug(gc, thread)(\"Reject request to interrupt old gc because another gc is pending: %s\", GCCause::to_string(existing));\n+      return false;\n+    }\n+\n+    log_info(gc)(\"Preempting old generation mark to allow %s GC\", shenandoah_generation_name(generation));\n@@ -935,4 +934,7 @@\n-    \/\/ does not take the lock. We need to enforce following order, so that read side sees\n-    \/\/ latest requested gc cause when the flag is set.\n-    _requested_gc_cause = cause;\n-    _gc_requested.set();\n+    \/\/ does not take the lock. This races with the regulator thread to start a concurrent gc\n+    \/\/ and the control thread to clear it at the start of a cycle.\n+    GCCause::Cause existing = Atomic::xchg(&_requested_gc_cause, cause);\n+    if (existing != GCCause::_no_gc) {\n+      log_debug(gc, thread)(\"GC request supersedes existing request: %s\", GCCause::to_string(existing));\n+    }\n+\n@@ -1003,4 +1005,0 @@\n-bool ShenandoahControlThread::is_humongous_alloc_failure_gc() {\n-  return _humongous_alloc_failure_gc.is_set();\n-}\n-\n@@ -1008,1 +1006,0 @@\n-  _gc_requested.unset();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":39,"deletions":42,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -89,1 +89,0 @@\n-  ShenandoahSharedFlag _gc_requested;\n@@ -95,2 +94,3 @@\n-  GCCause::Cause       _requested_gc_cause;\n-  ShenandoahGenerationType _requested_generation;\n+\n+  GCCause::Cause  _requested_gc_cause;\n+  volatile ShenandoahGenerationType _requested_generation;\n@@ -127,3 +127,0 @@\n-  \/\/ True if humongous allocation failure flag has been set.\n-  bool is_humongous_alloc_failure_gc();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"}]}