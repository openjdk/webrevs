{"files":[{"patch":"@@ -81,0 +81,4 @@\n+\n+      if (ShenandoahCardBarrier) {\n+        post_barrier(access, access.resolved_addr(), new_value.result());\n+      }\n@@ -84,0 +88,1 @@\n+\n@@ -108,0 +113,3 @@\n+    if (ShenandoahCardBarrier) {\n+      post_barrier(access, access.resolved_addr(), result);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_riscv.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shenandoah\/mode\/shenandoahMode.hpp\"\n@@ -84,0 +85,7 @@\n+void ShenandoahBarrierSetAssembler::arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                                       Register start, Register count, Register tmp, RegSet saved_regs) {\n+  if (ShenandoahCardBarrier && is_oop) {\n+    gen_write_ref_array_post_barrier(masm, decorators, start, count, tmp, saved_regs);\n+  }\n+}\n+\n@@ -385,0 +393,21 @@\n+void ShenandoahBarrierSetAssembler::store_check(MacroAssembler* masm, Register obj) {\n+  assert(ShenandoahCardBarrier, \"Did you mean to enable ShenandoahCardBarrier?\");\n+\n+  __ srli(obj, obj, CardTable::card_shift());\n+\n+  assert(CardTable::dirty_card_val() == 0, \"must be\");\n+\n+  __ load_byte_map_base(t1);\n+  __ add(t1, obj, t1);\n+\n+  if (UseCondCardMark) {\n+    Label L_already_dirty;\n+    __ lbu(t0, Address(t1));\n+    __ beqz(t0, L_already_dirty);\n+    __ sb(zr, Address(t1));\n+    __ bind(L_already_dirty);\n+  } else {\n+    __ sb(zr, Address(t1));\n+  }\n+}\n+\n@@ -410,10 +439,6 @@\n-  if (val == noreg) {\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp3, 0), noreg, noreg, noreg, noreg);\n-  } else {\n-    \/\/ Barrier needs uncompressed oop for region cross check.\n-    Register new_val = val;\n-    if (UseCompressedOops) {\n-      new_val = t1;\n-      __ mv(new_val, val);\n-    }\n-    BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp3, 0), val, noreg, noreg, noreg);\n+  BarrierSetAssembler::store_at(masm, decorators, type, Address(tmp3, 0), val, noreg, noreg, noreg);\n+\n+  bool in_heap = (decorators & IN_HEAP) != 0;\n+  bool needs_post_barrier = (val != noreg) && in_heap && ShenandoahCardBarrier;\n+  if (needs_post_barrier) {\n+    store_check(masm, tmp3);\n@@ -527,0 +552,31 @@\n+void ShenandoahBarrierSetAssembler::gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                                                     Register start, Register count, Register tmp, RegSet saved_regs) {\n+  assert(ShenandoahCardBarrier, \"Did you mean to enable ShenandoahCardBarrier?\");\n+\n+  Label L_loop, L_done;\n+  const Register end = count;\n+\n+  \/\/ Zero count? Nothing to do.\n+  __ beqz(count, L_done);\n+\n+  \/\/ end = start + count << LogBytesPerHeapOop\n+  \/\/ last element address to make inclusive\n+  __ shadd(end, count, start, tmp, LogBytesPerHeapOop);\n+  __ sub(end, end, BytesPerHeapOop);\n+  __ srli(start, start, CardTable::card_shift());\n+  __ srli(end, end, CardTable::card_shift());\n+\n+  \/\/ number of bytes to copy\n+  __ sub(count, end, start);\n+\n+  __ load_byte_map_base(tmp);\n+  __ add(start, start, tmp);\n+\n+  __ bind(L_loop);\n+  __ add(tmp, start, count);\n+  __ sb(zr, Address(tmp));\n+  __ sub(count, count, 1);\n+  __ bgez(count, L_loop);\n+  __ bind(L_done);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.cpp","additions":66,"deletions":10,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+  void store_check(MacroAssembler* masm, Register obj);\n+\n@@ -64,0 +66,4 @@\n+  void gen_write_ref_array_post_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                                        Register start, Register count,\n+                                        Register tmp, RegSet saved_regs);\n+\n@@ -78,0 +84,3 @@\n+  virtual void arraycopy_epilogue(MacroAssembler* masm, DecoratorSet decorators, bool is_oop,\n+                                  Register start, Register count, Register tmp, RegSet saved_regs);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoahBarrierSetAssembler_riscv.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#if !(defined AARCH64 || defined AMD64 || defined IA32 || defined PPC64)\n+#if !(defined AARCH64 || defined AMD64 || defined IA32 || defined PPC64 || defined RISCV64)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahGenerationalMode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}