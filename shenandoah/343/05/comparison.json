{"files":[{"patch":"@@ -60,1 +60,3 @@\n-  _age_table->add(age, bytes >> LogBytesPerWord);\n+  if (age <= markWord::max_age) { \/\/ Filter age sentinel.\n+    _age_table->add(age, bytes >> LogBytesPerWord);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -861,4 +861,0 @@\n-  \/\/ Return the object's age (at a safepoint or when object isn't\n-  \/\/ mutable by the mutator)\n-  static inline uint get_object_age(oop obj);\n-\n@@ -868,1 +864,1 @@\n-  static inline uint get_object_age_concurrent(oop obj);\n+  static inline uint get_object_age(oop obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -540,5 +541,25 @@\n-  markWord w = obj->has_displaced_mark() ? obj->displaced_mark() : obj->mark();\n-  w = w.set_age(MIN2(markWord::max_age, w.age() + additional_age));\n-  if (obj->has_displaced_mark()) {\n-    obj->set_displaced_mark(w);\n-  } else {\n+  \/\/ This operates on new copy of an object. This means that the object's mark-word\n+  \/\/ is thread-local and therefore safe to access. However, when the mark is\n+  \/\/ displaced (i.e. stack-locked or monitor-locked), then it must be considered\n+  \/\/ a shared memory location. It can be accessed by other threads.\n+  \/\/ In particular, a competing evacuating thread can succeed to install its copy\n+  \/\/ as the forwardee and continue to unlock the object, at which point 'our'\n+  \/\/ write to the foreign stack-location would potentially over-write random\n+  \/\/ information on that stack. Writing to a monitor is less problematic,\n+  \/\/ but still not safe: while the ObjectMonitor would not randomly disappear,\n+  \/\/ the other thread would also write to the same displaced header location,\n+  \/\/ possibly leading to increase the age twice.\n+  \/\/ For all these reasons, we take the conservative approach and not attempt\n+  \/\/ to increase the age when the header is displaced.\n+  markWord w = obj->mark();\n+  \/\/ The mark-word has been copied from the original object. It can not be\n+  \/\/ inflating, because inflation can not be interrupted by a safepoint,\n+  \/\/ and after a safepoint, a Java thread would first have to successfully\n+  \/\/ evacuate the object before it could inflate the monitor.\n+  assert(!w.is_being_inflated() || LockingMode == LM_LIGHTWEIGHT, \"must not inflate monitor before evacuation of object succeeds\");\n+  \/\/ It is possible that we have copied the object after another thread has\n+  \/\/ already successfully completed evacuation. While harmless (we would never\n+  \/\/ publish our copy), don't even attempt to modify the age when that\n+  \/\/ happens.\n+  if (!w.has_displaced_mark_helper() && !w.is_marked()) {\n+    w = w.set_age(MIN2(markWord::max_age, w.age() + additional_age));\n@@ -549,8 +570,0 @@\n-\/\/ Return the object's age (at a safepoint or when object isn't\n-\/\/ mutable by the mutator)\n-uint ShenandoahHeap::get_object_age(oop obj) {\n-  markWord w = obj->has_displaced_mark() ? obj->displaced_mark() : obj->mark();\n-  assert(w.age() <= markWord::max_age, \"Impossible!\");\n-  return w.age();\n-}\n-\n@@ -560,1 +573,1 @@\n-uint ShenandoahHeap::get_object_age_concurrent(oop obj) {\n+uint ShenandoahHeap::get_object_age(oop obj) {\n@@ -564,2 +577,4 @@\n-  \/\/ We can do better for objects with inflated monitor\n-  if (w.is_being_inflated() || w.has_displaced_mark_helper()) {\n+  assert(!w.is_marked(), \"must not be forwarded\");\n+  if (w.has_monitor()) {\n+    w = w.monitor()->header();\n+  } else if (w.is_being_inflated() || w.has_displaced_mark_helper()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":31,"deletions":16,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-      uint age = ShenandoahHeap::get_object_age_concurrent(obj);\n+      uint age = ShenandoahHeap::get_object_age(obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"gc\/shenandoah\/shenandoahStringDedup.hpp\"\n-\n@@ -31,0 +29,3 @@\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahStringDedup.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -48,16 +49,4 @@\n-  const markWord mark = obj->mark();\n-\n-  \/\/ Having\/had displaced header, too risky to deal with them, skip\n-  if (mark == markWord::INFLATING() || mark.has_displaced_mark_helper()) {\n-    return false;\n-  }\n-\n-  if (StringDedup::is_below_threshold_age(mark.age())) {\n-    \/\/ Increase string age and enqueue it when it reaches age threshold\n-    markWord new_mark = mark.incr_age();\n-    if (mark == obj->cas_set_mark(new_mark, mark)) {\n-      return StringDedup::is_threshold_age(new_mark.age()) &&\n-             !dedup_requested(obj);\n-    }\n-  }\n-  return false;\n+  uint age = ShenandoahHeap::get_object_age(obj);\n+  return (age <= markWord::max_age) &&\n+         StringDedup::is_below_threshold_age(age) &&\n+         !dedup_requested(obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStringDedup.inline.hpp","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"}]}