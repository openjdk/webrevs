{"files":[{"patch":"@@ -52,0 +52,1 @@\n+import java.math.BigInteger;\n@@ -101,1 +102,3 @@\n-            String heapAddress = readHeapAddressInLog();\n+            \/\/ Extract the heap start from pagesize logging\n+            BigInteger heapStart = extractHeapStartFromLog();\n+\n@@ -104,2 +107,2 @@\n-            final Pattern heapSection = Pattern.compile(\"^\" + heapAddress + \".*\");\n-            final Pattern thpEligible = Pattern.compile(\"THPeligible:\\\\s+(\\\\d)\\\\s*\");\n+            final Pattern addressRangePattern = Pattern.compile(\"([0-9a-f]*?)-([0-9a-f]*?) .*\");\n+            final Pattern thpEligiblePattern = Pattern.compile(\"THPeligible:\\\\s+(\\\\d)\\\\s*\");\n@@ -109,14 +112,24 @@\n-                Matcher heapMatcher = heapSection.matcher(smapsFile.nextLine());\n-\n-                if (heapMatcher.matches()) {\n-                    \/\/ Found the first heap section, verify that it is THP eligible\n-                    while (smapsFile.hasNextLine()) {\n-                        Matcher m = thpEligible.matcher(smapsFile.nextLine());\n-                        if (m.matches()) {\n-                            if (Integer.parseInt(m.group(1)) == 1) {\n-                                \/\/ THPeligible is 1, heap can be backed by huge pages\n-                                return;\n-                            }\n-\n-                            throw new RuntimeException(\"First heap section at 0x\" + heapAddress + \" is not THPeligible\");\n-                        }\n+                Matcher addressRangeMatcher = addressRangePattern.matcher(smapsFile.nextLine());\n+                if (!addressRangeMatcher.matches()) {\n+                    continue;\n+                }\n+\n+                \/\/ Found an address range line in the smaps file\n+\n+                BigInteger addressStart = new BigInteger(addressRangeMatcher.group(1), 16);\n+                BigInteger addressEnd = new BigInteger(addressRangeMatcher.group(2), 16);\n+\n+                \/\/ Linux sometimes merges adjacent VMAs so we can't search for a range that\n+                \/\/ exactly matches the heap range. Instead we look for the first range that\n+                \/\/ contains the start of the heap and verify that that range is THP eligible.\n+\n+                if (addressStart.compareTo(heapStart) > 0 || heapStart.compareTo(addressEnd) >= 0) {\n+                    continue;\n+                }\n+\n+                \/\/ Found a range that contains the start of the heap, verify that it is THP eligible.\n+\n+                while (smapsFile.hasNextLine()) {\n+                    Matcher m = thpEligiblePattern.matcher(smapsFile.nextLine());\n+                    if (!m.matches()) {\n+                        continue;\n@@ -124,0 +137,12 @@\n+\n+                    \/\/ Found the THPeligible line\n+\n+                    if (m.group(1).equals(\"1\")) {\n+                        \/\/ Success - THPeligible is 1, heap can be backed by huge pages\n+                        return;\n+                    }\n+\n+                    throw new RuntimeException(\"The address range 0x\" + addressStart.toString(16)\n+                                               + \"-0x\" + addressEnd.toString(16)\n+                                               + \" that contains the heap start\" + heapStart\n+                                               + \" is not THPeligible\");\n@@ -125,0 +150,2 @@\n+\n+                throw new RuntimeException(\"Couldn't find THPeligible in the smaps file\");\n@@ -127,2 +154,1 @@\n-            \/\/ Failed to verify THP for heap\n-            throw new RuntimeException(\"Could not find heap section in smaps file\");\n+            throw new RuntimeException(\"Could not find an address range containing the heap start \" + heapStart + \" in the smaps file\");\n@@ -131,2 +157,3 @@\n-        private static String readHeapAddressInLog() throws Exception {\n-            final Pattern heapAddress = Pattern.compile(\".* Heap: .*base=(0x[0-9A-Fa-f]*).*\");\n+        private static BigInteger extractHeapStartFromLog() throws Exception {\n+            \/\/ [0.041s][info][pagesize] Heap:  min=128M max=128M base=0x0000ffff5c600000 size=128M page_size=2M\n+            final Pattern heapAddress = Pattern.compile(\".* Heap: .*base=0x([0-9A-Fa-f]*).*\");\n@@ -136,1 +163,3 @@\n-                Matcher m = heapAddress.matcher(logFile.nextLine());\n+                String line = logFile.nextLine();\n+\n+                Matcher m = heapAddress.matcher(line);\n@@ -138,1 +167,1 @@\n-                    return Long.toHexString(Long.decode(m.group(1)));\n+                    return new BigInteger(m.group(1), 16);\n@@ -141,1 +170,2 @@\n-            throw new RuntimeException(\"Failed to parse heap address, failing test\");\n+\n+            throw new RuntimeException(\"Failed to find heap start\");\n@@ -152,1 +182,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/TestTransparentHugePagesHeap.java","additions":54,"deletions":25,"binary":false,"changes":79,"status":"modified"}]}