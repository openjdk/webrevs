{"files":[{"patch":"@@ -556,0 +556,1 @@\n+        String str;\n@@ -557,2 +558,1 @@\n-            this.value = \"\".value;\n-            this.coder = \"\".coder;\n+            str = \"\";\n@@ -560,6 +560,25 @@\n-            if (COMPACT_STRINGS) {\n-                int dp = StringCoding.countPositives(bytes, offset, length);\n-                if (dp == length) {\n-                    this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                    this.coder = LATIN1;\n-                    return;\n+            str = utf8(bytes, offset, length);\n+        } else if (charset == ISO_8859_1.INSTANCE) {\n+            str = iso88591(bytes, offset, length);\n+        } else if (charset == US_ASCII.INSTANCE) {\n+            str = ascii(bytes, offset, length);\n+        } else {\n+            str = decode(charset, bytes, offset, length);\n+        }\n+        this(str);\n+    }\n+\n+    private static String utf8(byte[] bytes, int offset, int length) {\n+        if (COMPACT_STRINGS) {\n+            int dp = StringCoding.countPositives(bytes, offset, length);\n+            if (dp == length) {\n+                return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n+            }\n+            \/\/ Decode with a stable copy, to be the result if the decoded length is the same\n+            byte[] latin1 = Arrays.copyOfRange(bytes, offset, offset + length);\n+            int sp = dp;            \/\/ first dp bytes are already in the copy\n+            while (sp < length) {\n+                int b1 = latin1[sp++];\n+                if (b1 >= 0) {\n+                    latin1[dp++] = (byte) b1;\n+                    continue;\n@@ -567,7 +586,5 @@\n-                \/\/ Decode with a stable copy, to be the result if the decoded length is the same\n-                byte[] latin1 = Arrays.copyOfRange(bytes, offset, offset + length);\n-                int sp = dp;            \/\/ first dp bytes are already in the copy\n-                while (sp < length) {\n-                    int b1 = latin1[sp++];\n-                    if (b1 >= 0) {\n-                        latin1[dp++] = (byte)b1;\n+                if ((b1 & 0xfe) == 0xc2 && sp < length) { \/\/ b1 either 0xc2 or 0xc3\n+                    int b2 = latin1[sp];\n+                    if (b2 < -64) { \/\/ continuation bytes are always negative values in the range -128 to -65\n+                        latin1[dp++] = (byte) decode2(b1, b2);\n+                        sp++;\n@@ -576,20 +593,0 @@\n-                    if ((b1 & 0xfe) == 0xc2 && sp < length) { \/\/ b1 either 0xc2 or 0xc3\n-                        int b2 = latin1[sp];\n-                        if (b2 < -64) { \/\/ continuation bytes are always negative values in the range -128 to -65\n-                            latin1[dp++] = (byte)decode2(b1, b2);\n-                            sp++;\n-                            continue;\n-                        }\n-                    }\n-                    \/\/ anything not a latin1, including the REPL\n-                    \/\/ we have to go with the utf16\n-                    sp--;\n-                    break;\n-                }\n-                if (sp == length) {\n-                    if (dp != latin1.length) {\n-                        latin1 = Arrays.copyOf(latin1, dp);\n-                    }\n-                    this.value = latin1;\n-                    this.coder = LATIN1;\n-                    return;\n@@ -597,13 +594,8 @@\n-                byte[] utf16 = StringUTF16.newBytesFor(length);\n-                StringLatin1.inflate(latin1, 0, utf16, 0, dp);\n-                dp = decodeUTF8_UTF16(latin1, sp, length, utf16, dp, true);\n-                if (dp != length) {\n-                    utf16 = Arrays.copyOf(utf16, dp << 1);\n-                }\n-                this.value = utf16;\n-                this.coder = UTF16;\n-            } else { \/\/ !COMPACT_STRINGS\n-                byte[] dst = StringUTF16.newBytesFor(length);\n-                int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n-                if (dp != length) {\n-                    dst = Arrays.copyOf(dst, dp << 1);\n+                \/\/ anything not a latin1, including the REPL\n+                \/\/ we have to go with the utf16\n+                sp--;\n+                break;\n+            }\n+            if (sp == length) {\n+                if (dp != latin1.length) {\n+                    latin1 = Arrays.copyOf(latin1, dp);\n@@ -611,2 +603,1 @@\n-                this.value = dst;\n-                this.coder = UTF16;\n+                return new String(latin1, LATIN1);\n@@ -614,7 +605,5 @@\n-        } else if (charset == ISO_8859_1.INSTANCE) {\n-            if (COMPACT_STRINGS) {\n-                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                this.coder = LATIN1;\n-            } else {\n-                this.value = StringLatin1.inflate(bytes, offset, length);\n-                this.coder = UTF16;\n+            byte[] utf16 = StringUTF16.newBytesFor(length);\n+            StringLatin1.inflate(latin1, 0, utf16, 0, dp);\n+            dp = decodeUTF8_UTF16(latin1, sp, length, utf16, dp, true);\n+            if (dp != length) {\n+                utf16 = Arrays.copyOf(utf16, dp << 1);\n@@ -622,13 +611,6 @@\n-        } else if (charset == US_ASCII.INSTANCE) {\n-            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n-                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                this.coder = LATIN1;\n-            } else {\n-                byte[] dst = StringUTF16.newBytesFor(length);\n-                int dp = 0;\n-                while (dp < length) {\n-                    int b = bytes[offset++];\n-                    StringUTF16.putChar(dst, dp++, (b >= 0) ? (char) b : REPL);\n-                }\n-                this.value = dst;\n-                this.coder = UTF16;\n+            return new String(utf16, UTF16);\n+        } else { \/\/ !COMPACT_STRINGS\n+            byte[] dst = StringUTF16.newBytesFor(length);\n+            int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n+            if (dp != length) {\n+                dst = Arrays.copyOf(dst, dp << 1);\n@@ -636,0 +618,7 @@\n+            return new String(dst, UTF16);\n+        }\n+    }\n+\n+    private static String iso88591(byte[] bytes, int offset, int length) {\n+        if (COMPACT_STRINGS) {\n+            return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n@@ -637,22 +626,3 @@\n-            \/\/ (1)We never cache the \"external\" cs, the only benefit of creating\n-            \/\/ an additional StringDe\/Encoder object to wrap it is to share the\n-            \/\/ de\/encode() method. These SD\/E objects are short-lived, the young-gen\n-            \/\/ gc should be able to take care of them well. But the best approach\n-            \/\/ is still not to generate them if not really necessary.\n-            \/\/ (2)The defensive copy of the input byte\/char[] has a big performance\n-            \/\/ impact, as well as the outgoing result byte\/char[]. Need to do the\n-            \/\/ optimization check of (sm==null && classLoader0==null) for both.\n-            CharsetDecoder cd = charset.newDecoder();\n-            \/\/ ArrayDecoder fastpaths\n-            if (cd instanceof ArrayDecoder ad) {\n-                \/\/ ascii\n-                if (ad.isASCIICompatible() && !StringCoding.hasNegatives(bytes, offset, length)) {\n-                    if (COMPACT_STRINGS) {\n-                        this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                        this.coder = LATIN1;\n-                        return;\n-                    }\n-                    this.value = StringLatin1.inflate(bytes, offset, length);\n-                    this.coder = UTF16;\n-                    return;\n-                }\n+            return new String(StringLatin1.inflate(bytes, offset, length), UTF16);\n+        }\n+    }\n@@ -660,0 +630,30 @@\n+    private static String ascii(byte[] bytes, int offset, int length) {\n+        if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n+            return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n+        } else {\n+            byte[] dst = StringUTF16.newBytesFor(length);\n+            int dp = 0;\n+            while (dp < length) {\n+                int b = bytes[offset++];\n+                StringUTF16.putChar(dst, dp++, (b >= 0) ? (char) b : REPL);\n+            }\n+            return new String(dst, UTF16);\n+        }\n+    }\n+\n+    private static String decode(Charset charset, byte[] bytes, int offset, int length) {\n+        \/\/ (1)We never cache the \"external\" cs, the only benefit of creating\n+        \/\/ an additional StringDe\/Encoder object to wrap it is to share the\n+        \/\/ de\/encode() method. These SD\/E objects are short-lived, the young-gen\n+        \/\/ gc should be able to take care of them well. But the best approach\n+        \/\/ is still not to generate them if not really necessary.\n+        \/\/ (2)The defensive copy of the input byte\/char[] has a big performance\n+        \/\/ impact, as well as the outgoing result byte\/char[]. Need to do the\n+        \/\/ optimization check of (sm==null && classLoader0==null) for both.\n+        CharsetDecoder cd = charset.newDecoder();\n+        \/\/ ArrayDecoder fastpaths\n+        if (cd instanceof ArrayDecoder ad) {\n+            \/\/ ascii\n+            if (ad.isASCIICompatible() && !StringCoding.hasNegatives(bytes, offset, length)) {\n+                return iso88591(bytes, offset, length);\n+            } else {\n@@ -664,3 +664,8 @@\n-                    this.value = dst;\n-                    this.coder = LATIN1;\n-                    return;\n+                    return new String(dst, LATIN1);\n+                } else {\n+                    int en = scale(length, cd.maxCharsPerByte());\n+                    cd.onMalformedInput(CodingErrorAction.REPLACE)\n+                            .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+                    char[] ca = new char[en];\n+                    int clen = ad.decode(bytes, offset, length, ca);\n+                    return new String(ca, 0, clen, null);\n@@ -668,15 +673,0 @@\n-\n-                int en = scale(length, cd.maxCharsPerByte());\n-                cd.onMalformedInput(CodingErrorAction.REPLACE)\n-                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n-                char[] ca = new char[en];\n-                int clen = ad.decode(bytes, offset, length, ca);\n-                if (COMPACT_STRINGS) {\n-                    byte[] val = StringUTF16.compress(ca, 0, clen);;\n-                    this.coder = StringUTF16.coderFromArrayLen(val, clen);\n-                    this.value = val;\n-                    return;\n-                }\n-                coder = UTF16;\n-                value = StringUTF16.toBytes(ca, 0, clen);\n-                return;\n@@ -684,1 +674,1 @@\n-\n+        } else {\n@@ -697,8 +687,1 @@\n-            if (COMPACT_STRINGS) {\n-                byte[] val = StringUTF16.compress(ca, 0, caLen);\n-                this.coder = StringUTF16.coderFromArrayLen(val, caLen);\n-                this.value = val;\n-                return;\n-            }\n-            coder = UTF16;\n-            value = StringUTF16.toBytes(ca, 0, caLen);\n+            return new String(ca, 0, caLen, null);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":102,"deletions":119,"binary":false,"changes":221,"status":"modified"}]}