{"files":[{"patch":"@@ -40,0 +40,1 @@\n+  _consecutive_degenerated_gcs_without_progress(0),\n@@ -70,1 +71,1 @@\n-  _consecutive_degenerated_gcs = 0;\n+  reset_consecutive_degenerated_gcs();\n@@ -77,1 +78,1 @@\n-  _consecutive_degenerated_gcs = 0;\n+  reset_consecutive_degenerated_gcs();\n@@ -98,1 +99,1 @@\n-void ShenandoahCollectorPolicy::record_success_degenerated(bool is_young, bool is_abbreviated) {\n+void ShenandoahCollectorPolicy::record_degenerated(bool is_young, bool is_abbreviated, bool progress) {\n@@ -103,0 +104,7 @@\n+\n+  if (progress) {\n+    _consecutive_degenerated_gcs_without_progress = 0;\n+  } else {\n+    _consecutive_degenerated_gcs_without_progress++;\n+  }\n+\n@@ -117,1 +125,1 @@\n-  _consecutive_degenerated_gcs = 0;\n+  reset_consecutive_degenerated_gcs();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  uint _consecutive_degenerated_gcs_without_progress;\n@@ -58,0 +59,4 @@\n+  void reset_consecutive_degenerated_gcs() {\n+    _consecutive_degenerated_gcs = 0;\n+    _consecutive_degenerated_gcs_without_progress = 0;\n+  }\n@@ -60,0 +65,13 @@\n+  \/\/ The most common scenario for lack of good progress following a degenerated GC is an accumulation of floating\n+  \/\/ garbage during the most recently aborted concurrent GC effort.  With generational GC, it is far more effective to\n+  \/\/ reclaim this floating garbage with another degenerated cycle (which focuses on young generation and might require\n+  \/\/ a pause of 200 ms) rather than a full GC cycle (which may require over 2 seconds with a 10 GB old generation).\n+  \/\/\n+  \/\/ In generational mode, we'll only upgrade to full GC if we've done two degen cycles in a row and both indicated\n+  \/\/ bad progress.  In non-generational mode, we'll preserve the original behavior, which is to upgrade to full\n+  \/\/ immediately following a degenerated cycle with bad progress.  This preserves original behavior of non-generational\n+  \/\/ Shenandoah to avoid introducing \"surprising new behavior.\"  It also makes less sense with non-generational\n+  \/\/ Shenandoah to replace a full GC with a degenerated GC, because both have similar pause times in non-generational\n+  \/\/ mode.\n+  static constexpr size_t GENERATIONAL_CONSECUTIVE_BAD_DEGEN_PROGRESS_THRESHOLD = 2;\n+\n@@ -72,1 +90,6 @@\n-  void record_success_degenerated(bool is_young, bool is_abbreviated);\n+\n+  \/\/ Record that a degenerated cycle has been completed. Note that such a cycle may or\n+  \/\/ may not make \"progress\". We separately track the total number of degenerated cycles,\n+  \/\/ the number of consecutive degenerated cycles and the number of consecutive cycles that\n+  \/\/ fail to make good progress.\n+  void record_degenerated(bool is_young, bool is_abbreviated, bool progress);\n@@ -97,0 +120,5 @@\n+  \/\/ Genshen will only upgrade to a full gc after the configured number of futile degenerated cycles.\n+  bool generational_should_upgrade_degenerated_gc() const {\n+    return _consecutive_degenerated_gcs_without_progress >= GENERATIONAL_CONSECUTIVE_BAD_DEGEN_PROGRESS_THRESHOLD;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.hpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -52,2 +52,1 @@\n-  _abbreviated(false),\n-  _consecutive_degen_with_bad_progress(0) {\n+  _abbreviated(false) {\n@@ -250,1 +249,0 @@\n-              heap->cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);\n@@ -315,21 +313,5 @@\n-  \/\/ The most common scenario for lack of good progress following a degenerated GC is an accumulation of floating\n-  \/\/ garbage during the most recently aborted concurrent GC effort.  With generational GC, it is far more effective to\n-  \/\/ reclaim this floating garbage with another degenerated cycle (which focuses on young generation and might require\n-  \/\/ a pause of 200 ms) rather than a full GC cycle (which may require over 2 seconds with a 10 GB old generation).\n-  \/\/\n-  \/\/ In generational mode, we'll only upgrade to full GC if we've done two degen cycles in a row and both indicated\n-  \/\/ bad progress.  In non-generational mode, we'll preserve the original behavior, which is to upgrade to full\n-  \/\/ immediately following a degenerated cycle with bad progress.  This preserves original behavior of non-generational\n-  \/\/ Shenandoah so as to avoid introducing \"surprising new behavior.\"  It also makes less sense with non-generational\n-  \/\/ Shenandoah to replace a full GC with a degenerated GC, because both have similar pause times in non-generational\n-  \/\/ mode.\n-  if (!metrics.is_good_progress(_generation)) {\n-    _consecutive_degen_with_bad_progress++;\n-  } else {\n-    _consecutive_degen_with_bad_progress = 0;\n-  }\n-  if (!heap->mode()->is_generational() ||\n-      ((heap->shenandoah_policy()->consecutive_degenerated_gc_count() > 1) && (_consecutive_degen_with_bad_progress >= 2))) {\n-    heap->cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);\n-    op_degenerated_futile();\n-  } else {\n+  \/\/ Decide if this cycle made good progress, and, if not, should it upgrade to a full GC.\n+  const bool progress = metrics.is_good_progress(_generation);\n+  ShenandoahCollectorPolicy* policy = heap->shenandoah_policy();\n+  policy->record_degenerated(_generation->is_young(), _abbreviated, progress);\n+  if (progress) {\n@@ -337,2 +319,2 @@\n-    heap->shenandoah_policy()->record_success_degenerated(_generation->is_young(), _abbreviated);\n-    _generation->heuristics()->record_success_degenerated();\n+  } else if (!heap->mode()->is_generational() || policy->generational_should_upgrade_degenerated_gc()) {\n+    op_degenerated_futile();\n@@ -485,1 +467,3 @@\n-  ShenandoahHeap::heap()->shenandoah_policy()->record_degenerated_upgrade_to_full();\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  heap->cancel_gc(GCCause::_shenandoah_upgrade_to_full_gc);\n+  heap->shenandoah_policy()->record_degenerated_upgrade_to_full();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":11,"deletions":27,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-  size_t _consecutive_degen_with_bad_progress;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n+#include \"unittest.hpp\"\n+\n+TEST(ShenandoahCollectorPolicyTest, track_degen_cycles_sanity) {\n+  ShenandoahCollectorPolicy policy;\n+  EXPECT_EQ(policy.consecutive_degenerated_gc_count(), 0UL);\n+  EXPECT_EQ(policy.generational_should_upgrade_degenerated_gc(), false);\n+}\n+\n+TEST(ShenandoahCollectorPolicyTest, track_degen_cycles_no_upgrade) {\n+  ShenandoahCollectorPolicy policy;\n+  policy.record_degenerated(true, true, true);\n+  policy.record_degenerated(true, true, true);\n+  EXPECT_EQ(policy.consecutive_degenerated_gc_count(), 2UL);\n+  EXPECT_EQ(policy.generational_should_upgrade_degenerated_gc(), false);\n+}\n+\n+TEST(ShenandoahCollectorPolicyTest, track_degen_cycles_upgrade) {\n+  ShenandoahCollectorPolicy policy;\n+  policy.record_degenerated(true, true, false);\n+  policy.record_degenerated(true, true, false);\n+  EXPECT_EQ(policy.consecutive_degenerated_gc_count(), 2UL);\n+  EXPECT_EQ(policy.generational_should_upgrade_degenerated_gc(), true);\n+}\n+\n+TEST(ShenandoahCollectorPolicyTest, track_degen_cycles_reset_progress) {\n+  ShenandoahCollectorPolicy policy;\n+  policy.record_degenerated(true, true, false);\n+  policy.record_degenerated(true, true, true);\n+  EXPECT_EQ(policy.consecutive_degenerated_gc_count(), 2UL);\n+  EXPECT_EQ(policy.generational_should_upgrade_degenerated_gc(), false);\n+}\n+\n+TEST(ShenandoahCollectorPolicyTest, track_degen_cycles_full_reset) {\n+  ShenandoahCollectorPolicy policy;\n+  policy.record_degenerated(true, true, false);\n+  policy.record_success_full();\n+  EXPECT_EQ(policy.consecutive_degenerated_gc_count(), 0UL);\n+  EXPECT_EQ(policy.generational_should_upgrade_degenerated_gc(), false);\n+}\n+\n+TEST(ShenandoahCollectorPolicyTest, track_degen_cycles_reset) {\n+  ShenandoahCollectorPolicy policy;\n+  policy.record_degenerated(true, true, false);\n+  policy.record_success_concurrent(true, true);\n+  EXPECT_EQ(policy.consecutive_degenerated_gc_count(), 0UL);\n+  EXPECT_EQ(policy.generational_should_upgrade_degenerated_gc(), false);\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahCollectorPolicy.cpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}