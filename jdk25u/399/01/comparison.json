{"files":[{"patch":"@@ -2439,211 +2439,0 @@\n-\/\/ Look at the method's handlers.  If the bci is in the handler's try block\n-\/\/ then check if the handler_pc is already on the stack.  If not, push it\n-\/\/ unless the handler has already been scanned.\n-void ClassVerifier::push_handlers(ExceptionTable* exhandlers,\n-                                  GrowableArray<u4>* handler_list,\n-                                  GrowableArray<u4>* handler_stack,\n-                                  u4 bci) {\n-  int exlength = exhandlers->length();\n-  for(int x = 0; x < exlength; x++) {\n-    if (bci >= exhandlers->start_pc(x) && bci < exhandlers->end_pc(x)) {\n-      u4 exhandler_pc = exhandlers->handler_pc(x);\n-      if (!handler_list->contains(exhandler_pc)) {\n-        handler_stack->append_if_missing(exhandler_pc);\n-        handler_list->append(exhandler_pc);\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ Return TRUE if all code paths starting with start_bc_offset end in\n-\/\/ bytecode athrow or loop.\n-bool ClassVerifier::ends_in_athrow(u4 start_bc_offset) {\n-  ResourceMark rm;\n-  \/\/ Create bytecode stream.\n-  RawBytecodeStream bcs(method());\n-  int code_length = method()->code_size();\n-  bcs.set_start(start_bc_offset);\n-\n-  \/\/ Create stack for storing bytecode start offsets for if* and *switch.\n-  GrowableArray<u4>* bci_stack = new GrowableArray<u4>(30);\n-  \/\/ Create stack for handlers for try blocks containing this handler.\n-  GrowableArray<u4>* handler_stack = new GrowableArray<u4>(30);\n-  \/\/ Create list of handlers that have been pushed onto the handler_stack\n-  \/\/ so that handlers embedded inside of their own TRY blocks only get\n-  \/\/ scanned once.\n-  GrowableArray<u4>* handler_list = new GrowableArray<u4>(30);\n-  \/\/ Create list of visited branch opcodes (goto* and if*).\n-  GrowableArray<u4>* visited_branches = new GrowableArray<u4>(30);\n-  ExceptionTable exhandlers(_method());\n-\n-  while (true) {\n-    if (bcs.is_last_bytecode()) {\n-      \/\/ if no more starting offsets to parse or if at the end of the\n-      \/\/ method then return false.\n-      if ((bci_stack->is_empty()) || (bcs.end_bci() == code_length))\n-        return false;\n-      \/\/ Pop a bytecode starting offset and scan from there.\n-      bcs.set_start(bci_stack->pop());\n-    }\n-    Bytecodes::Code opcode = bcs.raw_next();\n-    int bci = bcs.bci();\n-\n-    \/\/ If the bytecode is in a TRY block, push its handlers so they\n-    \/\/ will get parsed.\n-    push_handlers(&exhandlers, handler_list, handler_stack, bci);\n-\n-    switch (opcode) {\n-      case Bytecodes::_if_icmpeq:\n-      case Bytecodes::_if_icmpne:\n-      case Bytecodes::_if_icmplt:\n-      case Bytecodes::_if_icmpge:\n-      case Bytecodes::_if_icmpgt:\n-      case Bytecodes::_if_icmple:\n-      case Bytecodes::_ifeq:\n-      case Bytecodes::_ifne:\n-      case Bytecodes::_iflt:\n-      case Bytecodes::_ifge:\n-      case Bytecodes::_ifgt:\n-      case Bytecodes::_ifle:\n-      case Bytecodes::_if_acmpeq:\n-      case Bytecodes::_if_acmpne:\n-      case Bytecodes::_ifnull:\n-      case Bytecodes::_ifnonnull: {\n-        int target = bcs.dest();\n-        if (visited_branches->contains(bci)) {\n-          if (bci_stack->is_empty()) {\n-            if (handler_stack->is_empty()) {\n-              return true;\n-            } else {\n-              \/\/ Parse the catch handlers for try blocks containing athrow.\n-              bcs.set_start(handler_stack->pop());\n-            }\n-          } else {\n-            \/\/ Pop a bytecode starting offset and scan from there.\n-            bcs.set_start(bci_stack->pop());\n-          }\n-        } else {\n-          if (target > bci) { \/\/ forward branch\n-            if (target >= code_length) return false;\n-            \/\/ Push the branch target onto the stack.\n-            bci_stack->push(target);\n-            \/\/ then, scan bytecodes starting with next.\n-            bcs.set_start(bcs.next_bci());\n-          } else { \/\/ backward branch\n-            \/\/ Push bytecode offset following backward branch onto the stack.\n-            bci_stack->push(bcs.next_bci());\n-            \/\/ Check bytecodes starting with branch target.\n-            bcs.set_start(target);\n-          }\n-          \/\/ Record target so we don't branch here again.\n-          visited_branches->append(bci);\n-        }\n-        break;\n-        }\n-\n-      case Bytecodes::_goto:\n-      case Bytecodes::_goto_w: {\n-        int offset = (opcode == Bytecodes::_goto ? bcs.get_offset_s2() : bcs.get_offset_s4());\n-        int min_offset = -1 * max_method_code_size;\n-        \/\/ Check offset for overflow\n-        if (offset < min_offset || offset > max_method_code_size) return false;\n-\n-        int target = bci + offset;\n-        if (visited_branches->contains(bci)) {\n-          if (bci_stack->is_empty()) {\n-            if (handler_stack->is_empty()) {\n-              return true;\n-            } else {\n-              \/\/ Parse the catch handlers for try blocks containing athrow.\n-              bcs.set_start(handler_stack->pop());\n-            }\n-          } else {\n-            \/\/ Been here before, pop new starting offset from stack.\n-            bcs.set_start(bci_stack->pop());\n-          }\n-        } else {\n-          if (target >= code_length) return false;\n-          \/\/ Continue scanning from the target onward.\n-          bcs.set_start(target);\n-          \/\/ Record target so we don't branch here again.\n-          visited_branches->append(bci);\n-        }\n-        break;\n-        }\n-\n-      \/\/ Check that all switch alternatives end in 'athrow' bytecodes. Since it\n-      \/\/ is  difficult to determine where each switch alternative ends, parse\n-      \/\/ each switch alternative until either hit a 'return', 'athrow', or reach\n-      \/\/ the end of the method's bytecodes.  This is gross but should be okay\n-      \/\/ because:\n-      \/\/ 1. tableswitch and lookupswitch byte codes in handlers for ctor explicit\n-      \/\/    constructor invocations should be rare.\n-      \/\/ 2. if each switch alternative ends in an athrow then the parsing should be\n-      \/\/    short.  If there is no athrow then it is bogus code, anyway.\n-      case Bytecodes::_lookupswitch:\n-      case Bytecodes::_tableswitch:\n-        {\n-          address aligned_bcp = align_up(bcs.bcp() + 1, jintSize);\n-          int default_offset = Bytes::get_Java_u4(aligned_bcp) + bci;\n-          int keys, delta;\n-          if (opcode == Bytecodes::_tableswitch) {\n-            jint low = (jint)Bytes::get_Java_u4(aligned_bcp + jintSize);\n-            jint high = (jint)Bytes::get_Java_u4(aligned_bcp + 2*jintSize);\n-            \/\/ This is invalid, but let the regular bytecode verifier\n-            \/\/ report this because the user will get a better error message.\n-            if (low > high) return true;\n-            keys = high - low + 1;\n-            delta = 1;\n-          } else {\n-            keys = (int)Bytes::get_Java_u4(aligned_bcp + jintSize);\n-            delta = 2;\n-          }\n-          \/\/ Invalid, let the regular bytecode verifier deal with it.\n-          if (keys < 0) return true;\n-\n-          \/\/ Push the offset of the next bytecode onto the stack.\n-          bci_stack->push(bcs.next_bci());\n-\n-          \/\/ Push the switch alternatives onto the stack.\n-          for (int i = 0; i < keys; i++) {\n-            int min_offset = -1 * max_method_code_size;\n-            int offset = (jint)Bytes::get_Java_u4(aligned_bcp+(3+i*delta)*jintSize);\n-            if (offset < min_offset || offset > max_method_code_size) return false;\n-            int target = bci + offset;\n-            if (target > code_length) return false;\n-            bci_stack->push(target);\n-          }\n-\n-          \/\/ Start bytecode parsing for the switch at the default alternative.\n-          if (default_offset > code_length) return false;\n-          bcs.set_start(default_offset);\n-          break;\n-        }\n-\n-      case Bytecodes::_return:\n-        return false;\n-\n-      case Bytecodes::_athrow:\n-        {\n-          if (bci_stack->is_empty()) {\n-            if (handler_stack->is_empty()) {\n-              return true;\n-            } else {\n-              \/\/ Parse the catch handlers for try blocks containing athrow.\n-              bcs.set_start(handler_stack->pop());\n-            }\n-          } else {\n-            \/\/ Pop a bytecode offset and starting scanning from there.\n-            bcs.set_start(bci_stack->pop());\n-          }\n-        }\n-        break;\n-\n-      default:\n-        ;\n-    } \/\/ end switch\n-  } \/\/ end while loop\n-\n-  return false;\n-}\n-\n@@ -2674,19 +2463,0 @@\n-      ExceptionTable exhandlers(_method());\n-      int exlength = exhandlers.length();\n-      for(int i = 0; i < exlength; i++) {\n-        u2 start_pc = exhandlers.start_pc(i);\n-        u2 end_pc = exhandlers.end_pc(i);\n-\n-        if (bci >= start_pc && bci < end_pc) {\n-          if (!ends_in_athrow(exhandlers.handler_pc(i))) {\n-            verify_error(ErrorContext::bad_code(bci),\n-              \"Bad <init> method call from after the start of a try block\");\n-            return;\n-          } else if (log_is_enabled(Debug, verification)) {\n-            ResourceMark rm(THREAD);\n-            log_debug(verification)(\"Survived call to ends_in_athrow(): %s\",\n-                                          current_class()->name()->as_C_string());\n-          }\n-        }\n-      }\n-\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":0,"deletions":230,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -337,11 +337,0 @@\n-  \/\/ Used by ends_in_athrow() to push all handlers that contain bci onto the\n-  \/\/ handler_stack, if the handler has not already been pushed on the stack.\n-  void push_handlers(ExceptionTable* exhandlers,\n-                     GrowableArray<u4>* handler_list,\n-                     GrowableArray<u4>* handler_stack,\n-                     u4 bci);\n-\n-  \/\/ Returns true if all paths starting with start_bc_offset end in athrow\n-  \/\/ bytecode or loop.\n-  bool ends_in_athrow(u4 start_bc_offset);\n-\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -38,0 +38,7 @@\n+import jdk.internal.misc.Unsafe;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectStreamException;\n+import java.io.Serial;\n+import java.io.StreamCorruptedException;\n@@ -448,0 +455,34 @@\n+\n+    \/**\n+     * De-serialization without data not supported for this class.\n+     *\/\n+    @Serial\n+    private void readObjectNoData() throws ObjectStreamException {\n+        throw new StreamCorruptedException(\"Deserialized CopyOnWriteArraySet requires data\");\n+    }\n+\n+    \/**\n+     * Reconstitutes the {@code CopyOnWriteArraySet} instance from a stream\n+     * (that is, deserializes it).\n+     * @throws StreamCorruptedException if the object read from the stream is invalid.\n+     *\/\n+    @Serial\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        CopyOnWriteArrayList<E> newAl; \/\/ Set during the duplicate check\n+\n+        @SuppressWarnings(\"unchecked\")\n+        CopyOnWriteArrayList<E> inAl = (CopyOnWriteArrayList<E>) in.readFields().get(\"al\", null);\n+\n+        if (inAl == null\n+                || inAl.getClass() != CopyOnWriteArrayList.class\n+                || (newAl = new CopyOnWriteArrayList<>()).addAllAbsent(inAl) != inAl.size()) {\n+            throw new StreamCorruptedException(\"Content is invalid\");\n+        }\n+\n+        final Unsafe U = Unsafe.getUnsafe();\n+        U.putReference(\n+                this,\n+                U.objectFieldOffset(CopyOnWriteArraySet.class, \"al\"),\n+                newAl\n+        );\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CopyOnWriteArraySet.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1518,7 +1518,0 @@\n-    \/\/ Return TRUE if all code paths starting with start_bc_offset end in\n-    \/\/ bytecode athrow or loop.\n-    boolean ends_in_athrow(int start_bc_offset) {\n-        log_info(\"unimplemented VerifierImpl.ends_in_athrow\");\n-        return true;\n-    }\n-\n@@ -1537,10 +1530,0 @@\n-                for(var exhandler : _method.exceptionTable()) {\n-                    int start_pc = exhandler[0];\n-                    int end_pc = exhandler[1];\n-\n-                    if (bci >= start_pc && bci < end_pc) {\n-                        if (!ends_in_athrow(exhandler[2])) {\n-                            verifyError(\"Bad <init> method call from after the start of a try block\");\n-                        }\n-                    }\n-                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.net.URISyntaxException;\n@@ -51,0 +52,1 @@\n+import java.util.LinkedHashSet;\n@@ -53,0 +55,2 @@\n+import java.util.Optional;\n+import java.util.Set;\n@@ -61,0 +65,2 @@\n+import javax.security.auth.x500.X500Principal;\n+\n@@ -185,0 +191,160 @@\n+    \/**\n+     * Enumeration for the allowed schemes we support when following a\n+     * URI from an authorityInfoAccess extension on a certificate.\n+     *\/\n+    private enum AllowedScheme {\n+        HTTP(HttpFtpRuleMatcher.HTTP),\n+        HTTPS(HttpFtpRuleMatcher.HTTPS),\n+        LDAP(LdapRuleMatcher.LDAP),\n+        LDAPS(LdapRuleMatcher.LDAPS),\n+        FTP(HttpFtpRuleMatcher.FTP);\n+\n+        final URIRuleMatcher ruleMatcher;\n+\n+        AllowedScheme(URIRuleMatcher matcher) {\n+            ruleMatcher = matcher;\n+        }\n+\n+        \/**\n+         * Return an {@code AllowedScheme} based on a case-insensitive match\n+         * @param name the scheme name to be matched\n+         * @return the {@code AllowedScheme} that corresponds to the\n+         *      {@code name} provided, or null if there is no match.\n+         *\/\n+        static AllowedScheme nameOf(String name) {\n+            if (name == null) {\n+                return null;\n+            }\n+\n+            try {\n+                return AllowedScheme.valueOf(name.toUpperCase(Locale.ROOT));\n+            } catch (IllegalArgumentException _) {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    private static Set<URI> CA_ISS_URI_FILTERS = null;\n+    private static final boolean CA_ISS_ALLOW_ANY;\n+\n+    static {\n+        boolean allowAny = false;\n+        try {\n+            if (Builder.USE_AIA) {\n+                CA_ISS_URI_FILTERS = new LinkedHashSet<>();\n+                String aiaPropVal = Optional.ofNullable(\n+                        SecurityProperties.getOverridableProperty(\n+                                \"com.sun.security.allowedAIALocations\")).\n+                        map(String::trim).orElse(\"\");\n+                if (aiaPropVal.equalsIgnoreCase(\"any\")) {\n+                    allowAny = true;\n+                    if (debug != null) {\n+                        debug.println(\"allowedAIALocations: Warning: \" +\n+                                \"Allow-All URI filtering enabled!\");\n+                    }\n+                } else {\n+                    \/\/ Load all the valid rules from the Security property\n+                    if (!aiaPropVal.isEmpty()) {\n+                        String[] aiaUriStrs = aiaPropVal.trim().split(\"\\\\s+\");\n+                        addCaIssUriFilters(aiaUriStrs);\n+                    }\n+\n+                    if (CA_ISS_URI_FILTERS.isEmpty()) {\n+                        if (debug != null) {\n+                            debug.println(\"allowedAIALocations: Warning: \" +\n+                                    \"No valid filters found. Deny-all URI \" +\n+                                    \"filtering is active.\");\n+                        }\n+                    }\n+                }\n+            }\n+        } finally {\n+            CA_ISS_ALLOW_ANY = allowAny;\n+        }\n+    }\n+\n+    \/**\n+     * Populate the filter collection from the list of AIA CA issuer URIs\n+     * found in the {@code com.sun.security.allowedAIALocations} security\n+     * or system property.\n+     *\n+     * @param aiaUriStrs array containing String URI filters\n+     *\/\n+    private static void addCaIssUriFilters(String[] aiaUriStrs) {\n+        for (String aiaStr : aiaUriStrs) {\n+            if (aiaStr != null && !aiaStr.isEmpty()) {\n+                try {\n+                    AllowedScheme scheme;\n+                    URI aiaUri = new URI(aiaStr).normalize();\n+                    \/\/ It must be absolute and non-opaque\n+                    if (!aiaUri.isAbsolute() || aiaUri.isOpaque()) {\n+                        if (debug != null) {\n+                            debug.println(\"allowedAIALocations: Skipping \" +\n+                                    \"non-absolute or opaque URI \" + aiaUri);\n+                        }\n+                    } else if (aiaUri.getHost() == null) {\n+                        \/\/ We do not allow rules with URIs that omit a hostname\n+                        \/\/ or address.\n+                        if (debug != null) {\n+                            debug.println(\"allowedAIALocations: Skipping \" +\n+                                    \"URI rule with no hostname or address: \" +\n+                                    aiaUri);\n+                        }\n+                    } else if ((scheme = AllowedScheme.nameOf(\n+                            aiaUri.getScheme())) != null) {\n+                        \/\/ When it is an LDAP type, we can check the path\n+                        \/\/ portion (the DN) for proper structure and reject\n+                        \/\/ the rule early if it isn't correct.\n+                        if (scheme == AllowedScheme.LDAP ||\n+                                scheme == AllowedScheme.LDAPS) {\n+                            try {\n+                                new X500Principal(aiaUri.getPath().\n+                                        replaceFirst(\"^\/+\", \"\"));\n+                            } catch (IllegalArgumentException iae) {\n+                                if (debug != null) {\n+                                    debug.println(\"allowedAIALocations: \" +\n+                                            \"Skipping LDAP rule: \" + iae);\n+                                }\n+                                continue;\n+                            }\n+                        }\n+\n+                        \/\/ When a URI has a non-null query or fragment\n+                        \/\/ warn the user upon adding the rule that those\n+                        \/\/ components will be ignored\n+                        if (aiaUri.getQuery() != null) {\n+                            if (debug != null) {\n+                                debug.println(\"allowedAIALocations: \" +\n+                                        \"Rule will ignore non-null query\");\n+                            }\n+                        }\n+                        if (aiaUri.getFragment() != null) {\n+                            if (debug != null) {\n+                                debug.println(\"allowedAIALocations: \" +\n+                                        \"Rule will ignore non-null fragment\");\n+                            }\n+                        }\n+\n+                        CA_ISS_URI_FILTERS.add(aiaUri);\n+                        if (debug != null) {\n+                            debug.println(\"allowedAIALocations: Added \" +\n+                                    aiaUri + \" to URI filters\");\n+                        }\n+                    } else {\n+                        if (debug != null) {\n+                            debug.println(\"allowedAIALocations: Disallowed \" +\n+                                    \"filter URI scheme: \" +\n+                                    aiaUri.getScheme());\n+                        }\n+                    }\n+                } catch (URISyntaxException urise) {\n+                    if (debug != null) {\n+                        debug.println(\"allowedAIALocations: Skipping \" +\n+                                \"filter URI entry \" + aiaStr +\n+                                \": parse failure at index \" + urise.getIndex());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -247,0 +413,33 @@\n+\n+        \/\/ Before performing any instantiation make sure that\n+        \/\/ the URI passes any filtering rules.  This processing should\n+        \/\/ only occur if the com.sun.security.enableAIAcaIssuers is true\n+        \/\/ and the \"any\" rule has not been specified.\n+        if (Builder.USE_AIA && !CA_ISS_ALLOW_ANY) {\n+            URI normAIAUri = uri.normalize();\n+            AllowedScheme scheme = AllowedScheme.nameOf(normAIAUri.getScheme());\n+\n+            if (scheme == null) {\n+                if (debug != null) {\n+                    debug.println(\"allowedAIALocations: No matching ruleset \" +\n+                            \"for scheme \" + normAIAUri.getScheme());\n+                }\n+                return null;\n+            }\n+\n+            \/\/ Go through each of the filter rules and see if any will\n+            \/\/ make a positive match against the caIssuer URI.  If nothing\n+            \/\/ matches then we won't instantiate a URICertStore.\n+            if (CA_ISS_URI_FILTERS.stream().noneMatch(rule ->\n+                    scheme.ruleMatcher.matchRule(rule, normAIAUri))) {\n+                if (debug != null) {\n+                    debug.println(\"allowedAIALocations: Warning - \" +\n+                        \"The caIssuer URI \" + normAIAUri +\n+                        \" in the AuthorityInfoAccess extension is denied \" +\n+                        \"access. Use the com.sun.security.allowedAIALocations\" +\n+                        \" security\/system property to allow access.\");\n+                }\n+                return null;\n+            }\n+        }\n+\n@@ -273,1 +472,1 @@\n-        (CertSelector selector) throws CertStoreException {\n+            (CertSelector selector) throws CertStoreException {\n@@ -465,0 +664,155 @@\n+\n+    \/**\n+     * URIRuleMatcher - abstract base class for the rule sets used for\n+     * various URI schemes.\n+     *\/\n+    static abstract class URIRuleMatcher {\n+        protected final int wellKnownPort;\n+\n+        protected URIRuleMatcher(int port) {\n+            wellKnownPort = port;\n+        }\n+\n+        \/**\n+         * Attempt to match the scheme, host and port between a filter\n+         * rule URI and a URI coming from an AIA extension.\n+         *\n+         * @param filterRule the filter rule to match against\n+         * @param caIssuer the AIA URI being compared\n+         * @return true if the scheme, host and port numbers match, false if\n+         * any of the components do not match. If a port number is omitted in\n+         * either the filter rule or AIA URI, the well-known port for that\n+         * scheme is used in the comparison.\n+         *\/\n+        boolean schemeHostPortCheck(URI filterRule, URI caIssuer) {\n+            if (!filterRule.getScheme().equalsIgnoreCase(\n+                    caIssuer.getScheme())) {\n+                return false;\n+            } else if (!filterRule.getHost().equalsIgnoreCase(\n+                    caIssuer.getHost())) {\n+                return false;\n+            } else {\n+                try {\n+                    \/\/ Check for port matching, taking into consideration\n+                    \/\/ default ports\n+                    int fPort = (filterRule.getPort() == -1) ? wellKnownPort :\n+                            filterRule.getPort();\n+                    int caiPort = (caIssuer.getPort() == -1) ? wellKnownPort :\n+                            caIssuer.getPort();\n+                    if (fPort != caiPort) {\n+                        return false;\n+                    }\n+                } catch (IllegalArgumentException iae) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        \/**\n+         * Attempt to match an AIA URI against a specific filter rule.  The\n+         * specific rules to apply are implementation dependent.\n+         *\n+         * @param filterRule the filter rule to match against\n+         * @param caIssuer the AIA URI being compared\n+         * @return true if all matching rules pass, false if any fail.\n+         *\/\n+        abstract boolean matchRule(URI filterRule, URI caIssuer);\n+    }\n+\n+    static class HttpFtpRuleMatcher extends URIRuleMatcher {\n+        static final HttpFtpRuleMatcher HTTP = new HttpFtpRuleMatcher(80);\n+        static final HttpFtpRuleMatcher HTTPS = new HttpFtpRuleMatcher(443);\n+        static final HttpFtpRuleMatcher FTP = new HttpFtpRuleMatcher(21);\n+\n+        private HttpFtpRuleMatcher(int port) {\n+            super(port);\n+        }\n+\n+        @Override\n+        boolean matchRule(URI filterRule, URI caIssuer) {\n+            \/\/ Check for scheme\/host\/port matching\n+            if (!schemeHostPortCheck(filterRule, caIssuer)) {\n+                return false;\n+            }\n+\n+            \/\/ Check the path component to make sure the filter is at\n+            \/\/ least a root of the AIA caIssuer URI's path.  It must be\n+            \/\/ a case-sensitive match for all platforms.\n+            if (!isRootOf(filterRule, caIssuer)) {\n+                if (debug != null) {\n+                    debug.println(\"allowedAIALocations: Match failed: \" +\n+                            \"AIA URI is not within the rule's path hierarchy.\");\n+                }\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        \/**\n+         * Performs a hierarchical containment check, ensuring that the\n+         * base URI's path is a root component of the candidate path.  The\n+         * path comparison is case-sensitive.  If the base path ends in a\n+         * slash (\/) then all candidate paths that begin with the base\n+         * path are allowed.  If it does not end in a slash, then it is\n+         * assumed that the leaf node in the base path is a file component\n+         * and both paths must match exactly.\n+         *\n+         * @param base the URI that contains the root path\n+         * @param candidate the URI that contains the path being evaluated\n+         * @return true if {@code candidate} is a child path of {@code base},\n+         *         false otherwise.\n+         *\/\n+        private static boolean isRootOf(URI base, URI candidate) {\n+            \/\/ Note: The URIs have already been normalized at this point and\n+            \/\/ HTTP URIs cannot have null paths.  If it's an empty path\n+            \/\/ then consider the path to be \"\/\".\n+            String basePath = Optional.of(base.getPath()).\n+                    filter(p -> !p.isEmpty()).orElse(\"\/\");\n+            String candPath = Optional.of(candidate.getPath()).\n+                    filter(p -> !p.isEmpty()).orElse(\"\/\");\n+            return (basePath.endsWith(\"\/\")) ? candPath.startsWith(basePath) :\n+                    candPath.equals(basePath);\n+        }\n+    }\n+\n+    static class LdapRuleMatcher extends URIRuleMatcher {\n+        static final LdapRuleMatcher LDAP = new LdapRuleMatcher(389);\n+        static final LdapRuleMatcher LDAPS = new LdapRuleMatcher(636);\n+\n+        private LdapRuleMatcher(int port) {\n+            super(port);\n+        }\n+\n+        @Override\n+        boolean matchRule(URI filterRule, URI caIssuer) {\n+            \/\/ Check for scheme\/host\/port matching\n+            if (!schemeHostPortCheck(filterRule, caIssuer)) {\n+                return false;\n+            }\n+\n+            \/\/ Obtain the base DN component and compare\n+            try {\n+                X500Principal filterBaseDn = new X500Principal(\n+                        filterRule.getPath().replaceFirst(\"^\/+\", \"\"));\n+                X500Principal caIssBaseDn = new X500Principal(\n+                        caIssuer.getPath().replaceFirst(\"^\/+\", \"\"));\n+                if (!filterBaseDn.equals(caIssBaseDn)) {\n+                    if (debug != null) {\n+                        debug.println(\"allowedAIALocations: Match failed: \" +\n+                                \"Base DN mismatch (\" + filterBaseDn + \" vs \" +\n+                                caIssBaseDn + \")\");\n+                    }\n+                    return false;\n+                }\n+            } catch (IllegalArgumentException iae) {\n+                if (debug != null) {\n+                    debug.println(\"allowedAIALocations: Match failed on DN: \" +\n+                            iae);\n+                }\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/URICertStore.java","additions":356,"deletions":2,"binary":false,"changes":358,"status":"modified"},{"patch":"@@ -1577,0 +1577,45 @@\n+\n+#\n+# X.509 AuthorityInfoAccess caIssuer URI Filtering\n+#\n+# This property defines a whitespace-separated list of filters that\n+# are applied to URIs found in the authorityInfoAccess extension in\n+# X.509 certificates. Any caIssuers URIs in X.509 certificates are only\n+# followed when the com.sun.security.enableAIAcaIssuers System property is\n+# enabled and the filter allows the URI. By default this property imposes a\n+# deny-all ruleset.  This property may be overridden by a System property\n+# of the same name.\n+#\n+# The filters must take the form of absolute, hierarchical URIs as defined by\n+# the java.net.URI class. Additionally, only the following protocols are\n+# allowed as filters: http, https, ldap and ftp.\n+# See RFC 5280, section 4.2.2.1 for details about the types of URIs allowed for\n+# the extension and their specific requirements.\n+# The filter matching rules are applied to each CA issuer URI as follows:\n+# 1. The scheme must match (case-insensitive).\n+# 2. A hostname or address must be specified in the filter URI.  It must match\n+#    the host or address in the caIssuers URI (case-insensitive).  No name\n+#    resolution is performed on hostnames to match IP addresses.\n+# 3. The port number must match.  For filter and caIssuer URIs, when a port\n+#    number is omitted, the well-known port for that scheme will be used in the\n+#    comparison.\n+# 4. For hierarchical filesystem schemes (e.g. http[s], ftp):\n+#    a. The normalized path portion of the filter URI is matched in a\n+#       case-sensitive manner.  If the final component of the path does not end\n+#       in a slash (\/), it is considered to be a file path component and must\n+#       be an exact match of the caIssuer's URI file path component.  If the\n+#       final filter component ends in a slash, then it must either match or be\n+#       a prefix of the caIssuer's URI path component (e.g. a filter path of\n+#       \/ab\/cd\/ will match a caIssuer path of \/ab\/cd\/, \/ab\/cd\/ef and\n+#       \/ab\/cd\/ef\/ghi).\n+#    b. Query strings will be ignored in filter rules and caIssuer URIs.\n+#    c. Fragments will be ignored in filter rules and caIssuer URIs.\n+# 5. For ldap URIs:\n+#    a. The base DN must be an exact match (case-insensitive).\n+#    b. Any query string in the rule, if specified, is ignored.\n+# 6. A single value \"any\" (case-insensitive) will create an allow-all rule.\n+#\n+# As an example, here is a valid filter policy consisting of two rules:\n+#    com.sun.security.allowedAIALocations=http:\/\/some.company.com\/cacert \\\n+#          ldap:\/\/ldap.company.com\/dc=company,dc=com?caCertificate;binary\n+com.sun.security.allowedAIALocations=\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.lang.annotation.Native;\n@@ -38,0 +39,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -47,0 +50,6 @@\n+    @Native private static final int OPEN = 0;\n+    @Native private static final int BROWSE = 1;\n+    @Native private static final int EDIT = 2;\n+    @Native private static final int PRINT = 3;\n+    @Native private static final int MAIL = 4;\n+\n@@ -54,1 +63,1 @@\n-        this.lsOpenFile(file, false);\n+        this.lsOpenFile(file, OPEN);\n@@ -59,1 +68,1 @@\n-        this.lsOpenFile(file, false);\n+        this.lsOpenFile(file, EDIT);\n@@ -64,1 +73,1 @@\n-        this.lsOpenFile(file, true);\n+        this.lsOpenFile(file, PRINT);\n@@ -69,1 +78,1 @@\n-        this.lsOpen(uri);\n+        this.lsOpen(uri, MAIL);\n@@ -74,1 +83,1 @@\n-        this.lsOpen(uri);\n+        this.lsOpen(uri, BROWSE);\n@@ -165,2 +174,2 @@\n-    private void lsOpen(URI uri) throws IOException {\n-        int status = _lsOpenURI(uri.toString());\n+    private void lsOpen(URI uri, int action) throws IOException {\n+        int status = _lsOpenURI(uri.toString(), action);\n@@ -169,1 +178,3 @@\n-            throw new IOException(\"Failed to mail or browse \" + uri + \". Error code: \" + status);\n+            String actionString = (action == MAIL) ? \"mail\" : \"browse\";\n+            throw new IOException(\"Failed to \" + actionString + \" \" + uri\n+                                  + \". Error code: \" + status);\n@@ -173,2 +184,4 @@\n-    private void lsOpenFile(File file, boolean print) throws IOException {\n-        int status = _lsOpenFile(file.getCanonicalPath(), print);\n+    private void lsOpenFile(File file, int action) throws IOException {\n+        int status = -1;\n+        Path tmpFile = null;\n+        String tmpTxtPath = null;\n@@ -176,0 +189,13 @@\n+        try {\n+            if (action == EDIT) {\n+                tmpFile = Files.createTempFile(\"TmpFile\", \".txt\");\n+                tmpTxtPath = tmpFile.toAbsolutePath().toString();\n+            }\n+            status = _lsOpenFile(file.getCanonicalPath(), action, tmpTxtPath);\n+        } catch (Exception e) {\n+            throw new IOException(\"Failed to create tmp file: \", e);\n+        } finally {\n+            if (tmpFile != null) {\n+                Files.deleteIfExists(tmpFile);\n+            }\n+        }\n@@ -177,1 +203,4 @@\n-            throw new IOException(\"Failed to open, edit or print \" + file + \". Error code: \" + status);\n+            String actionString = (action == OPEN) ? \"open\"\n+                                                   : (action == EDIT) ? \"edit\" : \"print\";\n+            throw new IOException(\"Failed to \" + actionString + \" \" + file\n+                                  + \". Error code: \" + status);\n@@ -181,1 +210,1 @@\n-    private static native int _lsOpenURI(String uri);\n+    private static native int _lsOpenURI(String uri, int action);\n@@ -183,1 +212,1 @@\n-    private static native int _lsOpenFile(String path, boolean print);\n+    private static native int _lsOpenFile(String path, int action, String tmpTxtPath);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CDesktopPeer.java","additions":43,"deletions":14,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#import \"sun_lwawt_macosx_CDesktopPeer.h\"\n@@ -34,1 +35,1 @@\n- * Signature: (Ljava\/lang\/String;)I;\n+ * Signature: (Ljava\/lang\/String;I)I\n@@ -37,1 +38,1 @@\n-(JNIEnv *env, jclass clz, jstring uri)\n+(JNIEnv *env, jclass clz, jstring uri, jint action)\n@@ -39,1 +40,1 @@\n-    OSStatus status = noErr;\n+    __block OSStatus status = noErr;\n@@ -42,9 +43,41 @@\n-    \/\/ I would love to use NSWorkspace here, but it's not thread safe. Why? I don't know.\n-    \/\/ So we use LaunchServices directly.\n-\n-    NSURL *url = [NSURL URLWithString:JavaStringToNSString(env, uri)];\n-\n-    LSLaunchFlags flags = kLSLaunchDefaults;\n-\n-    LSApplicationParameters params = {0, flags, NULL, NULL, NULL, NULL, NULL};\n-    status = LSOpenURLsWithRole((CFArrayRef)[NSArray arrayWithObject:url], kLSRolesAll, NULL, &params, NULL, 0);\n+    NSURL *urlToOpen = [NSURL URLWithString:JavaStringToNSString(env, uri)];\n+    NSURL *appURI = nil;\n+\n+    if (action == sun_lwawt_macosx_CDesktopPeer_BROWSE) {\n+        \/\/ To get the defaultBrowser\n+        NSURL *httpsURL = [NSURL URLWithString:@\"https:\/\/\"];\n+        NSWorkspace *workspace = [NSWorkspace sharedWorkspace];\n+        appURI = [workspace URLForApplicationToOpenURL:httpsURL];\n+    } else if (action == sun_lwawt_macosx_CDesktopPeer_MAIL) {\n+        \/\/ To get the default mailer\n+        NSURL *mailtoURL = [NSURL URLWithString:@\"mailto:\/\/\"];\n+        NSWorkspace *workspace = [NSWorkspace sharedWorkspace];\n+        appURI = [workspace URLForApplicationToOpenURL:mailtoURL];\n+    }\n+\n+    if (appURI == nil) {\n+        return -1;\n+    }\n+\n+    \/\/ Prepare NSOpenConfig object\n+    NSArray<NSURL *> *urls = @[urlToOpen];\n+    NSWorkspaceOpenConfiguration *configuration = [NSWorkspaceOpenConfiguration configuration];\n+    configuration.activates = YES; \/\/ To bring app to foreground\n+    configuration.promptsUserIfNeeded = YES; \/\/ To allow macOS desktop prompts\n+\n+    \/\/ dispatch semaphores used to wait for the completion handler to update and return status\n+    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n+    dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(NSEC_PER_SEC)); \/\/ 1 second timeout\n+\n+    \/\/ Asynchronous call to openURL\n+    [[NSWorkspace sharedWorkspace] openURLs:urls\n+                                    withApplicationAtURL:appURI\n+                                    configuration:configuration\n+                                    completionHandler:^(NSRunningApplication *app, NSError *error) {\n+        if (error) {\n+            status = (OSStatus) error.code;\n+        }\n+        dispatch_semaphore_signal(semaphore);\n+    }];\n+\n+    dispatch_semaphore_wait(semaphore, timeout);\n@@ -59,1 +92,1 @@\n- * Signature: (Ljava\/lang\/String;Z)I;\n+ * Signature: (Ljava\/lang\/String;I;Ljava\/lang\/String;)I;\n@@ -62,1 +95,1 @@\n-(JNIEnv *env, jclass clz, jstring jpath, jboolean print)\n+(JNIEnv *env, jclass clz, jstring jpath, jint action, jstring jtmpTxtPath)\n@@ -64,1 +97,1 @@\n-    OSStatus status = noErr;\n+    __block OSStatus status = noErr;\n@@ -67,3 +100,0 @@\n-    \/\/ I would love to use NSWorkspace here, but it's not thread safe. Why? I don't know.\n-    \/\/ So we use LaunchServices directly.\n-\n@@ -71,2 +101,1 @@\n-\n-    NSURL *url = [NSURL fileURLWithPath:(NSString *)path];\n+    NSURL *urlToOpen = [NSURL fileURLWithPath:(NSString *)path];\n@@ -75,8 +104,54 @@\n-    url = (NSURL *)CFURLCreateWithFileSystemPath(NULL, (CFStringRef)[url path], kCFURLPOSIXPathStyle, false);\n-\n-    LSLaunchFlags flags = kLSLaunchDefaults;\n-    if (print) flags |= kLSLaunchAndPrint;\n-\n-    LSApplicationParameters params = {0, flags, NULL, NULL, NULL, NULL, NULL};\n-    status = LSOpenURLsWithRole((CFArrayRef)[NSArray arrayWithObject:url], kLSRolesAll, NULL, &params, NULL, 0);\n-    [url release];\n+    urlToOpen = (NSURL *)CFURLCreateWithFileSystemPath(NULL, (CFStringRef)[urlToOpen path],\n+                                                        kCFURLPOSIXPathStyle, false);\n+\n+    NSWorkspace *workspace = [NSWorkspace sharedWorkspace];\n+    NSURL *appURI = [workspace URLForApplicationToOpenURL:urlToOpen];\n+    NSURL *defaultTerminalApp = [workspace URLForApplicationToOpenURL:[NSURL URLWithString:@\"file:\/\/\/bin\/sh\"]];\n+\n+    \/\/ Prepare NSOpenConfig object\n+    NSArray<NSURL *> *urls = @[urlToOpen];\n+    NSWorkspaceOpenConfiguration *configuration = [NSWorkspaceOpenConfiguration configuration];\n+    configuration.activates = YES; \/\/ To bring app to foreground\n+    configuration.promptsUserIfNeeded = YES;  \/\/ To allow macOS desktop prompts\n+\n+    \/\/ pre-checks for open\/print\/edit before calling openURLs API\n+    if (action == sun_lwawt_macosx_CDesktopPeer_OPEN\n+            || action == sun_lwawt_macosx_CDesktopPeer_PRINT) {\n+        if (appURI == nil\n+            || [[urlToOpen absoluteString] containsString:[appURI absoluteString]]\n+            || [[defaultTerminalApp absoluteString] containsString:[appURI absoluteString]]) {\n+            return -1;\n+        }\n+        \/\/ Additionally set forPrinting=TRUE for print\n+        if (action == sun_lwawt_macosx_CDesktopPeer_PRINT) {\n+            configuration.forPrinting = YES;\n+        }\n+    } else if (action == sun_lwawt_macosx_CDesktopPeer_EDIT) {\n+        if (appURI == nil\n+            || [[urlToOpen absoluteString] containsString:[appURI absoluteString]]) {\n+            return -1;\n+        }\n+        \/\/ for EDIT: if (defaultApp = TerminalApp) then set appURI = DefaultTextEditor\n+        if ([[defaultTerminalApp absoluteString] containsString:[appURI absoluteString]]) {\n+            NSString *path  = NormalizedPathNSStringFromJavaString(env, jtmpTxtPath);\n+            NSURL *tempFilePath = [NSURL fileURLWithPath:(NSString *)path];\n+            appURI = [workspace URLForApplicationToOpenURL:tempFilePath];\n+        }\n+    }\n+\n+    \/\/ dispatch semaphores used to wait for the completion handler to update and return status\n+    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n+    dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(NSEC_PER_SEC)); \/\/ 1 second timeout\n+\n+    \/\/ Asynchronous call - openURLs:withApplicationAtURL\n+    [[NSWorkspace sharedWorkspace] openURLs:urls\n+                                   withApplicationAtURL:appURI\n+                                   configuration:configuration\n+                                   completionHandler:^(NSRunningApplication *app, NSError *error) {\n+        if (error) {\n+            status = (OSStatus) error.code;\n+        }\n+        dispatch_semaphore_signal(semaphore);\n+    }];\n+\n+    dispatch_semaphore_wait(semaphore, timeout);\n@@ -87,1 +162,0 @@\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CDesktopPeer.m","additions":104,"deletions":30,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -455,13 +455,28 @@\n-            if (s.contains(\"<html>\")) {\n-                \/* line break in html text is done by <br> tag\n-                 * and not by \/n so it's incorrect to address newline\n-                 * same as non-html text.\n-                 * Text between <html> <\/html> tags are extracted\n-                 * and rendered as JLabel text\n-                 *\/\n-                int index1 = s.indexOf(\"<html>\");\n-                int index2 = s.indexOf(\"<\/html>\");\n-                String str = \"\";\n-                if (index2 >= 0) {\n-                    str = s.substring(index2 + \"<\/html>\".length());\n-                    s = s.substring(index1, index2 + + \"<\/html>\".length());\n+            if (nl >= 0) {\n+                \/\/ break up newlines\n+                if (nl == 0) {\n+                    JPanel breakPanel = new JPanel() {\n+                        public Dimension getPreferredSize() {\n+                            Font f = getFont();\n+\n+                            if (f != null) {\n+                                return new Dimension(1, f.getSize() + 2);\n+                            }\n+                            return new Dimension(0, 0);\n+                        }\n+                    };\n+                    breakPanel.setName(\"OptionPane.break\");\n+                    addMessageComponents(container, cons, breakPanel, maxll,\n+                                         true);\n+                } else {\n+                    addMessageComponents(container, cons, s.substring(0, nl),\n+                                         maxll, false);\n+                }\n+                \/\/ Prevent recursion of more than\n+                \/\/ 200 successive newlines in a message\n+                \/\/ and indicate message is truncated via ellipsis\n+                if (recursionCount++ > 200) {\n+                    recursionCount = 0;\n+                    addMessageComponents(container, cons, new String(\"...\"),\n+                                         maxll, false);\n+                    return;\n@@ -469,2 +484,11 @@\n-                JLabel label;\n-                label = new JLabel(s, JLabel.LEADING);\n+                addMessageComponents(container, cons, s.substring(nl + nll), maxll,\n+                                     false);\n+\n+            } else if (len > maxll) {\n+                Container c = Box.createVerticalBox();\n+                c.setName(\"OptionPane.verticalBox\");\n+                burstStringInto(c, s, maxll);\n+                addMessageComponents(container, cons, c, maxll, true);\n+\n+            } else {\n+                JLabel label = new JLabel();\n@@ -472,1 +496,1 @@\n-                    this.optionPane.getClientProperty(\"html.disable\"))) {\n+                    optionPane.getClientProperty(\"html.disable\"))) {\n@@ -475,0 +499,1 @@\n+                label.setText(s);\n@@ -478,49 +503,0 @@\n-                if (!str.isEmpty()) {\n-                    addMessageComponents(container, cons, str, maxll, false);\n-                }\n-            } else {\n-                if (nl >= 0) {\n-                    \/\/ break up newlines\n-                    if (nl == 0) {\n-                                JPanel breakPanel = new JPanel() {\n-                            public Dimension getPreferredSize() {\n-                                Font f = getFont();\n-\n-                                if (f != null) {\n-                                    return new Dimension(1, f.getSize() + 2);\n-                                }\n-                                return new Dimension(0, 0);\n-                            }\n-                        };\n-                        breakPanel.setName(\"OptionPane.break\");\n-                        addMessageComponents(container, cons, breakPanel, maxll,\n-                                true);\n-                    } else {\n-                        addMessageComponents(container, cons, s.substring(0, nl),\n-                                maxll, false);\n-                    }\n-                    \/\/ Prevent recursion of more than\n-                    \/\/ 200 successive newlines in a message\n-                    \/\/ and indicate message is truncated via ellipsis\n-                    if (recursionCount++ > 200) {\n-                        recursionCount = 0;\n-                        addMessageComponents(container, cons, new String(\"...\"),\n-                                maxll, false);\n-                        return;\n-                    }\n-                    addMessageComponents(container, cons, s.substring(nl + nll), maxll,\n-                            false);\n-\n-                } else if (len > maxll) {\n-                    Container c = Box.createVerticalBox();\n-                    c.setName(\"OptionPane.verticalBox\");\n-                    burstStringInto(c, s, maxll);\n-                    addMessageComponents(container, cons, c, maxll, true);\n-\n-                } else {\n-                    JLabel label;\n-                    label = new JLabel(s, JLabel.LEADING);\n-                    label.setName(\"OptionPane.label\");\n-                    configureMessageLabel(label);\n-                    addMessageComponents(container, cons, label, maxll, true);\n-                }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicOptionPaneUI.java","additions":41,"deletions":65,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1901,1 +1901,3 @@\n-        if (usrClip == null) {\n+        final Shape clip = usrClip;\n+\n+        if (clip == null) {\n@@ -1904,1 +1906,1 @@\n-        } else if (usrClip instanceof Rectangle2D) {\n+        } else if (clip instanceof Rectangle2D rect2d) {\n@@ -1906,1 +1908,1 @@\n-            clipRegion = devClip.getIntersection((Rectangle2D) usrClip);\n+            clipRegion = devClip.getIntersection(rect2d);\n@@ -1908,1 +1910,1 @@\n-            PathIterator cpi = usrClip.getPathIterator(null);\n+            PathIterator cpi = clip.getPathIterator(null);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SunGraphics2D.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+\n+import sun.java2d.InvalidPipeException;\n@@ -70,1 +72,3 @@\n-\n+        if (ri.region.isRectangular()) {\n+            throw new InvalidPipeException(\"Invalid clip data\");\n+        }\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/SpanClipRenderer.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,1 @@\n+#include \"safe_math.h\"\n@@ -275,0 +276,3 @@\n+  if (!SAFE_TO_MULT(3, wid_e) || !SAFE_TO_ADD(3 * wid_e, m)) {\n+    return MLIB_FAILURE;\n+  }\n@@ -632,0 +636,3 @@\n+  if (!SAFE_TO_MULT(3, wid_e) || !SAFE_TO_ADD(3 * wid_e, m)) {\n+    return MLIB_FAILURE;\n+  }\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/mlib_ImageConvMxN_Fp.c","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,1 @@\n+#include \"safe_math.h\"\n@@ -232,0 +233,3 @@\n+  if (!SAFE_TO_MULT(3, wid_e) || !SAFE_TO_ADD(3 * wid_e, m)) {\n+    return MLIB_FAILURE;\n+  }\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/mlib_ImageConvMxN_ext.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"safe_math.h\"\n@@ -263,0 +264,3 @@\n+  if (!SAFE_TO_ADD(max_hsize, (n - 1))) {\n+    return MLIB_FAILURE;\n+  }\n@@ -265,0 +269,3 @@\n+  if (!SAFE_TO_ADD(smax_hsize, 1) || !SAFE_TO_MULT(2, (smax_hsize + 1))) {\n+    return MLIB_FAILURE;\n+  }\n@@ -512,0 +519,4 @@\n+  if (!SAFE_TO_ADD(wid, (m - 1))) {\n+    status = MLIB_FAILURE;\n+    FREE_AND_RETURN_STATUS;\n+  }\n@@ -514,0 +525,4 @@\n+  if (!SAFE_TO_MULT((n + 3), swid)) {\n+    status = MLIB_FAILURE;\n+    FREE_AND_RETURN_STATUS;\n+  }\n@@ -922,0 +937,3 @@\n+  if (!SAFE_TO_ADD(wid, (m - 1))) {\n+    return MLIB_FAILURE;\n+  }\n@@ -924,0 +942,3 @@\n+  if (!SAFE_TO_MULT((n + 2), swid)) {\n+    return MLIB_FAILURE;\n+  }\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/mlib_ImageConv_16ext.c","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"safe_math.h\"\n@@ -469,0 +470,4 @@\n+  if (!SAFE_TO_MULT((n + 3), wid)) {\n+    status = MLIB_FAILURE;\n+    FREE_AND_RETURN_STATUS;\n+  }\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/mlib_ImageConv_16nw.c","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"safe_math.h\"\n@@ -338,0 +339,4 @@\n+  if (!SAFE_TO_MULT((n + 2), wid)) {\n+    status = MLIB_FAILURE;\n+    FREE_AND_RETURN_STATUS;\n+  }\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/mlib_ImageConv_32nw.c","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"safe_math.h\"\n@@ -248,0 +249,3 @@\n+  if (!SAFE_TO_ADD(max_hsize, (n - 1))) {\n+    return MLIB_FAILURE;\n+  }\n@@ -250,0 +254,3 @@\n+  if (!SAFE_TO_ADD(smax_hsize, 1) || !SAFE_TO_MULT(2, (smax_hsize + 1))) {\n+    return MLIB_FAILURE;\n+  }\n@@ -497,0 +504,4 @@\n+  if (!SAFE_TO_ADD(wid, (m - 1))) {\n+    status = MLIB_FAILURE;\n+    FREE_AND_RETURN_STATUS;\n+  }\n@@ -499,0 +510,4 @@\n+  if (!SAFE_TO_MULT((n + 3), swid)) {\n+    status = MLIB_FAILURE;\n+    FREE_AND_RETURN_STATUS;\n+  }\n@@ -907,0 +922,3 @@\n+  if (!SAFE_TO_ADD(wid, (m - 1))) {\n+    return MLIB_FAILURE;\n+  }\n@@ -909,0 +927,3 @@\n+  if (!SAFE_TO_MULT((n + 2), swid)) {\n+    return MLIB_FAILURE;\n+  }\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/mlib_ImageConv_8ext.c","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"safe_math.h\"\n@@ -470,0 +471,4 @@\n+  if (!SAFE_TO_MULT((n + 3), wid)) {\n+    status = MLIB_FAILURE;\n+    FREE_AND_RETURN_STATUS;\n+  }\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/mlib_ImageConv_8nw.c","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"safe_math.h\"\n@@ -273,0 +274,3 @@\n+  if (!SAFE_TO_ADD(max_hsize, (n - 1))) {\n+    return MLIB_FAILURE;\n+  }\n@@ -275,0 +279,3 @@\n+  if (!SAFE_TO_ADD(smax_hsize, 1) || !SAFE_TO_MULT(2, (smax_hsize + 1))) {\n+    return MLIB_FAILURE;\n+  }\n@@ -522,0 +529,4 @@\n+  if (!SAFE_TO_ADD(wid, (m - 1))) {\n+    status = MLIB_FAILURE;\n+    FREE_AND_RETURN_STATUS;\n+  }\n@@ -524,0 +535,4 @@\n+  if (!SAFE_TO_MULT((n + 3), swid)) {\n+    status = MLIB_FAILURE;\n+    FREE_AND_RETURN_STATUS;\n+  }\n@@ -930,0 +945,3 @@\n+  if (!SAFE_TO_ADD(wid, (m - 1))) {\n+    return MLIB_FAILURE;\n+  }\n@@ -932,0 +950,3 @@\n+  if (!SAFE_TO_MULT((n + 2), swid)) {\n+    return MLIB_FAILURE;\n+  }\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/mlib_ImageConv_u16ext.c","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"safe_math.h\"\n@@ -469,0 +470,4 @@\n+  if (!SAFE_TO_MULT((n + 3), wid)) {\n+    status = MLIB_FAILURE;\n+    FREE_AND_RETURN_STATUS;\n+  }\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/mlib_ImageConv_u16nw.c","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+#include \"safe_math.h\"\n@@ -305,0 +306,3 @@\n+  if (!SAFE_TO_MULT(xsize, 2)) {\n+    return MLIB_FAILURE;\n+  }\n@@ -443,0 +447,3 @@\n+  if (!SAFE_TO_MULT(3, xsize)) {\n+    return MLIB_FAILURE;\n+  }\n@@ -586,0 +593,3 @@\n+  if (!SAFE_TO_MULT(xsize, 4)) {\n+    return MLIB_FAILURE;\n+  }\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/mlib_ImageLookUp_Bit.c","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,0 +104,5 @@\n+  int intSize = sizeof(mlib_s32);\n+  if (!SAFE_TO_MULT(dstHeight, intSize) ||\n+      !SAFE_TO_ADD(dstHeight * intSize, 7)) {\n+    return MLIB_FAILURE;\n+  }\n@@ -112,0 +117,4 @@\n+  if (!SAFE_TO_MULT(4, bsize0) || !SAFE_TO_ADD(4 * bsize0, bsize1)) {\n+    return MLIB_FAILURE;\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libmlib_image\/mlib_ImageScanPoly.c","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,3 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n@@ -53,3 +56,5 @@\n-    private static String ACTION_OPEN_VERB = \"open\";\n-    private static String ACTION_EDIT_VERB = \"edit\";\n-    private static String ACTION_PRINT_VERB = \"print\";\n+    private static final String ACTION_OPEN_VERB = \"open\";\n+    private static final String ACTION_EDIT_VERB = \"edit\";\n+    private static final String ACTION_PRINT_VERB = \"print\";\n+    private static final String ACTION_BROWSE_VERB = \"browse\";\n+    private static final String ACTION_MAIL_VERB = \"mail\";\n@@ -98,1 +103,1 @@\n-        this.ShellExecute(uri, ACTION_OPEN_VERB);\n+        this.ShellExecute(uri, ACTION_MAIL_VERB);\n@@ -103,1 +108,1 @@\n-        this.ShellExecute(uri, ACTION_OPEN_VERB);\n+        this.launchUriInBrowser(uri);\n@@ -124,0 +129,36 @@\n+    private void launchUriInBrowser(URI uri) throws IOException {\n+        String defaultBrowser = getDefaultBrowser();\n+        if (defaultBrowser == null) {\n+            throw new IOException(\"Failed to get default browser\");\n+        }\n+\n+        List<String> cmdLineTokens = getCmdLineTokens(uri, defaultBrowser);\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(cmdLineTokens);\n+            pb.start();\n+        }  catch (Exception e) {\n+            throw new IOException(\"Error launching Browser: \", e);\n+        }\n+    }\n+\n+    private static List<String> getCmdLineTokens(URI uri, String defaultBrowser) {\n+        if (defaultBrowser.contains(\"%1\")) {\n+            defaultBrowser = defaultBrowser.replace(\"%1\", uri.toString());\n+        } else {\n+            defaultBrowser = defaultBrowser + \" \" + uri.toString();\n+        }\n+\n+        List<String> cmdLineTokens = new ArrayList<>();\n+        int firstIndex = defaultBrowser.indexOf(\"\\\"\");\n+        int secondIndex = defaultBrowser.indexOf(\"\\\"\", firstIndex + 1);\n+\n+        if (firstIndex == 0 && secondIndex != firstIndex) {\n+            cmdLineTokens.add(defaultBrowser.substring(firstIndex, secondIndex + 1));\n+            defaultBrowser = defaultBrowser.substring(secondIndex + 1).trim();\n+        }\n+        cmdLineTokens.addAll(Arrays.asList(defaultBrowser.split(\" \")));\n+        return cmdLineTokens;\n+    }\n+\n+    private static native String getDefaultBrowser();\n+\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WDesktopPeer.java","additions":47,"deletions":6,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,6 @@\n+#include <Windows.h>\n+#include <shlwapi.h>  \/\/ for AssocQueryStringW\n+#include <wchar.h>\n+#include <cwchar>\n+#include <string.h>\n+#include <winsafer.h> \/\/ for SaferiIsExecutableFileType\n@@ -81,0 +87,1 @@\n+\n@@ -85,0 +92,8 @@\n+    if (wcscmp(verb_c, L\"open\") == 0) {\n+        BOOL isExecutable = SaferiIsExecutableFileType(fileOrUri_c, FALSE);\n+        if (isExecutable) {\n+            return env->NewStringUTF(\"Unsupported URI content\");\n+        }\n+    }\n+    \/\/ set action verb for mail() to open before calling ShellExecute\n+    LPCWSTR actionVerb = wcscmp(verb_c, L\"mail\") == 0 ? L\"open\" : verb_c;\n@@ -88,1 +103,1 @@\n-    HINSTANCE retval = ::ShellExecute(NULL, verb_c, fileOrUri_c, NULL, NULL,\n+    HINSTANCE retval = ::ShellExecute(NULL, actionVerb, fileOrUri_c, NULL, NULL,\n@@ -116,1 +131,0 @@\n-\n@@ -120,0 +134,29 @@\n+\/*\n+ * Class:     sun_awt_windows_WDesktopPeer\n+ * Method:    getDefaultBrowser\n+ * Signature: ()Ljava\/lang\/String;\n+ *\/\n+JNIEXPORT jstring JNICALL Java_sun_awt_windows_WDesktopPeer_getDefaultBrowser\n+(JNIEnv *env, jclass cls)\n+{\n+    LPCWSTR fileExtension = L\"https\";\n+    WCHAR defaultBrowser_c [MAX_PATH];\n+    DWORD cchBuffer = MAX_PATH;\n+\n+    \/\/ Use AssocQueryString to get the default browser\n+    HRESULT hr = AssocQueryStringW(\n+        ASSOCF_NONE,            \/\/ No special flags\n+        ASSOCSTR_COMMAND,       \/\/ Request the command string\n+        fileExtension,          \/\/ File extension\n+        NULL,                   \/\/ pszExtra (optional)\n+        defaultBrowser_c,       \/\/ Output buffer - result\n+        &cchBuffer              \/\/ Size of the output buffer\n+    );\n+\n+    if (FAILED(hr)) {\n+        return NULL;\n+    }\n+\n+    return JNU_NewStringPlatform(env, defaultBrowser_c);\n+}\n+\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Desktop.cpp","additions":46,"deletions":3,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import javax.net.ssl.SSLParameters;\n@@ -122,0 +123,10 @@\n+\n+        if (Boolean.parseBoolean(\n+                System.getProperty(\"jdk.rmi.ssl.client.enableEndpointIdentification\", \"true\"))) {\n+            SSLParameters params = sslSocket.getSSLParameters();\n+            if (params == null) {\n+                params = new SSLParameters();\n+            }\n+            params.setEndpointIdentificationAlgorithm(\"HTTPS\");\n+            sslSocket.setSSLParameters(params);\n+        }\n","filename":"src\/java.rmi\/share\/classes\/javax\/rmi\/ssl\/SslRMIClientSocketFactory.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,1 @@\n-    } else {\n+    } else if (jIn != NULL) {\n@@ -189,0 +189,1 @@\n+      \/\/ may happen if out of memory\n@@ -190,0 +191,2 @@\n+    } else {\n+      inBufP = NULL;\n@@ -197,1 +200,1 @@\n-        if (directIn == 0) {\n+        if (directIn == 0 && inBufP != NULL) {\n@@ -211,1 +214,1 @@\n-    if (directIn == 0) {\n+    if (directIn == 0 && inBufP != NULL) {\n@@ -254,1 +257,1 @@\n-    } else {\n+    } else if (jIn != NULL) {\n@@ -256,0 +259,1 @@\n+      \/\/ may happen if out of memory\n@@ -257,0 +261,2 @@\n+    } else {\n+      inBufP = NULL;\n@@ -264,1 +270,1 @@\n-        if (directIn == 0) {\n+        if (directIn == 0 && inBufP != NULL) {\n@@ -278,1 +284,1 @@\n-    if (directIn == 0) {\n+    if (directIn == 0 && inBufP != NULL) {\n@@ -465,1 +471,1 @@\n-    } else {\n+    } else if (jIn != NULL) {\n@@ -467,0 +473,1 @@\n+      \/\/ may happen if out of memory\n@@ -468,0 +475,2 @@\n+    } else {\n+      inBufP = NULL;\n@@ -475,1 +484,1 @@\n-        if (directIn == 0) {\n+        if (directIn == 0 && inBufP != NULL) {\n@@ -488,1 +497,1 @@\n-    if (directIn == 0) {\n+    if (directIn == 0 && inBufP != NULL) {\n@@ -531,1 +540,1 @@\n-    } else {\n+    } else if (jIn != NULL) {\n@@ -533,0 +542,1 @@\n+      \/\/ may happen if out of memory\n@@ -534,0 +544,2 @@\n+    } else {\n+      inBufP = NULL;\n@@ -541,1 +553,1 @@\n-        if (directIn == 0) {\n+        if (directIn == 0 && inBufP != NULL) {\n@@ -554,1 +566,1 @@\n-    if (directIn == 0) {\n+    if (directIn == 0 && inBufP != NULL) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_crypt.c","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import sun.net.httpserver.Utils;\n@@ -179,0 +180,5 @@\n+        \/\/ checkHeader is called in this class to fail fast\n+        \/\/ It also must be called in sendResponseHeaders because\n+        \/\/ Headers instances internal state can be modified\n+        \/\/ external to these methods.\n+        Utils.checkHeader(key, false);\n@@ -180,1 +186,1 @@\n-            checkValue(v);\n+            Utils.checkHeader(v, true);\n@@ -192,1 +198,2 @@\n-        checkValue(value);\n+        Utils.checkHeader(key, false);\n+        Utils.checkHeader(value, true);\n@@ -202,24 +209,0 @@\n-    private static void checkValue(String value) {\n-        int len = value.length();\n-        for (int i=0; i<len; i++) {\n-            char c = value.charAt(i);\n-            if (c == '\\r') {\n-                \/\/ is allowed if it is followed by \\n and a whitespace char\n-                if (i >= len - 2) {\n-                    throw new IllegalArgumentException(\"Illegal CR found in header\");\n-                }\n-                char c1 = value.charAt(i+1);\n-                char c2 = value.charAt(i+2);\n-                if (c1 != '\\n') {\n-                    throw new IllegalArgumentException(\"Illegal char found after CR in header\");\n-                }\n-                if (c2 != ' ' && c2 != '\\t') {\n-                    throw new IllegalArgumentException(\"No whitespace found after CRLF in header\");\n-                }\n-                i+=2;\n-            } else if (c == '\\n') {\n-                throw new IllegalArgumentException(\"Illegal LF found in header\");\n-            }\n-        }\n-    }\n-\n@@ -267,1 +250,1 @@\n-            values.forEach(Headers::checkValue);\n+            values.forEach(value -> Utils.checkHeader(value, true));\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/Headers.java","additions":10,"deletions":27,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -201,0 +201,2 @@\n+    private static final byte[] CRLF = new byte[] {0x0D, 0x0A};\n+\n@@ -209,1 +211,1 @@\n-        String statusLine = \"HTTP\/1.1 \"+rCode+Code.msg(rCode)+\"\\r\\n\";\n+        String statusLine = \"HTTP\/1.1 \"+rCode+Code.msg(rCode);\n@@ -212,1 +214,2 @@\n-        tmpout.write (bytes(statusLine, 0), 0, statusLine.length());\n+        tmpout.write (bytes(statusLine, false, 0), 0, statusLine.length());\n+        tmpout.write (CRLF);\n@@ -299,1 +302,1 @@\n-                buf = bytes (key, 2);\n+                buf = bytes (key, true, 2);\n@@ -303,1 +306,1 @@\n-                buf = bytes (val, 2);\n+                buf = bytes (val, false, 2);\n@@ -321,0 +324,5 @@\n+     *\n+     * Header values are supposed to be limited to 7-bit ASCII\n+     * but 8-bit has to be allowed (for ISO_8859_1). For efficiency\n+     * we just down cast 16 bit Java chars to byte. We don't allow\n+     * any character that can't be encoded in 8 bits.\n@@ -322,1 +330,2 @@\n-    private byte[] bytes (String s, int extra) {\n+    private byte[] bytes (String s, boolean isKey, int extra) throws IOException {\n+        Utils.checkHeader(s, !isKey);\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ExchangeImpl.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -91,0 +91,33 @@\n+\n+    \/* Throw IAE if illegal character found.  isValue is true if String is\n+     * a value. Otherwise it is header name\n+     *\/\n+    public static void checkHeader(String str, boolean isValue) {\n+        int len = str.length();\n+        for (int i=0; i<len; i++) {\n+            char c = str.charAt(i);\n+            if (c == '\\r') {\n+                if (!isValue) {\n+                    throw new IllegalArgumentException(\"Illegal CR found in header\");\n+                }\n+                \/\/ is allowed if it is followed by \\n and a whitespace char\n+                if (i >= len - 2) {\n+                    throw new IllegalArgumentException(\"Illegal CR found in header\");\n+                }\n+                char c1 = str.charAt(i+1);\n+                char c2 = str.charAt(i+2);\n+                if (c1 != '\\n') {\n+                    throw new IllegalArgumentException(\"Illegal char found after CR in header\");\n+                }\n+                if (c2 != ' ' && c2 != '\\t') {\n+                    throw new IllegalArgumentException(\"No whitespace found after CRLF in header\");\n+                }\n+                i+=2;\n+            } else if (c == '\\n') {\n+                throw new IllegalArgumentException(\"Illegal LF found in header\");\n+            } else if (c > 255) {\n+                throw new IllegalArgumentException(\"Illegal character found in header\");\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/Utils.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -186,0 +186,10 @@\n+\n+# Mechanically added:\n+runtime\/Thread\/TestThreadDumpMonitorContention.java 8361370 windows-x64\n+runtime\/Thread\/StopAtExit.java 8365835 linux-x64\n+runtime\/Thread\/SetPriorityAtExit.java 8365835 linux-x64\n+runtime\/Thread\/SuspendAtExit.java 8365835 linux-x64\n+runtime\/Thread\/SetNameAtExit.java 8365835 linux-x64\n+runtime\/8176717\/TestInheritFD.java 8347001 linux-x64\n+vmTestbase\/nsk\/jdi\/stress\/serial\/mixed002\/TestDescription.java 8291514 macosx-aarch64\n+serviceability\/jvmti\/RedefineClasses\/ClassVersionAfterRedefine.java 8369953 linux-aarch64,linux-x64,macosx-aarch64,windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -831,0 +831,4 @@\n+\n+# Mechanically added:\n+javax\/sound\/midi\/Soundbanks\/ExtraCharInSoundbank.java 8350613 linux-aarch64,linux-x64\n+java\/net\/CookieHandler\/B6644726.java 8366103 linux-aarch64,linux-x64,macosx-aarch64,windows-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,3 +43,19 @@\n-            This test could launch default file manager to open user's home\n-            directory, and default web browser to show the URL of java vendor.\n-            After test execution close the native file manager and web browser\n+            Set your default browser as per the test platform.\n+            macOS - Safari\n+            windows - MS Edge\n+            linux - Firefox\n+\n+            This test checks 2 cases:\n+\n+            1) Directory URI:\n+               On macOS and windows, verify that a browser window opens and\n+               EITHER the browser OR native file manager shows the user's\n+               home directory.\n+\n+               On Linux verify that the user's home directory is shown by the\n+               default file manager.\n+\n+            2) Web URI:\n+               Verify that the Web URI (URL of java vendor) opens in the browser.\n+\n+            After test execution close the native file manager and any web browser\n@@ -47,0 +63,1 @@\n+\n@@ -56,1 +73,1 @@\n-        boolean failed = false;\n+        PassFailJFrame.log(\"Testing 1st case: Directory URI ...\");\n@@ -65,0 +82,1 @@\n+        PassFailJFrame.log(\"Testing 2nd case: Web URI ...\");\n","filename":"test\/jdk\/java\/awt\/Desktop\/BrowseTest.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-            If you see any EXCEPTION messages in the output press FAIL.\n+            If you see any EXCEPTION messages in case of .txt file in the output press FAIL.\n","filename":"test\/jdk\/java\/awt\/Desktop\/EditAndPrintTest\/EditAndPrintTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365058\n+ * @summary Check basic correctness of de-serialization\n+ * @run junit SerializationTest\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class SerializationTest {\n+\n+    \/\/ Ensure basic serialization round trip correctness\n+    @ParameterizedTest\n+    @MethodSource\n+    void roundTripTest(CopyOnWriteArraySet<?> expected) {\n+        var bytes = ser(expected);\n+        var actual = deSer(bytes);\n+        assertEquals(CopyOnWriteArraySet.class, actual.getClass());\n+        assertEquals(expected, actual);\n+    }\n+\n+    private static Stream<CopyOnWriteArraySet<?>> roundTripTest() {\n+        return Stream.of(\n+                new CopyOnWriteArraySet<>(),\n+                new CopyOnWriteArraySet<>(List.of(1, 2, 3)),\n+                new CopyOnWriteArraySet<>(Set.of(\"Foo\", \"Bar\", \"Baz\"))\n+        );\n+    }\n+\n+    private static byte[] ser(Object obj) {\n+        return assertDoesNotThrow(() -> {\n+            try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+                 ObjectOutputStream oos = new ObjectOutputStream(byteArrayOutputStream)) {\n+                oos.writeObject(obj);\n+                return byteArrayOutputStream.toByteArray();\n+            }\n+        }, \"Unexpected error during serialization\");\n+    }\n+\n+    private static Object deSer(byte[] bytes) {\n+        return assertDoesNotThrow(() -> {\n+            try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n+                 ObjectInputStream ois = new ObjectInputStream(byteArrayInputStream)) {\n+                return ois.readObject();\n+            }\n+        }, \"Unexpected error during de-serialization\");\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/CopyOnWriteArraySet\/SerializationTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -402,0 +402,2 @@\n+        opts.add(\"-Djdk.rmi.ssl.client.enableEndpointIdentification=false\");\n+\n","filename":"test\/jdk\/javax\/management\/security\/SecurityTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,0 +137,1 @@\n+        System.setProperty(\"jdk.rmi.ssl.client.enableEndpointIdentification\", \"false\");\n@@ -156,1 +157,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/javax\/rmi\/ssl\/SSLSocketParametersTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/* @test\n- * @bug 5074006\n- * @key headful\n- * @library \/java\/awt\/regtesthelpers\n- * @build PassFailJFrame\n- * @summary Swing JOptionPane shows <html> tag as a string after newline\n- * @run main\/manual TestJOptionHTMLTag\n-*\/\n-\n-import javax.swing.JDialog;\n-import javax.swing.JOptionPane;\n-import javax.swing.SwingUtilities;\n-\n-public class TestJOptionHTMLTag {\n-    static String instructions\n-            = \"\"\"\n-            INSTRUCTIONS:\n-                A dialog will be shown.\n-                If it does not contain <\/html> string, press Pass else press Fail.\n-            \"\"\";\n-    static PassFailJFrame passFailJFrame;\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        SwingUtilities.invokeAndWait(() -> {\n-            try {\n-                String message = \"<html>\" + \"This is a test\\n\" + \"<\/html>\";\n-                JOptionPane optionPane = new JOptionPane();\n-                optionPane.setMessage(message);\n-                optionPane.setMessageType(JOptionPane.INFORMATION_MESSAGE);\n-                JDialog dialog = new JDialog();\n-                dialog.setContentPane(optionPane);\n-                dialog.pack();\n-                dialog.setVisible(true);\n-\n-                passFailJFrame = new PassFailJFrame(instructions);\n-                PassFailJFrame.addTestWindow(dialog);\n-                PassFailJFrame.positionTestWindow(dialog, PassFailJFrame.Position.HORIZONTAL);\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-            }\n-        });\n-        passFailJFrame.awaitAndCheck();\n-    }\n-}\n-\n","filename":"test\/jdk\/javax\/swing\/JOptionPane\/TestJOptionHTMLTag.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,0 +209,1 @@\n+                args.add(\"-Djdk.rmi.ssl.client.enableEndpointIdentification=false\");\n","filename":"test\/jdk\/sun\/management\/jmxremote\/bootstrap\/JMXInterfaceBindingTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,0 +172,1 @@\n+        System.setProperty(\"jdk.rmi.ssl.client.enableEndpointIdentification\", \"false\");\n","filename":"test\/jdk\/sun\/management\/jmxremote\/bootstrap\/RmiBootstrapTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -182,0 +182,2 @@\n+            command.add(\"-Djdk.rmi.ssl.client.enableEndpointIdentification=false\");\n+            Collections.addAll(command, Utils.getTestJavaOpts());\n@@ -185,0 +187,2 @@\n+            command.add(\"-cp\");\n+            command.add(TEST_CLASS_PATH);\n","filename":"test\/jdk\/sun\/management\/jmxremote\/bootstrap\/RmiRegistrySslTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.security.Security;\n@@ -72,0 +73,1 @@\n+        Security.setProperty(\"com.sun.security.allowedAIALocations\", \"any\");\n","filename":"test\/jdk\/sun\/security\/x509\/URICertStore\/AIACertTimeout.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.security.Security;\n@@ -50,1 +51,0 @@\n-import java.util.Arrays;\n@@ -70,19 +70,21 @@\n-    private static final String CA_CERT = \"\"\n-        + \"-----BEGIN CERTIFICATE-----\\n\"\n-        + \"MIIC8TCCAdmgAwIBAgIJAJsSNtj5wdqqMA0GCSqGSIb3DQEBDQUAMA8xDTALBgNV\\n\"\n-        + \"BAMMBFJvb3QwHhcNMTUwOTAxMTgwMzU5WhcNNDMwMTE3MTgwMzU5WjAPMQ0wCwYD\\n\"\n-        + \"VQQDDARSb290MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvj892vPm\\n\"\n-        + \"bB++x9QqqyBveP+ZqQ2B1stV7vh5JmDnOTevkZUOcemp3SXu\/esNLSbpL+fARYXH\\n\"\n-        + \"V5ubnrfip6RbvcxPfVIIDJrRTLIIsU6W7M6\/LJLbLkEVGy4ZV4IHkOw9W2O92rcv\\n\"\n-        + \"BkoqhzZnOTGR6uT3rRcKx4RevEKBKhZO+OPPf\/\/lnckOybmYL7t7yQrajzHro76b\\n\"\n-        + \"QTXYjAUq\/DKhglXfC7vF\/JzlAvG2IunGmIfjGcnuDo\/9X3Bxef\/q5TxCS35fvb7t\\n\"\n-        + \"svC+g2QhTcBkQh4uNW2jSjlTIVp1uErCfP5aCjLaez5mqmb1hxPIlcvsNR23HwU6\\n\"\n-        + \"bQO7z7NBo9Do6QIDAQABo1AwTjAdBgNVHQ4EFgQUmLZNOBBkqdYoElyxklPYHmAb\\n\"\n-        + \"QXIwHwYDVR0jBBgwFoAUmLZNOBBkqdYoElyxklPYHmAbQXIwDAYDVR0TBAUwAwEB\\n\"\n-        + \"\/zANBgkqhkiG9w0BAQ0FAAOCAQEAYV4fOhDi5q7+XNXCxO8Eil2frR9jqdP4LaQp\\n\"\n-        + \"3L0evW0gvPX68s2WmkPWzIu4TJcpdGFQqxyQFSXuKBXjthyiln77QItGTHWeafES\\n\"\n-        + \"q5ESrKdSaJZq1bTIrrReCIP74f+fY\/F4Tnb3dCqzaljXfzpdbeRsIW6gF71xcOUQ\\n\"\n-        + \"nnPEjGVPLUegN+Wn\/jQpeLxxIB7FmNXncdRUfMfZ43xVSKuMCy1UUYqJqTa\/pXZj\\n\"\n-        + \"jCMeRPThRjRqHlJ69jStfWUQATbLyj9KN09rUaJxzmUSt61UqJi7sjcGySaCjAJc\\n\"\n-        + \"IcCdVmX\/DmRLsdv8W36O3MgrvpT1zR3kaAlv2d8HppnBqcL3xg==\\n\"\n-        + \"-----END CERTIFICATE-----\";\n+    private static final String CA_CERT =\n+            \"\"\"\n+            -----BEGIN CERTIFICATE-----\n+            MIIC8TCCAdmgAwIBAgIJAJsSNtj5wdqqMA0GCSqGSIb3DQEBDQUAMA8xDTALBgNV\n+            BAMMBFJvb3QwHhcNMTUwOTAxMTgwMzU5WhcNNDMwMTE3MTgwMzU5WjAPMQ0wCwYD\n+            VQQDDARSb290MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvj892vPm\n+            bB++x9QqqyBveP+ZqQ2B1stV7vh5JmDnOTevkZUOcemp3SXu\/esNLSbpL+fARYXH\n+            V5ubnrfip6RbvcxPfVIIDJrRTLIIsU6W7M6\/LJLbLkEVGy4ZV4IHkOw9W2O92rcv\n+            BkoqhzZnOTGR6uT3rRcKx4RevEKBKhZO+OPPf\/\/lnckOybmYL7t7yQrajzHro76b\n+            QTXYjAUq\/DKhglXfC7vF\/JzlAvG2IunGmIfjGcnuDo\/9X3Bxef\/q5TxCS35fvb7t\n+            svC+g2QhTcBkQh4uNW2jSjlTIVp1uErCfP5aCjLaez5mqmb1hxPIlcvsNR23HwU6\n+            bQO7z7NBo9Do6QIDAQABo1AwTjAdBgNVHQ4EFgQUmLZNOBBkqdYoElyxklPYHmAb\n+            QXIwHwYDVR0jBBgwFoAUmLZNOBBkqdYoElyxklPYHmAbQXIwDAYDVR0TBAUwAwEB\n+            \/zANBgkqhkiG9w0BAQ0FAAOCAQEAYV4fOhDi5q7+XNXCxO8Eil2frR9jqdP4LaQp\n+            3L0evW0gvPX68s2WmkPWzIu4TJcpdGFQqxyQFSXuKBXjthyiln77QItGTHWeafES\n+            q5ESrKdSaJZq1bTIrrReCIP74f+fY\/F4Tnb3dCqzaljXfzpdbeRsIW6gF71xcOUQ\n+            nnPEjGVPLUegN+Wn\/jQpeLxxIB7FmNXncdRUfMfZ43xVSKuMCy1UUYqJqTa\/pXZj\n+            jCMeRPThRjRqHlJ69jStfWUQATbLyj9KN09rUaJxzmUSt61UqJi7sjcGySaCjAJc\n+            IcCdVmX\/DmRLsdv8W36O3MgrvpT1zR3kaAlv2d8HppnBqcL3xg==\n+            -----END CERTIFICATE-----\n+            \"\"\";\n@@ -109,20 +111,21 @@\n-    private static final String EE_CERT = \"\"\n-        + \"-----BEGIN CERTIFICATE-----\\n\"\n-        + \"MIIDHTCCAgWgAwIBAgIBBzANBgkqhkiG9w0BAQ0FADAPMQ0wCwYDVQQDDARSb290\\n\"\n-        + \"MB4XDTE1MDkwMTE4MDM1OVoXDTQzMDExNzE4MDM1OVowDTELMAkGA1UEAwwCRUUw\\n\"\n-        + \"ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCpyz97liuWPDYcLH9TX8Bi\\n\"\n-        + \"T78olCmAfmevvch6ncXUVuCzbdaKuKXwn4EVbDszsVJLoK5zdtP+X3iDhutj+IgK\\n\"\n-        + \"mLhuczF3M9VIcWr+JJUyTH4+3h\/RT8cjCDZOmk9iXkb5ifruVsLqzb9g+Vp140Oz\\n\"\n-        + \"7leikne7KmclHvTfvFd0WDI7Gb9vo4f5rT717BXJ\/n+M6pNk8DLpLiEu6eziYvXR\\n\"\n-        + \"v5x+t5Go3x0eCXdaxEQUf2j876Wfr2qHRJK7lDfFe1DDsMg\/KpKGiILYZ+g2qtVM\\n\"\n-        + \"ZSxtp5BZEtfB5qV\/IE5kWO+mCIAGpXSZIdbERR6pZUq8GLEe1T9e+sO6H24w2F19\\n\"\n-        + \"AgMBAAGjgYUwgYIwNAYDVR0fBC0wKzApoCegJYYjbGRhcDovL2xkYXAuaG9zdC5m\\n\"\n-        + \"b3IuY3JsZHAvbWFpbi5jcmwwSgYIKwYBBQUHAQEEPjA8MDoGCCsGAQUFBzAChi5s\\n\"\n-        + \"ZGFwOi8vbGRhcC5ob3N0LmZvci5haWEvZGM9Um9vdD9jQUNlcnRpZmljYXRlMA0G\\n\"\n-        + \"CSqGSIb3DQEBDQUAA4IBAQBWDfZHpuUx0yn5d3+BuztFqoks1MkGdk+USlH0TB1\/\\n\"\n-        + \"gWWBd+4S4PCKlpSur0gj2rMW4fP5HQfNlHci8JV8\/bG4KuKRAXW56dg1818Hl3pc\\n\"\n-        + \"iIrUSRn8uUjH3p9qb+Rb\/u3mmVQRyJjN2t\/zceNsO8\/+Dd808OB9aEwGs8lMT0nn\\n\"\n-        + \"ZYaaAqYz1GIY\/Ecyx1vfEZEQ1ljo6i\/r70C3igbypBUShxSiGsleiVTLOGNA+MN1\\n\"\n-        + \"\/a\/Qh0bkaQyTGqK3bwvzzMeQVqWu2EWTBD\/PmND5ExkpRICdv8LBVXfLnpoBr4lL\\n\"\n-        + \"hnxn9+e0Ah+t8dS5EKfn44w5bI5PCu2bqxs6RCTxNjcY\\n\"\n-        + \"-----END CERTIFICATE-----\";\n+    private static final String EE_CERT =\n+            \"\"\"\n+            -----BEGIN CERTIFICATE-----\n+            MIIDHTCCAgWgAwIBAgIBBzANBgkqhkiG9w0BAQ0FADAPMQ0wCwYDVQQDDARSb290\n+            MB4XDTE1MDkwMTE4MDM1OVoXDTQzMDExNzE4MDM1OVowDTELMAkGA1UEAwwCRUUw\n+            ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCpyz97liuWPDYcLH9TX8Bi\n+            T78olCmAfmevvch6ncXUVuCzbdaKuKXwn4EVbDszsVJLoK5zdtP+X3iDhutj+IgK\n+            mLhuczF3M9VIcWr+JJUyTH4+3h\/RT8cjCDZOmk9iXkb5ifruVsLqzb9g+Vp140Oz\n+            7leikne7KmclHvTfvFd0WDI7Gb9vo4f5rT717BXJ\/n+M6pNk8DLpLiEu6eziYvXR\n+            v5x+t5Go3x0eCXdaxEQUf2j876Wfr2qHRJK7lDfFe1DDsMg\/KpKGiILYZ+g2qtVM\n+            ZSxtp5BZEtfB5qV\/IE5kWO+mCIAGpXSZIdbERR6pZUq8GLEe1T9e+sO6H24w2F19\n+            AgMBAAGjgYUwgYIwNAYDVR0fBC0wKzApoCegJYYjbGRhcDovL2xkYXAuaG9zdC5m\n+            b3IuY3JsZHAvbWFpbi5jcmwwSgYIKwYBBQUHAQEEPjA8MDoGCCsGAQUFBzAChi5s\n+            ZGFwOi8vbGRhcC5ob3N0LmZvci5haWEvZGM9Um9vdD9jQUNlcnRpZmljYXRlMA0G\n+            CSqGSIb3DQEBDQUAA4IBAQBWDfZHpuUx0yn5d3+BuztFqoks1MkGdk+USlH0TB1\/\n+            gWWBd+4S4PCKlpSur0gj2rMW4fP5HQfNlHci8JV8\/bG4KuKRAXW56dg1818Hl3pc\n+            iIrUSRn8uUjH3p9qb+Rb\/u3mmVQRyJjN2t\/zceNsO8\/+Dd808OB9aEwGs8lMT0nn\n+            ZYaaAqYz1GIY\/Ecyx1vfEZEQ1ljo6i\/r70C3igbypBUShxSiGsleiVTLOGNA+MN1\n+            \/a\/Qh0bkaQyTGqK3bwvzzMeQVqWu2EWTBD\/PmND5ExkpRICdv8LBVXfLnpoBr4lL\n+            hnxn9+e0Ah+t8dS5EKfn44w5bI5PCu2bqxs6RCTxNjcY\n+            -----END CERTIFICATE-----\"\"\";\n@@ -133,1 +136,2 @@\n-\n+        Security.setProperty(\"com.sun.security.allowedAIALocations\",\n+                \"ldap:\/\/\" + targetHost + \"\/dc=Root\");\n@@ -140,2 +144,2 @@\n-        CertPath cp = (CertPath) CertificateFactory.getInstance(\"X509\")\n-                .generateCertPath(Arrays.asList(eeCert));\n+        CertPath cp = CertificateFactory.getInstance(\"X509\")\n+                .generateCertPath(List.of(eeCert));\n@@ -154,1 +158,1 @@\n-        try (SocksProxy proxy = SocksProxy.startProxy(socketConsumer)) {\n+        try (SocksProxy _ = SocksProxy.startProxy(socketConsumer)) {\n","filename":"test\/jdk\/sun\/security\/x509\/URICertStore\/ExtensionsWithLDAP.java","additions":49,"deletions":45,"binary":false,"changes":94,"status":"modified"}]}