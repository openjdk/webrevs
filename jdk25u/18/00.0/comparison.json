{"files":[{"patch":"@@ -1271,0 +1271,12 @@\n+\/\/\n+\/\/ For CmpF\/D + CMoveI\/L, ordered ones are quite straight and simple,\n+\/\/ so, just list behaviour of unordered ones as follow.\n+\/\/\n+\/\/ Set dst (CMoveI (Binary cop (CmpF\/D op1 op2)) (Binary dst src))\n+\/\/ (If one or both inputs to the compare are NaN, then)\n+\/\/    1. (op1 lt op2) => true  => CMove: dst = src\n+\/\/    2. (op1 le op2) => true  => CMove: dst = src\n+\/\/    3. (op1 gt op2) => false => CMove: dst = dst\n+\/\/    4. (op1 ge op2) => false => CMove: dst = dst\n+\/\/    5. (op1 eq op2) => false => CMove: dst = dst\n+\/\/    6. (op1 ne op2) => true  => CMove: dst = src\n@@ -1272,5 +1284,0 @@\n-\/\/ Move src to dst only if cmp1 == cmp2,\n-\/\/ otherwise leave dst unchanged, including the case where one of them is NaN.\n-\/\/ Clarification:\n-\/\/   java code      :  cmp1 != cmp2 ? dst : src\n-\/\/   transformed to :  CMove dst, (cmp1 eq cmp2), dst, src\n@@ -1292,1 +1299,1 @@\n-    \/\/ not jump (i.e. move src to dst) if cmp1 == cmp2\n+    \/\/ fallthrough (i.e. move src to dst) if cmp1 == cmp2\n@@ -1301,5 +1308,0 @@\n-\/\/ Keep dst unchanged only if cmp1 == cmp2,\n-\/\/ otherwise move src to dst, including the case where one of them is NaN.\n-\/\/ Clarification:\n-\/\/   java code      :  cmp1 == cmp2 ? dst : src\n-\/\/   transformed to :  CMove dst, (cmp1 ne cmp2), dst, src\n@@ -1321,1 +1323,1 @@\n-    \/\/ not jump (i.e. move src to dst) if cmp1 != cmp2, including the case of NaN\n+    \/\/ fallthrough (i.e. move src to dst) if cmp1 != cmp2, including the case of NaN\n@@ -1330,8 +1332,0 @@\n-\/\/ When cmp1 <= cmp2 or any of them is NaN then dst = src, otherwise, dst = dst\n-\/\/ Clarification\n-\/\/   scenario 1:\n-\/\/     java code      :  cmp2 < cmp1 ? dst : src\n-\/\/     transformed to :  CMove dst, (cmp1 le cmp2), dst, src\n-\/\/   scenario 2:\n-\/\/     java code      :  cmp1 > cmp2 ? dst : src\n-\/\/     transformed to :  CMove dst, (cmp1 le cmp2), dst, src\n@@ -1353,1 +1347,1 @@\n-    \/\/ not jump (i.e. move src to dst) if cmp1 <= cmp2 or either is NaN\n+    \/\/ fallthrough (i.e. move src to dst) if cmp1 <= cmp2 or either is NaN\n@@ -1362,8 +1356,24 @@\n-\/\/ When cmp1 < cmp2 or any of them is NaN then dst = src, otherwise, dst = dst\n-\/\/ Clarification\n-\/\/   scenario 1:\n-\/\/     java code      :  cmp2 <= cmp1 ? dst : src\n-\/\/     transformed to :  CMove dst, (cmp1 lt cmp2), dst, src\n-\/\/   scenario 2:\n-\/\/     java code      :  cmp1 >= cmp2 ? dst : src\n-\/\/     transformed to :  CMove dst, (cmp1 lt cmp2), dst, src\n+void MacroAssembler::cmov_cmp_fp_ge(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single) {\n+  if (UseZicond) {\n+    if (is_single) {\n+      fle_s(t0, cmp2, cmp1);\n+    } else {\n+      fle_d(t0, cmp2, cmp1);\n+    }\n+    czero_nez(dst, dst, t0);\n+    czero_eqz(t0 , src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  if (is_single) {\n+    \/\/ jump if cmp1 < cmp2 or either is NaN\n+    \/\/ fallthrough (i.e. move src to dst) if cmp1 >= cmp2\n+    float_blt(cmp1, cmp2, no_set, false, true);\n+  } else {\n+    double_blt(cmp1, cmp2, no_set, false, true);\n+  }\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n@@ -1385,1 +1395,1 @@\n-    \/\/ not jump (i.e. move src to dst) if cmp1 < cmp2 or either is NaN\n+    \/\/ fallthrough (i.e. move src to dst) if cmp1 < cmp2 or either is NaN\n@@ -1394,0 +1404,24 @@\n+void MacroAssembler::cmov_cmp_fp_gt(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single) {\n+  if (UseZicond) {\n+    if (is_single) {\n+      flt_s(t0, cmp2, cmp1);\n+    } else {\n+      flt_d(t0, cmp2, cmp1);\n+    }\n+    czero_nez(dst, dst, t0);\n+    czero_eqz(t0 , src, t0);\n+    orr(dst, dst, t0);\n+    return;\n+  }\n+  Label no_set;\n+  if (is_single) {\n+    \/\/ jump if cmp1 <= cmp2 or either is NaN\n+    \/\/ fallthrough (i.e. move src to dst) if cmp1 > cmp2\n+    float_ble(cmp1, cmp2, no_set, false, true);\n+  } else {\n+    double_ble(cmp1, cmp2, no_set, false, true);\n+  }\n+  mv(dst, src);\n+  bind(no_set);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":64,"deletions":30,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -663,0 +663,1 @@\n+  void cmov_cmp_fp_ge(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single);\n@@ -664,0 +665,1 @@\n+  void cmov_cmp_fp_gt(FloatRegister cmp1, FloatRegister cmp2, Register dst, Register src, bool is_single);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}