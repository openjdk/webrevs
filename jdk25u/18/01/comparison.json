{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=jdk-updates\n@@ -4,1 +4,1 @@\n-version=25\n+version=25.0.1\n","filename":".jcheck\/conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-DEFAULT_VERSION_UPDATE=0\n+DEFAULT_VERSION_UPDATE=1\n@@ -36,1 +36,1 @@\n-DEFAULT_VERSION_DATE=2025-09-16\n+DEFAULT_VERSION_DATE=2025-10-21\n","filename":"make\/conf\/version-numbers.conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5347,36 +5347,0 @@\n-\/**\n- * Multiply 32 bit by 32 bit first loop.\n- *\/\n-void MacroAssembler::multiply_32_x_32_loop(Register x, Register xstart, Register x_xstart,\n-                                           Register y, Register y_idx, Register z,\n-                                           Register carry, Register product,\n-                                           Register idx, Register kdx) {\n-  \/\/ jlong carry, x[], y[], z[];\n-  \/\/ for (int idx=ystart, kdx=ystart+1+xstart; idx >= 0; idx--, kdx--) {\n-  \/\/     long product = y[idx] * x[xstart] + carry;\n-  \/\/     z[kdx] = (int)product;\n-  \/\/     carry = product >>> 32;\n-  \/\/ }\n-  \/\/ z[xstart] = (int)carry;\n-\n-  Label L_first_loop, L_first_loop_exit;\n-  blez(idx, L_first_loop_exit);\n-\n-  shadd(t0, xstart, x, t0, LogBytesPerInt);\n-  lwu(x_xstart, Address(t0, 0));\n-\n-  bind(L_first_loop);\n-  subiw(idx, idx, 1);\n-  shadd(t0, idx, y, t0, LogBytesPerInt);\n-  lwu(y_idx, Address(t0, 0));\n-  mul(product, x_xstart, y_idx);\n-  add(product, product, carry);\n-  srli(carry, product, 32);\n-  subiw(kdx, kdx, 1);\n-  shadd(t0, kdx, z, t0, LogBytesPerInt);\n-  sw(product, Address(t0, 0));\n-  bgtz(idx, L_first_loop);\n-\n-  bind(L_first_loop_exit);\n-}\n-\n@@ -5599,0 +5563,1 @@\n+  const Register jdx = tmp1;\n@@ -5604,2 +5569,1 @@\n-  Label L_multiply_64_x_64_loop, L_done;\n-\n+  Label L_done;\n@@ -5609,61 +5573,0 @@\n-  const Register jdx = tmp1;\n-\n-  if (AvoidUnalignedAccesses) {\n-    int base_offset = arrayOopDesc::base_offset_in_bytes(T_INT);\n-    assert((base_offset % (UseCompactObjectHeaders ? 4 :\n-                           (UseCompressedClassPointers ? 8 : 4))) == 0, \"Must be\");\n-\n-    if ((base_offset % 8) == 0) {\n-      \/\/ multiply_64_x_64_loop emits 8-byte load\/store to access two elements\n-      \/\/ at a time from int arrays x and y. When base_offset is 8 bytes, these\n-      \/\/ accesses are naturally aligned if both xlen and ylen are even numbers.\n-      orr(t0, xlen, ylen);\n-      test_bit(t0, t0, 0);\n-      beqz(t0, L_multiply_64_x_64_loop);\n-    }\n-\n-    Label L_second_loop_unaligned, L_third_loop, L_third_loop_exit;\n-\n-    multiply_32_x_32_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);\n-    shadd(t0, xstart, z, t0, LogBytesPerInt);\n-    sw(carry, Address(t0, 0));\n-\n-    bind(L_second_loop_unaligned);\n-    mv(carry, zr);\n-    mv(jdx, ylen);\n-    subiw(xstart, xstart, 1);\n-    bltz(xstart, L_done);\n-\n-    subi(sp, sp, 2 * wordSize);\n-    sd(z, Address(sp, 0));\n-    sd(zr, Address(sp, wordSize));\n-    shadd(t0, xstart, z, t0, LogBytesPerInt);\n-    addi(z, t0, 4);\n-    shadd(t0, xstart, x, t0, LogBytesPerInt);\n-    lwu(product, Address(t0, 0));\n-\n-    blez(jdx, L_third_loop_exit);\n-\n-    bind(L_third_loop);\n-    subiw(jdx, jdx, 1);\n-    shadd(t0, jdx, y, t0, LogBytesPerInt);\n-    lwu(t0, Address(t0, 0));\n-    mul(t1, t0, product);\n-    add(t0, t1, carry);\n-    shadd(tmp6, jdx, z, t1, LogBytesPerInt);\n-    lwu(t1, Address(tmp6, 0));\n-    add(t0, t0, t1);\n-    sw(t0, Address(tmp6, 0));\n-    srli(carry, t0, 32);\n-    bgtz(jdx, L_third_loop);\n-\n-    bind(L_third_loop_exit);\n-    ld(z, Address(sp, 0));\n-    addi(sp, sp, 2 * wordSize);\n-    shadd(t0, xstart, z, t0, LogBytesPerInt);\n-    sw(carry, Address(t0, 0));\n-\n-    j(L_second_loop_unaligned);\n-  }\n-\n-  bind(L_multiply_64_x_64_loop);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":2,"deletions":99,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -1387,4 +1387,0 @@\n-  void multiply_32_x_32_loop(Register x, Register xstart, Register x_xstart,\n-                             Register y, Register y_idx, Register z,\n-                             Register carry, Register product,\n-                             Register idx, Register kdx);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-  \/\/ Misc Intrinsics could depend on RVV\n+  \/\/ Misc Intrinsics that could depend on RVV.\n@@ -208,1 +208,1 @@\n-  if (UseZba || UseRVV) {\n+  if (!AvoidUnalignedAccesses && (UseZba || UseRVV)) {\n@@ -214,1 +214,1 @@\n-      warning(\"CRC32 intrinsic requires Zba or RVV instructions (not available on this CPU)\");\n+      warning(\"CRC32 intrinsic are not available on this CPU.\");\n@@ -328,2 +328,7 @@\n-  if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {\n-    FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, true);\n+  if (!AvoidUnalignedAccesses) {\n+    if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, true);\n+    }\n+  } else if (UseMultiplyToLenIntrinsic) {\n+    warning(\"Intrinsics for BigInteger.multiplyToLen() not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, false);\n@@ -332,2 +337,7 @@\n-  if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {\n-    FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, true);\n+  if (!AvoidUnalignedAccesses) {\n+    if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, true);\n+    }\n+  } else if (UseSquareToLenIntrinsic) {\n+    warning(\"Intrinsics for BigInteger.squareToLen() not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, false);\n@@ -336,2 +346,7 @@\n-  if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {\n-    FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, true);\n+  if (!AvoidUnalignedAccesses) {\n+    if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, true);\n+    }\n+  } else if (UseMontgomeryMultiplyIntrinsic) {\n+    warning(\"Intrinsics for BigInteger.montgomeryMultiply() not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, false);\n@@ -340,2 +355,7 @@\n-  if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {\n-    FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, true);\n+  if (!AvoidUnalignedAccesses) {\n+    if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, true);\n+    }\n+  } else if (UseMontgomerySquareIntrinsic) {\n+    warning(\"Intrinsics for BigInteger.montgomerySquare() not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, false);\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":31,"deletions":11,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1578,3 +1578,8 @@\n-    \/\/ Check if src array address is aligned to HeapWordSize (dst is always aligned)\n-    const TypeInt* toffset = gvn().type(offset)->is_int();\n-    bool aligned = toffset->is_con() && ((toffset->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n+    \/\/ Check if dst array address is aligned to HeapWordSize\n+    bool aligned = (arrayOopDesc::base_offset_in_bytes(T_BYTE) % HeapWordSize == 0);\n+    \/\/ If true, then check if src array address is aligned to HeapWordSize\n+    if (aligned) {\n+      const TypeInt* toffset = gvn().type(offset)->is_int();\n+      aligned = toffset->is_con() && ((arrayOopDesc::base_offset_in_bytes(T_CHAR) +\n+                                       toffset->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n+    }\n@@ -1661,2 +1666,2 @@\n-    bool aligned = tsrc->is_con() && ((tsrc->get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0) &&\n-                   tdst->is_con() && ((tdst->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n+    bool aligned = tsrc->is_con() && ((arrayOopDesc::base_offset_in_bytes(T_BYTE) + tsrc->get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0) &&\n+                   tdst->is_con() && ((arrayOopDesc::base_offset_in_bytes(T_CHAR) + tdst->get_con() * type2aelembytes(T_CHAR)) % HeapWordSize == 0);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1476,3 +1476,8 @@\n-  \/\/ Check if destination address is aligned to HeapWordSize\n-  const TypeInt* tdst = __ gvn().type(start)->is_int();\n-  bool aligned = tdst->is_con() && ((tdst->get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0);\n+  \/\/ Check if src array address is aligned to HeapWordSize\n+  bool aligned = (arrayOopDesc::base_offset_in_bytes(T_BYTE) % HeapWordSize == 0);\n+  \/\/ If true, then check if dst array address is aligned to HeapWordSize\n+  if (aligned) {\n+    const TypeInt* tdst = __ gvn().type(start)->is_int();\n+    aligned = tdst->is_con() && ((arrayOopDesc::base_offset_in_bytes(T_BYTE) +\n+                                  tdst->get_con() * type2aelembytes(T_BYTE)) % HeapWordSize == 0);\n+  }\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1100,0 +1100,16 @@\n+bool WhiteBox::is_asan_enabled() {\n+#ifdef ADDRESS_SANITIZER\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n+bool WhiteBox::is_ubsan_enabled() {\n+#ifdef UNDEFINED_BEHAVIOR_SANITIZER\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n@@ -1911,0 +1927,8 @@\n+WB_ENTRY(jboolean, WB_IsAsanEnabled(JNIEnv* env))\n+  return (jboolean) WhiteBox::is_asan_enabled();\n+WB_END\n+\n+WB_ENTRY(jboolean, WB_IsUbsanEnabled(JNIEnv* env))\n+  return (jboolean) WhiteBox::is_ubsan_enabled();\n+WB_END\n+\n@@ -2911,0 +2935,2 @@\n+  {CC\"isAsanEnabled\", CC\"()Z\",                        (void*)&WB_IsAsanEnabled },\n+  {CC\"isUbsanEnabled\", CC\"()Z\",                       (void*)&WB_IsUbsanEnabled },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,3 @@\n+  \/\/ provide info about enabling of Address Sanitizer \/ Undefined Behavior Sanitizer\n+  static bool is_asan_enabled();\n+  static bool is_ubsan_enabled();\n","filename":"src\/hotspot\/share\/prims\/whitebox.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1019,0 +1019,1 @@\n+    JNU_CHECK_EXCEPTION_RETURN(env, RESULT_ERROR);\n@@ -1124,1 +1125,1 @@\n-\n+    JNU_CHECK_EXCEPTION_RETURN(env, RESULT_ERROR);\n@@ -1154,0 +1155,1 @@\n+    JNU_CHECK_EXCEPTION_RETURN(env, RESULT_ERROR);\n@@ -1181,0 +1183,1 @@\n+    JNU_CHECK_EXCEPTION_RETURN(env, RESULT_ERROR);\n@@ -1209,1 +1212,1 @@\n-    if (key == NoSymbol) {\n+    if (key == NoSymbol || (*env)->ExceptionCheck(env)) {\n@@ -1216,0 +1219,1 @@\n+    JNU_CHECK_EXCEPTION_RETURN(env, RESULT_ERROR);\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_pipewire.c","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+    vm.asan \\\n+    vm.ubsan \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2025, Institute of Software, Chinese Academy of Sciences.\n+ * All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests.stringopts;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/**\n+ * @test\n+ * @bug 8359270\n+ * @requires vm.debug == true & vm.compiler2.enabled\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"riscv64\" | os.arch==\"aarch64\"\n+ * @summary C2: alignment check should consider base offset when emitting arraycopy runtime call.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stringopts.TestArrayCopySelect\n+ *\/\n+\n+public class TestArrayCopySelect {\n+\n+    public static final String input_strU = \"\\u0f21\\u0f22\\u0f23\\u0f24\\u0f25\\u0f26\\u0f27\\u0f28\";\n+    public static final char[] input_arrU = new char[] {'\\u0f21', '\\u0f22', '\\u0f23', '\\u0f24',\n+                                                        '\\u0f25', '\\u0f26', '\\u0f27', '\\u0f28'};\n+\n+    public static String output_strU;\n+    public static char[] output_arrU;\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:-UseCompactObjectHeaders\",\n+                                   \"-XX:-CompactStrings\",\n+                                   \"-XX:CompileCommand=inline,java.lang.StringBuilder::toString\",\n+                                   \"-XX:CompileCommand=inline,java.lang.StringUTF16::getChars\",\n+                                   \"-XX:CompileCommand=inline,java.lang.StringUTF16::toBytes\");\n+\n+        TestFramework.runWithFlags(\"-XX:+UseCompactObjectHeaders\",\n+                                   \"-XX:-CompactStrings\",\n+                                   \"-XX:CompileCommand=inline,java.lang.StringBuilder::toString\",\n+                                   \"-XX:CompileCommand=inline,java.lang.StringUTF16::getChars\",\n+                                   \"-XX:CompileCommand=inline,java.lang.StringUTF16::toBytes\");\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(applyIf = {\"UseCompactObjectHeaders\", \"false\"},\n+        counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \">0\"})\n+    static void testSBToStringAligned() {\n+        \/\/ Exercise the StringBuilder.toString API\n+        StringBuilder sb = new StringBuilder(input_strU);\n+        output_strU = sb.append(input_strU).toString();\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(applyIf = {\"UseCompactObjectHeaders\", \"true\"},\n+        counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \"0\"})\n+    static void testSBToStringUnAligned() {\n+        \/\/ Exercise the StringBuilder.toString API\n+        StringBuilder sb = new StringBuilder(input_strU);\n+        output_strU = sb.append(input_strU).toString();\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(applyIf = {\"UseCompactObjectHeaders\", \"false\"},\n+        counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \">0\"})\n+    static void testStrUGetCharsAligned() {\n+        \/\/ Exercise the StringUTF16.getChars API\n+        output_arrU = input_strU.toCharArray();\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(applyIf = {\"UseCompactObjectHeaders\", \"true\"},\n+        counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \"0\"})\n+    static void testStrUGetCharsUnAligned() {\n+        \/\/ Exercise the StringUTF16.getChars API\n+        output_arrU = input_strU.toCharArray();\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(applyIf = {\"UseCompactObjectHeaders\", \"false\"},\n+        counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \">0\"})\n+    static void testStrUtoBytesAligned() {\n+        \/\/ Exercise the StringUTF16.toBytes API\n+        output_strU = String.valueOf(input_arrU);\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(applyIf = {\"UseCompactObjectHeaders\", \"true\"},\n+        counts = {IRNode.CALL_OF, \"arrayof_jshort_disjoint_arraycopy\", \"0\"})\n+    static void testStrUtoBytesUnAligned() {\n+        \/\/ Exercise the StringUTF16.toBytes API\n+        output_strU = String.valueOf(input_arrU);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stringopts\/TestArrayCopySelect.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -34,0 +34,2 @@\n+ * @comment ulimit clashes with the memory requirements of ASAN\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestUseCompressedOopsFlagsWithUlimit.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+ * @comment loading of the jsig lib does currently not work well with ASAN lib\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestBreakSignalThreadDump.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+ * @comment loading of the jsig lib does currently not work well with ASAN lib\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/runtime\/XCheckJniJsig\/XCheckJSig.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+ * @comment ASAN changes the memory map dump slightly, but the test has rather strict requirements\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemDumpMapTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+ * @comment ASAN changes the memory map dump slightly, but the test has rather strict requirements\n+ * @requires !vm.asan\n@@ -50,0 +52,2 @@\n+ * @comment ASAN changes the memory map dump slightly, but the test has rather strict requirements\n+ * @requires !vm.asan\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,1 @@\n+        System.out.println(\"thread is going to loop while <flag> is true ...\");\n@@ -159,1 +160,0 @@\n-        System.out.println(\"thread is going to loop while <flag> is true ...\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetCurrentContendedMonitor\/contmon01\/contmon01.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,0 +105,2 @@\n+    vm.asan \\\n+    vm.ubsan \\\n","filename":"test\/jdk\/TEST.ROOT","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+ * @comment ASAN keeps the 'unwanted' paths in the binaries because of its build options\n+ * @requires !vm.asan\n","filename":"test\/jdk\/build\/AbsPathsInImage.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,0 +141,2 @@\n+        map.put(\"vm.asan\", this::isAsanEnabled);\n+        map.put(\"vm.ubsan\", this::isUbsanEnabled);\n@@ -731,0 +733,9 @@\n+    \/\/ Sanitizer support\n+    protected String isAsanEnabled() {\n+        return \"\" + WB.isAsanEnabled();\n+    }\n+\n+    protected String isUbsanEnabled() {\n+        return \"\" + WB.isUbsanEnabled();\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -82,0 +82,9 @@\n+            \/\/ On some docker implementations e.g. RHEL8 ppc64le we have the following version output:\n+            \/\/    Docker version v25.0.3, build 4debf41\n+            \/\/ Trim potentially leading 'v' and trailing ','\n+            if (versNums.startsWith(\"v\")) {\n+                versNums = versNums.substring(1);\n+            }\n+            int cidx = versNums.indexOf(',');\n+            versNums = (cidx != -1) ? versNums.substring(0, cidx) : versNums;\n+\n@@ -87,1 +96,1 @@\n-            throw new RuntimeException(\"Failed to parse container runtime version: \" + version);\n+            throw new RuntimeException(\"Failed to parse container runtime version: \" + version, e);\n@@ -107,1 +116,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/ContainerRuntimeVersionTestUtils.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -329,0 +329,4 @@\n+  \/\/ Sanitizers\n+  public native boolean isAsanEnabled();\n+  public native boolean isUbsanEnabled();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}