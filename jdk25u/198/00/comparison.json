{"files":[{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.inline.hpp\"\n@@ -68,2 +68,0 @@\n-  const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n-\n@@ -101,1 +99,1 @@\n-          assert(region->age() >= tenuring_threshold, \"Preselection filter\");\n+          assert(heap->is_tenurable(region), \"Preselection filter\");\n@@ -106,1 +104,1 @@\n-        } else if (region->is_young() && (region->age() >= tenuring_threshold)) {\n+        } else if (region->is_young() && heap->is_tenurable(region)) {\n@@ -145,1 +143,1 @@\n-        if (region->is_young() && region->age() >= tenuring_threshold) {\n+        if (region->is_young() && heap->is_tenurable(region)) {\n@@ -249,4 +247,0 @@\n-#ifdef ASSERT\n-  const uint tenuring_threshold = ShenandoahGenerationalHeap::heap()->age_census()->tenuring_threshold();\n-#endif\n-\n@@ -260,1 +254,1 @@\n-      assert(r->age() >= tenuring_threshold, \"Preselected regions must have tenure age\");\n+      assert(ShenandoahGenerationalHeap::heap()->is_tenurable(r), \"Preselected regions must have tenure age\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.inline.hpp\"\n@@ -59,1 +59,0 @@\n-  const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n@@ -103,1 +102,1 @@\n-    if (r->is_old() || (r->age() >= tenuring_threshold)) {\n+    if (r->is_old() || heap->is_tenurable(r)) {\n@@ -117,1 +116,1 @@\n-      assert(r->is_young() && (r->age() < tenuring_threshold), \"DeMorgan's law (assuming r->is_affiliated)\");\n+      assert(r->is_young() && !heap->is_tenurable(r), \"DeMorgan's law (assuming r->is_affiliated)\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGlobalHeuristics.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.inline.hpp\"\n@@ -67,1 +67,1 @@\n-  auto heap = ShenandoahGenerationalHeap::heap();\n+  const auto heap = ShenandoahGenerationalHeap::heap();\n@@ -69,4 +69,3 @@\n-  size_t capacity = heap->young_generation()->max_capacity();\n-  size_t garbage_threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n-  size_t ignore_threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahIgnoreGarbageThreshold \/ 100;\n-  const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n+  const size_t capacity = heap->soft_max_capacity();\n+  const size_t garbage_threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahGarbageThreshold \/ 100;\n+  const size_t ignore_threshold = ShenandoahHeapRegion::region_size_bytes() * ShenandoahIgnoreGarbageThreshold \/ 100;\n@@ -76,1 +75,0 @@\n-  size_t max_cset = (size_t) (heap->young_generation()->get_evacuation_reserve() \/ ShenandoahEvacWaste);\n@@ -78,2 +76,3 @@\n-  size_t free_target = (capacity * ShenandoahMinFreeThreshold) \/ 100 + max_cset;\n-  size_t min_garbage = (free_target > actual_free) ? (free_target - actual_free) : 0;\n+  const size_t max_cset = (size_t) (heap->young_generation()->get_evacuation_reserve() \/ ShenandoahEvacWaste);\n+  const size_t free_target = (capacity * ShenandoahMinFreeThreshold) \/ 100 + max_cset;\n+  const size_t min_garbage = (free_target > actual_free) ? (free_target - actual_free) : 0;\n@@ -92,5 +91,9 @@\n-    if (r->age() < tenuring_threshold) {\n-      size_t new_cset = cur_cset + r->get_live_data_bytes();\n-      size_t region_garbage = r->garbage();\n-      size_t new_garbage = cur_young_garbage + region_garbage;\n-      bool add_regardless = (region_garbage > ignore_threshold) && (new_garbage < min_garbage);\n+\n+    \/\/ Note that we do not add tenurable regions if they were not pre-selected.  They were not preselected\n+    \/\/ because there is insufficient room in old-gen to hold their to-be-promoted live objects or because\n+    \/\/ they are to be promoted in place.\n+    if (!heap->is_tenurable(r)) {\n+      const size_t new_cset = cur_cset + r->get_live_data_bytes();\n+      const size_t region_garbage = r->garbage();\n+      const size_t new_garbage = cur_young_garbage + region_garbage;\n+      const bool add_regardless = (region_garbage > ignore_threshold) && (new_garbage < min_garbage);\n@@ -104,3 +107,0 @@\n-    \/\/ Note that we do not add aged regions if they were not pre-selected.  The reason they were not preselected\n-    \/\/ is because there is not sufficient room in old-gen to hold their to-be-promoted live objects or because\n-    \/\/ they are to be promoted in place.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahYoungHeuristics.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,1 +30,3 @@\n-ShenandoahAgeCensus::ShenandoahAgeCensus() {\n+ShenandoahAgeCensus::ShenandoahAgeCensus()\n+  : ShenandoahAgeCensus(ShenandoahHeap::heap()->max_workers())\n+{\n@@ -32,0 +34,5 @@\n+}\n+\n+ShenandoahAgeCensus::ShenandoahAgeCensus(uint max_workers)\n+  : _max_workers(max_workers)\n+{\n@@ -42,0 +49,3 @@\n+  CENSUS_NOISE(_skipped = 0);\n+  NOT_PRODUCT(_counted = 0);\n+  NOT_PRODUCT(_total = 0);\n@@ -51,2 +61,1 @@\n-    size_t max_workers = ShenandoahHeap::heap()->max_workers();\n-    _local_age_table = NEW_C_HEAP_ARRAY(AgeTable*, max_workers, mtGC);\n+    _local_age_table = NEW_C_HEAP_ARRAY(AgeTable*, _max_workers, mtGC);\n@@ -54,1 +63,1 @@\n-    for (uint i = 0; i < max_workers; i++) {\n+    for (uint i = 0; i < _max_workers; i++) {\n@@ -64,0 +73,16 @@\n+ShenandoahAgeCensus::~ShenandoahAgeCensus() {\n+  for (uint i = 0; i < MAX_SNAPSHOTS; i++) {\n+    delete _global_age_table[i];\n+  }\n+  FREE_C_HEAP_ARRAY(AgeTable*, _global_age_table);\n+  FREE_C_HEAP_ARRAY(uint, _tenuring_threshold);\n+  CENSUS_NOISE(FREE_C_HEAP_ARRAY(ShenandoahNoiseStats, _global_noise));\n+  if (_local_age_table) {\n+    for (uint i = 0; i < _max_workers; i++) {\n+      delete _local_age_table[i];\n+    }\n+    FREE_C_HEAP_ARRAY(AgeTable*, _local_age_table);\n+    CENSUS_NOISE(FREE_C_HEAP_ARRAY(ShenandoahNoiseStats, _local_noise));\n+  }\n+}\n+\n@@ -134,1 +159,1 @@\n-    _global_age_table[_epoch]->add((uint)0, age0_pop);\n+    _global_age_table[_epoch]->add(0u, age0_pop);\n@@ -136,1 +161,0 @@\n-    size_t max_workers = ShenandoahHeap::heap()->max_workers();\n@@ -139,1 +163,1 @@\n-    for (uint i = 0; i < max_workers; i++) {\n+    for (uint i = 0; i < _max_workers; i++) {\n@@ -180,2 +204,1 @@\n-  size_t max_workers = ShenandoahHeap::heap()->max_workers();\n-  for (uint i = 0; i < max_workers; i++) {\n+  for (uint i = 0; i < _max_workers; i++) {\n@@ -207,2 +230,1 @@\n-  size_t max_workers = ShenandoahHeap::heap()->max_workers();\n-  for (uint i = 0; i < max_workers; i++) {\n+  for (uint i = 0; i < _max_workers; i++) {\n@@ -249,1 +271,1 @@\n-  log_trace(gc, age)(\"New tenuring threshold %zu (min %zu, max %zu)\",\n+  log_info(gc, age)(\"New tenuring threshold %zu (min %zu, max %zu)\",\n@@ -282,3 +304,4 @@\n-     \/\/ We stay below the computed tenuring threshold for the last cycle plus 1,\n-     \/\/ ignoring the mortality rates of any older cohorts.\n-     upper_bound = MIN2(upper_bound, prev_tt + 1);\n+     \/\/ We stay below the computed tenuring threshold for the last cycle,\n+     \/\/ ignoring the mortality rates of any older cohorts (which may see\n+     \/\/ higher mortality rates due to promotions).\n+     upper_bound = MIN2(upper_bound, prev_tt);\n@@ -288,1 +311,1 @@\n-  const uint lower_bound = MAX2((uint)ShenandoahGenerationalMinTenuringAge, (uint)1);\n+  const uint lower_bound = MAX2((uint)ShenandoahGenerationalMinTenuringAge, 1u);\n@@ -306,1 +329,1 @@\n-      assert(tenuring_threshold == i+1 || tenuring_threshold == upper_bound, \"Error\");\n+      assert(tenuring_threshold == i + 1 || tenuring_threshold == upper_bound, \"Error\");\n@@ -308,1 +331,1 @@\n-      return tenuring_threshold;\n+      return i + 1;\n@@ -338,0 +361,8 @@\n+\n+  const LogTarget(Debug, gc, age) lt;\n+  if (!lt.is_enabled()) {\n+    return;\n+  }\n+\n+  LogStream ls(lt);\n+\n@@ -353,1 +384,1 @@\n-    double mr = mortality_rate(prev_pop, cur_pop);\n+    const double mr = mortality_rate(prev_pop, cur_pop);\n@@ -356,3 +387,2 @@\n-      log_info(gc, age)\n-        (\" - age %3u: prev %10zu bytes, curr %10zu bytes, mortality %.2f \",\n-         i, prev_pop*oopSize, cur_pop*oopSize, mr);\n+      ls.print_cr(\" - age %3u: prev %10zu bytes, curr %10zu bytes, mortality %.2f \",\n+         i, prev_pop * oopSize, cur_pop * oopSize, mr);\n@@ -363,1 +393,1 @@\n-      log_info(gc, age)(\"----------------------------------------------------------------------------\");\n+      ls.print_cr(\"----------------------------------------------------------------------------\");\n@@ -366,1 +396,1 @@\n-  CENSUS_NOISE(_global_noise[cur_epoch].print(total);)\n+  CENSUS_NOISE(_global_noise[cur_epoch].print(ls, total);)\n@@ -370,1 +400,1 @@\n-void ShenandoahNoiseStats::print(size_t total) {\n+void ShenandoahNoiseStats::print(LogStream& ls, const size_t total) {\n@@ -372,8 +402,8 @@\n-    float f_skipped = (float)skipped\/(float)total;\n-    float f_aged    = (float)aged\/(float)total;\n-    float f_clamped = (float)clamped\/(float)total;\n-    float f_young   = (float)young\/(float)total;\n-    log_info(gc, age)(\"Skipped: %10zu (%.2f),  R-Aged: %10zu (%.2f),  \"\n-                      \"Clamped: %10zu (%.2f),  R-Young: %10zu (%.2f)\",\n-                      skipped*oopSize, f_skipped, aged*oopSize, f_aged,\n-                      clamped*oopSize, f_clamped, young*oopSize, f_young);\n+    const float f_skipped = (float)skipped\/(float)total;\n+    const float f_aged    = (float)aged\/(float)total;\n+    const float f_clamped = (float)clamped\/(float)total;\n+    const float f_young   = (float)young\/(float)total;\n+    ls.print_cr(\"Skipped: %10zu (%.2f),  R-Aged: %10zu (%.2f),  \"\n+                \"Clamped: %10zu (%.2f),  R-Young: %10zu (%.2f)\",\n+                skipped*oopSize, f_skipped, aged*oopSize, f_aged,\n+                clamped*oopSize, f_clamped, young*oopSize, f_young);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.cpp","additions":63,"deletions":33,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+class LogStream;\n+\n@@ -70,1 +72,1 @@\n-  void print(size_t total);\n+  void print(LogStream& ls, size_t total);\n@@ -94,1 +96,1 @@\n-\/\/ evacuation). These are cleared after each marking (resectively, evacuation) cycle,\n+\/\/ evacuation). These are cleared after each marking (respectively, evacuation) cycle,\n@@ -114,2 +116,2 @@\n-  uint _epoch;                       \/\/ Current epoch (modulo max age)\n-  uint *_tenuring_threshold;         \/\/ An array of the last N tenuring threshold values we\n+  uint  _epoch;                      \/\/ Current epoch (modulo max age)\n+  uint* _tenuring_threshold;         \/\/ An array of the last N tenuring threshold values we\n@@ -118,0 +120,2 @@\n+  uint _max_workers;                 \/\/ Maximum number of workers for parallel tasks\n+\n@@ -168,0 +172,2 @@\n+  ShenandoahAgeCensus(uint max_workers);\n+  ~ShenandoahAgeCensus();\n@@ -171,2 +177,11 @@\n-  AgeTable* get_local_age_table(uint worker_id) {\n-    return (AgeTable*) _local_age_table[worker_id];\n+  AgeTable* get_local_age_table(uint worker_id) const {\n+    return _local_age_table[worker_id];\n+  }\n+\n+  \/\/ Return the most recently computed tenuring threshold.\n+  \/\/ Visible for testing. Use is_tenurable for consistent tenuring comparisons.\n+  uint tenuring_threshold() const { return _tenuring_threshold[_epoch]; }\n+\n+  \/\/ Return true if this age is at or above the tenuring threshold.\n+  bool is_tenurable(uint age) const {\n+    return age >= tenuring_threshold();\n@@ -204,3 +219,0 @@\n-  \/\/ Return the most recently computed tenuring threshold\n-  uint tenuring_threshold() const { return _tenuring_threshold[_epoch]; }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.hpp","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.inline.hpp\"\n@@ -101,1 +102,1 @@\n-    if (ShenandoahHeap::heap()->mode()->is_generational() && r->age() >= ShenandoahGenerationalHeap::heap()->age_census()->tenuring_threshold()) {\n+    if (ShenandoahHeap::heap()->mode()->is_generational() && ShenandoahGenerationalHeap::heap()->is_tenurable(r)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.inline.hpp\"\n@@ -33,1 +33,0 @@\n-#include \"gc\/shenandoah\/shenandoahMonitoringSupport.hpp\"\n@@ -537,1 +536,0 @@\n-  const uint tenuring_threshold = heap->age_census()->tenuring_threshold();\n@@ -561,1 +559,1 @@\n-    if (r->age() >= tenuring_threshold) {\n+    if (heap->is_tenurable(r)) {\n@@ -616,1 +614,1 @@\n-      if (heap->is_aging_cycle() && (r->age() + 1 == tenuring_threshold)) {\n+      if (heap->is_aging_cycle() && heap->age_census()->is_tenurable(r->age() + 1)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.inline.hpp\"\n@@ -60,2 +60,1 @@\n-  _only_promote_regions(only_promote_regions),\n-  _tenuring_threshold(0)\n+  _only_promote_regions(only_promote_regions)\n@@ -64,1 +63,0 @@\n-  _tenuring_threshold = _heap->age_census()->tenuring_threshold();\n@@ -145,1 +143,1 @@\n-  if (r->is_young() && r->is_active() && (r->age() >= _tenuring_threshold)) {\n+  if (r->is_young() && r->is_active() && _heap->is_tenurable(r)) {\n@@ -183,1 +181,1 @@\n-    assert(region->age() >= _tenuring_threshold, \"Only promote regions that are sufficiently aged\");\n+    assert(_heap->is_tenurable(region), \"Only promote regions that are sufficiently aged\");\n@@ -266,1 +264,1 @@\n-  assert(region->age() >= _tenuring_threshold, \"Only promote regions that are sufficiently aged\");\n+  assert(_heap->is_tenurable(region), \"Only promote regions that are sufficiently aged\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-  uint _tenuring_threshold;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -196,1 +196,0 @@\n-        _tenuring_threshold(0),\n@@ -215,2 +214,0 @@\n-\n-  _tenuring_threshold = _heap->age_census()->tenuring_threshold();\n@@ -282,1 +279,1 @@\n-      (from_region_age + object_age >= _tenuring_threshold)) {\n+      _heap->age_census()->is_tenurable(from_region_age + object_age)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -93,1 +93,0 @@\n-  uint                              _tenuring_threshold;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-    } else if (r->age() + mark.age() >= age_census()->tenuring_threshold()) {\n+    } else if (age_census()->is_tenurable(r->age() + mark.age())) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+  inline bool is_tenurable(const ShenandoahHeapRegion* r) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALHEAP_INLINE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALHEAP_INLINE_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+\n+inline bool ShenandoahGenerationalHeap::is_tenurable(const ShenandoahHeapRegion* r) const {\n+  return _age_census->is_tenurable(r->age());\n+}\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONALHEAP_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.inline.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n+#include \"unittest.hpp\"\n+\n+class ShenandoahAgeCensusTest : public ::testing::Test {\n+protected:\n+  static constexpr size_t MinimumPopulationSize = 4*K;\n+  static constexpr size_t InitialPopulationSize = MinimumPopulationSize * 1000;\n+\n+  size_t _cohorts_count = ShenandoahAgeCensus::MAX_COHORTS;\n+  double _mortality_rates[ShenandoahAgeCensus::MAX_COHORTS];\n+  size_t _cohort_populations[ShenandoahAgeCensus::MAX_COHORTS];\n+\n+  ShenandoahAgeCensusTest()\n+  : _mortality_rates{0.9, 0.7, 0.5, 0.3, 0.09, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}\n+  {\n+    build_cohort_populations(_mortality_rates, _cohort_populations, _cohorts_count);\n+  }\n+\n+  static void add_population(ShenandoahAgeCensus& census, const uint age, const size_t population_words) {\n+    CENSUS_NOISE(census.add(age, 0, 0, population_words, 0));\n+    NO_CENSUS_NOISE(census.add(age, 0, population_words, 0));\n+  }\n+\n+  void update(ShenandoahAgeCensus& census, size_t cohorts) const {\n+    for (uint i = 1; i < cohorts; i++) {\n+      add_population(census, i, _cohort_populations[i]);\n+    }\n+    census.update_census(_cohort_populations[0]);\n+  }\n+\n+  void update(ShenandoahAgeCensus& census) const {\n+    update(census, _cohorts_count);\n+  }\n+\n+  size_t get_total_population_older_than(const size_t min_cohort_age) const {\n+    size_t total = 0;\n+    for (size_t i = 0; i < _cohorts_count; i++) {\n+      if (i >= min_cohort_age) {\n+        total += _cohort_populations[i];\n+      }\n+    }\n+    return total;\n+  }\n+\n+  void promote_all_tenurable(const size_t tenuring_threshold) {\n+    for (size_t i = 0; i < _cohorts_count; i++) {\n+      if (i > tenuring_threshold) {\n+        _cohort_populations[i] = 0;\n+      }\n+    }\n+  }\n+\n+  static void build_cohort_populations(const double mortality_rates[], size_t cohort_populations[], const size_t cohorts) {\n+    cohort_populations[0] = InitialPopulationSize;\n+    for (size_t i = 1; i < cohorts; i++) {\n+      cohort_populations[i] = cohort_populations[i - 1] * (1.0 - mortality_rates[i - 1]);\n+    }\n+  }\n+};\n+\n+TEST_F(ShenandoahAgeCensusTest, initialize) {\n+  const ShenandoahAgeCensus census(1);\n+  EXPECT_EQ(census.tenuring_threshold(), ShenandoahAgeCensus::MAX_COHORTS);\n+}\n+\n+TEST_F(ShenandoahAgeCensusTest, ignore_small_populations) {\n+  \/\/ Small populations are ignored so we do not return early before reaching the youngest cohort.\n+  ShenandoahAgeCensus census(1);\n+  add_population(census,1, 32);\n+  add_population(census,1, 32);\n+  census.update_census(64);\n+  EXPECT_EQ(1u, census.tenuring_threshold());\n+}\n+\n+TEST_F(ShenandoahAgeCensusTest, find_high_mortality_rate) {\n+  ShenandoahAgeCensus census(1);\n+\n+  \/\/ Initial threshold, no data\n+  EXPECT_EQ(16u, census.tenuring_threshold());\n+\n+  \/\/ Provide population data for 1st cohort. Previous epoch has no population data so our\n+  \/\/ algorithm skips over all cohorts, leaving tenuring threshold at 1.\n+  update(census, 1);\n+  EXPECT_EQ(1u, census.tenuring_threshold());\n+\n+  \/\/ Mortality rate of 1st cohort at age 1 is 0.9, we don't want to promote here. Move threshold to 2.\n+  update(census, 2);\n+  EXPECT_EQ(2u, census.tenuring_threshold());\n+\n+  \/\/ Mortality rate of 1st cohort at age 2 is 0.7, we don't want to promote here. Move threshold to 3.\n+  update(census, 3);\n+  EXPECT_EQ(3u, census.tenuring_threshold());\n+\n+  \/\/ Mortality rate of 1st cohort at age 3 is 0.5, we don't want to promote here. Move threshold to 4.\n+  update(census, 4);\n+  EXPECT_EQ(4u, census.tenuring_threshold());\n+\n+  \/\/ Mortality rate of 1st cohort at age 4 is 0.3, we don't want to promote here. Move threshold to 5.\n+  update(census, 5);\n+  EXPECT_EQ(5u, census.tenuring_threshold());\n+\n+  \/\/ Mortality rate of 1st cohort at age 5 is 0.09, this is less than the mortality rate threshold. It\n+  \/\/ is okay to tenure objects older than 5 now. Keep threshold at 5.\n+  update(census, 6);\n+  EXPECT_EQ(5u, census.tenuring_threshold());\n+\n+  \/\/ Mortality rate at this age is 0. Keep tenuring threshold at 5.\n+  update(census, 7);\n+  EXPECT_EQ(5u, census.tenuring_threshold());\n+}\n+\n+TEST_F(ShenandoahAgeCensusTest, ignore_mortality_caused_by_promotions) {\n+  ShenandoahAgeCensus census(1);\n+\n+  \/\/ Simulate a sequence of censuses with the same mortality rate. Each one will see a\n+  \/\/ mortality rate above the tenuring threshold and raise the tenuring threshold by one.\n+  update(census, 1);\n+  update(census, 2);\n+  update(census, 3);\n+  update(census, 4);\n+  update(census, 5);\n+\n+  EXPECT_EQ(5u, census.tenuring_threshold());\n+\n+  \/\/ Simulate the effect of promoting all objects above the tenuring threshold\n+  \/\/ out of the young generation. This will look like a very high (100%) mortality\n+  \/\/ rate for these cohorts. However, we do _not_ want to raise the threshold in\n+  \/\/ this case because these objects haven't really \"died\", they have just been\n+  \/\/ tenured.\n+  promote_all_tenurable(census.tenuring_threshold());\n+  update(census);\n+\n+  \/\/ We want this to stay at 5 - the mortality in 1st cohort at age 6 was caused by expected promotions.\n+  EXPECT_EQ(5u, census.tenuring_threshold());\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahAgeCensus.cpp","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"}]}