{"files":[{"patch":"@@ -1991,0 +1991,1 @@\n+  INSN(vnsrl_wi, 0b1010111, 0b011, 0b101100);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2492,1 +2492,3 @@\n-  VectorRegister tmp = stub.data<2>();\n+  VectorRegister vtmp = stub.data<2>();\n+  assert_different_registers(dst, src, vtmp);\n+\n@@ -2495,0 +2497,1 @@\n+  \/\/ Active elements (NaNs) are marked in v0 mask register.\n@@ -2497,11 +2500,47 @@\n-  \/\/ preserve the payloads of non-canonical NaNs.\n-  __ vnsra_wi(dst, src, 13, Assembler::v0_t);\n-\n-  \/\/ preserve the sign bit.\n-  __ vnsra_wi(tmp, src, 26, Assembler::v0_t);\n-  __ vsll_vi(tmp, tmp, 10, Assembler::v0_t);\n-  __ mv(t0, 0x3ff);\n-  __ vor_vx(tmp, tmp, t0, Assembler::v0_t);\n-\n-  \/\/ get the result by merging sign bit and payloads of preserved non-canonical NaNs.\n-  __ vand_vv(dst, dst, tmp, Assembler::v0_t);\n+  \/\/  Float (32 bits)\n+  \/\/    Bit:     31        30 to 23          22 to 0\n+  \/\/          +---+------------------+-----------------------------+\n+  \/\/          | S |     Exponent     |      Mantissa (Fraction)    |\n+  \/\/          +---+------------------+-----------------------------+\n+  \/\/          1 bit       8 bits                  23 bits\n+  \/\/\n+  \/\/  Float (16 bits)\n+  \/\/    Bit:    15        14 to 10         9 to 0\n+  \/\/          +---+----------------+------------------+\n+  \/\/          | S |    Exponent    |     Mantissa     |\n+  \/\/          +---+----------------+------------------+\n+  \/\/          1 bit      5 bits          10 bits\n+  const int fp_sign_bits = 1;\n+  const int fp32_bits = 32;\n+  const int fp32_mantissa_2nd_part_bits = 9;\n+  const int fp32_mantissa_3rd_part_bits = 4;\n+  const int fp16_exponent_bits = 5;\n+  const int fp16_mantissa_bits = 10;\n+\n+  \/\/ preserve the sign bit and exponent, clear mantissa.\n+  __ vnsra_wi(dst, src, fp32_bits - fp_sign_bits - fp16_exponent_bits, Assembler::v0_t);\n+  __ vsll_vi(dst, dst, fp16_mantissa_bits, Assembler::v0_t);\n+\n+  \/\/ Preserve high order bit of float NaN in the\n+  \/\/ binary16 result NaN (tenth bit); OR in remaining\n+  \/\/ bits into lower 9 bits of binary 16 significand.\n+  \/\/   | (doppel & 0x007f_e000) >> 13 \/\/ 10 bits\n+  \/\/   | (doppel & 0x0000_1ff0) >> 4  \/\/  9 bits\n+  \/\/   | (doppel & 0x0000_000f));     \/\/  4 bits\n+  \/\/\n+  \/\/ Check j.l.Float.floatToFloat16 for more information.\n+  \/\/ 10 bits\n+  __ vnsrl_wi(vtmp, src, fp32_mantissa_2nd_part_bits + fp32_mantissa_3rd_part_bits, Assembler::v0_t);\n+  __ mv(t0, 0x3ff); \/\/ retain first part of mantissa in a float 32\n+  __ vand_vx(vtmp, vtmp, t0, Assembler::v0_t);\n+  __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n+  \/\/ 9 bits\n+  __ vnsrl_wi(vtmp, src, fp32_mantissa_3rd_part_bits, Assembler::v0_t);\n+  __ mv(t0, 0x1ff); \/\/ retain second part of mantissa in a float 32\n+  __ vand_vx(vtmp, vtmp, t0, Assembler::v0_t);\n+  __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n+  \/\/ 4 bits\n+  \/\/ Narrow shift is necessary to move data from 32 bits element to 16 bits element in vector register.\n+  __ vnsrl_wi(vtmp, src, 0, Assembler::v0_t);\n+  __ vand_vi(vtmp, vtmp, 0xf, Assembler::v0_t);\n+  __ vor_vv(dst, dst, vtmp, Assembler::v0_t);\n@@ -2514,2 +2553,2 @@\n-void C2_MacroAssembler::float_to_float16_v(VectorRegister dst, VectorRegister src, VectorRegister vtmp,\n-                                           Register tmp, uint vector_length) {\n+void C2_MacroAssembler::float_to_float16_v(VectorRegister dst, VectorRegister src,\n+                                           VectorRegister vtmp, Register tmp, uint vector_length) {\n@@ -2519,1 +2558,1 @@\n-              (dst, src, vtmp, 28, float_to_float16_v_slow_path);\n+              (dst, src, vtmp, 56, float_to_float16_v_slow_path);\n@@ -2526,1 +2565,1 @@\n-  \/\/ replace v_fclass with vmseq_vv as performance optimization.\n+  \/\/ replace v_fclass with vmfne_vv as performance optimization.\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":55,"deletions":16,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -40,0 +41,1 @@\n+import java.util.Random;\n@@ -43,0 +45,1 @@\n+import jdk.test.lib.Utils;\n@@ -82,0 +85,1 @@\n+        Random rand = Utils.getRandomInstance();\n@@ -88,2 +92,3 @@\n-            if (i%39 == 0) {\n-                int x = 0x7f800000 + ((i\/39) << 13);\n+            if (i%3 == 0) {\n+                int shift = rand.nextInt(13+1);\n+                int x = 0x7f800000 + ((i\/39) << shift);\n@@ -131,1 +136,2 @@\n-        String msg = \"floatToFloat16 wrong result: idx: \" + idx + \", \\t\" + f +\n+        String msg = \"floatToFloat16 wrong result: idx: \" + idx +\n+                     \", \\t\" + f + \", hex: \" + Integer.toHexString(Float.floatToRawIntBits(f)) +\n@@ -170,1 +176,1 @@\n-            if (i%39 == 0) {\n+            if (i%3 == 0) {\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVectorNaN.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"}]}