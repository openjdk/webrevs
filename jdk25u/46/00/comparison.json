{"files":[{"patch":"@@ -300,1 +300,1 @@\n-        } else if (callingSequence.forUpcall() && needsSession()) {\n+        } else if (callingSequence.forUpcall() && anyArgNeedsScope()) {\n@@ -440,1 +440,1 @@\n-    private boolean needsSession() {\n+    private boolean anyArgNeedsScope() {\n@@ -593,1 +593,1 @@\n-        if (needsSession()) {\n+        if (boxAddress.needsScope()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.util.function.BiConsumer;\n@@ -49,0 +50,2 @@\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.assertEquals;\n@@ -52,0 +55,1 @@\n+    static final MethodHandle MH_do_upcall_ptr;\n@@ -53,0 +57,1 @@\n+    static final MethodHandle MH_BiConsumer_accept;\n@@ -60,0 +65,4 @@\n+        MH_do_upcall_ptr = LINKER.downcallHandle(\n+                findNativeOrThrow(\"do_upcall_ptr\"),\n+                FunctionDescriptor.ofVoid(C_POINTER, S_PDI_LAYOUT, C_POINTER)\n+        );\n@@ -64,0 +73,2 @@\n+            MH_BiConsumer_accept = MethodHandles.publicLookup().findVirtual(BiConsumer.class, \"accept\",\n+                    MethodType.methodType(void.class, Object.class, Object.class));\n@@ -69,2 +80,8 @@\n-    private static MethodHandle methodHandle (Consumer<MemorySegment> callback) {\n-        return MH_Consumer_accept.bindTo(callback).asType(MethodType.methodType(void.class, MemorySegment.class));\n+    private static MethodHandle methodHandle(Consumer<MemorySegment> callback) {\n+        return MH_Consumer_accept.bindTo(callback)\n+                .asType(MethodType.methodType(void.class, MemorySegment.class));\n+    }\n+\n+    private static MethodHandle methodHandle(BiConsumer<MemorySegment, MemorySegment> callback) {\n+        return MH_BiConsumer_accept.bindTo(callback)\n+                .asType(MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class));\n@@ -88,0 +105,18 @@\n+    @Test\n+    public void testOtherPointer() throws Throwable {\n+        AtomicReference<MemorySegment> capturedSegment = new AtomicReference<>();\n+        MethodHandle target = methodHandle((_, addr) -> capturedSegment.set(addr));\n+        FunctionDescriptor upcallDesc = FunctionDescriptor.ofVoid(S_PDI_LAYOUT, C_POINTER);\n+        MemorySegment argAddr = MemorySegment.ofAddress(42);\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment upcallStub = LINKER.upcallStub(target, upcallDesc, arena);\n+            MemorySegment argSegment = arena.allocate(S_PDI_LAYOUT);\n+            MH_do_upcall_ptr.invoke(upcallStub, argSegment, argAddr);\n+        }\n+\n+        \/\/ We've captured the address '42' from the upcall. This should have\n+        \/\/ the global scope, so it should still be alive here.\n+        MemorySegment captured = capturedSegment.get();\n+        assertEquals(argAddr, captured);\n+        assertTrue(captured.scope().isAlive());\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+\n+EXPORT void do_upcall_ptr(void (*cb)(struct S_PDI, void*), struct S_PDI a0, void* ptr) {\n+    cb(a0, ptr);\n+}\n","filename":"test\/jdk\/java\/foreign\/libTestUpcallStructScope.c","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}