{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -32,1 +32,1 @@\n-\/**\n+\/*\n@@ -40,1 +40,1 @@\n-\/**\n+\/*\n@@ -65,0 +65,1 @@\n+import java.util.concurrent.locks.LockSupport;\n@@ -164,0 +165,16 @@\n+    \/**\n+     * SocketChannel shutdownInput while virtual thread blocked in read.\n+     *\/\n+    @Test\n+    void testSocketChannelReadAsyncShutdownInput() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (var connection = new Connection()) {\n+                SocketChannel sc = connection.channel1();\n+                runAfterParkedAsync(sc::shutdownInput);\n+                int n = sc.read(ByteBuffer.allocate(100));\n+                assertEquals(-1, n);\n+                assertTrue(sc.isOpen());\n+            }\n+        });\n+    }\n+\n@@ -193,2 +210,2 @@\n-            boolean retry = true;\n-            while (retry) {\n+            boolean done = false;\n+            while (!done) {\n@@ -199,1 +216,3 @@\n-                    runAfterParkedAsync(sc::close);\n+                    runAfterParkedAsync(sc::close, true);\n+\n+                    \/\/ write until channel is closed\n@@ -209,1 +228,1 @@\n-                        retry = false;\n+                        done = true;\n@@ -211,1 +230,26 @@\n-                        \/\/ closed when not blocked in write, need to retry test\n+                        \/\/ closed but not blocked in write, need to retry test\n+                        System.err.format(\"%s, need to retry!%n\", e);\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+\n+    \/**\n+     * SocketChannel shutdownOutput while virtual thread blocked in write.\n+     *\/\n+    @Test\n+    void testSocketChannelWriteAsyncShutdownOutput() throws Exception {\n+        VThreadRunner.run(() -> {\n+            try (var connection = new Connection()) {\n+                SocketChannel sc = connection.channel1();\n+\n+                \/\/ shutdown output when current thread blocks in write\n+                runAfterParkedAsync(sc::shutdownOutput);\n+                try {\n+                    ByteBuffer bb = ByteBuffer.allocate(100*1024);\n+                    for (;;) {\n+                        int n = sc.write(bb);\n+                        assertTrue(n > 0);\n+                        bb.clear();\n@@ -213,0 +257,2 @@\n+                } catch (ClosedChannelException e) {\n+                    \/\/ expected\n@@ -214,0 +260,1 @@\n+                assertTrue(sc.isOpen());\n@@ -224,2 +271,2 @@\n-            boolean retry = true;\n-            while (retry) {\n+            boolean done = false;\n+            while (!done) {\n@@ -231,1 +278,1 @@\n-                    runAfterParkedAsync(thisThread::interrupt);\n+                    runAfterParkedAsync(thisThread::interrupt, true);\n@@ -233,0 +280,1 @@\n+                    \/\/ write until channel is closed\n@@ -243,1 +291,1 @@\n-                        retry = false;\n+                        done = true;\n@@ -245,1 +293,2 @@\n-                        \/\/ closed when not blocked in write, need to retry test\n+                        \/\/ closed but not blocked in write, need to retry test\n+                        System.err.format(\"%s, need to retry!%n\", e);\n@@ -737,2 +786,2 @@\n-            boolean retry = true;\n-            while (retry) {\n+            boolean done = false;\n+            while (!done) {\n@@ -744,1 +793,3 @@\n-                    runAfterParkedAsync(sink::close);\n+                    runAfterParkedAsync(sink::close, true);\n+\n+                    \/\/ write until channel is closed\n@@ -754,1 +805,1 @@\n-                        retry = false;\n+                        done = true;\n@@ -756,1 +807,2 @@\n-                        \/\/ closed when not blocked in write, need to retry test\n+                        \/\/ closed but not blocked in write, need to retry test\n+                        System.err.format(\"%s, need to retry!%n\", e);\n@@ -769,2 +821,2 @@\n-            boolean retry = true;\n-            while (retry) {\n+            boolean done = false;\n+            while (!done) {\n@@ -777,1 +829,1 @@\n-                    runAfterParkedAsync(thisThread::interrupt);\n+                    runAfterParkedAsync(thisThread::interrupt, true);\n@@ -779,0 +831,1 @@\n+                    \/\/ write until channel is closed\n@@ -789,1 +842,1 @@\n-                        retry = false;\n+                        done = true;\n@@ -791,1 +844,2 @@\n-                        \/\/ closed when not blocked in write, need to retry test\n+                        \/\/ closed but not blocked in write, need to retry test\n+                        System.err.format(\"%s, need to retry!%n\", e);\n@@ -851,1 +905,2 @@\n-     * Runs the given task asynchronously after the current virtual thread has parked.\n+     * Runs the given task asynchronously after the current virtual thread parks.\n+     * @param writing if the thread will block in write\n@@ -854,1 +909,1 @@\n-    static Thread runAfterParkedAsync(ThrowingRunnable task) {\n+    private static Thread runAfterParkedAsync(ThrowingRunnable task, boolean writing) {\n@@ -860,3 +915,2 @@\n-                Thread.State state = target.getState();\n-                while (state != Thread.State.WAITING\n-                        && state != Thread.State.TIMED_WAITING) {\n+                \/\/ wait for target thread to park\n+                while (!isWaiting(target)) {\n@@ -864,1 +918,0 @@\n-                    state = target.getState();\n@@ -866,1 +919,12 @@\n-                Thread.sleep(20);  \/\/ give a bit more time to release carrier\n+\n+                \/\/ if the target thread is parked in write then we nudge it a few times\n+                \/\/ to avoid wakeup with some bytes written\n+                if (writing) {\n+                    for (int i = 0; i < 3; i++) {\n+                        LockSupport.unpark(target);\n+                        while (!isWaiting(target)) {\n+                            Thread.sleep(20);\n+                        }\n+                    }\n+                }\n+\n@@ -868,0 +932,1 @@\n+\n@@ -873,0 +938,13 @@\n+\n+    private static Thread runAfterParkedAsync(ThrowingRunnable task) {\n+        return runAfterParkedAsync(task, false);\n+    }\n+\n+    \/**\n+     * Return true if the given Thread is parked.\n+     *\/\n+    private static boolean isWaiting(Thread target) {\n+        Thread.State state = target.getState();\n+        assertNotEquals(Thread.State.TERMINATED, state);\n+        return (state == Thread.State.WAITING || state == Thread.State.TIMED_WAITING);\n+    }\n","filename":"test\/jdk\/java\/nio\/channels\/vthread\/BlockingChannelOps.java","additions":109,"deletions":31,"binary":false,"changes":140,"status":"modified"}]}