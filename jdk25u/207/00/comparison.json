{"files":[{"patch":"@@ -915,0 +915,26 @@\n+ public:\n+\n+  static uint32_t encode_jal(Register Rd, const int32_t offset) {\n+    guarantee(is_simm21(offset) && ((offset % 2) == 0), \"offset is invalid.\");\n+    uint32_t insn = 0;\n+    patch((address)&insn, 6, 0, 0b1101111);\n+    patch_reg((address)&insn, 7, Rd);\n+    patch((address)&insn, 19, 12, (uint32_t)((offset >> 12) & 0xff));\n+    patch((address)&insn, 20, (uint32_t)((offset >> 11) & 0x1));\n+    patch((address)&insn, 30, 21, (uint32_t)((offset >> 1) & 0x3ff));\n+    patch((address)&insn, 31, (uint32_t)((offset >> 20) & 0x1));\n+    return insn;\n+  }\n+\n+  static uint32_t encode_jalr(Register Rd, Register Rs, const int32_t offset) {\n+    guarantee(is_simm12(offset), \"offset is invalid.\");\n+    uint32_t insn = 0;\n+    patch((address)&insn, 6, 0, 0b1100111);\n+    patch_reg((address)&insn, 7, Rd);\n+    patch((address)&insn, 14, 12, 0b000);\n+    patch_reg((address)&insn, 15, Rs);\n+    int32_t val = offset & 0xfff;\n+    patch((address)&insn, 31, 20, val);\n+    return insn;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/align.hpp\"\n@@ -55,1 +56,1 @@\n-  address destination = MacroAssembler::target_addr_for_insn(addr);\n+  address stub_addr = MacroAssembler::target_addr_for_insn(addr);\n@@ -60,4 +61,4 @@\n-  assert(nm != nullptr, \"Sanity\");\n-  assert(nm->stub_contains(destination), \"Sanity\");\n-  assert(destination != nullptr, \"Sanity\");\n-  return stub_address_destination_at(destination);\n+  assert(nm->stub_contains(stub_addr), \"Sanity\");\n+  assert(stub_addr != nullptr, \"Sanity\");\n+\n+  return stub_address_destination_at(stub_addr);\n@@ -92,0 +93,24 @@\n+void NativeCall::optimize_call(address dest, bool mt_safe) {\n+  \/\/ Skip over auipc + ld\n+  address jmp_ins_pc = instruction_address() + 2 * NativeInstruction::instruction_size;\n+  \/\/ Rutime calls may be unaligned, but they are never changed after relocation.\n+  assert(!mt_safe || is_aligned(jmp_ins_pc, NativeInstruction::instruction_size), \"Must be naturally aligned: %p\", jmp_ins_pc);\n+  \/\/ If reachable use JAL\n+  if (Assembler::reachable_from_branch_at(jmp_ins_pc, dest)) {\n+    int64_t distance = dest - jmp_ins_pc;\n+    uint32_t new_jal = Assembler::encode_jal(ra, distance);\n+    Atomic::store((uint32_t *)jmp_ins_pc, new_jal);\n+  } else if (!MacroAssembler::is_jalr_at(jmp_ins_pc)) { \/\/ The jalr is always identical: jalr ra, 0(t1)\n+    uint32_t new_jalr = Assembler::encode_jalr(ra, t1, 0);\n+    Atomic::store((uint32_t *)jmp_ins_pc, new_jalr);\n+  } else {\n+    \/\/ No change to instruction stream\n+    return;\n+  }\n+  \/\/ We changed instruction stream\n+  if (mt_safe) {\n+    \/\/ IC invalidate provides a leading full fence, it thus happens after we changed the instruction stream.\n+    ICache::invalidate_range(jmp_ins_pc, NativeInstruction::instruction_size);\n+  }\n+}\n+\n@@ -99,4 +124,5 @@\n-  if (stub_addr != nullptr) {\n-    set_stub_address_destination_at(stub_addr, dest);\n-    return true;\n-  }\n+  assert(stub_addr != nullptr, \"No stub?\");\n+  set_stub_address_destination_at(stub_addr, dest); \/\/ release\n+  \/\/ optimize_call happens after we stored new address in addr stub.\n+  \/\/ patches jalr -> jal\/jal -> jalr depending on dest\n+  optimize_call(dest, true);\n@@ -104,1 +130,1 @@\n-  return false;\n+  return true;\n@@ -107,1 +133,2 @@\n-bool NativeCall::reloc_set_destination(address dest) {\n+\/\/ The argument passed in is the address to the stub containing the destination\n+bool NativeCall::reloc_set_destination(address stub_addr) {\n@@ -116,4 +143,6 @@\n-    assert(dest != nullptr, \"Sanity\");\n-    assert(dest == trampoline_stub_Relocation::get_trampoline_for(call_addr,\n-                                                          code->as_nmethod()), \"Sanity\");\n-    MacroAssembler::pd_patch_instruction_size(call_addr, dest);\n+    assert(stub_addr != nullptr, \"Sanity\");\n+    assert(stub_addr == trampoline_stub_Relocation::get_trampoline_for(call_addr, code->as_nmethod()), \"Sanity\");\n+    MacroAssembler::pd_patch_instruction_size(call_addr, stub_addr); \/\/ patches auipc + ld to stub_addr\n+\n+    address dest = stub_address_destination_at(stub_addr);\n+    optimize_call(dest, false); \/\/ patches jalr -> jal\/jal -> jalr depending on dest\n@@ -145,3 +174,3 @@\n-  address dest = MacroAssembler::target_addr_for_insn(call_addr);\n-  assert(code->contains(dest), \"Sanity\");\n-  return dest;\n+  address stub_addr = MacroAssembler::target_addr_for_insn(call_addr);\n+  assert(code->contains(stub_addr), \"Sanity\");\n+  return stub_addr;\n@@ -163,0 +192,9 @@\n+  if (MacroAssembler::is_auipc_at(addr) &&\n+      MacroAssembler::is_ld_at(addr + instr_size) &&\n+      MacroAssembler::is_jal_at(addr + 2 * instr_size) &&\n+      (MacroAssembler::extract_rd(addr)                    == x6) &&\n+      (MacroAssembler::extract_rd(addr + instr_size)       == x6) &&\n+      (MacroAssembler::extract_rs1(addr + instr_size)      == x6) &&\n+      (MacroAssembler::extract_rd(addr + 2 * instr_size)   == x1)) {\n+    return true;\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":56,"deletions":18,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -160,0 +160,4 @@\n+  \/\/ We either have a jalr or jal depending on distance to old destination.\n+  \/\/ This method emits a new jal if new destination is within jal reach.\n+  \/\/ Otherwise restores the jalr which can reach any destination.\n+  void optimize_call(address dest, bool mt_safe = true);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}