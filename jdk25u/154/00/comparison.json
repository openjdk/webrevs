{"files":[{"patch":"@@ -34,0 +34,3 @@\n+\n+#Unstable methods\n+*::hashCode\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/conf\/exclude.methods.lst","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package testlibrary.jittester.src.jdk.test.lib.jittester;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Executable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.Asserts;\n+\n+import static java.util.function.Predicate.not;\n+\n+\n+\/**\n+ * A wrapper for string method templates, similar to the CompileCommand patterns.\n+ *\/\n+public final class MethodTemplate {\n+\n+    \/**\n+     * String that can have wildcard symbols on its ends, allowing it to match a family of strings.\n+     * For example, \"abc*\" matches \"abc123\", and so on.\n+     *\/\n+    public static class WildcardString {\n+        private final String pattern;\n+        private final boolean frontWildcarded;\n+        private final boolean tailWildcarded;\n+\n+        \/**\n+         * Creates a WildcardString from given string.\n+         * @param pattern   string pattern, like \"some*\"\n+         *\/\n+        public WildcardString(String pattern) {\n+            \/\/ check for the leading '*'\n+            frontWildcarded = pattern.charAt(0) == '*';\n+            pattern = frontWildcarded ? pattern.substring(1) : pattern;\n+\n+            \/\/ check for the trailing '*'\n+            tailWildcarded = pattern.length() > 0 && pattern.charAt(pattern.length() - 1) == '*';\n+            pattern = tailWildcarded ? pattern.substring(0, pattern.length() - 1) : pattern;\n+\n+            this.pattern = pattern;\n+        }\n+\n+        \/**\n+         * Returns true it this WildcardString matches given other string.\n+         * @param other the string that this WildcardString should be matched against\n+         * @return      true in case of a match.\n+         *\/\n+        public boolean matches(String other) {\n+            boolean result = pattern.equals(other);\n+            result |= frontWildcarded ? other.endsWith(pattern) : result;\n+            result |= tailWildcarded ? other.startsWith(pattern) : result;\n+            result |= tailWildcarded && frontWildcarded ? other.contains(pattern) : result;\n+            return result;\n+        }\n+    }\n+\n+    private static final Pattern METHOD_PATTERN = Pattern.compile(generateMethodPattern());\n+\n+    private final WildcardString klassName;\n+    private final WildcardString methodName;\n+    private final Optional<List<Class<?>>> signature;\n+\n+    private MethodTemplate(String klassName, String methodName, Optional<List<Class<?>>> signature) {\n+        this.klassName = new WildcardString(klassName);\n+        this.methodName = new WildcardString(methodName);\n+        this.signature = signature;\n+    }\n+\n+    private static String generateMethodPattern() {\n+        \/\/ Sample valid template(s):    java\/lang\/String::indexOf(Ljava\/lang\/String;I)\n+        \/\/                              java\/lang\/::*(Ljava\/lang\/String;I)\n+        \/\/                              *String::indexOf(*)\n+        \/\/                              java\/lang\/*::indexOf\n+\n+        String primitiveType = \"[ZBSCIJFD]\";        \/\/ Simply a letter, like 'I'\n+        String referenceType = \"L[\\\\w\/$]+;\";        \/\/ Like 'Ljava\/lang\/String;'\n+        String primOrRefType =\n+            \"\\\\[?\" + primitiveType +                \/\/ Bracket is optional: '[Z', or 'Z'\n+            \"|\" +\n+            \"\\\\[?\" + referenceType;                 \/\/ Bracket is optional: '[LSomeObject;' or 'LSomeObject;'\n+        String argTypesOrWildcard = \"(\" +           \/\/ Method argument(s) Ljava\/lang\/String;Z...\n+                \"(\" + primOrRefType + \")*\" +\n+            \")|\\\\*\";                                \/\/ .. or a wildcard:\n+\n+        return\n+            \"(?<klassName>[\\\\w\/$]*\\\\*?)\" +          \/\/ Class name, like 'java\/lang\/String'\n+            \"::\" +                                  \/\/ Simply '::'\n+            \"(?<methodName>\\\\*?[\\\\w$]+\\\\*?)\" +      \/\/ method name, 'indexOf''\n+            \"(\\\\((?<argTypes>\" +                    \/\/ Method argument(s) in brackets:\n+                argTypesOrWildcard +                \/\/     (Ljava\/lang\/String;Z) or '*' or nothing\n+            \")\\\\))?\";\n+    }\n+\n+    \/**\n+     * Returns true iff none of the given MethodTemplates matches the given Executable.\n+     *\n+     * @param templates     the collection of templates to check\n+     * @param method        the executable to match the colletions templates\n+     * @return              true if none of the given templates matches the method, false otherwise\n+     *\/\n+    public static boolean noneMatches(Collection<MethodTemplate> templates, Executable method) {\n+        for (MethodTemplate template : templates) {\n+            if (template.matches(method)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns true if this MethodTemplate matches the given Executable.\n+     *\n+     * @param other     the Executable to try to match to\n+     * @return          whether the other matches this MethodTemplate\n+     *\/\n+    public boolean matches(Executable other) {\n+        boolean result = klassName.matches(other.getDeclaringClass().getName());\n+\n+        result &= (other instanceof Constructor)\n+            ? result\n+            : methodName.matches(other.getName());\n+\n+        return result &&\n+            signature.map(Arrays.asList(other.getParameterTypes())::equals)\n+                     .orElse(true);\n+    }\n+\n+    \/**\n+     * Parses the given string and returs a MethodTemplate.\n+     *\n+     * @param methodStr     the string to parse\n+     * @return              created MethodTemplate\n+     *\/\n+    public static MethodTemplate parse(String methodStr) {\n+        Matcher matcher = METHOD_PATTERN.matcher(methodStr);\n+        String msg = String.format(\"Format of the methods exclude input file is incorrect,\"\n+                + \" methodStr \\\"%s\\\" has wrong format\", methodStr);\n+        Asserts.assertTrue(matcher.matches(), msg);\n+\n+        String klassName = matcher.group(\"klassName\").replaceAll(\"\/\", \"\\\\.\");\n+        String methodName = matcher.group(\"methodName\");\n+        Optional<List<Class<?>>> signature = Optional.ofNullable(matcher.group(\"argTypes\"))\n+                                                     .filter(not(\"*\"::equals))\n+                                                     .map(MethodTemplate::parseSignature);\n+        return new MethodTemplate(klassName, methodName, signature);\n+    }\n+\n+    private static List<Class<?>> parseSignature(String signature) {\n+        List<Class<?>> sigClasses = new ArrayList<>();\n+        char typeChar;\n+        boolean isArray;\n+        String klassName;\n+        StringBuilder sb;\n+        StringBuilder arrayDim;\n+        try (StringReader str = new StringReader(signature)) {\n+            int symbol = str.read();\n+            while (symbol != -1) {\n+                typeChar = (char) symbol;\n+                arrayDim = new StringBuilder();\n+                Class<?> primArrayClass = null;\n+                if (typeChar == '[') {\n+                    isArray = true;\n+                    arrayDim.append('[');\n+                    symbol = str.read();\n+                    while (symbol == '[') {\n+                        arrayDim.append('[');\n+                        symbol = str.read();\n+                    }\n+                    typeChar = (char) symbol;\n+                    if (typeChar != 'L') {\n+                        primArrayClass = Class.forName(arrayDim.toString() + typeChar);\n+                    }\n+                } else {\n+                    isArray = false;\n+                }\n+                switch (typeChar) {\n+                    case 'Z':\n+                        sigClasses.add(isArray ? primArrayClass : boolean.class);\n+                        break;\n+                    case 'I':\n+                        sigClasses.add(isArray ? primArrayClass : int.class);\n+                        break;\n+                    case 'J':\n+                        sigClasses.add(isArray ? primArrayClass : long.class);\n+                        break;\n+                    case 'F':\n+                        sigClasses.add(isArray ? primArrayClass : float.class);\n+                        break;\n+                    case 'D':\n+                        sigClasses.add(isArray ? primArrayClass : double.class);\n+                        break;\n+                    case 'B':\n+                        sigClasses.add(isArray ? primArrayClass : byte.class);\n+                        break;\n+                    case 'S':\n+                        sigClasses.add(isArray ? primArrayClass : short.class);\n+                        break;\n+                    case 'C':\n+                        sigClasses.add(isArray ? primArrayClass : char.class);\n+                        break;\n+                    case 'L':\n+                        sb = new StringBuilder();\n+                        symbol = str.read();\n+                        while (symbol != ';') {\n+                            sb.append((char) symbol);\n+                            symbol = str.read();\n+                        }\n+                        klassName = sb.toString().replaceAll(\"\/\", \"\\\\.\");\n+                        if (isArray) {\n+                            klassName = arrayDim.toString() + \"L\" + klassName + \";\";\n+                        }\n+                        Class<?> klass = Class.forName(klassName);\n+                        sigClasses.add(klass);\n+                        break;\n+                    default:\n+                        throw new Error(\"Unknown type \" + typeChar);\n+                }\n+                symbol = str.read();\n+            }\n+        } catch (IOException | ClassNotFoundException ex) {\n+            throw new Error(\"Unexpected exception while parsing exclude methods file\", ex);\n+        }\n+        return sigClasses;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/MethodTemplate.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.io.File;\n@@ -28,1 +27,0 @@\n-import java.io.StringReader;\n@@ -38,2 +36,0 @@\n-import java.util.HashSet;\n-import java.util.LinkedList;\n@@ -41,1 +37,3 @@\n-import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n@@ -47,0 +45,2 @@\n+import static java.util.function.Predicate.not;\n+\n@@ -52,0 +52,2 @@\n+    private List<MethodTemplate> methodsToExclude;\n+\n@@ -54,0 +56,5 @@\n+    private static String trimComment(String source) {\n+        int commentStart = source.indexOf('#');\n+        return commentStart == -1 ? source : source.substring(0, commentStart);\n+    }\n+\n@@ -65,21 +72,15 @@\n-        List<Class<?>> klasses = parseKlasses(klassesFileName);\n-        Set<Executable> methodsToExclude;\n-        if (exMethodsFileName != null && !exMethodsFileName.isEmpty()) {\n-            methodsToExclude = parseMethods(exMethodsFileName);\n-        } else {\n-            methodsToExclude = new HashSet<>();\n-        }\n-        klasses.stream().forEach(klass -> {\n-            TypeKlass typeKlass = (TypeKlass) getType(klass);\n-            if (TypeList.isReferenceType(typeKlass)) {\n-                return;\n-            }\n-            TypeList.add(typeKlass);\n-            Set<Executable> methods = new HashSet<>();\n-            methods.addAll(Arrays.asList(klass.getMethods()));\n-            methods.addAll(Arrays.asList(klass.getConstructors()));\n-            methods.removeAll(methodsToExclude);\n-            methods.stream().forEach(method -> {\n-                if (method.isSynthetic()) {\n-                    return;\n-                }\n+        TypesParser theParser = new TypesParser();\n+        theParser.initMethodsToExclude(exMethodsFileName);\n+        parseKlasses(klassesFileName)\n+            .stream()\n+            .filter(klass -> !TypeList.isReferenceType(getTypeKlass(klass)))\n+            .forEach(theParser::processKlass);\n+    }\n+\n+    private void processKlass(Class<?> klass) {\n+        TypeKlass typeKlass = getTypeKlass(klass);\n+        TypeList.add(typeKlass);\n+        Stream.concat(Arrays.stream(klass.getMethods()), Arrays.stream(klass.getConstructors()))\n+            .filter(not(Executable::isSynthetic))\n+            .filter(method -> MethodTemplate.noneMatches(methodsToExclude, method))\n+            .forEach(method -> {\n@@ -109,2 +110,1 @@\n-                typeKlass.addSymbol(new FunctionInfo(name, typeKlass, returnType, 1, flags,\n-                        paramList));\n+                typeKlass.addSymbol(new FunctionInfo(name, typeKlass, returnType, 1, flags, paramList));\n@@ -112,1 +112,0 @@\n-        });\n@@ -158,0 +157,4 @@\n+    private static TypeKlass getTypeKlass(Class<?> klass) {\n+        return (TypeKlass) getType(klass);\n+    }\n+\n@@ -237,31 +240,3 @@\n-    private static Set<Executable> parseMethods(String methodsFileName) {\n-        Asserts.assertNotNull(methodsFileName, \"Methods exclude input file name is null\");\n-        Asserts.assertFalse(methodsFileName.isEmpty(), \"Methods exclude input file name is empty\");\n-        LinkedList<String> methodNamesList = new LinkedList<>();\n-        Path klassesFilePath = Paths.get(methodsFileName);\n-        try {\n-            Files.lines(klassesFilePath).forEach(line -> {\n-                line = line.trim();\n-                if (line.isEmpty()) {\n-                    return;\n-                }\n-                String msg = String.format(\"Format of the methods exclude input file \\\"%s\\\" is incorrect,\"\n-                        + \" line \\\"%s\\\" has wrong format\", methodsFileName, line);\n-                Asserts.assertTrue(line.matches(\"\\\\w[\\\\w\/$]*::[\\\\w$]+\\\\((\\\\[?[ZBSCIJFD]|\\\\[?L[\\\\w\/$]+;)*\\\\)\"), msg);\n-                methodNamesList.add(line.substring(0, line.length() - 1));\n-            });\n-        } catch (IOException ex) {\n-            throw new Error(\"Error reading exclude method file\", ex);\n-        }\n-        Set<Executable> methodsList = new HashSet<>();\n-        methodNamesList.forEach(methodName -> {\n-            String[] klassAndNameAndSig = methodName.split(\"::\");\n-            String klassName = klassAndNameAndSig[0].replaceAll(\"\/\", \"\\\\.\");\n-            String[] nameAndSig = klassAndNameAndSig[1].split(\"[\\\\(\\\\)]\");\n-            String name = nameAndSig[0];\n-            String signature = \"\";\n-            if (nameAndSig.length > 1) {\n-                signature = nameAndSig[1];\n-            }\n-            Class<?> klass = null;\n-            List<Class<?>> signatureTypes = null;\n+    private void initMethodsToExclude(String methodsFileName) {\n+        if (methodsFileName != null && !methodsFileName.isEmpty()) {\n+            Path methodsFilePath = Paths.get(methodsFileName);\n@@ -269,19 +244,5 @@\n-                klass = Class.forName(klassName);\n-                signatureTypes = parseSignature(signature);\n-            } catch (ClassNotFoundException ex) {\n-                throw new Error(\"Unexpected exception while parsing exclude methods file\", ex);\n-            }\n-            try {\n-                Executable method;\n-                if (name.equals(klass.getSimpleName())) {\n-                    method = klass.getConstructor(signatureTypes.toArray(new Class<?>[0]));\n-                } else {\n-                    method = klass.getMethod(name, signatureTypes.toArray(new Class<?>[0]));\n-                }\n-                methodsList.add(method);\n-            } catch (NoSuchMethodException | SecurityException ex) {\n-                throw new Error(\"Unexpected exception while parsing exclude methods file\", ex);\n-            }\n-        });\n-        return methodsList;\n-    }\n+                methodsToExclude = Files.lines(methodsFilePath)\n+                    \/\/ Cleaning nonimportant parts\n+                    .map(TypesParser::trimComment)\n+                    .map(String::trim)\n+                    .filter(not(String::isEmpty))\n@@ -289,71 +250,5 @@\n-    private static List<Class<?>> parseSignature(String signature) throws ClassNotFoundException {\n-        LinkedList<Class<?>> sigClasses = new LinkedList<>();\n-        char typeChar;\n-        boolean isArray;\n-        String klassName;\n-        StringBuilder sb;\n-        StringBuilder arrayDim;\n-        try (StringReader str = new StringReader(signature)) {\n-            int symbol = str.read();\n-            while (symbol != -1){\n-                typeChar = (char) symbol;\n-                arrayDim = new StringBuilder();\n-                Class<?> primArrayClass = null;\n-                if (typeChar == '[') {\n-                    isArray = true;\n-                    arrayDim.append('[');\n-                    symbol = str.read();\n-                    while (symbol == '['){\n-                        arrayDim.append('[');\n-                        symbol = str.read();\n-                    }\n-                    typeChar = (char) symbol;\n-                    if (typeChar != 'L') {\n-                        primArrayClass = Class.forName(arrayDim.toString() + typeChar);\n-                    }\n-                } else {\n-                    isArray = false;\n-                }\n-                switch (typeChar) {\n-                    case 'Z':\n-                        sigClasses.add(isArray ? primArrayClass : boolean.class);\n-                        break;\n-                    case 'I':\n-                        sigClasses.add(isArray ? primArrayClass : int.class);\n-                        break;\n-                    case 'J':\n-                        sigClasses.add(isArray ? primArrayClass : long.class);\n-                        break;\n-                    case 'F':\n-                        sigClasses.add(isArray ? primArrayClass : float.class);\n-                        break;\n-                    case 'D':\n-                        sigClasses.add(isArray ? primArrayClass : double.class);\n-                        break;\n-                    case 'B':\n-                        sigClasses.add(isArray ? primArrayClass : byte.class);\n-                        break;\n-                    case 'S':\n-                        sigClasses.add(isArray ? primArrayClass : short.class);\n-                        break;\n-                    case 'C':\n-                        sigClasses.add(isArray ? primArrayClass : char.class);\n-                        break;\n-                    case 'L':\n-                        sb = new StringBuilder();\n-                        symbol = str.read();\n-                        while (symbol != ';') {\n-                            sb.append((char) symbol);\n-                            symbol = str.read();\n-                        }\n-                        klassName = sb.toString().replaceAll(\"\/\", \"\\\\.\");\n-                        if (isArray) {\n-                            klassName = arrayDim.toString() + \"L\" + klassName + \";\";\n-                        }\n-                        Class<?> klass = Class.forName(klassName);\n-                        sigClasses.add(klass);\n-                        break;\n-                    default:\n-                        throw new Error(\"Unknown type \" + typeChar);\n-                }\n-                symbol = str.read();\n+                    \/\/ Actual parsing\n+                    .map(MethodTemplate::parse)\n+                    .collect(Collectors.toList());\n+            } catch (IOException ex) {\n+                throw new Error(\"Error reading exclude method file\", ex);\n@@ -361,2 +256,2 @@\n-        } catch (IOException ex) {\n-            throw new Error(\"Unexpected exception while parsing exclude methods file\", ex);\n+        } else {\n+            methodsToExclude = new ArrayList<>();\n@@ -364,1 +259,0 @@\n-        return sigClasses;\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/TypesParser.java","additions":48,"deletions":154,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.jittester;\n+\n+import java.lang.reflect.Executable;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @summary Unit tests for JITTester string method templates\n+ *\n+ * @library \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/testlibrary\/jittester\/src\n+ *\n+ * @run testng jdk.test.lib.jittester.MethodTemplateTest\n+ *\/\n+public class MethodTemplateTest {\n+\n+    @Test\n+    public void testMatchingPatterns() throws NoSuchMethodException {\n+        Tester.forMethod(System.class, \"getenv\", String.class)\n+            .assertMatches(\"java\/lang\/System::getenv(Ljava\/lang\/String;)\")\n+            .assertMatches(\"*::getenv(Ljava\/lang\/String;)\")\n+            .assertMatches(\"java\/lang\/*::getenv(Ljava\/lang\/String;)\")\n+            .assertMatches(\"java\/lang\/System::*env*(Ljava\/lang\/String;)\")\n+            .assertMatches(\"java\/lang\/System::getenv\")\n+            .assertMatches(\"java\/lang\/System::getenv(*)\");\n+\n+        Tester.forCtor(RuntimeException.class, Throwable.class)\n+            .assertMatches(\"java\/lang\/RuntimeException::RuntimeException(Ljava\/lang\/Throwable;)\");\n+\n+        Tester.forMethod(String.class, \"regionMatches\", int.class, String.class, int.class, int.class)\n+            .assertMatches(\"java\/lang\/String::regionMatches(ILjava\/lang\/String;II)\");\n+    }\n+\n+    @Test\n+    public void testNonMatchingPatterns() throws NoSuchMethodException {\n+        Tester.forMethod(String.class, \"regionMatches\", int.class, String.class, int.class, int.class)\n+            .assertDoesNotMatch(\"java\/lang\/String::regionMatches(IIILjava\/lang\/String;)\");\n+\n+        Tester.forMethod(String.class, \"endsWith\", String.class)\n+              .assertDoesNotMatch(\"java\/lang\/String::startsWith(Ljava\/lang\/String;)\");\n+    }\n+\n+    @Test\n+    public void testWildcardStrings() {\n+        assertTrue(new MethodTemplate.WildcardString(\"Torment\")\n+                .matches(\"Torment\"));\n+\n+        assertTrue(new MethodTemplate.WildcardString(\"Torm*\")\n+                .matches(\"Torment\"));\n+\n+        assertTrue(new MethodTemplate.WildcardString(\"*ent\")\n+                .matches(\"Torment\"));\n+\n+        assertTrue(new MethodTemplate.WildcardString(\"*\")\n+                .matches(\"Something\"));\n+\n+        assertTrue(new MethodTemplate.WildcardString(\"**\")\n+                .matches(\"Something\"));\n+\n+        assertTrue(new MethodTemplate.WildcardString(\"*Middle*\")\n+                .matches(\"OnlyMiddleMatches\"));\n+\n+        assertFalse(new MethodTemplate.WildcardString(\"Wrong\")\n+                .matches(\"Correct\"));\n+        assertFalse(new MethodTemplate.WildcardString(\"Joy\")\n+                .matches(\"Joyfull\"));\n+        assertFalse(new MethodTemplate.WildcardString(\"*Torm*\")\n+                .matches(\"Sorrow\"));\n+    }\n+\n+    static final class Tester {\n+        private final Executable executable;\n+\n+        private Tester(Executable executable) {\n+            this.executable = executable;\n+        }\n+\n+        public Tester assertMatches(String stringTemplate) {\n+            MethodTemplate template = MethodTemplate.parse(stringTemplate);\n+            assertTrue(template.matches(executable),\n+                    \"Method '\" + executable + \"' does not match template '\" + stringTemplate + \"'\");\n+            return this;\n+        }\n+\n+        public Tester assertDoesNotMatch(String stringTemplate) {\n+            MethodTemplate template = MethodTemplate.parse(stringTemplate);\n+            assertFalse(template.matches(executable),\n+                    \"Method '\" + executable + \"' erroneously matches template '\" + stringTemplate + \"'\");\n+            return this;\n+        }\n+\n+        public static Tester forMethod(Class klass, String name, Class<?>... arguments)\n+                throws  NoSuchMethodException {\n+            return new Tester(klass.getDeclaredMethod(name, arguments));\n+        }\n+\n+        public static Tester forCtor(Class klass, Class<?>... arguments)\n+                throws  NoSuchMethodException {\n+                return new Tester(klass.getConstructor(arguments));\n+        }\n+    }\n+\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/jittester\/MethodTemplateTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}