{"files":[{"patch":"@@ -569,1 +569,1 @@\n-        var value = findBinding();\n+        Object value = scopedValueBindings().find(this);\n@@ -578,1 +578,4 @@\n-     * {@return {@code true} if this scoped value is bound in the current thread}\n+     * Return the value of the scoped value or NIL if not bound.\n+     * Consult the cache, and only if the value is not found there\n+     * search the list of bindings. Update the cache if the binding\n+     * was found.\n@@ -580,1 +583,1 @@\n-    public boolean isBound() {\n+    private Object findBinding() {\n@@ -585,1 +588,1 @@\n-                return true;\n+                return objects[n + 1];\n@@ -589,1 +592,1 @@\n-                return true;\n+                return objects[n + 1];\n@@ -592,4 +595,4 @@\n-        var value = findBinding();\n-        boolean result = (value != Snapshot.NIL);\n-        if (result)  Cache.put(this, value);\n-        return result;\n+        Object value = scopedValueBindings().find(this);\n+        boolean found = (value != Snapshot.NIL);\n+        if (found)  Cache.put(this, value);\n+        return value;\n@@ -599,1 +602,1 @@\n-     * Return the value of the scoped value or NIL if not bound.\n+     * {@return {@code true} if this scoped value is bound in the current thread}\n@@ -601,3 +604,3 @@\n-    private Object findBinding() {\n-        Object value = scopedValueBindings().find(this);\n-        return value;\n+    public boolean isBound() {\n+        Object obj = findBinding();\n+        return obj != Snapshot.NIL;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopedValue.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import static java.lang.ScopedValue.where;\n@@ -95,0 +96,20 @@\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int thousandUnboundOrElses(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.unbound.orElse(1);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int thousandBoundOrElses(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.sl1.orElse(1);\n+        }\n+        return result;\n+    }\n+\n@@ -130,1 +151,1 @@\n-        return ScopedValue.where(sl1, THE_ANSWER).call(sl1::get);\n+        return where(sl1, THE_ANSWER).call(sl1::get);\n@@ -135,1 +156,1 @@\n-    private static final ScopedValue.Carrier HOLD_42 = ScopedValue.where(sl1, 42);\n+    private static final ScopedValue.Carrier HOLD_42 = where(sl1, 42);\n@@ -216,0 +237,61 @@\n+\n+    \/\/ Test 6: Performance with a large number of bindings\n+    static final long deepCall(ScopedValue<Integer> outer, long n) {\n+        long result = 0;\n+        if (n > 0) {\n+            ScopedValue<Long> sv = ScopedValue.newInstance();\n+            return where(sv, n).call(() -> deepCall(outer, n - 1));\n+        } else {\n+            for (int i = 0; i < 1_000_000; i++) {\n+                result += outer.orElse(12);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public long deepBindingTest1() {\n+        return deepCall(ScopedValuesData.unbound, 1000);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public long deepBindingTest2() {\n+        return deepCall(ScopedValuesData.sl1, 1000);\n+    }\n+\n+\n+    \/\/ Test 7: Performance with a large number of bindings\n+    \/\/ Different from Test 6 in that we recursively build a very long\n+    \/\/ list of Carriers and invoke Carrier.call() only once.\n+    static final long deepCall2(ScopedValue<Integer> outer, ScopedValue.Carrier carrier, long n) {\n+        long result = 0;\n+        if (n > 0) {\n+            ScopedValue<Long> sv = ScopedValue.newInstance();\n+            return deepCall2(outer, carrier.where(sv, n), n - 1);\n+        } else {\n+            result = carrier.call(() -> {\n+                long sum = 0;\n+                for (int i = 0; i < 1_000_000; i++) {\n+                    sum += outer.orElse(12);\n+                }\n+                return sum;\n+            });\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public long deepBindingTest3() {\n+        return deepCall2(ScopedValuesData.unbound, where(ScopedValuesData.sl2,0), 1000);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    public long deepBindingTest4() {\n+        return deepCall2(ScopedValuesData.sl1, where(ScopedValuesData.sl2, 0), 1000);\n+    }\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopedValues.java","additions":84,"deletions":2,"binary":false,"changes":86,"status":"modified"}]}