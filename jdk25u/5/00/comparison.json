{"files":[{"patch":"@@ -5313,36 +5313,0 @@\n-\/**\n- * Multiply 32 bit by 32 bit first loop.\n- *\/\n-void MacroAssembler::multiply_32_x_32_loop(Register x, Register xstart, Register x_xstart,\n-                                           Register y, Register y_idx, Register z,\n-                                           Register carry, Register product,\n-                                           Register idx, Register kdx) {\n-  \/\/ jlong carry, x[], y[], z[];\n-  \/\/ for (int idx=ystart, kdx=ystart+1+xstart; idx >= 0; idx--, kdx--) {\n-  \/\/     long product = y[idx] * x[xstart] + carry;\n-  \/\/     z[kdx] = (int)product;\n-  \/\/     carry = product >>> 32;\n-  \/\/ }\n-  \/\/ z[xstart] = (int)carry;\n-\n-  Label L_first_loop, L_first_loop_exit;\n-  blez(idx, L_first_loop_exit);\n-\n-  shadd(t0, xstart, x, t0, LogBytesPerInt);\n-  lwu(x_xstart, Address(t0, 0));\n-\n-  bind(L_first_loop);\n-  subiw(idx, idx, 1);\n-  shadd(t0, idx, y, t0, LogBytesPerInt);\n-  lwu(y_idx, Address(t0, 0));\n-  mul(product, x_xstart, y_idx);\n-  add(product, product, carry);\n-  srli(carry, product, 32);\n-  subiw(kdx, kdx, 1);\n-  shadd(t0, kdx, z, t0, LogBytesPerInt);\n-  sw(product, Address(t0, 0));\n-  bgtz(idx, L_first_loop);\n-\n-  bind(L_first_loop_exit);\n-}\n-\n@@ -5565,0 +5529,1 @@\n+  const Register jdx = tmp1;\n@@ -5570,2 +5535,1 @@\n-  Label L_multiply_64_x_64_loop, L_done;\n-\n+  Label L_done;\n@@ -5575,61 +5539,0 @@\n-  const Register jdx = tmp1;\n-\n-  if (AvoidUnalignedAccesses) {\n-    int base_offset = arrayOopDesc::base_offset_in_bytes(T_INT);\n-    assert((base_offset % (UseCompactObjectHeaders ? 4 :\n-                           (UseCompressedClassPointers ? 8 : 4))) == 0, \"Must be\");\n-\n-    if ((base_offset % 8) == 0) {\n-      \/\/ multiply_64_x_64_loop emits 8-byte load\/store to access two elements\n-      \/\/ at a time from int arrays x and y. When base_offset is 8 bytes, these\n-      \/\/ accesses are naturally aligned if both xlen and ylen are even numbers.\n-      orr(t0, xlen, ylen);\n-      test_bit(t0, t0, 0);\n-      beqz(t0, L_multiply_64_x_64_loop);\n-    }\n-\n-    Label L_second_loop_unaligned, L_third_loop, L_third_loop_exit;\n-\n-    multiply_32_x_32_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);\n-    shadd(t0, xstart, z, t0, LogBytesPerInt);\n-    sw(carry, Address(t0, 0));\n-\n-    bind(L_second_loop_unaligned);\n-    mv(carry, zr);\n-    mv(jdx, ylen);\n-    subiw(xstart, xstart, 1);\n-    bltz(xstart, L_done);\n-\n-    subi(sp, sp, 2 * wordSize);\n-    sd(z, Address(sp, 0));\n-    sd(zr, Address(sp, wordSize));\n-    shadd(t0, xstart, z, t0, LogBytesPerInt);\n-    addi(z, t0, 4);\n-    shadd(t0, xstart, x, t0, LogBytesPerInt);\n-    lwu(product, Address(t0, 0));\n-\n-    blez(jdx, L_third_loop_exit);\n-\n-    bind(L_third_loop);\n-    subiw(jdx, jdx, 1);\n-    shadd(t0, jdx, y, t0, LogBytesPerInt);\n-    lwu(t0, Address(t0, 0));\n-    mul(t1, t0, product);\n-    add(t0, t1, carry);\n-    shadd(tmp6, jdx, z, t1, LogBytesPerInt);\n-    lwu(t1, Address(tmp6, 0));\n-    add(t0, t0, t1);\n-    sw(t0, Address(tmp6, 0));\n-    srli(carry, t0, 32);\n-    bgtz(jdx, L_third_loop);\n-\n-    bind(L_third_loop_exit);\n-    ld(z, Address(sp, 0));\n-    addi(sp, sp, 2 * wordSize);\n-    shadd(t0, xstart, z, t0, LogBytesPerInt);\n-    sw(carry, Address(t0, 0));\n-\n-    j(L_second_loop_unaligned);\n-  }\n-\n-  bind(L_multiply_64_x_64_loop);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":2,"deletions":99,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -1385,4 +1385,0 @@\n-  void multiply_32_x_32_loop(Register x, Register xstart, Register x_xstart,\n-                             Register y, Register y_idx, Register z,\n-                             Register carry, Register product,\n-                             Register idx, Register kdx);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -328,2 +328,7 @@\n-  if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {\n-    FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, true);\n+  if (!AvoidUnalignedAccesses) {\n+    if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, true);\n+    }\n+  } else if (UseMultiplyToLenIntrinsic) {\n+    warning(\"Intrinsics for BigInteger.multiplyToLen() not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, false);\n@@ -332,2 +337,7 @@\n-  if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {\n-    FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, true);\n+  if (!AvoidUnalignedAccesses) {\n+    if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, true);\n+    }\n+  } else if (UseSquareToLenIntrinsic) {\n+    warning(\"Intrinsics for BigInteger.squareToLen() not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, false);\n@@ -336,2 +346,7 @@\n-  if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {\n-    FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, true);\n+  if (!AvoidUnalignedAccesses) {\n+    if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, true);\n+    }\n+  } else if (UseMontgomeryMultiplyIntrinsic) {\n+    warning(\"Intrinsics for BigInteger.montgomeryMultiply() not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, false);\n@@ -340,2 +355,7 @@\n-  if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {\n-    FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, true);\n+  if (!AvoidUnalignedAccesses) {\n+    if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {\n+      FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, true);\n+    }\n+  } else if (UseMontgomerySquareIntrinsic) {\n+    warning(\"Intrinsics for BigInteger.montgomerySquare() not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, false);\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"}]}