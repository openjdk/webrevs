{"files":[{"patch":"@@ -917,0 +917,11 @@\n+  static uint32_t encode_csrrw(Register Rd, const uint32_t csr, Register Rs1) {\n+    guarantee(is_uimm12(csr), \"csr is invalid\");\n+    uint32_t insn = 0;\n+    patch((address)&insn, 6, 0, 0b1110011);\n+    patch((address)&insn, 14, 12, 0b001);\n+    patch_reg((address)&insn, 7, Rd);\n+    patch_reg((address)&insn, 15, Rs1);\n+    patch((address)&insn, 31, 20, csr);\n+    return insn;\n+  }\n+\n@@ -3696,8 +3707,7 @@\n-#define INSN(NAME)                                                                           \\\n-  void NAME(Register Rd, int32_t imm) {                                                      \\\n-    \/* lui -> c.lui *\/                                                                       \\\n-    if (do_compress() && (Rd != x0 && Rd != x2 && imm != 0 && is_simm18(imm))) {             \\\n-      c_lui(Rd, imm);                                                                        \\\n-      return;                                                                                \\\n-    }                                                                                        \\\n-    _lui(Rd, imm);                                                                           \\\n+  void lui(Register Rd, int32_t imm) {\n+    \/* lui -> c.lui *\/\n+    if (do_compress() && (Rd != x0 && Rd != x2 && imm != 0 && is_simm18(imm))) {\n+      c_lui(Rd, imm);\n+      return;\n+    }\n+    _lui(Rd, imm);\n@@ -3706,3 +3716,0 @@\n-  INSN(lui);\n-\n-#undef INSN\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1357,0 +1357,1 @@\n+  Assembler::IncompressibleScope scope(_masm);\n@@ -1367,0 +1368,1 @@\n+  Assembler::IncompressibleScope scope(_masm);\n@@ -1859,0 +1861,4 @@\n+  Assembler::IncompressibleScope scope(_masm);\n+  \/\/ Post call nops must be natural aligned due to cmodx rules.\n+  align_call(lir_rtcall);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -358,0 +358,2 @@\n+  assert(!in_compressible_scope(), \"Must be\");\n+  assert_alignment(pc());\n@@ -361,5 +363,4 @@\n-  relocate(post_call_nop_Relocation::spec(), [&] {\n-    InlineSkippedInstructionsCounter skipCounter(this);\n-    nop();\n-    li32(zr, 0);\n-  });\n+  relocate(post_call_nop_Relocation::spec());\n+  InlineSkippedInstructionsCounter skipCounter(this);\n+  nop();\n+  li32(zr, 0);\n@@ -5016,1 +5017,1 @@\n-  IncompressibleScope scope(this); \/\/ relocations\n+  assert(!in_compressible_scope(), \"Must be\");\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -370,1 +370,3 @@\n-  return uint_at(0) == 0xc0101073; \/\/ an illegal instruction, 'csrrw x0, time, x0'\n+  \/\/ an illegal instruction, 'csrrw x0, time, x0'\n+  uint32_t encoded = Assembler::encode_csrrw(x0, Assembler::time, x0);\n+  return uint_at(0) == encoded;\n@@ -419,0 +421,2 @@\n+  MacroAssembler::assert_alignment(code_pos);\n+\n@@ -450,0 +454,1 @@\n+  MacroAssembler::assert_alignment(addr_at(4));\n@@ -461,1 +466,5 @@\n-void NativeDeoptInstruction::verify() {\n+bool NativeDeoptInstruction::is_deopt_at(address instr) {\n+  assert(instr != nullptr, \"Must be\");\n+  uint32_t value = Assembler::ld_instr(instr);\n+  uint32_t encoded = Assembler::encode_csrrw(x0, Assembler::instret, x0);\n+  return value == encoded;\n@@ -466,4 +475,3 @@\n-  \/\/ 0xc0201073 encodes CSRRW x0, instret, x0\n-  uint32_t insn = 0xc0201073;\n-  uint32_t *pos = (uint32_t *) code_pos;\n-  *pos = insn;\n+  MacroAssembler::assert_alignment(code_pos);\n+  uint32_t encoded = Assembler::encode_csrrw(x0, Assembler::instret, x0);\n+  Assembler::sd_instr(code_pos, encoded);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -380,8 +380,1 @@\n-  void verify();\n-\n-  static bool is_deopt_at(address instr) {\n-    assert(instr != nullptr, \"\");\n-    uint32_t value = Assembler::ld_instr(instr);\n-    \/\/ 0xc0201073 encodes CSRRW x0, instret, x0\n-    return value == 0xc0201073;\n-  }\n+  static bool is_deopt_at(address instr);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1272,0 +1272,20 @@\n+int CallRuntimeDirectNode::compute_padding(int current_offset) const\n+{\n+  return align_up(current_offset, alignment_required()) - current_offset;\n+}\n+\n+int CallLeafDirectNode::compute_padding(int current_offset) const\n+{\n+  return align_up(current_offset, alignment_required()) - current_offset;\n+}\n+\n+int CallLeafDirectVectorNode::compute_padding(int current_offset) const\n+{\n+  return align_up(current_offset, alignment_required()) - current_offset;\n+}\n+\n+int CallLeafNoFPDirectNode::compute_padding(int current_offset) const\n+{\n+  return align_up(current_offset, alignment_required()) - current_offset;\n+}\n+\n@@ -8172,1 +8192,1 @@\n-  \n+\n@@ -10506,0 +10526,1 @@\n+  ins_alignment(4);\n@@ -10523,0 +10544,1 @@\n+  ins_alignment(4);\n@@ -10540,0 +10562,1 @@\n+  ins_alignment(4);\n@@ -10557,0 +10580,1 @@\n+  ins_alignment(4);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1007,2 +1007,10 @@\n-    \/\/ Make sure the call is patchable\n-    __ align(NativeInstruction::instruction_size);\n+    address call_pc;\n+    {\n+      Assembler::IncompressibleScope scope(masm);\n+      \/\/ Make sure the call is patchable\n+      __ align(NativeInstruction::instruction_size);\n+\n+      call_pc = __ reloc_call(resolve);\n+      if (call_pc == nullptr) {\n+        fatal(\"CodeCache is full at gen_continuation_enter\");\n+      }\n@@ -1010,3 +1018,2 @@\n-    const address tr_call = __ reloc_call(resolve);\n-    if (tr_call == nullptr) {\n-      fatal(\"CodeCache is full at gen_continuation_enter\");\n+      oop_maps->add_gc_map(__ pc() - start, map);\n+      __ post_call_nop();\n@@ -1014,4 +1021,0 @@\n-\n-    oop_maps->add_gc_map(__ pc() - start, map);\n-    __ post_call_nop();\n-\n@@ -1020,1 +1023,1 @@\n-    address stub = CompiledDirectCall::emit_to_interp_stub(masm, tr_call);\n+    address stub = CompiledDirectCall::emit_to_interp_stub(masm, call_pc);\n@@ -1039,2 +1042,5 @@\n-  \/\/ Make sure the call is patchable\n-  __ align(NativeInstruction::instruction_size);\n+  address call_pc;\n+  {\n+    Assembler::IncompressibleScope scope(masm);\n+    \/\/ Make sure the call is patchable\n+    __ align(NativeInstruction::instruction_size);\n@@ -1042,4 +1048,4 @@\n-  const address tr_call = __ reloc_call(resolve);\n-  if (tr_call == nullptr) {\n-    fatal(\"CodeCache is full at gen_continuation_enter\");\n-  }\n+    call_pc = __ reloc_call(resolve);\n+    if (call_pc == nullptr) {\n+      fatal(\"CodeCache is full at gen_continuation_enter\");\n+    }\n@@ -1047,2 +1053,3 @@\n-  oop_maps->add_gc_map(__ pc() - start, map);\n-  __ post_call_nop();\n+    oop_maps->add_gc_map(__ pc() - start, map);\n+    __ post_call_nop();\n+  }\n@@ -1054,5 +1061,11 @@\n-  ContinuationEntry::_thaw_call_pc_offset = __ pc() - start;\n-  __ rt_call(CAST_FROM_FN_PTR(address, StubRoutines::cont_thaw()));\n-  oop_maps->add_gc_map(__ pc() - start, map->deep_copy());\n-  ContinuationEntry::_return_pc_offset = __ pc() - start;\n-  __ post_call_nop();\n+  \/\/ Post call nops must be natural aligned due to cmodx rules.\n+  {\n+    Assembler::IncompressibleScope scope(masm);\n+    __ align(NativeInstruction::instruction_size);\n+\n+    ContinuationEntry::_thaw_call_pc_offset = __ pc() - start;\n+    __ rt_call(CAST_FROM_FN_PTR(address, StubRoutines::cont_thaw()));\n+    oop_maps->add_gc_map(__ pc() - start, map->deep_copy());\n+    ContinuationEntry::_return_pc_offset = __ pc() - start;\n+    __ post_call_nop();\n+  }\n@@ -1087,1 +1100,1 @@\n-  address stub = CompiledDirectCall::emit_to_interp_stub(masm, tr_call);\n+  address stub = CompiledDirectCall::emit_to_interp_stub(masm, call_pc);\n@@ -1120,0 +1133,3 @@\n+  \/\/ Post call nops must be natural aligned due to cmodx rules.\n+  __ align(NativeInstruction::instruction_size);\n+\n@@ -1123,1 +1139,4 @@\n-  __ post_call_nop(); \/\/ this must be exactly after the pc value that is pushed into the frame info, we use this nop for fast CodeBlob lookup\n+  {\n+    Assembler::IncompressibleScope scope(masm);\n+    __ post_call_nop(); \/\/ this must be exactly after the pc value that is pushed into the frame info, we use this nop for fast CodeBlob lookup\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":44,"deletions":25,"binary":false,"changes":69,"status":"modified"}]}