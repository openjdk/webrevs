{"files":[{"patch":"@@ -1827,0 +1827,11 @@\n+\n+#ifdef ASSERT\n+void InterpreterMacroAssembler::verify_field_offset(Register reg) {\n+  \/\/ Verify the field offset is not in the header, implicitly checks for 0\n+  Label L;\n+  subs(zr, reg, oopDesc::base_offset_in_bytes());\n+  br(Assembler::GE, L);\n+  stop(\"bad field offset\");\n+  bind(L);\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -322,0 +322,2 @@\n+\n+  void verify_field_offset(Register reg) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+  assert_different_registers(bc_reg, temp_reg);\n@@ -234,3 +235,6 @@\n-\n-  \/\/ patch bytecode\n-  __ strb(bc_reg, at_bcp(0));\n+  \/\/ Patch bytecode with release store to coordinate with ResolvedFieldEntry loads\n+  \/\/ in fast bytecode codelets. load_field_entry has a memory barrier that gains\n+  \/\/ the needed ordering, together with control dependency on entering the fast codelet\n+  \/\/ itself.\n+  __ lea(temp_reg, at_bcp(0));\n+  __ stlrb(bc_reg, temp_reg);\n@@ -3085,0 +3089,1 @@\n+  __ verify_field_offset(r1);\n@@ -3174,0 +3179,2 @@\n+  __ verify_field_offset(r1);\n+\n@@ -3240,0 +3247,1 @@\n+\n@@ -3241,0 +3249,1 @@\n+  __ verify_field_offset(r1);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"}]}