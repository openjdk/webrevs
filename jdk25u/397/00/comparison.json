{"files":[{"patch":"@@ -209,0 +209,1 @@\n+  DEBUG_ONLY(volatile bool _out_of_stack_walking_enabled = true;)\n@@ -255,0 +256,6 @@\n+\n+  #ifdef ASSERT\n+  void set_out_of_stack_walking_enabled(bool runnable) {\n+    AtomicAccess::release_store(&_out_of_stack_walking_enabled, runnable);\n+  }\n+  #endif\n@@ -357,4 +364,5 @@\n-\n-    if (Atomic::cmpxchg(&_is_async_processing_of_cpu_time_jfr_requests_triggered, true, false)) {\n-      stackwalk_threads_in_native();\n-    }\n+    DEBUG_ONLY(if (AtomicAccess::load_acquire(&_out_of_stack_walking_enabled)) {)\n+      if (AtomicAccess::cmpxchg(&_is_async_processing_of_cpu_time_jfr_requests_triggered, true, false)) {\n+        stackwalk_threads_in_native();\n+      }\n+    DEBUG_ONLY(})\n@@ -550,0 +558,11 @@\n+#ifdef ASSERT\n+bool JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(bool runnable) {\n+  if (_instance != nullptr && _instance->_sampler != nullptr) {\n+    _instance->_sampler->set_out_of_stack_walking_enabled(runnable);\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+#endif\n+\n@@ -818,0 +837,7 @@\n+#ifdef ASSERT\n+bool JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(bool runnable) {\n+  warn();\n+  return false;\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -133,0 +133,2 @@\n+\n+  DEBUG_ONLY(static bool set_out_of_stack_walking_enabled(bool runnable);)\n@@ -153,0 +155,4 @@\n+<<<<<<< HEAD\n+=======\n+  DEBUG_ONLY(static bool set_out_of_stack_walking_enabled(bool runnable));\n+>>>>>>> d27649fe22a (8367302: New test jdk\/jfr\/event\/profiling\/TestCPUTimeSampleQueueAutoSizes.java from JDK-8366082 is failing)\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2686,0 +2686,17 @@\n+WB_ENTRY(void, WB_BusyWaitCPUTime(JNIEnv* env, jobject wb, jint time))\n+  ThreadToNativeFromVM  ttn(thread);\n+  u8 start = os::current_thread_cpu_time();\n+  u8 target_duration = time * (u8)1000000;\n+  while (os::current_thread_cpu_time() - start < target_duration) {\n+    for (volatile int i = 0; i < 1000000; i++);\n+  }\n+WB_END\n+\n+WB_ENTRY(jboolean, WB_CPUSamplerSetOutOfStackWalking(JNIEnv* env, jobject wb, jboolean enable))\n+  #if defined(ASSERT) && INCLUDE_JFR && defined(LINUX)\n+    return JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(enable == JNI_TRUE) ? JNI_TRUE : JNI_FALSE;\n+  #else\n+    return JNI_FALSE;\n+  #endif\n+WB_END\n+\n@@ -3035,0 +3052,2 @@\n+  {CC\"busyWaitCPUTime\", CC\"(I)V\",                     (void*)&WB_BusyWaitCPUTime},\n+  {CC\"cpuSamplerSetOutOfStackWalking\", CC\"(Z)Z\",      (void*)&WB_CPUSamplerSetOutOfStackWalking},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2025 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.stream.Collectors;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.internal.JVM;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\n+\/*\n+ * Tests the sample queues increase in size as needed, when loss is recorded.\n+ *\n+ * The test starts CPU time sampling with a short interval (1ms), disabling\n+ * out-of-stack sample processing for the duration of the test.\n+ * It now runs in native for one second, to cause queue overflows,\n+ * then it comes back into Java to trigger the queue walking.\n+ * Repeats the cycle 5 times and verifies that the loss decreases from the first\n+ * to the last iteration.\n+ * @test\n+ * @requires vm.hasJFR & os.family == \"linux\" & vm.debug & vm.flagless\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @build  jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:StartFlightRecording:dumponexit=true jdk.jfr.event.profiling.TestCPUTimeSampleQueueAutoSizes\n+ *\/\n+public class TestCPUTimeSampleQueueAutoSizes {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    record LossEvent(long relativeTimeMillis, long lostSamples) {}\n+\n+    \/** A data collection from the CPUTimeSampleLost events for the burst thread *\/\n+    static class LossEventCollection {\n+        private final List<LossEvent> events = new ArrayList<>();\n+        private final List<Long> sampleEventsInTimeBox = new ArrayList<>();\n+        private final List<Long> timeBoxEnds = new ArrayList<>();\n+\n+        public synchronized void addEvent(LossEvent event) {\n+            events.add(event);\n+        }\n+\n+        public synchronized List<LossEvent> getSortedEvents() {\n+            return events.stream()\n+                         .sorted(Comparator.comparingLong(e -> e.relativeTimeMillis))\n+                         .collect(Collectors.toList());\n+        }\n+\n+        public synchronized List<LossEvent> getEventsPerTimeBox() {\n+            List<LossEvent> ret = new ArrayList<>();\n+            AtomicLong previousEnd = new AtomicLong(0);\n+            for (Long timeBoxEnd : timeBoxEnds) {\n+                long lostSamples = events.stream()\n+                                          .filter(e -> e.relativeTimeMillis >= previousEnd.get() && e.relativeTimeMillis <= timeBoxEnd)\n+                                          .mapToLong(e -> e.lostSamples)\n+                                          .sum();\n+                ret.add(new LossEvent(previousEnd.get(), lostSamples));\n+                previousEnd.set(timeBoxEnd);\n+            }\n+            return ret;\n+        }\n+\n+        public synchronized void addTimeBoxEnd(long timeBoxEnd, long sampleEvents) {\n+            timeBoxEnds.add(timeBoxEnd);\n+            sampleEventsInTimeBox.add(sampleEvents);\n+        }\n+\n+        public synchronized void print() {\n+            System.out.println(\"Loss event information:\");\n+            for (int i = 0; i < timeBoxEnds.size(); i++) {\n+                System.out.println(\"  Time box end: \" + timeBoxEnds.get(i) + \", sample events: \" + sampleEventsInTimeBox.get(i));\n+            }\n+            for (LossEvent e : events) {\n+                System.out.println(\"  Lost samples event: \" + e.lostSamples + \" at \" + e.relativeTimeMillis);\n+            }\n+            for (LossEvent e : getEventsPerTimeBox()) {\n+                System.out.println(\"  Lost samples in time box ending at \" + e.relativeTimeMillis + \": \" + e.lostSamples);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            \/\/ setup recording\n+            long burstThreadId = Thread.currentThread().threadId();\n+            final long startTimeMillis = Instant.now().toEpochMilli();\n+            LossEventCollection lossEvents = new LossEventCollection();\n+            AtomicLong sampleEventCountInTimeBox = new AtomicLong(0);\n+            rs.enable(EventNames.CPUTimeSample).with(\"throttle\", \"1ms\");\n+            rs.enable(EventNames.CPUTimeSamplesLost);\n+            rs.onEvent(EventNames.CPUTimeSamplesLost, e -> {\n+                if (e.getThread(\"eventThread\").getJavaThreadId() == burstThreadId) {\n+                    long eventTime = e.getStartTime().toEpochMilli();\n+                    long relativeTime = eventTime - startTimeMillis;\n+                    System.out.println(\"Lost samples: \" + e.getLong(\"lostSamples\") + \" at \" + relativeTime + \" start time \" + startTimeMillis);\n+                    lossEvents.addEvent(new LossEvent(relativeTime, e.getLong(\"lostSamples\")));\n+                }\n+            });\n+            rs.onEvent(EventNames.CPUTimeSample, e -> {\n+                if (e.getThread(\"eventThread\").getJavaThreadId() == burstThreadId) {\n+                    sampleEventCountInTimeBox.incrementAndGet();\n+                }\n+            });\n+            rs.startAsync();\n+            \/\/ we disable the out-of-stack walking so that the queue fills up and overflows\n+            \/\/ while we are in native code\n+            disableOutOfStackWalking();\n+\n+\n+            for (int i = 0; i < 5; i++) {\n+                \/\/ run in native for one second\n+                WHITE_BOX.busyWaitCPUTime(1000);\n+                \/\/ going out-of-native at the end of the previous call should have triggered\n+                \/\/ the safepoint handler, thereby also triggering the stack walking and creation\n+                \/\/ of the loss event\n+                WHITE_BOX.forceSafepoint(); \/\/ just to be sure\n+                lossEvents.addTimeBoxEnd(Instant.now().toEpochMilli() - startTimeMillis, sampleEventCountInTimeBox.get());\n+                sampleEventCountInTimeBox.set(0);\n+            }\n+\n+            rs.stop();\n+            rs.close();\n+\n+            enableOutOfStackWalking();\n+\n+            checkThatLossDecreased(lossEvents);\n+        }\n+    }\n+\n+    static void disableOutOfStackWalking() {\n+        Asserts.assertTrue(WHITE_BOX.cpuSamplerSetOutOfStackWalking(false), \"Out-of-stack-walking not supported\");\n+    }\n+\n+    static void enableOutOfStackWalking() {\n+        WHITE_BOX.cpuSamplerSetOutOfStackWalking(true);\n+    }\n+\n+    static void checkThatLossDecreased(LossEventCollection lossEvents) {\n+        lossEvents.print();\n+        List<LossEvent> timeBoxedLosses = lossEvents.getEventsPerTimeBox();\n+        \/\/ check that the last time box has far fewer lost samples than the first\n+        Asserts.assertTrue(timeBoxedLosses.get(timeBoxedLosses.size() - 1).lostSamples <=\n+                           timeBoxedLosses.get(0).lostSamples \/ 2);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleQueueAutoSizes.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -848,0 +848,6 @@\n+  public native void busyWaitCPUTime(int cpuTimeMs);\n+\n+\n+  \/\/ returns true if supported, false if not\n+  public native boolean cpuSamplerSetOutOfStackWalking(boolean enable);\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}